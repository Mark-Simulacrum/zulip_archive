[
    {
        "content": "<p>While working on some SB diagnostics, I realized that I could have Miri emit a diagnostic that identifies allocations which are responsible for a lot of retags. I ran this on the tests for <code>serde-json</code> and got a lot of output that looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>test test_write_object ... note: tracking was triggered\n     |\n     = note: This allocation is particularly busy\n     = note: (no span available)\nhelp: created here\n    --&gt; /tmp/serde_json-1.0.79/src/ser.rs:1752:26\n     |\n1752 |         writer.write_all(b&quot;\\&quot;&quot;)\n     |                          ^^^^^\n\nnote: tracking was triggered\n     |\n     = note: This allocation is particularly busy\n     = note: (no span available)\nhelp: created here\n    --&gt; /tmp/serde_json-1.0.79/src/ser.rs:1944:38\n     |\n1944 |         PrettyFormatter::with_indent(b&quot;  &quot;)\n     |                                      ^^^^^\n</code></pre></div>\n<p>This seems particularly silly. In addition, a program like this consumes unbounded memory even without stacked borrows:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"s\">\"oh dear\"</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I understand why creating a new allocation every time is desirable for CTFE, but I don't see how it's beneficial for Miri. And just thinking over the kinds of errors that are even possible to have on a literal or constant, I feel like it should be possible to cut some corners here but I can't seem to come up with what exactly one would do. Thoughts?</p>",
        "id": 275250366,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647271008
    },
    {
        "content": "<p>What does the MIR look like in those case? I don't see any allocations in the loop example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"s\">\"oh dear\"</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>MIR:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn main() -&gt; () {\n    let mut _0: ();                      // return place in scope 0 at src/main.rs:1:15: 1:15\n\n    bb0: {\n        goto -&gt; bb1;                     // scope 0 at src/main.rs:2:5: 2:24\n    }\n\n    bb1: {\n        goto -&gt; bb1;                     // scope 0 at src/main.rs:2:5: 2:24\n    }\n}\n</code></pre></div>",
        "id": 275259631,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647274488
    },
    {
        "content": "<p>oh wait, the unbounded memory aspect is not in the MIR, but in how miri keeps track of the stack?</p>",
        "id": 275259745,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647274540
    },
    {
        "content": "<p>There are two memory issues.</p>\n<p>One is that in even that trivial example, every loop iteration creates a new allocation. I admit the MIR doesn't seem to line up with that, but if you <code>cargo miri run</code> that program, you can watch the memory usage of the process doubling every so often as the allocation map grows in size. This is probably important for CTFE because in a const eval context, you can't rely on the location of a constant. But since Miri is dealing in runtime semantics, you can rely on string literals being stable. So there could be some sort of caching/interning trick in Miri, perhaps?</p>\n<p>The second aspect is specfic to stacked borrows. Every memory offset in every allocation has a borrow stack, but I think for literals/statics/constants, there is a severely restricted number of things you can do with the allocation. For example, I don't think there is any way to invalidate tags. And without raw pointer tracking, every tag either corresponds to a pointer in which case it can access the whole allocation or it corresponds to a reference which can't be moved anyway. So I feel like stacked borrows (without raw pointer tracking) collapses to just rejecting attempts at mutable access.</p>",
        "id": 275266575,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647277171
    },
    {
        "content": "<blockquote>\n<p>One is that in even that trivial example, every loop iteration creates a new allocation. I admit the MIR doesn't seem to line up with that, but if you cargo miri run that program, you can watch the memory usage of the process doubling every so often as the allocation map grows in size.</p>\n</blockquote>\n<p>I suspect this is because miri tracks somehow the path it traversed between MIR basic blocks. Although I never took a that close look at the code, so this is just pure guesswork :)</p>\n<blockquote>\n<p>The second aspect is specfic to stacked borrows. Every memory offset in every allocation has a borrow stack, but I think for literals/statics/constants, there is a severely restricted number of things you can do with the allocation.</p>\n</blockquote>\n<p>Ah, so instead of just pushing a tag per borrow, it could just increment a counter per borrow if the borrows are identical? (and decrease it when the borrow expires, kind of like <code>Rc</code>/<code>Arc</code>)</p>",
        "id": 275270677,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647278921
    },
    {
        "content": "<p>Without the string literal I see the same MIR from the \"show MIR\" option in the playground, but I do not get memory usage growth with Miri. That's interesting.</p>",
        "id": 275274446,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647280664
    },
    {
        "content": "<p>Hmm, maybe miri uses a different MIR export than the Playground, I don't remember how to get to the other MIR versions, though. I saw some other tools do that (e.g. Prusti).</p>",
        "id": 275275249,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647280980
    },
    {
        "content": "<p>Maybe the string literal isn't removed with <code>-Zmir-opt-level=0</code>?</p>",
        "id": 275275269,
        "sender_full_name": "bjorn3",
        "timestamp": 1647280986
    },
    {
        "content": "<p>Indeed <a href=\"https://rust.godbolt.org/z/oqTGa3cMj\">https://rust.godbolt.org/z/oqTGa3cMj</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_0</span>: <span class=\"p\">();</span><span class=\"w\">                      </span><span class=\"c1\">// return place in scope 0 at /app/example.rs:1:15: 1:15</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_1</span>: <span class=\"o\">!</span><span class=\"p\">;</span><span class=\"w\">                       </span><span class=\"c1\">// in scope 0 at /app/example.rs:2:5: 2:24</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_2</span>: <span class=\"p\">();</span><span class=\"w\">                      </span><span class=\"c1\">// in scope 0 at /app/example.rs:1:1: 3:2</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_3</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">;</span><span class=\"w\">                        </span><span class=\"c1\">// in scope 0 at /app/example.rs:2:12: 2:21</span>\n\n<span class=\"w\">    </span><span class=\"n\">bb0</span>: <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">StorageLive</span><span class=\"p\">(</span><span class=\"n\">_1</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 0 at /app/example.rs:2:5: 2:24</span>\n<span class=\"w\">        </span><span class=\"n\">goto</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">bb1</span><span class=\"p\">;</span><span class=\"w\">                     </span><span class=\"c1\">// scope 0 at /app/example.rs:2:5: 2:24</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">bb1</span>: <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">StorageLive</span><span class=\"p\">(</span><span class=\"n\">_3</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 0 at /app/example.rs:2:12: 2:21</span>\n<span class=\"w\">        </span><span class=\"n\">_3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"s\">\"oh dear\"</span><span class=\"p\">;</span><span class=\"w\">            </span><span class=\"c1\">// scope 0 at /app/example.rs:2:12: 2:21</span>\n<span class=\"w\">        </span><span class=\"n\">StorageDead</span><span class=\"p\">(</span><span class=\"n\">_3</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 0 at /app/example.rs:2:21: 2:22</span>\n<span class=\"w\">        </span><span class=\"n\">_2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\">                   </span><span class=\"c1\">// scope 0 at /app/example.rs:2:10: 2:24</span>\n<span class=\"w\">        </span><span class=\"n\">goto</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">bb1</span><span class=\"p\">;</span><span class=\"w\">                     </span><span class=\"c1\">// scope 0 at /app/example.rs:2:5: 2:24</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275275379,
        "sender_full_name": "bjorn3",
        "timestamp": 1647281041
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I suspect this is because miri tracks somehow the path it traversed between MIR basic blocks. Although I never took a that close look at the code, so this is just pure guesswork :)</p>\n</blockquote>\n<p>Without the string literal I see the same MIR from the \"show MIR\" option in the playground, but I do not get memory usage growth with Miri. That's interesting.</p>\n</blockquote>\n<p>I took a glance at the code to see if miri \"remembers\" the basic blocks it traversed, but I don't see any such logic. It's probably related to the opt level that miri ingests and the borrow stack that keeps growing due to new borrows.</p>",
        "id": 275279375,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647282782
    },
    {
        "content": "<p>I guess what miri is trying to do is: remember all the \"old\" pointers to <code>_3</code> so that it can detect if the loop leaked a pointer and whether it will be accessed after deallocation. Is there a way to also see the lifetimes together with the MIR? Or are these already converted into StorageLive/StorageDead at this point and there is no way to infer that <code>_3</code> could have a static lifetime in this case?</p>",
        "id": 275283077,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647284342
    },
    {
        "content": "<p>This seems to make it worse <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span>  <a href=\"https://rust.godbolt.org/z/rWcejdMeh\">https://rust.godbolt.org/z/rWcejdMeh</a></p>",
        "id": 275285484,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647285428
    },
    {
        "content": "<p>It's probably because that statement in the loop block holds a non-ZST value that it insists on accessing. This also shows a StorageLive/StorageDead but without an access and memory usage stays normal:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275286211,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647285822
    },
    {
        "content": "<p>In theory it should be possible to detect whether a (non-pointer) variable was only written to and never read, maybe in that case it wouldn't need to remember the tag when it goes out of scope, because it was never read and a pointer to its contents was never created, so it can't be accessed after de-allocating (barring any out-of-bounds pointers that were derived from a different allocated object - but those will be detected as such already). This should keep the stack nice and small in the presence of infinite loops!</p>",
        "id": 275287280,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647286437
    },
    {
        "content": "<p>That probably won't help in the <code>serde</code> example that was posted earlier though, there the variable is actually accessed for reading :'(</p>",
        "id": 275287466,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647286546
    },
    {
        "content": "<p>Actually, if miri throws out the unaccessed allocations (i.e. \"unread\") that are entirely within bounds of  the<code>range</code> that is being <a href=\"https://github.com/rust-lang/miri/blob/dce1a1b94fc633ec9f8e5bbf97f55d282795197b/src/stacked_borrows.rs#L594-L606\">deallocated</a>, after calling <code>RangeMap::iter_mut</code> that might still work for the <code>serde</code> example assuming that a <code>move</code> does not count as a <code>memory_read</code>.</p>\n<p>I was trying something along these lines: <a href=\"https://github.com/rust-lang/miri/compare/master...Pointerbender:for-science?expand=1\">https://github.com/rust-lang/miri/compare/master...Pointerbender:for-science?expand=1</a> Tests seem to pass and the memory issue is gone for the \"oh dear\" loop example</p>",
        "id": 275300296,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647292981
    },
    {
        "content": "<p>This is my first time hacking the internals of miri, so I don't know if this idea will hold up to scrutiny, but I could polish it a bit and create a PR if it's viable :)</p>",
        "id": 275300536,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647293142
    },
    {
        "content": "<p>Okay hold up this is kind of making my head spin.</p>\n<p>You're adding code in <code>memory_deallocated</code>. We're deallocating. Shouldn't we or the CTFE memory system be cleaning up all the resources associated with the allocation when it goes away? I suppose the fact that this has any impact at all means we aren't? So if I'm understanding this part correctly (and it's not a part of Miri I know well) I think the right patch here is to call <code>clear</code> or whatnot on everything associated with the allocation inside <code>memory_deallocated</code>.</p>",
        "id": 275305163,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647296066
    },
    {
        "content": "<p>I can't reproduce a memory usage improvement with the above patch. I still get the same memory usage increase pattern, as well as peak memory usage for this test program</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">200_000</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"oh dear\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>/usr/bin/time -v cargo +miri miri run</code> tells me that this uses 604120 kbytes (maximum resident set size), give or take a MB or so.</p>",
        "id": 275307593,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647297674
    },
    {
        "content": "<blockquote>\n<p>Shouldn't we or the CTFE memory system be cleaning up all the resources associated with the allocation when it goes away? I suppose the fact that this has any impact at all means we aren't?</p>\n</blockquote>\n<p>I believe that currently by design miri doesn't clean up the stacks when those go away. I'm not sure what the reason for this is. Maybe this is so that it can detect when de-allocated memory is accessed or maybe it yields better performance if it doesn't have to remove elements from <code>Stacks.stacks: RefCell&lt;RangeMap&lt;Stack&gt;&gt;</code>. </p>\n<p>In theory the <code>Stack</code>s can be removed at the end of a loop iteration if miri can prove that it's corresponding tag was not leaked to \"outside\" of the loop (this includes across FFI boundaries). Merely checking if the Stack was accessed as in the diff I posted is not sufficient and is a too naive approach, as nicely demonstrated with your latest example :)  Here it registers the <code>Stack</code> as accessed due to a mutable borrow being taken out on the iterator every loop iteration and calling <code>.next()</code> on it, and this is what prevents it from being cleaned up in my hacked idea.</p>\n<p>Two more ideas on how to improve on that idea:</p>\n<p>1) Instead of keeping the empty <code>Stack</code> around, we could just always <code>clear</code> it. This would take-away miri's ability to reason about accessing deallocated memory, but the end-result is the same: there exists no valid access tag on the stack (because the stack is missing for the tag).<br>\n2) Do some complex analysis where miri finds the cycles between MIR basic blocks, and once it exits the cycle or restarts the cycle (e.g. go to the next loop iteration), then figure out which tags were not leaked to \"outside\" of the loop and clean those up in order to lower its memory consumption.</p>\n<p>Both ideas would not be great for performance, but idea <a href=\"https://github.com/rust-lang/rust/issues/1\">#1</a> is probably the least impacting. Performance impact for idea <a href=\"https://github.com/rust-lang/rust/issues/1\">#1</a> can be somewhat mitigated with a different data structure backing <code>RangeMap</code>, which does less copying when elements are removed and does not allocate upon every insert.</p>",
        "id": 275349338,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647337134
    },
    {
        "content": "<p>Currently <code>RangeMap</code> is backed by a <code>Vec</code>.</p>",
        "id": 275349386,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647337167
    },
    {
        "content": "<p>Another nice aspect of idea <a href=\"https://github.com/rust-lang/rust/issues/1\">#1</a> is that it doesn't need a <code>was_read</code> field on the <code>Stack</code> struct, which is better for the cache locality properties of <code>Stacks</code> :)</p>",
        "id": 275352893,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647339235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> here is another attempt at idea 1, it seems to work well for your last example too: <a href=\"https://github.com/rust-lang/miri/compare/master...Pointerbender:for-science2?expand=1\">https://github.com/rust-lang/miri/compare/master...Pointerbender:for-science2?expand=1</a></p>",
        "id": 275367568,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647348522
    },
    {
        "content": "<p>I ended up keeping the <code>Vec</code> for now and altering <code>RangeMap::iter_mut</code> to also get rid of empty stacks during the optimistic merging.</p>",
        "id": 275367643,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647348570
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span> The code in the Miri repo isn't responsible for detecting use after free, that's handled by the rest of the interpreter implementation.</p>\n<p>What are you doing to conclude that your changes improve memory usage? I still don't observe an improvement.</p>",
        "id": 275380323,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647354630
    },
    {
        "content": "<p>I'm removing <code>Stack</code> instances from the <code>RangeMap</code> if those <code>Stack</code> are empty (when <code>RangeMap::iter_mut</code> is called). Which example are you running that still gives memory problems? Can you post your output from <code>time -v</code> ?</p>",
        "id": 275380912,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647354927
    },
    {
        "content": "<p>I'm running the same code as before,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">200_000</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"oh dear\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Output is</p>\n<div class=\"codehilite\"><pre><span></span><code>    Command being timed: &quot;cargo +miri miri run&quot;\n    User time (seconds): 17.50\n    System time (seconds): 0.31\n    Percent of CPU this job got: 99%\n    Elapsed (wall clock) time (h:mm:ss or m:ss): 0:17.84\n    Average shared text size (kbytes): 0\n    Average unshared data size (kbytes): 0\n    Average stack size (kbytes): 0\n    Average total size (kbytes): 0\n    Maximum resident set size (kbytes): 610676\n    Average resident set size (kbytes): 0\n    Major (requiring I/O) page faults: 0\n    Minor (reclaiming a frame) page faults: 212202\n    Voluntary context switches: 88\n    Involuntary context switches: 38\n    Swaps: 0\n    File system inputs: 0\n    File system outputs: 120\n    Socket messages sent: 0\n    Socket messages received: 0\n    Signals delivered: 0\n    Page size (bytes): 4096\n    Exit status: 0\n</code></pre></div>",
        "id": 275385388,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647356716
    },
    {
        "content": "<p>Hmm, I'm getting different numbers, but I'm also running it slightly differently (same example though):</p>\n<div class=\"codehilite\"><pre><span></span><code>    Command being timed: &quot;~/git/rust/pointerbender/miri/miri run&quot;\n    User time (seconds): 2.20\n    System time (seconds): 0.72\n    Percent of CPU this job got: 85%\n    Elapsed (wall clock) time (h:mm:ss or m:ss): 0:03.42\n    Average shared text size (kbytes): 0\n    Average unshared data size (kbytes): 0\n    Average stack size (kbytes): 0\n    Average total size (kbytes): 0\n    Maximum resident set size (kbytes): 78712\n    Average resident set size (kbytes): 0\n    Major (requiring I/O) page faults: 1035\n    Minor (reclaiming a frame) page faults: 182814\n    Voluntary context switches: 1936\n    Involuntary context switches: 32\n    Swaps: 0\n    File system inputs: 314528\n    File system outputs: 312\n    Socket messages sent: 0\n    Socket messages received: 0\n    Signals delivered: 0\n    Page size (bytes): 4096\n    Exit status: 0\n</code></pre></div>\n<p>3 seconds seems too short, although maybe it is that much faster with the memory issue gone?</p>",
        "id": 275385785,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647356908
    },
    {
        "content": "<p>Oh wait, I can reproduce your output now with a different command:</p>\n<div class=\"codehilite\"><pre><span></span><code>    Command being timed: &quot;./miri run ../example/src/main.rs&quot;\n    User time (seconds): 24.29\n    System time (seconds): 0.80\n    Percent of CPU this job got: 100%\n    Elapsed (wall clock) time (h:mm:ss or m:ss): 0:25.10\n    Average shared text size (kbytes): 0\n    Average unshared data size (kbytes): 0\n    Average stack size (kbytes): 0\n    Average total size (kbytes): 0\n    Maximum resident set size (kbytes): 616348\n    Average resident set size (kbytes): 0\n    Major (requiring I/O) page faults: 14\n    Minor (reclaiming a frame) page faults: 315733\n    Voluntary context switches: 409\n    Involuntary context switches: 347\n    Swaps: 0\n    File system inputs: 15552\n    File system outputs: 312\n    Socket messages sent: 0\n    Socket messages received: 0\n    Signals delivered: 0\n    Page size (bytes): 4096\n    Exit status: 0\n</code></pre></div>\n<p>Why do I get different results when executing the same binary from different working directories? <span aria-label=\"clown\" class=\"emoji emoji-1f921\" role=\"img\" title=\"clown\">:clown:</span></p>",
        "id": 275387384,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647357601
    },
    {
        "content": "<p>I don't fully know why you're seeing what you're seeing. But if you look into the <code>miri</code> script, it runs <code>rustc --print-sysroot</code> which is set by a toolchain override inside the miri repo from <code>./rustup-toolchain</code>.</p>\n<p>So I think it's a problem to run the <code>miri</code> script from outside of the repo.</p>",
        "id": 275388774,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647358211
    },
    {
        "content": "<p>Does that imply that the memory consumption issue might be related to the toolchain version and not to miri itself?</p>",
        "id": 275390480,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647358909
    },
    {
        "content": "<p>It seems the problem is not due to the empty <code>Stack</code>s sitting in the <code>RangeMap</code> , removing all the empty stacks on every deallocation is not having any effect on the memory usage :'(</p>",
        "id": 275393458,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647360099
    },
    {
        "content": "<p>the toolchain in the other working directory (where the unbounded memory usage is not visible) is this for me btw:</p>\n<div class=\"codehilite\"><pre><span></span><code>active toolchain\n----------------\n\nnightly-x86_64-unknown-linux-gnu (default)\nrustc 1.58.0-nightly (8b09ba6a5 2021-11-09)\n</code></pre></div>",
        "id": 275393943,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647360282
    },
    {
        "content": "<p>do you do shrink_to_fit() or just clear()?</p>",
        "id": 275396104,
        "sender_full_name": "bjorn3",
        "timestamp": 1647361073
    },
    {
        "content": "<p>FWIW, I tried replacing the whole Option&lt;Stacks&gt; with a None upon deallocation by patching the code in src/machine.rs, and saw no improvement in memory use.</p>",
        "id": 275397832,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647361731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/269128-miri/topic/Optimizing.20for.20memory.20usage.20of.20literals.2Fconstants.3F/near/275396104\">said</a>:</p>\n<blockquote>\n<p>do you do shrink_to_fit() or just clear()?</p>\n</blockquote>\n<p>The code I have locally for this is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Clone, Debug)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">RangeMap</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">Elem</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">remove</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">RangeMap</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">clear</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nb\">PartialEq</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">remove</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">retain</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">elem</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">elem</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">remove</span><span class=\"p\">.</span><span class=\"n\">as_ref</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275417084,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647369258
    },
    {
        "content": "<p>And then call that <code>clear</code> method at the end of <code>Stacks::memory_deallocated</code></p>",
        "id": 275417231,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647369319
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Stacks</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">memory_deallocated</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">alloc_id</span>: <span class=\"nc\">AllocId</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">tag</span>: <span class=\"nc\">SbTag</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">range</span>: <span class=\"nc\">AllocRange</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">extra</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">MemoryExtra</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">InterpResult</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">trace</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">\"deallocation with tag {:?}: {:?}, size {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">alloc_id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">range</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">.</span><span class=\"n\">bytes</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">extra</span><span class=\"p\">.</span><span class=\"n\">get_mut</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">for_each_mut</span><span class=\"p\">(</span><span class=\"n\">range</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">offset</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">stack</span><span class=\"p\">.</span><span class=\"n\">dealloc</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Pointer</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">alloc_id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">})</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Cleanup empty stacks...</span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">stacks</span><span class=\"p\">.</span><span class=\"n\">get_mut</span><span class=\"p\">().</span><span class=\"n\">clear</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Ok</span><span class=\"p\">(())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275417317,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647369357
    },
    {
        "content": "<p>Removing elements from a vec doesn't shrink it. You need an explicit <code>.shrink_to_fit()</code> to shrink it.</p>",
        "id": 275417382,
        "sender_full_name": "bjorn3",
        "timestamp": 1647369370
    },
    {
        "content": "<p>Let me try, I was hoping that would be enough to prevent it from growing that large in the first place, will follow up shortly what the result of this is. :)</p>",
        "id": 275417715,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647369509
    },
    {
        "content": "<p>That doesn't seem to make a significant difference  unfortunately (memory usage and execution time are similar still):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"n\">Command</span><span class=\"w\"> </span><span class=\"n\">being</span><span class=\"w\"> </span><span class=\"n\">timed</span>: <span class=\"s\">\"./miri run ../prusti-example/src/main.rs\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">User</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">seconds</span><span class=\"p\">)</span>: <span class=\"mf\">25.00</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">System</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">seconds</span><span class=\"p\">)</span>: <span class=\"mf\">0.97</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Percent</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">CPU</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">job</span><span class=\"w\"> </span><span class=\"n\">got</span>: <span class=\"mi\">99</span><span class=\"o\">%</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Elapsed</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">wall</span><span class=\"w\"> </span><span class=\"n\">clock</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">time</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">h</span>:<span class=\"nc\">mm</span>:<span class=\"nc\">ss</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">m</span>:<span class=\"nc\">ss</span><span class=\"p\">)</span>: <span class=\"mi\">0</span>:<span class=\"mf\">25.98</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Average</span><span class=\"w\"> </span><span class=\"n\">shared</span><span class=\"w\"> </span><span class=\"n\">text</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">kbytes</span><span class=\"p\">)</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Average</span><span class=\"w\"> </span><span class=\"n\">unshared</span><span class=\"w\"> </span><span class=\"n\">data</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">kbytes</span><span class=\"p\">)</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Average</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">kbytes</span><span class=\"p\">)</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Average</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">kbytes</span><span class=\"p\">)</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Maximum</span><span class=\"w\"> </span><span class=\"n\">resident</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">kbytes</span><span class=\"p\">)</span>: <span class=\"mi\">616416</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Average</span><span class=\"w\"> </span><span class=\"n\">resident</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">kbytes</span><span class=\"p\">)</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Major</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">requiring</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">/</span><span class=\"n\">O</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">page</span><span class=\"w\"> </span><span class=\"n\">faults</span>: <span class=\"mi\">2</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Minor</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">reclaiming</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">frame</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"n\">page</span><span class=\"w\"> </span><span class=\"n\">faults</span>: <span class=\"mi\">315753</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Voluntary</span><span class=\"w\"> </span><span class=\"n\">context</span><span class=\"w\"> </span><span class=\"n\">switches</span>: <span class=\"mi\">433</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Involuntary</span><span class=\"w\"> </span><span class=\"n\">context</span><span class=\"w\"> </span><span class=\"n\">switches</span>: <span class=\"mi\">108</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Swaps</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">File</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"n\">inputs</span>: <span class=\"mi\">7720</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">File</span><span class=\"w\"> </span><span class=\"n\">system</span><span class=\"w\"> </span><span class=\"n\">outputs</span>: <span class=\"mi\">312</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Socket</span><span class=\"w\"> </span><span class=\"n\">messages</span><span class=\"w\"> </span><span class=\"n\">sent</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Socket</span><span class=\"w\"> </span><span class=\"n\">messages</span><span class=\"w\"> </span><span class=\"n\">received</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Signals</span><span class=\"w\"> </span><span class=\"n\">delivered</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Page</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">)</span>: <span class=\"mi\">4096</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Exit</span><span class=\"w\"> </span><span class=\"n\">status</span>: <span class=\"mi\">0</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275418182,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647369742
    },
    {
        "content": "<p>Maybe try massif (part of valgrind) to find which functions allocate the most memory?</p>",
        "id": 275418392,
        "sender_full_name": "bjorn3",
        "timestamp": 1647369851
    },
    {
        "content": "<p>Hmm I think the version that comes with my OS distribution is too old, it shows mostly \"xmalloc\" as the culprit :P Compiling the latest valgrind binary results in a non-working binary.</p>",
        "id": 275424763,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647373047
    },
    {
        "content": "<p>I will fiddle some more tomorrow to see if I can get a proper version of valgrind installed</p>",
        "id": 275425611,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647373447
    },
    {
        "content": "<p>(or if anyone already has it installed and beats me to it that's fine too :) )</p>",
        "id": 275425671,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647373484
    },
    {
        "content": "<p>Does it show any backtraces?</p>",
        "id": 275429605,
        "sender_full_name": "bjorn3",
        "timestamp": 1647375403
    },
    {
        "content": "<p>It does, but something seems off, it only shows ~72kb of heap usage in total, while <code>time -v</code> suggests 9 times as much. I don't think it's showing the full picture on my version:<br>\n<a href=\"/user_uploads/4715/ghS2O4GoMqbj_mDYrgD41hXG/Screenshot_2022-03-15_21-32-02.png\">Screenshot_2022-03-15_21-32-02.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/ghS2O4GoMqbj_mDYrgD41hXG/Screenshot_2022-03-15_21-32-02.png\" title=\"Screenshot_2022-03-15_21-32-02.png\"><img src=\"/user_uploads/4715/ghS2O4GoMqbj_mDYrgD41hXG/Screenshot_2022-03-15_21-32-02.png\"></a></div>",
        "id": 275431331,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647376367
    },
    {
        "content": "<p>I bet that's a profile of the bash process running the <code>miri</code> script</p>",
        "id": 275431456,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647376434
    },
    {
        "content": "<p>Yeah, the backtrace lists bash, not miri.</p>",
        "id": 275431588,
        "sender_full_name": "bjorn3",
        "timestamp": 1647376483
    },
    {
        "content": "<p>massif produces 3 different files that all seem to contain data about the bash process</p>",
        "id": 275431942,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647376639
    },
    {
        "content": "<p>Gonna try if i can hack the bash file to call valgrind from there :D</p>",
        "id": 275432672,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377039
    },
    {
        "content": "<p>hmm it ran but with an error and no output files:</p>\n<div class=\"codehilite\"><pre><span></span><code>--11993-- WARNING: unhandled amd64-linux syscall: 332\n--11993-- You may be able to write your own handler.\n--11993-- Read the file README_MISSING_SYSCALL_OR_IOCTL.\n--11993-- Nevertheless we consider this a bug.  Please report\n--11993-- it at http://valgrind.org/support/bug_reports.html.\n</code></pre></div>",
        "id": 275432985,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377187
    },
    {
        "content": "<p>Going to try heaptrack instead</p>",
        "id": 275433193,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377290
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/hJlizToYGYEAl4HqkOchIiIv/Screenshot_2022-03-15_21-51-02.png\">Screenshot_2022-03-15_21-51-02.png</a> <a href=\"/user_uploads/4715/4Ya2t2KfBdGYmpS2QYJJnkwD/Screenshot_2022-03-15_21-50-20.png\">Screenshot_2022-03-15_21-50-20.png</a> </p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/hJlizToYGYEAl4HqkOchIiIv/Screenshot_2022-03-15_21-51-02.png\" title=\"Screenshot_2022-03-15_21-51-02.png\"><img src=\"/user_uploads/4715/hJlizToYGYEAl4HqkOchIiIv/Screenshot_2022-03-15_21-51-02.png\"></a></div><div class=\"message_inline_image\"><a href=\"/user_uploads/4715/4Ya2t2KfBdGYmpS2QYJJnkwD/Screenshot_2022-03-15_21-50-20.png\" title=\"Screenshot_2022-03-15_21-50-20.png\"><img src=\"/user_uploads/4715/4Ya2t2KfBdGYmpS2QYJJnkwD/Screenshot_2022-03-15_21-50-20.png\"></a></div><p>Now we're getting somewhere :)</p>",
        "id": 275433628,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377538
    },
    {
        "content": "<p>regex, interesting!</p>",
        "id": 275433642,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377549
    },
    {
        "content": "<p>that looks like a profile for the rustup wrapper for miri, not miri itself</p>",
        "id": 275433924,
        "sender_full_name": "simulacrum",
        "timestamp": 1647377709
    },
    {
        "content": "<p>hmmm, in the <code>miri</code> bash script I updated the command to <code>exec heaptrack cargo run $CARGO_BUILD_FLAGS -- --sysroot \"$MIRI_SYSROOT\" \"$@\"</code></p>",
        "id": 275434070,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377798
    },
    {
        "content": "<p>Might you have any tips for what I could put there instead to directly call miri with all the right flags and env variables? :)</p>",
        "id": 275434132,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377838
    },
    {
        "content": "<p>Hmm there is a way to attach it to an already running process, let me see if I can grab it that way.</p>",
        "id": 275434370,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647377977
    },
    {
        "content": "<p>I would probably add some -vv flags to Cargo and try to get the final thing it runs (full command) and then copy/paste that</p>",
        "id": 275434408,
        "sender_full_name": "simulacrum",
        "timestamp": 1647377998
    },
    {
        "content": "<p>that worked, thanks :) going to run it again on the master branch to be sure none of my local hacks are getting in the way, one sec</p>",
        "id": 275436691,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647379088
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/11tVA-BNkKHoIb_lvNpuDvjx/Screenshot_2022-03-15_22-29-24.png\">Screenshot_2022-03-15_22-29-24.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/11tVA-BNkKHoIb_lvNpuDvjx/Screenshot_2022-03-15_22-29-24.png\" title=\"Screenshot_2022-03-15_22-29-24.png\"><img src=\"/user_uploads/4715/11tVA-BNkKHoIb_lvNpuDvjx/Screenshot_2022-03-15_22-29-24.png\"></a></div>",
        "id": 275438050,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647379780
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/hRnadiK7Dam2ArZ-3K8oRTxg/Screenshot_2022-03-15_22-30-43.png\">Screenshot_2022-03-15_22-30-43.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/hRnadiK7Dam2ArZ-3K8oRTxg/Screenshot_2022-03-15_22-30-43.png\" title=\"Screenshot_2022-03-15_22-30-43.png\"><img src=\"/user_uploads/4715/hRnadiK7Dam2ArZ-3K8oRTxg/Screenshot_2022-03-15_22-30-43.png\"></a></div>",
        "id": 275438228,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647379855
    },
    {
        "content": "<p><code>retag_return_place</code> has the most allocations</p>",
        "id": 275438349,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647379920
    },
    {
        "content": "<p>and here is the flame graph for peak memory usage:</p>",
        "id": 275438399,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647379932
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/vrJpzhHoV8VE6I3ZHXTFY-a9/Screenshot_2022-03-15_22-32-25.png\">Screenshot_2022-03-15_22-32-25.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/vrJpzhHoV8VE6I3ZHXTFY-a9/Screenshot_2022-03-15_22-32-25.png\" title=\"Screenshot_2022-03-15_22-32-25.png\"><img src=\"/user_uploads/4715/vrJpzhHoV8VE6I3ZHXTFY-a9/Screenshot_2022-03-15_22-32-25.png\"></a></div>",
        "id": 275438445,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647379958
    },
    {
        "content": "<p>about ~45% of peak memory  usage comes from the <code>stacked_borrows</code> module</p>",
        "id": 275438697,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647380079
    },
    {
        "content": "<p><code>Stacks::new_allocation</code> (14.4%) and <code>EvalContextExt::retag</code> (29.4%) being the biggest</p>",
        "id": 275438896,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647380164
    },
    {
        "content": "<p>the <code>rustc_const_eval::interpret::eval_context::InterpCx::eval_rvalue_into_place</code> method is called quite a lot, too (whenever it does the assignment inside the loop I think)</p>",
        "id": 275443158,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647382649
    },
    {
        "content": "<p><code>rustc_const_eval</code> might be the place to make an optimization for the memory issues it looks like <span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> , if it can do less allocations and deallocations there, then stacked borrows will automatically benefit from that as well in terms of memory usage. The memory usage seems roughly split down the middle between that crate and stacked borrows (which is called by <code>rustc_const_eval</code>).</p>",
        "id": 275443432,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647382871
    },
    {
        "content": "<p>Hopefully such an optimization is possible for const literals :)</p>",
        "id": 275443673,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647383048
    },
    {
        "content": "<p>Yeah, this is what I was trying to call out originally. It's really comforting that your data lines up with what I suspected from just some gdb prodding.</p>\n<p>I think we get so many allocations here because in a <code>const fn</code> you can't rely on accessing the same string literal twice and getting the same address for it. If you could rely on that, there could be only a single allocation created in the const eval code for this string literal, and then it could be interned or... something. But Miri is modeling runtime semantics, so it doesn't have any particular reason to make a new allocation every time.</p>",
        "id": 275443924,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647383215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span>  Is there a file or something you can upload so I can look at your results? I've failed completely to operate <code>massif</code> every time I've tried, and I really want to see what is in some of those thinner flames that mention stacked borrows.</p>",
        "id": 275443997,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647383278
    },
    {
        "content": "<p>Sure! Will PM it to you, one sec</p>",
        "id": 275444479,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647383522
    },
    {
        "content": "<p>Even if miri/stacked borrows could deduplicate the literals it gets from <code>rustc_const_eval</code> this would only cut memory usage roughly in half, the space complexity will stay the same, unless this is fully addressed in <code>rustc_const_eval</code> somehow :'(</p>",
        "id": 275444800,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647383759
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/beta/nightly-rustc/rustc_const_eval/interpret/eval_context/struct.InterpCx.html#method.deallocate_local\">deallocate_local</a> from the <code>rustc_const_eval</code> crate also takes ~45% of the peak memory usage, this part never goes into miri as far as I can tell.</p>",
        "id": 275444961,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647383855
    },
    {
        "content": "<p>Or maybe it does through a couple of trait indirections that have associated types that miri implements through the <code>Machine</code> trait, not sure now...</p>",
        "id": 275445521,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647384153
    },
    {
        "content": "<p>Oh right, <code>&lt;Evaluator as Machine&gt;::memory_deallocated</code> is marked as <code>#[inline(always)]</code>, so I guess this one doesn't show up in the flamegraph because of that.</p>",
        "id": 275503218,
        "sender_full_name": "Pointerbender",
        "timestamp": 1647433661
    },
    {
        "content": "<p>wow a lot of theories here^^ but also many things are not quite matching how Miri works. miri doesn't keep track of a \"trace\" of how we got to the current BB, and it does deallocate stack locals when the function returns.<br>\nMiri however <em>does</em> keep track of the size and alignment of allocations that have been deallocated. is that the map that is blowing up here?<br>\nas for constants, there is indeed a new AllocId each time a constant is copied, so that is more likely the issue here with that <code>loop { \"string\" }</code> example.</p>",
        "id": 275533425,
        "sender_full_name": "RalfJ",
        "timestamp": 1647446589
    },
    {
        "content": "<p>but when an allocation is removed, we do deallocate the stacked borrows data for it, so I doubt explicitly clearing/shrinking the rangemap will help</p>",
        "id": 275533704,
        "sender_full_name": "RalfJ",
        "timestamp": 1647446670
    },
    {
        "content": "<blockquote>\n<p>I think we get so many allocations here because in a const fn you can't rely on accessing the same string literal twice and getting the same address for it. If you could rely on that, there could be only a single allocation created in the const eval code for this string literal, and then it could be interned or... something. But Miri is modeling runtime semantics, so it doesn't have any particular reason to make a new allocation every time.</p>\n</blockquote>\n<p>basically, yes, except that the runtime semantics of Rust are <em>also</em> to make a new copy of that const each time. we just dont guarantee unique addresses, so rustc deduplicates most of those allocations (but with generic associated consts across crate boundaries, duplicates can remain).</p>",
        "id": 275533921,
        "sender_full_name": "RalfJ",
        "timestamp": 1647446750
    },
    {
        "content": "<p>miri currently does no deduplication for constants. it does perform deduplication for vtables though.</p>",
        "id": 275534120,
        "sender_full_name": "RalfJ",
        "timestamp": 1647446816
    },
    {
        "content": "<p>we could possibly also do this for constants, but is this really a problem in real code? <code>loop {\"string\" }</code> does not look realistic^^.<br>\nlooking at the code that started the thread, the issue there was a single allocation being very \"busy\" (in terms of SB I assume). deduplication constants will not change that, it will just make that one allocation even more busy.</p>",
        "id": 275534484,
        "sender_full_name": "RalfJ",
        "timestamp": 1647446919
    },
    {
        "content": "<p>Yeah sorry for being a bit vague. I've been having a lot of fun hacking some stuff together in Miri recently.</p>\n<p>My concern is twofold. First, I thought it might be nice to do allocation deduplication. But I didn't have a whole lot of hopes for that because of where allocations are handled, and you've also explained that it's not possible at all, semantically. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n<p>(my \"is busy\" diagnostic was a very crude way to visualize what parts of code are responsible for tag creation, my concern there is what kinds of code are producing a lot of tags)</p>\n<p>My second concern is that in the implementation of stacked borrows inside Miri, we are using memory to store a borrow stack whose state isn't observable. For example, a length-1 string literal. Are there multiple meaningful states for the borrow stack of that allocation? It's only valid for reads, so doesn't checking stacked borrows simplify to just rejecting writes?</p>",
        "id": 275537093,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647447781
    },
    {
        "content": "<blockquote>\n<p>My concern is twofold. First, I thought it might be nice to do allocation deduplication. But I didn't have a whole lot of hopes for that because of where allocations are handled, and you've also explained that it's not possible at all, semantically. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> </p>\n</blockquote>\n<p>I think for constants it would be possible with a cache similar to vtables. I am not sure if we want that though. ideally we'd randomize this with the seed so we can find code that relies on address identity either way...</p>",
        "id": 275595055,
        "sender_full_name": "RalfJ",
        "timestamp": 1647477473
    },
    {
        "content": "<blockquote>\n<p>My second concern is that in the implementation of stacked borrows inside Miri, we are using memory to store a borrow stack whose state isn't observable. For example, a length-1 string literal. Are there multiple meaningful states for the borrow stack of that allocation? It's only valid for reads, so doesn't checking stacked borrows simplify to just rejecting writes?</p>\n</blockquote>\n<p>SB still also checks that the pointer is allowed to do the read -- if it has the wrong tag (a tag not in the borrow stack), the read is rejected</p>",
        "id": 275595121,
        "sender_full_name": "RalfJ",
        "timestamp": 1647477509
    },
    {
        "content": "<p>Yes, but how does one end up with the wrong tag? I feel like you'd have to do one of</p>\n<ul>\n<li>Get a pointer that's from another allocation, which is rejected before you get into the stack checking part</li>\n<li>Use an invalidated a pointer, which I think is impossible for string literals because you can't be granted Unique</li>\n<li>In stacked borrows with raw pointer tagging, attempt to use an untagged pointer, but that again doesn't require touching the borrow stack</li>\n</ul>",
        "id": 275595909,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647478327
    },
    {
        "content": "<p>oh you mean for 1-byte allocations the AllocId already basically suffices... maybe? I agree there is some redundancy between SB tag and AllocId, but conceptually I think it is the AllocId that should be removed (but that will likely not be feasible to implement)</p>",
        "id": 275596973,
        "sender_full_name": "RalfJ",
        "timestamp": 1647479398
    },
    {
        "content": "<p>With raw pointer tagging, I think we can avoid touching the borrow stack for things for 1-byte constants.</p>\n<p>But without raw pointer tagging I think we can avoid touching the borrow stack for all operations on constants which are based on an Untagged pointer, regardless of size. The base tag always grants SRO, and only reads are possible.</p>",
        "id": 275597775,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647480257
    },
    {
        "content": "<p>To be clear here, I don't want to suggest that I think this would address the memory blowup problems that Miri has in general. I'm pretty sure some of the catastrophic memory growth we see is fundamental to Stacked Borrows. But it might be nice to have a nice chunk off here and there.</p>",
        "id": 275597835,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647480356
    },
    {
        "content": "<p>I am not sure it is worth special-casing 1-byte allocations</p>",
        "id": 275598922,
        "sender_full_name": "RalfJ",
        "timestamp": 1647481617
    }
]