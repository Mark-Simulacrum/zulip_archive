[
    {
        "content": "<p>I'm trying to implement an allocator and test it with Miri. I kept getting an error, which I've minimized to the following example on the <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8a7ed5210f6aa3907ded0199b57213af\">playground</a>. This allocator simply rounds (aligns) the requested size up to the next multiple of 16, then calls the <code>System</code> allocator. The <code>NonNull&lt;[u8]&gt;</code> returned by <code>allocate</code> has the aligned-up length that <code>System.allocate</code> was called with. <code>System.deallocate</code> is also called with the aligned-up length. I believe this doesn't break the requirements of the allocator API?</p>\n<p>When dropping a vec-turned-into-boxed-slice, I get this error:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">Undefined</span><span class=\"w\"> </span><span class=\"n\">Behavior</span>: <span class=\"nc\">no</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"n\">granting</span><span class=\"w\"> </span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">deallocation</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"mi\">111752</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">alloc32471</span><span class=\"o\">+</span><span class=\"mh\">0x4</span><span class=\"w\"> </span><span class=\"n\">found</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">borrow</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"o\">/</span><span class=\"n\">playground</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"n\">rustup</span><span class=\"o\">/</span><span class=\"n\">toolchains</span><span class=\"o\">/</span><span class=\"n\">nightly</span><span class=\"o\">-</span><span class=\"n\">x86_64</span><span class=\"o\">-</span><span class=\"n\">unknown</span><span class=\"o\">-</span><span class=\"n\">linux</span><span class=\"o\">-</span><span class=\"n\">gnu</span><span class=\"o\">/</span><span class=\"n\">lib</span><span class=\"o\">/</span><span class=\"n\">rustlib</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rust</span><span class=\"o\">/</span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">std</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">sys</span><span class=\"o\">/</span><span class=\"n\">unix</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">42</span>:<span class=\"mi\">9</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">         </span><span class=\"n\">libc</span>::<span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">libc</span>::<span class=\"n\">c_void</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\">         </span><span class=\"o\">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class=\"w\"> </span><span class=\"n\">no</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"n\">granting</span><span class=\"w\"> </span><span class=\"n\">write</span><span class=\"w\"> </span><span class=\"n\">access</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">deallocation</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"mi\">111752</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">alloc32471</span><span class=\"o\">+</span><span class=\"mh\">0x4</span><span class=\"w\"> </span><span class=\"n\">found</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">borrow</span><span class=\"w\"> </span><span class=\"n\">stack</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">help</span>: <span class=\"nc\">this</span><span class=\"w\"> </span><span class=\"n\">indicates</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">potential</span><span class=\"w\"> </span><span class=\"n\">bug</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">program</span>: <span class=\"nc\">it</span><span class=\"w\"> </span><span class=\"n\">performed</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"n\">operation</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">rules</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">violated</span><span class=\"w\"> </span><span class=\"n\">are</span><span class=\"w\"> </span><span class=\"n\">still</span><span class=\"w\"> </span><span class=\"n\">experimental</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">help</span>: <span class=\"nc\">see</span><span class=\"w\"> </span><span class=\"n\">https</span>:<span class=\"c1\">//github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information</span>\n</code></pre></div>\n<p>Is this a limitation of Miri? I don't quite get what's going on here, but <a href=\"https://github.com/rust-lang/miri/issues/1909#issuecomment-968187327\">this github comment</a> suggests that boxes are handled specially (not sure if that's related to this issue).</p>",
        "id": 278449819,
        "sender_full_name": "Raekye",
        "timestamp": 1649569283
    },
    {
        "content": "<p>Update: I've narrowed down the issue a bit: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=341a9b7363e3db3882cbeefb02388a83\">playground</a>. The <a href=\"https://doc.rust-lang.org/std/alloc/trait.Allocator.html#tymethod.allocate\">allocator api</a> specifically says the returned <code>NonNull&lt;[u8]&gt;</code> may have larger size than requested. But using such an allocator with <code>Box::new_in</code> seems to result in an error when the box is dropped. I noticed that <a href=\"https://doc.rust-lang.org/src/alloc/boxed.rs.html#1175\"><code>drop</code> for <code>Box</code> is specially handled by the compiler</a>, but I'm having trouble finding what's going on in the MIR/MIRI</p>",
        "id": 278454221,
        "sender_full_name": "Raekye",
        "timestamp": 1649576759
    },
    {
        "content": "<p>I think the original error I was experiencing with my allocator is actually different, although maybe related, since it involves setting the <code>#[global_allocator]</code> to such a size-rounding allocator. My allocator allocates at minimum 16 bytes; enough to store 2 pointers on a 64-bit system (minus CHERI) which I use when the memory is free. Here's a simple example (run through miri to get an error): <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=d43ff9b1646cc3b775c33e27785121f4\">playground</a></p>",
        "id": 278454645,
        "sender_full_name": "Raekye",
        "timestamp": 1649577411
    },
    {
        "content": "<p>See the box_free lang item.</p>",
        "id": 278462536,
        "sender_full_name": "bjorn3",
        "timestamp": 1649589455
    },
    {
        "content": "<p>Using <a href=\"https://doc.rust-lang.org/unstable-book/language-features/lang-items.html\">lang items</a>, I made the following more self-contained example: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a9f952da93a34387fea2a58a4ff77454\">playground</a>. I defined the lang items <code>exchange_malloc</code> and <code>box_free</code> to call <code>malloc</code> and <code>free</code>. Similarly, rounding the size up before calling <code>libc::malloc</code> (line 20) causes a problem when deallocating (removing the rounding, on line 20, from the playground makes miri run ok).</p>\n<p>I didn't find any references/special handling of <code>box_free</code> or <code>BoxFree</code> in rust-lang/miri. The most related code I found in rust-lang/rust was <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir_dataflow/src/elaborate_drops.rs\"><code>elaborate_drops.rs</code></a>, but it wasn't obvious to me how the problem arises</p>",
        "id": 278465025,
        "sender_full_name": "Raekye",
        "timestamp": 1649592803
    },
    {
        "content": "<p>Hmmm, it seems Miri knows the valid range of a box, which is just the size of the layout it was allocated with. That makes sense, since given a <code>Box&lt;u32, MyAlloc&gt;</code>, regardless of how much memory <code>MyAlloc</code> allocates, it probably doesn't make sense for the user of the <code>Box&lt;u32, MyAlloc&gt;</code> to access anything (before or) after the <code>u32</code>. But when the box's internal pointer gets passed to deallocate, it still has the limited valid range of the u32, as opposed to the full bytes <code>MyAlloc</code> allocated (and returned as a slice)</p>",
        "id": 278466435,
        "sender_full_name": "Raekye",
        "timestamp": 1649594798
    },
    {
        "content": "<p>So when <code>MyAlloc</code> deallocates, and assumes that it has at least some minimum number bytes (e.g. layout size rounded up to the next multiple of 16), this causes a miri violation</p>",
        "id": 278466796,
        "sender_full_name": "Raekye",
        "timestamp": 1649595357
    },
    {
        "content": "<p>this might be related to <a href=\"https://github.com/rust-lang/miri/issues/1909\">https://github.com/rust-lang/miri/issues/1909</a>  -- global allocators and stacked borrows don't go well together</p>",
        "id": 278466846,
        "sender_full_name": "RalfJ",
        "timestamp": 1649595388
    },
    {
        "content": "<p>It seems to me that issue 1909 is solely due to using int-to-ptr casts (which I've somewhat followed the discussions in #t-lang/wg-unsafe-code-guidelines, and I'm avoiding completely in my code). The <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=299898fda3bf67a420c0f5d3250f1a5d\">playground</a> in 1909 even says \"this line is essential for the SB violation\" followed by a ptr-int-ptr roundtrip (that serves no other purpose)</p>\n<p>The issue I'm facing seems somewhat related(*) to the <a href=\"https://doc.rust-lang.org/std/alloc/trait.Allocator.html#tymethod.allocate\">allocator api</a>'s ability to return more memory than requested, but when used with <code>Box</code>, the box only remembers its own valid range (which seems reasonable to me on its own). When the box gets dropped and its internal pointer gets deallocated, only the box's range of memory is accessible, as opposed to the full bytes returned by <code>allocate</code></p>\n<p>(*) Technically speaking, it's just the fact that my allocator over-allocates memory (minimum size 16), so it has enough space in deallocated memory to store metadata (a free list), that ultimately causes an issue (otherwise, the box's valid range == the slice returned by <code>allocate</code>). I don't think that's an unreasonable design for an allocator, that ideally could be supported. The allocator api does more or less explicitly allow this to happen; <code>allocate</code> returns a slice which <a href=\"https://doc.rust-lang.org/std/alloc/trait.Allocator.html#tymethod.allocate\">\"may have a larger size than specified by <code>layout.size()</code>\"</a>, and the layout passed to <code>deallocate</code> <a href=\"https://doc.rust-lang.org/std/alloc/trait.Allocator.html#memory-fitting\">must have size between the original requested layout, and the size of the slice returned by <code>allocate</code></a></p>",
        "id": 278467662,
        "sender_full_name": "Raekye",
        "timestamp": 1649596516
    },
    {
        "content": "<p>I see. conceptually that still seems similar though, the problem is <code>Box</code> applying \"subobject provenance\" and then later the allocator has no way to \"pop back up\" to the provenance it needs, that includes the stuff around the <code>Box</code></p>",
        "id": 278467876,
        "sender_full_name": "RalfJ",
        "timestamp": 1649596855
    },
    {
        "content": "<p>I see, I haven't caught up on the \"subobject provenance\" thread in <a class=\"stream\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines\">#t-lang/wg-unsafe-code-guidelines</a> so I'm not sure how much that's related (I'll read and catch up now). But if you have time to answer quickly - are there any potential solutions or plans to make something like this work? I'd be happy to try to prototype something if someone can give guidance on what would be a (potentially) viable solution</p>",
        "id": 278468091,
        "sender_full_name": "Raekye",
        "timestamp": 1649597176
    },
    {
        "content": "<p>Ah well (reading the thread) off that bat it seems like this is another case of <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a> if I understand correctly?</p>",
        "id": 278468137,
        "sender_full_name": "Raekye",
        "timestamp": 1649597273
    },
    {
        "content": "<p>it's loosely related I think -- that thread discussed whether we should have subobject provenance or not. Stacked Borrows does implement subobject provenance and that is, I think your problem here.</p>",
        "id": 278468259,
        "sender_full_name": "RalfJ",
        "timestamp": 1649597424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437904\">Raekye</span> <a href=\"#narrow/stream/269128-miri/topic/Miri.20error.20with.20custom.20allocator.20that.20rounds.20size/near/278468137\">said</a>:</p>\n<blockquote>\n<p>Ah well (reading the thread) off that bat it seems like this is another case of <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a> if I understand correctly?</p>\n</blockquote>\n<p>no, since in your case it's not just a raw pointer. it's a <code>Box</code>.</p>",
        "id": 278468267,
        "sender_full_name": "RalfJ",
        "timestamp": 1649597452
    },
    {
        "content": "<p>(I know/have been told allocators are weird but) the allocator returns a pointer with ok provenance for its rounded-up size/range, as far as I can tell. But it gets \"sized down\" when it gets used for a box. I can sorta reproduce the example without <code>Box</code>: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0de54f4ff99d41f64a366cbbb8ad15d5\">playground</a> - it's ok on the playground, but running locally with <code>MIRIFLAGS='-Zmiri-tag-raw-pointers'</code> it fails on line 38 (which is a mirror of the code in <a href=\"https://github.com/rust-lang/rust/issues/134\">#134</a>, except the <code>&amp;[u8]</code> comes from dereferencing the return value of <code>allocate</code>, as opposed to coming from a local)</p>\n<p>Naively, I don't understand why it only fails with <code>-Zmiri-tag-raw-pointers</code> though... but in any case, at my current testing it seems to me that box being special isn't the problem per se, rather anything that restricts to subobject provenance is an issue</p>",
        "id": 278469804,
        "sender_full_name": "Raekye",
        "timestamp": 1649599306
    },
    {
        "content": "<p>miri without tag-raw-ptrs has some counterintuitive behvaior, so dont worry about that</p>",
        "id": 278470762,
        "sender_full_name": "RalfJ",
        "timestamp": 1649600475
    },
    {
        "content": "<p>right, but <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/134\">https://github.com/rust-lang/unsafe-code-guidelines/issues/134</a> is about relaxing subobject provenance <em>for raw pointers only</em>. that wouldnt be enough for the <code>Box</code> version of your problem.</p>",
        "id": 278470775,
        "sender_full_name": "RalfJ",
        "timestamp": 1649600509
    },
    {
        "content": "<p>so in that sense this is more like <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/256\">https://github.com/rust-lang/unsafe-code-guidelines/issues/256</a></p>",
        "id": 278470780,
        "sender_full_name": "RalfJ",
        "timestamp": 1649600521
    },
    {
        "content": "<p>I see, reading related threads the discussion in <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/316\">316</a> is also interesting. In any case, originally I wasn't sure what the scope of the issue I was facing was, but now it seems like a well-known (and relatively actively discussed) issue. I probably won't be able to add anything new intellectually <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> though I am interested in seeing where this goes. If there's ever a shortage of engineering effort to prototype something or whatever maybe I can give it a shot, because I would be keen on getting this to work</p>",
        "id": 278481846,
        "sender_full_name": "Raekye",
        "timestamp": 1649614176
    },
    {
        "content": "<p>Hmmm, I seem to have run into a somewhat more unpleasant issue... again the premise is similar to <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/316\">316</a></p>\n<blockquote>\n<p>Which, given <code>Box</code>'s implementation, is assuming that if somebody asks an <code>impl GlobalAlloc</code> —or an <code>impl Alloc</code> if generalizing— memory for a <code>Layout::new::&lt;T&gt;()</code> (through <code>alloc</code> or <code>realloc</code>), and gets back a non-null pointer <code>ptr</code>, then it is then legal to give back <code>ptr</code> to that <code>impl Alloc</code>'s <code>dealloc</code> (or <code>realloc</code>), but with <code>ptr</code>'s provenance having been \"shrunk\" down to that <code>T</code>'s layout (_e.g._, through <code>ptr = &lt;*mut _&gt;::cast(&amp;mut *ptr.cast::&lt;MaybeUninit&lt;T&gt;&gt;());</code>).</p>\n</blockquote>\n<p>I believe the following code is problematic for any size-segregated allocator implemented in Rust that does not implement its own way of \"regrowing\" provenance:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MyAlloc</span><span class=\"o\">&gt;</span>::<span class=\"n\">new_in</span><span class=\"p\">(</span><span class=\"n\">MyAlloc</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// suppose N is some exact size returned by MyAlloc, and assume the next exact size &gt; N + 1</span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// at this point, len == N + 1</span>\n<span class=\"c1\">// the underlying allocation is some larger number of bytes (because we assumed the next exact size &gt; N + 1)</span>\n<span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">shrink_to_fit</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// into_boxed_slice already does this, but just being explicit</span>\n<span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">into_boxed_slice</span><span class=\"p\">());</span><span class=\"w\"> </span><span class=\"c1\">// deallocates with Layout::array::&lt;u8&gt;(N + 1)</span>\n</code></pre></div>\n<p>The pointer passed to <code>MyAlloc.deallocate</code> is only valid for <code>N + 1</code> bytes. So for any pointer derived from the one deallocated (e.g. if you push on to and pop from a free list) can only be used for allocations <code>&lt;= N + 1</code> bytes now. The remaining bytes (when accessed from such a derived pointer) are nolonger allowed to be accessed by Miri, and without a way to regrow provenance, the remaining memory is lost</p>\n<p>At present, the only way I can think of restoring the provenance is by (roughly speaking) storing some \"root\" pointer which has large provenance (e.g. over an entire <code>mmap</code>ed region), e.g. similar to what's done <a href=\"https://github.com/retep998/wio-rs/blob/9bf021178b2d02485f1bd35e6cff41bf52d4a9a2/src/vsb.rs#L98-L113\">here in wio-rs</a></p>\n<p>This is easy if the allocator has some max memory limit, so that all the memory can be got from the OS in a single region (then there's a single unambiguous root pointer). But if the underlying memory used by the allocator is disjoint (multiple regions/multiple <code>mmap</code>s), which is common for general purpose allocators, one needs a way of mapping arbitrary pointers in the address space to their root pointer</p>\n<p>Short of an address-space-wide map (e.g. a radix tree), I guess I can ensure that these regions have some sufficiently large alignment so the root pointer can be obtained by masking away the lower bits, which isn't particularly difficult, but at this point satisfying miri is nolonger just \"don't use dangerous APIs like int-to-ptr\", but fundamentally changing the way the code works</p>\n<p>I guess I don't have any solutions to offer, but I didn't see this scenario in previous discussions (and I think it's a quite natural and explicit scenario) so I wanted to share... I also just wanted to confirm:</p>\n<ol>\n<li>am I correct in understanding the problem here? and</li>\n<li>does anyone have any other suggestions than \"align your <code>mmap</code>s to derive a root pointer to regrow provenance\"?</li>\n</ol>",
        "id": 278485880,
        "sender_full_name": "Raekye",
        "timestamp": 1649619467
    },
    {
        "content": "<p>Actually I realized just \"aligning <code>mmap</code>s to mask bits to obtain a root pointer\" doesn't work, because that masking just derives a pointer from the given pointer (the one passed to <code>deallocate</code> with subobject provenance). You really need a root pointer with large provenance, stored somewhere in memory, that can be read back on demand to regrow provenance. That seems to imply an actual map data structure (which I think for an address-space-wide domain for allocators is often a radix tree... but usually that's only needed by <code>malloc</code> replacements because <code>free</code> isn't told the size)</p>",
        "id": 278486234,
        "sender_full_name": "Raekye",
        "timestamp": 1649619920
    },
    {
        "content": "<p>hopefully we can make it so that that map exists only in the Abstract Machine, not for real... but I think we have a lot of lower-hanging fruit to figure out before we can really tackle allocators</p>",
        "id": 278488653,
        "sender_full_name": "RalfJ",
        "timestamp": 1649623324
    },
    {
        "content": "<p>That's fair! When you say lower-hanging fruit, is that the discussions in <a class=\"stream\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines\">#t-lang/wg-unsafe-code-guidelines</a> (or where can I read to follow along)? In any case, I'm excited to see where things go!</p>",
        "id": 278489126,
        "sender_full_name": "Raekye",
        "timestamp": 1649623983
    },
    {
        "content": "<p>yeah right now Im thinking of all the provenance discussions</p>",
        "id": 278489293,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624201
    },
    {
        "content": "<p>and some old discussions around <code>dereferencable</code></p>",
        "id": 278489301,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624210
    },
    {
        "content": "<p>lots of stuff there that interacts with the aliasing model that is tricky even if we consider the allocator a built-in magic construct ;)</p>",
        "id": 278489310,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624232
    },
    {
        "content": "<p>I reread issue 316 more carefully and in the <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/316#issuecomment-1014017192\">most recent comment</a> you discussed something that seems to me like it would help here:</p>\n<blockquote>\n<p>So, we could imagine that when a pointer <code>p</code> is returned from an allocation function (in LLVM terms: a function with a <code>noalias</code> return type), we do something like this:</p>\n<ul>\n<li>generate a fresh ID (e.g. <code>AllocId</code>) representing the provenance of this allocation</li>\n<li>store the previous provenance of <code>p</code> in some global table that maps each fresh AllocId to the original provenance of the \"root pointer\" for that allocation</li>\n</ul>\n<p>When a pointer <code>p</code> is passed to a deallocation function (which would hence also need some kind of attribute, or we could represent both of these things via intrinsics, or whatever):</p>\n<ul>\n<li>Look up the <code>AllocId</code> of this pointer in the aforementioned global table, and use that to restore the provenance that this pointer had when it left the allocator implementation. The 'user-side' <code>AllocId</code> of this pointer now becomes invalid and must not be used any more.</li>\n</ul>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p>I have not fully thought about how this interacts with the more intricate provenance of Stacked Borrows, but I don't see why this would not work there.</p>\n</blockquote>\n<p>This doesn't seem too difficult to prototype based on the Miri and rustc code I took a look at (while trying to understand what was going on above), if it really is just a global table that doesn't interact much (at all?) with the stacked borrows and other code. If I understood the code and recall correctly, the global allocator is already known to Miri. However, <code>Box</code> and <code>Vec</code> take an <code>Allocator</code> as a template and call the associated functions directly, which I would guess Miri doesn't know about. <code>box_free</code> is already a lang item, although I didn't see any code handling it specially in Miri. Not sure how difficult it would be to \"hook\" into the std <code>box_free</code> to do this provenance-restoring before passing the pointer to the allocator. I remember reading something in <a class=\"stream\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines\">#t-lang/wg-unsafe-code-guidelines</a> saying <code>Vec</code> is treated specially, although I don't remember why; not sure how much of an issue that will pose for this</p>\n<p>Would implementing this global table for allocators be something worthwhile for me to try? i.e. have you thought of any issues with this approach since originally proposed, and would the miri people have time to (answer possible implementation questions and) review the results?</p>",
        "id": 278564195,
        "sender_full_name": "Raekye",
        "timestamp": 1649688325
    },
    {
        "content": "<p>Miri knows the default global allocator, and things like <code>malloc</code></p>",
        "id": 278571275,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690951
    },
    {
        "content": "<p>if you set your own global allocator, Miri just treats that like a regular fn call currently</p>",
        "id": 278571312,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690971
    },
    {
        "content": "<p>and same for <code>Allocator</code> calls</p>",
        "id": 278571329,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690976
    },
    {
        "content": "<p>so those would probably both need more special treatment</p>",
        "id": 278571389,
        "sender_full_name": "RalfJ",
        "timestamp": 1649690993
    },
    {
        "content": "<blockquote>\n<p>Would implementing this global table for allocators be something worthwhile for me to try? i.e. have you thought of any issues with this approach since originally proposed, and would the miri people have time to (answer possible implementation questions and) review the results?</p>\n</blockquote>\n<p>I have not thought about this much at all since I wrote that.<br>\nand unfortunately currently I cannot promise much mentoring or review time, there's already 2 miri PRs in my queue. the recent flurry of activity on strict provenance is great but it is also taking more time than I should spend on Rust. I'm supposed to do other work as well.^^<br>\nwe have some other people occasionally review Miri PRs (mostly <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>), but not typically those that go deep into Stacked Borrows. it's hard for me to ensure the memory model implemented in Miri remains coherent when I don't have the time to do all the reviewing required for that. I dont have good ideas for scaling this up, either. :( can we have a coherent memory model without the entire thing being in one person's head? not sure; I don't know how -- if everyone only has a partial view, it is very easy for things to become incoherent. we can have multiple people have it all in their head, currently, but so far not many have stepped up for that task. ;)</p>",
        "id": 278571944,
        "sender_full_name": "RalfJ",
        "timestamp": 1649691181
    },
    {
        "content": "<p>OTOH if there is a way to keep this separate from other memory model aspects in miri, then that would help a lot with those coherence concerns.</p>",
        "id": 278572164,
        "sender_full_name": "RalfJ",
        "timestamp": 1649691278
    },
    {
        "content": "<p>No worries, it's why I asked :)</p>",
        "id": 278592947,
        "sender_full_name": "Raekye",
        "timestamp": 1649699961
    }
]