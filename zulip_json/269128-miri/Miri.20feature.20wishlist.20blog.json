[
    {
        "content": "<p>I wrote a blog post about a few ideas I had for improving miri. Or rather, things i'd like to someday add (or for someone else to) that would catch a lot of issues I've seen before. Anyway, this is probably the only group of people interested in such a thing at all so: <a href=\"https://shift.click/blog/miri-wishlist\">https://shift.click/blog/miri-wishlist</a></p>",
        "id": 260603682,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636329890
    },
    {
        "content": "<p>Thanks for sharing. :)</p>",
        "id": 260887118,
        "sender_full_name": "RalfJ",
        "timestamp": 1636506764
    },
    {
        "content": "<blockquote>\n<p>I think miri can help detect it by modifying “int mode” (or adding a variant if thats not possible) so that allocations never have a higher alignment then requested4 — if you request an alignment of 4, you should not happen to get an 8-byte aligned pointer by luck.</p>\n</blockquote>\n<p>the thing is, in a sense this <em>reduces</em> test coverage... e.g., imagine a repr(C) <code>struct Foo { x: i32, y: i32 }</code>. if we guarantee we will never get 8-aligned allocations for <code>Box&lt;Foo&gt;</code>, we actually guarantee that the 2nd field is 8-aligned!<br>\nso, I thought about this and rejected the idea, instead Miri will ensure that for each allocation base address the last 4 bits are random, modulo what is required by alignment. this means a 4-aligned allocation will be 8-aligned half the time and not 8-aligned the other half. that's already a lot less aligned than real allocators.</p>",
        "id": 260887261,
        "sender_full_name": "RalfJ",
        "timestamp": 1636506888
    },
    {
        "content": "<p>Hm, is that what it does? I did notice that it was less aligned than real allocators</p>",
        "id": 260887359,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636506973
    },
    {
        "content": "<p>That's a good argument in favor of not doing it by default. I had considered the alignment of field (as in the later section), but not the interaction.</p>",
        "id": 260887405,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636507032
    },
    {
        "content": "<p>here's the code doing that: <a href=\"https://github.com/rust-lang/miri/blob/3f2c9ee17e64c89b1dd89c5970f106f3f74416cc/src/intptrcast.rs#L95\">https://github.com/rust-lang/miri/blob/3f2c9ee17e64c89b1dd89c5970f106f3f74416cc/src/intptrcast.rs#L95</a></p>",
        "id": 260887429,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507063
    },
    {
        "content": "<p>if you think 16 is too small, I'd be happy to increase that number</p>",
        "id": 260887443,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507077
    },
    {
        "content": "<blockquote>\n<p>Note that we need to be sure that no two pointers are ever separated by more than isize::MAX for compliance with other properties.</p>\n</blockquote>\n<p>where does that come from? LLVM requires that no single allocation be larger than isize::MAX, but ptrs into different allocs can be arbitrarily far apart I think.</p>",
        "id": 260887541,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507152
    },
    {
        "content": "<p>Hm, good point. I forgot that it's not valid to subtract two unrelated pointers</p>",
        "id": 260887609,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636507207
    },
    {
        "content": "<p>but I freely admit that the int addresses Miri picks are not the result of a lot of thought (aside from the alignment thing which I did think about), mostly because this is outside my area of expertise. this should be rather easy to tweak though.<br>\n(and this affects <em>all</em> allocations. currently miri puts stack and heap allocations next to each other without concern for how real stacks or heaps work. we could change that, too, if there is a good reason to.)</p>",
        "id": 260887638,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507238
    },
    {
        "content": "<p>That's probably fine</p>",
        "id": 260887651,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636507258
    },
    {
        "content": "<p>specifically, what it currently does is to start at <a href=\"https://github.com/rust-lang/miri/blob/3f2c9ee17e64c89b1dd89c5970f106f3f74416cc/src/machine.rs#L32\">32 * 4096</a> and then it just assigns addresses linearly as they are required, leaving small gaps for the above alignment thing.</p>",
        "id": 260887752,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507352
    },
    {
        "content": "<p>Isn't it PTRDIFF_MAX, not isize::MAX, to be pedantic?</p>",
        "id": 260887770,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636507372
    },
    {
        "content": "<p>those miri constants will probably make anyone who actually knows how real addresses spaces are organized laugh out loud. or make them cry.^^</p>",
        "id": 260887786,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507394
    },
    {
        "content": "<p>so the \"More Address Shenanigans\" part of the post is rather easy to implement I think</p>",
        "id": 260887875,
        "sender_full_name": "RalfJ",
        "timestamp": 1636507472
    },
    {
        "content": "<p>I actually had presumed that'd be a harder piece. i guess spurious wakeups have the question of \"when\" which is challenging</p>",
        "id": 260889234,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1636508620
    }
]