[
    {
        "content": "<p>This is mostly a note to myself... I wonder if we could at least preliminarily make miri compatible with self-referential generators by treating <code>&amp;mut T</code> for <code>T: !Unpin</code> as not actually being a unique pointer. AFAIK codegen already does something like that wrt how it adds <code>noalias</code>? My main concern is that there might be too many <code>!Unpin</code> types so this could make detection of other aliasing issues less effective. I am not sure how common <code>!Unpin</code> types are in practice.</p>",
        "id": 265914899,
        "sender_full_name": "RalfJ",
        "timestamp": 1640265018
    },
    {
        "content": "<p>yeah, noalias for mutable references is tied to <code>Unpin</code>:<br>\n<a href=\"https://github.com/rust-lang/rust/blob/b81553267437627af63c79c1a20c73af865a842a/compiler/rustc_middle/src/ty/layout.rs#L2482\">https://github.com/rust-lang/rust/blob/b81553267437627af63c79c1a20c73af865a842a/compiler/rustc_middle/src/ty/layout.rs#L2482</a></p>",
        "id": 265920992,
        "sender_full_name": "RalfJ",
        "timestamp": 1640269539
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/miri/pull/1952\">https://github.com/rust-lang/miri/pull/1952</a> implements this and seems to have the desired effect. I wonder what people think about this.</p>",
        "id": 266568173,
        "sender_full_name": "RalfJ",
        "timestamp": 1641060395
    },
    {
        "content": "<p>personally not a huge fan given that pin and such were designed to be a library solution not a language thign, but i guess this accurately models how rustc actually compiles things, so...</p>",
        "id": 266571339,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641065197
    },
    {
        "content": "<p>Wait, does that mean it's now legal to opt out of <code>Unique</code> access levels w.r.t. <code>&amp;mut T</code> for any <code>T: ?Sized</code>? <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span>  <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c729de03da938f74f58f7dc70aef37e4\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c729de03da938f74f58f7dc70aef37e4</a></p>",
        "id": 269172090,
        "sender_full_name": "Pointerbender",
        "timestamp": 1643058031
    },
    {
        "content": "<p>no, it doesnt mean its legal. it just means Miri no longer complains.</p>",
        "id": 269304768,
        "sender_full_name": "RalfJ",
        "timestamp": 1643136682
    },
    {
        "content": "<p>this is an attempt to make miri more useful for programs/libraries that involve self-referential generators -- overall I think this can help catch more bugs, even if it means some uniqueness violations are missed</p>",
        "id": 269304939,
        "sender_full_name": "RalfJ",
        "timestamp": 1643136741
    },
    {
        "content": "<p>but we are unfortunately not yet at the stage where \"it passes miri\" implies \"it is legal\" (in the sense of not being UB)</p>",
        "id": 269304984,
        "sender_full_name": "RalfJ",
        "timestamp": 1643136760
    },
    {
        "content": "<p>Thanks :) In that case I'll refrain from using such trickery :D</p>",
        "id": 269314610,
        "sender_full_name": "Pointerbender",
        "timestamp": 1643140515
    },
    {
        "content": "<blockquote>\n<p>\"it passes miri\" implies \"it is legal\" </p>\n</blockquote>\n<p>Someday... someday... <span aria-label=\"fingers crossed\" class=\"emoji emoji-1f91e\" role=\"img\" title=\"fingers crossed\">:fingers_crossed:</span></p>",
        "id": 269314813,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643140617
    },
    {
        "content": "<p>At first I disliked this because this seemed extremely ad-hoc and I couldn't think of a reason this would be the case, but there's a sense in which this kinda works.</p>\n<p>My very loose reasoning is: <code>!Unpin</code> indicates that some pointers into the value exist that will be invalidated by the move. Which means some pointers into the value exist. Which means it can't be noalias.</p>\n<p>That said this description <em>for sure</em> plays it fast and loose with the difference between values and types. And if things have been pinned or not. (TBH, it's bordering on deliberately handwavey, but attempts to unwave the hands only made it more confusing)</p>",
        "id": 270631620,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643929224
    },
    {
        "content": "<p>I've come to understand that my mental model for what pin means is very different than how it was formalized (and thats about all I've come to understand about pins formalization), so I suspect this doesn't play nicely with that at all.</p>",
        "id": 270631905,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643929364
    },
    {
        "content": "<p>I agree with that intuition, <span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span>. Moreover, I'm pretty sure I recall <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> mentioning something along the lines of: when an <code>!Unpin</code> instance is pointed to by a <code>Pin</code>-wrapped pointer (when it is \"pinned\"), then, conceptually, the instance is kind of \"owned by its memory location\".<br>\nSo, in that regard, it surely can't be deemed unaliased anymore.</p>",
        "id": 270712602,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643980535
    },
    {
        "content": "<p>If a <code>Pin&lt;&amp;mut T&gt;</code> (where <code>T: !Unpin</code>) would end up being aliasable, it would probably be better internally represented as an <code>&amp;UnsafeCell&lt;T&gt;</code> without compiler or SB modifications, something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(specialization)]</span><span class=\"w\"></span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">marker</span>::<span class=\"n\">PhantomData</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">cell</span>::<span class=\"n\">UnsafeCell</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">mod</span> <span class=\"nn\">private</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Reference</span>: <span class=\"nc\">private</span>::<span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// The type that the reference points to.</span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Target</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// How the reference is stored internally in `Pin`.</span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Pointer</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Reference</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Target</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Reference</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nb\">Unpin</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Target</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">default</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Reference</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Target</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">UnsafeCell</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Reference</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pointer</span>: <span class=\"nc\">T</span>::<span class=\"n\">Pointer</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">pointer</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// This impl currently breaks the Rust compiler:</span>\n<span class=\"c1\">// error[E0275]: overflow evaluating the requirement `Pin&lt;&amp;mut _&gt;: From&lt;&amp;mut _&gt;`</span>\n<span class=\"n\">default</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: casting `&amp;mut T` to &amp;UnsafeCell&lt;T&gt;` is sound</span>\n<span class=\"w\">            </span><span class=\"n\">pointer</span>: <span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nb\">Unpin</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">pointer</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(This <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2bdaa697419cce8e95ece9c82f91ccc1\">doesn't actually compile</a> today, even with the incomplete <code>specialization</code> feature :P)</p>",
        "id": 270729221,
        "sender_full_name": "Pointerbender",
        "timestamp": 1643988241
    },
    {
        "content": "<p>Interestingly enough, that error is not caused by the unstable <code>specialization</code> feature (<a href=\"https://github.com/rust-lang/rust/issues/37748\">#37748</a>).</p>",
        "id": 270730115,
        "sender_full_name": "Pointerbender",
        "timestamp": 1643988634
    },
    {
        "content": "<p>i think the trait projection here would break covariance in stuff like <code>Pin&lt;&amp;'a T&gt;</code> and <code>Pin&lt;Box&lt;T&gt;&gt;</code></p>",
        "id": 270749294,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643997175
    },
    {
        "content": "<p>but even if that worked, idrk that i really agree that this is a good way of modeling it</p>",
        "id": 270749364,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643997222
    },
    {
        "content": "<p>istm that an unfortunate problem here is that even when the value is not held in a Pin, it still might be pinned, since you can get a <code>&amp;mut T</code> out of a <code>Pin&lt;&amp;mut T&gt;</code>, which shouldn't invalidate the aliasing pointers into the internals unless you move it out, which the unsafe makes you you promise not to do</p>",
        "id": 270749751,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643997417
    },
    {
        "content": "<p>which means that any <code>&amp;mut impl !Unpin</code> potentially can be aliased, unless you know for sure it has not been pinned. at least from the compilers perspective and such -- what rust code can assume is different (as safe code can move out of a <code>&amp;mut impl !Unpin</code> with reckless abandon)</p>",
        "id": 270750269,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643997667
    },
    {
        "content": "<p>(i believe this also all applies to <code>&amp;impl !Unpin</code> too, ofc, although its somewhat of a less interesting case)</p>",
        "id": 270750317,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643997705
    },
    {
        "content": "<p>this all means i dont think unsafecell is an appropriate way to model it</p>",
        "id": 270750493,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643997782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270729221\">said</a>:</p>\n<blockquote>\n<p>If a <code>Pin&lt;&amp;mut T&gt;</code> (where <code>T: !Unpin</code>) would end up being aliasable...</p>\n</blockquote>\n<p>e.g. i think the problem is that it has to still be aliasable so long as its pinned, even if youve pulled the <code>&amp;mut T</code> out of the pin. so thats not quite sufficient.</p>",
        "id": 270750746,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643997895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270749294\">said</a>:</p>\n<blockquote>\n<p>i think the trait projection here would break covariance in stuff like <code>Pin&lt;&amp;'a T&gt;</code> and <code>Pin&lt;Box&lt;T&gt;&gt;</code></p>\n<p>...</p>\n<p>this all means i dont think unsafecell is an appropriate way to model it</p>\n</blockquote>\n<p>Oh yeah this is a really good point :) I fully agree with you there.</p>",
        "id": 270827567,
        "sender_full_name": "Pointerbender",
        "timestamp": 1644068673
    },
    {
        "content": "<p>Would <code>NonNull&lt;T&gt;</code> be a viable alternative to <code>&amp;UnsafeCell&lt;T&gt;</code> to store a <code>Pin&lt;T: !Unpin&gt;</code> internally? It would solve the problems with the variance and since any <code>&amp;mut T</code> derived from it would be a reborrow, this would be allowed under Stacked Borrows (with the assumption that only the internals of <code>Pin</code> and generators can promise this kind of behavior, as a kind of safe encapsulation - so not as a hard promise to the \"outside world\" that <code>Pin&lt;T: !Unpin&gt;</code> is allowed to alias anywhere). I guess <code>NonNull&lt;T&gt;</code> is less optimizable because it doesn't have alignment or write-provenance guarantees semantically (nor having tagged the <code>restrict</code> llvm keyword , for that matter) and these can all lead to missed compiler optimizations where the compiler can't infer these by itself.</p>",
        "id": 270828203,
        "sender_full_name": "Pointerbender",
        "timestamp": 1644069247
    },
    {
        "content": "<p>An example of what that might look like (this time it also compiles :P <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=9dd5dbfa8b595f2b29cd6c7031046d33\">playground</a>):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(specialization)]</span><span class=\"w\"></span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">marker</span>::<span class=\"n\">PhantomData</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">ops</span>::<span class=\"p\">{</span><span class=\"n\">Deref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">DerefMut</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">ptr</span>::<span class=\"n\">NonNull</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">mod</span> <span class=\"nn\">private</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">ops</span>::<span class=\"n\">Deref</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">PinPointer</span>: <span class=\"nc\">Deref</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">private</span>::<span class=\"n\">Sealed</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Pointer</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">deref</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">Self</span>::<span class=\"n\">Pointer</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">default</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">Deref</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">PinPointer</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">NonNull</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">deref</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">Self</span>::<span class=\"n\">Pointer</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: `self.pointer` is an aligned `NonNull` pointer.</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: `&amp;self.pointer` can be soundly represented as `*const *const P::Target`</span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: and can safely be dereferenced twice.</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;**</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">Deref</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Unpin</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">PinPointer</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">deref</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">Self</span>::<span class=\"n\">Pointer</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Pointer</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">deref</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(Copy, Clone)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[repr(transparent)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">PinPointer</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pointer</span>: <span class=\"nc\">P</span>::<span class=\"n\">Pointer</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">PinPointer</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">P</span>: <span class=\"nb\">Send</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">PinPointer</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Sync</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">P</span>: <span class=\"nb\">Sync</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">PinPointer</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Target</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">deref</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span>::<span class=\"n\">Target</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">PinPointer</span><span class=\"o\">&gt;</span>::<span class=\"n\">deref</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">pointer</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">PinPointer</span><span class=\"o\">&lt;</span><span class=\"n\">Pointer</span><span class=\"o\">=</span><span class=\"n\">P</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">DerefMut</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span>: <span class=\"nb\">Unpin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">P</span>: <span class=\"nc\">DerefMut</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">deref_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">Target</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">pointer</span><span class=\"p\">.</span><span class=\"n\">deref_mut</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">P</span>: <span class=\"nc\">PinPointer</span><span class=\"o\">&lt;</span><span class=\"n\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span>: <span class=\"nb\">Unpin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"nc\">P</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">pointer</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">P</span>: <span class=\"nb\">Copy</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">PinPointer</span><span class=\"o\">&lt;</span><span class=\"n\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">NonNull</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deref</span><span class=\"o\">&gt;</span>::<span class=\"n\">Target</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"nc\">P</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">pointer</span>: <span class=\"nc\">NonNull</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">.</span><span class=\"n\">deref</span><span class=\"p\">()),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">PinPointer</span><span class=\"o\">&lt;</span><span class=\"n\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new_unchecked_mut</span><span class=\"p\">(</span><span class=\"n\">pointer</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_phantom</span>: <span class=\"nc\">PhantomData</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">pointer</span>: <span class=\"nc\">NonNull</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">pointer</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">pin</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">pin</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">pin</span><span class=\"p\">.</span><span class=\"n\">deref_mut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270833714,
        "sender_full_name": "Pointerbender",
        "timestamp": 1644076239
    },
    {
        "content": "<p>The issue is that the value is still pinned even after it is no longer wrapped in the pin. E.g. extracting the <code>&amp;mut T</code> from the Pin needs to be allowed, and should not invalidate the pointers (unless you use the <code>&amp;mut</code> to violate pinning guarantees ofc, which you promise via <code>unsafe</code> that you wont) -- this must be the case, because in practice you need to get a <code>&amp;mut T</code> out of the pin to use it in many cases.</p>\n<p>Unfortunately, means that I don't think there's anything you can do to the internals of Pin to solve this, including NonNull. That is (AFAICT), once a value of an <code>!Unpin</code> type ever becomes pinned[^1], it behaves a bit like the value has a magic invisible UnsafeCell (or UnsafeAlias? IDK), wrapped around it or something. This cannot be modeled statically, without significant breaking changes</p>\n<p>Sadly, the fact that it isn't a wrapper and instead is trait-based is not really obviously sensible, and seems fragile. For example, it seems like a problem when references are taken to fields of the <code>&amp;mut Unpin</code>.</p>\n<p>These would get noalias on them (as they are <code>Unpin</code>), even though they may have pointers to them. This is not directly possible with <code>async {}</code> (it might be indirectly possible when the value is polled, but may take some contrived case for something to go wrong...). </p>\n<p>Either way, it seems like a problem whether or not <code>async {}</code> hits it,  and more broadly, it was kinda part of why I've argued a few times that us needing to disable noalias on <code>!Unpin</code> is a bad sign, and feels like we may probably shouldn't be applying it as aggressively as we do. That said, that's an unpopular opinion, and maybe I'm too pessimistic.</p>\n<p>[^1]: Something like this anyway -- miri and rustc don't noalias any !unpin, even ones that have never been pinned. I think this is just because rustc has no way of knowing if the value has been pinned in most cases, and miri follows rustcs lead here, but it may be that the rules are more complex than I can tell.</p>",
        "id": 270840567,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644084149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270840567\">said</a>:</p>\n<blockquote>\n<p>Either way, it seems like a problem whether or not <code>async {}</code> hits it,  and more broadly, it was kinda part of why I've argued a few times that us needing to disable noalias on <code>!Unpin</code> is a bad sign, and feels like we may probably shouldn't be applying it as aggressively as we do. That said, that's an unpopular opinion, and maybe I'm too pessimistic.</p>\n</blockquote>\n<p>I'd say you make good arguments for it :) I'm not a pinning expert, but am still curious to see how they'd solve that! Thank you for all the feedback :)</p>",
        "id": 270896642,
        "sender_full_name": "Pointerbender",
        "timestamp": 1644163178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> </p>\n<blockquote>\n<p>Sadly, the fact that it isn't a wrapper and instead is trait-based is not really obviously sensible, and seems fragile. For example, it seems like a problem when references are taken to fields of the &amp;mut Unpin.</p>\n<p>These would get noalias on them (as they are Unpin), even though they may have pointers to them. This is not directly possible with async {} (it might be indirectly possible when the value is polled, but may take some contrived case for something to go wrong...). </p>\n</blockquote>\n<p>do you have an example of when this would be a problem?</p>",
        "id": 270993814,
        "sender_full_name": "RalfJ",
        "timestamp": 1644247437
    },
    {
        "content": "<p>Hmm, with <code>async{}</code>? No, it's possible I'm wrong and it wouldn't?</p>",
        "id": 270993990,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644247495
    },
    {
        "content": "<p>I can come up with what i mean for a manually self-referential type</p>",
        "id": 270994033,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644247514
    },
    {
        "content": "<p>if thats not clear</p>",
        "id": 270994038,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644247518
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270712602\">said</a>:</p>\n<blockquote>\n<p>I agree with that intuition, <span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span>. Moreover, I'm pretty sure I recall <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> mentioning something along the lines of: when an <code>!Unpin</code> instance is pointed to by a <code>Pin</code>-wrapped pointer (when it is \"pinned\"), then, conceptually, the instance is kind of \"owned by its memory location\".<br>\nSo, in that regard, it surely can't be deemed unaliased anymore.</p>\n</blockquote>\n<p>I dont know what you mean by \"owned by its memory location\"... but very roughly my definition of pinning says that ownership of that memory is then subject to library-specific rules, i.e., it is managed by the type itself. that is very different from the regular owned / mutably borrowed case where we know that ownership of the memory lies with the owner of that type.</p>",
        "id": 270994072,
        "sender_full_name": "RalfJ",
        "timestamp": 1644247532
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270994033\">said</a>:</p>\n<blockquote>\n<p>I can come up with what i mean for a manually self-referential type</p>\n</blockquote>\n<p>yeah that's what I mean -- a reasonably realistic example where this would happen in practice</p>",
        "id": 270994192,
        "sender_full_name": "RalfJ",
        "timestamp": 1644247571
    },
    {
        "content": "<p>FWIW I think the best idea in <a href=\"https://github.com/rust-lang/rust/issues/63818\">https://github.com/rust-lang/rust/issues/63818</a> so far was to have something like UnsafeAliasable or so, which acts similar to UnsafeCell but opts-out of uniqueness (rather than opting out of immutability)</p>",
        "id": 270994504,
        "sender_full_name": "RalfJ",
        "timestamp": 1644247694
    },
    {
        "content": "<p>Yeah, i broadly like the idea of that too, but don't see how it could be compatible with pin/unpin</p>",
        "id": 270994569,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644247722
    },
    {
        "content": "<p>that said, i do feel some degree of wrapper fatigue. but maybe i just need to embrace <code>UnsafeAlias&lt;UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;&gt;</code> as peak rust</p>",
        "id": 270995086,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644247920
    },
    {
        "content": "<p>i think the problem with UnsafeAlias is that it seems tricky to use, since in practice you need a &amp;T or &amp;mut T to do most things with a type, and as soon as you get something out of UnsafeAlias the jig is up</p>",
        "id": 270995230,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644247967
    },
    {
        "content": "<p>The !Unpin workaround avoids that issue but... feels like it has others. I could be wrong though.</p>",
        "id": 270995354,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644248013
    },
    {
        "content": "<p>That said, the degree to which \"the jig is up\" is more substantial in current SB than it feels like it needs to be, since (i believe) extracting the <code>&amp;mut T</code> will invalidate the other pointers into the UnsafeAlias permanently. If it only did so during the span of time that the reference was around, it would be more usable, perhaps.</p>",
        "id": 270996489,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644248462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270995086\">said</a>:</p>\n<blockquote>\n<p>that said, i do feel some degree of wrapper fatigue. but maybe i just need to embrace <code>UnsafeAlias&lt;UnsafeCell&lt;MaybeUninit&lt;T&gt;&gt;&gt;</code> as peak rust</p>\n</blockquote>\n<p>yeah... type wrappers are great to let the type system help us express various things, but they dont compose terribly well</p>",
        "id": 271006753,
        "sender_full_name": "RalfJ",
        "timestamp": 1644252413
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270995230\">said</a>:</p>\n<blockquote>\n<p>i think the problem with UnsafeAlias is that it seems tricky to use, since in practice you need a &amp;T or &amp;mut T to do most things with a type, and as soon as you get a &amp;mut out of UnsafeAlias the jig is up</p>\n</blockquote>\n<p>well it'd have to be like UnsafeCell -- you would have <code>&amp;mut UnsafeAlias&lt;T&gt;</code></p>",
        "id": 271006851,
        "sender_full_name": "RalfJ",
        "timestamp": 1644252469
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/269128-miri/topic/Self-referential.20generators.20stopgap/near/270996489\">said</a>:</p>\n<blockquote>\n<p>That said, the degree to which \"the jig is up\" is more substantial in current SB than it feels like it needs to be, since (i believe) extracting the <code>&amp;mut T</code> will invalidate the other pointers into the UnsafeAlias permanently. If it only did so during the span of time that the reference was around, it would be more usable, perhaps.</p>\n</blockquote>\n<p>that depends on where the reference is derived from -- if all those aliasing pointers form a single \"equivalence class\" for aliasing (as they should), then deriving an &amp;mut from one of them will not invalidate the others. but using any of the others will invalidate the &amp;mut, of course.</p>",
        "id": 271006970,
        "sender_full_name": "RalfJ",
        "timestamp": 1644252515
    },
    {
        "content": "<p>Hey. I was pointed to this thread from &lt;<a href=\"https://github.com/tokio-rs/tokio/issues/3101\">https://github.com/tokio-rs/tokio/issues/3101</a>&gt;</p>",
        "id": 271188668,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1644353301
    }
]