[
    {
        "content": "<p>Hi! The Bevy team is deeply interested in getting variadics into Rust, and have a number of technical and motivated folks who should be able to own the design process.</p>",
        "id": 277913132,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649178994
    },
    {
        "content": "<p>Chatting with the team: I'll take variadics. <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>,  when you get a chance, let me know where to begin / what to read / who to talk to.</p>",
        "id": 277935678,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649188850
    },
    {
        "content": "<p>Been thinking about this, I think there's a lot you could do with a <code>Tuple</code> trait with some GATs for appending/manipulating the types, and a tuple for_each macro or the like. Be interesting to start there and see where the feature gap is.</p>",
        "id": 277948394,
        "sender_full_name": "alercah",
        "timestamp": 1649195481
    },
    {
        "content": "<p>I actually wrote up an API and was working on extensions to the compiler to support PartialEq/Debug/etc. for tuples with the same idea</p>",
        "id": 277948646,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649195648
    },
    {
        "content": "<p>maybe I can dig it up..</p>",
        "id": 277949034,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649195883
    },
    {
        "content": "<p>Something like <code>&amp;(T1, T2, T3, ..., TN)</code> -&gt; <code>[&amp;dyn Trait; N]</code> might be a really nice primitive to experiment with.  It'd certainly work for things like <code>Debug</code>, since the derive for tuple-structs uses <code>dyn Debug</code> anyway.  And if unrolled it might well get devirtualized, solving the perf hit.</p>",
        "id": 277949179,
        "sender_full_name": "scottmcm",
        "timestamp": 1649195996
    },
    {
        "content": "<p>it's possible to use the existing unstable <code>call</code> function of <code>Fn</code> to uncurry, which is nice</p>",
        "id": 277949598,
        "sender_full_name": "alercah",
        "timestamp": 1649196204
    },
    {
        "content": "<p>If variadic generics were to be introduced that should allow removing the rust-call call conv in which case using the call function for that would be circular.</p>",
        "id": 277950906,
        "sender_full_name": "bjorn3",
        "timestamp": 1649197062
    },
    {
        "content": "<p>Yeah but I think it'd be more useful to look at what we have and see if we can get all the useful functionality without true variadic generics.</p>",
        "id": 277953036,
        "sender_full_name": "alercah",
        "timestamp": 1649198254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/277949179\">said</a>:</p>\n<blockquote>\n<p>Something like <code>&amp;(T1, T2, T3, ..., TN)</code> -&gt; <code>[&amp;dyn Trait; N]</code> might be a really nice primitive to experiment with.  It'd certainly work for things like <code>Debug</code>, since the derive for tuple-structs uses <code>dyn Debug</code> anyway.  And if unrolled it might well get devirtualized, solving the perf hit.</p>\n</blockquote>\n<p>I'd rather have that as a function people can write in a couple of lines, rather than as a primitive.</p>",
        "id": 277975418,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649220605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/277950906\">said</a>:</p>\n<blockquote>\n<p>If variadic generics were to be introduced that should allow removing the rust-call call conv in which case using the call function for that would be circular.</p>\n</blockquote>\n<p>rust-call and Fn is close to half of the reason I want variadic generics and variadic tuples in the first place. :)</p>",
        "id": 277975436,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649220650
    },
    {
        "content": "<p>an <code>&amp;(T1, T2, T3, ..., TN)</code> -&gt; <code>&amp;[dyn Trait; N]</code> API wouldnt help for bevy since what we need is to implement a trait for tuples of any length where each element implements a trait (additionally I dont think there is genreally a<code>dyn Trait</code> to even use as there are _lots_ of assoc types in our code and dyn trait requires those to be written)</p>",
        "id": 277975624,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649220883
    },
    {
        "content": "<p>Yep, Boxy is completely right here</p>",
        "id": 277975645,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649220931
    },
    {
        "content": "<p>also I think that would basically stabilize the layout of tuples?</p>",
        "id": 277975662,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649220962
    },
    {
        "content": "<p>ah i guess not i missed the fact that it was <code>&amp;dyn Trait</code> element type</p>",
        "id": 277975707,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649220981
    },
    {
        "content": "<p>(not sure why I read that as <code>&amp;[dyn Trait; N]</code> doesnt make any sense lol)</p>",
        "id": 277975718,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649221005
    },
    {
        "content": "<p>in ecs-land/gamedev-land there is just a _lot_ of implementing <code>Trait</code> for <code>(T: Trait, U: Trait)</code> and setting all assoc types to <code>(T::Assoc, U::Assoc)</code> any variadics proposal that doesnt support this would largely be useless to us <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 277975838,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649221181
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/277975418\">said</a>:</p>\n<blockquote>\n<p>I'd rather have that as a function people can write in a couple of lines, rather than as a primitive.</p>\n</blockquote>\n<p>Oh, me too.  But that means figuring out â‰ˆeverything.  Whereas \"hey, I just want to consume a tuple\" could be unblocked much faster.  (Though your comment implies that if it were to be exposed early, it should probably look like a library function, not like a coercion or something, which I agree with.)</p>",
        "id": 277993529,
        "sender_full_name": "scottmcm",
        "timestamp": 1649235162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/277975707\">said</a>:</p>\n<blockquote>\n<p>ah i guess not i missed the fact that it was <code>&amp;dyn Trait</code> element type</p>\n</blockquote>\n<p>Yeah, it's like <code>Option::as_ref</code> but for tuples and also unsizing.</p>\n<p>I've so far not been convinced by any of the variadic plans that amounted to \"just use tuples, and in doing so pessimize tuple layout for everyone\".</p>",
        "id": 277993763,
        "sender_full_name": "scottmcm",
        "timestamp": 1649235271
    },
    {
        "content": "<p>I don't think anything that involves pessimizing tuple layout would be good. It should be monomorphized.</p>",
        "id": 278259520,
        "sender_full_name": "alercah",
        "timestamp": 1649396802
    },
    {
        "content": "<p>I'm working on preparing a collection of notes on variadics, and I'm looking for background reading to link.</p>\n<p>I've already found <a href=\"https://github.com/rust-lang/rfcs/issues/376\">https://github.com/rust-lang/rfcs/issues/376</a>: is there anything else essential I should know about?</p>",
        "id": 278351454,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649446199
    },
    {
        "content": "<p>Aha: <a href=\"https://github.com/rust-lang/rfcs/issues/376#issuecomment-560184417\">https://github.com/rust-lang/rfcs/issues/376#issuecomment-560184417</a></p>",
        "id": 278353265,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649447011
    },
    {
        "content": "<p>There's also <a href=\"https://github.com/rust-lang/lang-team/blob/master/src/design_notes/variadic_generics_design.md\">https://github.com/rust-lang/lang-team/blob/master/src/design_notes/variadic_generics_design.md</a></p>",
        "id": 278378856,
        "sender_full_name": "Charles Lew",
        "timestamp": 1649466155
    },
    {
        "content": "<p>Ah thanks: I hadn't seen that one :) It's a very nice concise summary</p>",
        "id": 278380623,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649468624
    },
    {
        "content": "<p>Maybe scope creep, but I think it could be cool if whatever is used for variadics also works for things like arrays or tuples.  Like if <code>[...a, b, ...c]</code> can merge <code>a: [T; 4], b: T, c: [T; 10]</code> into one array.</p>",
        "id": 278381877,
        "sender_full_name": "scottmcm",
        "timestamp": 1649470244
    },
    {
        "content": "<p>Yeah <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Having looked at use cases, I actually think that sort of type manipulation is not super critical for an MVP. But it makes sense as a arbitrary tool to concatenate types IMO</p>",
        "id": 278381910,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649470320
    },
    {
        "content": "<p>FYI, I'm starting to collect my very early thoughts here: <a href=\"https://github.com/alice-i-cecile/rust-variadics-background\">https://github.com/alice-i-cecile/rust-variadics-background</a></p>\n<p>Please don't share widely yet, but if y'all would like to help fill it out or make corrections I'd be happy to merge them in.</p>",
        "id": 278381965,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649470398
    },
    {
        "content": "<p>It's deliberately expansive: I want to get a sense of the broad landscape and chart a path, then propose a few targeted changes that we can move forward on independently</p>",
        "id": 278382204,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649470711
    },
    {
        "content": "<p>Yeah, definitely good to have both a long-term vision and the <code>min_variadic_generics</code> thing that can be carved out initially</p>",
        "id": 278382228,
        "sender_full_name": "scottmcm",
        "timestamp": 1649470789
    },
    {
        "content": "<p>My current thinking is that we could move forward on a <code>Tuple</code> trait pretty much immediately without controversy, and it would both be immediately useful and likely to lay the foundations for any future variadics work</p>",
        "id": 278382277,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649470843
    },
    {
        "content": "<p>What would you expect on the trait?  I'll note that we don't have an <code>Array</code> trait...</p>",
        "id": 278382340,
        "sender_full_name": "scottmcm",
        "timestamp": 1649470930
    },
    {
        "content": "<p>But I definitely agree that \"implement traits on tuples\" is the first thing that people definitely want to do with this.</p>",
        "id": 278382426,
        "sender_full_name": "scottmcm",
        "timestamp": 1649471050
    },
    {
        "content": "<p>There are a few things:</p>\n<ol>\n<li>LEN</li>\n<li>next(), or some other form of iteration (non-trivial due to heterogenous types)</li>\n<li>Eventually, the ability to specify \"tuple item trait bounds\". This pattern comes up again and again: you need to be able to guarantee that all types within the tuple impl some trait. It's essential to \"implement traits on tuples\"), but it's not easily expressible right now</li>\n<li>Other convenience methods for tuple type transformation, into_ref, into_ref_mut can be added later. frunk has quite a few good candidate methods.</li>\n</ol>",
        "id": 278382458,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649471146
    },
    {
        "content": "<p>Hmm, I wonder if this will want generic closures first.</p>",
        "id": 278382525,
        "sender_full_name": "scottmcm",
        "timestamp": 1649471228
    },
    {
        "content": "<p>Yeah? What's the connection?</p>",
        "id": 278382528,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649471245
    },
    {
        "content": "<p><code>&lt;(A, B) as Tuple&gt;::for_each</code> wants an argument that's <code>Fn(A) + Fn(B)</code>.</p>",
        "id": 278382543,
        "sender_full_name": "scottmcm",
        "timestamp": 1649471281
    },
    {
        "content": "<p>Ah, yeah. I was thinking that for most uses of iteration you actually want to use tuple item trait bounds.</p>\n<p>Effectively, treat the item type as a dyn Trait :)</p>",
        "id": 278382590,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649471323
    },
    {
        "content": "<p>And the easiest way to satisfy that would be if you could pass a generic that accepted <code>impl Trait</code> for some <code>Trait</code> that both <code>A</code> and <code>B</code> implement</p>",
        "id": 278382592,
        "sender_full_name": "scottmcm",
        "timestamp": 1649471328
    },
    {
        "content": "<p>I assume people will want to be able to use them not via <code>dyn</code>, though.  Because otherwise the \"convert tuple to array of dyn\" is enough.</p>",
        "id": 278382755,
        "sender_full_name": "scottmcm",
        "timestamp": 1649471524
    },
    {
        "content": "<p>Yeah, dyn forces indirection right?</p>",
        "id": 278382768,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649471545
    },
    {
        "content": "<p>The ECS folks would be unhappy with that for example, and they're currently jumping through the hoops of fake-variadics in order to avoid ever having to go through dynamic dispatch</p>",
        "id": 278382786,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649471602
    },
    {
        "content": "<p>Well, it compiles to indirection in LLVM-IR -- LLVM can often remove it again, but not always.</p>",
        "id": 278382803,
        "sender_full_name": "scottmcm",
        "timestamp": 1649471628
    },
    {
        "content": "<p>I think you have to be pretty clear here about what behaviour you actually want to expose, for risk of accidentally introducing specialization.</p>",
        "id": 278445145,
        "sender_full_name": "alercah",
        "timestamp": 1649560634
    },
    {
        "content": "<p>But I would think the MVP version of tuple iteration would just be a built-in macro</p>",
        "id": 278445149,
        "sender_full_name": "alercah",
        "timestamp": 1649560652
    },
    {
        "content": "<p>I guess that depends on exactly whether this can be implemented as an intrinsic though</p>",
        "id": 278445208,
        "sender_full_name": "alercah",
        "timestamp": 1649560749
    },
    {
        "content": "<p>I do agree with a built-in tuple trait being a valuable thing, though.</p>",
        "id": 278445300,
        "sender_full_name": "alercah",
        "timestamp": 1649560918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/278382340\">said</a>:</p>\n<blockquote>\n<p>What would you expect on the trait?  I'll note that we don't have an <code>Array</code> trait...</p>\n</blockquote>\n<p><code>Array</code> doesn't need a trait because you can bind generically to any array already:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">on_array</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"n\">N</span><span class=\"p\">]);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278445401,
        "sender_full_name": "alercah",
        "timestamp": 1649561067
    },
    {
        "content": "<p>It's actually quite interesting that std uses the \"implement this trait for all tuples &lt;= 12 using macros\" pattern internally. It means we could get serious users of any solution before stabilization</p>",
        "id": 278445424,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649561148
    },
    {
        "content": "<p>Also if there's going to be any kind of iteration, start with fold, because it's critical for a number of use cases but subsumes most others.</p>",
        "id": 278445597,
        "sender_full_name": "alercah",
        "timestamp": 1649561428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123893\">alercah</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/278445401\">said</a>:</p>\n<blockquote>\n<p><code>Array</code> doesn't need a trait because you can bind generically to any array already:</p>\n</blockquote>\n<p>Sure, but that's because of const generics.  If we have variadic generics, then the same applies to tuples:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">on_tuple</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"n\">T</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278451586,
        "sender_full_name": "scottmcm",
        "timestamp": 1649572364
    },
    {
        "content": "<p>im not convinced we need a tuple trait because if variadics doesnt give us an easy way to be generic over all tuples then I think we have hugely failed :D</p>",
        "id": 278451595,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649572393
    },
    {
        "content": "<p>Assuming variadics aren't implemented in terms of tuples, which is IMO a big assumption.</p>",
        "id": 278519643,
        "sender_full_name": "alercah",
        "timestamp": 1649664295
    },
    {
        "content": "<p>While I think it is good to think of the implementation of language features in terms of lowering to more fundamental features (e.g., variadics to tuples or async methods to GATs), I think it is a mistake to think we must expose that lowering in any way to users, either by making the translation possible in user code or even exposing the underlying features. So even if internally we use tuples here, I think that doesn't mean we should have or need a tuple trait</p>",
        "id": 278525430,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649667719
    },
    {
        "content": "<p>We dumped collections traits and similar things pre-1.0 and it was a great move, I think this kind of abstraction does not work well in Rust programs and I would be sad to have a tuple trait</p>",
        "id": 278525662,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649667848
    },
    {
        "content": "<p>I dont see how variadics _could_ be implemented in terms of tuples</p>",
        "id": 278532011,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649671640
    },
    {
        "content": "<p>how would you implement a trait for tuples of any length where all elements implement a trait?</p>",
        "id": 278532040,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649671658
    },
    {
        "content": "<p>if rust had trait generics i could somehow s ee that working... <code>impl&lt;T: Tuple&lt;Trait&gt;&gt; Trait for T</code></p>",
        "id": 278532406,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649671887
    },
    {
        "content": "<p>actually I guess with generic_const_exprs + <code>for&lt;N&gt; &lt;T as Tuple&gt;::Element&lt;N&gt;: Trait</code> bounds you could get it to work</p>",
        "id": 278533210,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649672364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/278532040\">said</a>:</p>\n<blockquote>\n<p>how would you implement a trait for tuples of any length where all elements implement a trait?</p>\n</blockquote>\n<p>Magically, obviosuly.</p>",
        "id": 278582339,
        "sender_full_name": "Lokathor",
        "timestamp": 1649695577
    },
    {
        "content": "<p>It depends on the trait :P</p>",
        "id": 278582393,
        "sender_full_name": "Lokathor",
        "timestamp": 1649695601
    },
    {
        "content": "<p>more helpfully: Step 1 is to treat the tuple as an array (field 0 is index 0, field 1 is index 1, etc), step 2 depends on the trait</p>",
        "id": 278582657,
        "sender_full_name": "Lokathor",
        "timestamp": 1649695694
    },
    {
        "content": "<p>So, suppose we wanted to do this for <code>PartialEq</code>. What would this look like?</p>",
        "id": 278583077,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649695867
    },
    {
        "content": "<p>You just PartialEq for a.0 and b.0, then a.1 and b.1, etc</p>",
        "id": 278585239,
        "sender_full_name": "Lokathor",
        "timestamp": 1649696734
    },
    {
        "content": "<p>just like how arrays do it</p>",
        "id": 278585249,
        "sender_full_name": "Lokathor",
        "timestamp": 1649696739
    },
    {
        "content": "<p>arrays implement iterator tuples dont :P</p>",
        "id": 278585341,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649696763
    },
    {
        "content": "<p>so the problem is easier there</p>",
        "id": 278585354,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649696767
    },
    {
        "content": "<p>like.. doing a.0 and b.0 then a.1 and b.1 is like the thing that is not clear how to actually _do_</p>",
        "id": 278585393,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649696790
    },
    {
        "content": "<p>I don't understand the concern, the compiler would generate the impl as if you'd written</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// magically however many are necessary</span>\n<span class=\"kc\">true</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278585551,
        "sender_full_name": "Lokathor",
        "timestamp": 1649696860
    },
    {
        "content": "<p>like i'm not proposing that code be written, i'm proposing that the compiler just do it internally</p>",
        "id": 278585592,
        "sender_full_name": "Lokathor",
        "timestamp": 1649696880
    },
    {
        "content": "<p>you're saying that the impls for partialeq on tuple should be a compiler generated thing?</p>",
        "id": 278586042,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649697066
    },
    {
        "content": "<p>we dont need variadics for that :P</p>",
        "id": 278586052,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649697069
    },
    {
        "content": "<p>No, we don't :3</p>",
        "id": 278586083,
        "sender_full_name": "Lokathor",
        "timestamp": 1649697086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  Pardon, I'm a bit confused. How would a user implement a non-standard library trait for tuples under your model?</p>",
        "id": 278608455,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1649707290
    },
    {
        "content": "<p>Oh, they wouldn't be able to. That's why magical things aren't so great and should be moved away from in the long term.</p>",
        "id": 278608614,
        "sender_full_name": "Lokathor",
        "timestamp": 1649707368
    },
    {
        "content": "<p>That's a fair point.</p>\n<p>I think my personal take would be that it'd still be valuable to go that direction early on, though, with an intent never to stabilize, because I imagine the syntax and its meaning is going to be a long and arduous bikeshed here.</p>\n<p>I think there's probably a lot of value out of something that works but ain't pretty to start with, to explore the space, eventually figure out whether more language support is necessary on top of that bare minimum, and then finally to paper over it all (and possibly make the implementation something more direct) at the end.</p>",
        "id": 278648667,
        "sender_full_name": "alercah",
        "timestamp": 1649739741
    },
    {
        "content": "<p>Oops, I got stuck scrolled up. That was continuing what <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> said above.</p>",
        "id": 278648689,
        "sender_full_name": "alercah",
        "timestamp": 1649739761
    },
    {
        "content": "<p>(given that this project has apparently been blessed in some capacity, should it get its own stream so we aren't cramming everything into one thread?)</p>",
        "id": 278648722,
        "sender_full_name": "alercah",
        "timestamp": 1649739822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/Variadics/near/278582657\">said</a>:</p>\n<blockquote>\n<p>more helpfully: Step 1 is to treat the tuple as an array (field 0 is index 0, field 1 is index 1, etc), step 2 depends on the trait</p>\n</blockquote>\n<p>If you do this then the element type is \"dependent pair\" and we don't want to go there.</p>",
        "id": 278649664,
        "sender_full_name": "alercah",
        "timestamp": 1649741147
    },
    {
        "content": "<p>or at least, that's the naive way to end up... the more enlightened way would be to treat the interior type as existential. and perhaps that works.</p>",
        "id": 278650143,
        "sender_full_name": "alercah",
        "timestamp": 1649741769
    }
]