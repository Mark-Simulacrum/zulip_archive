[
    {
        "content": "<p>And, on the same note: Bevy is interested in helping to drive forward a design on library-provided custom error messages.</p>\n<p>I'm likely to step up for this myself; I do much of the project management and documentation for the team, so I think I'm a solid fit.</p>",
        "id": 277913403,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649179098
    },
    {
        "content": "<p>This is something I'd also be interested in. I'm the author and maintainer of <a href=\"https://crates.io/crates/darling\"><code>darling</code></a>, which tries to be <code>serde</code>, but for proc-macros.</p>",
        "id": 278174516,
        "sender_full_name": "Ted Driggs",
        "timestamp": 1649342730
    },
    {
        "content": "<p>It may be relevant to look at what GHC does: <a href=\"https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/custom-type-errors\">https://gitlab.haskell.org/ghc/ghc/-/wikis/proposal/custom-type-errors</a> Basically you write the non-existent impl, but add a where clause requiring that a \"const generic\" representing the error message implements the TypeError trait (type family in haskell). You can also use the actual inferred generics and implementing type as part of the error message. I'm not sure if rust's type system is flexible enough for this approach though.</p>",
        "id": 278181711,
        "sender_full_name": "bjorn3",
        "timestamp": 1649345478
    },
    {
        "content": "<p>I think there are two aspects/buckets to this:</p>\n<ol>\n<li>Allowing macros to explicitly emit fancier diagnostics: Warnings, diagnostic chains, et cetera.</li>\n<li>Allowing macros to add context to errors emitted by the compiler.</li>\n</ol>\n<p>As a concrete example, <code>derive_builder</code> allows the user to specify the error type returned by the build function, like so:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Builder)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[builder(build_fn(error = </span><span class=\"s\">\"MyCustomError\"</span><span class=\"cp\">))]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Thing</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">name</span>: <span class=\"nb\">String</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">age</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>There are a few ways this could go wrong:</p>\n<ol>\n<li>The user passes something that isn't a string to <code>error =</code>. The macro can detect this, so it falls into bucket 1.</li>\n<li>The string the user passes to <code>error = </code> isn't a valid path. The macro can detect this too, so it also falls into bucket 1.</li>\n<li>The user passes a valid path, but it's not in scope. The macro can't detect this, so it falls into bucket 2.</li>\n<li>The user passes a valid path to an in-scope type, but it doesn't impl <code>From&lt;derive_builder::UninitializedFieldError&gt;</code>. This also falls into bucket 2.</li>\n<li>The user passes a valid path to an in-scope type with the required impls, but the type's visibility is less than that of the generated build method; maybe the build method is <code>pub</code> and the error type is <code>pub(crate)</code>. This is also bucket 2.</li>\n</ol>\n<p>My crate <code>darling</code> does everything it can to handle bucket 1 failures well (but is limited in what it can do, and I'm therefore eager for improvements to the diagnostics APIs). For bucket 2, the only option is to try and set the spans of the generated conversion code to point at the path. For this particular use-case that's probably good enough, but for more complex macros it would be difficult or impossible to do that; imagine if the macro has the user specify two paths, and the problem is that there's no <code>From</code> conversion between them.</p>\n<p>If I understand the Haskell article properly, it seems to help with these bucket 2 failures: The macro creates something that doesn't compile/type check, and the macro gets the opportunity to improve the error message on its way to the user. Is that a correct (albeit simplistic) understanding of it?</p>",
        "id": 278199107,
        "sender_full_name": "Ted Driggs",
        "timestamp": 1649352651
    },
    {
        "content": "<p>The only concern I have with the GHC style is that I think it would require reliance on specialization to work, right?</p>",
        "id": 278260707,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1649398178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"406353\">@Alice Cecile</span> <span class=\"user-mention\" data-user-id=\"488050\">@Ted Driggs</span> I think a good first step would be to outline the kinds of errors that you would be giving in a perfect world</p>",
        "id": 278364850,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1649453449
    },
    {
        "content": "<p>I'd rather we not start with mechanism</p>",
        "id": 278364867,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1649453462
    },
    {
        "content": "<p>if you like, I'd be game to schedule some time to chat about this and brainstorm a bit!</p>",
        "id": 278364899,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1649453479
    },
    {
        "content": "<p>Yep, I can absolutely provide that for Bevy's use cases at least.</p>",
        "id": 278371620,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649458340
    },
    {
        "content": "<p>Our problematic error messages are fundamentally centered around variadics, so there are quite a few possible fixes</p>",
        "id": 278371662,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649458393
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> +1 to starting with the goal in mind. I'll grab some examples from<code>derive_builder</code> early next week and share them here.</p>",
        "id": 278373588,
        "sender_full_name": "Ted Driggs",
        "timestamp": 1649460118
    },
    {
        "content": "<p>I would also be interested. We (pyo3) have some examples at <a href=\"https://github.com/PyO3/pyo3/tree/main/tests/ui\">https://github.com/PyO3/pyo3/tree/main/tests/ui</a> Some of these can have decent error messages created by a proc macro, but some are really bad</p>",
        "id": 278400348,
        "sender_full_name": "mejrs",
        "timestamp": 1649498121
    },
    {
        "content": "<p>I collected some at <a href=\"https://gist.github.com/mejrs/4199fefcf72e56567ecdd3c89b407ae2\">https://gist.github.com/mejrs/4199fefcf72e56567ecdd3c89b407ae2</a></p>",
        "id": 278434560,
        "sender_full_name": "mejrs",
        "timestamp": 1649543714
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249430\">@David Hewitt</span> can you think of any other really bad pyo3 errors?</p>",
        "id": 278434632,
        "sender_full_name": "mejrs",
        "timestamp": 1649543805
    },
    {
        "content": "<p>great!</p>",
        "id": 278721408,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1649782755
    }
]