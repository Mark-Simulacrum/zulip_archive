[
    {
        "content": "<p>While it's under \"looking forward\", I think it's worth mentioning that there was some movement (albeit quite small) on library-provided lints: <a href=\"https://github.com/rust-linting/design\">https://github.com/rust-linting/design</a> decided some of the larger points for the design of custom lints, including a plausible path towards MVP and future possibilities.</p>\n<p>Unfortunately no one really had time to drive the effort, so it stalled out. There is still interest in it among the org members, however. I know I would love to do some work here!</p>",
        "id": 277823197,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649128954
    },
    {
        "content": "<p>Hi! The Bevy team is interested in this, and we can likely find someone to own a design here :)</p>",
        "id": 277912911,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649178906
    },
    {
        "content": "<p>Also, the Clippy team was experimenting with a coccinelle-like custom lints API in <a href=\"https://github.com/rust-lang/rust-clippy/pull/3875\">https://github.com/rust-lang/rust-clippy/pull/3875</a> . It's a solid design, and I think there's a stalled implementation PR out there. There's also a masters thesis on it <a href=\"https://fkohlgrueber.github.io/thesis.pdf\">https://fkohlgrueber.github.io/thesis.pdf</a></p>\n<p>I'd _highly_ recommend folks try to build something off of this design.</p>\n<p>The basic idea is that lints are written as patterns that _look like rust code_, so you can kinda say \"if the code matches <code>&lt;code&gt;</code> then do ...\" where <code>&lt;code&gt;</code> is a bit of Rust code with placeholders.</p>\n<p>If paired with a good suite of utility functions for dealing with the typesystem, this can be super powerful whilst minimally constraining the internals of rustc (or any future compiler) on implementation.</p>\n<p>Happy to talk about this more; and also, happy to have this prototyped in clippy if folks need. Our utils/ module can probably inform y'all on what APIs outside of syntax tree matching are useful.</p>\n<p>Our goal was to eventually move over to this model for the bulk of our lints, reducing rust update churn</p>",
        "id": 277938406,
        "sender_full_name": "Manish Goregaokar",
        "timestamp": 1649190179
    },
    {
        "content": "<p>I really love that idea: the closer we can get to \"ordinary Rust syntax\" the more accessible this will be.</p>\n<p>Prototyping in Clippy first seems like an excellent idea.</p>",
        "id": 277938621,
        "sender_full_name": "Alice Cecile",
        "timestamp": 1649190316
    },
    {
        "content": "<p>Fwiw we were aware of that RFC during the discussions. If I remember correctly we agreed it wasn't necessary for the minimum viable product, as the primary challenge would be creating a stable API to work with. That would be necessary even with that RFC.</p>",
        "id": 277950460,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649196776
    },
    {
        "content": "<p>I haven't seen the thesis, though.</p>",
        "id": 277950471,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649196784
    },
    {
        "content": "<p>I would be interested in seeing something writable in terms of type-based matches / Rust-based patterns. I'm a big fan of smatch and coccinelle, and would love to have that capability for Rust built in.</p>",
        "id": 277975343,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649220508
    },
    {
        "content": "<p>I definitely don't want to make the perfect the enemy of the good, though, and I'm fine with semantically having matches on Rust code but having to write that out in a more longhand manner at first.</p>",
        "id": 277975359,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649220545
    },
    {
        "content": "<p>Super cool -- I've also been thinking about this as I work more on a-mir-formality. One thought I had was to go through the compiler's own lints and suggestions and try to \"dogfood\" them -- I think it should be possible to pattern match and describe patterns quite effectively. I'll check out <a href=\"https://github.com/rust-lang/rust-clippy/pull/3875\">https://github.com/rust-lang/rust-clippy/pull/3875</a>, <span class=\"user-mention\" data-user-id=\"132040\">@Manish Goregaokar</span>, since it sounds like it's going in a similar direction.</p>",
        "id": 278364251,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1649453082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/318377-t-lang.2Froadmap-2024/topic/blog.20post.20.E2.80.94.20custom.20lints/near/277950460\">said</a>:</p>\n<blockquote>\n<p>Fwiw we were aware of that RFC during the discussions. If I remember correctly we agreed it wasn't necessary for the minimum viable product, as the primary challenge would be creating a stable API to work with. That would be necessary even with that RFC.</p>\n</blockquote>\n<p>uh, one of the major benefits of that RFC is that it reduces the necessity of an actually stable API for dealing with the AST: you just need a (much narrower) stable API of various utils for checking type stuff, and AST matching is done entirely by macro</p>",
        "id": 278364561,
        "sender_full_name": "Manish Goregaokar",
        "timestamp": 1649453283
    },
    {
        "content": "<p>as someone who has thought way too much about AST stability in the context of clippy; I feel pretty confident in saying that this would likely be an _easier_ approach here</p>",
        "id": 278364635,
        "sender_full_name": "Manish Goregaokar",
        "timestamp": 1649453343
    },
    {
        "content": "<p>Hmm, that could be true. It's been a while since the discussions (last August I believe). Our intent was to base it off of syn, as its structure has remained largely unchanged (the missing support can be fixed).</p>",
        "id": 278385124,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649475240
    }
]