[
    {
        "content": "<p>I'm currently trying to see how an <code>undocumented_unsafe_blocks</code> lint could be implemented in clippy. AFAICT there are two possible solutions:</p>\n<ul>\n<li>use plain comments (<code>// SAFETY: ...</code>): this is the most natural approach, and is currently used in the standard library. However since comments are not included in the AST, this would require some hacks to get them. The way I'd do it is getting the source code from the <code>SourceMap</code> and lexing it with <code>rustc_lexer</code>.</li>\n<li>use doc comments (<code>/// SAFETY: ...</code>): this would probably be more surprising, but it can lead to some interesting ideas. Doc comments are kept in the AST (though discarded in the HIR), so no hacks would be required. The main problem which probably kills the idea is that attributes on expressions are experimental (<a href=\"https://github.com/rust-lang/rust/issues/15701\">#15701</a>).</li>\n</ul>\n<p>Would the hacks required for using plain comments be OK for use in clippy? Are there any other solutions I missed?</p>",
        "id": 248607223,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628254976
    },
    {
        "content": "<p>We have some lints which snip the code using <code>Span</code>s and then make a decision based on the returned <code>String</code>. However, all of them are Allow-by-default. Adding this in a similar fashion would be okay IMO, but probably also require it to be Allow-by-default. I would wait for some more feedback before diving into this.</p>\n<p>Another possibility would be to also put the lint behind the same feature gate as the \"doc comments on statement feature\". <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 248612387,
        "sender_full_name": "xFrednet",
        "timestamp": 1628257441
    },
    {
        "content": "<p>Discussed this with <span class=\"user-mention\" data-user-id=\"369415\">@xFrednet</span> and we noted that only attributes on expressions <em>inside statements</em> are experimental. So the following is accepted on stable:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// SAFETY: ...</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But this is not:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// SAFETY: ...</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* some reaaaaaaaaaaly long expression that causes line wrap */</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But most interestingly:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// SAFETY: ...</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// SAFETY: ...</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p><em>is</em> accepted.</p>",
        "id": 248614921,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628258636
    },
    {
        "content": "<p>I would probably use normal comments, snippets, and lexer. We have some lexer usage in SpanlessEq I believe.</p>",
        "id": 249064923,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1628652568
    },
    {
        "content": "<p>I have a close-to-working prototype</p>",
        "id": 249177677,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628720778
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/rust-lang/rust-clippy/issues/7557\">clippy#7557</a></p>",
        "id": 249182782,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628724536
    },
    {
        "content": "<p>Cool! Are you going to avoid lexing the entire file? You could get a span from the end of the previous statement to the start of the unsafe block.</p>",
        "id": 249193197,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1628737453
    }
]