[
    {
        "content": "<p>Hey everyone, </p>\n<p>Would love some guidance in how to implement <a href=\"https://github.com/rust-lang/rust-clippy/issues/8650\">this lint</a>.</p>\n<p><span class=\"user-mention\" data-user-id=\"264664\">@flip1995</span> suggested the following:</p>\n<blockquote>\n<p>This lint might be similar to the ptr_arg lint, but with the additional step of figuring out what the actual required type is. Maybe this can be done with expr_ty_adjusted, but if not this might be a bit more difficult with figuring out the actual type by looking at the function definition.<br>\nBut the ptr_arg lint should be a good starting point for figuring out if you're dealing with a type like &amp;String, &amp;Vec, ...</p>\n</blockquote>\n<p>I'm not 100% sure how to adjust <code>ptr_arg</code> for this as it's built for traits rather than free functions. Is it possible to reach function usages from a definition?</p>\n<p>Would something that detects free functions work for trait / impls?</p>\n<p>I did manage to reach the function definition from the usage earlier (other way around), in which case I need to be able to match an argument being <code>&amp;str</code>.</p>\n<p>It's possible to detect a call to <code>String::new()</code> like so:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">LateLintPass</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">UnnecessaryStringNew</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">check_expr</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">LateContext</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">expr</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">tcx</span> <span class=\"nc\">Expr</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">if_chain</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">Call</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">qpath</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">fn_def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">qpath_res</span><span class=\"p\">(</span><span class=\"n\">qpath</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"p\">.</span><span class=\"n\">hir_id</span><span class=\"p\">).</span><span class=\"n\">opt_def_id</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">match_def_path</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fn_def_id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">paths</span>::<span class=\"n\">STRING_NEW</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">//  [\"alloc\", \"string\", \"String\", \"new\"]</span>\n<span class=\"w\">            </span><span class=\"n\">then</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But this may not be the most efficient way to do so, I'm still getting familiar with the Clippy codebase.</p>\n<p>Additionally, is it possible to debug lints (interactively) using e.g. CLion?</p>\n<p>Thank you!</p>",
        "id": 278197675,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649351951
    },
    {
        "content": "<p>The similarity with <code>ptr_arg</code> I suspected exists is with detecting those suspcious types, like <code>&amp;String</code>, <code>&amp;Vec</code>, .... that have a non-owned alternative. Once you found such a type the lints aren't really similar anymore I guess. </p>\n<p>I assume that if you find a <code>&amp;String::new</code> and then call <code>cx.tcx.expr_ty_adjusted</code> on that expression, it might just return <code>&amp;str</code>.</p>\n<p>If that doesn't work and you already managed to reach the function def from the use site, then that's the way to go.</p>",
        "id": 278198237,
        "sender_full_name": "flip1995",
        "timestamp": 1649352237
    },
    {
        "content": "<p>No idea about <code>CLion</code>. I usually place many <code>dbg!()</code> macros into the lint to get a feeling for what I'm looking at</p>",
        "id": 278198335,
        "sender_full_name": "flip1995",
        "timestamp": 1649352276
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"264664\">@flip1995</span> !</p>\n<p>A few questions if you or anyone else has the time (I don't want to flood you with too many <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span>):</p>\n<ul>\n<li>What is <code>adjusted</code> referring to here?</li>\n<li>I'm not sure I understand the advice regarding calling <code>cx.tcx.expr_ty_adjusted</code> on <code>&amp;String::new</code>, do you mean it wouldn't be beneficial or that it would that be an easier way of detecting <code>&amp;String::new</code> vs <code>String::new</code>?</li>\n<li>Is there a way to go from <code>String::new()</code> to <code>&amp;String::new()</code>? Since I have to make sure that's what I'm matching rather than any arbitrary call to <code>String::new()</code></li>\n</ul>\n<p>Thank you!</p>",
        "id": 278198932,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649352570
    },
    {
        "content": "<ul>\n<li>Rust is able to dereference types automatically (and some other operations on types). This is the reason why you don't need an operator like <code>-&gt;</code> that you need in C. Those automatic type transformations are called \"adjustments\" in the compiler.</li>\n<li>It may be a way to find out, if the compiler actually needed an <code>&amp;str</code>.  So in the <code>check_expr</code> function you posted above, after you found the <code>&amp;String::new()</code> call, you can call <code>cx.tcx.expr_ty_adjusted(expr)</code> on the whole expression and check if that is <code>&amp;str</code>.</li>\n<li>Good question. No, not really, BUT why not go the other way around and start the <code>if_chain</code> with checking for an <code>ExprKind::Ref(expr2)</code>, and then check <code>expr2</code> if it is <code>String::new()</code></li>\n<li>You will get a <code>ty::Ty</code> from <code>expr_ty_adjusted</code>. Im pretty sure there is a <code>ty::TyKind::Str</code> or something similar you can check for.</li>\n</ul>",
        "id": 278199745,
        "sender_full_name": "flip1995",
        "timestamp": 1649352920
    },
    {
        "content": "<ul>\n<li>Got it, so essentially it could have been <code>expr_ty_dereferenced</code> in terms of the meaning</li>\n<li>Sounds good, that would probably be better than reaching the definition</li>\n<li>Will check it out, sounds promising!</li>\n<li>Same as above</li>\n</ul>\n<p>Thank you! Appreciate the help</p>",
        "id": 278200058,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649353079
    },
    {
        "content": "<ul>\n<li>Yes, but the compiler also does other cool things with types, like unsizing. But generally that is the mental model.</li>\n<li>Yeah, I hope that works.</li>\n</ul>",
        "id": 278200267,
        "sender_full_name": "flip1995",
        "timestamp": 1649353180
    },
    {
        "content": "<p><code>ExprKind::Ref</code> - does this exist in <code>rust_hir</code> or only in <code>rust_ast</code>? If not, do I need to use an early pass lint?</p>",
        "id": 278200696,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649353338
    },
    {
        "content": "<p>Oh in HIR it is <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/enum.ExprKind.html#variant.AddrOf\">ExprKind::AddrOf`</a>. You definitely need a LatePass, because you need type information. You don't have type information in an EarlyPass</p>",
        "id": 278200858,
        "sender_full_name": "flip1995",
        "timestamp": 1649353423
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 278200901,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649353443
    },
    {
        "content": "<p>Does the following make sense?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">LateLintPass</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">UnnecessaryStringNew</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">check_expr</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">LateContext</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">expr</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">tcx</span> <span class=\"nc\">Expr</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">if_chain</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">AddrOf</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inner_expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">Call</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">inner_expr</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">qpath</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">fn_def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">qpath_res</span><span class=\"p\">(</span><span class=\"n\">qpath</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"p\">.</span><span class=\"n\">hir_id</span><span class=\"p\">).</span><span class=\"n\">opt_def_id</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">match_def_path</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fn_def_id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">paths</span>::<span class=\"n\">STRING_NEW</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">//  [\"alloc\", \"string\", \"String\", \"new\"]</span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span>::<span class=\"n\">TyKind</span>::<span class=\"n\">Ref</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inner_str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">typeck_results</span><span class=\"p\">().</span><span class=\"n\">expr_ty_adjusted</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">).</span><span class=\"n\">kind</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">inner_str</span><span class=\"p\">.</span><span class=\"n\">is_str</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">then</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278202343,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649354080
    },
    {
        "content": "<p><del>Looks like it matches for <code>&amp;String</code> as well</del></p>",
        "id": 278203197,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649354416
    },
    {
        "content": "<p>Oh no nevermind, it doesn't</p>",
        "id": 278203294,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649354456
    },
    {
        "content": "<p>With suggestion:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">LateLintPass</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">UnnecessaryStringNew</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">check_expr</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">LateContext</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">expr</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">tcx</span> <span class=\"nc\">Expr</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">applicability</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Applicability</span>::<span class=\"n\">MachineApplicable</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">if_chain</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">AddrOf</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inner_expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">Call</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">args</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">inner_expr</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ExprKind</span>::<span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">qpath</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">fn_def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">qpath_res</span><span class=\"p\">(</span><span class=\"n\">qpath</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fun</span><span class=\"p\">.</span><span class=\"n\">hir_id</span><span class=\"p\">).</span><span class=\"n\">opt_def_id</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">match_def_path</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fn_def_id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">paths</span>::<span class=\"n\">STRING_NEW</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">//  [\"alloc\", \"string\", \"String\", \"new\"]</span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ty</span>::<span class=\"n\">TyKind</span>::<span class=\"n\">Ref</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inner_str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">typeck_results</span><span class=\"p\">().</span><span class=\"n\">expr_ty_adjusted</span><span class=\"p\">(</span><span class=\"n\">expr</span><span class=\"p\">).</span><span class=\"n\">kind</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">inner_str</span><span class=\"p\">.</span><span class=\"n\">is_str</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">then</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">span_lint_and_sugg</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">cx</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">UNNECESSARY_STRING_NEW</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">expr</span><span class=\"p\">.</span><span class=\"n\">span</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"s\">\"Detected a usage of `&amp;String::new()` for a function expecting a `&amp;str` argument\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"s\">\"try\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"s\">\"</span><span class=\"se\">\\\"\\\"</span><span class=\"s\">\"</span><span class=\"p\">.</span><span class=\"n\">to_owned</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">applicability</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278203908,
        "sender_full_name": "Yoav Lavi",
        "timestamp": 1649354745
    },
    {
        "content": "<p>You probably also want to check that the <code>AddrOf</code> is immutable. I'm pretty sure that converting <code>&amp;mut String</code> to <code>&amp;mut str</code> doesn't work.</p>\n<p>Otherwise this LGTM. Also no need to post code snippets of a whole lint here on Zulip <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> . You can open a WIP PR anytime. Then you also get the CI to tell you if something is wrong.</p>",
        "id": 278268394,
        "sender_full_name": "flip1995",
        "timestamp": 1649404698
    }
]