[
    {
        "content": "<p>There's been some interest in the Nintendo Switch homebrew community to try and get libstd support upstream. There's a pretty vibrant community but attempting to maintain out-of-tree libstd implementations has made things quite hard and a bit brittle due to maintenance burden.</p>\n<p>So me, <span class=\"user-mention\" data-user-id=\"239001\">@leo60228</span>, and possibly a few others would like to work on getting support for a homebrew-targeted toolchain upstreamed, while also leaving open the possibility of in the future there being a non-homebrew toolchain (e.g. one that links against the 'nnsdk' (Nintendo's sdk)) for those who want to just use Rust for officially supported Switch games, however that wouldn't be a part of what we want to upstream</p>",
        "id": 253445503,
        "sender_full_name": "jam1garner",
        "timestamp": 1631723643
    },
    {
        "content": "<p>There's been a bit of an attempt by leo in the past to upstream support all at once, however libstd moves quite fast and reviewer bandwidth for such an unpopular platform is small, so it fizzled out</p>",
        "id": 253445637,
        "sender_full_name": "jam1garner",
        "timestamp": 1631723690
    },
    {
        "content": "<p>One possibility that I think would prevent this happening again would be to start by upstreaming a very basic support first--thing something like wasm where there's no I/O or syncronization primatives aside from stubs</p>",
        "id": 253445900,
        "sender_full_name": "jam1garner",
        "timestamp": 1631723771
    },
    {
        "content": "<p>note that previous attempts were built on top of an existing libc, however i'd expect new attempts to be pure-rust</p>",
        "id": 253446108,
        "sender_full_name": "leo60228",
        "timestamp": 1631723836
    },
    {
        "content": "<p>However I just wanted to make sure that (a) such a target would be fine to upstream (similar homebrew toolchains for C/C++ have existed for a long time across many consoles with no legal issues, so I mainly mean in a technical sense) and (b) would a stubbed target be an acceptable approach to start?</p>",
        "id": 253446159,
        "sender_full_name": "jam1garner",
        "timestamp": 1631723853
    },
    {
        "content": "<p>(i recently learned that the developers of that libc are explicitly against supporting compilers that are not gcc/g++)</p>",
        "id": 253446169,
        "sender_full_name": "leo60228",
        "timestamp": 1631723858
    },
    {
        "content": "<p>Does it satisfy the following requirements?</p>\n<p><a href=\"https://rust-lang.github.io/rfcs/2803-target-tier-policy.html#tier-3-target-policy\">https://rust-lang.github.io/rfcs/2803-target-tier-policy.html#tier-3-target-policy</a></p>\n<ul>\n<li>Tier 3 targets may have unusual requirements to build or use, but must not create legal issues or impose onerous legal terms for the Rust project or for Rust developers or users. <br>\n    * The target must not introduce license incompatibilities.<br>\n    * Targets should not require proprietary (non-FOSS) components to link a functional binary or library.<br>\n    * \"onerous\" here is an intentionally subjective term. At a minimum, \"onerous\" legal/licensing terms include but are not limited to: non-disclosure requirements, non-compete requirements, contributor license agreements (CLAs) or equivalent, \"non-commercial\"/\"research-only\"/etc terms, requirements conditional on the employer or employment of any particular Rust developers, revocable terms, any requirements that create liability for the Rust project or its developers or users, or any requirements that adversely affect the livelihood or prospects of the Rust project or its developers or users.</li>\n</ul>",
        "id": 253446227,
        "sender_full_name": "bjorn3",
        "timestamp": 1631723882
    },
    {
        "content": "<p>This is the subset of all requirements for adding a tier 3 target that I am least certain about is met.</p>",
        "id": 253446434,
        "sender_full_name": "bjorn3",
        "timestamp": 1631723942
    },
    {
        "content": "<p>it wouldn't <em>impose</em> any legal terms</p>",
        "id": 253446455,
        "sender_full_name": "leo60228",
        "timestamp": 1631723950
    },
    {
        "content": "<p>Is there not for example proprietary blob you need to link against?</p>",
        "id": 253446644,
        "sender_full_name": "bjorn3",
        "timestamp": 1631724008
    },
    {
        "content": "<p>i see no reason to believe that the target would create legal issues, though it's definitely less clear-cut than linux</p>",
        "id": 253446646,
        "sender_full_name": "leo60228",
        "timestamp": 1631724009
    },
    {
        "content": "<p>no towards the proprietary blobs</p>",
        "id": 253446706,
        "sender_full_name": "jam1garner",
        "timestamp": 1631724029
    },
    {
        "content": "<p>to be clear the target currently being discussed would work via reverse engineered syscalls/etc</p>",
        "id": 253446805,
        "sender_full_name": "leo60228",
        "timestamp": 1631724067
    },
    {
        "content": "<p>i would not expect a non-reverse-engineered target to be upstreamed due to ndas</p>",
        "id": 253446960,
        "sender_full_name": "leo60228",
        "timestamp": 1631724122
    },
    {
        "content": "<p>(it's building against a cleanroom understanding of an interface, none of the code present would be reverse engineered/decompiled)</p>",
        "id": 253447013,
        "sender_full_name": "jam1garner",
        "timestamp": 1631724126
    },
    {
        "content": "<p>yeah</p>",
        "id": 253447039,
        "sender_full_name": "leo60228",
        "timestamp": 1631724138
    },
    {
        "content": "<p>also i think jam wrote a libstd port intended for game modding that uses the official sdk</p>",
        "id": 253447135,
        "sender_full_name": "leo60228",
        "timestamp": 1631724172
    },
    {
        "content": "<p>(the sdk is dynamically linked, so)</p>",
        "id": 253447210,
        "sender_full_name": "leo60228",
        "timestamp": 1631724197
    },
    {
        "content": "<p>but that's separate from what's being discussed here</p>",
        "id": 253447244,
        "sender_full_name": "leo60228",
        "timestamp": 1631724209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"322737\">jam1garner</span> <a href=\"#narrow/stream/219381-t-libs/topic/Upstreaming.20Nintendo.20Switch.20Support/near/253445900\">said</a>:</p>\n<blockquote>\n<p>One possibility that I think would prevent this happening again would be to start by upstreaming a very basic support first--thing something like wasm where there's no I/O or syncronization primatives aside from stubs</p>\n</blockquote>\n<p>that seems perfectly fine to me.</p>",
        "id": 253447431,
        "sender_full_name": "Mara",
        "timestamp": 1631724259
    },
    {
        "content": "<p>thank you mara &lt;3 I think that will make things a lot easier on both ends, I frankly felt bad for the reviewer last time <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 253447539,
        "sender_full_name": "jam1garner",
        "timestamp": 1631724301
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/88529#issuecomment-919938396\">https://github.com/rust-lang/rust/pull/88529#issuecomment-919938396</a> should be kept in mind, I think</p>",
        "id": 253449556,
        "sender_full_name": "simulacrum",
        "timestamp": 1631725025
    },
    {
        "content": "<p>if we were to go that route, what would 'legal review' entail? I'm assuming the Rust project has no means of providing us with legal review, but what type of service should be sought out if the burden of legal review is on us?</p>",
        "id": 253450460,
        "sender_full_name": "jam1garner",
        "timestamp": 1631725314
    },
    {
        "content": "<p>I'd email <a href=\"mailto:core@rust-lang.org\">core@rust-lang.org</a> and ask. I think it depends on the exact scope and proposal for what is being added and where.</p>",
        "id": 253450916,
        "sender_full_name": "simulacrum",
        "timestamp": 1631725459
    },
    {
        "content": "<p>we do have the means to provide legal review through the foundation</p>",
        "id": 253451085,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1631725532
    },
    {
        "content": "<blockquote>\n<p>I'm assuming the Rust project has no means of providing us with legal review</p>\n</blockquote>\n<p>the foundation and/or the core team might be able to provide that. the foundation handles a bunch of legal stuff.</p>",
        "id": 253451090,
        "sender_full_name": "Mara",
        "timestamp": 1631725534
    },
    {
        "content": "<p>Alright. I assume no_std support can proceed without anything requiring review, since it wouldn't require anything special, but once we near a point in which alloc/std support is being discussed we'll make sure to contact either the core team or the foundation about legal review</p>",
        "id": 253452156,
        "sender_full_name": "jam1garner",
        "timestamp": 1631725866
    },
    {
        "content": "<p>I recommend cc'ing both in the email</p>",
        "id": 253454693,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1631726777
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby</span> for the foundation I should use <a href=\"mailto:foundation@rust-lang.org\">foundation@rust-lang.org</a>, correct? (and ofc the core team email from above)</p>",
        "id": 253456755,
        "sender_full_name": "jam1garner",
        "timestamp": 1631727621
    },
    {
        "content": "<p>Correct</p>",
        "id": 253458203,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1631728174
    },
    {
        "content": "<p>Alright, thank you all!</p>",
        "id": 253459796,
        "sender_full_name": "jam1garner",
        "timestamp": 1631728722
    },
    {
        "content": "<p>What no_std support would be added? if you don't mind saying. For GBA support only a single division function was added to <code>compiler_builtins</code>, everything else worked out of the box.</p>",
        "id": 253480082,
        "sender_full_name": "Lokathor",
        "timestamp": 1631736801
    },
    {
        "content": "<p>Adding a compiler target I guess.</p>",
        "id": 253480226,
        "sender_full_name": "bjorn3",
        "timestamp": 1631736853
    },
    {
        "content": "<p>Yes, the inital PR is just adding a compiler target</p>",
        "id": 253490797,
        "sender_full_name": "jam1garner",
        "timestamp": 1631741320
    },
    {
        "content": "<p>sorry \"no_std support\" was a weird phrasing choice, my bad. the switch is not weird enough a target to require anything special in core</p>",
        "id": 253490890,
        "sender_full_name": "jam1garner",
        "timestamp": 1631741366
    },
    {
        "content": "<p>Here's the initial tier 3 target PR if anyone here wants to tag in for review: <a href=\"https://github.com/rust-lang/rust/pull/88991\">https://github.com/rust-lang/rust/pull/88991</a></p>",
        "id": 253492697,
        "sender_full_name": "jam1garner",
        "timestamp": 1631742193
    },
    {
        "content": "<p>This makes me ever so slightly want to add a \"gba\" tier 3 target that's separate from the current <code>thumbv4t-none-eabi</code> target and specifies an os and/or env of \"gba\".</p>\n<p>then again, i didn't even get off my butt to add a generic armv4t-none-eabi target, which would be far easier to get t-compiler to accept i think</p>",
        "id": 253514134,
        "sender_full_name": "Lokathor",
        "timestamp": 1631755556
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> imo that's actually a <em>good</em> idea, if only because then people making crates targeting it have a standardized cfg()</p>",
        "id": 253514684,
        "sender_full_name": "jam1garner",
        "timestamp": 1631755973
    },
    {
        "content": "<p>(I do not know if this is the general consensus--but being able to upstream that sort of thing so that more an more \"normal\" crates just work out of the box for these targets is something personally appealing to me)</p>",
        "id": 253514745,
        "sender_full_name": "jam1garner",
        "timestamp": 1631756035
    },
    {
        "content": "<p>Well when I added thumbv4t-none-eabi it started as being GBA specific, and then during the review process i was very slightly prodded to move it away from being GBA specific so that it could be more generally used.</p>\n<p>currently the <code>gba</code> crate is in a holding pattern, but it has a non-zero number of people other than me who comment on the issues and file PRs sometimes, so clearly it's used someone other than just myself. My own rust time has actually been spent working on a tutorial for GBA programming, which will take me probably quite some time more before it's done. Which is to say: I don't feel super rushed to decide either way.</p>",
        "id": 253515394,
        "sender_full_name": "Lokathor",
        "timestamp": 1631756490
    },
    {
        "content": "<p>I'm actually very interested that you're adding a linker script automatically. Is it well settled enough that no one would really need to change it?</p>",
        "id": 253515492,
        "sender_full_name": "Lokathor",
        "timestamp": 1631756543
    },
    {
        "content": "<p>Given the primary use case of this target is homebrew where the linkage is unfortunately kinda strict--yes</p>",
        "id": 253516022,
        "sender_full_name": "jam1garner",
        "timestamp": 1631756929
    },
    {
        "content": "<p>The switch homebrew loader that has become the standard has kinda an unfortunate environment in general--rather than use the OS standard format for dynamic libraries (nro) it uses a custom homebrew-only variation of it that isn't great, among some other criticisms I have but not conforming to it isn't really an option</p>",
        "id": 253516147,
        "sender_full_name": "jam1garner",
        "timestamp": 1631757023
    },
    {
        "content": "<p>ah fair. the GBA is in the baremetal subcategory of no_std, where the programmer has near-complete freedom about all memory usage, within the very light limits of the hardware itself. but no significant memory protection or anything like that.</p>",
        "id": 253516229,
        "sender_full_name": "Lokathor",
        "timestamp": 1631757105
    },
    {
        "content": "<p>well can't wait to see your tutorial, I've only used straight arm for GBA, Rust sounds like a fun time :)</p>",
        "id": 253516297,
        "sender_full_name": "jam1garner",
        "timestamp": 1631757144
    },
    {
        "content": "<p><a href=\"https://lokathor.github.io/gba-from-scratch/\">https://lokathor.github.io/gba-from-scratch/</a> (WIP and such)</p>",
        "id": 253516433,
        "sender_full_name": "Lokathor",
        "timestamp": 1631757252
    },
    {
        "content": "<p>awesome, will need to find my GBA and flashcart that I got for dev work then barely ever touched</p>",
        "id": 253516470,
        "sender_full_name": "jam1garner",
        "timestamp": 1631757283
    },
    {
        "content": "<p>i was thinking abt the actual libstd implementation</p>",
        "id": 253599795,
        "sender_full_name": "leo60228",
        "timestamp": 1631805903
    },
    {
        "content": "<p>the crate for interfacing with the system (<code>nx</code>) currently depends on <code>paste</code>,  <code>logpacket</code> (implementation of what's basically the switch's equivalent to syslog), <code>linked_list_allocator</code>, and <code>arrayvec</code></p>",
        "id": 253600068,
        "sender_full_name": "leo60228",
        "timestamp": 1631806011
    },
    {
        "content": "<p>(none of those themselves have any dependencies with the enabled features)</p>",
        "id": 253600102,
        "sender_full_name": "leo60228",
        "timestamp": 1631806022
    },
    {
        "content": "<p>for using <code>nx</code> in libstd</p>",
        "id": 253600152,
        "sender_full_name": "leo60228",
        "timestamp": 1631806040
    },
    {
        "content": "<p><code>nx</code> and <code>logpacket</code> would be easy</p>",
        "id": 253600180,
        "sender_full_name": "leo60228",
        "timestamp": 1631806052
    },
    {
        "content": "<p>with a libstd port it'd probably make sense to remove the <code>linked_list_allocator</code> dep and use <code>dlmalloc</code> in libstd</p>",
        "id": 253600257,
        "sender_full_name": "leo60228",
        "timestamp": 1631806079
    },
    {
        "content": "<p><code>arrayvec</code> i guess i should submit a PR adding <code>rustc-dep-of-std</code>....? i'm not sure it's really worth creating a bespoke version of <code>arrayvec</code> but i guess it'd be possible</p>",
        "id": 253600422,
        "sender_full_name": "leo60228",
        "timestamp": 1631806132
    },
    {
        "content": "<p>i honestly have no idea what to do abt <code>paste</code></p>",
        "id": 253600444,
        "sender_full_name": "leo60228",
        "timestamp": 1631806142
    },
    {
        "content": "<p>now that we have const generics, it'd be cool to have something like <code>arrayvec</code> in <code>std</code>.</p>",
        "id": 253600666,
        "sender_full_name": "Mara",
        "timestamp": 1631806223
    },
    {
        "content": "<p>like, i think <code>paste</code> is probably light enough as a dependency, esp. for only one target</p>",
        "id": 253601413,
        "sender_full_name": "leo60228",
        "timestamp": 1631806528
    },
    {
        "content": "<p>but i don't really understand how proc macros interact with the <code>rustc-dep-of-std</code> thing</p>",
        "id": 253601456,
        "sender_full_name": "leo60228",
        "timestamp": 1631806547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/Upstreaming.20Nintendo.20Switch.20Support/near/253600666\">said</a>:</p>\n<blockquote>\n<p>now that we have const generics, it'd be cool to have something like <code>arrayvec</code> in <code>std</code>.</p>\n</blockquote>\n<p>yeah, probably</p>",
        "id": 253601557,
        "sender_full_name": "leo60228",
        "timestamp": 1631806573
    },
    {
        "content": "<p>i'd be fine adding that in its own PR but it feels like smth that probably deserves an RFC</p>",
        "id": 253601605,
        "sender_full_name": "leo60228",
        "timestamp": 1631806593
    },
    {
        "content": "<p>I don't think having libstd depend on proc macros is a good idea. It may give problems with cross-compiling. They already need a hack when cross compiling rustc.</p>",
        "id": 253603645,
        "sender_full_name": "bjorn3",
        "timestamp": 1631807419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/219381-t-libs/topic/Upstreaming.20Nintendo.20Switch.20Support/near/253603645\">said</a>:</p>\n<blockquote>\n<p>I don't think having libstd depend on proc macros is a good idea. It may give problems with cross-compiling. They already need a hack when cross compiling rustc.</p>\n</blockquote>\n<p>that's fair</p>",
        "id": 253604215,
        "sender_full_name": "leo60228",
        "timestamp": 1631807653
    },
    {
        "content": "<p>i haven't actually touched the code using it myself until now</p>",
        "id": 253604220,
        "sender_full_name": "leo60228",
        "timestamp": 1631807655
    },
    {
        "content": "<p>let me make a simplified version of how it's used, one sec</p>",
        "id": 253604318,
        "sender_full_name": "leo60228",
        "timestamp": 1631807692
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d1e460ff12120c220d1cbff48b7fc34b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d1e460ff12120c220d1cbff48b7fc34b</a></p>",
        "id": 253605209,
        "sender_full_name": "leo60228",
        "timestamp": 1631808021
    },
    {
        "content": "<p>ofc the actual use is more complex</p>",
        "id": 253605241,
        "sender_full_name": "leo60228",
        "timestamp": 1631808030
    },
    {
        "content": "<p>but this is the idea</p>",
        "id": 253605251,
        "sender_full_name": "leo60228",
        "timestamp": 1631808033
    },
    {
        "content": "<p>hm, i haven't looked super closely, but i think this might work</p>",
        "id": 253605391,
        "sender_full_name": "leo60228",
        "timestamp": 1631808093
    },
    {
        "content": "<p>I've looked back through it (haven't played with XorTroll's stuff in a while) and all the paste usage seems like it could be replaced with either a build script or ahead-of-time codegen</p>",
        "id": 253606125,
        "sender_full_name": "jam1garner",
        "timestamp": 1631808386
    },
    {
        "content": "<p>it also might be worth assessing what parts of nx-rs we actually need and possibly working with XorTroll to split nx-rs into multiple crates and possibly only depend on the core of it</p>",
        "id": 253606275,
        "sender_full_name": "jam1garner",
        "timestamp": 1631808457
    },
    {
        "content": "<p>I think also reducing the surface area of the switch-specific code needed to be reviewed might make the legal assessment easier, nx-rs has gotten decently large for what we need of it</p>",
        "id": 253606535,
        "sender_full_name": "jam1garner",
        "timestamp": 1631808548
    },
    {
        "content": "<p>it's currently roughly 12k lines of Rust (and that's not even including the code generated by said macros for IPC) which imo is probably overkill for what we need (effectively a libc level of abstraction, but a very small portion of what libc's API covers)</p>",
        "id": 253606843,
        "sender_full_name": "jam1garner",
        "timestamp": 1631808660
    },
    {
        "content": "<p>I think another benefit of such an approach is that we'd be able to assess and improve XorTroll's code while moving the parts we need to a separate library. I think it'd be in our best interest as well to do a pass over all the code we depend on (both from a technical and legal perspective) so it'd be knocking out two birds with one stone.</p>",
        "id": 253607177,
        "sender_full_name": "jam1garner",
        "timestamp": 1631808782
    },
    {
        "content": "<p><code>tinyvec</code>, if it can cover your use case, is already somewhere within the standard library overall</p>",
        "id": 253607259,
        "sender_full_name": "Lokathor",
        "timestamp": 1631808814
    },
    {
        "content": "<p>it has an arrayvec style struct and also a smallvec style enum</p>",
        "id": 253607369,
        "sender_full_name": "Lokathor",
        "timestamp": 1631808844
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"322737\">jam1garner</span> <a href=\"#narrow/stream/219381-t-libs/topic/Upstreaming.20Nintendo.20Switch.20Support/near/253606125\">said</a>:</p>\n<blockquote>\n<p>I've looked back through it (haven't played with XorTroll's stuff in a while) and all the paste usage seems like it could be replaced with either a build script or ahead-of-time codegen</p>\n</blockquote>\n<p>fwiw</p>",
        "id": 253609058,
        "sender_full_name": "leo60228",
        "timestamp": 1631809527
    },
    {
        "content": "<p>i came up with an extremely evil hack to keep using decl macros for codegen without removing any functionality</p>",
        "id": 253609086,
        "sender_full_name": "leo60228",
        "timestamp": 1631809545
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=369d35c0d8401101a95b055c68609ef9\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=369d35c0d8401101a95b055c68609ef9</a></p>",
        "id": 253609089,
        "sender_full_name": "leo60228",
        "timestamp": 1631809546
    },
    {
        "content": "<p>oops</p>",
        "id": 253622570,
        "sender_full_name": "leo60228",
        "timestamp": 1631814885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/Upstreaming.20Nintendo.20Switch.20Support/near/253607259\">said</a>:</p>\n<blockquote>\n<p><code>tinyvec</code>, if it can cover your use case, is already somewhere within the standard library overall</p>\n</blockquote>\n<p>is it vendored? it seems to be a dependency of rustc but not libstd</p>",
        "id": 253622649,
        "sender_full_name": "leo60228",
        "timestamp": 1631814915
    },
    {
        "content": "<p>I don't think it is vendored.</p>",
        "id": 253622876,
        "sender_full_name": "bjorn3",
        "timestamp": 1631815011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/Upstreaming.20Nintendo.20Switch.20Support/near/253600666\">said</a>:</p>\n<blockquote>\n<p>now that we have const generics, it'd be cool to have something like <code>arrayvec</code> in <code>std</code>.</p>\n</blockquote>\n<p>was thinking about how to implement this since it'd share a ton of code with vec</p>",
        "id": 253624036,
        "sender_full_name": "leo60228",
        "timestamp": 1631815424
    },
    {
        "content": "<p>and i had a possibly-excessively-clever idea</p>",
        "id": 253624062,
        "sender_full_name": "leo60228",
        "timestamp": 1631815437
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">RawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ArrayRawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">([</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">RawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ArrayRawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">HeapRawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">Allocator</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">Allocator</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">RawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">HeapRawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">AbstractVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span>: <span class=\"nc\">RawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">ArrayVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">AbstractVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ArrayRawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">Allocator</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">HeapRawVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 253624849,
        "sender_full_name": "leo60228",
        "timestamp": 1631815698
    },
    {
        "content": "<p>biggest issue i see is how to make rustdoc not be confusing</p>",
        "id": 253624988,
        "sender_full_name": "leo60228",
        "timestamp": 1631815757
    },
    {
        "content": "<p>if <code>ArrayVec</code> was in <code>alloc</code> then this would be easier</p>",
        "id": 253625067,
        "sender_full_name": "leo60228",
        "timestamp": 1631815786
    },
    {
        "content": "<p>since it could be <code>pub struct Vec&lt;T, R: RawVec&lt;T&gt; = HeapRawVec&lt;T&gt;&gt;</code></p>",
        "id": 253625159,
        "sender_full_name": "leo60228",
        "timestamp": 1631815808
    },
    {
        "content": "<p>but i don't think <code>ArrayVec</code> <em>should</em> be in <code>alloc</code></p>",
        "id": 253625203,
        "sender_full_name": "leo60228",
        "timestamp": 1631815825
    },
    {
        "content": "<p>see also <a href=\"https://internals.rust-lang.org/t/is-custom-allocators-the-right-abstraction/13460\">https://internals.rust-lang.org/t/is-custom-allocators-the-right-abstraction/13460</a><br>\nAnd there also is an open arrayvec RFC but it hasn't made much progress lately.</p>",
        "id": 253625233,
        "sender_full_name": "The 8472",
        "timestamp": 1631815842
    },
    {
        "content": "<blockquote>\n<p>is it vendored? it seems to be a dependency of rustc but not libstd</p>\n</blockquote>\n<p>oh oops. I knew it was used by \"some unicode stuff\" and figured that was the standard library.</p>",
        "id": 253625368,
        "sender_full_name": "Lokathor",
        "timestamp": 1631815891
    },
    {
        "content": "<p>do you have a link to that rfc? i looked for one but didn't see anything</p>",
        "id": 253625628,
        "sender_full_name": "leo60228",
        "timestamp": 1631815990
    },
    {
        "content": "<p>oh, not sure how i didnt see it <a href=\"https://github.com/rust-lang/rfcs/pull/2990\">https://github.com/rust-lang/rfcs/pull/2990</a></p>",
        "id": 253625681,
        "sender_full_name": "leo60228",
        "timestamp": 1631816014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Upstreaming.20Nintendo.20Switch.20Support/near/253625233\">said</a>:</p>\n<blockquote>\n<p>see also <a href=\"https://internals.rust-lang.org/t/is-custom-allocators-the-right-abstraction/13460\">https://internals.rust-lang.org/t/is-custom-allocators-the-right-abstraction/13460</a><br>\nAnd there also is an open arrayvec RFC but it hasn't made much progress lately.</p>\n</blockquote>\n<p>my main thought with the rfc is just that <code>Vec</code> and <code>ArrayVec</code> would share far more than they don't</p>",
        "id": 253626262,
        "sender_full_name": "leo60228",
        "timestamp": 1631816236
    },
    {
        "content": "<p>only including stable methods</p>",
        "id": 253626491,
        "sender_full_name": "leo60228",
        "timestamp": 1631816320
    },
    {
        "content": "<p>for <code>Vec</code>:</p>\n<ul>\n<li><code>reserve</code> and <code>reserve_exact</code> don't necessarily make sense but can just be an <code>assert!</code></li>\n<li><code>shrink_to_fit</code> doesn't make sense but it being a no-op wouldn't violate the API contract</li>\n<li><code>with_capacity</code>, <code>into_boxed_slice</code>,  and <code>from_raw_parts</code> don't make sense</li>\n</ul>",
        "id": 253626894,
        "sender_full_name": "leo60228",
        "timestamp": 1631816478
    },
    {
        "content": "<p>for <code>RawVec</code>:</p>\n<ul>\n<li><code>with_capacity</code>, <code>with_capacity_zeroed</code>, <code>from_raw_parts</code>, <code>new_in</code>, <code>with_capacity_in</code>, <code>with_capacity_zeroed_in</code>, <code>from_box</code>, <code>into_box</code>, <code>from_raw_parts_in</code>, and <code>allocator</code> should just be moved to <code>HeapRawVec</code></li>\n<li>alternatives to <code>ptr</code> that return <code>&amp;[MaybeUninit&lt;T&gt;]</code>/<code>&amp;mut [MaybeUninit&lt;T&gt;]</code> aren't necessary, but with the added complexity might be nice to help catch bugs</li>\n</ul>",
        "id": 253627402,
        "sender_full_name": "leo60228",
        "timestamp": 1631816679
    },
    {
        "content": "<p>Depends on what you want to happen when the capacity is reached, errors or panics. That's similar to the fallible vec topic.</p>",
        "id": 253628292,
        "sender_full_name": "The 8472",
        "timestamp": 1631817028
    },
    {
        "content": "<p>If <code>ArrayVec</code> was in std, it would be much better to have errors than panics. Exhaustion of the buffer is exactly the kind of edge case you want end users thinking about, and panics hide the issue</p>",
        "id": 253628517,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631817128
    },
    {
        "content": "<p>Well, it doesn't hurt to have both panicking and erroring versions of these methods (I think the <code>arrayvec</code> crate already does this), but in that case I would use a clippy lint to make sure I never call the wrong one, because it's a footgun</p>",
        "id": 253629513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631817531
    }
]