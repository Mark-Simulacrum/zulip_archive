[
    {
        "content": "<p>Split off from <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/273965148\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/273965148</a></p>",
        "id": 274099472,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384780
    },
    {
        "content": "<p>Open question: <a href=\"https://github.com/rust-lang/rfcs/pull/2930#issuecomment-688933597\">https://github.com/rust-lang/rfcs/pull/2930#issuecomment-688933597</a></p>",
        "id": 274099518,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384807
    },
    {
        "content": "<p>Which I think comes down to should the buffer type be <code>&amp;mut ReadBuf</code> or <code>ReadBufRef</code>. The latter prevents the callee swapping out the buffer for a different one, but requires an extra type, and makes for slightly more boilerplate to set up the buffer</p>",
        "id": 274099825,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384992
    },
    {
        "content": "<p>The motivation (aiui) is that if the implementation is malicious and the caller keeps the initialised length across the call, then they might accidentally access uninitialised memory.</p>",
        "id": 274100024,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646385106
    },
    {
        "content": "<p>To me, this seems unlikely. The fact that the caller is passing a &amp;mut reference in to the read call means they shouldn't rely on a property of the <br>\nbuffer from before the call, rather they should interact with the buffer using only its methods and state after the call. Furthermore, this problem only arises if the implementation of read is actively malicious, and I think in general we do not try to protect against such a case (it seems impossible to do so since a malicious impl could always just use unsafe code to do whatever they want).</p>",
        "id": 274100506,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646385363
    },
    {
        "content": "<p>This protects against accidental errors and potential unsound usage.<br>\nThese two arguments are in my opinion more than enough compared to the disadvantages.</p>",
        "id": 274101276,
        "sender_full_name": "Urgau",
        "timestamp": 1646385770
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327095\">Urgau</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274101276\">said</a>:</p>\n<blockquote>\n<p>This protects against accidental errors and potential unsound usage.</p>\n</blockquote>\n<p>AIUI, there is no actual unsoundness, just a footgun which is fairly easy to avoid (i.e., its only a footgun if you assume a mutable reference will not in fact be mutated which IMO is an unreasonable assumption). And it doesn't protect against accidental errors, only deliberate ones, again AIUI.</p>",
        "id": 274101884,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646386053
    },
    {
        "content": "<p>The unsoudness I was referring is in the consumer not in the implementation of a <code>read_buf</code>, which would be painful and difficult to debug.<br>\nYou could have a method that does some things with a <code>&amp;mut ReadBuf</code> then accidentally replacing the buffer maybe with a opaque macro; there are may cases where it could append accidentally.</p>",
        "id": 274103018,
        "sender_full_name": "Urgau",
        "timestamp": 1646386516
    },
    {
        "content": "<p>Btw <a href=\"https://github.com/rust-lang/rust/issues/93305\">https://github.com/rust-lang/rust/issues/93305</a> reports it as unsound.</p>",
        "id": 274103240,
        "sender_full_name": "Urgau",
        "timestamp": 1646386618
    },
    {
        "content": "<p>Yeah, I understand the unsoundness is in the consumer, but I don't think it is actually unsound :-)  Could you give an example of how you think an issue could occur?</p>",
        "id": 274103245,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646386620
    },
    {
        "content": "<p>Reasoning it out:<br>\nIn general, anytime entirely safe code can cause the invocation of UB, that's a soundness bug.<br>\nThis includes if the safe code can cause unsafe code to invoke UB.<br>\nThus, unsafe code can't rely on assumptions that safe code won't do a thing that it's capable of doing, if violating those assumptions would lead to UB.</p>",
        "id": 274103558,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646386799
    },
    {
        "content": "<p>In this case, entirely safe code can cause the reading of uninitialized memory.</p>",
        "id": 274103626,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646386818
    },
    {
        "content": "<p>Well I guess it depends if you consider accessing uninit memory as unsound. If that's the case the issue as an example.</p>",
        "id": 274103632,
        "sender_full_name": "Urgau",
        "timestamp": 1646386821
    },
    {
        "content": "<p>That's leaving aside that I personally <em>do</em> think that reading uninitialized memory shouldn't be undefined behavior, but...yes, exactly. If you <em>do</em> consider that UB, which our current definitions do, then read_buf is unsound with just <code>&amp;mut ReadBuf</code>.</p>",
        "id": 274103687,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646386864
    },
    {
        "content": "<p>I think there is a missing step in that reasoning in that it is only unsound if the programmer doesn't make a mistake, like if I write <code>unsafe { buf.set_len(42); }</code> that is not unsoundness its just a mistake</p>",
        "id": 274104247,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387157
    },
    {
        "content": "<p>In this case it is the same thing, the programmer is assuming that the underlying buffer and the read buf are the same, which is not guaranteed after passing a &amp;mut ref to the read buf to another function</p>",
        "id": 274104373,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104247\">said</a>:</p>\n<blockquote>\n<p>I think there is a missing step in that reasoning in that it is only unsound if the programmer doesn't make a mistake, like if I write <code>unsafe { buf.set_len(42); }</code> that is not unsoundness its just a mistake</p>\n</blockquote>\n<p>It's still unsoundness if you provide a safe interface that can result in calling set_len incorrectly.</p>",
        "id": 274104438,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646387264
    },
    {
        "content": "<p>So this is a programming mistake, not unsoundess. The question is whether the programming mistake is a reasonable one. It kind of is, so this is a footgun</p>",
        "id": 274104444,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104438\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104247\">said</a>:</p>\n<blockquote>\n<p>I think there is a missing step in that reasoning in that it is only unsound if the programmer doesn't make a mistake, like if I write <code>unsafe { buf.set_len(42); }</code> that is not unsoundness its just a mistake</p>\n</blockquote>\n<p>It's still unsoundness if you provide a safe interface that can result in calling set_len incorrectly.</p>\n</blockquote>\n<p>I don't follow. <code>set_len</code> is unsafe, setting it incorrectly is easy, just set it to something wrong. In this case, it is being set to something that is not guaranteed by the API in any way</p>",
        "id": 274104595,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387355
    },
    {
        "content": "<p>It's just as wrong as setting it to 42</p>",
        "id": 274104620,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104595\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104438\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104247\">said</a>:</p>\n<blockquote>\n<p>I think there is a missing step in that reasoning in that it is only unsound if the programmer doesn't make a mistake, like if I write <code>unsafe { buf.set_len(42); }</code> that is not unsoundness its just a mistake</p>\n</blockquote>\n<p>It's still unsoundness if you provide a safe interface that can result in calling set_len incorrectly.</p>\n</blockquote>\n<p>I don't follow. <code>set_len</code> is unsafe, setting it incorrectly is easy, just set it to something wrong.</p>\n</blockquote>\n<p>Since <code>set_len</code> is <code>unsafe</code>, you normally can't call it except from <code>unsafe</code> code. Calling it incorrectly in unsafe code isn't automatically a soundness issue, but calling it incorrectly in unsafe code with a safe interface is unsound.</p>",
        "id": 274104954,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646387548
    },
    {
        "content": "<p>Sure, so in the case of the issue, using <code>io::copy_to</code> is unsound, but that is due to an error with the implementation, not because the API of BufReader or buf_read is unsound, that is just a footgun that led to the unsoundness</p>",
        "id": 274105172,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387644
    },
    {
        "content": "<p>I think I'm confused about the distinction you're making. But in any case, it sounds like you're still agreeing that it's a footgun.</p>",
        "id": 274105322,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646387719
    },
    {
        "content": "<p>And I don't think we want people to have to go out of their way to avoid that footgun.</p>",
        "id": 274105364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646387741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104373\">said</a>:</p>\n<blockquote>\n<p>In this case it is the same thing, the programmer is assuming that the underlying buffer and the read buf are the same, which is not guaranteed after passing a &amp;mut ref to the read buf to another function</p>\n</blockquote>\n<p>That's the problem, it's not guaranteed but it should be!</p>",
        "id": 274105384,
        "sender_full_name": "Urgau",
        "timestamp": 1646387750
    },
    {
        "content": "<p>So, the distinction I'm making is that the signature of Read::buf_read is not a soundness problem, it is potentially a footgun, but I think it is an important distinction because we <em>must</em> fix unsoundness, fixing footguns is a tradeoff question</p>",
        "id": 274105532,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387830
    },
    {
        "content": "<p>I don't think I'm suggesting that <code>ReadBuf</code> or <code>read_buf</code> is unsound. I'm suggesting that the usage in <code>io::copy</code> seems to make <code>io::copy</code> unsound, and that what we'd have to do to fix that we shouldn't have to do.</p>",
        "id": 274105761,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646387937
    },
    {
        "content": "<p>And I expect others to make exactly the same \"mistake\".</p>",
        "id": 274105828,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646387982
    },
    {
        "content": "<p>And it is only a footgun in the presence of actively malicious code. If we change from <code>&amp;mut ReadBuf</code> to <code>ReadBufRef</code>,  a malicious read impl could still cause an error by transmuting the ReadBuf and just setting the init length to something untrue.</p>",
        "id": 274106027,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646388024
    },
    {
        "content": "<p><code>transmute</code> is unsafe, and it's not unsound to rely on people not doing incorrect things in unsafe code.</p>",
        "id": 274106282,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388097
    },
    {
        "content": "<p><code>ReadBufRef</code> means it's no longer possible (as far as we know) to write <em>safe</em> code that violates the assumptions of unsafe code in callers that leads to UB.</p>",
        "id": 274106472,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388199
    },
    {
        "content": "<p>So, I'm not sure I understand the constraints on what is acceptable. Lets ignore copy_to for now because that is just a bug and we all agree it needs to be fixed. For buf_read, there is the caller and the implementer. It seems that there is only an issue if the caller makes a logic error (assuming something mutable is in fact immutable) and if the implementer is being actively malicious. Currently they can be actively malicious with only safe code, by changing to BufReadRef we eliminate the possibility of the caller making the logic error. And now to cause an error the malicious implementer must use unsafe code in their impl. This seems to me like a technicality since the presence of unsafe code in an IO method  is totally expected, so a simple audit of safe vs unsafe will not suffice.</p>",
        "id": 274106858,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646388414
    },
    {
        "content": "<p>We don't currently treat unsoundness as having an \"except for malicious code\" exception. Many soundness bugs in the past have effectively required malicious safe code to exploit. We still treated them as soundness bugs.</p>",
        "id": 274107077,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388533
    },
    {
        "content": "<p>And while yes, it's an error to assume the whole buffer can't be replaced, validating that assumption seems like a pain.</p>",
        "id": 274107150,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388578
    },
    {
        "content": "<p>Right, so this is where the soundness/footgun distinction is important. We should fix copy because that is unsoundness, I'm not sure we should fix buf_read since that is not unsound</p>",
        "id": 274107184,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646388598
    },
    {
        "content": "<p>What would the fix to copy look like if we <em>don't</em> fix <code>read_buf</code>?</p>",
        "id": 274107307,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388642
    },
    {
        "content": "<p>(Also, aside, you keep writing <code>buf_read</code>, and I'm wondering if that's a typo or if there's some proposal I'm not aware of to change the name?)</p>",
        "id": 274107421,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388716
    },
    {
        "content": "<p>We have several unsoundness bugs that have no accidental occurrences. Simply declaring them as \"footgun, not unsound\" seems very problematic to me. Introducing a new one in full knowledge of that even more so</p>",
        "id": 274107488,
        "sender_full_name": "oli",
        "timestamp": 1646388729
    },
    {
        "content": "<p>I am fine discussing that point, but it seems independent of the read_buf situation. Can we pull it out to a separate thread in the lang team stream?</p>",
        "id": 274107633,
        "sender_full_name": "oli",
        "timestamp": 1646388827
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274106858\">said</a>:</p>\n<blockquote>\n<p>And now to cause an error the malicious implementer must use unsafe code in their impl. This seems to me like a technicality since the presence of unsafe code in an IO method  is totally expected, so a simple audit of safe vs unsafe will not suffice.</p>\n</blockquote>\n<p>\"you can never cause UB via only safe code\" is part of Rust's definition of soundness. I don't think that's a technicality.</p>",
        "id": 274107636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388829
    },
    {
        "content": "<p>(Related: I'm looking into some automated schemes for detecting unsoundness. If I can't rely on \"no unsafe, but UB\" as the marker I'm looking for, I don't know what to rely on instead)</p>",
        "id": 274107944,
        "sender_full_name": "oli",
        "timestamp": 1646388982
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274107307\">said</a>:</p>\n<blockquote>\n<p>What would the fix to copy look like if we <em>don't</em> fix <code>read_buf</code>?</p>\n</blockquote>\n<p>In this case, check the buffer hasn't changed. But that is because in copy_to the ReadBuf is not available to the user and when relying on state of the ReadBuf to modify the underlying buffer, it should verify the assumption that it is in fact underlying still. If the user is using read_buf directly, then they can just use the ReadBuf directly without comparing with the original buffer.</p>",
        "id": 274108181,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274107421\">said</a>:</p>\n<blockquote>\n<p>(Also, aside, you keep writing <code>buf_read</code>, and I'm wondering if that's a typo or if there's some proposal I'm not aware of to change the name?)</p>\n</blockquote>\n<p>No, just a typo, sorry :-)</p>",
        "id": 274108213,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274107633\">said</a>:</p>\n<blockquote>\n<p>I am fine discussing that point, but it seems independent of the read_buf situation. Can we pull it out to a separate thread in the lang team stream?</p>\n</blockquote>\n<p>I'm not saying that at all. The unsoundness in copy_to should be fixed and is unsoundness not a footgun. The API of BufRead is a contributor to that unsoundness, but not unsound in itself and therefore I think is <em>just a footgun</em>.</p>",
        "id": 274108368,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389218
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274107636\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274106858\">said</a>:</p>\n<blockquote>\n<p>And now to cause an error the malicious implementer must use unsafe code in their impl. This seems to me like a technicality since the presence of unsafe code in an IO method  is totally expected, so a simple audit of safe vs unsafe will not suffice.</p>\n</blockquote>\n<p>\"you can never cause UB via only safe code\" is part of Rust's definition of soundness. I don't think that's a technicality.</p>\n</blockquote>\n<p>Right, but that only applies to copy_to, not read_buf. There is no way to cause UB using only safe code and read_buf. copy_to is unsound because it uses unsafe code internally</p>",
        "id": 274108472,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389297
    },
    {
        "content": "<p>I agree that <code>read_buf</code> isn't unsound, it's just a footgun that's likely to make more people write unsound code when using it.</p>",
        "id": 274108584,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389357
    },
    {
        "content": "<p>And we have a way to completely prevent that.</p>",
        "id": 274108615,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389380
    },
    {
        "content": "<p>Ah, ok, I misunderstood</p>",
        "id": 274108676,
        "sender_full_name": "oli",
        "timestamp": 1646389426
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274108615\">said</a>:</p>\n<blockquote>\n<p>And we have a way to completely prevent that.</p>\n</blockquote>\n<p>Right, so I think it is worth considering the tradeoff here of ergonomics vs safety here, bearing in mind that we're helping people avoid writing unsound code, not actually fixing an unsoundness.</p>",
        "id": 274108886,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389559
    },
    {
        "content": "<p>On a different note: I may be missing something obvious, but I'm wondering if we could <em>just</em> expose <code>ReadBufRef</code> and not <code>ReadBuf</code>.</p>",
        "id": 274108953,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389573
    },
    {
        "content": "<p>I think that if the caller wants to access the ReadBuf, then we need both? I guess the ReadBufRef could be cloned?</p>",
        "id": 274109020,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389620
    },
    {
        "content": "<p>ReadBuf already holds a reference to a buffer, rather than owning the buffer.<br>\n<em>Oh</em>, that's the obvious thing I'm missing, you wouldn't be able to pass it without giving it away.</p>",
        "id": 274109058,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389647
    },
    {
        "content": "<p>right</p>",
        "id": 274109074,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389656
    },
    {
        "content": "<p>/me wonders how much overhead it'd be to make <code>ReadBuf</code> hold a <code>Cow</code> rather than a reference.</p>",
        "id": 274109204,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389724
    },
    {
        "content": "<p>But something like: </p>\n<div class=\"codehilite\"><pre><span></span><code>let buf = ReadBufRef::new(...);\nreader.read_buf(buf.clone())?;\n// use buf\n</code></pre></div>\n<p>would work</p>",
        "id": 274109207,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389725
    },
    {
        "content": "<p>It would, but that clone wouldn't be free.</p>",
        "id": 274109239,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389741
    },
    {
        "content": "<p>It would be pretty cheap since it would only clone the ref, not the ReadBuf</p>",
        "id": 274109281,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389764
    },
    {
        "content": "<p>I had been assuming, in saying we could just have <code>ReadBufRef</code>, that it would need to have the initialized and filled lengths itself.</p>",
        "id": 274109342,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389799
    },
    {
        "content": "<p>If it instead pointed to <code>ReadBuf</code>, that <code>ReadBuf</code> has to live somewhere, and in the absence of the caller holding it, we'd need something like an <code>Rc</code>.</p>",
        "id": 274109573,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389832
    },
    {
        "content": "<p>Ah, I was assuming ReadBufRef is just a newtype reference and ReadBuf exists but is not exposed</p>",
        "id": 274109588,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389844
    },
    {
        "content": "<p>Yeah, true</p>",
        "id": 274109607,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389859
    },
    {
        "content": "<p>I don't see any way to expose only <code>ReadBufRef</code> with zero overhead.</p>",
        "id": 274109640,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389888
    },
    {
        "content": "<p>Hmm, we'd need custom DSTs or something to make it work nicely</p>",
        "id": 274109770,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646389960
    },
    {
        "content": "<p>I just had a thought that <em>might</em> make <code>ReadBufRef</code> more usable.</p>",
        "id": 274110003,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390116
    },
    {
        "content": "<p>What if <code>ReadBuf</code> had a <code>DerefMut</code> to <code>ReadBufRef</code>, and then all the actual methods were implemented on <code>ReadBufRef</code>, and <code>ReadBuf</code> just has the constructors and nothing else?</p>",
        "id": 274110052,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390154
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ReadBuf</span>::<span class=\"n\">uninit</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span><span class=\"w\"></span>\n<span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">read_buf</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">process</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">filled</span><span class=\"p\">());</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274110163,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390223
    },
    {
        "content": "<p>That is interesting...</p>",
        "id": 274110325,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646390308
    },
    {
        "content": "<p>Obviously we'd have to drop the <code>Deref</code>/<code>DerefMut</code> to <code>&amp;[u8]</code>, which is a tradeoff.</p>",
        "id": 274110354,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274110354\">said</a>:</p>\n<blockquote>\n<p>Obviously we'd have to drop the <code>Deref</code>/<code>DerefMut</code> to <code>&amp;[u8]</code>, which is a tradeoff.</p>\n</blockquote>\n<p>That was only a suggestion of mine. Currently there is just a <code>filled</code> method</p>",
        "id": 274110446,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646390385
    },
    {
        "content": "<p>Hmmm. This would actually make the type of <code>read_buf</code> even less pleasant; <code>&amp;mut buf</code> would get coerced from <code>&amp;mut ReadBuf</code> to <code>&amp;mut ReadBufRef</code>, so <code>read_buf</code> would have to take <code>&amp;mut ReadBufRef</code>. Which is still anti-footgun, because replacing the <code>ReadBufRef</code> doesn't replace the <code>ReadBuf</code>, but it's unnecessarily weird.</p>",
        "id": 274110657,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390501
    },
    {
        "content": "<p>It'd <em>work</em>, it's just not necessarily <em>less</em> weird.</p>",
        "id": 274110745,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390538
    },
    {
        "content": "<p>It also means there are three pointers to deref to get to the underlying data which seems sub-optimal for perf-sensitive code</p>",
        "id": 274110953,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646390647
    },
    {
        "content": "<p>Could we go half way to a DST?</p>\n<div class=\"codehilite\"><pre><span></span><code>struct ReadBuf&lt;T: ?Sized&gt;(usize, usize, T);\n</code></pre></div>\n<p>and make the argument of <code>read_buf</code> a <code>ReadBuf&lt;[MaybeUninit&lt;u8&gt;]&gt;</code>. Then we can move a buffer into a ReadBuf, take a mutable reference and unsize it.</p>",
        "id": 274110989,
        "sender_full_name": "oli",
        "timestamp": 1646390671
    },
    {
        "content": "<p>I don't have a sense of how much worse than two pointers though</p>",
        "id": 274110993,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646390674
    },
    {
        "content": "<p>we might be able to do bette with a DST impl if we don't mind transmuting in the ctors</p>",
        "id": 274111086,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646390759
    },
    {
        "content": "<p>but wouldn't that still have the footgun issue?</p>",
        "id": 274111180,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646390807
    },
    {
        "content": "<p>Better in the API sense? Or with a behaviour change?</p>",
        "id": 274111184,
        "sender_full_name": "oli",
        "timestamp": 1646390811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> In general some things get nicer if ReadBuf owns the buffer, but IIRC that wasn't ideal for various performance-sensitive use cases which wanted to read directly into a destination buffer.</p>",
        "id": 274111196,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390818
    },
    {
        "content": "<p>We could also use a RefCell rather than pointer maybe? Not sure about the perf tradeoff</p>",
        "id": 274111237,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646390841
    },
    {
        "content": "<p>You can't replace an unsized thing behind a reference or move out of it... for now, right. Forgot unsized locals</p>",
        "id": 274111242,
        "sender_full_name": "oli",
        "timestamp": 1646390843
    },
    {
        "content": "<p>Yea, that's what I was afraid of. Should've read the alternatives section of the RFC, sorry, will do now</p>",
        "id": 274111342,
        "sender_full_name": "oli",
        "timestamp": 1646390894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274110953\">said</a>:</p>\n<blockquote>\n<p>It also means there are three pointers to deref to get to the underlying data which seems sub-optimal for perf-sensitive code</p>\n</blockquote>\n<p>I never know what degree to assume Rust manages to make references not in practice require an indirection.</p>",
        "id": 274111406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390942
    },
    {
        "content": "<p>I suspect the answer is \"not as often as I'd hope\".</p>",
        "id": 274111426,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646390954
    },
    {
        "content": "<p>Yeah, this seems hard to optimise since the caller and callee are likely to be in different crates</p>",
        "id": 274111556,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646391030
    },
    {
        "content": "<p>We can always add custom mir opts for such peephole opts</p>",
        "id": 274111586,
        "sender_full_name": "oli",
        "timestamp": 1646391059
    },
    {
        "content": "<p>We could put the size fields in Cells and pass a &amp;ReadBuf rather than a &amp;mut ReadBuf?</p>",
        "id": 274113820,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646392230
    },
    {
        "content": "<p>It would mean ReadBuf is no longer Sync, but that doesn't seem too bad</p>",
        "id": 274113851,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646392253
    },
    {
        "content": "<p>Oh no, we do want to modify the buf too, doh</p>",
        "id": 274113927,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646392316
    },
    {
        "content": "<p>Stick the whole thing in a RefCell?</p>",
        "id": 274114030,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646392373
    },
    {
        "content": "<p>I guess then there is runtime overhead</p>",
        "id": 274114067,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646392404
    },
    {
        "content": "<p><code>[Cell&lt;MaybeUninit&lt;u8&gt;&gt;]</code></p>",
        "id": 274114098,
        "sender_full_name": "oli",
        "timestamp": 1646392441
    },
    {
        "content": "<p>No runtime overhead, but same effect</p>",
        "id": 274114201,
        "sender_full_name": "oli",
        "timestamp": 1646392493
    },
    {
        "content": "<p>Stepping back, although every step in the argument is logical, it feels weird to me that we are trying to design a buffer abstraction that can defend against a malicious read impl</p>",
        "id": 274114545,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646392725
    },
    {
        "content": "<p>I mean... we already are defending against accidental misuse. The API doesn't get more complex really, you just have a different type.</p>",
        "id": 274115116,
        "sender_full_name": "oli",
        "timestamp": 1646393157
    },
    {
        "content": "<p>Of all the options we've talked about, I think <code>ReadBufRef</code> still seems like the simplest.</p>",
        "id": 274115260,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646393239
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature/near/274104444\">said</a>:</p>\n<blockquote>\n<p>So this is a programming mistake, not unsoundess. The question is whether the programming mistake is a reasonable one. It kind of is, so this is a footgun</p>\n</blockquote>\n<p>Yes. <span aria-label=\"100\" class=\"emoji emoji-1f4af\" role=\"img\" title=\"100\">:100:</span> It is a <em>potential footgun</em> with the following pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">MU</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">uninit</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">MU</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"c1\">// …</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">read_buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ReadBuf</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">uninit</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">unknown_read_impl</span><span class=\"p\">.</span><span class=\"n\">read_buf</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">read_buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">init_count</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">read_buf</span><span class=\"p\">.</span><span class=\"n\">initialized</span><span class=\"p\">().</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">init</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// SAFETY: none, the callee cannot be trusted not to have swapped the readbuf</span>\n<span class=\"w\">    </span><span class=\"n\">Mu</span>::<span class=\"n\">slice_assume_init_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">uninit</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"n\">init_count</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so this may be <em>surprising</em>, especially if undocumented, and thus can legitimately be deemed <em>a footgun</em>, but it is <strong>not unsound</strong>.</p>\n<p>Just wanted to clarify that; this is just a more convoluted version of the \"what if the init len was returned by the implementor (<code>Result&lt;usize, …&gt;</code>)\" which would also yield a value that couldn't be trusted, lest the trait be <code>unsafe</code>.</p>",
        "id": 274126147,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646399693
    },
    {
        "content": "<p>If <code>ReadBufRef</code> removes this footgun, then I do <em>personally</em> consider that it should be worth featuring, even if the footgun is not unsound <em>per se</em>. The disappointing part would be the code duplication, but I suspect there should be ways to palliate that</p>",
        "id": 274126925,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646400114
    },
    {
        "content": "<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>An example</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Not necessarily the best, but here is a little trait+wrapper-to-make-the-methods-inherent trick to have:</p>\n<ul>\n<li>a <code>ReadBuf&lt;'buf&gt;</code> type;</li>\n<li>as well as a <code>ReadBufRef&lt;'r, 'buf&gt;</code> type;</li>\n</ul>\n<p>which both feature the same inherent impls thanks to a:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// These impls apply to both [`ReadBuf&lt;'buf&gt;`][`ReadBuf`] and</span>\n<span class=\"sd\">/// [`ReadBufRef&lt;'r, 'buf&gt;`][`ReadBufRef`].</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Kind</span><span class=\"w\"> </span>: <span class=\"nc\">ReadBufLike</span><span class=\"o\">&lt;'</span><span class=\"na\">buf</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">ReadBuf</span><span class=\"o\">&lt;'</span><span class=\"na\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Kind</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<p>single block of inherent impls.</p>\n<p>Implementor-side (only for stdlib maintainers), impls would just start with a <code>self.0.by_mut()</code> to get access to the internal <code>&amp;'r mut actual::ReadBuf&lt;'buf&gt;</code> with which to write the actual logic.</p>\n<ul>\n<li><a href=\"https://play.integer32.com/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=c5995f67a13eb8079a40b4a7e506be16\">Playground</a></li>\n</ul>\n</div></div>\n<hr>\n<p>Another approach, simpler to write, and potentially simpler to read as well, would be to just use macros to manually perform the <code>.by_mut()</code> dispatching. It would also have the advantage of ensure monomorphisation happens as early as possible.</p>",
        "id": 274133078,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646402705
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span><br>\n<a href=\"https://twitter.com/casio_juarez/status/1500237036703395841\">https://twitter.com/casio_juarez/status/1500237036703395841</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/casio_juarez/status/1500237036703395841\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/425d6703b013a27a415d7da5f0136391225a6dda/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313031363430363139353132373531333038382f63475035417366635f6e6f726d616c2e6a7067\"></a><p>Every time somebody talks about documenting things user shouldn't do so that users don't do them, I remember this line for the GIF 89a spec:\n\n\"Animation - The Graphics Interchange Format is not intended as a platform for animation, even though it can be done in a limited way.\"</p><span>- non-controversial display name (@casio_juarez)</span></div></div>",
        "id": 274316507,
        "sender_full_name": "Jubilee",
        "timestamp": 1646586157
    },
    {
        "content": "<p>I created <a href=\"https://github.com/rust-lang/rust/issues/94742\">https://github.com/rust-lang/rust/issues/94742</a> to continue discussion.</p>",
        "id": 274575578,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646760810
    }
]