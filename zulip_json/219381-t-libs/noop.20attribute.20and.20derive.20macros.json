[
    {
        "content": "<p>I'm not sure if this is the right place to ask about this. I'm thinking about writing an rfc for noop attribute and derive macros. This would be useful when you want to conditionally compile generated code.</p>\n<p>Instead of <code>cfg_attr</code> everywhere you use it, you could write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[cfg(feature = </span><span class=\"s\">\"serde\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">serde</span>::<span class=\"p\">{</span><span class=\"n\">Serialize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Deserialize</span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[cfg(not(feature = </span><span class=\"s\">\"serde\"</span><span class=\"cp\">))]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">macros</span>::<span class=\"n\">NoOp</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Serialize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"cp\">#[cfg(not(feature = </span><span class=\"s\">\"serde\"</span><span class=\"cp\">))]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">macros</span>::<span class=\"n\">NoOp</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Deserialize</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This would be even more useful for things where it only makes sense to enable it globally. In that case you could publish a crate that either re-exports something from a proc-macro crate or a noop.</p>\n<p>My use-case is a derive macro that generates trampolines for debug/display/structured printing a type with debugger integrations to call them. Ideally library users could just stick it on everything and it would be nearly free unless the final downstream user built with debug assertions and enabled it. Credit for the idea goes to Yandros ꜰʀ-ᴇꜱ on Discord.</p>",
        "id": 239476632,
        "sender_full_name": "Daniel Franklin",
        "timestamp": 1621449929
    },
    {
        "content": "<p>I think you'd need more code than just <code>use NoOp as Serialize</code> so rustc knows what to do with the <code>#[serde(...)]</code> attributes</p>",
        "id": 239485091,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1621453600
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/219381-t-libs/topic/noop.20attribute.20and.20derive.20macros/near/239485091\">said</a>:</p>\n<blockquote>\n<p>I think you'd need more code than just <code>use NoOp as Serialize</code> so rustc knows what to do with the <code>#[serde(...)]</code> attributes</p>\n</blockquote>\n<p>You're right, I forgot attributes can have arbitrary names. That makes this a little more complicated. NoOp could be special-cased as accepting any attribute, or it could be something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">proc_macro_derive_noop</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">attributes</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 239486331,
        "sender_full_name": "Daniel Franklin",
        "timestamp": 1621454142
    }
]