[
    {
        "content": "<p>What is folks' first reaction to supporting the following in std::assert?</p>\n<div class=\"codehilite\"><pre><span></span><code>assert!(impl Send for MyType, &quot;...&quot;);\nassert!(impl !Unpin for MyType, &quot;...&quot;);\n</code></pre></div>\n<p>I have <a href=\"https://github.com/dtolnay/cxx/blob/ede65e0ce27932009ea3be87ca3a9c6587ced8dd/macro/src/expand.rs#L392-L416\">this</a> as the current best known workaround but the error messages are horrible. See <a href=\"https://github.com/dtolnay/cxx/blob/master/tests/ui/unpin_impl.rs\">unpin_impl.rs</a> and <a href=\"https://github.com/dtolnay/cxx/blob/master/tests/ui/unpin_impl.stderr\">unpin_impl.stderr</a>.</p>",
        "id": 260352617,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636071686
    },
    {
        "content": "<p>Feels a little awkward in assert, since I don't think we want to support \"getting a bool representing the presence of an impl\" -- I think Niko has said that avoiding that kind of testing is good, and it would also hurt polymorphization and similar efforts. But assert_impl or static_assert feel more reasonable to me, and like a big win over today's <code>fn foo&lt;T: Send&gt;() { foo::&lt;SomeType&gt;() }</code>and similar (which ... don't work for negative impls?)</p>",
        "id": 260352987,
        "sender_full_name": "simulacrum",
        "timestamp": 1636072040
    },
    {
        "content": "<p>Not exposing a bool for the presence of an impl is exactly the idea behind building this into std::assert only</p>",
        "id": 260353075,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636072143
    },
    {
        "content": "<p>As opposed to <code>do_whatever_i_want_with(implemented!(Send, MyType))</code></p>",
        "id": 260353182,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636072242
    },
    {
        "content": "<p>Yeah, I just have a negative reaction to assert taking a not bool off hand, but it may be actually great; certainly in some sense less to teach -- I've never settled on a firm feeling whether rolling capability into assert! vs. having dedicated macros (assert_impl!, static_assert!) for more compile-time rather than run-time asserts is better.</p>",
        "id": 260353230,
        "sender_full_name": "simulacrum",
        "timestamp": 1636072316
    },
    {
        "content": "<p>I definitely think it needs to be an \"assert\" macro of some kind.</p>",
        "id": 260353276,
        "sender_full_name": "simulacrum",
        "timestamp": 1636072329
    },
    {
        "content": "<p>I'd be on board with an assert_impl or static_assert</p>",
        "id": 260353383,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636072461
    },
    {
        "content": "<p>I do think it should have a new name, leaving <code>assert!</code> as a runtime thing</p>",
        "id": 260353463,
        "sender_full_name": "cuviper",
        "timestamp": 1636072559
    },
    {
        "content": "<p>would you use this inside a test just like a regular assert!(), or anywhere including at file/module scope like compile_error!()?</p>",
        "id": 260353464,
        "sender_full_name": "Mara",
        "timestamp": 1636072560
    },
    {
        "content": "<p>whether it's an overload of a more normal <code>const</code>-<code>bool</code>-y <code>static_assert!</code> is another question</p>",
        "id": 260353524,
        "sender_full_name": "cuviper",
        "timestamp": 1636072594
    },
    {
        "content": "<p>For assert_impl I find <code>assert_impl!(!Unpin for MyType)</code> a little more awkward for not a lot of benefit over making assert recognize <code>impl $trait for $ty</code> as a macro input pattern, but I can understand not want to pack too much different things into assert itself</p>",
        "id": 260353525,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636072595
    },
    {
        "content": "<p><code>compile_assert!(impl ...);</code></p>",
        "id": 260353557,
        "sender_full_name": "Mara",
        "timestamp": 1636072640
    },
    {
        "content": "<p>Mara: I'd be writing <code>const _: () = whatever_assert!(...);</code> since assert now works in const</p>",
        "id": 260353559,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636072640
    },
    {
        "content": "<p>that seems odd to me for an 'impl assert' like this, because there's no runtime version of it.</p>",
        "id": 260353651,
        "sender_full_name": "Mara",
        "timestamp": 1636072718
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>macro_rules! static_assert {\n    ($($t:tt)*) =&gt; { const _: () = $crate::assert!($($t)*); }; //  \\o/\n}\n</code></pre></div>",
        "id": 260353751,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636072817
    },
    {
        "content": "<p>SHIP IT</p>",
        "id": 260353778,
        "sender_full_name": "cuviper",
        "timestamp": 1636072857
    },
    {
        "content": "<p>I think static_assert definitely has a lot of name benefits and lets us put other stuff (like guaranteed-compile time asserts) into it, even if they're relatively easy to achieve with an anonymous constant these days</p>",
        "id": 260353802,
        "sender_full_name": "simulacrum",
        "timestamp": 1636072883
    },
    {
        "content": "<p>are we doing the c++ thing of calling 17 different concepts 'static'? :p</p>",
        "id": 260353803,
        "sender_full_name": "Mara",
        "timestamp": 1636072885
    },
    {
        "content": "<p><code>const_assert!</code> works too</p>",
        "id": 260353830,
        "sender_full_name": "cuviper",
        "timestamp": 1636072914
    },
    {
        "content": "<p>hmm, the <code>static_assertions</code> crate already calls it that, and also has impl stuff</p>",
        "id": 260353994,
        "sender_full_name": "cuviper",
        "timestamp": 1636073057
    },
    {
        "content": "<p>Yeah the variation in cxx is based on static_assertions::assert_not_impl_any</p>",
        "id": 260354041,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636073123
    },
    {
        "content": "<p>/me wonders if choosing a different name avoids \"breaking\" people using #[macro_use] and the like</p>",
        "id": 260354042,
        "sender_full_name": "simulacrum",
        "timestamp": 1636073126
    },
    {
        "content": "<p>Sane diagnostics for the user is the motivation for not just keeping it, not because i don't want a dependency on static_assertions or don't want to own the 20 lines of relevant code</p>",
        "id": 260354135,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636073203
    },
    {
        "content": "<p>i wonder if it might be better to have this as a language feature rather than a macro. syntax for 'this type must impl Send' could be useful for more than just checks/asserts.</p>",
        "id": 260354159,
        "sender_full_name": "Mara",
        "timestamp": 1636073238
    },
    {
        "content": "<p>there is also <code>static_assert_macro</code> with the <code>static_assert!</code> name, but it doesn't have the same reach</p>",
        "id": 260354180,
        "sender_full_name": "cuviper",
        "timestamp": 1636073273
    },
    {
        "content": "<p>I think the underlying implementation of the macro is probably compiler intrinsic or other magic -- but I'm not sure I can think of a better way to expose it</p>",
        "id": 260354181,
        "sender_full_name": "simulacrum",
        "timestamp": 1636073277
    },
    {
        "content": "<p>Yeah compiler intrinsic is what I had in mind</p>",
        "id": 260354235,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636073295
    },
    {
        "content": "<p>are there any other things than checking trait impls that you'd want to assert on, that are not just const bools?</p>",
        "id": 260354275,
        "sender_full_name": "Mara",
        "timestamp": 1636073358
    },
    {
        "content": "<p>Probably in practice it's a rustc_ attr on an impl block or something, since I'm not sure there's actually a way to pass in an arbitrary <em>trait</em> to a method otherwise.</p>",
        "id": 260354285,
        "sender_full_name": "simulacrum",
        "timestamp": 1636073379
    },
    {
        "content": "<p><code>static_assert!(bool)</code> should be considered first</p>",
        "id": 260354382,
        "sender_full_name": "cuviper",
        "timestamp": 1636073450
    },
    {
        "content": "<p>I expect the impl stuff has a lot more questions</p>",
        "id": 260354394,
        "sender_full_name": "cuviper",
        "timestamp": 1636073466
    },
    {
        "content": "<p><code>compile_error!(\"..\") where T: !Send;</code></p>",
        "id": 260354497,
        "sender_full_name": "Mara",
        "timestamp": 1636073545
    },
    {
        "content": "<p>for that extra negated logic <del>confusion</del> fun</p>",
        "id": 260354538,
        "sender_full_name": "Mara",
        "timestamp": 1636073627
    },
    {
        "content": "<p><code>#[cfg&lt;T: !Send&gt;] compile_error!(\"..\");</code></p>",
        "id": 260354539,
        "sender_full_name": "cuviper",
        "timestamp": 1636073628
    },
    {
        "content": "<p><span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 260354614,
        "sender_full_name": "Mara",
        "timestamp": 1636073681
    },
    {
        "content": "<p><code>compile_error!(\"...\" if T: !Send else üëç);</code></p>",
        "id": 260354678,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636073751
    },
    {
        "content": "<p>oh i like that one</p>",
        "id": 260354734,
        "sender_full_name": "Mara",
        "timestamp": 1636073772
    },
    {
        "content": "<p>does the <span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span> lexer support modifiers?</p>",
        "id": 260354798,
        "sender_full_name": "cuviper",
        "timestamp": 1636073841
    },
    {
        "content": "<p>can't tell if serious but it somewhat meshes with <code>std::matches</code>'s guard clause</p>",
        "id": 260354817,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636073857
    },
    {
        "content": "<p>did I seem serious? oh my...</p>",
        "id": 260354902,
        "sender_full_name": "cuviper",
        "timestamp": 1636073917
    },
    {
        "content": "<p>Nope, Mara did</p>",
        "id": 260354930,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636073946
    },
    {
        "content": "<p>ah</p>",
        "id": 260354963,
        "sender_full_name": "cuviper",
        "timestamp": 1636073971
    },
    {
        "content": "<p>oh, nothing i say after midnight is serious</p>",
        "id": 260354967,
        "sender_full_name": "Mara",
        "timestamp": 1636073980
    },
    {
        "content": "<p>i should go to sleep <span aria-label=\"zzz\" class=\"emoji emoji-1f4a4\" role=\"img\" title=\"zzz\">:zzz:</span></p>",
        "id": 260354971,
        "sender_full_name": "Mara",
        "timestamp": 1636073985
    },
    {
        "content": "<p>Sounds good. I'll think about a proposal -- thanks all</p>",
        "id": 260355039,
        "sender_full_name": "David Tolnay",
        "timestamp": 1636074008
    },
    {
        "content": "<p>I prefer using the bounds syntax rather than the impl syntax - since we are testing if there is a transitive implementation not a direct one</p>",
        "id": 260374756,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636099159
    },
    {
        "content": "<p>Late to the party here, but: <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for having an <code>assert_impls!(Trait for Type, \"...\")</code> or similar.</p>",
        "id": 260413771,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636123264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119235\">David Tolnay</span> <a href=\"#narrow/stream/219381-t-libs/topic/assert.20impl.20or.20not.20impl/near/260353751\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\"><pre><span></span><code>macro_rules! static_assert {\n    ($($t:tt)*) =&gt; { const _: () = $crate::assert!($($t)*); }; //  \\o/\n}\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Or just write <code>const { assert!() }</code>.</p>",
        "id": 260532524,
        "sender_full_name": "Gary Guo",
        "timestamp": 1636228084
    },
    {
        "content": "<p>Nobody has mentioned this here afaik...is the intent to have the static assertion be inside of a method or not? Either way seems reasonable, but it would affect various ideas.</p>",
        "id": 260544743,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1636245083
    },
    {
        "content": "<p>With the name static, that implies it has item context to me.</p>",
        "id": 260558004,
        "sender_full_name": "cuviper",
        "timestamp": 1636267445
    },
    {
        "content": "<p>If it can be outside a method, then it can be inside a method too, not vice versa though obviously</p>",
        "id": 260571814,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636289110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/assert.20impl.20or.20not.20impl/near/260353803\">said</a>:</p>\n<blockquote>\n<p>are we doing the c++ thing of calling 17 different concepts 'static'? <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>\n</blockquote>\n<p>This. In Rust parlance it would be a <code>compile_time</code> or <code>const</code> assertion, if anything, rather than a <code>static</code> one, since there is no <code>static</code> storage involved anywhere <span aria-label=\"100\" class=\"emoji emoji-1f4af\" role=\"img\" title=\"100\">:100:</span> </p>\n<hr>\n<p>Other than that I agree with the sentiment that, at least for \"assert not impl\", we do have a serious lack of decent diagnostics, here.</p>\n<p>And what about generic contexts? <em>e.g.</em>, <code>const</code>-asserting that <code>MyWrapper&lt;T&gt; : !Unpin</code> for any choice of <code>T</code>. On the one hand, such an assertion is a legitimate thing to want to write. But on the other hand, I'm afraid that many implementations of <code>assert_not_impl</code>, at least those on stable Rust, would be unable to yield an unambiguous answer. Take, for instance, the current implementation of <code>assert_not_impl</code>. It <em>correctly</em> refuses to handle generic types ( <span aria-label=\"ok\" class=\"emoji emoji-1f44c\" role=\"img\" title=\"ok\">:ok:</span>), since, <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=ab35e700266a423ea013455cf0ee6222\">if it did, it wouldn't necessarily yield the expected result</a>. The core issue here is that besides <code>T : Trait</code> and <code>T : !Trait</code>, we may have a <code>T : ?Trait</code> situation, which is a mathematical / quantification-related property that may not be obvious for all the Rust programmers.</p>\n<ul>\n<li>This is yet another reason to have an officially blessed macro (with potential <code>lang</code>-magic support if needs be), which would be able to error on the weak <code>T : ?Trait</code> case.</li>\n</ul>\n<p>But once such a macro is officially blessed, what about semver (~coherence)? A key design of Rust is that implementing a new trait for a type must not be a breaking change; but if downstream users were able to use a stdlib macro to assert that a certain trait not be implemented for that type, then such an addition would be breaking!</p>\n<ul>\n<li>This may, however, be handled by the aforementioned \"erroring on the weak <code>T : ?Trait</code> case\", since coherence would correctly assume that <code>NonLocalTy : ?NonLocalTrait</code> whenever <code>NonLocalTy : NonLocalTrait</code> does not hold, right? And so, for upstream crates, only an explicit <code>impl !Trait for Ty {}</code> would be able to allow downstream crates to get the desired <code>NonLocalTy : !NonLocalTrait</code> semantics off which such an assertion macro could work, right?</li>\n</ul>",
        "id": 260574690,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636292735
    }
]