[
    {
        "content": "<p>...can you elaborate any on \"misused RNGs in tests and blessed the results\"?</p>",
        "id": 272457323,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218339
    },
    {
        "content": "<p>I think whatever we put into core/std should focus exclusively on the former.</p>",
        "id": 272457327,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> Folks would write change detection tests rather than verify behavior. Think \"shuffle this vector and make sure the first item is the thing I expected it to be when I wrote the test\"</p>",
        "id": 272457441,
        "sender_full_name": "Brendan Hickey",
        "timestamp": 1645218382
    },
    {
        "content": "<p>I think anything seedable is a de facto guarantee of the algorithm, which makes it something that might not belong in std since if it turns out to be insecure we can't get rid of it.</p>\n<p>If it's not seedable, then it's different every time, and thus we could change it to a different algorithm whenever just fine.</p>",
        "id": 272457444,
        "sender_full_name": "scottmcm",
        "timestamp": 1645218386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I was too slow :-( <a href=\"#narrow/stream/122651-general/topic/RNGs.20in.20tests.20are.20misuses\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/RNGs.20in.20tests.20are.20misuses</a></p>",
        "id": 272457534,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645218441
    },
    {
        "content": "<p>Ah, lemme reshuffle these messages...</p>",
        "id": 272457602,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272457444\">said</a>:</p>\n<blockquote>\n<p>I think anything seedable is a de facto guarantee of the algorithm, which makes it something that might not belong in std since if it turns out to be insecure we can't get rid of it.</p>\n<p>If it's not seedable, then it's different every time, and thus we could change it to a different algorithm whenever just fine.</p>\n</blockquote>\n<p>Ah, that's a valid point.</p>",
        "id": 272457607,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> agree wholeheartedly, it goes beyond just the bit generator implementation but all of the algorithms we build around them. If you promise some particular implementation people will come to rely on it and then you're committed</p>",
        "id": 272457697,
        "sender_full_name": "Brendan Hickey",
        "timestamp": 1645218515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Though, I can imagine a world in which we say that we can deprecate old algorithms for the unseeded case, and only keep them for the seeded case, so that people can replay old seeds.</p>",
        "id": 272457759,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/RNGs.20in.20tests.20are.20misuses/near/272457444\">said</a>:</p>\n<blockquote>\n<p>I think anything seedable is a de facto guarantee of the algorithm, which makes it something that might not belong in std since if it turns out to be insecure we can't get rid of it.</p>\n<p>If it's not seedable, then it's different every time, and thus we could change it to a different algorithm whenever just fine.</p>\n</blockquote>\n<p>We have a history of carving out behavior that we would like to be able to break in the future, is there any value to making something seedable but not guaranteeing that the specific resulting values will be stable between compiler versions?</p>",
        "id": 272458008,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645218714
    },
    {
        "content": "<p>we did have this problem with <code>SipHasher</code>, which is now deprecated in favor of <code>DefaultHasher</code></p>",
        "id": 272458100,
        "sender_full_name": "bstrie",
        "timestamp": 1645218755
    },
    {
        "content": "<p>i guess if you wanted to write tests that only pass because of a specific seed then that would break if the behavior changed. Is the topic of this thread insinuating that such tests are fundamentally a misuse of rng APIs?</p>",
        "id": 272458226,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645218822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby [she/her]</span> it's very handy when debugging and doesn't commit you to a long term stability guarantee</p>",
        "id": 272458313,
        "sender_full_name": "Brendan Hickey",
        "timestamp": 1645218858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> I can't actually seem to move this into #general sadly.</p>",
        "id": 272458317,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218861
    },
    {
        "content": "<p>I think it depends on what the API is called.</p>\n<p>If you're getting things from something called <code>Shake256</code>, say, then it's fine because the name says that you can't change the API anyway.</p>\n<p>If it's called <code>std::randomess::SeedableSource</code>, then it's a misuse.</p>",
        "id": 272458377,
        "sender_full_name": "scottmcm",
        "timestamp": 1645218896
    },
    {
        "content": "<p>if so we could not just reserve the right to change the behavior between compiler versions, but intentionally change the rng seed salt(?) on every compiler versino</p>",
        "id": 272458392,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645218903
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/RNGs.20in.20tests.20are.20misuses.3F/near/272458226\">said</a>:</p>\n<blockquote>\n<p>i guess if you wanted to write tests that only pass because of a specific seed then that would break if the behavior changed. Is the topic of this thread insinuating that such tests are fundamentally a misuse of rng APIs?</p>\n</blockquote>\n<p>I added a question mark because it was about questioning that statement. ^^;</p>",
        "id": 272458405,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/RNGs.20in.20tests.20are.20misuses.3F/near/272458392\">said</a>:</p>\n<blockquote>\n<p>if so we could not just reserve the right to change the behavior between compiler versions, but intentionally change the rng seed salt(?) on every compiler versino</p>\n</blockquote>\n<p>We could, but also, that'd break most of the reason to be seedable.</p>",
        "id": 272458445,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218934
    },
    {
        "content": "<p>Also, I feel like there's a whole discussion here about seeding and algorithmic stability that doesn't go under \"seedable RNGs in tests\".</p>",
        "id": 272458581,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219006
    },
    {
        "content": "<p>/me adds more question marks to the topic.</p>",
        "id": 272458738,
        "sender_full_name": "Jubilee",
        "timestamp": 1645219086
    },
    {
        "content": "<p>(that works :) )</p>",
        "id": 272458763,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219102
    },
    {
        "content": "<p>seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F</p>",
        "id": 272458797,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645219118
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> One common use case for seedable RNGs is replayability. For instance, you have some randomly seeded search process and want to reproduce the result. Or you have a game that saves replays, and it has random elements so you also save the seed.</p>",
        "id": 272458835,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219148
    },
    {
        "content": "<p>Most people aren't dealing with an environment where refactoring some minor RNG library will break 20,000 targets. Still, I'm glad y'all are considering the downsides of allowing seedability and what it implies for reproducibility</p>",
        "id": 272458845,
        "sender_full_name": "Brendan Hickey",
        "timestamp": 1645219154
    },
    {
        "content": "<p>If the algorithm changes, or if the seed changes on every compiler version, that defeats all those use cases.</p>",
        "id": 272458876,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219175
    },
    {
        "content": "<p>At which point, I don't think the seedable interface carries enough remaining weight of use cases to provide or stabilize.</p>",
        "id": 272458897,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272458445\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/RNGs.20in.20tests.20are.20misuses.3F/near/272458392\">said</a>:</p>\n<blockquote>\n<p>if so we could not just reserve the right to change the behavior between compiler versions, but intentionally change the rng seed salt(?) on every compiler versino</p>\n</blockquote>\n<p>We could, but also, that'd break most of the reason to be seedable.</p>\n</blockquote>\n<p>If it's in core it can't seed itself. Someone has to provide entropy. That's separate from being seedable for reproducibility reasons.</p>",
        "id": 272459021,
        "sender_full_name": "The 8472",
        "timestamp": 1645219270
    },
    {
        "content": "<p>Perhaps most cases would be better served by accepting <code>R: Rng</code> and then using <code>fn test_rng() -&gt; impl Rng { 4 }</code></p>",
        "id": 272459065,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645219303
    },
    {
        "content": "<p>x86 apparently has the RDRAND instruction.</p>",
        "id": 272459081,
        "sender_full_name": "Jubilee",
        "timestamp": 1645219310
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> And rdseed.</p>",
        "id": 272459094,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272459065\">said</a>:</p>\n<blockquote>\n<p>Perhaps most cases would be better served by accepting <code>R: Rng</code> and then using <code>fn test_rng() -&gt; impl Rng { 4 }</code></p>\n</blockquote>\n<p>randomly selected via libs team FCP</p>",
        "id": 272459141,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645219326
    },
    {
        "content": "<p>no idea if that's acceptable.</p>",
        "id": 272459152,
        "sender_full_name": "Jubilee",
        "timestamp": 1645219332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> Agreed, but there's nothing requiring us to make the components available rather than the seeded RNG interface, if the seedable component doesn't carry enough weight.</p>",
        "id": 272459156,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272459152\">said</a>:</p>\n<blockquote>\n<p>no idea if that's acceptable.</p>\n</blockquote>\n<p>It's absolutely a viable interface for reading random bytes, though if not available we'd still want to fall back to <code>getrandom</code>.</p>",
        "id": 272459197,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219359
    },
    {
        "content": "<p>I still don't trust RDRAND, but I think that ship sailed years ago.</p>",
        "id": 272459233,
        "sender_full_name": "Brendan Hickey",
        "timestamp": 1645219374
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"463851\">Brendan Hickey</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272459233\">said</a>:</p>\n<blockquote>\n<p>I still don't trust RDRAND, but I think that ship sailed years ago.</p>\n</blockquote>\n<p>I'm very much on the ship of \"if you don't trust your hardware then RDRAND/RDSEED is the <em>least</em> of your concerns\".</p>",
        "id": 272459271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219401
    },
    {
        "content": "<p>There are reasons to not trust it other than malicious vendors. E.g. there was that AMD bug.</p>",
        "id": 272460079,
        "sender_full_name": "The 8472",
        "timestamp": 1645219816
    },
    {
        "content": "<p>The linux kernel doesn't trust it either unless you opt-in afaik.</p>",
        "id": 272460131,
        "sender_full_name": "The 8472",
        "timestamp": 1645219854
    },
    {
        "content": "<p>True, but distros turn that flag on.</p>",
        "id": 272460300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645219945
    },
    {
        "content": "<p>#notalldistros<br>\n<a href=\"https://github.com/archlinux/svntogit-packages/blob/911bc6d5451dea81cf8aa6a5f170188e330b4406/trunk/config#L4429\">https://github.com/archlinux/svntogit-packages/blob/911bc6d5451dea81cf8aa6a5f170188e330b4406/trunk/config#L4429</a></p>",
        "id": 272460617,
        "sender_full_name": "The 8472",
        "timestamp": 1645220125
    },
    {
        "content": "<p><a href=\"https://www.theregister.com/2013/12/09/freebsd_abandoning_hardware_randomness/\">https://www.theregister.com/2013/12/09/freebsd_abandoning_hardware_randomness/</a></p>",
        "id": 272460869,
        "sender_full_name": "Jubilee",
        "timestamp": 1645220260
    },
    {
        "content": "<p>Well RDRAND is still used as one way among several to seed the pool that feeds the CSPRNG. It's just not used for entropy accounting purposes or passed through raw.</p>",
        "id": 272461154,
        "sender_full_name": "The 8472",
        "timestamp": 1645220424
    },
    {
        "content": "<p>Yes, it seems so.</p>",
        "id": 272461224,
        "sender_full_name": "Jubilee",
        "timestamp": 1645220477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272458835\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> One common use case for seedable RNGs is replayability. For instance, you have some randomly seeded search process and want to reproduce the result. Or you have a game that saves replays, and it has random elements so you also save the seed.</p>\n</blockquote>\n<p>Oh, yes, I fully agree that replayability is useful.  But scenarios like that also make the \"change a salt every release\" from <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272458392\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272458392</a> not acceptable either.</p>\n<p>When their very nature is \"this algorithm must remain around unchanged forever\", I'm not convinced we can reasonably pick <em>exactly one</em> of those for <code>std</code>, and accepting multiple isn't good either.  A crate that just does exactly that, with very precise pinning tests, seems like a great solution for it.</p>\n<p>And then people can use the maybe-slow OS's CS-XOF we expose in std to pick the seed to start that process per simulation or match or whatever.</p>",
        "id": 272461258,
        "sender_full_name": "scottmcm",
        "timestamp": 1645220503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272461154\">said</a>:</p>\n<blockquote>\n<p>Well RDRAND is still used as one way among several to seed the pool that feeds the CSPRNG. It's just not used for entropy accounting purposes or passed through raw.</p>\n</blockquote>\n<p>Which, now that hardware randomness is used differently and fed in as an input, I'm wondering if the config option to disable it is still needed.</p>",
        "id": 272461579,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645220684
    },
    {
        "content": "<p>Doesn't linux do the same as freebsd?</p>",
        "id": 272461684,
        "sender_full_name": "The 8472",
        "timestamp": 1645220740
    },
    {
        "content": "<p>I mean, doesn't the flag only affect the accounting, not the use?</p>",
        "id": 272461868,
        "sender_full_name": "The 8472",
        "timestamp": 1645220830
    },
    {
        "content": "<p>Ah, I see. Yeah, I can imagine that people might still treat it as a point of desired configuration whether Linux considers the output of <code>rdseed</code> sufficient to call the CSPRNG seeded.</p>",
        "id": 272462259,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645221046
    },
    {
        "content": "<p>Using it as sole source is iffy since it's inauditable, that's why the flag exists.</p>",
        "id": 272462466,
        "sender_full_name": "The 8472",
        "timestamp": 1645221155
    },
    {
        "content": "<p>It was <em>more</em> iffy when it was applied \"after\" the entropy pool, rather than as an input to it.</p>",
        "id": 272462559,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645221217
    },
    {
        "content": "<p>Previously, the output of the RNG was just non-cryptographically combined (XOR I think) with the output of RDRAND, which was neither necessary nor desirable.</p>",
        "id": 272462675,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645221254
    },
    {
        "content": "<p>Now, it's just one more input to the pool.</p>",
        "id": 272462692,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645221268
    },
    {
        "content": "<p>Yeah, but... the AMD bug. Also, is it an interceptable instruction for virtualization?</p>",
        "id": 272462763,
        "sender_full_name": "The 8472",
        "timestamp": 1645221302
    },
    {
        "content": "<p>Anyway, we were talking about using it as entropy source in userspace, I think? That would suffer from all the problems.</p>",
        "id": 272463113,
        "sender_full_name": "The 8472",
        "timestamp": 1645221472
    },
    {
        "content": "<p>If it's just an input to the entropy pool then bugs don't matter. It could output anything and it wouldn't make things less secure then if it didn't exist at all. After all, if the pool is vulnerable to non-random input then it's broken.</p>",
        "id": 272463249,
        "sender_full_name": "Chris Denton",
        "timestamp": 1645221534
    },
    {
        "content": "<p>It still matters of entropy accounting. If you trust every bit from it then the pool may become fully initialized from the instruction alone.</p>",
        "id": 272463363,
        "sender_full_name": "The 8472",
        "timestamp": 1645221597
    },
    {
        "content": "<p>e.g. the AMD bug did output all zeroes. Which means in the worst case you'd initialize the pool to the same value every time.</p>",
        "id": 272463694,
        "sender_full_name": "The 8472",
        "timestamp": 1645221681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272461258\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272458835\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> One common use case for seedable RNGs is replayability. For instance, you have some randomly seeded search process and want to reproduce the result. Or you have a game that saves replays, and it has random elements so you also save the seed.</p>\n</blockquote>\n<p>Oh, yes, I fully agree that replayability is useful.  But scenarios like that also make the \"change a salt every release\" from <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272458392\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272458392</a> not acceptable either.</p>\n<p>When their very nature is \"this algorithm must remain around unchanged forever\", I'm not convinced we can reasonably pick <em>exactly one</em> of those for <code>std</code>, and accepting multiple isn't good either.  A crate that just does exactly that, with very precise pinning tests, seems like a great solution for it.</p>\n<p>And then people can use the maybe-slow OS's CS-XOF we expose in std to pick the seed to start that process per simulation or match or whatever.</p>\n</blockquote>\n<p>this leads strongly back into the other discussion we've been having around the <code>mpsc</code> PR about improving discoverability of 3rd party crates / making official libs team crate recommendations</p>",
        "id": 272464047,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645221868
    },
    {
        "content": "<p>gonna add a note to the 2022 roadmap scratch doc</p>",
        "id": 272464087,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645221899
    },
    {
        "content": "<p>we would only consider the hardware primitives for <code>no_std</code>, right? I don't see a reason to move away from entropy provided by the kernel</p>",
        "id": 272464120,
        "sender_full_name": "lyinch",
        "timestamp": 1645221926
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272463694\">said</a>:</p>\n<blockquote>\n<p>e.g. the AMD bug did output all zeroes. Which means in the worst case you'd initialize the pool to the same value every time.</p>\n</blockquote>\n<p>Sure, if the pool is reliant on a single source of entropy. IIRC Linux includes CPU jitter which is better than nothing even if other sources are non-random.</p>",
        "id": 272464904,
        "sender_full_name": "Chris Denton",
        "timestamp": 1645222335
    },
    {
        "content": "<p>We don't have a mechanism for \"use A in no_std crates, use B if we have an OS\".</p>",
        "id": 272464910,
        "sender_full_name": "The 8472",
        "timestamp": 1645222339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260325\">@Chris Denton</span> my understanding is that scheduler noise gets fed in eventually, but during early boot and with TRUST_CPU there could be a window where the pool is solely initialized from the instructions. And userspace doesn't have that luxury anyway.</p>",
        "id": 272465207,
        "sender_full_name": "The 8472",
        "timestamp": 1645222541
    },
    {
        "content": "<blockquote>\n<p>We don't have a mechanism for \"use A in no_std crates, use B if we have an OS\".</p>\n</blockquote>\n<p>Isn't this exactly what <code>cfg</code> does?</p>",
        "id": 272467122,
        "sender_full_name": "Lokathor",
        "timestamp": 1645223441
    },
    {
        "content": "<p>If you add an extra feature to that crate and opt-in. But someone might just use the no_std crate as-is.</p>",
        "id": 272467201,
        "sender_full_name": "The 8472",
        "timestamp": 1645223491
    },
    {
        "content": "<p>Wouldn't one cfg based on the target?</p>",
        "id": 272467300,
        "sender_full_name": "Lokathor",
        "timestamp": 1645223528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/seedable.20RNGs.20and.20risks.3F.3F.3F.3F.3F.3F.3F.3F.3F/near/272464910\">said</a>:</p>\n<blockquote>\n<p>We don't have a mechanism for \"use A in no_std crates, use B if we have an OS\".</p>\n</blockquote>\n<p>You can define it in core, then use symbol shenanighans to override it in std.</p>",
        "id": 272467930,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645223890
    },
    {
        "content": "<p>I may have lost track of the discussion. If we wanted something in <code>core</code> (at least for x86/arm) then we woldn't have a mechanism to replace the RDRAND use in core with a syscall when you're using std.<br>\nIf it's a no_std crate on crates IO then it'd have to pull in libc on those platforms.</p>",
        "id": 272467978,
        "sender_full_name": "The 8472",
        "timestamp": 1645223934
    },
    {
        "content": "<p>Yeah, I don't think we have anything doing the symbol stuff so far, do we? There was some discussion about pluggable existential traits or something in the libs wishlist for lang that might do it.</p>",
        "id": 272468052,
        "sender_full_name": "The 8472",
        "timestamp": 1645223990
    },
    {
        "content": "<blockquote>\n<p>Existential types with external definitions</p>\n</blockquote>",
        "id": 272468125,
        "sender_full_name": "The 8472",
        "timestamp": 1645224020
    },
    {
        "content": "<p>we have lang items, but those are a brutal hack.</p>",
        "id": 272468766,
        "sender_full_name": "Jubilee",
        "timestamp": 1645224415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> People use the same target for std and no_std code. With the benefit of hindsight, that may not have been the right approach.</p>",
        "id": 272470661,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645225562
    },
    {
        "content": "<p>I'm hopeful that targets like x86_64-unknown-none will help with that differentiation.</p>",
        "id": 272470752,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645225598
    },
    {
        "content": "<p>really this sounds like that thing you talked about in the interview the other day, that there be some sort of \"i will need this\" thing a lib does, and then the top level bin will provide it \"somehow\" but the lib using it doesn't know or care how</p>",
        "id": 272470987,
        "sender_full_name": "Lokathor",
        "timestamp": 1645225726
    },
    {
        "content": "<p>And you need an impl but also want a default impl if possible.</p>",
        "id": 272471058,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645225764
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 272471065,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645225766
    },
    {
        "content": "<p>Rolling std and core into one crate and using build-std by default would also solve the problem since then we could use cfg flags.</p>",
        "id": 272471167,
        "sender_full_name": "The 8472",
        "timestamp": 1645225805
    },
    {
        "content": "<p>build-std can't be used by non-cargo build systems.</p>",
        "id": 272471456,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645225960
    },
    {
        "content": "<p>Whatever mechanism it invokes certainly could be; stable cargo features don't use unstable rustc features.</p>",
        "id": 272472090,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645226309
    },
    {
        "content": "<p>Well, the question is whether building the standard library is available to $BUILD_SYSTEM without specific knowledge (other than trampolining into cargo, which adds deps and is <em>fun</em>)</p>",
        "id": 272472286,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645226437
    },
    {
        "content": "<p>Any system that wants to do the same thing cargo is doing either needs to call cargo (ideally) or duplicate what cargo is doing. But in general it should be <em>possible</em>, whether or not it's convenient.</p>",
        "id": 272473047,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645226943
    },
    {
        "content": "<p>In general, we don't treat \"easy and comfortable to do without cargo\" as a design criteria.</p>",
        "id": 272473085,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645226975
    },
    {
        "content": "<p>Yeah, I can just make all my --enable-build-std do the cargo trampoline <del>except on lccc <span aria-label=\"sunglasses\" class=\"emoji emoji-1f60e\" role=\"img\" title=\"sunglasses\">:sunglasses:</span> where it can $libsrcdir/configure</del> (getting off topic, though).</p>",
        "id": 272473605,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645227312
    },
    {
        "content": "<p>I don't think <code>-Zbuild-std</code> will work in the near to intermediate future without having cargo enable nightly features of rustc and having to adopt to changes in rustc every once in a while.</p>",
        "id": 272500758,
        "sender_full_name": "bjorn3",
        "timestamp": 1645256102
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> That's one major reason it'll be hard to stabilize in Cargo, because as long as it uses nightly rustc features it'll need to stay a nightly cargo feature.</p>",
        "id": 272501300,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645256860
    }
]