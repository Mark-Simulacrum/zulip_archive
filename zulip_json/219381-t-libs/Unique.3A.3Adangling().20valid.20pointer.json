[
    {
        "content": "<p>Hi,</p>\n<p>I have been doing some digging into how Vec&lt;&gt; is implemented, and I bumped into the implementation of Unique::dangling(), and there's something that's not clear to me (Please let me know if this is not the correct channel). I am looking at the implementation <a href=\"https://github.com/rust-lang/rust/blob/b17226fcc11587fed612631be372a5b4cb89988a/library/core/src/ptr/unique.rs#L76\">here</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">dangling</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// SAFETY: mem::align_of() returns a valid, non-null pointer. The</span>\n<span class=\"w\">        </span><span class=\"c1\">// conditions to call new_unchecked() are thus respected.</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Unique</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">mem</span>::<span class=\"n\">align_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Can someone please clarify what a <em>valid</em> pointer means here?</p>",
        "id": 272478131,
        "sender_full_name": "Celina V.",
        "timestamp": 1645230781
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/ptr/index.html#safety\">https://doc.rust-lang.org/std/ptr/index.html#safety</a></p>",
        "id": 272479597,
        "sender_full_name": "The 8472",
        "timestamp": 1645232038
    },
    {
        "content": "<p>For a dangling pointer, which won't be read/written to or is for a ZST, it's alignment and not pointing to a deallocated allocation.</p>",
        "id": 272479744,
        "sender_full_name": "The 8472",
        "timestamp": 1645232162
    },
    {
        "content": "<p>And being non-null of course.</p>",
        "id": 272479763,
        "sender_full_name": "The 8472",
        "timestamp": 1645232185
    },
    {
        "content": "<p>And since that's inside a <code>T: Sized</code> impl there are no concerns about fat pointer metadata.</p>",
        "id": 272479915,
        "sender_full_name": "The 8472",
        "timestamp": 1645232333
    },
    {
        "content": "<p>That <em>seems</em> like it's making the assumption of a \"null page\", where the whole page near 0 won't have valid objects in it.</p>",
        "id": 272484659,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645236767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"442621\">Celina V.</span> <a href=\"#narrow/stream/219381-t-libs/topic/Unique.3A.3Adangling.28.29.20valid.20pointer/near/272478131\">said</a>:</p>\n<blockquote>\n<p>Can someone please clarify what a <em>valid</em> pointer means here?</p>\n</blockquote>\n<p><code>Vec</code> is using a non-null pointer to enable layout optimizations, so it can't use null.  And it wants something that it can turn into a zero-length slice, so it needs to be something correctly aligned so it will be able to pass it to <code>slice::from_raw_parts</code> in the <code>Deref</code>.</p>\n<p><a href=\"https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.dangling\">https://doc.rust-lang.org/std/ptr/struct.NonNull.html#method.dangling</a> is probably a more useful thing to look at.</p>",
        "id": 272485088,
        "sender_full_name": "scottmcm",
        "timestamp": 1645237205
    },
    {
        "content": "<p>If you haven't read it yet, <span class=\"user-mention\" data-user-id=\"442621\">@Celina V.</span>, I suggest checking out <a href=\"https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html\">https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html</a></p>\n<p>That's usually what people mean my <em>valid</em> these days, those the code in <code>RawVec</code>/<code>Unique</code> is old enough that it might be using it non-rigorously.</p>",
        "id": 272485274,
        "sender_full_name": "scottmcm",
        "timestamp": 1645237393
    },
    {
        "content": "<blockquote>\n<p>That <em>seems</em> like it's making the assumption of a \"null page\", where the whole page near 0 won't have valid objects in it.</p>\n</blockquote>\n<p>While this helps to identify a dangling pointer (<code>NonNull::dangling</code> and <code>Layout::dangling</code> do the same thing) _in debugging_, this _is_ considered a pointer that could potentially have data behind it, and users _must_ track validity in some other way. (For <code>Vec</code>, it's cap=0.)</p>",
        "id": 272550916,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1645314398
    },
    {
        "content": "<p>Note that if you were going to write such a thing yourself, you might consider using <code>Box&lt;[MaybeUninit&lt;T&gt;], A&gt;</code> instead -- that's basically what a <code>RawVec&lt;T, A&gt;</code> is storing, but in a way that might have more obvious behaviour.</p>\n<p>For example, you can create it in an obviously-correct way <em>without allocating</em> by just doing <code>Box::new([])</code>: &lt;<a href=\"https://rust.godbolt.org/z/1zPbYx6zj\">https://rust.godbolt.org/z/1zPbYx6zj</a>&gt;</p>\n<p>(Though admittedly this is a bit circular, since if you look at how <em>Box</em> is implemented you'll run into <code>Unique</code> again.)</p>",
        "id": 272554051,
        "sender_full_name": "scottmcm",
        "timestamp": 1645318112
    },
    {
        "content": "<p>Thank you for all the information. The reason I started digging into this is because I work on a automated code verification project (<a href=\"https://github.com/model-checking/kani\">Kani</a>) and I was debugging an invalid pointer arithmetic operation error that was detected while creating an iterator from an empty vector. I am trying to understand if we need to adjust our tool or if there is in fact an invalid operation.</p>\n<p>During the iterator creation, the current implementation will create the begin and end marker using the dangling pointer and it will invoke the <code>ptr::add()</code> method with offset <code>0</code>. The <code>add</code> method has the following safety condition:</p>\n<blockquote>\n<p>/// # Safety<br>\n   ///<br>\n  /// If any of the following conditions are violated, the result is Undefined<br>\n  /// Behavior:<br>\n  ///<br>\n  /// * Both the starting and resulting pointer must be either in bounds or one<br>\n  ///   byte past the end of the same [allocated object].</p>\n</blockquote>\n<p>Should <code>Unique::&lt;T&gt;::dangling().as_ptr().add(offset)</code> be considered valid for any value of offset or at least for offset 0? Is it safe?</p>\n<p>Thanks again!</p>",
        "id": 272839004,
        "sender_full_name": "Celina V.",
        "timestamp": 1645551441
    },
    {
        "content": "<p>It's definitely not valid for arbitrary index -- to accept anything that's what <code>wrapping_offset</code> is for.</p>\n<p>Note that pointer <code>offset</code>/<code>add</code>/<code>sub</code> are LLVM's <code>getelementpointer inbounds</code> (<a href=\"https://llvm.org/docs/LangRef.html#getelementptr-instruction\">https://llvm.org/docs/LangRef.html#getelementptr-instruction</a>) so you might find more resources about that one.</p>\n<p>It's my understanding that an offset of zero is allowed from any non-null address.  (I'm unsure whether even that is allowed from a null pointer.)</p>",
        "id": 272842838,
        "sender_full_name": "scottmcm",
        "timestamp": 1645553003
    },
    {
        "content": "<p>Dangling pointers are from a int-to-ptr cast though. the compiler doesn't know their allocation bounds.</p>",
        "id": 272855533,
        "sender_full_name": "The 8472",
        "timestamp": 1645558563
    },
    {
        "content": "<p>So it does violate the first safety constraint right? The LLVM documentation also mentions that the correct behavior requires a pointer to an allocated object:</p>\n<blockquote>\n<p>If the inbounds keyword is present, the result value of the getelementptr is a poison value if one of the following rules is violated:</p>\n<p>The base pointer has an in bounds address of an allocated object, which means that it points into an allocated object, or to its end. The only in bounds address for a null pointer in the default address-space is the null pointer itself.<br>\n...</p>\n</blockquote>\n<p>I can't find any specific rule about int-to-ptr cast though.</p>",
        "id": 272855917,
        "sender_full_name": "Celina V.",
        "timestamp": 1645558786
    },
    {
        "content": "<p>Personally I'd say that what makes the pointers \"dangling\" is that they're not actually pointing to any non-zero-sized allocated object.  (They're arguably pointing at a <code>[T; 0]</code> allocated object, though.)</p>",
        "id": 272856906,
        "sender_full_name": "scottmcm",
        "timestamp": 1645559254
    },
    {
        "content": "<p>And we could conceptually replace their implementation with an intrinsic that explicitly gives a not-an-allocated-object pointer, rather than using an int-to-ptr cast, if we wanted to.</p>",
        "id": 272857028,
        "sender_full_name": "scottmcm",
        "timestamp": 1645559312
    },
    {
        "content": "<p>But you might also be interested in <a class=\"stream\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines\">#t-lang/wg-unsafe-code-guidelines</a>, <span class=\"user-mention\" data-user-id=\"442621\">@Celina V.</span></p>",
        "id": 272857144,
        "sender_full_name": "scottmcm",
        "timestamp": 1645559372
    },
    {
        "content": "<blockquote>\n<p>It's my understanding that an offset of zero is allowed from any non-null address.  (I'm unsure whether even that is allowed from a null pointer.)</p>\n</blockquote>\n<p>It's definately valid for null+0, gepi is used for pointer arithmetic by clang IIRC, and both C and C++ permit adding 0 to a null pointer.<br>\nIt's not allowed for a completely out-of-bounds pointer, though, such as a dangling pointer.</p>",
        "id": 272859450,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645560368
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/Unique.3A.3Adangling.28.29.20valid.20pointer/near/272859450\">said</a>:</p>\n<blockquote>\n<p>It's not allowed for a completely out-of-bounds pointer, though, such as a dangling pointer.</p>\n</blockquote>\n<p>That's interesting, because IIRC we compile <code>let x = &amp;[];</code> to a \"dangling\" pointer, and the same method <a href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_ptr_range\">https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_ptr_range</a> will <code>.add(0)</code> onto that pointer.</p>",
        "id": 272861354,
        "sender_full_name": "scottmcm",
        "timestamp": 1645561362
    },
    {
        "content": "<p>Dangling in terms of oob is not the same as <code>NonNull::dangling()</code>.</p>",
        "id": 272861695,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645561546
    },
    {
        "content": "<p>Hmm, seems like we need more words here then, since the topic mentions <code>Unique::dangling</code>, so that's how I was interpreting it.</p>\n<p>So are you saying that <code>.add(0)</code> after moving out side an allocated object would be UB?  Like <code>.wrapping_offset(100).add(0)</code>?  That would make sense to me.</p>",
        "id": 272861975,
        "sender_full_name": "scottmcm",
        "timestamp": 1645561683
    },
    {
        "content": "<p>Yeah. Or, I believe it also applies if you are starting inside a dead allocation.</p>",
        "id": 272862047,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645561724
    }
]