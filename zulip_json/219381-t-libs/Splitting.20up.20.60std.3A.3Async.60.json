[
    {
        "content": "<p>I’ve started looking at refactoring the <code>sync</code> module into new top-level ones as a chance to remove poisoning, shed some baggage, make <code>Arc</code> easier to find: <a href=\"https://gist.github.com/KodrAus/095cc49d00b22a66fd742bd219b16663\">https://gist.github.com/KodrAus/095cc49d00b22a66fd742bd219b16663</a></p>\n<p>I’ve got a branch in progress to see what the churn would look like for some big projects out there, but it’ll probably be on the backburner for a while. It might be nice to see if we’ve got appetite for shifting to a new structure for 2021 :slight_smile: </p>\n<p>The shape of the new modules and what not to bring over is just a strawman as a starting point. Does anybody have any other wishlist items for <code>sync</code>?</p>",
        "id": 208461860,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598748959
    },
    {
        "content": "<p>huge +1 on doing this!</p>",
        "id": 208462560,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1598750310
    },
    {
        "content": "<p>Putting Barrier in std::mutex is a bit strange</p>",
        "id": 208462564,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1598750335
    },
    {
        "content": "<p>maybe there's not a clearly good place to stick it though?</p>",
        "id": 208462571,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1598750347
    },
    {
        "content": "<p>Yeh, I wasn’t sure where it might belong so ended up stuffing it in <code>mutex</code> just because it’s built on <code>Mutex</code> and <code>Condvar</code></p>",
        "id": 208462696,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598750560
    },
    {
        "content": "<p>honestly we could think about not moving it</p>",
        "id": 208462707,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1598750614
    },
    {
        "content": "<p>it's a much more obscure synchronization primitive than mutex/condvar/rwlock</p>",
        "id": 208462711,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1598750629
    },
    {
        "content": "<p>That sounds good. It looks like its pretty small and I haven’t noticed any usages of it in the compiler yet so will try leaving it deprecated</p>",
        "id": 208463173,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598751555
    },
    {
        "content": "<p>I don't think I've ever used it outside benchmark code - maybe worth doing some GitHub searching though, as at least tokio replicated an async version</p>",
        "id": 208464239,
        "sender_full_name": "simulacrum",
        "timestamp": 1598753559
    },
    {
        "content": "<p>I would re-iterate that I don't think <code>mpsc</code> should be deprecated without a replacement. The existence of better implementations isn't enough to warrant deprecation, <code>mpsc</code> is still useful enough on its own. It should be pointed out that there is no stable 1.0.0 alternative to <code>mpsc</code>. <code>chan</code> is deprecated, <code>crossbeam-channel</code> and <code>flume</code> are still <code>0.x</code>. Which makes them all unsuitable for learning materials, because you don't want unstable APIs in tutorials and books about synchronisation primitives. I don't think people will see the removal of this functionality as an improvement to the standard library.</p>\n<p>That aside I think the deprecation of the <code>sync</code> module is significant enough that the deprecation lint should be across an edition, even if the new modules are stable much earlier. I think  just the amount of warnings this will trigger alone should put it behind an edition, so that people are opting into seeing that warning.</p>",
        "id": 208478252,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1598782738
    },
    {
        "content": "<p>What's stopping crossbeam-cannel from being 1.0?</p>",
        "id": 208478380,
        "sender_full_name": "isHavvy",
        "timestamp": 1598782957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"296643\">@isHavvy</span> You’d have to ask the maintainers, I’m more pointing out that right now a advertised stable alternative doesn’t really exist right now</p>",
        "id": 208484712,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1598793171
    },
    {
        "content": "<p>I believe the author of flume is currently working on proposing a change to the standard library that would use flume as the implementation of mpsc. That would address some correctness issues, and provide better performance.</p>",
        "id": 208492676,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598805177
    },
    {
        "content": "<p>The correctness issues are, I believe, why people would like to deprecate it.</p>",
        "id": 208492684,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598805187
    },
    {
        "content": "<p>Performance and correctness issues aside I think the teaching usecase is a good motivation, but still don’t feel it’s compelling enough to keep mpsc on its own as it is. It’s not complete (it’s just mpsc, no mpmc or oneshots), and it’s not futures aware either. Not having stable alternatives is really just a point in time issue. So I think if we want channels in the standard library going forward then they should be re-examined entirely</p>",
        "id": 208493802,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598806389
    },
    {
        "content": "<p>But by splitting up the <code>sync</code> module we do at least have a good chance to re-examine things!</p>",
        "id": 208494466,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598807111
    },
    {
        "content": "<p>If we do want to bring channels forward then I think they should be mpmc</p>",
        "id": 208494556,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598807254
    },
    {
        "content": "<p>Yeah, I think I agree with all of that, I think it would be good to include that motivation as well motivation for anything else that won't make the transition in the proposal.</p>",
        "id": 208494620,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1598807342
    },
    {
        "content": "<p>One of the goals of just picking a standpoint in the RFC is to invite conversation like this to see what people care about <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 208494788,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598807600
    },
    {
        "content": "<p>I wonder how disruptive it would be to make <code>flume</code> receivers clonable <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 208494851,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598807655
    },
    {
        "content": "<p>It looks like quite a nice implementation</p>",
        "id": 208494869,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1598807700
    },
    {
        "content": "<p>The ability to make breaking changes in a new module makes sense to me. But FWIW: I quite like the larger <code>sync</code> module with a couple of different but somewhat related functionality (another example: <code>fs</code>). In fact, I rather dislike modules like <code>std::option</code>, <code>std::boxed</code>, <code>std::rc</code>, ... -- which basically house a single type. Most external libraries also seem to expose fewer but larger modules, something I would like for <code>std</code> as well. Though... that ship probably has sailed.</p>",
        "id": 208502135,
        "sender_full_name": "Lukas Kalbertodt",
        "timestamp": 1598818268
    },
    {
        "content": "<p>I think <code>std::collections</code> is another one that fits into that category. It has a _collection_ of unrelated collection types (except <code>Vec</code> which gets its own snowflake module) but doesn’t give me the same grab-bag impression as <code>sync</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> Maybe it’s because there’s something more concrete that ties the items in modules like <code>collections</code> and <code>fs</code> together. <code>collections</code> and <code>fs</code> tell you what the items in them are, <code>sync</code> tells you what you’d use the items for</p>",
        "id": 208776005,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599017496
    },
    {
        "content": "<p>On the topic of <code>mpsc</code>, I wonder if <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> is still interested in the old <code>std::channel</code> proposal from here: <a href=\"https://stjepang.github.io/2019/03/02/new-channels.html\">https://stjepang.github.io/2019/03/02/new-channels.html</a> It would fit very nicely with the goals and proposed layout of deprecating <code>sync</code></p>",
        "id": 208776141,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599017710
    },
    {
        "content": "<p>As for <code>atomic</code>, <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> demonstrated how <a href=\"https://github.com/rust-lang/project-safe-transmute/blob/master/rfcs/0000-ext-generic-atomic.md\">safer transmute could let us add a useful <code>Atomic&lt;T&gt;</code></a> that I believe would still work nicely with our existing <code>Atomic*</code>-based types.</p>",
        "id": 208776336,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599018021
    },
    {
        "content": "<p>Would anybody be interested in a project group to figure out exactly what a new non-poisoning <code>std::mutex</code>, <code>std::rwlock</code> API should look like, how we should lint against the old APIs without causing some kind of syncpocalypse, possibly also considering enough of a <code>std::channel</code> proposal (looks like <code>flume</code> is MPMC and futures-aware now! Which I think solves pretty much every gripe I had with <code>std::sync::mpsc</code>) that it could be added later?</p>",
        "id": 209048455,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599184627
    },
    {
        "content": "<p>While I would love to get rid of mutex poisoning (I explicitly refused to implement poisoning in <code>parking_lot</code>), I am very concerned about the API churn for users. These types are widely used in the public APIs of crates and the new <code>Mutex</code> would be a different type from the old one.</p>",
        "id": 209050717,
        "sender_full_name": "Amanieu",
        "timestamp": 1599188321
    },
    {
        "content": "<p>Hmm ok, I was under the assumption that <code>Mutex</code> isn't typically a part of a public API so thought we might be able to get away with not having to unify them</p>",
        "id": 209050851,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599188523
    },
    {
        "content": "<p>I'll try find some examples of libraries that use <code>std::sync::Mutex</code> publicly (I personally always try to hide it) to see how it's used that way. Does anybody know of any already?</p>",
        "id": 209052417,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599191140
    },
    {
        "content": "<p>I did this once, <a href=\"https://docs.rs/randomize/1.0.0/randomize/fn.global_gen.html\">https://docs.rs/randomize/1.0.0/randomize/fn.global_gen.html</a></p>",
        "id": 209054893,
        "sender_full_name": "Lokathor",
        "timestamp": 1599195233
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>! Is that gone in the current version of <code>randomize</code>?</p>",
        "id": 209054954,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599195324
    },
    {
        "content": "<p>That's the last version with it, yeah. After that I just put a global_gen mechanic into specific projects that needed it (eg: <a href=\"https://github.com/Lokathor/dice-bot-rs/blob/master/src/global_gen.rs\">here</a>).</p>\n<p>Not that using a MutexGuard in the public API was confusing or anything, just that a global generator <em>in general</em> is mildly bad PRNG practice because it discourages you from easy save/restore/replay of whatever you're doing randomly.</p>",
        "id": 209055249,
        "sender_full_name": "Lokathor",
        "timestamp": 1599195759
    },
    {
        "content": "<p>Yeh this is a definitely a good example to look at!</p>",
        "id": 209062275,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599203932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Could you expand on what you mean API churn in this case? I don’t see right now how not having locking in the API would be significantly more churn than introducing a new Mutex type in the first place.</p>\n<p>If the concern is “people have <code>.lock()</code> everywhere in their code and it’s a hassle to remove” , I would go back to that if the <code>std::sync</code> transition was part of an edition,  the “churn” is entirely opt-in and we could have a <code>cargo fix</code> lint for upgrading the Mutex type that changes the import and removes all use of <code>.lock</code>.</p>\n<p>Obviously that won’t fix cases like <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>’s where the guard is part of the public API, but it should be sufficient for everyone else.</p>",
        "id": 209068804,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599209184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> I think in this case it is those public API usages that <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> is referring to</p>",
        "id": 209069337,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599209604
    },
    {
        "content": "<p>But that’s also a good point about <code>.lock()</code></p>",
        "id": 209069353,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599209629
    },
    {
        "content": "<p>i'd also be concerned about churn if we're going to deprecate <code>Mutex</code>. there's a lot of code out there using it. if we were to do that, then i'd strongly prefer that we do it at an edition boundary and it, if possible, make it easy to transition to the new mutex type with <code>cargo fix</code>. (i don't know if we can do that automatically. are there cases where people _want_ poisoning?)</p>\n<p>as for channels, i still think we should just deprecate mpsc in std and let people use <a href=\"http://crates.io\">crates.io</a>. i don't really buy the argument that we shouldn't do that because there's no stable alternative. in practice, <code>crossbeam-channel</code> is quite stable.</p>",
        "id": 209086287,
        "sender_full_name": "BurntSushi",
        "timestamp": 1599221725
    },
    {
        "content": "<p>If the old Mutex type is deprecated in compiler version <code>1.X</code>, then it shouldn't matter if my crate is set for 2015 or 2018 or 2048. The type is deprecated, no matter the edition.</p>",
        "id": 209088674,
        "sender_full_name": "Lokathor",
        "timestamp": 1599223312
    },
    {
        "content": "<p>we should be able to link deprecations to a given version</p>",
        "id": 209088937,
        "sender_full_name": "lcnr",
        "timestamp": 1599223467
    },
    {
        "content": "<p>so we would be able to only deprecate a type in the 2021 edition</p>",
        "id": 209088960,
        "sender_full_name": "lcnr",
        "timestamp": 1599223480
    },
    {
        "content": "<p>But why is compiler version being linked to edition in this case?</p>",
        "id": 209090644,
        "sender_full_name": "Lokathor",
        "timestamp": 1599224529
    },
    {
        "content": "<p>afaict <span class=\"user-mention silent\" data-user-id=\"222471\">BurntSushi</span> wants to only deprecate in edition N while keeping editions &lt;N as is</p>",
        "id": 209090773,
        "sender_full_name": "lcnr",
        "timestamp": 1599224617
    },
    {
        "content": "<p>might have missed something here though</p>",
        "id": 209090794,
        "sender_full_name": "lcnr",
        "timestamp": 1599224634
    },
    {
        "content": "<p>i think it might be nice to tie it to the edition, ya, but mainly what i'm after is churn reduction. churn is most painful when it trickles. it we bundle it with the edition changes and what not, and provide a <code>cargo fix</code>, then we reduce churn because folks can do more things at once.</p>",
        "id": 209091612,
        "sender_full_name": "BurntSushi",
        "timestamp": 1599225131
    },
    {
        "content": "<p>we specifically tell people that edition is not an upgrade they need to make, immediately or ever.</p>",
        "id": 209091826,
        "sender_full_name": "Lokathor",
        "timestamp": 1599225281
    },
    {
        "content": "<p>If there is to be a deprecation, it doesn't make any sense for some old edition to not get the deprecated warning when a newer edition does get the warning in the same compiler.</p>",
        "id": 209092017,
        "sender_full_name": "Lokathor",
        "timestamp": 1599225371
    },
    {
        "content": "<p>again, i said, \"i think it might be nice.\" but you're missing my broader point: i want churn to be reduced by bundling deprecations together. doing it when an edition is released does not require deprecating it for a newer edition and not an older edition. it's just adding the deprecation in the same release that the edition is a part of.</p>\n<p>to clarify: 1) strongly feel that churn should be minimized by bundling deprecations and what not together and 2) weakly feel that adding a deprecation for a new edition but not an old edition would be even nicer.</p>",
        "id": 209092526,
        "sender_full_name": "BurntSushi",
        "timestamp": 1599225679
    },
    {
        "content": "<p>I’ve definitely wanted poisoning in the past, but never through <code>Mutex</code>, so was thinking a more lightweight <code>panic::Poison&lt;T&gt;</code> might be worth looking at someday.</p>\n<p>There’s definitely a lot to think about. I’m not sure how much <code>Mutex</code> comes up in public API (@Lokathor gave an example before), but we’d want to minimise churn as much as we possibly can. People bet on the stability of the standard library so ending up forking a common type like <code>Mutex</code> should be done really carefully. On the other hand I feel like these kinds of things will continue to come up over the next 5, 10, 15 years, so it would be good to get an idea of how we can keep std both relevant and stable over that time</p>",
        "id": 209092578,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599225715
    },
    {
        "content": "<p>I think collections that are generic over allocators is in a bit of a similar boat, isn’t it? Where we have some ideas but no silver bullets?</p>",
        "id": 209092880,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599225860
    },
    {
        "content": "<p>I do agree with minimizing churn as a general principal.</p>",
        "id": 209092976,
        "sender_full_name": "Lokathor",
        "timestamp": 1599225920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204346\">@Ashley Mannix</span> last I heard, being generic over your allocator is backwards compatible as a change (older folks who didn't give an allocator get the global allocator as their allocator)</p>",
        "id": 209093144,
        "sender_full_name": "Lokathor",
        "timestamp": 1599225997
    },
    {
        "content": "<p>Ah right <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> I should try catch up on that <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 209093349,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599226100
    },
    {
        "content": "<p>I think it's also important to make sure we're not taking too big of a step for too small of a change. As a user I'm less likely to use the new stuff if it's not exciting or meaningfully better than the old API. As part of that it's important to note that the <code>std::sync</code> split can only really happen once. So the design of the new APIs should at least consider what could be done to prevent needing to make a <code>std::mutex2;</code> or other equivalents in five years.</p>",
        "id": 209107413,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599233171
    },
    {
        "content": "<p>i've done some experimenting with a profiler and some synthetic benchmarks in the past and (on my machine, an x86_64-apple-darwin, in low contention, etc etc) and checking the thread locals to implement poisoning seemed to dominate mutex lock/unlock time, which surprised me.</p>\n<p>i guess this is mostly because of <a href=\"https://github.com/rust-lang/rust/issues/67056#issuecomment-562925627\">https://github.com/rust-lang/rust/issues/67056#issuecomment-562925627</a> maybe?</p>\n<p>that said people tend to reach for parking_lot as soon as they have mutex perf issues, which would still be the case even if libstd's mutex didn't have this particular issue.</p>",
        "id": 209145311,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599257180
    },
    {
        "content": "<p>idk why you couldn't export a <code>std::mutex::{Mutex, PoisoningMutex}</code>, and then std::sync would have a <code>pub use std::mutex::PoisoningMutex as Mutex;</code></p>",
        "id": 209145376,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599257255
    },
    {
        "content": "<p>(i guess i agree that poisoning is a dubious choice but it seems weird to deprectate now, unless you're also going to deprecate <code>UnwindSafe</code> and friends — which, to be fair, i'd be in favor of)</p>",
        "id": 209145470,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599257352
    },
    {
        "content": "<p>I feel that poisoned mutexes are a much to niche concept to ideally include in the standard library, but I would be more than happy to reexport as <code>std::mutex::PoisoningMutex</code> as <span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> suggested to ease the transition given that they're already there.</p>",
        "id": 209147892,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599259921
    },
    {
        "content": "<p>yeah ideally... but i agree with <span class=\"user-mention\" data-user-id=\"222471\">@BurntSushi</span> that it seems maybe too big/common of an API to just deprecate without an automated fix... unfortunately, it doesn't feel like it's trivial to do automatically.</p>\n<p>that is, idk how (e.g) rustfix could handle code that attempts to handle poisoning in any way other than <code>unwrap()</code> (it's not rare to see code that by manually extracting the guard, or <code>map_err</code>-ing it which is kinda dubious imo since it's not exactly an error you can meaningfully handle).</p>\n<p>but even worse: the <code>.lock().unwrap()</code> case is tough too: it could be a load-bearing unwrap (and if nothing else, i've relied on poisoning in tests to make sure that a data structure holding a mutex behaved as I intended when the mutex got poisoned).</p>\n<p>... and do any of the current rustfix transforms change semantics like this?</p>",
        "id": 209148970,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599261032
    },
    {
        "content": "<p>one option might be to just deprecate the usage as <code>std::sync::Mutex</code> (is it possible to just deprecate a reexport without deprecating the type itself?), and ask people who can't easily migrate to explicitly use <code>std::mutex::PoisoningMutex</code> (which could be trivially rustfixed). that is, essentially make it so you are explicitly opting in to the poisoning behavior, and deprecating the poison-by-default.</p>\n<p>(anyway i had actually thought i was in the minority in thinking poisoning was bad, so i'm actually pretty thrilled to see this thread)</p>",
        "id": 209149053,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599261131
    },
    {
        "content": "<p>(Actually, my <code>global_generator</code> function did \"handle\" the poisoning... by just ignoring it, which is the correct thing to do in that specific case.)</p>",
        "id": 209153107,
        "sender_full_name": "Lokathor",
        "timestamp": 1599266613
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> As I understand rustfix works through lints. So if it’s possible to lint against it should be possible to write a transform for it.</p>",
        "id": 209167213,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599293213
    },
    {
        "content": "<p><code>PoisoningMutex</code> is an interesting idea <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> I’d be up for that too to help folks actually depending on poisoning or who are stuck with it in their public API.</p>\n<p>The <code>UnwindSafe</code> and <code>RefUnwindSafe</code> panic safety system is a bit of an odd one isn’t it, because it’s coarsely applied (so is opted-out for lots of types, even if they are panic safe), is trivial to work around (by just asserting you’re not bothered), and is off the beaten track compared to concurrency so is often overlooked and doesn’t have a lot of tools to support building panic safe types.</p>\n<p>I do actually use it though at the FFI of an embedded codebase without <code>AssertUnwindSafe</code>, which imposes a panic safety constraint throughout the rest of the codebase that has caught oversights, so I do find it valuable.</p>",
        "id": 209171985,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599302002
    },
    {
        "content": "<p>It’s just that <code>Mutex</code> is never the tool I reach for when I need panic safety 🙂</p>",
        "id": 209172042,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599302084
    },
    {
        "content": "<p>It might be worth making a post on the blog or internals saying the libs team is trying to find out how people use mutex's poisoning? That would at least take the temperature on what users might feel about that change without having to propose a new API.</p>",
        "id": 209174543,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599306737
    },
    {
        "content": "<p>The fact that you seemingly can't declare that <code>&amp;mut MyType</code> is always unwind safe is also an unfortunate situation.</p>",
        "id": 209177583,
        "sender_full_name": "Lokathor",
        "timestamp": 1599311851
    },
    {
        "content": "<p>I would also like to get rid of <code>UnwindSafe</code> personally, but that's a lot easier to do than poisoning: just dropping the bound from <code>catch_unwind</code> should be enough.</p>",
        "id": 209192193,
        "sender_full_name": "Amanieu",
        "timestamp": 1599333890
    },
    {
        "content": "<p>I would love to see a bit more of a retrospective on why it’s not so successful as an auto system. That might be helpful for future efforts to design new ones, since they come up from time to time</p>",
        "id": 209200953,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599350058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> Good idea! Maybe a blog post + survey would have the biggest reach? I put a quick call out on Twitter and got some more similar examples to <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>’s public guard</p>",
        "id": 209200968,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599350138
    },
    {
        "content": "<p>The unwind safe system?</p>",
        "id": 209201064,
        "sender_full_name": "Lokathor",
        "timestamp": 1599350318
    },
    {
        "content": "<p>Yeh</p>",
        "id": 209201295,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599350818
    },
    {
        "content": "<p>What RFC established it? Without knowing the goals, it's hard to say where things wrong.</p>",
        "id": 209201721,
        "sender_full_name": "Lokathor",
        "timestamp": 1599351788
    },
    {
        "content": "<p>After a little spelunking this looks like the one: <a href=\"https://github.com/rust-lang/rfcs/pull/1323\">https://github.com/rust-lang/rfcs/pull/1323</a></p>",
        "id": 209205079,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599359038
    },
    {
        "content": "<p>It looks like the bound used to be <code>Send + ‘static</code> for historical reasons, there was a desire to just remove them and stabilize a safe <code>catch_unwind</code> with no bounds (like <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> is suggesting now), but that was pushed back on with concerns that we’d make error management through panics too easy and subvert <code>Result</code>. Since <code>Send + ‘static</code> actually tells you nothing about panic safety a new auto trait was introduced for it, which became <code>UnwindSafe</code>. I think the  <code>RefUnwindSafe</code> trait was introduced later to try fix some issues with smart pointers. Thanks, I think, to <code>?</code> that subversion of <code>Result</code> didn’t happen anyways. So now we’re several years on questioning the relevance of <code>UnwindSafe</code>.</p>",
        "id": 209205301,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599359511
    },
    {
        "content": "<p>Well, first of all, all unsafe code has to be panic safe. That's just a fact.</p>",
        "id": 209205679,
        "sender_full_name": "Lokathor",
        "timestamp": 1599360317
    },
    {
        "content": "<p>Next, <code>&amp;mut T</code> is anti-UnwindSafe by default, for... reasons I don't quite get. I suppose it's something about \"well what if the type panic'd in the middle of an operation?\", but again all types need to be panic safe at all times. If you are ever temporarily in an inconsistent state that could lead to unsafety you need to make sure that no panics can possibly happen during those moments, or your code is unsound. If the code is just in an inconsistent state where things will maybe act weird without being UB, well avoid that but ultimately \"whatever\".</p>",
        "id": 209205790,
        "sender_full_name": "Lokathor",
        "timestamp": 1599360582
    },
    {
        "content": "<blockquote>\n<p>Well, first of all, all unsafe code has to be panic safe. That's just a fact.</p>\n</blockquote>\n<p>this depends on your definition of panic safety. obviously it still needs to behave soundly in the face of panics, but that's not actually what UnwindSafe/RefUnwindSafe are about at all, which i think is another part of the issue — calling it \"safety\" is very confusing. you're mention of soundness re: &amp;mut T also conflates this. unwind safety is about correctness, <em>not</em> soundness.</p>",
        "id": 209205836,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599360633
    },
    {
        "content": "<p>Yeah, I'd say even just the naming is part of the problem here.</p>",
        "id": 209205847,
        "sender_full_name": "Lokathor",
        "timestamp": 1599360671
    },
    {
        "content": "<p>2015 was perhaps an era of being less disciplined with terminology, I don't think the same name would be developed today in 2020.</p>",
        "id": 209205856,
        "sender_full_name": "Lokathor",
        "timestamp": 1599360709
    },
    {
        "content": "<blockquote>\n<p>I would love to see a bit more of a retrospective on why it’s not so successful as an auto system.</p>\n</blockquote>\n<p>some issues i've had when working with/writing a lot of code that tried to use UnwindSafe/RefUnwindSafe correctly (specifically the code in <a href=\"https://github.com/mozilla/application-services/\">https://github.com/mozilla/application-services/</a>, since all of it's functions go through something like <a href=\"https://docs.rs/ffi-support/0.4.2/ffi_support/fn.call_with_result.html\">https://docs.rs/ffi-support/0.4.2/ffi_support/fn.call_with_result.html</a> , which requires unwind safety)</p>\n<ul>\n<li>\n<p>the things unwind safety guarantees are confusing, partially because of it's name, as i just mentioned.</p>\n</li>\n<li>\n<p>it's hard to \"prove\" unwind safety, since it's an assertion about basically every line of the type's implementation where a <code>&amp;mut T</code> (or type with interior mutability) is in scope. in practice everything can panic unless you're extremely careful. (ironically, i think thread safety is easier to prove for the most part... at least for many cases).</p>\n</li>\n<li>\n<p>it's rarely used and kind of obscure, so libraries don't manually implement it for their types that use interior mutability, even if they'd consider issues with it a bug.</p>\n</li>\n<li>\n<p>RefUnwindSafe is very poorly documented, but is required to mark a &amp;T of your type unwind safe if it wouldn't otherwise be (i think? i always had trouble making this work).</p>\n</li>\n<li>\n<p>similarly, nothing exists to make <code>&amp;mut T</code> unwind safe, despite the fact that it's possible for me to write a type where i promise something like: \"if a panic is emitted from a function it has that takes a <code>&amp;mut MyType</code>, then it will behave as if the function was not called\" (a la c++ exception safe types)</p>\n</li>\n<li>\n<p>catch_unwind is required for soundness at FFI barriers, for example (this is being worked on, sure, but for a long time it has been an issue). additionally, if you plan to <code>resume_unwind</code>, it's not really clear if that makes the AssertUnwindSafe okay. these things mean that it's not really practical to try to require unwind safety.</p>\n</li>\n<li>\n<p>the only other language that worries about this that i know of is C++, despite exceptions being very common in many other languages. it <em>feels</em> like this has something to do with memory or thread safety (because it's almost a rust-specific concept), which is scary. (see also: naming)</p>\n</li>\n</ul>\n<p>i could keep going probably. honestly, it really feels like this was added just to discourage using catch_unwind, not because it actually allows you to reason about the correctness of your code.</p>",
        "id": 209206316,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599361623
    },
    {
        "content": "<p>a lot of those are related. i think it's a very wishy-washy notion of safety. the thing is: a type made up of thread safe parts is (barring unsafe code) still thread safe.</p>\n<p>a type made up of unwind safe parts isn't necessarily unwind safe, which is why the <code>&amp;mut T</code> restriction exists, but also why it works much less well than the other auto traits</p>",
        "id": 209206375,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599361795
    },
    {
        "content": "<blockquote>\n<p>catch_unwind is required for soundness at FFI barriers, for example (this is being worked on, sure, but for a long time it has been an issue). additionally, if you plan to resume_unwind, it's not really clear if that makes the AssertUnwindSafe okay. these things mean that it's not really practical to try to require unwind safety.</p>\n</blockquote>\n<p>+1 to this, I have to use AssertUnwindSafe regardless of the type or unwinding will <em>actually</em> be unsound</p>",
        "id": 209206478,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599361997
    },
    {
        "content": "<p>so it's actually <em>adding</em> a roadblock to writing correct code</p>",
        "id": 209206479,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599362009
    },
    {
        "content": "<p>I'd like to specifically note that a wrapper type which blindly makes a thing \"safe\" using a value constructor that's totally unchecked is... a poor example if anyone were to emulate it in their own crate.</p>",
        "id": 209208001,
        "sender_full_name": "Lokathor",
        "timestamp": 1599365304
    },
    {
        "content": "<p>yeah, there are a lot of reasons calling it unwind-safety is dodgy... i'm sympathetic for the decision, since the name (seems like it) was taken from c++'s notion of exception safety which can be used to mean either correctness (like UnwindSafe) or soundness (unlike UnwindSafe).</p>\n<p>note: c++ does actually distinguish between the \"correctness\" and \"soundness\" aspect some, in that there's a \"strong exception-safety guarantee\" (correctness under exceptions — the moral equivalent to UnwindSafe), but also a weaker \"basic exception-safety guarantee\" which is basically just soundness under exceptions. (see <a href=\"https://www.boost.org/community/exception_safety.html\">https://www.boost.org/community/exception_safety.html</a> if you want to read more about this for whatever reason)</p>\n<p>that said, imo the concept shouldn't exist in rust. UnwindSafe being mostly equivalent to a subtle and (very) tricky to get right c++ invariant (e.g. strong exception safety) doesn't earn it any points from me.</p>",
        "id": 209238827,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599421486
    },
    {
        "content": "<p>there's a bunch of discussion about poisoned mutexes being unnecessary, but about 50% pieces of code that I’ve written where mutex was poisoned code would have been unsound if poisoning was not a thing.</p>",
        "id": 209243912,
        "sender_full_name": "nagisa",
        "timestamp": 1599430432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> But a user can safely ignore poisoning with <a href=\"https://doc.rust-lang.org/nightly/std/sync/struct.PoisonError.html#method.into_inner\"><code>PoisonError::into_inner</code></a>...</p>",
        "id": 209245790,
        "sender_full_name": "Amanieu",
        "timestamp": 1599433786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> Oh that’s interesting 🤔 Do have any examples to point to?</p>",
        "id": 209246541,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599435231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/219381-t-libs/topic/Splitting.20up.20.60std.3A.3Async.60/near/209245790\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> But a user can safely ignore poisoning with <a href=\"https://doc.rust-lang.org/nightly/std/sync/struct.PoisonError.html#method.into_inner\"><code>PoisonError::into_inner</code></a>...</p>\n</blockquote>\n<p>ugh.</p>",
        "id": 209246588,
        "sender_full_name": "nagisa",
        "timestamp": 1599435281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204346\">@Ashley Mannix</span> it was mostly in FFI-using wrappers that temporarily make internal state of the data type inconsistent or invalid.</p>",
        "id": 209246599,
        "sender_full_name": "nagisa",
        "timestamp": 1599435317
    },
    {
        "content": "<p>an example of that being having a pointer field pointing to an invalid type while its being reconstructed or something along those lines.</p>",
        "id": 209246652,
        "sender_full_name": "nagisa",
        "timestamp": 1599435363
    },
    {
        "content": "<p>but I guess that makes the wrapper itself unsound given <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span>'s comment above.</p>",
        "id": 209246718,
        "sender_full_name": "nagisa",
        "timestamp": 1599435521
    },
    {
        "content": "<p>I always was just very happy with it exploding in my face loudly and never bothered to check if somebody could willingly __ignore__ it.</p>",
        "id": 209246731,
        "sender_full_name": "nagisa",
        "timestamp": 1599435556
    },
    {
        "content": "<p><a href=\"https://crates.io/crates/antidote\">https://crates.io/crates/antidote</a></p>",
        "id": 209246747,
        "sender_full_name": "Amanieu",
        "timestamp": 1599435588
    },
    {
        "content": "<p>To maintain soundness you really need to use drop guards.</p>",
        "id": 209246790,
        "sender_full_name": "Amanieu",
        "timestamp": 1599435608
    },
    {
        "content": "<p>I’ve got a draft post in the HackMD now that introduces poisoning and why we think the way we do it on <code>Mutex</code> and <code>RwLock</code> is worth trying to fix. Any feedback or edits would be much appreciated! <a href=\"https://hackmd.io/icmi6sjlRcKkL9T49iQiDg\">https://hackmd.io/icmi6sjlRcKkL9T49iQiDg</a></p>",
        "id": 209972304,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600068463
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <span class=\"user-mention\" data-user-id=\"323697\">@Tim McNamara</span></p>",
        "id": 209972397,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600068508
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204346\">@Ashley Mannix</span> Great write up, I think it explains the context and motivation for this change effectively.</p>",
        "id": 209975080,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1600070622
    },
    {
        "content": "<p>Sorry to intervene in this thread, I am no libs-team member, just a random contributor but I do use rust everyday at work and use synchronization primitives from time to time. I've read the HackMD document and personally I think it would be great to explain (or point to proper documentation in other crates) what are the options we have for what happens when a panic occurs using a non poisoning Mutex.</p>",
        "id": 210071515,
        "sender_full_name": "marmeladema",
        "timestamp": 1600123367
    },
    {
        "content": "<p>I <em>think</em> that, assuming you unwind, the MutexLock drops as normal during the unwind, and then the Mutex can just be used later on without any weirdness if you catch the unwind and continue.</p>",
        "id": 210073396,
        "sender_full_name": "Lokathor",
        "timestamp": 1600124803
    },
    {
        "content": "<p>That's also my understanding but it might not be that obvious to everyone. Just explaining that might be good enough.</p>",
        "id": 210074508,
        "sender_full_name": "marmeladema",
        "timestamp": 1600125782
    },
    {
        "content": "<p>And explaining that might also be used as an example for why poisoning Mutex is sometime not that useful: if you call <code>lock().unwrap()</code> unconditionally, then most of the time, you could be using a non poisoning Mutex and get the \"same\" behavior, being that the panic is forwarded passed the Mutex boundary. One of the difference being what thread gets unwinded</p>",
        "id": 210074988,
        "sender_full_name": "marmeladema",
        "timestamp": 1600126104
    },
    {
        "content": "<p><code>.lock().unwrap()</code> <em>does</em> have a difference when using poisoning or not though.</p>\n<p>If the mutex has poisoning and there was a panic during a lock, now you hit the Err and now you're going to panic too.</p>\n<p>If the mutex doesn't have poisoning and there was a panic during a lock, you get whatever was leftover in the mutex when the unwind dropped that lock.</p>",
        "id": 210075535,
        "sender_full_name": "Lokathor",
        "timestamp": 1600126552
    },
    {
        "content": "<p>Sure but from different code i've seen most people \"just\" want to forward the panic passed the Mutex boundary, wether it's from the thread that panic itself, or later on from a thread that tries to lock it again does not seem to matter much.</p>",
        "id": 210075760,
        "sender_full_name": "marmeladema",
        "timestamp": 1600126693
    },
    {
        "content": "<p>Then they would absolutely need to use the Poisoning version, and a non-Poisoning version would not be correct for their use case.</p>",
        "id": 210075818,
        "sender_full_name": "Lokathor",
        "timestamp": 1600126751
    },
    {
        "content": "<p>Well, not if they just want to terminate the program right?</p>",
        "id": 210075837,
        "sender_full_name": "marmeladema",
        "timestamp": 1600126791
    },
    {
        "content": "<p>If, for example, you have a main thread an a side thread, and they share a value through a mutex, and the <em>side thread</em> panics while holding the lock, it would die, but the main thread would not.</p>\n<p>Now the main thread goes to lock: if it's a non-poisoning mutex the main thread will acquire the lock and the main thread will continue with life, possibly totally oblivious to the fact that the side thread is dead.</p>",
        "id": 210075975,
        "sender_full_name": "Lokathor",
        "timestamp": 1600126922
    },
    {
        "content": "<p>Ok I see what you mean. I was mistakenly using the assumptions that the main thread would detect the panic in the thread and terminates too.</p>",
        "id": 210076351,
        "sender_full_name": "marmeladema",
        "timestamp": 1600127182
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281572\">@marmeladema</span> Thanks for the suggestion! We should note that when a panic unwinds through a non-poisoning lock it typically just unlocks normally and leaves the lock ready for the next consumer</p>",
        "id": 210206385,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600213860
    },
    {
        "content": "<p>Should we also say something about <code>Once</code>? It has its own poisoning implementation but is a bit different to <code>Mutex</code> and <code>RwLock</code>. If <code>Mutex</code>'s API was consistent with <code>Once</code>'s it would be:</p>\n<ul>\n<li><code>.lock()</code> always returns a guard or panics if the <code>Mutex</code> is poisoned (just like if you always called <code>.lock().unwrap()</code></li>\n<li><code>.lock_force()</code> always returns a guard and ignores poisoning</li>\n</ul>",
        "id": 210206774,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600214138
    },
    {
        "content": "<p>I've put together a Google Form for the survey: <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSehk-GkwoCag_w3YfXDfgeANulR0h5m2d3EzUMQaiY1vRfIEw/viewform\">https://docs.google.com/forms/d/e/1FAIpQLSehk-GkwoCag_w3YfXDfgeANulR0h5m2d3EzUMQaiY1vRfIEw/viewform</a></p>\n<p>How does that look to everybody? You technically can submit responses already, but I'll delete any that come through before we do the post <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p>Should I add some notes on how long we want to run the survey for? And who the results will be shared with?</p>",
        "id": 210480679,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600407759
    },
    {
        "content": "<p>I'd also be interested in collecting examples of when poisoning actively protected a program after a bug-induced panic (i.e. the process was better off with the poisoned lock than it would have been without it)</p>",
        "id": 210512454,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1600432869
    },
    {
        "content": "<p>That’s a good idea!</p>",
        "id": 210513934,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600433873
    },
    {
        "content": "<p>It might be a good idea to ask if people use poisoning locks for anything other than <code>m.lock().unwrap()</code> (could phrase that better) since I do intentionally use poisoning locks but always only for propagating panics, not for recovering after a panic.</p>",
        "id": 210540351,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1600444944
    },
    {
        "content": "<p>I’ll reword it a bit so it’s clear that we’re asking whether you do <code>m.lock().unwrap()</code> “on purpose”</p>",
        "id": 210600250,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600496768
    },
    {
        "content": "<p>I think the question at the start of the survey would be better as 2 questions: </p>\n<ul>\n<li>Do you use std mutexes?</li>\n<li>Do you use non-std mutexes?</li>\n</ul>\n<p>If the respondent uses both std mutexes and non-std mutexes, then they would answer both sections.</p>",
        "id": 210631590,
        "sender_full_name": "Samuel Harrington",
        "timestamp": 1600544165
    }
]