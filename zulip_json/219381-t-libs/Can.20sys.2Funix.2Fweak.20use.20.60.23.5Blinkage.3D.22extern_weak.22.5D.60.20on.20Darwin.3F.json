[
    {
        "content": "<p>I noticed that macOS/iOS are explicitly excluded from using <code>#[linkage = \"extern_weak\"]</code> in <a href=\"https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/weak.rs\">https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/weak.rs</a>. Is there a reason we don't use this there too? While there is a type of weak linkage that is not supported by Mach-O (e.g. being able to override a weakly defined symbol, as with cases like <code>malloc</code> and the like), but I think that's different than <code>extern_weak</code>, or at least our use of it.</p>\n<p>AFAICT <code>#[linkage = \"extern_weak\"]</code> is \"this is provided externally and should be null if missing\", which is (semantically) equivalent to clang's <code>__attribute__((weak_import))</code> which is used <em>extremely heavily</em> on macOS/iOS for system APIs -- nearly every system API in apple headers is defined with one of the availability macros (for example <code>__OSX_AVAILABLE(10.12)</code>), which will expand to include <code>__attribute__((weak_import))</code> (usually -- depends on what you tell clang the min supported OS version for your code is). IOW, this type of weak linkage should (in principal) be extremely robust and well-tested on these targets.</p>\n<p>That said, the comments in the code and in <a href=\"https://github.com/rust-lang/rust/pull/90846\">https://github.com/rust-lang/rust/pull/90846</a> (CC <span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span>) describe <code>extern_weak</code> behaving badly (without specifics), so I'm unsure if there's some bug in our handling (or perhaps it's not compiled to the same code as <code>weak_import</code>). My hunch is that it's just a misunderstanding stemming from Mach-O not supporting the other kinds of weak symbols, but I figured I'd check. </p>\n<p>FWIW, stdlib tests seem to pass if I change things to use <code>#[linkage=\"extern_weak\"]</code> on macOS, but \"behaving badly\" makes me wonder if there's something subtle/buggy. (I also haven't checked that it behaves properly if the symbol is missing (my machine is fully up to date), nor have I checked that the symbols are actually present -- I suppose the tests should pass even if the code is always hitting the fallback path).</p>",
        "id": 278434730,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649543991
    },
    {
        "content": "<p>I have no macOS experience myself. I don't think I added any _new_ comments about it behaving badly, just preserved past comments, maybe reworded slightly.</p>",
        "id": 278434863,
        "sender_full_name": "cuviper",
        "timestamp": 1649544181
    },
    {
        "content": "<p>Ah, sorry</p>",
        "id": 278434869,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649544192
    },
    {
        "content": "<p>No worries</p>",
        "id": 278434873,
        "sender_full_name": "cuviper",
        "timestamp": 1649544208
    },
    {
        "content": "<p>For history, maybe dig through <code>git blame</code> for that \"only really workable on Linux\" comment, where I relaxed it to ELF.</p>",
        "id": 278435016,
        "sender_full_name": "cuviper",
        "timestamp": 1649544437
    },
    {
        "content": "<p>Yeah, git blame blamed you. but I'll keep going</p>",
        "id": 278435152,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649544641
    },
    {
        "content": "<p>It seems likely that the issue is confusion between the two uses of weak (e.g. allowing the symbol to be overridden downstream vs making the symbol turn into null if missing).</p>\n<p>I don't really know why these are both considered the same, but maybe it's about ELF.</p>",
        "id": 278435154,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649544654
    },
    {
        "content": "<p>(It <em>should</em> be workable -- I'd be <em>very</em> surprised if any platforms used the \"import weakly and fall back to null\" behavior nearly as much as the apple targets)</p>",
        "id": 278435240,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649544804
    },
    {
        "content": "<p>(Conversely dlsym is heavily discouraged, at least on iOS)</p>",
        "id": 278435300,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649544888
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/commit/1a31e1c09f89daeefa06ca9336912e9bcadb0c1d\">https://github.com/rust-lang/rust/commit/1a31e1c09f89daeefa06ca9336912e9bcadb0c1d</a></p>",
        "id": 278435384,
        "sender_full_name": "cuviper",
        "timestamp": 1649545057
    },
    {
        "content": "<p>Yeah, just found that</p>",
        "id": 278435388,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649545066
    },
    {
        "content": "<p>So maybe <span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span> knows if they're still around. It doesn't seem like a concrete issue, though</p>",
        "id": 278435439,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649545115
    },
    {
        "content": "<p>Does ELF use the same functionality for both types \"weak linkage\" (e.g. overridable symbols like malloc and optional ones like this)?</p>",
        "id": 278435579,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649545282
    },
    {
        "content": "<p>any external symbol can be overridden, whether or not it's weak</p>",
        "id": 278435628,
        "sender_full_name": "cuviper",
        "timestamp": 1649545333
    },
    {
        "content": "<p>well, maybe weak allows additional overrides in different link orders, I'm not sure off hand</p>",
        "id": 278435655,
        "sender_full_name": "cuviper",
        "timestamp": 1649545418
    },
    {
        "content": "<p>but <code>LD_PRELOAD</code> can intercept most things</p>",
        "id": 278435702,
        "sender_full_name": "cuviper",
        "timestamp": 1649545453
    },
    {
        "content": "<p>see the effect of <code>LD_DYNAMIC_WEAK</code> in <a href=\"https://man7.org/linux/man-pages/man8/ld.so.8.html\"><code>man 8 ld.so</code></a></p>",
        "id": 278435737,
        "sender_full_name": "cuviper",
        "timestamp": 1649545560
    },
    {
        "content": "<p>so the \"downstream\" override was old glibc behavior</p>",
        "id": 278435801,
        "sender_full_name": "cuviper",
        "timestamp": 1649545658
    },
    {
        "content": "<p>Yeah, so on Mach-O you can import a symbol (or even an entire library) weakly, where if it's not present the symbol will be null.</p>\n<p>But overriding symbols is completely different and unrelated. That's is done via interposing, and symbols/libraries generally must opt in to being interposed. Interposing also doesn't work without futzing with env vars prior to 10.12 (and even then it's a bit dodgy usually -- e.g. malloc <em>is</em> interposable, but it shouldn't be done -- apple makes a lot of promises about how its malloc works and custom mallocs will definitely not follow them)</p>",
        "id": 278435921,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649545803
    },
    {
        "content": "<p>but <code>dlsym</code> will effectively allow interposing anyway, right?</p>",
        "id": 278435951,
        "sender_full_name": "cuviper",
        "timestamp": 1649545877
    },
    {
        "content": "<p>I suppose, but only if everybody used it.</p>",
        "id": 278436003,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649545925
    },
    {
        "content": "<p>We dont need interposing behavior though</p>",
        "id": 278436009,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649545933
    },
    {
        "content": "<p>anyway, that's not the main point we're aiming for here -- we mostly just need the link-or-null behavior</p>",
        "id": 278436010,
        "sender_full_name": "cuviper",
        "timestamp": 1649545934
    },
    {
        "content": "<p>Yeah</p>",
        "id": 278436012,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649545936
    },
    {
        "content": "<p>it's mildly nice that you <em>can</em> interpose some things here on Linux, vs raw syscalls</p>",
        "id": 278436026,
        "sender_full_name": "cuviper",
        "timestamp": 1649545990
    },
    {
        "content": "<p>Hm, how would the syscalls be interposed? I thought if you do the syscall that <em>prevents</em> something from being overridden</p>",
        "id": 278436042,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649546024
    },
    {
        "content": "<p>that's what I mean, raw syscalls avoid interposing -- unless you catch <code>libc::syscall</code> itself, since we don't actually do syscall asm ourselves</p>",
        "id": 278436097,
        "sender_full_name": "cuviper",
        "timestamp": 1649546073
    },
    {
        "content": "<p>Ah yeah. I think its actually nice when things can be overridden for testing purposes, but its neither here nor there for this</p>",
        "id": 278436128,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649546133
    },
    {
        "content": "<p>I explicitly commented this possibility for our use of <code>getrandom</code></p>",
        "id": 278436165,
        "sender_full_name": "cuviper",
        "timestamp": 1649546164
    },
    {
        "content": "<p>you can mock it to something deterministic, I suppose</p>",
        "id": 278436171,
        "sender_full_name": "cuviper",
        "timestamp": 1649546182
    },
    {
        "content": "<p>Yeah</p>",
        "id": 278436172,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649546188
    },
    {
        "content": "<p>And if someone can set LD_PRELOAD/DYLD_INSERT_LIBRARIES they can pwn the process in more direct ways than a deterministic getrandom anyway.</p>",
        "id": 278436200,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649546272
    },
    {
        "content": "<p>yeah, that's why those are ignored for setuid binaries</p>",
        "id": 278436249,
        "sender_full_name": "cuviper",
        "timestamp": 1649546304
    },
    {
        "content": "<p>anyway, I won't object if you try to make macOS/iOS use true weak linkage too. it would be nice to find the story about its past problems though.</p>",
        "id": 278436330,
        "sender_full_name": "cuviper",
        "timestamp": 1649546481
    },
    {
        "content": "<p>Yeah, sandboxed apps on apple also don't have them (unless they set an entitlement to enable dyld env vars), but this is unused except for stuff from the app stores <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 278436333,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649546484
    },
    {
        "content": "<p>Yeah, I'll look. It seems highly likely to me its just that the semantics are slightly different for ELF weak vs Mach-O weak, but in a way that does not matter here.</p>",
        "id": 278436379,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649546535
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/29603\">#29603</a> may help</p>",
        "id": 278436597,
        "sender_full_name": "cuviper",
        "timestamp": 1649546945
    },
    {
        "content": "<p>Yeah, I think it's a conflation of different features (as the last comment indicates). None of the open issues mention it, and the closed issues that seem semi-relevant all appear to be fixed.</p>\n<p>I had kinda forgotten about the weird semantics weak definitions have on Darwin. Actually, I forgot it had support for weak definitions at all (since for the most part you need to use interposing anyway). We don't need that though, just weak imports, e.g. the mach-o <code>N_WEAK_REF</code> flag should be on the symbol (whereas weak definitions are <code>N_WEAK_DEF</code>)</p>",
        "id": 278436828,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649547271
    },
    {
        "content": "<p>Ah, hm, actually it does not work. Or rather, for some reason rustc implements linkage by using a second symbol <code>_rust_extern_with_linkage_</code> which references its address, so we end up with something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">@</span><span class=\"n\">fake_symbol_lalala</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">extern_weak</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"w\"></span>\n<span class=\"o\">@</span><span class=\"n\">_rust_extern_with_linkage_fake_symbol_lalala</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">internal</span><span class=\"w\"> </span><span class=\"n\">global</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"o\">@</span><span class=\"n\">fake_symbol_lalala</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but this seems not to work on mach-o, as ld64 ends up considering it to be required. i think is probably not how extern_weak symbols should be compiled on mach-o (actually, it's surprising to me that they're compiled like this anywhere -- the comments around where this happens so that we avoid creating null references or function pointers but I think that shouldn't be relevant here). still, this seems more involved than I expected. nards.</p>",
        "id": 278443787,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649558247
    },
    {
        "content": "<p>Weak linkage is currently broken on macOS in cg_clif. Switching to it would break macOS support for cg_clif.</p>",
        "id": 278462677,
        "sender_full_name": "bjorn3",
        "timestamp": 1649589666
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20sys.2Funix.2Fweak.20use.20.60.23.5Blinkage.3D.22extern_weak.22.5D.60.20on.20Darwin.3F/near/278435439\">said</a>:</p>\n<blockquote>\n<p>So maybe <span class=\"user-mention silent\" data-user-id=\"116015\">Alex Crichton</span> knows if they're still around. It doesn't seem like a concrete issue, though</p>\n</blockquote>\n<p>The commit Josh linked looks like I was translating from one style to another, so I don't recall any reason to specifically avoid a linkage-based approach. Somewhat independently I vaguely recall that we've been burned by weak linkage in the past for one reason or another, but I think that's probably mostly due to a lack of understanding about how it was supposed to work in combination with being too ambitious about trying to use it everywhere. If it's used regularly on macOS/iOS I doubt there would be any issue to start using extern_weak linkage for symbols on just those platforms.</p>",
        "id": 278559053,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1649686232
    },
    {
        "content": "<blockquote>\n<p>in combination with being too ambitious about trying to use it everywhere</p>\n</blockquote>\n<p>This might be happening here TBH <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>. I don't think we can use it (at least not without investigation)</p>\n<p>It seems like XCode may be doing something to make it actually work, since if rust builds a static library and links it in, it works inside XCode, but if built and linked otherwise it emits a linker error even though it's marked as undefined. What _looks_ like is happening is the linker still considers it an error for weak symbols to be undefined, but that there's a workaround implemented... inside XCode?</p>\n<p>I suppose this is possible, but it approaches being bit too goofy for me to believe (my general experience is that linking/loading are pretty sane on darwin, but just not identical to other platforms).  So I have to assume something else is going on. It's a bit hard to tell though, sadly; XCode sends gobs and gobs of information to ld64 via several files so it's hard to say from just the args without really digging into it. So I don't think this can change until someone knows what the deal is. I think I'll _eventually_ try and peek through ld64's source to get to the bottom of it, but certainly it's a bit of a bummer that this doesn't just work, given how common weak symbols are on the platform...</p>\n<p>(... and not to mention how they tend to discourage use of dlsym for stuff distributed via the app stores (or they used to anyway), due to dlsym's ability to sneakily access private OS APIs in a way that doesn't show up on referenced symbol lists. That said, I have to think we'd have heard about it by now if the use in <code>weak.rs</code> was causing problems)</p>\n<blockquote>\n<p>Switching to it would break macOS support for cg_clif.</p>\n</blockquote>\n<p>Fair enough. In principal if we switched (after figuring out the linker), it would probably be fine for cl_clif to implement it as a static thats always null, or even to a strong link. Rather, these are bugs but in practice, but it isn't like we don't already have similar bugs (under LLVM) on other platforms, and they dont seem unreasonable for the use cases for cg_clif's that I've heard of. (But I wonder if you're hitting the same issue described above)</p>\n<p>Anyway it's moot because it doesn't seem to work as desired with LLVM either, at least without some additional linker massaging.</p>",
        "id": 278745745,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649793676
    }
]