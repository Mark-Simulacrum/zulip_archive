[
    {
        "content": "<p>Hey all! I've started sketching out a survey based on <span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span>'s suggestion to find out how poisoning is used out in the wild: <a href=\"https://hackmd.io/icmi6sjlRcKkL9T49iQiDg\">https://hackmd.io/icmi6sjlRcKkL9T49iQiDg</a></p>\n<p>What do you all think?</p>",
        "id": 209461725,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599612873
    },
    {
        "content": "<p>Would a post on the Rust blog with a link to the survey be appropriate? Or would the users/internals forum be better?</p>",
        "id": 209461771,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599612929
    },
    {
        "content": "<p>I think rust blog would be fine, certainly inside rust</p>",
        "id": 209461849,
        "sender_full_name": "simulacrum",
        "timestamp": 1599612985
    },
    {
        "content": "<p>But I think main blog is the place for this</p>",
        "id": 209461859,
        "sender_full_name": "simulacrum",
        "timestamp": 1599612999
    },
    {
        "content": "<p>Of course linked to from forums</p>",
        "id": 209461866,
        "sender_full_name": "simulacrum",
        "timestamp": 1599613012
    },
    {
        "content": "<p>Is there somewhere I should ask about any considerations we have for running surveys through the project?</p>",
        "id": 209461993,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599613160
    },
    {
        "content": "<p>Hm I don't think so - we usually do google forms, nothing too special</p>",
        "id": 209462763,
        "sender_full_name": "simulacrum",
        "timestamp": 1599614152
    },
    {
        "content": "<p>If you want it translated then I'd ask Niko - he has an up to date list of volunteers (we're running main 2020 survey starting Thursday, so they've all been pinged recently)</p>",
        "id": 209462828,
        "sender_full_name": "simulacrum",
        "timestamp": 1599614240
    },
    {
        "content": "<p>For the survey, we will want an accompanying short post for it. I think an explanation of what poisoning is would be good, I suspect many don't know</p>",
        "id": 209462922,
        "sender_full_name": "simulacrum",
        "timestamp": 1599614379
    },
    {
        "content": "<p>It's also sort of true that anyone using std lock types today \"depends\" on it to some extent since behavior would be different almost certainly without it</p>",
        "id": 209462987,
        "sender_full_name": "simulacrum",
        "timestamp": 1599614441
    },
    {
        "content": "<p>Question: Have you ever used a crate like <code>antidote</code> or <code>parking_lot</code> to avoid having to add <code>unwrap</code> all over your code?</p>",
        "id": 209465162,
        "sender_full_name": "Amanieu",
        "timestamp": 1599617283
    },
    {
        "content": "<p>Nice and direct <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 209465491,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599617814
    },
    {
        "content": "<p>I'll work on an accompanying post while we decide on the exact shape of the questions <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 209466059,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599618499
    },
    {
        "content": "<p>We should also run a survey to ask how people feel about <code>const fn</code>, CC <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>.</p>",
        "id": 209520875,
        "sender_full_name": "pickfire",
        "timestamp": 1599662763
    },
    {
        "content": "<p>Not sure what exactly you mean but it seems unrelated to lock poisoning, so maybe open a new thread?^^</p>",
        "id": 209528160,
        "sender_full_name": "RalfJ",
        "timestamp": 1599665671
    },
    {
        "content": "<p>I'm not sure if I missed previous discussion on this, but has <a href=\"http://joeduffyblog.com/2016/02/07/the-error-model\">\"The Error model\"</a> been brought up in this context? It's a fairly popular blog post on how to deal with errors in programming. Rust's error handling model is very close to the conclusion of that blog post: statically checked \"recoverable errors\" and abandonment in case of bugs. Particularly the later part is interesting in regards to poisoning:</p>\n<p>The author says that the correct response to a bug is to tear down the current process as everything the buggy code might have touched should be considered tainted. Rust's \"abandonment\" model, panics, only tears down the current thread, which is a lot less isolated than processes. But that's whats poisoning helps with: to better isolate a buggy (panicked) thread. </p>\n<p>So what I'm getting at: from my understanding, removing poisoning would steer Rust a bit further from the \"clean abandonment\" model in that blog post.</p>",
        "id": 210610846,
        "sender_full_name": "Lukas Kalbertodt",
        "timestamp": 1600515534
    },
    {
        "content": "<p>survey seems to ignore that <code>.lock().unwrap()</code> is very different from using a non-poisoning locks</p>",
        "id": 210611097,
        "sender_full_name": "boats",
        "timestamp": 1600515904
    },
    {
        "content": "<p><code>.lock().unwrap()</code> causes every thread that shares the data to eventually panic if one does, whereas non-poisoning allows the other threads to continue</p>",
        "id": 210611113,
        "sender_full_name": "boats",
        "timestamp": 1600515929
    },
    {
        "content": "<p>(not that im against removing lock poisoning necessarily)</p>",
        "id": 210611211,
        "sender_full_name": "boats",
        "timestamp": 1600516071
    },
    {
        "content": "<p>that is, the answer to \"Do you use the poisoning behavior of the standard library‚Äôs lock types in any of your projects?\" should be <code>yes</code> for anyone who calls <code>.lock().unwrap()</code></p>",
        "id": 210611325,
        "sender_full_name": "boats",
        "timestamp": 1600516208
    },
    {
        "content": "<p>the real questions seems more like \"have you ever thought carefully about lock poisoning when using a mutex?\" and \"do you feel you've benefit from the poisoning default?\" and \"have you ever written code to ignore the poisoning of the std mutex?\"</p>",
        "id": 210611349,
        "sender_full_name": "boats",
        "timestamp": 1600516296
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118772\">@Lukas Kalbertodt</span> I think that author is just wrong though.</p>",
        "id": 210616470,
        "sender_full_name": "Lokathor",
        "timestamp": 1600523795
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Sure, didn't mean to say that the post is completely correct. I guess the new error handling WG could think about that...</p>",
        "id": 210616580,
        "sender_full_name": "Lukas Kalbertodt",
        "timestamp": 1600523995
    },
    {
        "content": "<p><span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 210617712,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600525549
    },
    {
        "content": "<p>Thanks for the suggestions everyone! How is this looking now? <a href=\"https://docs.google.com/forms/d/e/1FAIpQLSehk-GkwoCag_w3YfXDfgeANulR0h5m2d3EzUMQaiY1vRfIEw/viewform\">https://docs.google.com/forms/d/e/1FAIpQLSehk-GkwoCag_w3YfXDfgeANulR0h5m2d3EzUMQaiY1vRfIEw/viewform</a></p>",
        "id": 210641549,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600560652
    },
    {
        "content": "<p>I‚Äôve tried to word it so users could indicate that they <code>.lock().unwrap()</code> or ignore poisoning and either do or don‚Äôt care about it</p>",
        "id": 210641612,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600560786
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118772\">Lukas Kalbertodt</span> I think that author is just wrong though.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Can you expand on that? What do you think the author is wrong about?</p>",
        "id": 210649952,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600578558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204346\">@Ashley Mannix</span> Sure, I was responding to this point:</p>\n<blockquote>\n<p>The author says that the correct response to a bug is to tear down the current process as everything the buggy code might have touched should be considered tainted.</p>\n</blockquote>\n<p>Which is like... just <em>very</em> out there as a concept. Like, so if there's a bug in some edge case of parsing user input, you should just crash the entire sever? Even though most requests are coming in and sending back out replies just fine? I can't accept that as reasonable.</p>\n<p>I'm sure there are some places where you want to blow up the universe in response to a single bug, but those are probably not too many.</p>",
        "id": 210651226,
        "sender_full_name": "Lokathor",
        "timestamp": 1600581242
    },
    {
        "content": "<p>If we use \"process\" more liberally to mean \"unit of work\" and then say \"oh well if there's a parse error we just reject that request and move on\", then <em>that</em> would be a fine take.</p>",
        "id": 210651276,
        "sender_full_name": "Lokathor",
        "timestamp": 1600581326
    },
    {
        "content": "<p>(I will admit to not having read the full article, just the summary that Lukas wrote about it)</p>",
        "id": 210651343,
        "sender_full_name": "Lokathor",
        "timestamp": 1600581443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> If bug in this case is defined as undefined behaviour and not a recoverable error (as the error post mentions) then I believe the correct thing to do is to crash the server, and it is what you want in most cases.</p>\n<p>You would not want your HTTP client/server to accept malicious TLS certificate no matter what. Parsers accepting input that leads to undefined behaviour is where a lot of biggest security vulns have come from.</p>",
        "id": 210652552,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1600584075
    },
    {
        "content": "<p>Well UB is very different from how the summary posted within this zulip topic put it XD.</p>",
        "id": 210652976,
        "sender_full_name": "Lokathor",
        "timestamp": 1600584868
    },
    {
        "content": "<p>though i opened the article just now to try and get some extra context and and couldn't find where \"undefined\" is written at all.</p>",
        "id": 210652989,
        "sender_full_name": "Lokathor",
        "timestamp": 1600584915
    },
    {
        "content": "<p>Ah ok I see where you‚Äôre coming from now üëç I guess that also relates to the panic=abort discussion on one hand, and to the way panics are sometimes treated as DoS vulnerabilities on the other. Panics indicate bugs, but bugs happen and safe systems are built to tolerate buggy components</p>",
        "id": 210656802,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600592194
    },
    {
        "content": "<p>I filled out the survey and thought it was good!</p>",
        "id": 210664111,
        "sender_full_name": "boats",
        "timestamp": 1600603955
    },
    {
        "content": "<p>From the perspective of working on servers, I have always found the \"well, you should just abort on bugs\" kind of ridiculous. If 0.1% of requests start hitting a panic at 2AM due to some bug and the server unwinds on panic, it's a thing I can fix the next day at my leisure. If the entire server process is crashing every 1,000 requests, I am going to get paged and have to fight a fire in the middle of the night. I have literally never encountered a bug in production that I wished had killed the entire process rather than panicking.</p>",
        "id": 210668759,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1600611204
    },
    {
        "content": "<p><a href=\"http://docs.rs\">docs.rs</a> actually goes even further and uses <code>catch_unwind</code> for the builds thread (although it doesn't help much, since usually if it panics once it will panic every time)</p>",
        "id": 210669369,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600612134
    },
    {
        "content": "<p>But yes abort() on error would be completely unsustainable</p>",
        "id": 210669380,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600612165
    },
    {
        "content": "<p>I wrote this up on hacker news a while back: <a href=\"https://news.ycombinator.com/item?id=22938055\">https://news.ycombinator.com/item?id=22938055</a></p>",
        "id": 210669433,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600612248
    },
    {
        "content": "<p>I probably haven't done a good job of summarizing the article. I think the article lays out the reasoning pretty well, but I also know it's long -- sorry!.Regarding crashing the whole webserver: </p>\n<p>I am pretty sure the author, by talking about \"process\", means \"unit of isolation\". As in: everything that buggy code might have influenced should be considered invalid. Within reason of course. If your webserver handles each request individually and in an isolated fashion (as it should usually be the case), then just panicking for that one request and responding 5xx, but keeping the server running is perfectly reasonable. And I think it doesn't conflict with the blog article I posted: \"architect your system so that the whole remains functional even when individual pieces fail\". </p>\n<p>And well, one way that \"isolation of threads\" is violated is via sharing data via mutexes. If one thread of a webserver panics while holding a global lock, then it might be worth thinking about whether the whole server should stop.</p>",
        "id": 210672030,
        "sender_full_name": "Lukas Kalbertodt",
        "timestamp": 1600616597
    },
    {
        "content": "<p>I didn't intend to derail the discussion into error handling though :/</p>",
        "id": 210672047,
        "sender_full_name": "Lukas Kalbertodt",
        "timestamp": 1600616626
    },
    {
        "content": "<p>I think error handling and mutex poisoning are very related</p>",
        "id": 210674218,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600619900
    },
    {
        "content": "<p>the <a href=\"http://docs.rs\">docs.rs</a> case is a little odd because we have no shared state, all the state comes from the database</p>",
        "id": 210674225,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600619919
    },
    {
        "content": "<p>so it kind of sidesteps the question</p>",
        "id": 210674241,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600619950
    },
    {
        "content": "<p>From the perspective of shipping a product to end users panic=abort is never what I want either. It's the difference between \"log and fail gracefully\" and \"fall flat on your face and have to fiddle with crash dumps\". But yeh I guess it's all a question of service boundaries how failures are surfaced. I think the wider point is that as with lots of things there are many equally valid usecases with different needs to accommodate <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 210695050,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600652414
    },
    {
        "content": "<p>I'm going to be really interested to see what kinds of combinations we get back on the questions about what you want to happen when you hit a poisoned mutex</p>",
        "id": 210695075,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600652494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204346\">@Ashley Mannix</span> You can still report and fail gracefully from a panic, you just have to do it from a panic hook, or arrange to have the program supervised.</p>",
        "id": 210696440,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1600654840
    },
    {
        "content": "<p>Yep, there's lots of different approaches <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 210699750,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600660929
    },
    {
        "content": "<p>IMO unwinding is useful only if there is the possibility of containing the failure: the typical example is to fail just one request on a server instead of taking the whole process down. If you're taking the whole process down regardless then you might as well just abort.</p>",
        "id": 210736550,
        "sender_full_name": "Amanieu",
        "timestamp": 1600692983
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204346\">@Ashley Mannix</span> Survey is nice but I think it would be good to autoskip a section if a user select \"no\", not sure if that's possible.</p>\n<blockquote>\n<p>If you use locks from outside the standard library<br>\nThis section applies if you answered ‚Äúyes‚Äù to using other lock types in any of your projects.</p>\n</blockquote>",
        "id": 211029491,
        "sender_full_name": "pickfire",
        "timestamp": 1600879213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"225422\">@pickfire</span> I couldn‚Äôt find a way to do that with Google Forms but it would be nice to be able to auto skip sections</p>",
        "id": 211074190,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600903585
    },
    {
        "content": "<p>it's possible, you need to define a new section and there's a place where you can define the flow from one section to the other, but i guess it's too late for that <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 211075989,
        "sender_full_name": "DPC",
        "timestamp": 1600905433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120823\">@DPC</span> Not at all <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span> We haven‚Äôt officially posted it yet</p>",
        "id": 211104619,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1600937886
    },
    {
        "content": "<p>Just passing through, but I recently benefited from the the ability to recover from poison:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">--- a/ui/src/sandbox.rs</span>\n<span class=\"gi\">+++ b/ui/src/sandbox.rs</span>\n<span class=\"gu\">@@ -860,6 +860,22 @@ pub struct MacroExpansionResponse {</span>\n mod test {\n     use super::*;\n\n<span class=\"gi\">+    // Running the tests completely in parallel causes spurious</span>\n<span class=\"gi\">+    // failures due to my resource-limited Docker</span>\n<span class=\"gi\">+    // environment. Additionally, we have some tests that *require*</span>\n<span class=\"gi\">+    // that no other docker processes are running.</span>\n<span class=\"gi\">+    fn one_test_at_a_time() -&gt; impl Drop {</span>\n<span class=\"gi\">+        use lazy_static::lazy_static;</span>\n<span class=\"gi\">+        use std::sync::Mutex;</span>\n<span class=\"gi\">+</span>\n<span class=\"gi\">+        lazy_static! {</span>\n<span class=\"gi\">+            static ref DOCKER_SINGLETON: Mutex&lt;()&gt; = Default::default();</span>\n<span class=\"gi\">+        }</span>\n<span class=\"gi\">+</span>\n<span class=\"gi\">+        // We can't poison the empty tuple</span>\n<span class=\"gi\">+        DOCKER_SINGLETON.lock().unwrap_or_else(|e| e.into_inner())</span>\n<span class=\"gi\">+    }</span>\n<span class=\"gi\">+</span>\n     const HELLO_WORLD_CODE: &amp;'static str = r#\"\n     fn main() {\n         println!(\"Hello, world!\");\n<span class=\"gu\">@@ -907,6 +923,7 @@ mod test {</span>\n\n     #[test]\n     fn basic_functionality() {\n<span class=\"gi\">+        let _singleton = one_test_at_a_time();</span>\n         let req = ExecuteRequest::default();\n\n         let sb = Sandbox::new().expect(\"Unable to create sandbox\");\n</code></pre></div>",
        "id": 215458154,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1604412857
    },
    {
        "content": "<p>That <code>.unwrap_or_else(|e| e.into_inner())</code> makes me think an <code>.ignore_poison()</code> would be nice. But I guess something like that probably has come up before?</p>",
        "id": 215458987,
        "sender_full_name": "Mara",
        "timestamp": 1604413229
    },
    {
        "content": "<p>Yes I have run into that one or two times, there are situations where you can be sure that even if the lock is poisend the guarded data is still valid.</p>",
        "id": 215466011,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1604416390
    },
    {
        "content": "<p>It'd be a bit weird or at least undiscoverable to add <code>.ignore_poison</code> since it'd need to be an impl on <code>Result&lt;T, PoisonError&lt;...&gt;&gt;</code></p>",
        "id": 215466156,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1604416455
    },
    {
        "content": "<p>it'd be easy to find if <code>.lock()</code> itself documents it</p>",
        "id": 215466312,
        "sender_full_name": "Mara",
        "timestamp": 1604416537
    },
    {
        "content": "<p>Or something like <code>.lock_ignoring_poisen()</code>, <code>.lock_poisond()</code>.</p>",
        "id": 215467532,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1604417054
    },
    {
        "content": "<p>If we're going to add an API, we should just add a non-poisoning mutex</p>",
        "id": 215467644,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1604417096
    },
    {
        "content": "<p>I think that would unnecessary complexity. IMHO I like that the current mutex forces you to think about poisoning. Especially if you are new to programming thinks like that are excellent to help you become a better programmer, and even if your are not new they still make you remember that you should properly handle panics.</p>",
        "id": 215468010,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1604417269
    },
    {
        "content": "<p>and a non-poisoning condvar and a non-poisoning rwlock? i'm all for it. but that's a much bigger api change. adding .ignore_poison() on the LockResult covers all those cases. and not having to switch the type just to be able to ignore posion is also useful.</p>",
        "id": 215469023,
        "sender_full_name": "Mara",
        "timestamp": 1604417686
    },
    {
        "content": "<p>Hi folks! I didn't read the backlog, so this might have been brought up already, but the thing I realized while reading the article/filling the survey is that I have never actually thought about poisoning much (if at all).<br>\nIf std had \"better\" locking primitives that have no poisoning (\"better\" as in - shorter API/faster performance) - I'd use those without second thought <em>despite</em> the fact that it would make my programs incorrect (because, again, I didn't even <em>think</em> it would be possible for them to be incorrect here)</p>\n<p>So, constructively, I would ask for the non-poisoning locks to have either big scary warnings on the doc page, or have them be <code>unsafe</code>, or more cumbersome to construct, or (and this might be the best one) simply not release the lock if being dropped during a panic (and thus stay locked, forever, until manual intervention (like <code>.force_unlock()</code> or something)). So that the user takes notice that something is off, and does not silently gets their data corrupted.</p>\n<p>Just my 2c.</p>",
        "id": 219685723,
        "sender_full_name": "moxian",
        "timestamp": 1607742451
    },
    {
        "content": "<p>I would really prefer it not to deadlock, that would be make it really hard to find what's <em>actually</em> a deadlock vs a panic that wasn't addressed</p>",
        "id": 219686718,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607743950
    },
    {
        "content": "<p>big scary warnings seems fine</p>",
        "id": 219686721,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607743961
    },
    {
        "content": "<p>I  want to argue that deadlocking on panic is good.<br>\nTwo (and a half) arguments: 1) this is how it works in \"other languages\", and it's an unsurprising behavior. You usually have something like</p>\n<div class=\"codehilite\"><pre><span></span><code>mutex.lock()\ndo_stuff()  // this might throw an exception/panic/terminate the thread/whatever\nmutex.unlock()\n</code></pre></div>\n<p>Mimicking that is at least \"not a regression\" [coming from other languages]<br>\nAlso note that this even happens in languages that use exceptions as a control flow, and where such \"panics\" are much more common.</p>\n<p>2) if the non-poisoning API is more ergonomic (due to the lack of <code>.unwrap()</code>s), then people who don't really think about intricacies of concurrency and poisoning (i.e., me) would tend to use this \"simpler\" API over the poisoning one (\"because they don't need this advanced feature\" or similar).<br>\nWhen they switch from the poisoning locks to non-poisoning, release-on-panic locks, their programs' behavior change from \"stop doing anything useful upon a panic\" to \"silently operate on corrupted data upon a panic\" (which is really really bad!!). This behavior, however, is not changed, if they switch to stay-locked-on-panic locks - the program continues to \"not do anything useful\", just in a slightly different shape now.<br>\nSo, again, deadlocking on panic is \"not a regression\" [coming from naive use of current <code>std</code> locks that doesn't handle poisoning]</p>\n<p>3) I don't even think the distinction between \"genuine deadlock\" [that arose because you failed to maintain an invariant] vs \"panic-induced deadlock\" [that arouse because you failed to restore invariant upon a panic, that you did handle, but only partially] is meaningful. It is probably nice during development, but not so much in production. And, if you really care about the two - maybe poisoning locks is what you really want here?..</p>",
        "id": 219689691,
        "sender_full_name": "moxian",
        "timestamp": 1607748114
    },
    {
        "content": "<p>In short, I believe unlocking the mutex upon panic is a footgun, and I think we should be weary adding that to <code>std</code></p>",
        "id": 219690289,
        "sender_full_name": "moxian",
        "timestamp": 1607749102
    },
    {
        "content": "<p>And now that I think about it, having two poison-less mutex types - one that release lock on panic, and one that doesn't - might satisfy both parties here.</p>",
        "id": 219690419,
        "sender_full_name": "moxian",
        "timestamp": 1607749308
    },
    {
        "content": "<p>I would love to have a poisonless lock whose behavior is to abort the process on panic if panic=unwind, or compile out all panic handling if panic=abort.</p>",
        "id": 219695451,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607757878
    },
    {
        "content": "<p>No error case either way. That would work for any program that doesn't try to handle lock poisoning except by propagating a panic.</p>",
        "id": 219695520,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607757980
    },
    {
        "content": "<p>Can you expand on a concrete use case where you want to unwind panics unless you happen to be holding some lock at the time? That seems like a somewhat artificial middle ground.</p>",
        "id": 219708676,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607779216
    },
    {
        "content": "<p>It would be similar to aborting for panics during unwinding, and IIRC it's been proposed that all panics during drop should abort too. This would be suggesting the same for panics during a critical section (holding a lock).</p>",
        "id": 219716025,
        "sender_full_name": "cuviper",
        "timestamp": 1607790733
    },
    {
        "content": "<p>Changing panics during drop to abort would be pretty clearly a breaking change.</p>",
        "id": 219717591,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607793137
    },
    {
        "content": "<p>I have the same comment as in <a href=\"https://internals.rust-lang.org/t/design-rationale-why-uncaught-panics-in-threads-dont-abort/12992/21\">https://internals.rust-lang.org/t/design-rationale-why-uncaught-panics-in-threads-dont-abort/12992/21</a>: this would completely and fundamentally break the design of <a href=\"http://docs.rs\">docs.rs</a></p>",
        "id": 219721804,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607799114
    },
    {
        "content": "<p>new APIs are fine but <em>please</em> do not silently change existing ones to crash the process</p>",
        "id": 219721856,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607799137
    },
    {
        "content": "<p><a href=\"https://news.ycombinator.com/item?id=22940836\">https://news.ycombinator.com/item?id=22940836</a></p>",
        "id": 219722031,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607799403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/219381-t-libs/topic/lock.20poisoning.20survey/near/219708676\">said</a>:</p>\n<blockquote>\n<p>Can you expand on a concrete use case where you want to unwind panics unless you happen to be holding some lock at the time? That seems like a somewhat artificial middle ground.</p>\n</blockquote>\n<p>The concrete use case is that otherwise, if I panic in a Mutex, I end up with a poisoned Mutex, and assuming I don't attempt to recover whatever inconsistent state the protected data is in, the only thing I'm likely to do is propagate the panic in the <em>next</em> thread that touches the Mutex, so I'd rather fail fast rather than slowly disintegrating over time.</p>",
        "id": 219746383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607839348
    },
    {
        "content": "<p>And failing fast also means the mutex doesn't have to track any kind of poisoned state.</p>",
        "id": 219746403,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607839404
    },
    {
        "content": "<p>(Also, for clarity, I'm aware that we can't change the existing <code>Mutex</code> without breaking backwards compatibility. I was suggesting the behavior I'd hope for from an alternative non-poisoning <code>Mutex</code>.)</p>",
        "id": 219746446,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607839443
    },
    {
        "content": "<p>maybe have the non-poisoning lock require wrapped types to implement <code>UnwindSafe</code>? (or whatever that trait is called, icr)</p>",
        "id": 219746613,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1607839807
    },
    {
        "content": "<p>I'm just still a bit confused as to why in this scenario you're sufficiently paranoid about getting into a bad state post panic with a mutex locked that you'd rather abort the whole process, but 1. are worried enough about panics in other contexts that you don't just want to build with panic=abort, and 2. are confident that you can't end up in a bad state when no lock is being held (e.g. the panic takes down a background thread that is necessary to keep the service stable)</p>",
        "id": 219761338,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607865714
    },
    {
        "content": "<p>I mean, I would <em>also</em> generally like uncaught thread panic to abort.</p>\n<p>But the issue isn't about paranoia. It's more that recovering from a panic is sufficiently unusual that I feel like it ought to have been opt-in, and I don't want the most commonly used mutexes to spend overhead on handling that case. It's one thing to use catch_unwind for something like \"restore the terminal state before exiting\". But I would be interested to know how many programs ever expect to <em>recover</em> from a poisoned mutex.</p>",
        "id": 219770911,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607880626
    },
    {
        "content": "<p>In the last ~7 years of writing things like webservers in Rust, I have literally never encountered a situation in which I was glad that a mutex was poisoned, or that I wished that I had used a poisoning mutex. There have been plenty of instances in which I wrote a bug that caused a panic, and some of those probably occurred while some lock was being held but in none of them would the service have been better off having aborted or been unable to ever access that data again.</p>",
        "id": 219771596,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607881714
    },
    {
        "content": "<p>There's nothing to do to \"recover\" - the odds are just very high that everything is actually totally fine in the server's internal state</p>",
        "id": 219771630,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607881783
    },
    {
        "content": "<p>I have long since abandoned poisoning entirely in favor of parking_lot and/or antidote, and my interaction with poisoning has generally been to file bugs on RLS when e.g. Racer panicked while some totally unrelated lock was being held up-stack resulting in the entire language server being in a state where it failed to respond to any future requests.</p>",
        "id": 219771703,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607881889
    },
    {
        "content": "<p>And the solution for RLS was to ignore poisoning, resulting in significant improvements to its stability</p>",
        "id": 219771781,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607882023
    },
    {
        "content": "<p>There is also a conflation that bugs=panics here - there are plenty of ways to screw up some code that don't result in a panic but do result in the corruption of some shared state via e.g. an accidental early return from <code>?</code>. A \"true\" poisoning lock IMO would require you to explicitly \"disarm\" the guard before it drops for any reason, panic or no.</p>",
        "id": 219772294,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607882740
    },
    {
        "content": "<p>In fact, in the one time I actually <em>have</em> intentionally used poisoning, the bad state I was looking to detect was a failed file write and so the API looked for that kind of explicit commit rather than panics</p>",
        "id": 219772530,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607883034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/219381-t-libs/topic/lock.20poisoning.20survey/near/219771596\">said</a>:</p>\n<blockquote>\n<p>In the last ~7 years of writing things like webservers in Rust, I have literally never encountered a situation in which I was glad that a mutex was poisoned, or that I wished that I had used a poisoning mutex. There have been plenty of instances in which I wrote a bug that caused a panic, and some of those probably occurred while some lock was being held but in none of them would the service have been better off having aborted or been unable to ever access that data again.</p>\n</blockquote>\n<p>I'm trying to reconcile your first and second sentences here.</p>",
        "id": 219816997,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607938200
    },
    {
        "content": "<p>The two seem to contradict each other somewhat, or I may be misunderstanding you here.</p>",
        "id": 219817076,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607938228
    },
    {
        "content": "<p>I'm saying that I have never been in a situation where the intended behavior of poisoning mutexes provided actual value. I.e. I have never thought \"wow, I sure am glad that random divide-by-zero bug escalated into a DoS on my shared state\"</p>",
        "id": 219834165,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607948961
    },
    {
        "content": "<p>So, I <em>do</em> believe the safety property is useful. I think either mutexes should poison, or they should abort on unwind, or they should be unsafe.</p>",
        "id": 219838621,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607951492
    },
    {
        "content": "<p>That is not how safety has been defined in Rust for at least 5 years</p>",
        "id": 219838937,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607951660
    },
    {
        "content": "<p>And the fact that into_inner is already a safe API on PoisonError means that isn't true today!</p>",
        "id": 219838967,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1607951686
    },
    {
        "content": "<p>Sigh. Let me try that again.</p>\n<p>I do believe the property is useful...</p>",
        "id": 219839232,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1607951840
    },
    {
        "content": "<p>/me  glances at <a href=\"https://github.com/rust-lang/docs.rs/issues/1149\">https://github.com/rust-lang/docs.rs/issues/1149</a></p>",
        "id": 219846140,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607955331
    },
    {
        "content": "<p>all of this is kind of incidental to <a href=\"http://docs.rs\">docs.rs</a> because we don't use mutexes (unless maybe our dependencies do? or <code>iron</code>?) but I definitely agree strongly with <span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span>, we <em>cannot</em> afford to abort the server because of a single bug</p>",
        "id": 219846277,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607955399
    },
    {
        "content": "<p>I'd be constantly on call, the site would constantly be down</p>",
        "id": 219846319,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1607955420
    },
    {
        "content": "<p>I may be a broken record at this point, but I'll mention again that also some shared state <em>cannot</em> enter an inconsistent state (eg: a single field), and thus poisoning is just an annoyance there.</p>",
        "id": 219873615,
        "sender_full_name": "Lokathor",
        "timestamp": 1607966686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/lock.20poisoning.20survey/near/219873615\">said</a>:</p>\n<blockquote>\n<p>I may be a broken record at this point, but I'll mention again that also some shared state <em>cannot</em> enter an inconsistent state (eg: a single field)</p>\n</blockquote>\n<p>That's not true. Consider the case of an AlwaysEvenInteger, which has a method where it's updated by two successive <code>*x = x.checked_add(1).unwrap()</code>. If one of them triggers overflow, It could be left in an \"inconsistent\" state because it didn't get to execute the 2nd addition.</p>\n<p>That said personally I've never wanted lock poisoning behavior, and largely agree with <span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span>'s comments ‚Äî IME the vast majority of the time stuff is fine, and the poisoning behavior is undesirable and leads to meaningfully less robust software.</p>\n<p>I'll also note that there's a nontrivial cost associated with implementing lock poisoning (admittedly it's been reduced somewhat recently), which often pushes people towards custom solutions regardless, which IMO isn't a great situation.</p>",
        "id": 219899475,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607978700
    },
    {
        "content": "<p>Arguing that there aren't <code>some</code> scenarios by using a counterexample seems disingenuous to me.</p>",
        "id": 219902313,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1607980139
    },
    {
        "content": "<p>Fair enough, I was more arguing that the single field scenario isn't universally a case like that.</p>",
        "id": 219903651,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1607980871
    },
    {
        "content": "<p>I've personally been leaning towards introducing a <code>Poison&lt;T&gt;</code> type, so that our current <code>std::sync::Mutex</code> would become semantically like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">std</span>::<span class=\"n\">sync</span>::<span class=\"n\">Mutex</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mutex</span>::<span class=\"n\">Mutex</span><span class=\"o\">&lt;</span><span class=\"n\">Poison</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I use poisoning a lot in my day-to-day codebase, but around files where it's not just panics, but most IO errors that cause us to poison files and operations. There aren't any locks to be seen there. Since locks also aren't the only way to share state across unwind boundaries it doesn't seem the most useful place for that behavior to live.</p>\n<p>I've also come around to <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span>'s suggestion to deprecate <code>UnwindSafe</code> and <code>RefUnwindSafe</code>, removing them from <code>panic::catch_unwind</code>. My own experience with these types is that they seem like they could be really useful traits, but the invariants they manage are too spongy for the current system to really protect, and the cases when you need them are uncommon enough that a lot of libraries ignore them. As an auto-trait system they don't seem to pull their weight.</p>",
        "id": 220076831,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1608093709
    },
    {
        "content": "<p>On the lang side we keep having conversations about never doing any more <code>auto trait</code>s, so +1 to deprecating those if they're not pulling their weight.</p>",
        "id": 220080698,
        "sender_full_name": "scottmcm",
        "timestamp": 1608098469
    },
    {
        "content": "<p>I would argue that they in fact anti-pull their weight: they use the word \"safe\" in a context where memory safety <strong>isn't</strong> involved, but the docs are vague and imply (to many readers) that it <em>might</em> be involved.</p>",
        "id": 220081758,
        "sender_full_name": "Lokathor",
        "timestamp": 1608099961
    },
    {
        "content": "<p>My 2ct's on this: I think the ability to detect and <strong>handle</strong> poisoning is very import for synchronization primitives which protect shared memory which is shared <strong>between different processes</strong>. If another process crashed, the shared state might be in inconsistent state, and something needs to clean it up. Crashing the local process is not the answer here, because the corrupted shared memory might still stay around. </p>\n<p>However for intra-process Mutexes I never found it useful to handle poisoned Mutexes. Most of the code I've written using Mutexes assumes that code executed while holding the lock never panics. If it does, something is very wrong, and the shared state might again not be in any well-defined and consistent state. Like with any kind of memory corruption or cache poisoning, continuing to run from there is dangerous. The current poisoning API allows to detect and fix the situation. However since it's not an expected state, I many people (including me) will skip handling it. And even if they do it might be barely tested and still have issues.<br>\nThat's why I'm not opposed to having a default behavior which panics again when trying to access such a log.</p>",
        "id": 220509279,
        "sender_full_name": "Matthias247",
        "timestamp": 1608452718
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> I agree entirely. I'd also love for the default behavior to have zero overhead if compiling with <code>panic=\"abort\"</code>, if possible.</p>",
        "id": 220540105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608502849
    },
    {
        "content": "<p>Some results from the survey: <a href=\"https://hackmd.io/2vuxXQL6Ruqaa6FZJKit_g\">https://hackmd.io/2vuxXQL6Ruqaa6FZJKit_g</a></p>",
        "id": 220542155,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1608506379
    },
    {
        "content": "<p>We got 786 total respondents <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> I'll write up a follow-up post exploring the results more thoroughly. That's just a dump of some of the total breakdowns. I think the interesting data will be in cross-sections of how different user needs translate to different poisoning strategies</p>",
        "id": 220542239,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1608506491
    },
    {
        "content": "<p>I'll check in with the core team (or community team?) about publishing the raw results too. We had a few free text inputs but I did put a warning about information leakage there so hopefully the results should be pretty sanitized already <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 220542297,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1608506577
    },
    {
        "content": "<p>It's looking like many users like the idea of getting rid of <code>.lock().unwrap()</code>. If they're not thinking about poisoning that might mean propagating panics automatically, and if they are that might mean suppressing them</p>",
        "id": 220542361,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1608506686
    },
    {
        "content": "<p>That's the part I found tricky about the survey. </p>\n<blockquote>\n<p>Do you think you‚Äôve benefited from the standard library‚Äôs lock types providing poisoning by default?</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p>Do you think you‚Äôve benefited from the standard library‚Äôs lock types providing poisoning by default?</p>\n</blockquote>\n<p>do not really make a distinction between</p>\n<ul>\n<li>a new Mutex which would still track poisoning, and always panic/abort on follow-up accesses</li>\n<li>a new Mutex which would ignore previous panics, and allow follow-up accesses</li>\n</ul>",
        "id": 220547877,
        "sender_full_name": "Matthias247",
        "timestamp": 1608516248
    },
    {
        "content": "<p>(Did you mean to copy two separate wordings there?)</p>",
        "id": 220553608,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1608526837
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> Yeh, in retrospect we probably could've made it easier to distinguish, but I'm interested to try slice it up by answers to what users want to happen when a lock is poisoned</p>",
        "id": 220553770,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1608527051
    },
    {
        "content": "<blockquote>\n<p>(Did you mean to copy two separate wordings there?)</p>\n</blockquote>\n<p>Oops - indeed! I also meant to copy </p>\n<blockquote>\n<p>How much friction do you think would be involved in migrating any of your projects from the standard library‚Äôs poisoning lock types to a non-poisoning lock crate?</p>\n</blockquote>\n<p>which will also vary a bit.</p>",
        "id": 220553904,
        "sender_full_name": "Matthias247",
        "timestamp": 1608527333
    },
    {
        "content": "<p>Trying not to hijack the conversation, but anyone knows of any writeup of:<br>\nA. Different poisoning techniques and handling of panicked threads.<br>\nB. What other languages do in that area.</p>",
        "id": 220569675,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1608545935
    },
    {
        "content": "<p>I've published the raw results from the Lock Poisoning Survey in our <code>libs-team</code> repository: <a href=\"https://github.com/rust-lang/libs-team/tree/main/data/2020-12-11-poisoning-survey\">https://github.com/rust-lang/libs-team/tree/main/data/2020-12-11-poisoning-survey</a></p>\n<p>I'm working on a follow-up post now exploring them, but if anybody else is keen to have a poke through them they're stored in CSV, along with a little tool that deserializes them to plain-old-structs if you wanted to grab them in a different format.</p>",
        "id": 223189155,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1611034784
    }
]