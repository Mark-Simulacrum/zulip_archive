[
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> <span class=\"user-mention\" data-user-id=\"362726\">@DrMeepster</span></p>",
        "id": 273947636,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646300856
    },
    {
        "content": "<p>Hi, I would like to discuss the ReadBuf API a bit as part of the path to stabilising RFC2930</p>",
        "id": 273947722,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646300890
    },
    {
        "content": "<p>First off, I'm not aware of any users, I've tweeted this a couple of times, but got nothing. There are some issues linking to the tracking issue but not any PRs, afaict</p>",
        "id": 273947868,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646300964
    },
    {
        "content": "<p>So if anyone knows of users I'd be very glad to get a real experience report</p>",
        "id": 273947907,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646300986
    },
    {
        "content": "<p>Anyway, I have two angles here: if we keep the current abstraction, then I think we can improve the API (as it is it seems fine, but a little big and confusing). I'd also like to float a slightly different abstraction (I know there was a lot of discussion pre-RFC, but I can't find it now. There didn't seem to be much discussion of this in the RFC itself, apologies if I'm retreading well-trodden ground)</p>",
        "id": 273948153,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646301115
    },
    {
        "content": "<p>The larger change: it strikes me that when using a byte slice, we don't keep track of filled vs unfilled, just the whole slice, returning the number of read bytes from read. Whereas with ReadBuf we track filled/unfilled/uninit. So I wonder instead if ReadBuf should just track init vs uninit internally and read should return the number of bytes read (and it must ensure that that number is all initialised, obvs). That would make ReadBuf much simpler (and using it closer to using a byte slice) at the expense of requiring some external state. Thoughts?</p>",
        "id": 273948539,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646301297
    },
    {
        "content": "<p>If we keep the three-way split, I propose the following changes:</p>\n<h2>Construction</h2>\n<ul>\n<li>remove <code>new</code> (it should create an empty <code>ReadBuf</code>, but that is useless, I think)</li>\n<li>Should implement <code>From&lt;&amp;'a [u8]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>new</code>)</li>\n<li>Should implement <code>From&lt;&amp;'a [MaybeUninit&lt;u8&gt;]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>uninit</code>)</li>\n</ul>\n<h2>Length functions</h2>\n<ul>\n<li>Keep <code>capacity</code></li>\n<li><code>filled_len</code> -&gt; <code>len</code> to match <code>Vec</code> etc. (in fact, we don't even need it with the <code>Deref</code> impl, see below)</li>\n<li>remove <code>remaining</code> (can use <code>capacity() - len()</code> or <code>unfilled().len()</code>)</li>\n<li>remove <code>initialized_len</code> (can use <code>initialized().len()</code>)</li>\n</ul>\n<h2>Slicing functions</h2>\n<ul>\n<li>Keep <code>initialized</code>, <code>unfilled</code>, <code>uninitialized</code>, and mut variants</li>\n<li>Remove <code>filled</code> and <code>filled_mut</code>, replace by implementing <code>Deref&lt;Target = [u8]&gt;</code> and <code>DerefMut</code></li>\n</ul>\n<h2>Initializing data</h2>\n<ul>\n<li>Remove <code>initialize_unfilled</code> and <code>initialize_unfilled_to</code>, unless these are super useful<ul>\n<li>rationale, getting unfilled slice is easy, initialising is easy, so it seems the only benefit is tracking this</li>\n</ul>\n</li>\n<li>keep <code>assume_init</code></li>\n</ul>\n<h2>Misc</h2>\n<ul>\n<li>Keep <code>clear</code> and <code>append</code></li>\n<li>Remove <code>add_filled</code></li>\n<li>Rename <code>set_filled</code> to <code>assume_filled</code> (to match <code>assume_init</code>)</li>\n</ul>",
        "id": 273950303,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646302128
    },
    {
        "content": "<p>For reference, current API is <a href=\"https://doc.rust-lang.org/nightly/std/io/struct.ReadBuf.html\">https://doc.rust-lang.org/nightly/std/io/struct.ReadBuf.html</a></p>",
        "id": 273950584,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646302257
    },
    {
        "content": "<p>The second half of this section of the RFC talks about returning the read count separately: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives\">https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives</a>. IMO it puts too much of the burden on consumers to remember all of the subtle checks required when working with <code>impl Read</code> + unsafe</p>",
        "id": 273964188,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1646310222
    },
    {
        "content": "<p>You could look at tokio stuff for usage - they have a copy of ReadBuf in their API: <a href=\"https://docs.rs/tokio/1.17.0/tokio/io/trait.AsyncRead.html\">https://docs.rs/tokio/1.17.0/tokio/io/trait.AsyncRead.html</a></p>",
        "id": 273964280,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1646310259
    },
    {
        "content": "<p>This is the most pressing issue blocking stabilization IMO: <a href=\"https://github.com/rust-lang/rfcs/pull/2930#issuecomment-688933597\">https://github.com/rust-lang/rfcs/pull/2930#issuecomment-688933597</a></p>",
        "id": 273965148,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1646310719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/273964188\">said</a>:</p>\n<blockquote>\n<p>The second half of this section of the RFC talks about returning the read count separately: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives\">https://github.com/rust-lang/rfcs/blob/master/text/2930-read-buf.md#rationale-and-alternatives</a>. IMO it puts too much of the burden on consumers to remember all of the subtle checks required when working with <code>impl Read</code> + unsafe</p>\n</blockquote>\n<p>I read that in the context of having the read count returned and having the filled len in ReadBuf, in which case I agree totally with the conclusion. But as an alternative where ReadBuf is simpler, I think it is more attractive - IMO, the difficult checks here are around the difference between init  but unfilled and uninit, which ReadBuf would still maintain. The number of bytes read (i.e., the filled len) is pretty simple, after all it corresponds exactly to reading using a byte buffer</p>",
        "id": 273966985,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646311756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/273950303\">said</a>:</p>\n<blockquote>\n<ul>\n<li>Should implement <code>From&lt;&amp;'a [u8]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>new</code>)</li>\n<li>Should implement <code>From&lt;&amp;'a [MaybeUninit&lt;u8&gt;]&gt; for ReadBuf&lt;'a&gt;</code> to create a ReadBuf from a byte slice (rather than <code>uninit</code>)</li>\n</ul>\n</blockquote>\n<p>Those should probably be <code>&amp;'a mut [u8]</code> and <code>&amp;'a mut [MaybeUninit&lt;u8&gt;]</code></p>",
        "id": 273978552,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1646317003
    },
    {
        "content": "<p>yes, indeed!</p>",
        "id": 273979116,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646317252
    },
    {
        "content": "<p>I think \"corresponds exactly to reading using a byte buffer\" is not a feature in cases where using a byte buffer is easy to get wrong.</p>",
        "id": 274028776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646336903
    },
    {
        "content": "<p>Remembering to slice the byte buffer by the returned value is something the compiler gives no help with.</p>",
        "id": 274028872,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646336942
    },
    {
        "content": "<p>It feels very much like c programming.</p>",
        "id": 274028905,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646336955
    },
    {
        "content": "<p>If tracking the number of bytes read in ReadBuf means I can just ask the ReadBuf for the slice of bytes I just got, without having to <code>[..bytes_read]</code>, that seems like a great <em>improvement</em> over byte buffers.</p>",
        "id": 274029147,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646337049
    },
    {
        "content": "<p>That makes a lot of sense, thanks!</p>",
        "id": 274097885,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384007
    },
    {
        "content": "<p>So, lets scratch that idea completely and just look at the smaller changes I suggested (which I acknowledge is still quite a significant overhaul).</p>",
        "id": 274097982,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384064
    },
    {
        "content": "<p>The bits I'm most unsure about are using deref to get to the filled buffer. This seems like a little bit of an abuse of deref and a bit magic, however, I do think it will make code read nicely. Alternatives are to stick to using a <code>filled</code> method or to impl <code>Into&lt;&amp;mut [u8]&gt;</code> to get the filled buffer.</p>",
        "id": 274098157,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384178
    },
    {
        "content": "<p>The other bit I'm unsure about is removing the initialize_unfilled methods, I see that these are useful when you want to get all the unfilled space for a task which expects a byte slice rather than a ReadBuf, but it also seems pretty easy to do yourself and not super common to do.</p>",
        "id": 274098545,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384399
    },
    {
        "content": "<p>An alternative, would be to rename to just <code>initialize</code>, I think adding the <code>unfilled</code> suffix does not really help understanding - I think the point is to make clear that the already initialized part of the buffer will not be reset, but as a casual reader, I would still need to look that up in the docs, so I don't think it adds a huge amount.</p>",
        "id": 274098934,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384513
    },
    {
        "content": "<p>I would also not return a slice, but return void (but see next thought) because I can imagine times when you would want a slice of the whole buffer, not just the unfilled part, and it seems that the current API is not very atomic.</p>",
        "id": 274099089,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384594
    },
    {
        "content": "<p>Next thought: I wonder if the various state-changing methods (assume_init, initialize_unfilled, etc.) should return <code>&amp;mut Self</code> rather than void to permit a more fluent, builder-style use of the API?</p>",
        "id": 274099356,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646384743
    },
    {
        "content": "<p>Meta: should I copy these thoughts to the tracking issue or create a draft PR or something? I hoped to get some initial discussion going here, but I'm not clear what the usual/best way is to have this kind of discussion</p>",
        "id": 274100639,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646385431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274099356\">said</a>:</p>\n<blockquote>\n<p>Next thought: I wonder if the various state-changing methods (assume_init, initialize_unfilled, etc.) should return <code>&amp;mut Self</code> rather than void to permit a more fluent, builder-style use of the API?</p>\n</blockquote>\n<p>Would you expect typical usage to need to call several of those one after another?</p>",
        "id": 274103780,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646386916
    },
    {
        "content": "<p>I would expect it is common usage to want to use a buffer after calling assume_init. Something like, let slice = bytes.assume_init(n).inititialized();</p>",
        "id": 274104814,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646387484
    },
    {
        "content": "<p>Fair. I think a PR to make those chainable, along with a doc example showing that usage, would suffice.</p>",
        "id": 274106181,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388039
    },
    {
        "content": "<p>Do you have thoughts on the other suggested changes?</p>",
        "id": 274106225,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646388063
    },
    {
        "content": "<p>Still processing them.</p>",
        "id": 274106490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388215
    },
    {
        "content": "<p>As an aside, I suspect in practice I'm <em>often</em> going to wish <code>ReadBuf</code> had the option of owning its data, and failing that, I'm going to wish for self-referential structures.</p>",
        "id": 274106660,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388303
    },
    {
        "content": "<p>I have use cases today in which I store a <code>Vec&lt;u8&gt;</code> or a <code>[u8; 4096]</code> in a data structure as a buffer in progress. I'd like to be able to replace those with <code>ReadBuf</code> and avoid the unnecessary initialization. But I can't do that with <code>ReadBuf</code>.</p>",
        "id": 274106752,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388361
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274098157\">said</a>:</p>\n<blockquote>\n<p>The bits I'm most unsure about are using deref to get to the filled buffer. This seems like a little bit of an abuse of deref and a bit magic, however, I do think it will make code read nicely. Alternatives are to stick to using a <code>filled</code> method or to impl <code>Into&lt;&amp;mut [u8]&gt;</code> to get the filled buffer.</p>\n</blockquote>\n<p>I agree that using <code>Deref</code> seems a little questionable, since there are actually two possible buffers you might want, <code>filled</code> or <code>initialized</code>. The caller wants <code>filled</code>, while the callee might want <code>initialized</code>.</p>",
        "id": 274107772,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388898
    },
    {
        "content": "<p>In practice making things more ergonomic for the caller seems like the right tradeoff (many many more callers of read_buf than implementers of read_buf), but I do find Deref eyebrow-raising at least.</p>",
        "id": 274107839,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388939
    },
    {
        "content": "<p>It's worth further consideration, at the least.</p>",
        "id": 274107859,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646388952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274098934\">said</a>:</p>\n<blockquote>\n<p>An alternative, would be to rename to just <code>initialize</code>, I think adding the <code>unfilled</code> suffix does not really help understanding - I think the point is to make clear that the already initialized part of the buffer will not be reset, but as a casual reader, I would still need to look that up in the docs, so I don't think it adds a huge amount.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274099089\">said</a>:</p>\n<blockquote>\n<p>I would also not return a slice, but return void (but see next thought) because I can imagine times when you would want a slice of the whole buffer, not just the unfilled part, and it seems that the current API is not very atomic.</p>\n</blockquote>\n<p>I think these two thoughts are tied together. If the methods return a slice, I think they need to have <code>unfilled</code> in the name, because the important detail is that the slice they return is of the unfilled portion. Along the same lines, <code>initialize_unfilled_to</code> counts <code>n</code> bytes of unfilled data, not <code>n</code> bytes from the beginning.</p>",
        "id": 274108288,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389182
    },
    {
        "content": "<p>I do think that in general we don't need to make it <em>that</em> ergonomic to use <code>ReadBuf</code> as a thing you initialize and then write to; that kinda defeats the purpose.</p>",
        "id": 274108377,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389228
    },
    {
        "content": "<p>I think if those methods don't return a slice then they don't have reason to exist.</p>",
        "id": 274108412,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646389260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274106752\">said</a>:</p>\n<blockquote>\n<p>I have use cases today in which I store a <code>Vec&lt;u8&gt;</code> or a <code>[u8; 4096]</code> in a data structure as a buffer in progress. I'd like to be able to replace those with <code>ReadBuf</code> and avoid the unnecessary initialization. But I can't do that with <code>ReadBuf</code>.</p>\n</blockquote>\n<p>I've been thinking we'd want a <code>Vec::read_buf()</code> method that creates a <code>VecReadBuf</code> which can do the <code>Vec::set_len()</code> on <code>Drop</code>. The <code>VecReadBuf</code> would expose the inner <code>ReadBuf</code> somehow (maybe through <code>DerefMut</code>?).</p>",
        "id": 274193932,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1646431049
    },
    {
        "content": "<p>My experience from using the ReadBuf API in Tokio is that you really have to fix the footgun if you want to stabilize this. You will see _lots_ of unsound code if you don't.</p>",
        "id": 274567912,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1646757798
    },
    {
        "content": "<p>I filed issue <a href=\"https://github.com/rust-lang/rust/issues/94741\">https://github.com/rust-lang/rust/issues/94741</a> to continue discussion. (I'm in the process of making one about the footgun, see also <a href=\"#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/Read.3A.3Abuf_read.20signature</a>)</p>",
        "id": 274568955,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646758223
    },
    {
        "content": "<p>Reading some of this makes we wish we had a storage API in the language. ReadBuf seems a lot like <a href=\"https://docs.rs/cl-generic-vec/0.3.4/cl_generic_vec/type.SliceVec.html\">https://docs.rs/cl-generic-vec/0.3.4/cl_generic_vec/type.SliceVec.html</a>, and the owned variety that <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> requested is just a normal or stack vec</p>",
        "id": 274582018,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1646763406
    },
    {
        "content": "<p>I'm <a href=\"https://github.com/rust-lang/rust/pull/94421\">already experimenting</a> with moving the vec impl to be inline with the HeapVec type you see in that crate, which should make any potential adoption of that design to be more streamlined</p>",
        "id": 274583358,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1646763963
    },
    {
        "content": "<p>Here's a quick PoC crate combining lots of the proposed ideas <a href=\"https://docs.rs/cl-generic-read-buf/0.1.0/cl_generic_read_buf/\">https://docs.rs/cl-generic-read-buf/0.1.0/cl_generic_read_buf/</a></p>",
        "id": 274661036,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1646817698
    },
    {
        "content": "<p>That makes <code>Read</code> not object safe, right? I think that should be avoided.</p>",
        "id": 274697551,
        "sender_full_name": "Kestrer",
        "timestamp": 1646837264
    },
    {
        "content": "<p>Just musing about this, one mildy cursed option would be to make <code>ReadBuf</code> an \"ultra-wide\" pointer:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ReadBuf</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">filled</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">initialized</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">ReadBuf</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">filled</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">initialized</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\">  </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">reborrow</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ReadBuf</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This approach would make replacing the <code>ReadBuf</code> impossible, as well as offering an extremely generic API. <code>Vec</code> can provide a function like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">as_read_buf</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">filled</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ReadBuf</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The only disadvantage is forcing every <code>read</code> call to accept a whole _four_ pointers, which isn't an insignificant nunber of bytes.</p>",
        "id": 274699073,
        "sender_full_name": "Kestrer",
        "timestamp": 1646837874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360486\">Kestrer</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274697551\">said</a>:</p>\n<blockquote>\n<p>That makes <code>Read</code> not object safe, right? I think that should be avoided.</p>\n</blockquote>\n<p>That is correct, good point. I think I can figure a way around that though</p>",
        "id": 274705814,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1646840611
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360486\">Kestrer</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/274699073\">said</a>:</p>\n<blockquote>\n<p>Just musing about this, one mildy cursed option would be to make <code>ReadBuf</code> an \"ultra-wide\" pointer:</p>\n</blockquote>\n<p>that is incredibly cursed but also brilliant and I love it</p>",
        "id": 274794898,
        "sender_full_name": "DrMeepster",
        "timestamp": 1646893096
    },
    {
        "content": "<p>I have been pondering the ReadBuf API again, and I have a suggestion. But first I want to recap what I see as the problems:</p>",
        "id": 278296448,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649420979
    },
    {
        "content": "<ol>\n<li>The unsoundness footgun</li>\n</ol>",
        "id": 278296471,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649420991
    },
    {
        "content": "<ol start=\"2\">\n<li>It's a confusing API: there are three slices in play but they are named in terms of two sets of two views and the middle slice (unfilled and initialised) does not have a name. In addition the methods are not uniform in terms of which slice is used as the base, e.g., (without looking at the docs) is n in  assume_init(n) relative to the start of the buffer of the start of the unfilled part of the buffer?</li>\n</ol>",
        "id": 278296876,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421142
    },
    {
        "content": "<ol start=\"3\">\n<li>Readers can mutate the filled part of the buffer. This has some use cases (compression), but means there is no way to get the number of bytes read from buffer and leads to some surprising edge cases like the size of the filled part being smaller after a read than before, or larger but not by the number of bytes read</li>\n</ol>",
        "id": 278296992,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421226
    },
    {
        "content": "<p>I propose a solution which addresses all of these issues, but which requires an extra data structure (though note that all the viable proposals to solving the footgun issue (which is considered a blocker) also introduce another data structure, albeit usually a simple one).</p>",
        "id": 278297159,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421307
    },
    {
        "content": "<p>Basically we split ReadBuf into two, I call these ReadBuf and ReadCursor (strawman naming, I'm sure these can be improved). ReadBuf makes the distinction between filled and unfilled parts of the buffer and is created like today from initialised or uninitialised bytes. Getting the filled part gets bytes, getting the unfilled parts gets a ReadCursor by value: ReadBuf&lt;'a&gt;::unfilled(&amp;'b mut self) -&gt; ReadCursor&lt;'a, 'b&gt;</p>",
        "id": 278297431,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421444
    },
    {
        "content": "<p>Read::read_buf takes a ReadCursor by value, so it can not be accessed by the caller after the read call. ReadCursor provides access to the init and unint (but not the filled) part of the buffer. As the cursor is filled, it no longer has access to the filled data. Modifying the cursor (either filling or initialising) updates the buffer. After the read, the caller can update its backing data based on the lengths from the ReadBuf, and there is no way this could be switched out (i.e., the footgun is gone). The number of bytes read is guaranteed to be the difference between the length of the filled part before and after the read and the filled part can only grow during the read. Since each data structure only presents two slices, there is no ambiguity about the base index for each method.</p>",
        "id": 278297868,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421677
    },
    {
        "content": "<p>Of course we lose the ability for readers to compress their read data along with existing data, but IMO that is a good thing!</p>",
        "id": 278298014,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421734
    },
    {
        "content": "<p>(It's actually not quite as simple as this, the user has to be able to get and set the length of the initialised data on the ReadBuf so that they can setup the buffer and update their backing buffer from it, so there is some distinction between init and uninit in the ReadBuf API, but there is no direct access to the bytes)</p>",
        "id": 278298364,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421897
    },
    {
        "content": "<p>Draft code: <a href=\"https://gist.github.com/nrc/0b2db7a0bcb6fd9317e8218f31fd5719\">https://gist.github.com/nrc/0b2db7a0bcb6fd9317e8218f31fd5719</a> (this is very unpolished and mostly just a copy and paste job from the existing API, I think we could improve the API a lot)</p>",
        "id": 278298560,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649421995
    },
    {
        "content": "<p>Two questions: can we remove the 'b lifetime from ReadCursor? It is annoying. I don't think it can be merged with 'a, I wonder if we could make ReadCursor unsized and refer to it as &amp;mut ReadCursor&lt;'a&gt;, but then its not moved to Read::read_buf, so we have the footgun back :-(</p>",
        "id": 278298704,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649422087
    },
    {
        "content": "<p>And would it be worth duplicating the length in ReadCursor so they are only updated 'locally' as the cursor is written to, then have an explicit <code>flush</code> method? I don't think this would work because the data and metadata would get out of sync and we'd need to rely on drop to keep things in sync, which is unsound.</p>",
        "id": 278298918,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649422220
    },
    {
        "content": "<p>Anyway, thoughts?</p>",
        "id": 278298936,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649422230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>",
        "id": 278376522,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649463211
    },
    {
        "content": "<p>Take a ReadBuf, fill the first kilobyte, then get a new cursor, it points to the next kilobyte, you pass it to a read_buf call, it can write and re-write that second kilobyte, but can't touch the first kilobyte.</p>",
        "id": 278376574,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649463248
    },
    {
        "content": "<p>(Also, unrelated, I'm starting to wonder if we should just call this <code>Buf</code> rather than <code>ReadBuf</code>; I wonder if we'll end up adding APIs to it that make it generally useful as both an input and output buffer.)</p>",
        "id": 278376675,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649463377
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278298704\">said</a>:</p>\n<blockquote>\n<p>Two questions: can we remove the 'b lifetime from ReadCursor? It is annoying. I don't think it can be merged with 'a, I wonder if we could make ReadCursor unsized and refer to it as &amp;mut ReadCursor&lt;'a&gt;, but then its not moved to Read::read_buf, so we have the footgun back :-(</p>\n</blockquote>\n<p>I don't think that'd be a footgun, because the read_buf call couldn't use a <code>&amp;mut ReadCursor</code> to modify the ReadBuf in unexpected ways (such as replacing it completely).</p>",
        "id": 278376794,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649463561
    },
    {
        "content": "<p>Unless you think people will reuse the ReadCursor rather than getting a fresh one for each read_buf call?</p>",
        "id": 278376857,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649463610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376522\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>\n</blockquote>\n<p>So, this is possible, just not explicitly supported by the API. I.e, the reader takes a view of the unfilled data as a slice and can then write to the slice <br>\nhowever it likes, it can read back, re-write, whatever. Its only when the reader commits its writes by using <code>advance</code> that the data is 'moved' from the unfilled to the filled segment and the reader loses access. So when I say it doesn't have access to any filled data, I strictly mean any data which is filled from the perspective of the buffer, not from the perspective of the reader writing into it.</p>",
        "id": 278526503,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649668339
    },
    {
        "content": "<p>I think that should be  OK for most use cases. Giving access to filled and committed data would mean tracking another length (and kind of segment from the user's perspective) which would make the API even more complicated</p>",
        "id": 278526573,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649668388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376675\">said</a>:</p>\n<blockquote>\n<p>(Also, unrelated, I'm starting to wonder if we should just call this <code>Buf</code> rather than <code>ReadBuf</code>; I wonder if we'll end up adding APIs to it that make it generally useful as both an input and output buffer.)</p>\n</blockquote>\n<p>Yeah, I have been thinking the same thing, but maybe BorrowedBuf or SliceBuf, since I think we might also want an OwnedBuf for io_uring style interfaces</p>",
        "id": 278526667,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649668442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278526503\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376522\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>\n</blockquote>\n<p>So, this is possible, just not explicitly supported by the API. I.e, the reader takes a view of the unfilled data as a slice and can then write to the slice <br>\nhowever it likes, it can read back, re-write, whatever. Its only when the reader commits its writes by using <code>advance</code> that the data is 'moved' from the unfilled to the filled segment and the reader loses access. So when I say it doesn't have access to any filled data, I strictly mean any data which is filled from the perspective of the buffer, not from the perspective of the reader writing into it.</p>\n</blockquote>\n<p>That means you have to keep working with a slice of MaybeUninit though, even once you know which parts you've filled.</p>",
        "id": 278526754,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649668498
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376857\">said</a>:</p>\n<blockquote>\n<p>Unless you think people will reuse the ReadCursor rather than getting a fresh one for each read_buf call?</p>\n</blockquote>\n<p>I don't think they would reuse the cursor, though they could (would that count as a footgun? It seems technically as possible as the current situation, although the incentives change a bit), but they might get the uninit length from the cursor rather than the buffer which would be unsound (well unsound if they don't check the address, i.e., the same footgun) and I think that would be just as feasible as currently?</p>",
        "id": 278526999,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649668605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278526754\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278526503\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/ReadBuf.20API/near/278376522\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> I'm not seeing an obvious reason why the ReadCursor couldn't give access to the data already filled via <em>that</em> ReadCursor, while preventing access to data filled via a <em>prior</em> ReadCursor.</p>\n</blockquote>\n<p>So, this is possible, just not explicitly supported by the API. I.e, the reader takes a view of the unfilled data as a slice and can then write to the slice <br>\nhowever it likes, it can read back, re-write, whatever. Its only when the reader commits its writes by using <code>advance</code> that the data is 'moved' from the unfilled to the filled segment and the reader loses access. So when I say it doesn't have access to any filled data, I strictly mean any data which is filled from the perspective of the buffer, not from the perspective of the reader writing into it.</p>\n</blockquote>\n<p>That means you have to keep working with a slice of MaybeUninit though, even once you know which parts you've filled.</p>\n</blockquote>\n<p>They could call <code>slice_assume_init_ref</code> or use <code>initialize_to</code> to get an initialized slice.</p>",
        "id": 278527078,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649668672
    },
    {
        "content": "<p>That'd lose the efficiency of using <code>read_buf</code>.</p>",
        "id": 278527144,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649668701
    },
    {
        "content": "<p>Oh, wait, <code>assume_init</code>, yes, that would work.</p>",
        "id": 278527168,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649668722
    }
]