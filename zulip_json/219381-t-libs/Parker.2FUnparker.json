[
    {
        "content": "<p>Heya, I was wondering if we have an equivalent of <a href=\"https://docs.rs/crossbeam/latest/crossbeam/sync/struct.Parker.html\"><code>crossbeam::Parker</code></a> internally in the stdlib. I know about the windows Parker type, but I'm not entirely sure if it's the same thing.</p>\n<p>Related to that: if we don't, is there a good place to add it internally? Or would this even be something we should consider adding as a public API? (I've wanted this a few times, though I'd like be keen to hear libs team member's perspective on this first.)</p>\n<p>cc/ <span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> probably?</p>",
        "id": 272409784,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1645195471
    },
    {
        "content": "<p>std::thread::park/unpark is almost this, just per-thread rather than on an ad-hoc struct</p>",
        "id": 272410592,
        "sender_full_name": "simulacrum",
        "timestamp": 1645195898
    },
    {
        "content": "<p>Yeah that's right. Though in this instance we definitely want to enable waking up the thread we created <code>Parker</code> on from (potentially) any other thread, which I don't believe we can do without a <code>Parker</code>-like abstraction.</p>",
        "id": 272414302,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1645197630
    },
    {
        "content": "<p>C++20 has a futex-like API on atomic types: <a href=\"https://en.cppreference.com/w/cpp/atomic/atomic/wait\">https://en.cppreference.com/w/cpp/atomic/atomic/wait</a></p>",
        "id": 272414347,
        "sender_full_name": "Amanieu",
        "timestamp": 1645197651
    },
    {
        "content": "<p>Basically you can <code>wait</code> on an atomic or wake up a thread that is waiting on an atomic.</p>",
        "id": 272414438,
        "sender_full_name": "Amanieu",
        "timestamp": 1645197692
    },
    {
        "content": "<p>oh that sounds neat!?</p>",
        "id": 272415088,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1645198008
    },
    {
        "content": "<p>Fwiw here's roughly how I plan to use <code>Parker</code>: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=f111c32329892c9b7e8f281b9c3c16a0\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=f111c32329892c9b7e8f281b9c3c16a0</a></p>",
        "id": 272415140,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1645198037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/219381-t-libs/topic/Parker.2FUnparker/near/272414438\">said</a>:</p>\n<blockquote>\n<p>Basically you can <code>wait</code> on an atomic or wake up a thread that is waiting on an atomic.</p>\n</blockquote>\n<p>That almost feels like the better API, right? -- though I believe the counterpart to C++'s <code>std::atomic&lt;T&gt;</code> would be something like <code>crossbeam::atomic::AtomicCell</code>? -- would it make sense to add it to the individual atomic types if we don't also have an <code>AtomicCell</code> type?</p>",
        "id": 272417055,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1645198981
    },
    {
        "content": "<p>I don't  know who  thought <code>std::atomic::wait</code> was a good idea, since it's required in freestanding.<br>\nI think it would be fairly difficult to implement something like it without OS support.</p>",
        "id": 272422183,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645201271
    },
    {
        "content": "<p>i had the start of an RFC for it at one point. I still think it's worth having, but I think it would be better to focus on after the other near-term std::sync changes.</p>",
        "id": 272424662,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645202542
    },
    {
        "content": "<p>Yea that's the issue with the <code>wait</code> API, we can't have it in <code>core</code> because it requires OS support. Maybe an extension trait in <code>std</code>? But then it could just as well be an extension trait in an external crate.</p>",
        "id": 272424913,
        "sender_full_name": "Amanieu",
        "timestamp": 1645202659
    },
    {
        "content": "<p>For the actual implementation it's basically the same as <code>parking_lot</code>: wait queues in a hash table keyed on an address.</p>",
        "id": 272425002,
        "sender_full_name": "Amanieu",
        "timestamp": 1645202707
    },
    {
        "content": "<p>i definitely think it would live in std on an extension trait. i was even considering just making it be <code>fn wait(&amp;AtomicU32, u32)</code> and <code>fn wake(&amp;AtomicU32)</code>. but in practice it probably needs to support other atomic types. (the downside being that this means the parking_lot approach must be taken, even on platforms with a native futex API, unless that native API supports many sizes of futex word, like windows does)</p>",
        "id": 272426768,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645203472
    }
]