[
    {
        "content": "<p>I've <a href=\"https://users.rust-lang.org/t/u16-slice-to-u8-iterator/59078/11?u=scottmcm\">twice</a> <a href=\"https://github.com/bevyengine/bevy/pull/1966#discussion_r616169211\">recently</a> seen people misusing <code>align_to</code> since it's the \"easiest\" way to turn slices into slices of different-sized elements.</p>\n<p>I'd love to be able to suggest <a href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.as_chunks\"><code>as_chunks</code></a> instead, but it's unstable.  I'd normally just send a stabilization PR and ask for an FCP, but the <a href=\"https://github.com/rust-lang/rust/issues/74985#issue-670131723\">tracking issue</a> says that it's currently blocked on a compile-time check for N==0, since it can't elegantly meet its postcondition in that case.</p>\n<p>It seems like that's a long way off from being fixable, though.  Any thoughts on how essential that is, vs just doing the runtime <code>panic</code> it does today?  I'd certainly <em>rather</em> it not compile, but it's not like it's a subtle problem that is likely to slip past notice without the compiler error, nor is it something that causes perf problems.  So I'm tempted to say I'd rather have it stable with the panic than wait for <code>where N &gt; 0</code> to be allowed...</p>",
        "id": 236721016,
        "sender_full_name": "scottmcm",
        "timestamp": 1619720328
    },
    {
        "content": "<blockquote>\n<p>It seems like that's a long way off from being fixable, though.</p>\n</blockquote>\n<p>I personally think that using a compile time check is worth it here and in general would prefer to not stabilize this with a runtime check if we're going to  later add methods with compile time checks</p>",
        "id": 236722386,
        "sender_full_name": "lcnr",
        "timestamp": 1619720914
    },
    {
        "content": "<p>now, while we're a long time off from const wf bounds</p>",
        "id": 236722430,
        "sender_full_name": "lcnr",
        "timestamp": 1619720938
    },
    {
        "content": "<p>we are exactly 0 days off from being able to implement this as a fairly innocent hack</p>",
        "id": 236722459,
        "sender_full_name": "lcnr",
        "timestamp": 1619720956
    },
    {
        "content": "<p>add an attribute <code>#[rustc_non_zero_const_param(integer)]</code> which</p>",
        "id": 236723098,
        "sender_full_name": "lcnr",
        "timestamp": 1619721211
    },
    {
        "content": "<ul>\n<li>requires const arguments instantiating the parameter to be fully concrete</li>\n</ul>",
        "id": 236723131,
        "sender_full_name": "lcnr",
        "timestamp": 1619721225
    },
    {
        "content": "<ul>\n<li>and causes an error if the argument is equal to 0</li>\n</ul>",
        "id": 236723155,
        "sender_full_name": "lcnr",
        "timestamp": 1619721237
    },
    {
        "content": "<p>this would prevent users from using <code>as_chunks</code> with a generic <code>N</code> until we've either decided that this doesn't has to be a compile time bound or const wf bounds are close enough to stable</p>",
        "id": 236723433,
        "sender_full_name": "lcnr",
        "timestamp": 1619721325
    },
    {
        "content": "<p>which imo is a good way to postpone this decision while still getting most of the benefits of having this method on stable</p>",
        "id": 236723480,
        "sender_full_name": "lcnr",
        "timestamp": 1619721351
    },
    {
        "content": "<p>if this is desirable i can either implement this in the <em>fairly near</em>(a few weeks) future or mentor immediately if someone is interested in working on this</p>",
        "id": 236724241,
        "sender_full_name": "lcnr",
        "timestamp": 1619721650
    },
    {
        "content": "<p>Another option is to make this a deny-by-default lint, which is less hacky but doesn't prevent generic parameters</p>",
        "id": 236728783,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1619723493
    },
    {
        "content": "<p>(And of course, means that make it a hard error isn't backwards compatible, which might be unsatisfactory)</p>",
        "id": 236728864,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1619723523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/219381-t-libs/topic/How.20essential.20is.20the.20compile-time.20check.20for.20empty.20arrays.3F/near/236728864\">said</a>:</p>\n<blockquote>\n<p>(And of course, means that make it a hard error isn't backwards compatible, which might be unsatisfactory)</p>\n</blockquote>\n<p>yeah, while i except us to not necessarily end up with erroring here in the end, i do want to keep that option</p>",
        "id": 236732868,
        "sender_full_name": "lcnr",
        "timestamp": 1619725187
    },
    {
        "content": "<p>I'd be willing to make an attempt at this.  It's been a while since I added an attribute, though, so some pointers to where I should put these things and how I should check it would be appreciated.</p>",
        "id": 236746179,
        "sender_full_name": "scottmcm",
        "timestamp": 1619730442
    },
    {
        "content": "<p>you could look at my recent <code>rustc_skip_array_during_method_dispatch</code>: <a href=\"https://github.com/rust-lang/rust/pull/84147/commits/b79af2fcde91abeae805c2dbccfdbf7114bfd47b\">https://github.com/rust-lang/rust/pull/84147/commits/b79af2fcde91abeae805c2dbccfdbf7114bfd47b</a></p>",
        "id": 236751861,
        "sender_full_name": "cuviper",
        "timestamp": 1619732359
    },
    {
        "content": "<p>most of that boiler-plate is for the stored metadata though, not the attribute itself</p>",
        "id": 236751895,
        "sender_full_name": "cuviper",
        "timestamp": 1619732376
    },
    {
        "content": "<p>You could also use the <code>static_assert!</code> hack that stdarch is using. The error message is pretty bad though.</p>",
        "id": 236761012,
        "sender_full_name": "Amanieu",
        "timestamp": 1619737634
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/stdarch/blob/6cec76beed3d1d27c1b88826a0e5d8142f836d66/crates/core_arch/src/macros.rs#L69\">https://github.com/rust-lang/stdarch/blob/6cec76beed3d1d27c1b88826a0e5d8142f836d66/crates/core_arch/src/macros.rs#L69</a></p>",
        "id": 236761065,
        "sender_full_name": "Amanieu",
        "timestamp": 1619737669
    },
    {
        "content": "<p>that one also doesn't apply for <code>cargo check</code> though <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> as the errors happen during mono item collection</p>",
        "id": 236814312,
        "sender_full_name": "lcnr",
        "timestamp": 1619778461
    },
    {
        "content": "<p>it might have been sensible to use the same hack for stdarch <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> might not be possible though</p>",
        "id": 236814440,
        "sender_full_name": "lcnr",
        "timestamp": 1619778517
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/How.20essential.20is.20the.20compile-time.20check.20for.20empty.20arrays.3F/near/236746179\">said</a>:</p>\n<blockquote>\n<p>I'd be willing to make an attempt at this.  It's been a while since I added an attribute, though, so some pointers to where I should put these things and how I should check it would be appreciated.</p>\n</blockquote>\n<p>so i except this to be very similar to <code>rustc_args_required_const</code>, except that the actual error reporting should probably happen somewhere else</p>",
        "id": 236814520,
        "sender_full_name": "lcnr",
        "timestamp": 1619778575
    },
    {
        "content": "<p>it probably makes sense to reuse <code>rustc_passes::intrinsicck</code>, though the name is incorrect here <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 236815472,
        "sender_full_name": "lcnr",
        "timestamp": 1619779092
    },
    {
        "content": "<p>I think we could change the  <code>ExprVisitor</code>+ <code>ItemVisitor</code> combination to be generic over the behavior of the <code>ExprVisitor</code> and add a new pass reusing that impl.</p>\n<p>We probably want to start with only allowing that attribute on methods and functions. This means we only have to check <code>hir::ExprKind::Path</code> and <code>hir::ExprKind::MethodCall</code> afaik</p>",
        "id": 236816364,
        "sender_full_name": "lcnr",
        "timestamp": 1619779616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/219381-t-libs/topic/How.20essential.20is.20the.20compile-time.20check.20for.20empty.20arrays.3F/near/236814440\">said</a>:</p>\n<blockquote>\n<p>it might have been sensible to use the same hack for stdarch <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> might not be possible though</p>\n</blockquote>\n<p>The stdarch changes still haven't been merged yet, so it's still possible to change.</p>",
        "id": 236832750,
        "sender_full_name": "Amanieu",
        "timestamp": 1619788896
    },
    {
        "content": "<p>hmm <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> i guess the question is whether is stdarch fine with not allowing const params as arguments?</p>",
        "id": 236846068,
        "sender_full_name": "lcnr",
        "timestamp": 1619794297
    },
    {
        "content": "<p>also not too sure what's the best way to extend this attribute to accept more complex conditions than just =! 0</p>",
        "id": 236846102,
        "sender_full_name": "lcnr",
        "timestamp": 1619794317
    },
    {
        "content": "<p>so, i did implement the attribute for functions and methods: <a href=\"https://github.com/lcnr/rust/commit/f99922d91ee19022a636d3cf53559771ae14f1c0\">https://github.com/lcnr/rust/commit/f99922d91ee19022a636d3cf53559771ae14f1c0</a></p>",
        "id": 248387761,
        "sender_full_name": "lcnr",
        "timestamp": 1628101226
    },
    {
        "content": "<p>i still have to figure out a way to extend this to types as well, to prevent users from writing <code>ArrayChunks&lt;0&gt;</code> or something. I could move all of this to wf and verify it while typechecking, but that seems kinda ugly <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 248387965,
        "sender_full_name": "lcnr",
        "timestamp": 1628101337
    },
    {
        "content": "<p>going to open a thread about that in <code>t-compiler</code></p>",
        "id": 248387991,
        "sender_full_name": "lcnr",
        "timestamp": 1628101350
    },
    {
        "content": "<p>cross ref <a href=\"#narrow/stream/131828-t-compiler/topic/checking.20generic.20arg.20!.3D.200/near/248388441\">https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/checking.20generic.20arg.20!.3D.200/near/248388441</a></p>",
        "id": 248388485,
        "sender_full_name": "lcnr",
        "timestamp": 1628101591
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/219381-t-libs/topic/How.20essential.20is.20the.20compile-time.20check.20for.20empty.20arrays.3F/near/248387965\">said</a>:</p>\n<blockquote>\n<p>i still have to figure out a way to extend this to types as well</p>\n</blockquote>\n<p>Ooh, thanks for making this!  The <code>.as_chunks()</code> calls just return slices of arrays, so they don't need the check for types, so I'll make a task for me to try out the attribute on the method and see what libs-api thinks about maybe stabilizing.</p>",
        "id": 249010429,
        "sender_full_name": "scottmcm",
        "timestamp": 1628616856
    },
    {
        "content": "<p>It's probably been discussed at some point, but would it make more sense to implement <code>#[rustc_generic_arg_non_zero]</code>as a trait bound?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">as_chunks_mut</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"cm\">/* snip */</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">()</span>: <span class=\"nc\">NonZero</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">NonZero</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// NonZero&lt;N&gt; is sealed, with impls generated by compiler magic, but equivalent to the following:</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">NonZero</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">NonZero</span><span class=\"o\">&lt;</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">NonZero</span><span class=\"o\">&lt;</span><span class=\"mi\">3</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"c1\">// ...</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">NonZero</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Having a trait seems like it might provide slightly better internal consistency than \"this function can't be called with this specific argument due to magic\", and maybe it could be compatibly replaced with a <code>where N != 0</code> bound on the method in the future, if the same <code>N != 0</code> bound is also added to the <code>NonZero</code> trait.</p>",
        "id": 249937316,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629343182
    },
    {
        "content": "<p>It could result in some user code referencing <code>NonZero</code> in its own generic bounds (e.g. in order to pass an argument through to <code>as_chunks_mut</code>), but that seems like it wouldn't be that bad? Especially if those generics are actually required to be non-zero, and there is a compatible migration path to the cleaner version <code>where N != 0</code> when/if full const generics ship.</p>",
        "id": 249937680,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629343590
    },
    {
        "content": "<p>I think that since it's just a hack, the attribute is fine.  I definitely wouldn't want to stabilize it that way, but I got no impression that that would be the plan.</p>\n<p>(I'm not sure it's worth making a maybe-slightly-better hack.  Might be fine to just wait for the \"real\" solution.)</p>",
        "id": 249938729,
        "sender_full_name": "scottmcm",
        "timestamp": 1629344958
    },
    {
        "content": "<p>I have no real objection to the hack (being able to call the method with generic parameters is nice, but not being able to do so is still better than nothing). That said, it seems like this hasn't been making much progress and I wondered if that was due to a lack of consensus as a result of how hacky the approach is.</p>",
        "id": 249939993,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629346527
    },
    {
        "content": "<p>Re. \"I definitely wouldn't want to stabilize it that way\" -- to be clear, I am trying to figure out how it could be stabilized (before full const generics is available).</p>",
        "id": 249940318,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629346988
    },
    {
        "content": "<p>Could that type be used to help <code>Default</code> impl for arrays as well?</p>",
        "id": 250007648,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629389061
    },
    {
        "content": "<p>It seems like it possibly could, if the compiler magic used to implement <code>NonZero</code> was smart enough to notice that it doesn't overlap with 0.</p>\n<p>There's probably a separate concern in that \"traits on the unit type\" is clearly not the ideal way to have bounds on const generics, and if it becomes widespread, it could result in a messier ecosystem than if we just waited for actual first-class bounds. On the other hand, maybe it's better than the workaround in which everyone skips the bounds entirely and pushes the errors all the way to runtime.</p>",
        "id": 250053725,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629409717
    },
    {
        "content": "<p>For instance, if someone asked why we have a magic <code>NonZero</code> trait but not a <code>GreaterThanFive</code> trait, I'm not sure I would have a compelling answer</p>",
        "id": 250054067,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629409949
    },
    {
        "content": "<p>Well, it could be instead, say, <code>LengthNotZero</code> trait for <code>[T; N]</code>, just like we previously do for <code>LengthAtMost32</code></p>",
        "id": 250055592,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629410912
    },
    {
        "content": "<p><code>LengthAtMost32</code> isn't ever going to be stable though, IIUC</p>",
        "id": 250055975,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629411186
    },
    {
        "content": "<p>Well, it's gone already. I am replying to the \"traits on the unit type\" thing</p>",
        "id": 250056022,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629411230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"392468\">Teddy Katz</span> <a href=\"#narrow/stream/219381-t-libs/topic/How.20essential.20is.20the.20compile-time.20check.20for.20empty.20arrays.3F/near/250054067\">said</a>:</p>\n<blockquote>\n<p>For instance, if someone asked why we have a magic <code>NonZero</code> trait but not a <code>GreaterThanFive</code> trait, I'm not sure I would have a compelling answer</p>\n</blockquote>\n<p>Probably the same reason we have a <code>NonZeroU32</code> type <a href=\"https://zulip-archive.rust-lang.org/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D.html#247823448\">but not</a> a <code>GreaterThanFiveU32</code> type :P</p>",
        "id": 250324205,
        "sender_full_name": "scottmcm",
        "timestamp": 1629707806
    },
    {
        "content": "<p>We do have a NonMinusOneI32 type on unix though (<code>File</code> ^^)</p>",
        "id": 250341754,
        "sender_full_name": "Mara",
        "timestamp": 1629720344
    },
    {
        "content": "<p><code>&amp;u16 as *const u16 as usize</code> technically is an <code>EvenUsize</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 250343381,
        "sender_full_name": "oli",
        "timestamp": 1629721328
    },
    {
        "content": "<p>Actually a wrapper <code>Aligned&lt;T&gt;(*mut T)</code> with that property might be quite useful.<br>\nEspecially for re-using the bits. For real performance gains, however, the problems plaguing NonZero* would need to be addressed.<br>\nAfaik there is some issue where llvm only realizes the bit properties when it loads from a pointer, not when passed by value?</p>",
        "id": 250344086,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1629721710
    },
    {
        "content": "<p>I guess the difference between a <code>GreaterThanFive&lt;const N: usize&gt;</code> trait and a <code>GreaterThanFiveUSize</code> type is that the latter is implementable in user code on stable right now, but the former isn't, unless your code includes (2**64 - 6) individual impls. In other words, having <code>NonZeroUSize</code> in the standard library doesn't inherently grant any new capabilities, whereas a <code>NonZero&lt;const N: usize&gt;</code> trait would, which calls for more caution when adding it.</p>",
        "id": 250535560,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629833157
    },
    {
        "content": "<p>That said, if a <code>NonZero</code> trait could get stabilized before <code>const_evaluatable_checked</code> despite this, I wouldn't complain.</p>",
        "id": 250535858,
        "sender_full_name": "Teddy Katz",
        "timestamp": 1629833306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/219381-t-libs/topic/How.20essential.20is.20the.20compile-time.20check.20for.20empty.20arrays.3F/near/248387761\">said</a>:</p>\n<blockquote>\n<p>so, i did implement the attribute for functions and methods: <a href=\"https://github.com/lcnr/rust/commit/f99922d91ee19022a636d3cf53559771ae14f1c0\">https://github.com/lcnr/rust/commit/f99922d91ee19022a636d3cf53559771ae14f1c0</a></p>\n</blockquote>\n<p>Hi, <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>!  I'm still interested in this attribute, and don't need the type version.  (Since I'm more interested in <code>.as_chunks</code> than <code>ArrayChunks</code>.)</p>\n<p>It looks like it didn't get checked in?  Is it in a place where I could try to pick it up and get it merged?</p>",
        "id": 263802759,
        "sender_full_name": "scottmcm",
        "timestamp": 1638757471
    },
    {
        "content": "<p>i think that should be mostly ready for for merge <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> don't 100% remember</p>",
        "id": 263823996,
        "sender_full_name": "lcnr",
        "timestamp": 1638782137
    },
    {
        "content": "<p>Could we use post-mono checking for this?</p>",
        "id": 263919582,
        "sender_full_name": "Gary Guo",
        "timestamp": 1638822190
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">AssertNonZero</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">AssertNonZero</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">VAL</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">array</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">AssertNonZero</span>::<span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>::<span class=\"n\">VAL</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">array</span>::<span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">array</span>::<span class=\"o\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//^~ ERROR</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263919971,
        "sender_full_name": "Gary Guo",
        "timestamp": 1638822381
    },
    {
        "content": "<p>Wow, that even works on stable.  I had no idea.</p>",
        "id": 263923182,
        "sender_full_name": "scottmcm",
        "timestamp": 1638824160
    },
    {
        "content": "<p>Panic in const context was just stabilized.</p>",
        "id": 263923480,
        "sender_full_name": "The 8472",
        "timestamp": 1638824284
    },
    {
        "content": "<p>post-monomorphization errors will not trigger easily for code coming from dependencies though, and it seems likely that a check build would not trigger the PME for the <code>array::&lt;0&gt;()</code> call if it were in a different crate (which seems problematic for libcore), while a build involving codegen would indeed fail with the PME</p>",
        "id": 263929248,
        "sender_full_name": "lqd",
        "timestamp": 1638827178
    },
    {
        "content": "<p>Post-mono also means this couldn't become a <code>where N != 0</code> bound in future, right?  Since that would break stuff that wrote it but didn't mono it?</p>",
        "id": 263929735,
        "sender_full_name": "scottmcm",
        "timestamp": 1638827478
    },
    {
        "content": "<p>I would believe so. your + lcnr's <code>rustc_generic_arg_non_zero</code> would fare better in that regard at least</p>",
        "id": 263931671,
        "sender_full_name": "lqd",
        "timestamp": 1638828420
    },
    {
        "content": "<p>Similar patterns work for quite a lot of compile time properties on stable. Including, but not limited, testing a pair of types for equal layout (permitting reusing Vec and Box storage), testing for zero-sized types, asserting trivial drop, working around not being allowed to use trait bounds in const-impl for 'empty' marker traits like Zeroable/Pod/etc., probably some stuff I forgot. And, unilke <code>where</code>, it is not infectious. There's a trade-off in post-monomorphization errors but it is truly a tradeoff in that it has upsides. Should the pattern be endorsed or not?</p>",
        "id": 264500793,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1639166689
    }
]