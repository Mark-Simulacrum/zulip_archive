[
    {
        "content": "<p>I'm just kind of sad that <code>ptr::slice_from_raw_parts</code> is safe, and doesn't have a safety restriction for <code>[T]</code> to have size &lt;= <code>isize::MAX</code> (it doesn't even have one for size &lt;= <code>usize::MAX</code>!) It would've been nice if we could have had it be a validity requirement for a slice pointer's length to keep size &lt;= <code>isize::MAX</code>, and have <code>SliceMetadata&lt;T&gt;</code> to enforce that (rather than having a pointer metadata of just <code>usize</code>).<br>\nIt would be so nice to be able to, in addition to forcing <code>Layout</code> to respect <code>isize::MAX</code>, to also have split out pointer metadata respect it, so <code>Layout::from_metadata</code> could be safe. As is, <em>even ignoring the decision for vtables,</em> the method has to either:</p>\n<ul>\n<li>Change <code>intrinsics::size_of_val</code> to return an <code>Option&lt;#[rustc_valid_scalar_start(0)] isize&gt;</code>, or</li>\n<li>Be unsafe, and require that the metadata describes a valid layout with size &lt;= <code>isize::MAX</code></li>\n</ul>",
        "id": 278373178,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649459670
    },
    {
        "content": "<p>And given that we maybe want to enforce that restraint to <code>Layout</code> as well as nebulously for \"rust objects\" (<a href=\"https://github.com/rust-lang/rust/pull/95295\">https://github.com/rust-lang/rust/pull/95295</a>), it's sad that we just <em>can't</em> for pointer metadata</p>",
        "id": 278373248,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649459762
    },
    {
        "content": "<p>Yeah, pointers don't need to be valid... but metadata maybe being invalid makes working with them much more dangerous than it needs to be</p>",
        "id": 278373317,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649459807
    },
    {
        "content": "<p>oof, yeah.  it's not valid to actually use the pointer if the metadata is over isize::MAX, but it can still be made :(</p>",
        "id": 278373994,
        "sender_full_name": "scottmcm",
        "timestamp": 1649460497
    },
    {
        "content": "<p>it's genuinely safe for a ZST</p>",
        "id": 278375573,
        "sender_full_name": "cuviper",
        "timestamp": 1649462223
    },
    {
        "content": "<p>otherwise I take it that the point is not really whether the metadata len is over <code>isize::MAX</code>, but the object size, <code>size_of::&lt;T&gt;()*len</code>, right?</p>",
        "id": 278375608,
        "sender_full_name": "cuviper",
        "timestamp": 1649462281
    },
    {
        "content": "<p>Yes</p>",
        "id": 278375703,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462385
    },
    {
        "content": "<p>yeah, I guess that since it's <em>len</em>, it's more reasonable.  It's not obvious to me that it'd be good for slices of different types to have different <em>validity</em> invariants on the length</p>",
        "id": 278375859,
        "sender_full_name": "scottmcm",
        "timestamp": 1649462456
    },
    {
        "content": "<p>It wouldn't have to be <em>validity</em>, it could just be safety enforced by the API, though, at the \"I am the language\" level that doesn't make too much of a difference?</p>",
        "id": 278375903,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462513
    },
    {
        "content": "<p>go for <code>*const [[u8; isize::MAX]]</code>, now your valid slice length is a <code>bool</code></p>",
        "id": 278375955,
        "sender_full_name": "cuviper",
        "timestamp": 1649462539
    },
    {
        "content": "<p>Like what I care about isn't invalid values, I just wish it were a possibility for <code>metadata(ptr).size()</code> to be safe</p>",
        "id": 278375997,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462598
    },
    {
        "content": "<p>Pointers-to-overlong-slice being safe to create make that an impossibility for the current intrinsic though</p>",
        "id": 278376012,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462619
    },
    {
        "content": "<p>The <code>*const [T]</code> len being <code>&lt; isize::MAX</code> bytes is less useful than one would think because it still does not enable using <code>ptr::add</code> since that requires operations to be in-bounds. So in practice you need len not just be small enough, you need it to be correct.</p>",
        "id": 278376117,
        "sender_full_name": "The 8472",
        "timestamp": 1649462721
    },
    {
        "content": "<p>Again, I'm not personally concerned about len right now, I'm looking at the size of the described object's layout</p>",
        "id": 278376192,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462781
    },
    {
        "content": "<p>byte size, not element length</p>",
        "id": 278376207,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/219381-t-libs/topic/Pointee.20metadata.20vs.20size_of/near/278375997\">said</a>:</p>\n<blockquote>\n<p>Like what I care about isn't invalid values, I just wish it were a possibility for <code>metadata(ptr).size()</code> to be safe</p>\n</blockquote>\n<p>where is this <code>fn size()</code>? something new?</p>",
        "id": 278376220,
        "sender_full_name": "cuviper",
        "timestamp": 1649462823
    },
    {
        "content": "<p><code>DynMetadata</code> has a <code>size_of</code>, I was playing off of that accidentally</p>",
        "id": 278376247,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462873
    },
    {
        "content": "<p>The proper spelling is in fact <code>mem::size_of_val_raw</code> or <code>intrinsics::size_of_val</code></p>",
        "id": 278376295,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462894
    },
    {
        "content": "<p>ah</p>",
        "id": 278376307,
        "sender_full_name": "cuviper",
        "timestamp": 1649462922
    },
    {
        "content": "<p>that could safely return an <code>Option&lt;usize&gt;</code></p>",
        "id": 278376322,
        "sender_full_name": "cuviper",
        "timestamp": 1649462952
    },
    {
        "content": "<p>The current implementation (I'm looking at it) is codegenning <code>size_of::&lt;T&gt;() * len</code> directly for the intrinsic</p>",
        "id": 278376335,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649462985
    },
    {
        "content": "<p>All it'd need to do really is do a checked mul, then the wrapper can cordon it off to <code>isize::MAX</code></p>",
        "id": 278376394,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649463017
    },
    {
        "content": "<p>However, doing so is not trivial because <code>bx</code> doesn't have a <code>checked_mul</code></p>",
        "id": 278376416,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649463057
    },
    {
        "content": "<p>So it could be done for slice pointers <em>specifically</em>, but pointers generally is still problematic</p>",
        "id": 278376442,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649463097
    },
    {
        "content": "<p>where else is it problematic? concrete types should already have limited size, and trait objects should have a concrete vtable with a valid size</p>",
        "id": 278376501,
        "sender_full_name": "cuviper",
        "timestamp": 1649463159
    },
    {
        "content": "<p>In that codegen has to emit the checked mul and a) making intrinsic size_of slower is scary and b) I have no idea how to do so anyway<br>\nAlso, technically it's not decided that raw pointers to trait objects have a <em>valid</em> vtable as an invariant, just that it's nonnull</p>",
        "id": 278376577,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649463253
    },
    {
        "content": "<p>The TL;DR of what I'm banging my head against is that the <code>isize::MAX</code> limit on size is too difficult to maintain by hand, so we want to do so automatically through <code>Layout</code>... but I want to prove out the storages API, which deals exclusively in pointer metadata, not in <code>Layout</code>, so we've lost that protection layer. The solution is to catch that as part of the storages API and return an alloc error. And that basically means safe versions of <code>intrinsic::size_of_val</code> and <code>intrinsic::align_of_val</code>.</p>",
        "id": 278376859,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649463614
    },
    {
        "content": "<blockquote>\n<p>checked mul</p>\n</blockquote>\n<p>s/checked/saturating</p>",
        "id": 278376966,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649463774
    },
    {
        "content": "<p>Oh, right, LLVM only has fixed-point saturating multiplication intrinsics and saturating addition intrinsics.  So probably no <code>bx</code> for umul_sat</p>",
        "id": 278377359,
        "sender_full_name": "scottmcm",
        "timestamp": 1649464206
    },
    {
        "content": "<p>saturating_mul is implemented as checked_mul, via bx.checked_binop, so I'm almost to making it use a saturating mul, except, I need to get a Ty for usize and since this is my first time touching compiler things this deep I have no idea how to do so and it doesn't help that in <code>size_and_align_of_dst</code> I only have <code>bx</code> and <code>t: Ty</code></p>",
        "id": 278377703,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649464679
    },
    {
        "content": "<p>aka no TyCtxt</p>",
        "id": 278377773,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649464754
    },
    {
        "content": "<p>Also there's the case of a composite type with unsized tail that I haven't even really considered</p>",
        "id": 278378392,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649465561
    },
    {
        "content": "<p>Aha: <code>bx.cx().tcx()</code> is the path to get to the tcx</p>",
        "id": 278378489,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649465757
    },
    {
        "content": "<p>Well I got the saturating mul, but a saturating add is what stops me from making it saturate for compound types as well...</p>",
        "id": 278380606,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649468564
    },
    {
        "content": "<p>Well, I filled <a href=\"https://github.com/rust-lang/rust/pull/95832\">https://github.com/rust-lang/rust/pull/95832</a> to try and see if this is a performance impact oh of <em>course</em> test 11600/12907 or so failed just after I hit send</p>",
        "id": 278380620,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649468616
    }
]