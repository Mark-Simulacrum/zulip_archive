[
    {
        "content": "<p>I was going to propose that we make <code>u128: From&lt;usize&gt;</code> infallible, since it is and always will be.  (Even just 2⁹⁶ silicon atoms is 3695 kilograms, and that's without addressing circuitry or wires.)</p>\n<p>But I guess we can't, can we, since we have <code>&lt;u128 as TryFrom&lt;usize&gt;&gt;::Error</code> as something other than <code>Infallible</code>?</p>",
        "id": 264242400,
        "sender_full_name": "scottmcm",
        "timestamp": 1639010572
    },
    {
        "content": "<p>I don't think it'd be a breaking change.</p>",
        "id": 264250894,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639018869
    },
    {
        "content": "<p>In practice.</p>",
        "id": 264250896,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639018872
    },
    {
        "content": "<p>But also, I genuinely think it's <em>possible</em> that people could have a system where <code>usize</code> is more than 128 bits.</p>",
        "id": 264250912,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639018894
    },
    {
        "content": "<p>Not because people would actually use 2**256 bytes <em>simultaneously</em>.</p>",
        "id": 264250929,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639018911
    },
    {
        "content": "<p>But for the same reason that IPv6 is 128 bits rather than 64: it's convenient for partitioning at several levels.</p>",
        "id": 264250991,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639018939
    },
    {
        "content": "<p>Suppose, hypothetically, you have a data-center-wide computer with a shared address space, such that there's a unique virtual address for every byte of virtual address in any process's address space. And for partitioning reasons, it might make sense to partition addresses such that there are N bits to identify a system, N bits to identify a CPU within the system, and also N bits to identify processes, in addition to each process having a 64-bit address space.</p>",
        "id": 264251093,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639019056
    },
    {
        "content": "<p>(leaving aside things like pointer tagging)</p>",
        "id": 264251098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639019063
    },
    {
        "content": "<p>I understand that more bits than you can address is reasonable -- that's why I only used 96 bits in my example.  But exponentials are just so powerful.  It's like why 128-bit security is more than fine, even though 80 bits isn't.</p>",
        "id": 264269516,
        "sender_full_name": "scottmcm",
        "timestamp": 1639038765
    },
    {
        "content": "<p>Do supercomputers still use shared memory models, BTW?  I thought they'd moved to MPI-like approaches instead.</p>",
        "id": 264269583,
        "sender_full_name": "scottmcm",
        "timestamp": 1639038838
    },
    {
        "content": "<p>Supercomputers generally don't, but there are other technologies that do, and things are tried from time to time.</p>",
        "id": 264270285,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639039300
    },
    {
        "content": "<p>HP tried to do interesting things with The Machine.</p>",
        "id": 264270397,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639039353
    },
    {
        "content": "<p>I don't feel comfortable predicting that we will not need more than 128-bit addressing in the future.</p>",
        "id": 264270487,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639039413
    },
    {
        "content": "<p>I <em>do</em> think we need the portability lint and defaults that let you infallibly get a u64 from a usize if you don't opt into handling more.</p>",
        "id": 264270584,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639039473
    },
    {
        "content": "<p>For collision resistance (classical) you'd need double the size. E.g. if your memory system wanted to hand out virtual addresses at random without having to check that they're already in use.</p>",
        "id": 264280065,
        "sender_full_name": "The 8472",
        "timestamp": 1639044922
    },
    {
        "content": "<p>This is an old story, I still think that we need to have <code>X: From&lt;usize&gt;</code> and <code>usize: From&lt;X&gt;</code> for all integer types that support the lossless conversion on the current target, together with a lint that warns on \"widely unportable\" conversions like <code>usize</code> -&gt; <code>u32</code> on 32-bit systems and <code>u64</code> -&gt; <code>usize</code> ion 64-bit systems.</p>",
        "id": 264283278,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1639046891
    },
    {
        "content": "<p>I believe there was even a relative recent (last year?) PR that started this work but was closed due to inactivity.</p>",
        "id": 264283325,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1639046931
    },
    {
        "content": "<p>(It was <a href=\"https://github.com/rust-lang/rust/pull/71360\">https://github.com/rust-lang/rust/pull/71360</a>)</p>",
        "id": 264305999,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1639058924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/We.20can't.20.60u128.3A.20From.3Cusize.3E.60.2C.20can.20we.3F/near/264270487\">said</a>:</p>\n<blockquote>\n<p>I don't feel comfortable predicting that we will not need more than 128-bit addressing in the future.</p>\n</blockquote>\n<p>This is where I like to pull out <a href=\"https://arxiv.org/abs/quant-ph/9908043\">Lloyd 1999</a>.  It discusses an \"ultimate laptop\":</p>\n<blockquote>\n<p>The amount of information that can be stored by the 1 kilogram computer in the black-hole limit is 3.827 × 10¹⁶ bits. A computer compressed to the size of a black hole can perform 5.4258 × 10⁵⁰ operations per second.</p>\n</blockquote>\n<p>That's 1.062 × 2⁵⁵ bits of information; call it 2⁵² bytes.  That leaves <em>plenty</em> of room for addressing across multiple such machines or whatever in a 128-bit <code>usize</code>.</p>\n<p>Come to think of it, this is potentially also interesting for the <code>size_t</code> vs <code>ptrdiff_t</code> conversation.  Arguably <code>size_t</code> is likely to be fine as 64-bit forever, even if <code>ptrdiff_t</code> may need to be larger.  (Like how an individual file in ZFS can only be 2⁶⁴ bytes even though the pool as a whole can store 2¹²⁸ bytes.)</p>",
        "id": 264352225,
        "sender_full_name": "scottmcm",
        "timestamp": 1639077408
    },
    {
        "content": "<p>By the time you're using a black hole on your lap for compute we might have a rust 2.0</p>",
        "id": 264353207,
        "sender_full_name": "The 8472",
        "timestamp": 1639077819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/We.20can't.20.60u128.3A.20From.3Cusize.3E.60.2C.20can.20we.3F/near/264353207\">said</a>:</p>\n<blockquote>\n<p>By the time you're using a black hole on your lap for compute we might have a rust 2.0</p>\n</blockquote>\n<p>Wow so this whole thing about Rust's stability guarantees is just a joke? Who would've thought</p>",
        "id": 264354092,
        "sender_full_name": "Jake",
        "timestamp": 1639078260
    },
    {
        "content": "<p>Feature accretion disk.</p>",
        "id": 264354360,
        "sender_full_name": "The 8472",
        "timestamp": 1639078399
    },
    {
        "content": "<p>Stability is not absolute, but relative to the observer</p>",
        "id": 264363748,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639082791
    },
    {
        "content": "<p>Isn't this kind of argument assuming that those 128 bits are actually all being used densely? It seems much more likely to me that a future pointer format is invented that needs more bits than that because of overly generous reservations at multiple levels. For example architectures currently reserve all 64 bytes of the pointer (except possibly the low few bits assuming known alignment, although even then it's not necessarily the case, e.g. ARM thumb pointers) even though most can't even use more than 48 bits due to the hardware design, which means pointer tagging systems like CHERI have to go to 128 bits even though there is certainly a lot less entropy than that</p>",
        "id": 264372395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639086887
    },
    {
        "content": "<p>Exactly. I don't expect that anyone needs more than <code>2**128</code> bytes of actual RAM, but when you assign portions of virtual address space for things like tags, networks, systems, CPUs, processes, etc, then you consume bits <em>linearly</em>.</p>",
        "id": 264372913,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639087179
    },
    {
        "content": "<p>For instance, combine CHERI pointer tagging with \"I want to uniquely address every virtual address on every system on the network\" and you already need more than 128 bits.</p>",
        "id": 264373020,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639087212
    },
    {
        "content": "<p>Or, suppose you chose a virtual address scheme involving a system's unique IPv6 address (to give a ridiculous but not <em>too</em> ridiculous possibility).</p>",
        "id": 264373196,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639087268
    },
    {
        "content": "<p>Or you take ASLR to the <em>next</em> level.</p>",
        "id": 264373879,
        "sender_full_name": "Connor Horman",
        "timestamp": 1639087499
    },
    {
        "content": "<p>Heh. \"You can't even guess a thing that's a valid address, and distant segfaults (rather than 'local' segfaults) are SIGKILL so you can't walk your shots\".</p>",
        "id": 264378108,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639089681
    },
    {
        "content": "<p>I think that's kinda what CHERI is trying to do.</p>",
        "id": 264378143,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639089702
    },
    {
        "content": "<p>Insofar as CHERI makes it possible to distinguish between \"just off the end of a valid address\" and \"could not have been derived from a valid address\".</p>",
        "id": 264378243,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639089734
    },
    {
        "content": "<p>Don't even need SIGKILL. You've got a <em>few</em> years (584) if you guess one address every nanosecond.</p>",
        "id": 264380090,
        "sender_full_name": "Connor Horman",
        "timestamp": 1639090855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Fair enough, though there's still value in catching attempts.</p>",
        "id": 264386626,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639095365
    },
    {
        "content": "<p>imagining an arch which uses sha-256 pointers, just to getcha</p>",
        "id": 264406346,
        "sender_full_name": "Jubilee",
        "timestamp": 1639115867
    },
    {
        "content": "<p>Oooh, that's fun. Or pointers public-key encrypted to a private key in the processor.</p>",
        "id": 264409066,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639119197
    },
    {
        "content": "<p>Ethereum Virtual Machine uses 256bit addressing because keccak256 has 256bit output.</p>",
        "id": 264410597,
        "sender_full_name": "fee1-dead",
        "timestamp": 1639121000
    },
    {
        "content": "<p>See <a href=\"https://github.com/rust-lang/rust/pull/49305’s\">https://github.com/rust-lang/rust/pull/49305’s</a> PR description:</p>\n<blockquote>\n<p>[…] the C99 standard which (indirectly) requires pointers to be at least 16 bits […]</p>\n<p>Note: if we make similar assumptions about the _maximum_ bit size of pointers (for all targets Rust will ever run on in the future), we could have similar <code>From</code> impls converting pointer-sized integers to large fixed-size integers. RISC-V considers the possibility of a 128-bit address space (RV128), which would leave only <code>impl From&lt;usize&gt; for u128</code> and <code>impl From&lt;isize&gt; for u128</code>. I <a href=\"https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20171017a-cheri-poster.pdf\">found</a> some <a href=\"http://www.csl.sri.com/users/neumann/2012resolve-cheri.pdf\">things</a> about 256-bit “capabilities”, but I don’t know how relevant that would be to Rust’s <code>usize</code> and <code>isize</code> types.</p>\n<p>I chose conservatively to make no assumption about the future there. Users <del>making</del> can make their own portability decisions and <del>using</del> use something like <code>.try_into().unwrap()</code>.</p>\n</blockquote>",
        "id": 264699971,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1639399298
    },
    {
        "content": "<p>ah I see CHERI was already mentioned here</p>",
        "id": 264700066,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1639399338
    },
    {
        "content": "<p>256-bit capabilities would apply to rust if usize=<code>uintptr_t</code>.</p>",
        "id": 264723431,
        "sender_full_name": "Connor Horman",
        "timestamp": 1639409734
    },
    {
        "content": "<p>I was reading this insanely cursed paper on how some people used a custom memory controller, plus some \"creative\" ideas of how to flip bits in RAM, to do computation \"directly on RAM\", and it turned out that 256 bits was about the right working unit. So it created a word (256-bits)-addressed SIMD machine.</p>\n<p>I claim no relationship with the rest of this conversation I just think it's funny.</p>",
        "id": 264927417,
        "sender_full_name": "Jubilee",
        "timestamp": 1639517031
    },
    {
        "content": "<p>That sounds similar to the zero-instruction computer built out of the x86 page fault handler.</p>",
        "id": 264929296,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639517902
    },
    {
        "content": "<p>They synthesized most higher-level instructions out of MAJ and NOT, as opposed to the classic AND, OR, and NOT building blocks.<br>\n<a href=\"https://people.inf.ethz.ch/omutlu/pub/SIMDRAM_asplos21.pdf\">https://people.inf.ethz.ch/omutlu/pub/SIMDRAM_asplos21.pdf</a></p>",
        "id": 264930738,
        "sender_full_name": "Jubilee",
        "timestamp": 1639518402
    }
]