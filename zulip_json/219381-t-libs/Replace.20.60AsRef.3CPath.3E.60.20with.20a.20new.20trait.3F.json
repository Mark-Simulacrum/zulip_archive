[
    {
        "content": "<p>What if  we introduced a new trait to be used in arguments as a drop-in replacement for <code>AsRef&lt;Path&gt;</code>. Would something break?</p>\n<p>For example, if the signature of <a href=\"https://doc.rust-lang.org/std/fs/struct.File.html#method.open\"><code>File::open</code></a> was changed to this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">open</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nc\">IntoPlatformPath</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">path</span>: <span class=\"nc\">P</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">io</span>::<span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">File</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And <code>IntoPlatformPath</code> is implemented for all <code>AsRef&lt;Path&gt;</code></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nb\">AsRef</span><span class=\"o\">&lt;</span><span class=\"n\">Path</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">IntoPlatformPath</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274782794,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646880130
    },
    {
        "content": "<p>What would be the advantage? Special cases for native UTF-16 paths?</p>",
        "id": 274785442,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646883117
    },
    {
        "content": "<p>Yeah, I was thinking it might be a way to directly pass in UTF-16 paths or null terminated C strings (depending on the platform). I'm not quite sure if it's a good idea but I did want to understand the available design space. I.e. what we can change and what we can't.</p>",
        "id": 274785600,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646883273
    },
    {
        "content": "<p>I <em>think</em> that wouldn't be breaking?</p>",
        "id": 274791532,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646889726
    },
    {
        "content": "<p>Not sure how easily you could take advantage of it, given constraints on OsString.</p>",
        "id": 274791556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646889771
    },
    {
        "content": "<p>You would need a completely different type.</p>",
        "id": 274791574,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646889784
    },
    {
        "content": "<p>Something would have to produce that type.</p>",
        "id": 274791588,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646889796
    },
    {
        "content": "<p>Well with the caveat that I'm just very roughly sketching at the moment, I was thinking something along these lines:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// OS specific.</span>\n<span class=\"k\">type</span> <span class=\"nc\">RawPlatformStr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"sd\">/// Safety: Must always return a valid RawPlatformStr.</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">AsRawPlatformStr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">as_raw</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">RawPlatformStr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">len</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"sd\">/// Conversion trait.</span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">ToPlatformString</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">PlatformString</span>: <span class=\"nc\">AsRawPlatformStr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">to_platform_str</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">PlatformString</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// This could be a user defined type.</span>\n<span class=\"cp\">#[derive(Copy, Clone)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyPlatformStr</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u16</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyPlatformStr</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">s</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"p\">[</span><span class=\"kt\">u16</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">last</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">0</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">AsRawPlatformStr</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyPlatformStr</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">as_raw</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">RawPlatformStr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">len</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ToPlatformString</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyPlatformStr</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">PlatformString</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">to_platform_str</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">PlatformString</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// An internal std type.</span>\n<span class=\"k\">struct</span> <span class=\"nc\">OwnedPlatformString</span><span class=\"p\">(</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u16</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">AsRawPlatformStr</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">OwnedPlatformString</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">as_raw</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">RawPlatformStr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">len</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nb\">AsRef</span><span class=\"o\">&lt;</span><span class=\"n\">Path</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">ToPlatformString</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">PlatformString</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">OwnedPlatformString</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">to_platform_str</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">PlatformString</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">OwnedPlatformString</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">as_ref</span><span class=\"p\">().</span><span class=\"n\">as_os_str</span><span class=\"p\">().</span><span class=\"n\">encode_wide</span><span class=\"p\">().</span><span class=\"n\">chain</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]).</span><span class=\"n\">collect</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274794891,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646893091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/274782794\">said</a>:</p>\n<blockquote>\n<p>And <code>IntoPlatformPath</code> is implemented for all <code>AsRef&lt;Path&gt;</code></p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">P</span>: <span class=\"nb\">AsRef</span><span class=\"o\">&lt;</span><span class=\"n\">Path</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">IntoPlatformPath</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I think that if you have that, you need negative impls in coherence to not overlap with the blanket if you ever want to implement it.</p>",
        "id": 274801745,
        "sender_full_name": "scottmcm",
        "timestamp": 1646899497
    },
    {
        "content": "<blockquote>\n<p>What if  we introduced a new trait to be used in arguments as a drop-in replacement for <code>AsRef&lt;Path&gt;</code>.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"260325\">@Chris Denton</span> I was thinking about the exact same thing the other day. Would be nice if we can eventually provide a 'true' 'OsString' (with a different name), that actually stores a nul-terminated and on windows UCS-2/UTF-16 string.</p>",
        "id": 274859844,
        "sender_full_name": "Mara",
        "timestamp": 1646929848
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260325\">@Chris Denton</span> iirc, in <code>std::sys</code> we have a slightly different api. something like <code>with_os_str(s, |x| { ... })</code>. that way, <code>x</code> can borrow from a local variable (on the stack) from <code>with_os_str</code>, which can be useful to avoid heap allocations for paths until a certain length.</p>",
        "id": 274860216,
        "sender_full_name": "Mara",
        "timestamp": 1646929983
    },
    {
        "content": "<p>Yeah, using a closure looks like a good design. In any case I wasn't meaning to design a new API right this minute <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span>. But I did want to check in to see if this was a future possibility.</p>",
        "id": 274892917,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646945351
    },
    {
        "content": "<p>I would rather see that we eventually switch fron the W variants to the A variants of win32 api's once UTF-8 is supported by them on all supported windows targets by setting the code page to utf-8: <a href=\"https://docs.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page\">https://docs.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page</a></p>",
        "id": 274895591,
        "sender_full_name": "bjorn3",
        "timestamp": 1646946794
    },
    {
        "content": "<p>That would mean no longer supporting broken Unicode (the <code>A</code> functions do a lossy conversion). Which may be ok but would be a change from how Rust currently works. It's also hard to enforce UTF-8 when Rust is used in a DLL rather than an exe because as far as I'm aware the setting is per process rather than per module.</p>\n<p>And on all platforms there's still the issue of appending the null terminator, which requires an allocation (or at least copying the string to a stack buffer).</p>",
        "id": 274897365,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646947744
    },
    {
        "content": "<p>Yeah the A functions are not great</p>",
        "id": 274907015,
        "sender_full_name": "Lokathor",
        "timestamp": 1646952549
    },
    {
        "content": "<blockquote>\n<p>And on all platforms there's still the issue of appending the null terminator, which requires an allocation (or at least copying the string to a stack buffer).</p>\n</blockquote>\n<p>This part is \"easily\" fixable with the type system</p>",
        "id": 274907085,
        "sender_full_name": "Lokathor",
        "timestamp": 1646952594
    },
    {
        "content": "<p>Easily?</p>",
        "id": 274907852,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646953018
    },
    {
        "content": "<p>What about using A where possible and falling back to W for incorrect UTF-16?</p>",
        "id": 274908405,
        "sender_full_name": "bjorn3",
        "timestamp": 1646953308
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/274897365\">said</a>:</p>\n<blockquote>\n<p>That would mean no longer supporting broken Unicode (the <code>A</code> functions do a lossy conversion). Which may be ok but would be a change from how Rust currently works. It's also hard to enforce UTF-8 when Rust is used in a DLL rather than an exe because as far as I'm aware the setting is per process rather than per module.</p>\n<p>And on all platforms there's still the issue of appending the null terminator, which requires an allocation (or at least copying the string to a stack buffer).</p>\n</blockquote>\n<p>I think once all supported Windows targets support UTF-8 in the A functions, we could reasonably make such a transition. I don't think it'd be impossible.</p>",
        "id": 274908749,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646953504
    },
    {
        "content": "<blockquote>\n<p>What about using A where possible and falling back to W for incorrect UTF-16?</p>\n</blockquote>\n<p>I mean, maybe. We'd ideally need to avoid doing a Unicode check on every use though.</p>",
        "id": 274910141,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646954410
    },
    {
        "content": "<blockquote>\n<p>I think once all supported Windows targets support UTF-8 in the A functions, we could reasonably make such a transition. I don't think it'd be impossible.</p>\n</blockquote>\n<p>Hm, in that case why can't we do lossy conversions now?</p>",
        "id": 274910154,
        "sender_full_name": "Chris Denton",
        "timestamp": 1646954420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/274907852\">said</a>:</p>\n<blockquote>\n<p>Easily?</p>\n</blockquote>\n<p>\"Easily\" as in \"you <em>just</em> need to make a separate set of string types that correctly does what you want\".</p>",
        "id": 274914171,
        "sender_full_name": "Lokathor",
        "timestamp": 1646957213
    },
    {
        "content": "<p>What about rust cdylibs using std? I think those can't control the manifest/utf8 codepage</p>",
        "id": 274916603,
        "sender_full_name": "Nick12",
        "timestamp": 1646958744
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/274914171\">said</a>:</p>\n<blockquote>\n<p>\"Easily\" as in \"you <em>just</em> need to make a separate set of string types that correctly does what you want\".</p>\n</blockquote>\n<p><em>cough</em> <a href=\"https://docs.rs/abistr/0.2.0-rc1/abistr/index.html\">abistr</a> <em>cough</em> &lt;/self-plug&gt;</p>",
        "id": 274917055,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1646959017
    },
    {
        "content": "<p>Just to continue expounding on prior art:</p>\n<ul>\n<li><code>AsRawPlatformStr</code> ~ <a href=\"https://docs.rs/abistr/0.2.0-rc1/abistr/trait.AsCStr.html\"><code>abistr::AsCStr</code></a>, although I skip <code>len</code></li>\n<li><code>ToPlatformString</code> ~ <a href=\"https://docs.rs/abistr/0.2.0-rc1/abistr/trait.TryIntoAsCStr.html\"><code>abistr::TryIntoAsCStr</code></a></li>\n<li><code>MyPlatformStr</code> ~ <code>std::ffi::CStr</code>, <a href=\"https://docs.rs/widestring/latest/widestring/ucstr/type.U16CStr.html\"><code>widestring::U{16,32}CStr</code></a>, <a href=\"https://docs.rs/abistr/0.2.0-rc1/abistr/struct.CStrPtr.html\"><code>abistr::CStrPtr</code></a>, <a href=\"https://docs.rs/abistr/0.2.0-rc1/abistr/struct.CStrNonNull.html\"><code>abistr::CStrNonNull</code></a></li>\n<li><code>OwnedPlatformString</code> ~ <code>std::ffi::CString</code>, <a href=\"https://docs.rs/widestring/latest/widestring/ucstring/type.U16CString.html\"><code>widestring::U{16,32}CString</code></a>, <a href=\"https://docs.rs/abistr/0.2.0-rc1/abistr/struct.CStrBuf.html\"><code>abistr::CStrBuf</code></a></li>\n</ul>",
        "id": 274919173,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1646960729
    },
    {
        "content": "<p>I've considered adding <code>abistr::*CPath*</code> variations but haven't bothered to actually go through with that yet</p>",
        "id": 274919292,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1646960814
    },
    {
        "content": "<p>@bjorn3: Throwing in the (very little) I know, AFAIK the <code>A</code> variants of Windows APIs aren't zero-cost -- from <a href=\"https://docs.microsoft.com/en-us/windows/win32/learnwin32/working-with-strings\">MSDN docs</a> (emphasis mine):</p>\n<blockquote>\n<p>Internally, the ANSI version translates the string to Unicode. ...</p>\n<p>...</p>\n<p>New applications should always call the Unicode versions. Many world languages require Unicode. If you use ANSI strings, it will be impossible to localize your application. <strong>The ANSI versions are also less efficient, because the operating system must convert the ANSI strings to Unicode at run time.</strong></p>\n</blockquote>",
        "id": 275115766,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1647117087
    },
    {
        "content": "<p>Given that, I'm fairly confident that switching to all the A functions would be a big step backwards.</p>",
        "id": 275118813,
        "sender_full_name": "Lokathor",
        "timestamp": 1647121765
    },
    {
        "content": "<p>I'm wondering to what extent that continues to be true, and to what extent that might change in the future, given the continued movement of Windows 10/11 towards compatibility.</p>",
        "id": 275119064,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647122176
    },
    {
        "content": "<p>Also, the quoted text there does not seem to take into account the current version of the ANSI APIs that operate in terms of UTF-8.</p>",
        "id": 275119073,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647122235
    },
    {
        "content": "<p>It seems to be talking only about ANSI as though it is not UTF-8.</p>",
        "id": 275119077,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647122259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>: I doubt that Windows would change its native string encodings without serious discussion and advertisement of intent -- there's some nontrivial performance concerns around that, esp. for non-Latin languages. I think it's an interesting idea, but there <em>are</em> a lot of stakeholders to engage with a change like that.</p>\n<p>It seems like the code page setting for UTF-8 changes what the conversion to UTF-16LE converts from (instead of ANSI), rather than avoiding conversion. From <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span>'s <a href=\"https://docs.microsoft.com/en-us/windows/apps/design/globalizing/use-utf8-code-page\">link about using UTF-8</a> (again, emphasis mine):</p>\n<blockquote>\n<h2>-A vs. -W APIs</h2>\n<p>Win32 APIs often support both -A and -W variants.</p>\n<p>-A variants recognize the ANSI code page configured on the system and support <code>char*</code>, while -W variants operate in UTF-16 and support <code>WCHAR</code>. </p>\n<p>Until recently, Windows has emphasized \"Unicode\" -W variants over -A APIs. However, recent releases have used the ANSI code page and -A APIs as a means to introduce UTF-8 support to apps. If the ANSI code page is configured for UTF-8, -A APIs operate in UTF-8. This model has the benefit of supporting existing code built with -A APIs without any code changes. </p>\n<h2>Code page conversion</h2>\n<p><strong>As Windows operates natively in UTF-16 (<code>WCHAR</code>), you might need to convert UTF-8 data to UTF-16 (or vice versa) to interoperate with Windows APIs.</strong></p>\n<p>...</p>\n</blockquote>",
        "id": 275120272,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1647124250
    },
    {
        "content": "<p>(Also of note is that some parts of User32 (which the stdlib likely doesn't interact with, but might) will remember if your program uses the A or W variant and then other functions that don't even have A/W variants will still be affected by your previous choice.)</p>",
        "id": 275121046,
        "sender_full_name": "Lokathor",
        "timestamp": 1647125747
    },
    {
        "content": "<p>Oh, dear. That sounds rife with problems when it comes to different modules!</p>",
        "id": 275121481,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1647126393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/275121046\">said</a>:</p>\n<blockquote>\n<p>(Also of note is that some parts of User32 (which the stdlib likely doesn't interact with, but might) will remember if your program uses the A or W variant and then other functions that don't even have A/W variants will still be affected by your previous choice.)</p>\n</blockquote>\n<p>Details on that, if you have them?</p>",
        "id": 275124570,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647131856
    },
    {
        "content": "<p>Fundamentally I don't see what the difference is between doing a lossy conversion implicitly and doing it explicitly. The arguments for and against are the same either way.</p>\n<p>If lossy conversion is OK then we can do that today. No need to wait or mess about detecting the code page. If lossy conversion is not OK today then I'm not sure what changes by making that conversion implicit?</p>",
        "id": 275129555,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647140462
    },
    {
        "content": "<p>WRT implicitness vs. explicitness here, I don't have a strong opinion on which option to take, but I do think it'd be helpful to clarify with alternate terminology a la @withoutboats' <a href=\"https://boats.gitlab.io/blog/post/2017-12-27-things-explicit-is-not/\">\"Not Explicit\" blog post</a>.</p>",
        "id": 275130219,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1647141569
    },
    {
        "content": "<p>By \"implicit\" I simply mean that the OS calls the equivalent of String::from_utf16_lossy for us. Whereas by \"explicit\" I mean that the stdlib implementation has to actually type out String::from_utf16_lossy itself.</p>",
        "id": 275130792,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647142542
    },
    {
        "content": "<p>I do not currently see any real difference between the two.</p>",
        "id": 275130845,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647142625
    },
    {
        "content": "<p>IMO that would fit under the \"Explicit is not local\" section in the blog post. IIUC you're effectively stating that you don't see _local_ indicators of encoding conversion as valuable as something else. Sounds like a valid opinion to me.</p>\n<p>Is that to avoid being burdensome for <code>std</code> maintainers specifically?</p>\n<p>When you say \"no difference\", do you mean for <code>std</code> maintainers, for users of <code>std</code>, both, or some other audience(s)?</p>",
        "id": 275131644,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1647144006
    },
    {
        "content": "<p>I mean in effect. Doing a lossy conversion has the same effect however it is done.</p>",
        "id": 275132090,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647144605
    },
    {
        "content": "<p>Currently we do not do lossy conversions so switching to lossy has an effect. But how that change is implemented does not, IMHO.</p>",
        "id": 275132167,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647144763
    },
    {
        "content": "<p>does windows actually use WTF-8? if you have a file with an unpaired surrogate as the name, do the *A APIs just return an error?</p>",
        "id": 275133529,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647147206
    },
    {
        "content": "<p>No they do a lossy conversion to/from UTF-16</p>",
        "id": 275133605,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647147327
    },
    {
        "content": "<p>How specifically do they do that, though?  Windows usually takes WTF-16, not actually UTF-16, because its UCS2 history means it doesn't enforce surrogate pairing.</p>",
        "id": 275140722,
        "sender_full_name": "scottmcm",
        "timestamp": 1647158886
    },
    {
        "content": "<p>I'm curious about that as well; how does Windows handle bad UTF-16 internally? Does it just not do any validation?</p>",
        "id": 275157468,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647182101
    },
    {
        "content": "<p>Yes, it doesn't do any validation. The whole UCS-2 thing is a bit of a red herring in this. It's UTF-16 but the kernel itself doesn't do checks. It didn't check for valid UCS-2 either back when that was a thing.</p>",
        "id": 275159812,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647184903
    },
    {
        "content": "<p>Yes, you are strongly encouraged to only <em>give</em> UTF-16 to Windows, but at the same time be ready to <em>take</em> any sequence of <code>u16</code> data. In some cases you need to just keep that value and pass it back at the correct time (eg: a file name) and so it doesn't really matter that it's not well formed UTF-16 data anyway. If you need to display it to the user, unfortunately \"that's your problem\", because if you replace the bad <code>u16</code> pairs with the unknown character (for example) then you're not showing them the actual file name that had the problem. Then again one might also call that a rare enough occurrence that you just don't worry about it.</p>",
        "id": 275185927,
        "sender_full_name": "Lokathor",
        "timestamp": 1647221399
    },
    {
        "content": "<p>Yeah, to be clear I'm not meaning to argue for or against making a change here, just to make it clear that using the <code>A</code> functions (with the UTF-8 code page) isn't a silver bullet. It's no different from doing lossy conversions using the <code>W</code> functions.</p>\n<p>Personally I've gone back and forth on the UTF-8 issue myself. On the one hand it would certainly make life easier for everyone if we only used valid unicode. On the other hand, it would mean someone could (if they misused the <code>W</code> apis) create a file that the Rust stdlib can't open. On the third hand, it is fairly common for software to be unable to handle such paths. Especially cross platform software.</p>",
        "id": 275186117,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647221670
    },
    {
        "content": "<p>It's also fairly common for software to have UB, but we try our best to rise above that ;3</p>",
        "id": 275187735,
        "sender_full_name": "Lokathor",
        "timestamp": 1647224237
    },
    {
        "content": "<p>ha, true.</p>",
        "id": 275187799,
        "sender_full_name": "Chris Denton",
        "timestamp": 1647224316
    },
    {
        "content": "<p>We just need another string type for properly supported utf16. Because rust doesn't have enough string types in its standard library.</p>",
        "id": 275187826,
        "sender_full_name": "Lokathor",
        "timestamp": 1647224401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/275124570\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/275121046\">said</a>:</p>\n<blockquote>\n<p>(Also of note is that some parts of User32 (which the stdlib likely doesn't interact with, but might) will remember if your program uses the A or W variant and then other functions that don't even have A/W variants will still be affected by your previous choice.)</p>\n</blockquote>\n<p>Details on that, if you have them?</p>\n</blockquote>\n<p>The most obvious sign of this is the existence of <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-iswindowunicode\"><code>IsWindowUnicode</code></a>, and the fact that interacting with HWNDs with a mixture of *A and *W fns is a recipe for pain and suffering and corruption</p>",
        "id": 275188309,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1647225051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/275140722\">said</a>:</p>\n<blockquote>\n<p>How specifically do they do that, though?  Windows usually takes WTF-16, not actually UTF-16, because its UCS2 history means it doesn't enforce surrogate pairing.</p>\n</blockquote>\n<p>Varies by API and OS version.  Internally, windows will be heavily leaning on:<br>\n<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-multibytetowidechar\"><code>MultiByteToWideChar</code></a><br>\n<a href=\"https://docs.microsoft.com/en-us/windows/win32/api/stringapiset/nf-stringapiset-widechartomultibyte\"><code>WideCharToMultiByte</code></a><br>\nboth of which have flags which let you opt-in to conversion errors instead of <code>U+FFFD</code> placeholders:<br>\n<code>MB_ERR_INVALID_CHARS</code><br>\n<code>WC_ERR_INVALID_CHARS</code><br>\nwhich when used, will result in failing with:<br>\n<code>ERROR_NO_UNICODE_TRANSLATION</code><br>\nnote from the errata of those functions that on e.g. 2k/XP, MultiByteToWideChar can simply <em>drop</em> the invalid codepoints without placeholders if you're not using the flag.</p>",
        "id": 275188579,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1647225440
    },
    {
        "content": "<p>also, <code>WC_ERR_INVALID_CHARS</code>:</p>\n<blockquote>\n<p>... only applies when CodePage is specified as CP_UTF8 or 54936. It cannot be used with other code page values.</p>\n</blockquote>",
        "id": 275188639,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1647225505
    },
    {
        "content": "<p>On the plus side, <code>U+FFFD</code> is the same replacement character that Rust uses, so at least that would line up</p>",
        "id": 275188660,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1647225579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replace.20.60AsRef.3CPath.3E.60.20with.20a.20new.20trait.3F/near/275187826\">said</a>:</p>\n<blockquote>\n<p>We just need another string type for properly supported utf16. Because rust doesn't have enough string types in its standard library.</p>\n</blockquote>\n<p>If I needed an existing type today, <a href=\"https://docs.rs/widestring/latest/widestring/ucstring/struct.UCString.html\"><code>widestring::U16CString</code></a>.  When I checked out 0.4.x the handling of <code>\\0</code>s was a bit muddled, but my issue about that was mentioned in refactoring and then closed, and 0.5.x is out, so I should revisit the crate to refresh my opinion on that... &lt;<a href=\"https://github.com/starkat99/widestring-rs/issues/18\">https://github.com/starkat99/widestring-rs/issues/18</a>&gt;</p>",
        "id": 275189121,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1647226251
    },
    {
        "content": "<p>Just do <code>BasicStr</code>/<code>BasicString</code>/<code>BasicCStr</code>/<code>BasicCString</code> at this point.</p>",
        "id": 275189377,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647226654
    },
    {
        "content": "<p>For the lowest hanging fruit to misinterpret your window text by mixing A and W fns without a single compile-time type error:</p>\n<ul>\n<li><code>RegisterClassExW</code> a class that uses <code>DefWindowProcA</code> by default or as a fallback</li>\n<li><code>CreateWindowEx{A,W}</code> or <code>SetWindowText{A,W}</code> will (re-)encode the window title as UTF16 to match the hwnd/class.</li>\n<li><code>DefWindowProcA</code> will try to read the window title as UTF8 (despited the passed hwnd being 'unicode'), likely truncating the title after the first character.</li>\n</ul>",
        "id": 275191003,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1647229074
    },
    {
        "content": "<p>Additionally, note that <code>GetMessage{A,W}</code> and <code>DispatchMessage{A,W}</code>, despite being differentiated into ANSI vs UNICODE, will handle messages like <code>WM_SETTEXT</code> and <code>WM_GETTEXT</code> bearing strings or target buffers as their <code>lparams</code> which will be encoded based on their target hwnd class unicodeishness, which isn't necessairly the same as the encoding the function name would imply</p>",
        "id": 275191152,
        "sender_full_name": "MaulingMonkey",
        "timestamp": 1647229286
    }
]