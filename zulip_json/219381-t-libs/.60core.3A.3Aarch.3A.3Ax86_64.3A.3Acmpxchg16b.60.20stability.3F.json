[
    {
        "content": "<p>So, <code>cmpxchg16b</code> has been unstable for a while: <a href=\"https://doc.rust-lang.org/nightly/core/arch/x86_64/fn.cmpxchg16b.html\">https://doc.rust-lang.org/nightly/core/arch/x86_64/fn.cmpxchg16b.html</a></p>\n<p>I always assumed it was a decision about not wanting the only access to 128 bit atomics be through a platform intrinsic, but <a href=\"https://github.com/rust-lang/stdarch/issues/827\">https://github.com/rust-lang/stdarch/issues/827</a> indicates that perhaps it was actually just forgotten (or is this deliberate, and decision just happened elsewhere?)</p>\n<p>Either way, with <code>asm!</code> perhaps stabilizing soon, it seems a little silly for this to remain unstable as well, given that inline assembly provides access to this functionality anyway, but in a more annoying to use form (substantially so â€” u128 is not exactly easily used in <code>asm!</code>).</p>\n<p>Do people feel warmly towards stabilizing this? If so, what would the path be towards that?</p>",
        "id": 264394588,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1639101713
    },
    {
        "content": "<p>I think it'd be appropriate to stabilize this. If someone posted a stabilization PR, I'd be happy to FCP it.</p>",
        "id": 264403146,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639112062
    },
    {
        "content": "<p>So that PR would be against... rust-lang/stdarch (since that's where the definition lives)?</p>",
        "id": 266615111,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641131403
    },
    {
        "content": "<p>(This (and vacation) has been most of why I've not filed one yet)</p>",
        "id": 266615131,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641131430
    },
    {
        "content": "<p>RE. stabilizing <code>Atomic{U,I}128</code>, wouldn't that bear a problem of not being an architecturally available atomic (since it depends on a target feature)? So it still wouldn't be available on x86_64, unless rustc (or others) adds support for the SysV architecture levels for x86_64 (x86_64v2 does require the cmpxchg16b feature by default), and then only on those targets. <br>\nThis is, at least, the reasoning I used in lccc, which doesn't indicate 16-byte lock-free atomic support for x86_64 (See &lt;<a href=\"https://github.com/LightningCreations/lccc/blob/1c39bb370a1df223fa9d3c88f4610abdb31c6667/xlang/xlang_targets/src/properties/x86.rs#L151\">https://github.com/LightningCreations/lccc/blob/1c39bb370a1df223fa9d3c88f4610abdb31c6667/xlang/xlang_targets/src/properties/x86.rs#L151</a>&gt;).</p>",
        "id": 266619178,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641137736
    },
    {
        "content": "<blockquote>\n<p>unless rustc (or others) adds support for the SysV architecture levels for x86_64</p>\n</blockquote>\n<p>That's already supported. <code>-Ctarget-cpu=x86-64-v2</code></p>",
        "id": 266624871,
        "sender_full_name": "The 8472",
        "timestamp": 1641145467
    },
    {
        "content": "<p>but that leaves the problem that <code>cmpxchg16b</code> is a relatively poor way to do 128bit atomics when you don't have 128bit loads and stores.</p>",
        "id": 266624988,
        "sender_full_name": "The 8472",
        "timestamp": 1641145647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F/near/266624871\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>unless rustc (or others) adds support for the SysV architecture levels for x86_64</p>\n</blockquote>\n<p>That's already supported. <code>-Ctarget-cpu=x86-64-v2</code></p>\n</blockquote>\n<p>That wouldn't use it architecturally, though, only the CPU features mandated by the ABI.</p>",
        "id": 266625047,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641145694
    },
    {
        "content": "<p>By architecturally you mean llvm being able to turn the 128bit atomic ops into cmpxchg16b?</p>",
        "id": 266625210,
        "sender_full_name": "The 8472",
        "timestamp": 1641145949
    },
    {
        "content": "<p><code>AtomicU128</code> and <code>AtomicI128</code> can only exist if the target spec said that 128bit atomics are supported while compiling libcore.</p>",
        "id": 266627109,
        "sender_full_name": "bjorn3",
        "timestamp": 1641148763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F/near/266615111\">said</a>:</p>\n<blockquote>\n<p>So that PR would be against... rust-lang/stdarch (since that's where the definition lives)?</p>\n</blockquote>\n<p>Erm, sorry, to be clear: this is a question. I thought stabilization PRs were supposed to be against rust-lang/rust, but the code that stabilizes this doesn't live there. Is that okay?</p>",
        "id": 266629907,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1641152998
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60core.3A.3Aarch.3A.3Ax86_64.3A.3Acmpxchg16b.60.20stability.3F/near/266627109\">said</a>:</p>\n<blockquote>\n<p><code>AtomicU128</code> and <code>AtomicI128</code> can only exist if the target spec said that 128bit atomics are supported while compiling libcore.</p>\n</blockquote>\n<p>That's what I thought of rustc. That's currently true of lccc as well, as my plan was only to query the lock-free atomic mask in the target properties when setting <code>target_has_atomic</code>.</p>",
        "id": 266631744,
        "sender_full_name": "Connor Horman",
        "timestamp": 1641155740
    }
]