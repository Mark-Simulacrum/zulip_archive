[
    {
        "content": "<p><code>std::slice::IterMut</code> seems to lack an <code>as_mut_slice</code> method like the ones in <code>std::array::IntoIter</code>, <code>std::vec::IntoIter</code> ecc ecc. Without it the only way to \"reborrow\" an <code>IterMut</code> is by calling <code>into_slice</code> and then manually restoring it after using that slice. This requires a bunch of boilerplace, is error prone, and is probably more limiting than it should be. </p>\n<p>The implementation should look something like this (plus stability attributes):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">IterMut</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">as_mut_slice</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">from_raw_parts_mut</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">AsMut</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">IterMut</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">as_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">as_mut_slice</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>For consistency an <code>AsMut&lt;[T]&gt;</code> implementation is also provided to match the current implementation of <code>AsRef&lt;[T]&gt;</code>.</p>",
        "id": 268519440,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1642588502
    },
    {
        "content": "<p>feel free to send a PR or open an issue for it :)</p>",
        "id": 268533871,
        "sender_full_name": "Mara",
        "timestamp": 1642596782
    },
    {
        "content": "<p>Currently working on it, I can't decide how to handle the stability attributes. I feel like I should mark <code>as_mut_slice</code> as unstable, but I can't do that for the implementation of <code>AsMut&lt;[T]&gt;</code> since trait implementations are insta-stable. Do I also make <code>as_mut_slice</code> insta-stable? Or should I wait implementing <code>AsMut&lt;[T]&gt;</code> until <code>as_mut_slice</code> is stabilized?</p>",
        "id": 268542686,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1642600775
    },
    {
        "content": "<p>you can put a comment next to the unstable attribute that we should uncomment/add the AsMut impl when the feature gets stabilized.</p>",
        "id": 268549806,
        "sender_full_name": "Mara",
        "timestamp": 1642603753
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/rust-lang/rust/issues/93079\">#93079</a> and <a href=\"https://github.com/rust-lang/rust/issues/93080\">#93080</a></p>",
        "id": 268559247,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1642607516
    },
    {
        "content": "<p>I vaguely remember that there was some reason we didn't have this, but I only found my own comment suggesting that we <em>could</em> add it, but nobody asked for it. But it wasn't blocked or refuted either.<br>\n<a href=\"https://github.com/rust-lang/rust/pull/58924#issuecomment-469469159\">https://github.com/rust-lang/rust/pull/58924#issuecomment-469469159</a></p>",
        "id": 268561404,
        "sender_full_name": "cuviper",
        "timestamp": 1642608307
    },
    {
        "content": "<p>It should also be noted that <code>array::IntoIter</code> and <code>vec::IntoIter</code> also have an <code>as_mut_slice</code> method, but others like <code>vec::Drain</code> don't</p>",
        "id": 268593073,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1642621402
    },
    {
        "content": "<p>Drain is less commonly used so I guess it's less important to have that. Plus it's internal complexity is higher compared to other iterators.</p>",
        "id": 268593708,
        "sender_full_name": "The 8472",
        "timestamp": 1642621720
    },
    {
        "content": "<p>The weird thing about drain is that it holds a <code>slice::Iter&lt;'a, T&gt;</code>, not <code>IterMut</code>, so <code>as_mut_slice</code> would need unsafe code</p>",
        "id": 268594263,
        "sender_full_name": "cuviper",
        "timestamp": 1642622011
    },
    {
        "content": "<p>I'm not sure off-hand why it does that -- maybe for variance?</p>",
        "id": 268594280,
        "sender_full_name": "cuviper",
        "timestamp": 1642622022
    },
    {
        "content": "<p>But if nobody is asking for <code>Drain::as_mut_slice</code>, let's not worry about it</p>",
        "id": 268594773,
        "sender_full_name": "cuviper",
        "timestamp": 1642622205
    },
    {
        "content": "<p>Still means you need to argue against occasional demands for consistency for its own sake :P</p>",
        "id": 268595236,
        "sender_full_name": "The 8472",
        "timestamp": 1642622407
    },
    {
        "content": "<p>actually, thinking more -- if <code>Drain</code> has variance in <code>T</code>, we <strong>should not</strong> have <code>as_mut_slice</code>, because <code>&amp;mut [T]</code> is invariant in T</p>",
        "id": 268603965,
        "sender_full_name": "cuviper",
        "timestamp": 1642626634
    },
    {
        "content": "<p>i.e. we don't want <code>Drain</code> to be a way to smuggle variance</p>",
        "id": 268604081,
        "sender_full_name": "cuviper",
        "timestamp": 1642626715
    },
    {
        "content": "<p>it has a <code>nonnull&lt;Vec&lt;T&gt;&gt;</code> field so I <em>suspect</em> that means it's invariant anyway? I always need to double check this to be confident though</p>",
        "id": 268604198,
        "sender_full_name": "simulacrum",
        "timestamp": 1642626775
    },
    {
        "content": "<p><code>NonNull</code> is explicitly covariant</p>",
        "id": 268604242,
        "sender_full_name": "cuviper",
        "timestamp": 1642626810
    },
    {
        "content": "<p>ah, ok -- well, I said I should check :)</p>",
        "id": 268604277,
        "sender_full_name": "simulacrum",
        "timestamp": 1642626828
    },
    {
        "content": "<p>afaict <code>Drain</code> is covariant in <code>T</code>: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b9d59ce1e1d695e5c576d8e8d8ef5bc4\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=b9d59ce1e1d695e5c576d8e8d8ef5bc4</a></p>",
        "id": 268607142,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1642628365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60std.3A.3Aslice.3A.3AIterMut.3A.3Aas_mut_slice.60/near/268603965\">said</a>:</p>\n<blockquote>\n<p>actually, thinking more -- if <code>Drain</code> has variance in <code>T</code>, we <strong>should not</strong> have <code>as_mut_slice</code>, because <code>&amp;mut [T]</code> is invariant in T</p>\n</blockquote>\n<p>Does that actually matter? <code>Drain</code> owns all the <code>T</code>s it would expose in that <code>&amp;mut [T]</code>.</p>",
        "id": 268608254,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1642628947
    },
    {
        "content": "<p>In other words, even if someone coerces the <code>Drain&lt;T&gt;</code> into a <code>Drain&lt;U&gt;</code> (where <code>U</code> is a subtype of <code>T</code>) and an <code>&amp;mut [U]</code> is created from that, only the <code>Drain&lt;U&gt;</code> will care about those <code>U</code>s, nobody that still remembers <code>T</code> can access them.</p>",
        "id": 268608766,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1642629214
    },
    {
        "content": "<p>hmm, only if that coercion is a one-way trip</p>",
        "id": 268613380,
        "sender_full_name": "cuviper",
        "timestamp": 1642631548
    },
    {
        "content": "<p>maybe that's ok, because you can't coerce <code>&amp;mut Drain&lt;T&gt;</code> to <code>&amp;mut Drain&lt;U&gt;</code></p>",
        "id": 268613415,
        "sender_full_name": "cuviper",
        "timestamp": 1642631583
    },
    {
        "content": "<p>and if you coerce by ownership, that is one-way</p>",
        "id": 268613462,
        "sender_full_name": "cuviper",
        "timestamp": 1642631624
    },
    {
        "content": "<p>Yep, <code>Drain</code> <em>owns</em> its elements (a <code>Drain&lt;'_, T&gt;</code> actually acts like a <code>&amp;'_ own [T]</code>), hence why covariance is fine. Then, as an owning collection, it can be <code>&amp;mut</code> transitive to the items it owns.</p>",
        "id": 268627706,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642641102
    }
]