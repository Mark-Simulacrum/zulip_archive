[
    {
        "content": "<p>A question for all of <span class=\"user-group-mention\" data-user-group-id=\"2645\">@T-libs-api</span>, <span class=\"user-group-mention\" data-user-group-id=\"4493\">@T-libs</span>, and everyone else who has an opinion on this:</p>\n<ul>\n<li>What is the standard library, or what should it be? That is, what kind of things should be part of it, and what shouldn't? What purpose does it have, and what purpose should it not have?</li>\n</ul>\n<p>We talked a bit about it during the meetings today, but it seems everyone has their own slightly different view on this topic. I'm curious to hear all the perspectives in a bit more detail. Overall there seems to be some consensus that e.g. 'arrayvec' should be in std (or core), while e.g. http parsing should not be. But many things fall in the gray area inbetween; for example mpmc channels. I'm curious to find the line between those and maybe define it a bit more clearly, if we can.</p>\n<p>‚Üí Can y'all give examples of where this border is for you? Examples of things that should and should not be in the standard library, and examples of things where the line starts to get blurry?</p>",
        "id": 254442108,
        "sender_full_name": "Mara",
        "timestamp": 1632346002
    },
    {
        "content": "<p>core/alloc should prioritize code that requires unsafe to implement. This means data structures, atomics, etc.</p>\n<p>std should do that and also include as much as possible to not have to deal with the OS. This means the file system, a time source  a randomness source, etc.</p>",
        "id": 254442809,
        "sender_full_name": "Lokathor",
        "timestamp": 1632346384
    },
    {
        "content": "<p>Not member of either team, but I consider <code>core</code> to be better at being a good <code>std</code> than libstd is. My benchmark for a good standard library is when people don't see a need to implement an alternative way to do something that the <code>std</code> provides. (this of course makes an implementation of <code>std</code> becoming bad inevitable over time, its only a question of what timescale we are talking about)</p>",
        "id": 254442971,
        "sender_full_name": "nagisa",
        "timestamp": 1632346456
    },
    {
        "content": "<p>One sticking point for me is cap-std, for example.</p>",
        "id": 254443054,
        "sender_full_name": "nagisa",
        "timestamp": 1632346502
    },
    {
        "content": "<p>I think it was Scott who once made the point that the prelude favors small modules/programs. The standard library is an extension of that. What's in the standard library is easier for small programs to do without having to look for the right dep and decide to trust it.</p>\n<p>So I actually don't care at all if the std filesystem api is perfect, it should instead be easy to use (and it's not really). I don't care if the MPSC in std is the fastest, because it's already there and I can understand it in like 2 example code blocks.</p>",
        "id": 254443217,
        "sender_full_name": "Lokathor",
        "timestamp": 1632346587
    },
    {
        "content": "<p>My concern is reliable code first and easy to implement second, personally, which might be misguided in some way, but reliability is why I use Rust in the first place.</p>",
        "id": 254443326,
        "sender_full_name": "nagisa",
        "timestamp": 1632346660
    },
    {
        "content": "<p>Socket APIs seem blurry. The parts that already are in std look obvious and yet they're not enough. We have socket2, the open PRs to get cmsg wrappers in std and various async libraries since the standard methods are only blocking and we don't even have an epoll wrapper in std.</p>",
        "id": 254443394,
        "sender_full_name": "The 8472",
        "timestamp": 1632346683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254442971\">said</a>:</p>\n<blockquote>\n<p>Not member of either team, but I consider <code>core</code> to be better at being a good <code>std</code> than libstd is. My benchmark for a good standard library is when people don't see a need to implement an alternative way to do something that the <code>std</code> provides. (this of course makes an implementation of <code>std</code> becoming bad inevitable over time, its only a question of what timescale we are talking about)</p>\n</blockquote>\n<p>I do agree with this. I want to be sure the API doesn't have to make opinionated choices that people may disagree with; instead, I want to make sure that if std has an API it's the <em>obvious</em> choice.</p>",
        "id": 254443413,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632346689
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254443394\">said</a>:</p>\n<blockquote>\n<p>Socket APIs seem blurry. The parts that already are in std look obvious and yet they're not enough. We have socket2, the open PRs to get cmsg wrappers in std and various async libraries since the standard methods are only blocking and we don't even have an epoll wrapper in std.</p>\n</blockquote>\n<p>I'm hoping that we add async APIs once we get the infrastructure and traits for those sorted.</p>",
        "id": 254443443,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632346704
    },
    {
        "content": "<p>I think \"easy to implement\" and \"reliability\" are not entirely opposed.<br>\nI think a goal for Rust's std should be that code that relies on it does not feel <strong>brittle</strong>.</p>",
        "id": 254443500,
        "sender_full_name": "Jubilee",
        "timestamp": 1632346739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254443500\">said</a>:</p>\n<blockquote>\n<p>I think \"easy to implement\" and \"reliability\" are not entirely opposed.<br>\nI think a goal for Rust's std should be that code that relies on it does not feel <strong>brittle</strong>.</p>\n</blockquote>\n<p>Good point, and what I was trying to say (poorly). I think there are a couple of APIs (the beforementioned filesystem API comes to mind, again) which I consider to be easy find brittle.</p>",
        "id": 254443681,
        "sender_full_name": "nagisa",
        "timestamp": 1632346829
    },
    {
        "content": "<p>I think std should only contain things that most programs will use. Ideally things like async APIs would live in another crate (but ideally still in sysroot)</p>",
        "id": 254443731,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632346869
    },
    {
        "content": "<p>what's the advantage of that?</p>",
        "id": 254443742,
        "sender_full_name": "Lokathor",
        "timestamp": 1632346883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254443054\">said</a>:</p>\n<blockquote>\n<p>One sticking point for me is cap-std, for example.</p>\n</blockquote>\n<p>Would adding openat&amp;co. on <code>ReadDir</code> solve that to some extent?</p>",
        "id": 254444037,
        "sender_full_name": "The 8472",
        "timestamp": 1632347064
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span>  For example, arch intrinsics aren't used by most programs. In fact they're used by almost no programs as a percentage. But does having that sorted in an <code>arch_intrinsics</code> crate we ship not in <code>core</code> but along side <code>core</code> particularly help with anything? It seems simpler to just have things in fewer separate crates.</p>",
        "id": 254444096,
        "sender_full_name": "Lokathor",
        "timestamp": 1632347107
    },
    {
        "content": "<p>gonna make that percentage even smaller <span aria-label=\"smiling imp\" class=\"emoji emoji-1f608\" role=\"img\" title=\"smiling imp\">:smiling_imp:</span></p>",
        "id": 254444160,
        "sender_full_name": "Jubilee",
        "timestamp": 1632347143
    },
    {
        "content": "<p>The only reason I see for having other crates is if they'd have a slightly more relaxed versioning policy than std. major version bump when enough demand for breaking changes has accumulated and the old version goes into bugfix-only mode. But still rust-org blessed.</p>",
        "id": 254444461,
        "sender_full_name": "The 8472",
        "timestamp": 1632347295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254444096\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span>  For example, arch intrinsics aren't used by most programs. In fact they're used by almost no programs as a percentage. But does having that sorted in an <code>arch_intrinsics</code> crate we ship not in <code>core</code> but along side <code>core</code> particularly help with anything? It seems simpler to just have things in fewer separate crates.</p>\n</blockquote>\n<p>I think intrinsics are quite special since they require special handling of the compiler. But async IO are not that special.</p>",
        "id": 254444478,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632347306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254444461\">said</a>:</p>\n<blockquote>\n<p>The only reason I see for having other crates is if they'd have a slightly more relaxed versioning policy than std. major version bump when enough demand for breaking changes has accumulated and the old version goes into bugfix-only mode. But still rust-org blessed.</p>\n</blockquote>\n<p>I think this is a pretty big pro.</p>",
        "id": 254444626,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632347385
    },
    {
        "content": "<p>I'm not sure it is. We're fine with having no regex in std and know everyone will use the crate.</p>",
        "id": 254444719,
        "sender_full_name": "The 8472",
        "timestamp": 1632347416
    },
    {
        "content": "<p>regex doesn't require unsafe to implement or exist as an OS/Target abstraction, so i wouldn't propose it for the standard library, myself</p>",
        "id": 254444956,
        "sender_full_name": "Lokathor",
        "timestamp": 1632347538
    },
    {
        "content": "<p>Ah I am confused. Regex is an argument supporting a small std, isn't it?</p>",
        "id": 254445029,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632347584
    },
    {
        "content": "<p>yes. I'm not seeing that much turf that can be covered by official but slightly-less-stable crates. an async runtime maybe since that's complex and OS concepts change every decade or so.</p>",
        "id": 254445183,
        "sender_full_name": "The 8472",
        "timestamp": 1632347653
    },
    {
        "content": "<p>fwiw shipping libstdc++ seems to make smaller distros unhappy and so does Rust's std.</p>",
        "id": 254445234,
        "sender_full_name": "Jubilee",
        "timestamp": 1632347682
    },
    {
        "content": "<p>in which way? keeping up with the release cycle?</p>",
        "id": 254445322,
        "sender_full_name": "The 8472",
        "timestamp": 1632347732
    },
    {
        "content": "<p>Yes but also because of the tight coupling between std and rustc.</p>",
        "id": 254445642,
        "sender_full_name": "Jubilee",
        "timestamp": 1632347882
    },
    {
        "content": "<p>It makes managing std and rustc a lot harder when they are, for all intents and purposes, \"the same thing\", even though they kinda aren't.</p>",
        "id": 254445805,
        "sender_full_name": "Jubilee",
        "timestamp": 1632347953
    },
    {
        "content": "<p>should we prioritize this concern? well... maybe not? but it has been mentioned that the tight coupling is <strong>also</strong> off-putting to would-be contributors. it requires the specialized build system.</p>",
        "id": 254445961,
        "sender_full_name": "Jubilee",
        "timestamp": 1632348012
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254444037\">said</a>:</p>\n<blockquote>\n<p>Would adding openat&amp;co. on <code>ReadDir</code> solve that to some extent?</p>\n</blockquote>\n<p>I don't believe so. The existence of path-centric APIs in the first place is what makes the filesystem APIs provided by the standard library feel brittle, and either way this is just a single pet-peeve that I have. There are more problems such as allocation as recently pointed out by the linux kernel devs.</p>",
        "id": 254445971,
        "sender_full_name": "nagisa",
        "timestamp": 1632348014
    },
    {
        "content": "<p>Obviously, because e.g. libcore is <strong>very</strong> tightly coupled with rustc, we can't necessarily get away from this. Certainly not <strong>all</strong> the way away.</p>",
        "id": 254446443,
        "sender_full_name": "Jubilee",
        "timestamp": 1632348207
    },
    {
        "content": "<p>Though I think we can agree that <em>some form</em> of allocation goes in the standard library. We just have a questionable convention about how it works.</p>",
        "id": 254446464,
        "sender_full_name": "Lokathor",
        "timestamp": 1632348217
    },
    {
        "content": "<p>Of course.</p>",
        "id": 254446537,
        "sender_full_name": "nagisa",
        "timestamp": 1632348242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> isn't the biggest problem generics?</p>",
        "id": 254446644,
        "sender_full_name": "Lokathor",
        "timestamp": 1632348295
    },
    {
        "content": "<p>and ABI as well i suppose</p>",
        "id": 254446677,
        "sender_full_name": "Lokathor",
        "timestamp": 1632348310
    },
    {
        "content": "<p>I am not 100% on that.</p>",
        "id": 254446703,
        "sender_full_name": "Jubilee",
        "timestamp": 1632348319
    },
    {
        "content": "<p>I will have to pick Ariadne's brain at some time.</p>",
        "id": 254446732,
        "sender_full_name": "Jubilee",
        "timestamp": 1632348333
    },
    {
        "content": "<p>To get back to the question: I think the phrase \"Rust has a small standard library\" has never once made me happy when I encounter it. My personal experience is that it's the reason to not have nice things.</p>",
        "id": 254447188,
        "sender_full_name": "Lokathor",
        "timestamp": 1632348575
    },
    {
        "content": "<p>I think it's a good thing. It sends a clear signal to look elsewhere rather than trying to make do with whatever is there. Look at javascript, their core library is tiny and they still ended up with the ==, ===, <a href=\"http://Object.is\">Object.is</a> mess or hacking the iterator-like stuff onto Array.prototype.</p>",
        "id": 254447891,
        "sender_full_name": "The 8472",
        "timestamp": 1632348939
    },
    {
        "content": "<p>Speaking as an ECMAScripter:<br>\nThat is because JS does not have a good way to introduce non-breaking forward compatibility.</p>",
        "id": 254448042,
        "sender_full_name": "Jubilee",
        "timestamp": 1632349012
    },
    {
        "content": "<p>I think we have actually a lot of that problem already, though.</p>",
        "id": 254448057,
        "sender_full_name": "Jubilee",
        "timestamp": 1632349023
    },
    {
        "content": "<p>The dreams of using UCFS and auto-UCFS-driven compatibility fixes never materialized to prevent situations like <a href=\"https://github.com/rust-lang/rust/issues/88967\">https://github.com/rust-lang/rust/issues/88967</a> from emerging.</p>",
        "id": 254448210,
        "sender_full_name": "Jubilee",
        "timestamp": 1632349107
    },
    {
        "content": "<p>That was actually brought up in the libs meeting again. There were some concerns about that approach. I'm not sure if I understood them correctly. I think it was about lots of stuff breaking on cargo update? Or people building from source rather from <a href=\"http://crates.io\">crates.io</a> packages. Not sure.</p>",
        "id": 254448407,
        "sender_full_name": "The 8472",
        "timestamp": 1632349211
    },
    {
        "content": "<p>There are no \"inherent traits\" to allow the existing trait qualification syntaxes to fix situations like <a href=\"https://github.com/rust-lang/rust/issues/85667\">https://github.com/rust-lang/rust/issues/85667</a></p>",
        "id": 254448423,
        "sender_full_name": "Jubilee",
        "timestamp": 1632349221
    },
    {
        "content": "<p>And I am not saying we should not introduce these breakages, they are technically permitted, and we are currently at a stage w/r/t Rust where breaking half the ecosystem is still actually not the worst thing to do, heh.</p>",
        "id": 254448619,
        "sender_full_name": "Jubilee",
        "timestamp": 1632349336
    },
    {
        "content": "<p>Anyways, those are actually issues, IMO, where std was <strong>too</strong> conservative, and so large swathes of the ecosystem picked a library rather than std, even though std would have been the obvious choice for a home for the constant.</p>",
        "id": 254449064,
        "sender_full_name": "Jubilee",
        "timestamp": 1632349571
    },
    {
        "content": "<p>I don't think itertools is a good example here. It's a mix of niche functions and more commonly useful ones. And <code>Iterator</code> started small too, so as it grows some conflict is inevitable. Unless we want the types to spend a lot more time unstable until the API has grown.</p>",
        "id": 254449577,
        "sender_full_name": "The 8472",
        "timestamp": 1632349757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254448210\">said</a>:</p>\n<blockquote>\n<p>The dreams of using UCFS and auto-UCFS-driven compatibility fixes never materialized to prevent situations like <a href=\"https://github.com/rust-lang/rust/issues/88967\">https://github.com/rust-lang/rust/issues/88967</a> from emerging.</p>\n</blockquote>\n<p>UCFS driven compatibility fixes?</p>",
        "id": 254452959,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632351574
    },
    {
        "content": "<p>normalize function calls to their fully qualified form when publishing crates.</p>",
        "id": 254453613,
        "sender_full_name": "The 8472",
        "timestamp": 1632351863
    },
    {
        "content": "<p>aaah</p>",
        "id": 254453774,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632351928
    },
    {
        "content": "<p>well, regarding the responsibility of std</p>",
        "id": 254453822,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632351955
    },
    {
        "content": "<p>to me I think std is the place to export high quality, widely used, and completely stable APIs</p>",
        "id": 254453921,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632351988
    },
    {
        "content": "<p>to me that generally means that we should trend towards a smaller std since 3rd party crates have a lot more flexibility when it comes to API changes</p>",
        "id": 254454030,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632352060
    },
    {
        "content": "<p>well, wouldn't regex fit those criteria?</p>",
        "id": 254454354,
        "sender_full_name": "The 8472",
        "timestamp": 1632352231
    },
    {
        "content": "<p>the first two absolutely, the last point I'm not 100% confident about</p>",
        "id": 254454460,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632352295
    },
    {
        "content": "<p>for example, does regex already handle precompiling regular expressions via const fn?</p>",
        "id": 254454580,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632352358
    },
    {
        "content": "<p>I expect as const fn becomes more powerful that will be introduced</p>",
        "id": 254454617,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632352387
    },
    {
        "content": "<p>i'm not clear what you mean, because going from not-const fn to const fn is compatible</p>",
        "id": 254454687,
        "sender_full_name": "Lokathor",
        "timestamp": 1632352435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254453613\">said</a>:</p>\n<blockquote>\n<p>normalize function calls to their fully qualified form when publishing crates.</p>\n</blockquote>\n<p>I don't think that's possible with macros</p>",
        "id": 254454750,
        "sender_full_name": "cuviper",
        "timestamp": 1632352451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254454687\">said</a>:</p>\n<blockquote>\n<p>i'm not clear what you mean, because going from not-const fn to const fn is compatible</p>\n</blockquote>\n<p>I'm imagining something where the <code>new</code> method could return <code>Self</code> directly instead of a <code>Result&lt;Self, Error&gt;</code> and have invalid regular expressions produce compile time errors instead of runtime errors</p>",
        "id": 254454865,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632352522
    },
    {
        "content": "<p>just <code>Regex::new(\"pattern\").ok().unwrap()</code>, which will be totally stable by the time const trait impl stuff is stable, which is the major blocker</p>",
        "id": 254454980,
        "sender_full_name": "Lokathor",
        "timestamp": 1632352578
    },
    {
        "content": "<p>regardless, I'm not saying regex couldn't be something we can include</p>",
        "id": 254455165,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632352696
    },
    {
        "content": "<p>I'm also not against the idea, though it doesn't strictly meet the criteria I gave</p>",
        "id": 254455235,
        "sender_full_name": "Lokathor",
        "timestamp": 1632352746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254442809\">said</a>:</p>\n<blockquote>\n<p>core/alloc should prioritize code that requires unsafe to implement. This means data structures, atomics, etc.</p>\n<p>std should do that and also include as much as possible to not have to deal with the OS. This means the file system, a time source  a randomness source, etc.</p>\n</blockquote>\n<p>Regarding this, I don't agree that the unsafety of an implementation should have any bearing on if it should be included in std/core</p>",
        "id": 254455367,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632352819
    },
    {
        "content": "<p>I think that the ecosystem should not be called upon to use unsafe itself too often. I think that any individual crate gets a lot less eyeballs on it than the standard library.</p>",
        "id": 254456094,
        "sender_full_name": "Lokathor",
        "timestamp": 1632353306
    },
    {
        "content": "<p>I don't think that alone is sufficient justification, but I do agree that any sort of fundamental abstractions that drastically reduce the amount of unsafe code needed in 3rd party libraries may be worth additional consideration, though even then I feel like these abstractions should generally start as 3rd party crates</p>",
        "id": 254456707,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632353733
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254453921\">said</a>:</p>\n<blockquote>\n<p>to me I think std is the place to export high quality, widely used, and completely stable APIs</p>\n</blockquote>\n<p>The second point here I think commonly manifests as types that generally end up being exposed in other libraries APIs</p>",
        "id": 254458461,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632355049
    },
    {
        "content": "<p>Actually, regarding this question I think a good exercise might be to evaluate the APIs that are currently part of std and see if we can't identify how each API's inclusion was justified and identify patterns from that</p>",
        "id": 254458577,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632355125
    },
    {
        "content": "<p>Error comes to mind for me, I think its inclusion is justified by the need to have a shared trait for representing errors so they can be composed and iterated over when reporting errors, via the <code>source</code> method</p>",
        "id": 254458627,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632355179
    },
    {
        "content": "<p>That's much more your area than mine, and I don't want to tell you your business, but the fact that the <code>std::error::Error</code> trait has not one but two deprecated methods, and also has numerous ecosystem traits to improve the situation over the years, leads me to strongly think that \"completely stable\" is far from true.</p>",
        "id": 254472092,
        "sender_full_name": "Lokathor",
        "timestamp": 1632365214
    },
    {
        "content": "<p>Also the fact that you can always downcast an error into a Box, thus making the entire system locked away from people doing no_alloc, is a daggin shame</p>",
        "id": 254472351,
        "sender_full_name": "Lokathor",
        "timestamp": 1632365426
    },
    {
        "content": "<p>I think the deprecation is more because of the error trait being added to std too soon than a general pattern in the standard library</p>",
        "id": 254473900,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632366842
    },
    {
        "content": "<p>And the box thing is completely resolvable</p>",
        "id": 254473944,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632366850
    },
    {
        "content": "<p>And we're already moving the error trait into core</p>",
        "id": 254473949,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632366864
    },
    {
        "content": "<p>The real issues at the moment are with from&lt;&amp;str&gt; for box dyn error</p>",
        "id": 254473994,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632366914
    },
    {
        "content": "<p>Something like the error trait needs to exist and should be available from core as you say</p>",
        "id": 254474028,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632366949
    },
    {
        "content": "<p>Going back to the original question, \"what is the standard library?\", I would like to offer a slightly different view than a discussion between where the boundary between <code>core</code> and <code>std</code>.</p>\n<p>To me, a language's standard library plays two main roles. Its primary role is to provide a dependable foundation to build one's own software. Secondly, I believe that a standard library demonstrates best practices within a language community. I look to Rust's standard library as a model for my own work.</p>\n<p>I personally would feel comfortable with a larger standard library than what Rust currently offers. Coming from Python, with its very rich standard library makes Rust's feel rather austere. I know that this was intentional, and has the positive effects of creating a very vibrant 3rd party ecosystem. However, it would be nice if there was a workable base distribution of Rust to make it easier to work without connecting to <a href=\"http://crates.io\">crates.io</a>.</p>",
        "id": 254478160,
        "sender_full_name": "Tim McNamara",
        "timestamp": 1632370694
    },
    {
        "content": "<p>Seems like a question worth pondering‚Ä¶ I‚Äôll try collect my own thoughts into a gist. Maybe we should all try do something like a call for posts and collect them up?</p>",
        "id": 254485739,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1632377237
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/88989\">#88989</a> is another unclear case imo. It's not needed since <code>nix</code> already covers it and the methods don't need much supporting infrastructure that std is especially positioned to provide. Otoh you can find those in the standard libraries of many other languages.</p>",
        "id": 254563643,
        "sender_full_name": "The 8472",
        "timestamp": 1632414303
    },
    {
        "content": "<p>Random thoughts: I personally think for OS-related things it's not very useful to re-litigate the argument that the std should be more minimalist (even though I have a lot of sympathy for that argument). It isn't so here we are. I wouldn't want it to expand <em>too</em> much but it does cover a range of \"basic\" OS things (e.g. <code>File</code>, <code>Path</code>, <code>Command</code>, <code>env::*</code>, etc). I think it makes sense to make these as good as they can be (within the constraints of std) even if that involves some amount of \"feature creep\", i.e. adding novel APIs but I'm not exactly sure where the line is.</p>\n<p>This is just a knee-jerk reaction but I guess <a href=\"https://github.com/rust-lang/rust/issues/88989\">#88989</a> is somewhere near the border for me but probably falls on std side of it. It \"fits\" in the sense that it feels like it's within the scope of things std does and it's limited enough that there doesn't (atm) look like stabilizing  the API would be a problem. So, for me, I think the only question is if it's going to get enough use to justify being in the std. [DISCLAIMER: I'm not arguing for or against it being stabilized <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> ]</p>",
        "id": 254567549,
        "sender_full_name": "Chris Denton",
        "timestamp": 1632415995
    },
    {
        "content": "<p>yeah if we're going to have File <em>at all</em>, it should have all the methods a person would want.</p>\n<p>Particularly because methods are scoped to a type and you can't easily add additional method to a type in an external crate.</p>",
        "id": 254568411,
        "sender_full_name": "Lokathor",
        "timestamp": 1632416331
    },
    {
        "content": "<p>Huh? But that's what extension traits do? For file this would work fine since it exposes the file descriptor.</p>",
        "id": 254572671,
        "sender_full_name": "The 8472",
        "timestamp": 1632417971
    },
    {
        "content": "<p>I'd say \"easily\" is a load bearing word there. You have to make up a trait that you implement for just the one type, and then anywhere you use the thing you have to be sure to add an extra import for the trait. Extension traits are a necessary evil, a bandaid, they're not actually a good thing.</p>",
        "id": 254652967,
        "sender_full_name": "Lokathor",
        "timestamp": 1632461001
    },
    {
        "content": "<p>I think that (as with many other important things) there is no black and white answer and there are just a ton of difficult trade-offs. I'm sympathetic to the minimalist arguments, but I think that there is a huge advantage for beginners to have things like String, Vec, and Hashmap in std, even though it is difficult to justify that from first principals. If we accept those fundamental data structures (and similarly things like File and fs), then its hard to draw a principled line between those and more exotic data structures or IO primitives (including async ones). I'm somewhat sympathetic to the idea that things like Regex and Serde should be part of std, and I can even imagine a case for Tokio. I think there are many criteria one could apply (used by nearly all programs/programmers, only likely to have one implementation, stable implementation, part of the OS, ...) but at the end of the day there will always be a complex, multi-dimensional trade-off</p>",
        "id": 254693895,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1632485826
    },
    {
        "content": "<p>Tokio has too much of a design space yet unexplored. There is no common agreement about whether a tokio-like of async-std-like api makes more sense, there are many tradeoffs around the executor design AFAIK, ...</p>",
        "id": 254701470,
        "sender_full_name": "bjorn3",
        "timestamp": 1632489308
    },
    {
        "content": "<p>Yeah, I‚Äôm not seriously proposing it, but saying an argument could be made</p>",
        "id": 254710196,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1632492616
    },
    {
        "content": "<p>I strongly agree with Eliza on this:  <a href=\"https://twitter.com/mycoliza/status/1441075025562374154\">https://twitter.com/mycoliza/status/1441075025562374154</a><br>\nI think the Rust standard library should be unquestionably bigger but remain reserved.</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/mycoliza/status/1441075025562374154\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/850b7fef7fa746078748dc4a8a544f29fc9882f8/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313035373238343830343138303233383333372f4468777935756d705f6e6f726d616c2e6a7067\"></a><p>the really critical point here, i think, is that a lot of people make the mistake of thinking that a standard lib is for stuff that's *important*. it's not. it's for stuff that *has to be standardized*: <a href=\"https://t.co/uYZtoAfwjh\">https://twitter.com/mycoliza/status/1441069480847699970?s=20</a></p><span>- ìÉ≠ìáãìäÉìÑøìÅê (@mycoliza)</span></div></div>",
        "id": 254743810,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505405
    },
    {
        "content": "<p>I think we should not standardize an executor, for instance, because that is sort of \"beyond standardization\". Instead we should standardize more interfaces to async stuff, so async stuff has cleaner interop between libraries.</p>",
        "id": 254744209,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505566
    },
    {
        "content": "<p>I think Rust makes a good choice in terms of exotic data structures: by keeping the list minimal, each can have a high-quality impl that receives tons of maintenance, relatively speaking.</p>",
        "id": 254744809,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505815
    },
    {
        "content": "<p>By having one LinkedList, no one has to write their own... and they're infamously more annoying to write in Rust. And it gets a lot less eyes on it than anything else. I would really fear to add another data structure, because then the whole \"a thousand eyeballs\" premise would fall apart entirely, IMO. That idea has largely been disproven: it doesn't scale, because there can simply be too much API surface, and the convention can point so strongly the other way, that people don't actually explore all the functions and structures available. Everyone starts at Vec and goes down the list and then... etc.</p>",
        "id": 254744942,
        "sender_full_name": "Jubilee",
        "timestamp": 1632505879
    },
    {
        "content": "<blockquote>\n<p>By having one LinkedList, no one has to write their own</p>\n</blockquote>\n<p>i feel like linked list is the one ive reimplemented the most in rust, tbh (the stdlib one isnt intrusive and i'm unsure any of the designes for a generic intrusive linked list are sound)</p>",
        "id": 254746967,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632506679
    },
    {
        "content": "<p>(thats not to disagree with the rest of your point)</p>",
        "id": 254747198,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632506763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254744209\">said</a>:</p>\n<blockquote>\n<p>I think we should not standardize an executor, for instance, because that is sort of \"beyond standardization\". Instead we should standardize more interfaces to async stuff, so async stuff has cleaner interop between libraries.</p>\n</blockquote>\n<p>I don't think we should standardize The One True Executor, but I think we should standardize a minimal interface to executors, and provide a Good Enough Executor.</p>",
        "id": 254747672,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632506972
    },
    {
        "content": "<p>I think that'd be a key part of supporting <code>async fn main()</code> or <code>#[test] async fn test_xyz()</code>.</p>",
        "id": 254747814,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632507026
    },
    {
        "content": "<p>Providing one with a test harness might be an idea.</p>",
        "id": 254751764,
        "sender_full_name": "Jubilee",
        "timestamp": 1632508650
    },
    {
        "content": "<p>I do definitely want to leave room for other executors in the future, and not (for instance) close off the possibility of an <code>io_uring</code>-based executor.</p>",
        "id": 254753325,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509333
    },
    {
        "content": "<p>But I think a simple executor atop epoll or equivalent would be appropriate.</p>",
        "id": 254753387,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632509360
    },
    {
        "content": "<p>this touches on one of the justifications we settled on for including scoped threads in the library</p>",
        "id": 254754205,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632509673
    },
    {
        "content": "<p>in that we wanted to be able to use them in examples in our documentation / the book since they substantially simplify examples about multithreading in rust which is absolutely something we want to highlight</p>",
        "id": 254754292,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632509704
    },
    {
        "content": "<p>I imagine a similar justification could apply to have a minimal executor available for demonstrating the power of async in examples</p>",
        "id": 254754385,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632509741
    },
    {
        "content": "<p>I was under the impression that scoped threads are fairly \"obvious\" in a way that implementations will not differ radically so that you might as well include it since std has threads as an API.</p>",
        "id": 254792824,
        "sender_full_name": "Jubilee",
        "timestamp": 1632530279
    },
    {
        "content": "<p>That's another reason</p>",
        "id": 254793981,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632531253
    },
    {
        "content": "<p>But the usage in examples was the deciding factor for amanieu</p>",
        "id": 254793998,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632531269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254746967\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>By having one LinkedList, no one has to write their own</p>\n</blockquote>\n<p>i feel like linked list is the one ive reimplemented the most in rust, tbh (the stdlib one isnt intrusive and i'm unsure any of the designes for a generic intrusive linked list are sound)</p>\n</blockquote>\n<p>this makes another subtle point. probably \"we have the best <code>LinkedList&lt;T&gt;</code>\" is indeed what we are going to have to settle for. std isn't for deeply specialized code in most cases.</p>",
        "id": 254798825,
        "sender_full_name": "Jubilee",
        "timestamp": 1632535746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/219381-t-libs/topic/What.20is.20the.20standard.20library.3F/near/254754292\">said</a>:</p>\n<blockquote>\n<p>in that we wanted to be able to use them in examples in our documentation / the book since they substantially simplify examples about multithreading in rust which is absolutely something we want to highlight</p>\n</blockquote>\n<p>While I agree with that, I also think the \"this is tricky nuanced unsafe code that should only be written once\" applies particularly well for scope threads too.</p>",
        "id": 254977896,
        "sender_full_name": "scottmcm",
        "timestamp": 1632705466
    },
    {
        "content": "<p>For sure</p>",
        "id": 254977969,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632705526
    },
    {
        "content": "<p>but Jane you rejected that justification when I said it XD</p>",
        "id": 254986279,
        "sender_full_name": "Lokathor",
        "timestamp": 1632713082
    },
    {
        "content": "<p>Errr, yes</p>",
        "id": 254988292,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632714916
    },
    {
        "content": "<p>I finished writing up my thoughts on this: <a href=\"https://kodraus.github.io/rust/2021/09/27/what-is-std.html\">https://kodraus.github.io/rust/2021/09/27/what-is-std.html</a></p>\n<p>tl;dr: Basically in-line with Eliza's tweet</p>",
        "id": 254990353,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1632716623
    },
    {
        "content": "<p>I think we've got at least an intuitive sense of what belongs in or out of the standard library. What I think we don't really have yet are all the tools to cope with integrating changing paradigms and deprecations that are building up over time. The question for me is less about what goes in the standard library and more how the standard library is composed, delivered, and evolved going forward so it's still great and useful in another 7 years (and then 7 more after that)</p>",
        "id": 255132249,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1632782689
    }
]