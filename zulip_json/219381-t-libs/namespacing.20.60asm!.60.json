[
    {
        "content": "<p>One of the remaining unresolved questions for <code>asm!</code> stabilization is where it should live. FWIW, my opinion is that the current situation of most macros being effectively defined \"in the prelude\" is an unfortunate historical remnant that shouldn't be perpetuated with modern macro stabilizations (e.g. <code>std::ptr::addr_of!</code> does it right). At the very least I would be happy if <code>asm!</code> ended up at <code>std::arch::asm!</code>; whether or not to then include <code>asm!</code> in the prelude could be a separate decision. During the RFC, some people wanted to go even further and have <code>std::arch::x86::asm!</code>, <code>std::arch::arm::asm!</code>, etc. <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> , am I correct in thinking that even if <code>asm!</code> lived under arch-specific namespaces, that there would be <em>no</em> actual difference between any of them, and they would all delegate to the same internal implementation regardless of architecture? Which is to say, is the proposal for having architecture-specific <code>asm!</code> imports simply a roundabout lint to keep code from compiling on unanticipated platforms?</p>",
        "id": 233407632,
        "sender_full_name": "bstrie",
        "timestamp": 1617752201
    },
    {
        "content": "<p>One potential advantage of putting asm in <code>arch::x86_64</code> is that it could document any architecture-specific options/flags/examples/etc</p>",
        "id": 233407838,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1617752382
    },
    {
        "content": "<p>that would also make it more obvious which arches support <code>asm!</code>, since not all do -- and maybe some never will?</p>",
        "id": 233408163,
        "sender_full_name": "cuviper",
        "timestamp": 1617752635
    },
    {
        "content": "<p>that would imply that there are actually useful user-facing distinctions between <code>asm!</code> on different architectures, yes? I ask because there's nothing stopping the stdlib from having <em>both</em> <code>std::arch::x86::asm!</code> and <code>std::arch::asm!</code>, where the latter internally <code>cfg</code>s to the former when you're on X86, etc. <em>But</em>, the mere existence of <code>std::arch::asm!</code> would defeat the purpose if the goal is to <em>force</em> users to commit to specific archs for their code, a.k.a. the lint perspective</p>",
        "id": 233408208,
        "sender_full_name": "bstrie",
        "timestamp": 1617752649
    },
    {
        "content": "<p>I'm honestly not too worried about the lint side of things - I can't imagine anyone who's using <code>asm!</code> but isn't aware it's architecure specific</p>",
        "id": 233408296,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1617752723
    },
    {
        "content": "<p>well, I can probably imagine such a person exists, but that trip-up would be a valuable learning experience for them :P</p>",
        "id": 233408376,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1617752772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233408208\">said</a>:</p>\n<blockquote>\n<p>that would imply that there are actually useful user-facing distinctions between <code>asm!</code> on different architectures, yes?</p>\n</blockquote>\n<p>Besides the assembly code itself, there are also things like arch-specific register classes</p>",
        "id": 233408457,
        "sender_full_name": "cuviper",
        "timestamp": 1617752849
    },
    {
        "content": "<p>Yes, I'm talking about things aside from the assembly itself. :) Are arch-specific register classes implemented? I thought I recalled from the RFC that the goal was sort of a \"lowest common denominator\" design</p>",
        "id": 233408607,
        "sender_full_name": "bstrie",
        "timestamp": 1617752949
    },
    {
        "content": "<p>I know there was a discussion around handling x87 stack clobbers recently</p>",
        "id": 233408621,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1617752973
    },
    {
        "content": "<p>which would potentially involve an arch-specific flag to asm</p>",
        "id": 233408642,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1617752997
    },
    {
        "content": "<p>I haven't followed the implementation, but I see tests using <code>reg_abcd</code> at least</p>",
        "id": 233408704,
        "sender_full_name": "cuviper",
        "timestamp": 1617753013
    },
    {
        "content": "<p>looking at the intersection of supported architectures and modules under <code>std::arch</code>, it looks like new <code>std::arch::riscv</code> and <code>std::arch::hexagon</code> mods would need to be added. Any objections to that? (In particular I'm curious if RISC-V is homogenous enough for such a module to make sense; there are a lot of RISC-V target triples?)</p>",
        "id": 233410957,
        "sender_full_name": "bstrie",
        "timestamp": 1617754431
    },
    {
        "content": "<p>I'm not super familiar with riscv, but I think even if we did want separate modules it'd make sense to place them under a top-level <code>std::arch::riscv</code> module</p>",
        "id": 233411544,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1617754824
    },
    {
        "content": "<p>isn't there 32/64-bit RISC-V at least? we don't combine x86 for that...</p>",
        "id": 233411590,
        "sender_full_name": "cuviper",
        "timestamp": 1617754855
    },
    {
        "content": "<p>although it looks like std does combine nvptx and nvptx64 into one module, although this is still unstable</p>",
        "id": 233411635,
        "sender_full_name": "bstrie",
        "timestamp": 1617754895
    },
    {
        "content": "<p><code>target_arch</code> is either <code>riscv32</code> or <code>riscv64</code></p>",
        "id": 233411675,
        "sender_full_name": "cuviper",
        "timestamp": 1617754919
    },
    {
        "content": "<p>where's the canonical source for that? on the forge I see riscv32i, riscv32imac, riscv32imc, riscv64gc, riscv64imac</p>",
        "id": 233411756,
        "sender_full_name": "bstrie",
        "timestamp": 1617754977
    },
    {
        "content": "<p><code>git grep arch:.*riscv compiler/rustc_target</code></p>",
        "id": 233411855,
        "sender_full_name": "cuviper",
        "timestamp": 1617755044
    },
    {
        "content": "<p>I guess it's similar to how <code>x86</code> represents target triples called <code>i386</code>, <code>i586</code>, <code>i686</code></p>",
        "id": 233412137,
        "sender_full_name": "cuviper",
        "timestamp": 1617755245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233407632\">said</a>:</p>\n<blockquote>\n<p>One of the remaining unresolved questions for <code>asm!</code> stabilization is where it should live. FWIW, my opinion is that the current situation of most macros being effectively defined \"in the prelude\" is an unfortunate historical remnant that shouldn't be perpetuated with modern macro stabilizations (e.g. <code>std::ptr::addr_of!</code> does it right). At the very least I would be happy if <code>asm!</code> ended up at <code>std::arch::asm!</code>; whether or not to then include <code>asm!</code> in the prelude could be a separate decision. During the RFC, some people wanted to go even further and have <code>std::arch::x86::asm!</code>, <code>std::arch::arm::asm!</code>, etc. <span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> , am I correct in thinking that even if <code>asm!</code> lived under arch-specific namespaces, that there would be <em>no</em> actual difference between any of them, and they would all delegate to the same internal implementation regardless of architecture? Which is to say, is the proposal for having architecture-specific <code>asm!</code> imports simply a roundabout lint to keep code from compiling on unanticipated platforms?</p>\n</blockquote>\n<p>There was a fair bit of discussion in a few threads about where exactly <code>asm!</code> should live.</p>\n<p>I feel strongly that it should <em>not</em> have the architecture in the path, since there are legitimate ways to write asm with abstractions that make it semi-portable (e.g. \"both x86 and x86-64\", or even \"any supported target, with some macros that expand to arch-specific assembly, and portable syntax for labels and directives\").</p>\n<p>As an implementation detail, I think it'd be acceptable either for <code>asm!</code> to live in the prelude, or for <code>asm!</code> to live in <code>std::arch::asm!</code> and be re-exported in the prelude. I wouldn't be thrilled if it lived in <code>std::arch::asm!</code> and required an import.</p>",
        "id": 233422849,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617763807
    },
    {
        "content": "<p>I don't want various crates to have to write (or pull in a crate for) <code>#[cfg(...)] pub use ...::asm as asm; #[cfg(...)] pub use ...::asm as asm; ...</code></p>",
        "id": 233422929,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617763874
    },
    {
        "content": "<p>I saw a pretty compelling pattern that doesn't involve cfg overload:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">arch</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// later, in your already-cfg'd code</span>\n<span class=\"n\">x86</span>::<span class=\"fm\">asm!</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">.);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 233423788,
        "sender_full_name": "bstrie",
        "timestamp": 1617764562
    },
    {
        "content": "<blockquote>\n<p>I wouldn't be thrilled if it lived in std::arch::asm! and required an import.</p>\n</blockquote>\n<p>Hmm, why's that? asm! isn't exactly <em>uncommon</em>, but it's certainly not as common as HashMap or <code>mem::replace</code>, and those aren't in the prelude either</p>",
        "id": 233423926,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617764666
    },
    {
        "content": "<p>for my part, I would like it to not live in the prelude; it's already bad that the stdlib documentation index has to list a ton of random macros just because they're otherwise homeless. IMO new macros should be treated like any other item, and be defined under a module and exported from the prelude as necessary</p>",
        "id": 233423936,
        "sender_full_name": "bstrie",
        "timestamp": 1617764680
    },
    {
        "content": "<p>(I'm halfway motivated to writing an RFC to migrate the existing macros to actual homes in the stdlib :P )</p>",
        "id": 233424002,
        "sender_full_name": "bstrie",
        "timestamp": 1617764747
    },
    {
        "content": "<p>(though I guess that wouldn't require an RFC, they'd all still be exported from the prelude)</p>",
        "id": 233424074,
        "sender_full_name": "bstrie",
        "timestamp": 1617764782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233423936\">said</a>:</p>\n<blockquote>\n<p>for my part, I would like it to not live in the prelude; it's already bad that the stdlib documentation index has to list a ton of random macros just because they're otherwise homeless. IMO new macros should be treated like any other item, and be defined under a module and exported from the prelude as necessary</p>\n</blockquote>\n<p>To clarify in case it came across otherwise, I have <em>zero</em> objection to defining it in a module and re-exporting it from the prelude. I do find the notion of making new prelude items <em>exclusively</em> re-exports rather compelling.</p>",
        "id": 233424269,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617764995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233423926\">said</a>:</p>\n<blockquote>\n<p>asm! isn't exactly <em>uncommon</em>, but it's certainly not as common as HashMap or <code>mem::replace</code>, and those aren't in the prelude either</p>\n</blockquote>\n<p>HashMap <em>should</em> be. :)</p>",
        "id": 233424415,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617765117
    },
    {
        "content": "<p>as for the architecture-specific <code>asm!</code> macros, I'm also of the opinion that just having a single <code>std::arch::asm!</code> is just fine, <em>unless</em> there are actually things that <code>asm!</code> would want to do differently on different architectures (e.g. reserved registers)</p>",
        "id": 233424422,
        "sender_full_name": "bstrie",
        "timestamp": 1617765121
    },
    {
        "content": "<p>And frankly I won't be at all surprised if <code>asm!</code> ends up reasonably common. We actually have a compelling advantage over C here. In C, there's no <em>portable</em> way to do inline assembly, and MSVC and GCC/clang do it differently, so you either have to mandate one compiler family (typically GCC/clang if you care about non-Windows users), or you avoid inline assembly. Even non-inline assembly is a pain, and sometimes involves mandating an assembler (e.g. nasm). In Rust, there will be one standardized way to do inline assembly, which means people writing Rust code <em>can</em> use it more readily than they can in portable C code.</p>",
        "id": 233424490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617765158
    },
    {
        "content": "<p>I wouldn't expect it to be <em>that</em> common; it's still unsafe, and like any unsafe people are going to want to push it out into leaf nodes and dependencies. that said, it's such a \"systems-y\" feature that I don't think anyone would bat an eye if it were in the prelude. And it' so sophisticated that it could credibly claim to warrant its own keyword and dedicated syntax someday, so having it available \"by default\" seems fine</p>",
        "id": 233424801,
        "sender_full_name": "bstrie",
        "timestamp": 1617765427
    },
    {
        "content": "<p>I'd expect it to end up more common than core::arch intrinsics because the intrinsics are at a very sour spot in the ergonomics spectrum</p>",
        "id": 233426922,
        "sender_full_name": "Lokathor",
        "timestamp": 1617767208
    },
    {
        "content": "<p>i think the main value in arch separate asm macros is if we want to commit to having very arch specific docs on each assembly macro. if they're all just going to say \"arm version of asm, x86 version of asm, ...\" then there's no point</p>",
        "id": 233427029,
        "sender_full_name": "Lokathor",
        "timestamp": 1617767284
    },
    {
        "content": "<p>Yeah, I'd expect to have the same documentation on every version.</p>",
        "id": 233428046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617768109
    },
    {
        "content": "<p>There is the <code>att_syntax</code> option which is specific to x86.</p>",
        "id": 233428650,
        "sender_full_name": "Amanieu",
        "timestamp": 1617768625
    },
    {
        "content": "<p>And obviously the list of registers and register classes which are target-specific.</p>",
        "id": 233428663,
        "sender_full_name": "Amanieu",
        "timestamp": 1617768642
    },
    {
        "content": "<p>I personally don't really care where <code>asm!</code> ends up: the cost of adding an import is tiny and I don't mind it (this is coming from a codebase with 200+ <code>asm!</code> blocks).</p>",
        "id": 233428779,
        "sender_full_name": "Amanieu",
        "timestamp": 1617768788
    },
    {
        "content": "<p>I'm worrying how would something like <a href=\"https://github.com/rust-lang/rust/blob/1c158b6a8b440f826d952c3a8f42bdc3f77a5ac1/library/core/src/hint.rs#L170\"><code>core::hint::black_box</code></a> be implemented if (<code>llvm_asm!</code> becomes <code>asm!</code> and) <code>asm!</code> becomes <code>core::arch::&lt;arch&gt;::asm!</code>.</p>",
        "id": 233443497,
        "sender_full_name": "hyd-dev",
        "timestamp": 1617779817
    },
    {
        "content": "<p>inside the function it would just have a lot of cfg, or none at all if asm was in the prelude</p>",
        "id": 233488272,
        "sender_full_name": "Lokathor",
        "timestamp": 1617802574
    },
    {
        "content": "<p>And you can always fall back to a volatile load/store for targets that don't support <code>asm!</code>.</p>",
        "id": 233488642,
        "sender_full_name": "Amanieu",
        "timestamp": 1617802722
    },
    {
        "content": "<p>i mostly agree with <span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span>, and in particular, i don't think <code>asm!</code> should be in the prelude. it's just nowhere near common enough to justify it IMO. whether it should be <code>std::arch::asm!</code> or <code>std::arch::{x86,x86_64,...}::asm!</code> isn't totally clear to me. it sounds like there is arch-specific syntax. so if all we have is <code>std::arch::asm!</code>, then how is that handled? how is it documented?</p>",
        "id": 233500998,
        "sender_full_name": "BurntSushi",
        "timestamp": 1617806904
    },
    {
        "content": "<p>At the moment all the documentation is here: <a href=\"https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html\">https://doc.rust-lang.org/nightly/unstable-book/library-features/asm.html</a></p>",
        "id": 233504426,
        "sender_full_name": "Amanieu",
        "timestamp": 1617807775
    },
    {
        "content": "<p>there is arch specific lists of what you can put in the various places you'd write a register name, and the assembly language used of course, other than that it's not arch specific.</p>",
        "id": 233504458,
        "sender_full_name": "Lokathor",
        "timestamp": 1617807781
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> would you mind if I did a big cleanup of the asm docs? They kinda need some work.</p>",
        "id": 233504759,
        "sender_full_name": "Lokathor",
        "timestamp": 1617807826
    },
    {
        "content": "<p>Sure, go ahead.</p>",
        "id": 233504908,
        "sender_full_name": "Amanieu",
        "timestamp": 1617807846
    },
    {
        "content": "<p>gotya. in that case, <code>std::arch::asm!</code> sounds good. or at least, i don't have any strong opinions.</p>",
        "id": 233504921,
        "sender_full_name": "BurntSushi",
        "timestamp": 1617807849
    },
    {
        "content": "<p>What kind of cleanup do you have in mind?</p>",
        "id": 233504939,
        "sender_full_name": "Amanieu",
        "timestamp": 1617807854
    },
    {
        "content": "<p>all the topics are kinda out of order</p>",
        "id": 233505038,
        "sender_full_name": "Lokathor",
        "timestamp": 1617807882
    },
    {
        "content": "<p>Well there's 2 parts to it: the guide-level and reference-level explanation</p>",
        "id": 233505172,
        "sender_full_name": "Amanieu",
        "timestamp": 1617807917
    },
    {
        "content": "<p>Right, the reference level explanation is mostly fine</p>",
        "id": 233505345,
        "sender_full_name": "Lokathor",
        "timestamp": 1617807961
    },
    {
        "content": "<p>If we do namespace <code>asm!</code>, we will also have to do the same with <code>global_asm!</code>. And possibly <code>asm_snippet!</code> as well if we decide to implement that.</p>",
        "id": 233505859,
        "sender_full_name": "Amanieu",
        "timestamp": 1617808071
    },
    {
        "content": "<p>What happens today if you use <code>asm!</code> on an unsupported platform? compiler error?</p>",
        "id": 233733411,
        "sender_full_name": "bstrie",
        "timestamp": 1617917230
    },
    {
        "content": "<p>yes, <code>error[E0472]: asm! is unsupported on this target</code></p>",
        "id": 233745085,
        "sender_full_name": "cuviper",
        "timestamp": 1617923855
    },
    {
        "content": "<p>I've opened <a href=\"https://github.com/rust-lang/rust/issues/84019\">https://github.com/rust-lang/rust/issues/84019</a> to collect all the various pros/cons of each approach</p>",
        "id": 233746163,
        "sender_full_name": "bstrie",
        "timestamp": 1617924667
    },
    {
        "content": "<p>One con about having <code>arch::&lt;arch&gt;::asm!</code> that I haven't seen mentioned is that this implicitly requires that the target architecture have the same stability as core (plus its stability attribute), and there are architectures that <code>asm!</code> has support for that have no corresponding <code>arch</code> submodule.</p>\n<p>I think it would be better to have it as <code>arch::asm!</code> so that whether you can use inline assembly with a target isn't blocked by adding new public APIs in <code>core</code>.</p>",
        "id": 233773255,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1617949012
    },
    {
        "content": "<p>but can't you just have a stable arch module with the one stable macro in it?</p>",
        "id": 233773519,
        "sender_full_name": "Lokathor",
        "timestamp": 1617949315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> What happens if support for that target was later dropped?</p>",
        "id": 233796178,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1617962757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219696\">XAMPPRocky</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233796178\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> What happens if support for that target was later dropped?</p>\n</blockquote>\n<p>Logically, since that module was only ever <code>cfg</code> enabled when compiling for that target, if that target disappears then that module is always <code>cfg</code> disabled -- aka. disappears too. though I imagine we'd probably just delete that source file.</p>",
        "id": 233798883,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1617964272
    },
    {
        "content": "<p>unlikely, since build-std is a thing and will continue to grow so we actually will basically never be able to confidently say we've dropped support for a target</p>",
        "id": 233810919,
        "sender_full_name": "Lokathor",
        "timestamp": 1617970826
    },
    {
        "content": "<p>particularly, even the targets we have demoted so far we didn't drop core support for, just std support for</p>",
        "id": 233811021,
        "sender_full_name": "Lokathor",
        "timestamp": 1617970874
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Not sure I agree, we could and have definitely come to a point where where a target is fully dropped. Off the top of my head CloudABI’s support was fully removed for example.</p>",
        "id": 233926043,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1618030308
    },
    {
        "content": "<p>you can still compile core for any target you like with a <code>&lt;target&gt;.json</code> file. would be nice if <code>asm(..)</code> is usable for those targets too</p>",
        "id": 233936892,
        "sender_full_name": "Mara",
        "timestamp": 1618041872
    },
    {
        "content": "<p>Even with &lt;target&gt;.json the compiler still needs full knowledge about the arch to know for example which registers and register classes exist. If the compiler has support, libcore may just as well support it. If libcore drops supports, the compiler would likely drop support for asm! too I did guess.</p>",
        "id": 233977996,
        "sender_full_name": "bjorn3",
        "timestamp": 1618080696
    },
    {
        "content": "<p>I would like to know more about this. One of my assumptions here is that, once Rust has <code>asm!</code> support for a given target, the only reason to ever deprecate that support is if LLVM drops support for that target. And if LLVM drops support for the target, there's no use even trying to provide a deprecation warning, because your code straight up won't compile anymore. (Insert &lt;any future backend&gt; for LLVM if you like.) Is this oversimplifying?</p>\n<blockquote>\n<p>I think it would be better to have it as arch::asm! so that whether you can use inline assembly with a target isn't blocked by adding new public APIs in core.</p>\n</blockquote>\n<p>I'm not sure about this. Assuming <code>arch::asm</code> is stabilized, adding any new target will either require changes to <code>asm!</code> or it won't. In the latter case, the act of merely adding target support to rustc insta-stabilizes <code>asm!</code> on that platform, which seems possibly undesirable. In the former case, adding the new target support to <code>asm!</code> isn't really made more onerous by needing to make a new module for that target. The fact that <code>arch::&lt;foo&gt;::asm</code> prevents the \"accidental stabilization\" case actually seems like it might be a point in its favor.</p>",
        "id": 233978065,
        "sender_full_name": "bstrie",
        "timestamp": 1618080738
    },
    {
        "content": "<p>Yeah, it's certainly the case that we won't want to stabilize asm for all arches at the same moment. x86, x86-64, arm, and aarch64 have had a lot of work and testing for bugs. other arches are much less used, but we don't want them to hold back stabilization for the most used arches. Same as the intrinsics story really.</p>",
        "id": 233980676,
        "sender_full_name": "Lokathor",
        "timestamp": 1618083066
    },
    {
        "content": "<p>though I suppose with creative <code>#cfg</code> use anything is possible, including preventing accidental stabilization even with <code>arch::asm</code>. So file this as yet another instance of \"it doesn't really matter which one gets chosen\" :P</p>",
        "id": 233982189,
        "sender_full_name": "bstrie",
        "timestamp": 1618084468
    },
    {
        "content": "<p>One question that it might be prudent to answer first: do people want <code>asm!</code> in the prelude? because if so, then the choice between these two almost literally just boils down to \"where should the documentation live\"</p>",
        "id": 233982676,
        "sender_full_name": "bstrie",
        "timestamp": 1618084933
    },
    {
        "content": "<p>Personally, i don't think asm! is anywhere close to common enough to deserve being in the prelude.</p>",
        "id": 233984121,
        "sender_full_name": "BurntSushi",
        "timestamp": 1618086257
    },
    {
        "content": "<p>i don't think having it in the prelude would clash with any other reasonable macro.</p>",
        "id": 233986389,
        "sender_full_name": "Lokathor",
        "timestamp": 1618088321
    },
    {
        "content": "<p>I would prefer to have it in the prelude, for simplicity of usage. It's a built-in macro, and the intent is for it to \"feel\" like a native language feature.</p>",
        "id": 233986422,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618088385
    },
    {
        "content": "<p>I don't think it would conflict with anything, and if someone defined their own, they'd just shadow it.</p>",
        "id": 233986584,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618088428
    },
    {
        "content": "<p>I guess this comes back to the <a href=\"https://github.com/rust-lang/rfcs/pull/3090#issuecomment-787149824\">\"vocabulary\"</a> argument again, like <code>drop</code>.  Even if you're not using it, you probably shouldn't ever be making an item with that name anyway...</p>",
        "id": 233996592,
        "sender_full_name": "scottmcm",
        "timestamp": 1618095985
    },
    {
        "content": "<p>to be clear, name clashing isn't really the thing that bothers me about putting it in the prelude. what bothers me is that it's uncommon.</p>\n<p>now, i would be more sympathetic to an argument like \"this is what we've done in the past with other macros like the arguably even more obscure <code>is_x86_feature_detected!</code>, and until we've come up with a good story for how to namespace those, we shouldn't be namespacing things like <code>asm!</code>.\" e.g., i think <code>is_x86_feature_detected!</code> shouldn't be in the prelude either. Just the other day I needed to use it and naively wrote <code>use std::arch::x86::is_x86_featured_detected</code> and was surprised when it didn't work. i thought to myself, \"wait where is it? something that obscure can't be in the prelude...\"</p>\n<p>of course, back then, i don't think we had a way to nicely namespace macros, but i forgot that bit of context in the moment.</p>",
        "id": 233998380,
        "sender_full_name": "BurntSushi",
        "timestamp": 1618097734
    },
    {
        "content": "<p>FWIW, I do think it's perfectly reasonable to put it in <code>std::arch</code>. I just think the prelude should have a <code>pub use</code>.</p>",
        "id": 233998461,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618097798
    },
    {
        "content": "<p>It's not that it's incredibly common. It's that it's a macro that serves as a language feature, and I think it should \"feel\" built-in.</p>",
        "id": 233998479,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618097828
    },
    {
        "content": "<p>Yeah commonality isn't a factor to me</p>",
        "id": 233998753,
        "sender_full_name": "Lokathor",
        "timestamp": 1618098208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233998479\">said</a>:</p>\n<blockquote>\n<p>It's not that it's incredibly common. It's that it's a macro that serves as a language feature, and I think it should \"feel\" built-in.</p>\n</blockquote>\n<p>Shouldn't that apply to the new <code>ptr</code> macros as well then?</p>",
        "id": 234003422,
        "sender_full_name": "isHavvy",
        "timestamp": 1618103096
    },
    {
        "content": "<p>that's an interesting angle. I'd say that the fact that <code>addr_of!</code> is \"expected\" to be deprecated in favor of <code>&amp;raw</code> someday is a good argument for it <em>not</em> being in the prelude, to make it marginally less disruptive to someday deprecate. It also suggests (to me, anyway) that this is not the \"finished\" version of this feature, not enough to warrant being included in the language \"by default\". But I don't know how well that applies to <code>asm!</code> vs a first-class <code>asm</code> keyword; do people actually have expectations that there will exist an <code>asm</code> keyword to supersede the <code>asm!</code> macro someday? Is there any proto-proposal that discusses what unique semantics it would have to warrant first-class syntax?</p>",
        "id": 234004742,
        "sender_full_name": "bstrie",
        "timestamp": 1618104533
    },
    {
        "content": "<p>I think MSVC <a href=\"https://docs.microsoft.com/en-us/cpp/assembler/inline/asm?view=msvc-160\">supports</a> a <code>__asm { code ... }</code> syntax</p>",
        "id": 234005957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618105923
    },
    {
        "content": "<p>MSVC only supports it on 32-bit x86</p>",
        "id": 234015794,
        "sender_full_name": "cuviper",
        "timestamp": 1618116780
    },
    {
        "content": "<p>Speaking only of the syntax question, I think it is moderately ugly that code is being written inside a string, since this implies that the language understanding of the contents is minimal. (And this is, for the most part, true.) In a perfect world, the contents of the asm macro would be typechecked so that invalid opcodes, label references and all the rest are resolved correctly, just like a proper DSL</p>",
        "id": 234016777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618117910
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Ideally it would be. But that is a <em>monumental</em> amount of work and ongoing maintenance, compared to using existing assemblers such as LLVM's.</p>",
        "id": 234017407,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618118724
    },
    {
        "content": "<p>Yes, I'm aware. That's very much a long term shiny future aspiration, not anything actionable in the near future</p>",
        "id": 234017498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618118831
    },
    {
        "content": "<p>Although, it's not actually that hard to write an assembler, particularly if you are sharing an official data source like some tables produced by intel</p>",
        "id": 234017551,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618118900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234017551\">said</a>:</p>\n<blockquote>\n<p>Although, it's not actually that hard to write an assembler, particularly if you are sharing an official data source like some tables produced by intel</p>\n</blockquote>\n<p>I just wrote a RISC-V spec parser (from the official TeX) for use in generating a disassembler:<br>\n<a href=\"https://crates.io/crates/riscv-instructions\">https://crates.io/crates/riscv-instructions</a><br>\nmostly-untested rv64gc disassembler generator:<br>\n<a href=\"https://github.com/programmerjake/riscv-jit-emulator/tree/master/riscv-jit-emulator-instruction-parser-generator\">https://github.com/programmerjake/riscv-jit-emulator/tree/master/riscv-jit-emulator-instruction-parser-generator</a></p>",
        "id": 234019817,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1618121691
    },
    {
        "content": "<p>The idea with providing a string-based API is that the community can always make a proc macro wrapper around it to provide a better interface.</p>",
        "id": 234019930,
        "sender_full_name": "Amanieu",
        "timestamp": 1618121858
    },
    {
        "content": "<blockquote>\n<p>I would like to know more about this. One of my assumptions here is that, once Rust has <code>asm!</code> support for a given target, the only reason to ever deprecate that support is if LLVM drops support for that target. And if LLVM drops support for the target, there's no use even trying to provide a deprecation warning, because your code straight up won't compile anymore. (Insert &lt;any future backend&gt; for LLVM if you like.) Is this oversimplifying?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> Well i think there are additional factors such as certain targets being only available with certain backends and not others. A real example of this is the SPIR-V <code>asm!</code>, which is only supported when using <code>rust-gpu</code> as your codegen backend. So that target's support isn't based on LLVM.</p>\n<p>Of course using that target requires nightly, but it wouldn't be intuitive if you had to change all <code>asm!</code> calls with <code>arch::x86_64::asm!</code> or some other target that wasn't the arch being compiled for, and I don't think makes sense to add new API surface for experimental targets which just re-export the same macro that every architecture uses.</p>",
        "id": 234050519,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1618152422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234016777\">said</a>:</p>\n<blockquote>\n<p>In a perfect world, the contents of the asm macro would be typechecked so that invalid opcodes, label references and all the rest are resolved correctly, just like a proper DSL</p>\n</blockquote>\n<p>No, the opposite. The current ASM is specifically spec'd as being \"the compiler is not allowed to examine the content of this string and is not allowed to assume that the instructions executed at runtime will even do what the content of this string says (in other words: you're allowed to replace the code at runtime and the compiler must not assume that you won't).</p>",
        "id": 234051108,
        "sender_full_name": "Lokathor",
        "timestamp": 1618152914
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> That's an important property, but doesn't preclude the compiler understanding the assembly. We would need to require that the compiler cannot change the assembly, but it could check your assembly against your stated clobbers, for example.</p>",
        "id": 234058211,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618158310
    },
    {
        "content": "<p>(you could clobber more than your assembly requires, but you could get an error if you clobber less.)</p>",
        "id": 234058243,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618158342
    },
    {
        "content": "<p>fair enough</p>",
        "id": 234058339,
        "sender_full_name": "Lokathor",
        "timestamp": 1618158436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234019930\">said</a>:</p>\n<blockquote>\n<p>The idea with providing a string-based API is that the community can always make a proc macro wrapper around it to provide a better interface.</p>\n</blockquote>\n<p>If we think that this is likely, then I think that's a reasonable argument for <code>asm!</code> not being in the prelude. But I think people would find this to be an easier pill to swallow if any such libraries already existed in a usable form; do they yet?</p>",
        "id": 234061261,
        "sender_full_name": "bstrie",
        "timestamp": 1618161268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219696\">XAMPPRocky</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234050519\">said</a>:</p>\n<blockquote>\n<p>Of course using that target requires nightly, but it wouldn't be intuitive if you had to change all <code>asm!</code> calls with <code>arch::x86_64::asm!</code> or some other target that wasn't the arch being compiled for, and I don't think makes sense to add new API surface for experimental targets which just re-export the same macro that every architecture uses.</p>\n</blockquote>\n<p>Hm, it does seem undesirable to suggest that alternative backends fork core just to get their supported submodules into <code>arch</code>. Although, I suppose that whatever patch added SPIR-V support to <code>asm!</code> in nightly could have just as easily added a <code>arch::spirv</code> module if this policy had happened to already be in place, yes? Adding a nightly-only module to support a nightly-only target doesn't seem that onerous. However, it does start to make the relative procedural simplicity of <code>arch::asm</code> look more desirable.</p>",
        "id": 234061930,
        "sender_full_name": "bstrie",
        "timestamp": 1618161969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/234061261\">said</a>:</p>\n<blockquote>\n<p>If we think that this is likely, then I think that's a reasonable argument for <code>asm!</code> not being in the prelude. But I think people would find this to be an easier pill to swallow if any such libraries already existed in a usable form; do they yet?</p>\n</blockquote>\n<p>I personally feel that it's unlikely to happen. It's the justification for not providing a higher-level API for inline asm in the compiler.</p>",
        "id": 234062887,
        "sender_full_name": "Amanieu",
        "timestamp": 1618163026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/namespacing.20.60asm!.60/near/233411590\">said</a>:</p>\n<blockquote>\n<p>isn't there 32/64-bit RISC-V at least? we don't combine x86 for that...</p>\n</blockquote>\n<p>It is actually very easy to write assembly code (and machine code!) that works for both RV32 and RV64. So probably it makes sense to combine them, but that'll might be a inconsistency compared to other architectures...</p>",
        "id": 234063070,
        "sender_full_name": "Gary Guo",
        "timestamp": 1618163179
    },
    {
        "content": "<p>Personally I don't think that a person is likely to write individual inline asm blocks so complex that they warrant an entire DSL proc-macro for checking. That just bloats the compile time for not much gain</p>",
        "id": 234066015,
        "sender_full_name": "Lokathor",
        "timestamp": 1618166014
    },
    {
        "content": "<p>I'm actually having a hard time answering the questions of what architectures rustc <em>does</em> support; it's very easy to see what arches <code>asm!</code> supports: <a href=\"https://github.com/rust-lang/rust/blob/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/asm/mod.rs#L173\">https://github.com/rust-lang/rust/blob/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/asm/mod.rs#L173</a> , but it looks rustc only inspects a String field to see what the current target's arch is. in particular I don't find anywhere that actually defines a Target whose arch is \"spirv\", even though <code>asm!</code> does support SPIR-V, and even though there is exactly one place in the tree that uses it: <code>#[cfg(not(target_arch = \"spirv\"))]</code>. if there's not a subset relationship between possible values of <code>target_arch</code> and the supported arches for <code>asm!</code>, then that's probably a big argument in favor of <code>arch::asm</code>.</p>",
        "id": 234066381,
        "sender_full_name": "bstrie",
        "timestamp": 1618166384
    },
    {
        "content": "<p>is the idea that external target specs are defining such a target?</p>",
        "id": 234066437,
        "sender_full_name": "bstrie",
        "timestamp": 1618166416
    },
    {
        "content": "<p>because even so, I'm kind of surprised that there's no explicit whitelist of targets supported by rustc, and that things are expected to Just Work</p>",
        "id": 234066495,
        "sender_full_name": "bstrie",
        "timestamp": 1618166518
    },
    {
        "content": "<blockquote>\n<p>is the idea that external target specs are defining such a target?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> Yes, the spirv target is defined entirely in the <code>rust-gpu</code> backend. When rustc is provided an unknown target it checks the available backends if it supports them.</p>",
        "id": 234069653,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1618169485
    },
    {
        "content": "<p>I'm impressed that works without even having any kind of call ABI defined in <a href=\"https://github.com/rust-lang/rust/tree/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/abi/call\">https://github.com/rust-lang/rust/tree/7953910464e073eb3876d1544a3fd5b5ba0ca49b/compiler/rustc_target/src/abi/call</a></p>",
        "id": 234071321,
        "sender_full_name": "bstrie",
        "timestamp": 1618171041
    },
    {
        "content": "<p>I'm wondering if this has any implication for the observable stability of different values of <code>target_arch</code>, since anyone can provide their own value as a string, and presumably rustc can then decide to do anything at all for any value of it. In particular, having distinct modules for every supported <code>asm!</code> target seems like it might be a stronger stability guarantee than is currently expected (well, disregarding the popular arches, anyway), which is worth keeping in mind.</p>",
        "id": 234071626,
        "sender_full_name": "bstrie",
        "timestamp": 1618171278
    },
    {
        "content": "<blockquote>\n<p>In particular, having distinct modules for every supported <code>asm!</code> target seems like it might be a stronger stability guarantee than is currently expected (well, disregarding the popular arches, anyway), which is worth keeping in mind.</p>\n</blockquote>\n<p>Yeah, which is why I’m of the opinion <code>asm!</code> should be treated more as a language feature and have its input fall under target support stability rather than <code>std</code>/<code>core</code> stability.</p>",
        "id": 234102771,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1618202685
    },
    {
        "content": "<p>I will copy-paste what I said on the Github issue:</p>\n<hr>\n<p>Strongly support std::arch::foo64::asm.</p>\n<p>I find the kind of issue discussed in \"3. Error reporting in the event of unguarded asm: having arch::asm\" to be determinative.</p>\n<p>I'm less worried about error reporting, though, than about having something accidentally cleanly assemble with different semantics because of the wrong architecture.</p>\n<p>I have an example lying around somewhere in the issue tracker that will assemble for both x86_64 and aarch64: this is scary, since the operand order for the default x86_64 assembler is source, dest while aarch64 is dest, source. So now you've got probably UB or at least a surprising bug when somebody accidentally compiles the unqualified code for the wrong architecture.</p>\n<hr>\n<p>The problem here is that the user experience for clients of some deeply-nested crate is not going to be ideal no matter what we do. I'd much rather be told that my dependency won't build because some asm buried in one of that crate's dependency has the wrong architecture; getting some weird build error from a dependent crate about illegal operands or something would be much more confusing. That's the best case — the worst case is the one I mentioned above, where the crate appears to compile and assemble fine but fails in some mysterious way at runtime. Not so Rustic, I think.</p>\n<hr>\n<p>The other thing I'm kind of sad about is that this discussion is happening here rather than on the Github issue. I would not even have known about it had @bstrie not linked this discussion to there. I think it's really valuable to capture this discussion in the issue tracker — more people may see it, and once it's resolved there will be an easily-located permanent record of the rationale that might be really valuable in the future.</p>",
        "id": 234106036,
        "sender_full_name": "Bart Massey",
        "timestamp": 1618206170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220717\">@Bart Massey</span> , note that I made this Zulip thread prior to making the Github thread, and semi-intended that the GH thread would be a more prominent/permanent summary of the various discussions happening here (or elsewhere). I've been updating the main GH issue as pertinent information arises. In general people seem to find it preferable to use Zulip for fast-moving/bikesheddy topics, since 1) it avoids pinging every single person's email every time anyone comments, and 2) it doesn't exhibit Github's annoying auto-hide behavior for long threads.</p>",
        "id": 234207852,
        "sender_full_name": "bstrie",
        "timestamp": 1618252257
    }
]