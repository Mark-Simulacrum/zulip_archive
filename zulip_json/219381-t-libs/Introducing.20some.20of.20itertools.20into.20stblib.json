[
    {
        "content": "<p>So I looked for an hour today for how to combine 2 iterators such that I get one element from each iterator at a time.<br>\nI tried combining chain and map and could figure it out. and after I failed I started googling for a while until I found <code>interleave</code> in itertools.<br>\nthis function seem like a natural extension to <code>chain</code> and <code>zip</code>.<br>\nI wonder what's the policy here and if we could introduce some of <code>itertools</code> into the standard library</p>",
        "id": 257923498,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1634481328
    },
    {
        "content": "<p>If the only reason is because no one opened a PR I'm willing to open a PR for <code>interleave</code> or a few other ones that seems very useful and simple</p>",
        "id": 257923733,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1634481520
    },
    {
        "content": "<p>It's tricky for compatability -- look what just happened with <code>intersperse</code></p>",
        "id": 257924802,
        "sender_full_name": "cuviper",
        "timestamp": 1634482540
    },
    {
        "content": "<p>/me nods</p>",
        "id": 257988846,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634542813
    },
    {
        "content": "<p>I think if we had a better way to avoid breaking compatibility with the same functions in itertools, we'd be much more willing to add more functions from itertools.</p>",
        "id": 257988884,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634542839
    },
    {
        "content": "<p>Has anyone tried using something like <code>#[cfg(rustc_version = \"&lt;1.56.0\")]</code> in itertools to make certain trait functions disappear on versions of rustc that upstream the method? I know it's not a perfect solution, but it's a very versatile technique</p>",
        "id": 257991885,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634544615
    },
    {
        "content": "<p>Another alternative would be to add the notion of \"weak\" methods, that will essentially be hidden if there'san ambiguity (like weak linkage). Or have a way of only allowing to call it starting at an edition.</p>",
        "id": 257995047,
        "sender_full_name": "oli",
        "timestamp": 1634546472
    },
    {
        "content": "<p>If a new method is only \"visible\" in a new edition, when I migrate my crate the fix is to stop having the itertools trait in scope to resolve the ambiguity. But that means I can’t (as easily) also use other methods of that trait that don’t exist in std</p>",
        "id": 258002187,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1634550306
    },
    {
        "content": "<p>you could also switch to fully qualified functions, although that's ugly in iterator chains. or use imports more selectively</p>",
        "id": 258004850,
        "sender_full_name": "The 8472",
        "timestamp": 1634551694
    },
    {
        "content": "<p>We could also just magic it (make a special attribute that resolves the conflict in favor of our version instead of erroring). I feel like this is an unusually good case for magic, given the unique demands on the standard library.</p>",
        "id": 258014641,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1634557118
    },
    {
        "content": "<p>not necessarily. a general mechanism to resolve conflicts could also be useful for other kinds of extension trait providing libraries to avoid conflicts with others.</p>",
        "id": 258054026,
        "sender_full_name": "The 8472",
        "timestamp": 1634573389
    },
    {
        "content": "<p>/me really wishes someone had the bandwidth to implement a subset of <code>cfg(accessible(...))</code>.</p>",
        "id": 258055601,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634573922
    },
    {
        "content": "<p>(Such as the subset that requires the argument to start with <code>std::</code> or <code>alloc::</code> or <code>core::</code>.)</p>",
        "id": 258055673,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634573952
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"417924\">inquisitivecrystal</span> <a href=\"#narrow/stream/219381-t-libs/topic/Introducing.20some.20of.20itertools.20into.20stblib/near/258014641\">said</a>:</p>\n<blockquote>\n<p>We could also just magic it (make a special attribute that resolves the conflict in favor of our version instead of erroring). I feel like this is an unusually good case for magic, given the unique demands on the standard library.</p>\n</blockquote>\n<p>I don't actually think we'd want to resolve in favor of ours; I think we'd want to resolve in favor of the external one, and deprioritize ours. If someone's linking in a crate, let's assume they want the crate.</p>",
        "id": 258056807,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634574280
    },
    {
        "content": "<p>Current IRLO thread about this: <a href=\"https://internals.rust-lang.org/t/pre-pre-rfc-give-trait-methods-a-priority-for-resolving-name-clashes/15455?u=scottmcm\">https://internals.rust-lang.org/t/pre-pre-rfc-give-trait-methods-a-priority-for-resolving-name-clashes/15455?u=scottmcm</a></p>",
        "id": 258099314,
        "sender_full_name": "scottmcm",
        "timestamp": 1634590805
    },
    {
        "content": "<p>One version of \"deprioritize ours\" would be some form of \"prefer trait methods not from the prelude before trait methods from the prelude\" -- I think that would have also fixed the <code>.try_into()</code> problems.  (And then if you explicitly <code>use Iterator;</code>'d then you'd get the ambiguity again.)</p>\n<p>Basically the same thing we already do for type names.</p>",
        "id": 258099771,
        "sender_full_name": "scottmcm",
        "timestamp": 1634590971
    },
    {
        "content": "<p>That would solve the problem for the prelude, but wouldn't solve the problem for traits that people commonly import that are implemented on types for which external crates also provide additional helpers.</p>",
        "id": 258173535,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634640222
    },
    {
        "content": "<p>For instance, consider what would happen if we add additional methods to the Read trait, and those methods happen to conflict with methods provided by a common third-party trait.</p>",
        "id": 258173616,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634640254
    },
    {
        "content": "<p>Rather than taking the prelude into account, could we (and should we) just deprioritize anything that comes from the standard library, compared to a third party crate?</p>",
        "id": 258173663,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634640288
    },
    {
        "content": "<p>why not last-import-wins + a warning?</p>",
        "id": 258184342,
        "sender_full_name": "The 8472",
        "timestamp": 1634645897
    },
    {
        "content": "<p>mhm, no that would be bad if some formatter rearranges imports</p>",
        "id": 258184597,
        "sender_full_name": "The 8472",
        "timestamp": 1634646014
    },
    {
        "content": "<p>Right, normally order doesn't matter.</p>",
        "id": 258185684,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634646587
    },
    {
        "content": "<p>A way to more selectively import methods of a trait could work, but that'd require new syntax or annotations.</p>",
        "id": 258186332,
        "sender_full_name": "The 8472",
        "timestamp": 1634646902
    },
    {
        "content": "<p>We need a way to UFCS an inherent method first</p>",
        "id": 258186525,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634646999
    },
    {
        "content": "<p>but you can already do that? <code>Type::method_name(receiver, rest of args)</code></p>",
        "id": 258186794,
        "sender_full_name": "The 8472",
        "timestamp": 1634647138
    },
    {
        "content": "<p>or do you mean better syntax for chaining them?</p>",
        "id": 258187527,
        "sender_full_name": "The 8472",
        "timestamp": 1634647473
    },
    {
        "content": "<p>postfix macros could do that. <code>iter.call!(Itertools::interleave, arg, ...)</code></p>",
        "id": 258187931,
        "sender_full_name": "The 8472",
        "timestamp": 1634647662
    },
    {
        "content": "<p><code>Type::method_name</code> can also refer to a trait implementation on that type.</p>",
        "id": 258187947,
        "sender_full_name": "cuviper",
        "timestamp": 1634647673
    },
    {
        "content": "<blockquote>\n<p>you could also switch to fully qualified functions</p>\n</blockquote>\n<p>that’s what I meant by not as easily</p>",
        "id": 258199669,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1634652186
    },
    {
        "content": "<p><code>&lt;Type as Self&gt;::method_name</code>?</p>",
        "id": 258316734,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1634709726
    }
]