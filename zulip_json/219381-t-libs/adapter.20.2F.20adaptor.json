[
    {
        "content": "<p>Hi, I’m wondering which spelling, “adapter” or “adaptor”, is supposed to be used in the library docs. I’ve seen both e.g. on <a href=\"https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html\">https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html</a> and I don’t like the inconsistency. Even though “adaptor” is more common on that page, throughout the whole <code>std</code>, “adapter” seems to win, including in the naming of internal modules such as <code>core::iter::adapters</code>.</p>\n<p>Would it be reasonable to do a PR to make them all consistent and if yes which one to choose?</p>",
        "id": 247705993,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1627650929
    },
    {
        "content": "<hr>\n<div class=\"codehilite\"><pre><span></span><code> ~/forks/rust/library   master  rg &#39;adapter&#39;\ncore/tests/iter/mod.rs\n7://! smaller modules. The two big modules are `adapters` and `traits`.\n9://! `adapters` are for methods on `Iterator` that adapt the data inside the\n15://! if a test in `traits` uses a specific adapter, then it should be moved to\n16://! that adapter&#39;s test file in `adapters`.\n18:mod adapters;\n\ncore/tests/iter/traits/double_ended.rs\n7://! it tests another adapter or trait, you should *add it to the adapter or\n10://! Some examples would be `adapters::cloned::test_cloned_try_folds` or\n11://! `adapters::flat_map::test_double_ended_flat_map`, which use `try_fold` and\n12://! `next_back`, but test their own adapter.\n\nstd/src/collections/mod.rs\n239://! Iterators also provide a series of *adapter* methods for performing common\n240://! threads to sequences. Among the adapters are functional favorites like `map`,\n242://! `rev` adapter, that reverses any iterator that supports this operation. Most\n\ncore/src/ops/control_flow.rs\n165:/// These are used only as part of implementing the iterator adapters.\n\nstd/src/io/buffered/mod.rs\n57:    /// adapters that wrap other adapters\n\ncore/src/iter/adapters/scan.rs\n2:use crate::iter::{adapters::SourceIter, InPlaceIterable};\n\ncore/src/iter/adapters/cloned.rs\n1:use crate::iter::adapters::{\n\ncore/src/iter/adapters/filter.rs\n2:use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n\ncore/src/iter/adapters/map.rs\n2:use crate::iter::adapters::{\n\ncore/src/iter/adapters/map_while.rs\n2:use crate::iter::{adapters::SourceIter, InPlaceIterable};\n\ncore/src/iter/adapters/copied.rs\n1:use crate::iter::adapters::{\n\ncore/src/iter/adapters/intersperse.rs\n3:/// An iterator adapter that places a separator between all elements.\n60:/// An iterator adapter that places a separator between all elements.\n\ncore/src/iter/adapters/take_while.rs\n2:use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n\ncore/src/iter/adapters/chain.rs\n25:    // adapter because its specialization for `FusedIterator` unconditionally descends into the\n\ncore/src/iter/adapters/enumerate.rs\n1:use crate::iter::adapters::{\n\ncore/src/iter/adapters/filter_map.rs\n2:use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n\ncore/src/iter/adapters/skip.rs\n2:use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n\ncore/src/iter/adapters/peekable.rs\n1:use crate::iter::{adapters::SourceIter, FusedIterator, TrustedLen};\n\ncore/src/iter/adapters/inspect.rs\n2:use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n\ncore/src/iter/adapters/skip_while.rs\n2:use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable};\n\ncore/src/iter/sources/repeat_with.rs\n8:/// Infinite iterators like `repeat_with()` are often used with adapters like\n\ncore/src/iter/adapters/mod.rs\n60:/// This trait provides transitive access to source-stage in an iterator-adapter pipeline\n63:/// * there is a delegating implementation of this trait for each adapter in the pipeline between\n71:/// source of a pipeline. A stateful intermediate adapter might eagerly evaluate a part\n108:    /// This means iterator adapters can rely on the source not changing during\n111:    /// Implementing this method means adapters relinquish private-only access to their\n113:    /// The lack of restricted access also requires that adapters must uphold the source&#39;s\n117:    /// its public API since adapters sitting between it and the source have the same\n118:    /// access. In particular an adapter may have consumed more elements than strictly necessary.\n128:/// An iterator adapter that produces output as long as the underlying\n\ncore/src/iter/sources/repeat.rs\n7:/// Infinite iterators like `repeat()` are often used with adapters like\n\ncore/src/iter/adapters/take.rs\n2:use crate::iter::{adapters::SourceIter, FusedIterator, InPlaceIterable, TrustedLen};\n\ncore/src/iter/adapters/fuse.rs\n2:use crate::iter::adapters::zip::try_get_unchecked;\n\ncore/src/iter/mod.rs\n53://! more complex forms of processing. See the [Adapters](#adapters) section\n76://! each iterator and iterator adapter.\n257://! often called &#39;iterator adapters&#39;, as they&#39;re a form of the &#39;adapter\n260://! Common iterator adapters include [`map`], [`take`], and [`filter`].\n263://! If an iterator adapter panics, the iterator will be in an unspecified (but\n274://! Iterators (and iterator [adapters](#adapters)) are *lazy*. This means that\n324://! It is common to use the [`take`] iterator adapter to turn an infinite\n395:pub use self::adapters::zip;\n397:pub use self::adapters::Cloned;\n399:pub use self::adapters::Copied;\n401:pub use self::adapters::Flatten;\n403:pub use self::adapters::MapWhile;\n405:pub use self::adapters::SourceIter;\n407:pub use self::adapters::StepBy;\n409:pub use self::adapters::TrustedRandomAccess;\n411:pub use self::adapters::TrustedRandomAccessNoCoerce;\n413:pub use self::adapters::{\n418:pub use self::adapters::{Intersperse, IntersperseWith};\n420:pub(crate) use self::adapters::process_results;\n422:mod adapters;\n\ncore/src/iter/traits/iterator.rs\n1343:    /// The [`map`] adapter is very useful, but only when the closure\n\ncore/src/iter/adapters/zip.rs\n556:pub(in crate::iter::adapters) unsafe fn try_get_unchecked&lt;I&gt;(it: &amp;mut I, idx: usize) -&gt; I::Item\n\nalloc/tests/vec.rs\n994:fn test_from_iter_specialization_with_iterator_adapters() {\n\nalloc/src/vec/source_iter_marker.rs\n18:// on the adapter implementations (beyond `impl&lt;I: Trait&gt; Trait for Adapter&lt;I&gt;`) only depend on other\n131:        // - it vectorizes better for some iterator adapters\n\nstdarch/crates/stdarch-verify/arm-intrinsics.html\n93182:        &lt;li&gt;&lt;a class=&quot;c-footer-section__link&quot; href=&quot;/products/software-development-tools/debug-probes-and-adapters&quot; title=&quot;Debug Probes and Adapters&quot;&gt;Debug Probes and Adapters&lt;/a&gt;&lt;/li&gt;\n</code></pre></div>\n<hr>\n<div class=\"codehilite\"><pre><span></span><code> ~/forks/rust/library   master  rg &#39;adaptor&#39;\ncore/tests/iter/adapters/mod.rs\n27:/// `Iterator`&#39;s contract. Used to test that iterator adaptors don&#39;t\n\ncore/src/alloc/mod.rs\n341:    /// Creates a &quot;by reference&quot; adaptor for this instance of `Allocator`.\n343:    /// The returned adaptor also implements `Allocator` and will simply borrow this.\n\ncore/src/iter/traits/iterator.rs\n697:    /// internal iteration on adaptors like `Chain`.\n1296:    /// An iterator adaptor similar to [`fold`] that holds internal state and\n1607:    /// This is useful to allow applying iterator adaptors while still\n\nstd/src/io/mod.rs\n813:    /// Creates a &quot;by reference&quot; adaptor for this instance of `Read`.\n815:    /// The returned adaptor also implements `Read` and will simply borrow this\n892:    /// Creates an adaptor which will chain this stream with another.\n930:    /// Creates an adaptor which will read at most `limit` bytes from it.\n1329:/// * The [`flush`] method is useful for adaptors and explicit buffers\n1680:    /// Creates a &quot;by reference&quot; adaptor for this instance of `Write`.\n1682:    /// The returned adaptor also implements `Write` and will simply borrow this\n2417:/// Reader adaptor which limits the bytes read from an underlying reader.\n</code></pre></div>",
        "id": 247706004,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1627650935
    },
    {
        "content": "<p>For what it's worth, \"adapter\" seems to be the much more common spelling in general. See <a href=\"https://github.com/first20hours/google-10000-english/blob/master/google-10000-english.txt\">word list sorted by frequency</a>. There is apparently <a href=\"https://writingexplained.org/adapter-vs-adaptor-difference#Possible_Distinctions\">some regional variation</a> in relative popularity but \"adapter\" seems to be winning everywhere.</p>",
        "id": 247707867,
        "sender_full_name": "Chris Denton",
        "timestamp": 1627651869
    },
    {
        "content": "<p>FWIW, the book uses “iterator adaptor”.</p>",
        "id": 247720623,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1627657824
    },
    {
        "content": "<p>Anyways, I’ve opened <a href=\"https://github.com/rust-lang/rust/issues/87629\">#87629</a> for now.</p>",
        "id": 247722692,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1627658680
    },
    {
        "content": "<p>The GoF book uses \"adapter\" for the design pattern, which I would take as fairly authoritative (<a href=\"https://www.oreilly.com/library/view/design-patterns-elements/0201633612/\">https://www.oreilly.com/library/view/design-patterns-elements/0201633612/</a>). I would personally use \"adaptor\", but I think that is due to higher prevalence in English English and since we use American English, I think \"adapter\" is better</p>",
        "id": 247882377,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627860639
    },
    {
        "content": "<p>While American English is technically preferred, in reality usage is quite mixed from my experience.</p>",
        "id": 247882505,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627860869
    },
    {
        "content": "<p>Does it even matter? Both are cromulent.</p>",
        "id": 247882791,
        "sender_full_name": "The 8472",
        "timestamp": 1627861331
    }
]