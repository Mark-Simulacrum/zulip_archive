[
    {
        "content": "<p>what's the status of <a href=\"https://github.com/rust-lang/rust/issues/43244\">https://github.com/rust-lang/rust/issues/43244</a> ? One of the concerns is the naming of the methods which I don't see much objection to (off late at least) to, so i guess we can finalise if it is fine to keep the name as is?</p>",
        "id": 273272775,
        "sender_full_name": "DPC",
        "timestamp": 1645816602
    },
    {
        "content": "<p>I think the drain-on-drop behavior evaluating user closures is a bigger issue.</p>",
        "id": 273275299,
        "sender_full_name": "The 8472",
        "timestamp": 1645817927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273275299\">said</a>:</p>\n<blockquote>\n<p>I think the drain-on-drop behavior evaluating user closures is a bigger issue.</p>\n</blockquote>\n<p>is this mitigated by <a href=\"https://github.com/rust-lang/lang-team/issues/97\">https://github.com/rust-lang/lang-team/issues/97</a>?</p>",
        "id": 273275554,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645818065
    },
    {
        "content": "<p>\"Never allow unwinding from Drop impls\"</p>",
        "id": 273275575,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645818075
    },
    {
        "content": "<p>or does the fact that it would abort just make it worse</p>",
        "id": 273275585,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645818083
    },
    {
        "content": "<p>Makes it worse. <a href=\"https://github.com/rust-lang/rust/issues/43244#issuecomment-975957123\">https://github.com/rust-lang/rust/issues/43244#issuecomment-975957123</a></p>",
        "id": 273275596,
        "sender_full_name": "The 8472",
        "timestamp": 1645818092
    },
    {
        "content": "<p><em>grumbles about linear types</em></p>",
        "id": 273275767,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645818188
    },
    {
        "content": "<p>part of me wishes we could take the accelerationist approach and just make the drop impl abort unconditionally and force ppl to go through iteration to defuse the drop bomb but i know that won't work in practice</p>",
        "id": 273275901,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645818246
    },
    {
        "content": "<p>the drain APIs all seem so tragic, between this and the pre-pooping your pants stuff for dealing with leaks, makes me wonder if that's not a sign that these APIs are fundamentally flawed and just don't fit well into rust's ownership model.</p>",
        "id": 273276128,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645818381
    },
    {
        "content": "<p><code>drain</code> isn't <em>too</em> terrible. the cleanup is a bit gnarly, but at least it doesn't run user code other than <code>drop</code>, which is normal for owning iterators. <code>drain_filter</code> is worse.</p>",
        "id": 273276373,
        "sender_full_name": "The 8472",
        "timestamp": 1645818520
    },
    {
        "content": "<p>yea that's fair, leaking a draining iterator is admittedly not a common issue</p>",
        "id": 273276712,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645818726
    },
    {
        "content": "<blockquote>\n<p>Should drain_filter accept a Range argument?</p>\n</blockquote>\n<p>This would also be useful. Otherwise there are cases that are served by neither method and we'd need a <code>drain_filter_range</code> later.</p>",
        "id": 273278666,
        "sender_full_name": "The 8472",
        "timestamp": 1645819797
    },
    {
        "content": "<p>Is there a survey somewhere of how often someone really needs the items <em>as an iterator</em> from this?  I wonder how much of it could be done with, say, a <code>retain_filter_map</code> kind of API instead that doesn't use the iterator structure.</p>",
        "id": 273278918,
        "sender_full_name": "scottmcm",
        "timestamp": 1645819932
    },
    {
        "content": "<p>What would the map part do?</p>",
        "id": 273279035,
        "sender_full_name": "The 8472",
        "timestamp": 1645820025
    },
    {
        "content": "<p>I have in the past used <code>drain</code> as an iterator (though not <code>drain_filter</code> as it's nightly only).</p>",
        "id": 273279036,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645820026
    },
    {
        "content": "<p>something like <code>fn filter_map(&amp;mut self, r: impl RangeBounds&lt;usize&gt;, f: impl FnMut(T) -&gt; Option&lt;T&gt;)</code>, so that you could keep things, change things, or remove things, but there's no iterator involved to cause <code>Drop</code> complications</p>",
        "id": 273279234,
        "sender_full_name": "scottmcm",
        "timestamp": 1645820132
    },
    {
        "content": "<p>There are some uses of <code>drain_filter</code> in the compiler. Most of them <code>collect</code> the resulting iterator into a <code>Vec</code>.</p>",
        "id": 273279574,
        "sender_full_name": "Amanieu",
        "timestamp": 1645820310
    },
    {
        "content": "<p>The other 2 cases seem like they could have been implemented using plain <code>retain</code> instead.</p>",
        "id": 273279654,
        "sender_full_name": "Amanieu",
        "timestamp": 1645820365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> retain_mut already allows changing things. It lacks the range part though.</p>",
        "id": 273279844,
        "sender_full_name": "The 8472",
        "timestamp": 1645820487
    },
    {
        "content": "<p><code>retain_mut</code> is still unstable, so we could enhance it.</p>",
        "id": 273279959,
        "sender_full_name": "The 8472",
        "timestamp": 1645820562
    },
    {
        "content": "<p>I'll note that in the tracking issue.</p>",
        "id": 273279982,
        "sender_full_name": "The 8472",
        "timestamp": 1645820580
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> But it doesn't give ownership.  <code>retain_filter_map</code> lets you do owning things.</p>",
        "id": 273279986,
        "sender_full_name": "scottmcm",
        "timestamp": 1645820581
    },
    {
        "content": "<p>moving things back in and out has its own costs, unless the compiler is smart enough to elide them</p>",
        "id": 273280124,
        "sender_full_name": "The 8472",
        "timestamp": 1645820647
    },
    {
        "content": "<p>or rather, there's an optimization in <code>retain</code> that skips moving things as long as everything has been retained.</p>",
        "id": 273280174,
        "sender_full_name": "The 8472",
        "timestamp": 1645820689
    },
    {
        "content": "<p><code>retain_mut</code> is in FCP, added a comment anyway. <a href=\"https://github.com/rust-lang/rust/issues/90829#issuecomment-1051234859\">https://github.com/rust-lang/rust/issues/90829#issuecomment-1051234859</a></p>",
        "id": 273281081,
        "sender_full_name": "The 8472",
        "timestamp": 1645821147
    },
    {
        "content": "<p>It does seem a little sad that it looks pretty likely we'll end up with at least 3 different functions for basically one operation (retain, retain_mut, and drain_filter in the future, at minimum)</p>",
        "id": 273281373,
        "sender_full_name": "simulacrum",
        "timestamp": 1645821323
    },
    {
        "content": "<p>But yes, moving doesn't always optimize out.  I don't know if it would in this case, but you can see in &lt;<a href=\"https://github.com/rust-lang/rust/issues/76725\">https://github.com/rust-lang/rust/issues/76725</a>&gt; that threading an object through a fold can be slower than just using <code>for_each</code>+<code>FnMut</code>.</p>",
        "id": 273281429,
        "sender_full_name": "scottmcm",
        "timestamp": 1645821353
    },
    {
        "content": "<p>I could also just see us having <code>retain</code>, <code>retain_mut</code>, and <code>retain_map</code> in future.  We have plenty of things with all three versions.  (Though of course one of them is a bit unfortunate in this specific case.)</p>",
        "id": 273281777,
        "sender_full_name": "scottmcm",
        "timestamp": 1645821476
    },
    {
        "content": "<p>Is the breakage really that widespread from just making retain take <code>FnMut(&amp;mut T) -&gt; bool</code>? (It feels like coercing <code>FnMut(&amp;T) -&gt; bool</code> to the <code>&amp;mut</code> version should be something the compiler could just do ...)</p>",
        "id": 273282334,
        "sender_full_name": "simulacrum",
        "timestamp": 1645821612
    },
    {
        "content": "<p>I remember trying that years ago: it was enough to cause rustc to fail to build.</p>",
        "id": 273282441,
        "sender_full_name": "Amanieu",
        "timestamp": 1645821676
    },
    {
        "content": "<p>oof</p>",
        "id": 273282519,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645821720
    },
    {
        "content": "<p>It's basically due to people writing closures in the form <code>iter.retain(|&amp;x| { ... })</code> which breaks when the argument type is changed to <code>&amp;mut T</code>.</p>",
        "id": 273282562,
        "sender_full_name": "Amanieu",
        "timestamp": 1645821724
    },
    {
        "content": "<p>I don't think the fold case is the best example. iterators and from_iter impls are full of different code paths that may just optimize differently, that does not necessarily mean that it's the moving that confuses the optimizer, could also be other things.<br>\nAlso, <code>fold_mut</code> wouldn't have been needed in that case, there's <code>scan</code> that provides a mutable state. Nobody remembers <code>scan</code>.</p>",
        "id": 273282666,
        "sender_full_name": "The 8472",
        "timestamp": 1645821796
    },
    {
        "content": "<p>IMO it should be tested whether a <code>retain_map</code> would experience any slowdown so that having <code>retain_mut</code> remains worthwhile.</p>",
        "id": 273282869,
        "sender_full_name": "The 8472",
        "timestamp": 1645821917
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273282562\">said</a>:</p>\n<blockquote>\n<p>It's basically due to people writing closures in the form <code>iter.retain(|&amp;x| { ... })</code> which breaks when the argument type is changed to <code>&amp;mut T</code>.</p>\n</blockquote>\n<p>I wonder how hard it would be to allow matching a <code>&amp;mut</code> with a pattern of <code>&amp;x</code>? That <em>seems</em> valid.</p>",
        "id": 273283070,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645822058
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> (suggestions welcome for who else to CC)</p>",
        "id": 273283122,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645822091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273275299\">said</a>:</p>\n<blockquote>\n<p>I think the drain-on-drop behavior evaluating user closures is a bigger issue.</p>\n</blockquote>\n<p>yeh definitely,  but at least wantd to get the name concern out of the way since I don't see any recent discussion about it</p>",
        "id": 273284597,
        "sender_full_name": "DPC",
        "timestamp": 1645822924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273283070\">said</a>:</p>\n<blockquote>\n<p>I wonder how hard it would be to allow matching a <code>&amp;mut</code> with a pattern of <code>&amp;x</code>? That <em>seems</em> valid.</p>\n</blockquote>\n<p>I think it's a long tail of similar things.  <code>iter.retain(Vec::is_empty);</code> breaks if the closure wants <code>&amp;mut</code>, because we don't have function-to-function coercions, for example.  (Though I'd like those too.)</p>",
        "id": 273285339,
        "sender_full_name": "scottmcm",
        "timestamp": 1645823407
    },
    {
        "content": "<p>Hack: take <code>impl FnMutOnRefOrRefMut</code></p>",
        "id": 273285710,
        "sender_full_name": "cuviper",
        "timestamp": 1645823676
    },
    {
        "content": "<p>But such a trait would have to prove that only one <code>FnMut</code> applies</p>",
        "id": 273285770,
        "sender_full_name": "cuviper",
        "timestamp": 1645823726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273276128\">said</a>:</p>\n<blockquote>\n<p>the drain APIs all seem so tragic, between this and the pre-pooping your pants stuff for dealing with leaks, makes me wonder if that's not a sign that these APIs are fundamentally flawed and just don't fit well into rust's ownership model.</p>\n</blockquote>\n<p>Don't mean to beat a dead horse here, but just anecdotally: The first time I used the <code>drain</code>-like APIs, I was surprised to find out that things I did not consume from the iterator would be dropped and removed anyway. This felt contrary to the typical \"lazy\" design of iterators. Obviously nothing we can do about it now (and changing this for new APIs seems too confusing to do anyone any good), but just as a point of interest</p>",
        "id": 273290860,
        "sender_full_name": "Jake",
        "timestamp": 1645826739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273285339\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273283070\">said</a>:</p>\n<blockquote>\n<p>I wonder how hard it would be to allow matching a <code>&amp;mut</code> with a pattern of <code>&amp;x</code>? That <em>seems</em> valid.</p>\n</blockquote>\n<p>I think it's a long tail of similar things.  <code>iter.retain(Vec::is_empty);</code> breaks if the closure wants <code>&amp;mut</code>, because we don't have function-to-function coercions, for example.  (Though I'd like those too.)</p>\n</blockquote>\n<p>I'm curious how long a tail it actually is. Coercing functions with <code>&amp;T</code> in their signatures to functions with <code>&amp;mut T</code> in their signatures seems like a natural extension.</p>",
        "id": 273292226,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645827555
    },
    {
        "content": "<p>I guess it also depends how people want to weigh technically-breaking vs nobody-does-that.  Because of course it could be <code>.retain(MyTrait::true_for_mut_ref_but_false_for_shared_ref)</code>.</p>",
        "id": 273297985,
        "sender_full_name": "scottmcm",
        "timestamp": 1645830953
    },
    {
        "content": "<p>I think it just raises the bar on how strongly justified it has to be</p>",
        "id": 273303138,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645834605
    },
    {
        "content": "<p>Generally speaking, we seem to value \"actually not breaking\" much higher, and place relatively little value on \"technically breaking but nobody notices in practice\".</p>",
        "id": 273304708,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645836112
    },
    {
        "content": "<p>would be nice to add a summary to the tracking issue</p>",
        "id": 273304916,
        "sender_full_name": "DPC",
        "timestamp": 1645836315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273304708\">said</a>:</p>\n<blockquote>\n<p>Generally speaking, we seem to value \"actually not breaking\" much higher, and place relatively little value on \"technically breaking but nobody notices in practice\".</p>\n</blockquote>\n<p>yes, especially as the amount of non-oss rust code grows (and i suspect its getting higher, just measuring from how the disparity between crate downloads and dependents in my own crates has grown), we're getting to the point where we can't trust crater to show us the extent of the issues as much as we once could.</p>",
        "id": 273305042,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645836472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> I don't want to treat crater <em>alone</em> as a measure of \"nobody does this\". I think we should start with some prior for how plausible something seems to do, and then use crater as experimental evidence to update that estimation.</p>",
        "id": 273305364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645836749
    },
    {
        "content": "<p>I swear I talked to <span class=\"user-mention\" data-user-id=\"224872\">@rylev</span> or someone at rustconf years ago about crater for closed source projects</p>",
        "id": 273305534,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645836922
    },
    {
        "content": "<p>And some sort of system for running your own subset of a crater run internally then submitting the results back to the community</p>",
        "id": 273305610,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645836977
    },
    {
        "content": "<p>yeah it was also discussed at the \"enterprise rust unconference\" the day before rustconf a few years ago. so it's definitely a thing we've had in mind for a while, although i'm unsure anything ever came of it (i think not).</p>",
        "id": 273305761,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645837166
    },
    {
        "content": "<p>Maybe a good project to throw at one of the big companies using rust looking for where to put their money</p>",
        "id": 273306100,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645837355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273275767\">said</a>:</p>\n<blockquote>\n<p><em>grumbles about linear types</em></p>\n</blockquote>\n<p>Since scoped APIs are incredibly handy to mock linear types, I wonder if that's not a part that could deserve more attention to be generally improved?</p>\n<ul>\n<li><em>e.g.</em>, if we were able to be generic over the <em>effect</em>, at least the <em>async</em> effect, while also being able to feature unboxed <code>async</code> closures with the right signature (possible with TAIT), then continuation-based APIs could be made a bit better, especially for <code>async</code> (where they're so bad right now);</li>\n</ul>\n<p>Anyhow, whenever drop becomes too problematic, I agree that it then looks like an API issue, and scoped APIs have been so nice for that.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/drain.20filters.20.28tracking.20issue.29/near/273279234\">said</a>:</p>\n<blockquote>\n<p>something like <code>fn filter_map(&amp;mut self, r: impl RangeBounds&lt;usize&gt;, f: impl FnMut(T) -&gt; Option&lt;T&gt;)</code>, so that you could keep things, change things, or remove things, but there's no iterator involved to cause <code>Drop</code> complications</p>\n</blockquote>\n<p>is one such example of a scoped API, but maybe there could be other designs.</p>\n<p>All I'm saying is these things could deserve more exploration <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 273338699,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1645879563
    },
    {
        "content": "<p>Ah interesting, so you're suggesting a drain api like <code>fn drain(&amp;mut self, f: impl FnMut(Drain) -&gt; Drain)</code></p>",
        "id": 273347325,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645889803
    },
    {
        "content": "<p>That would solve the problem of the user provided closures running in drop</p>",
        "id": 273347365,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645889881
    }
]