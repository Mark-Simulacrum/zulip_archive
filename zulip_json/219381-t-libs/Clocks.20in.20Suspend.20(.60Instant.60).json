[
    {
        "content": "<p>I've recently opened <a href=\"https://github.com/rust-lang/rust/pull/87907\">https://github.com/rust-lang/rust/pull/87907</a> and <a href=\"https://github.com/rust-lang/rust/issues/87906\">https://github.com/rust-lang/rust/issues/87906</a><br>\nabout the behavior of <code>Instant</code> and ticking during suspend.</p>\n<p>I'm coming to the libs channel to ask if we have any guidance for what <code>std</code> should do when there is not a useful lowest common denominator offered by all operating systems in the general case, since there seems to be disagreement in the comments about what stance <code>std</code> should take in situations where not all OSes provide the same capabilities.</p>",
        "id": 249305718,
        "sender_full_name": "Matthew Maurer",
        "timestamp": 1628810664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> for visibility since they had opinions on this specific case in the bug.</p>",
        "id": 249306878,
        "sender_full_name": "Matthew Maurer",
        "timestamp": 1628811840
    },
    {
        "content": "<p>I personally feel that CLOCK_MONOTONIC is the correct behavior here. When a system is suspended, it is reasonable to expect that time is paused. For example, if I suspend a laptop playing a video then I would be very surprised if upon resuming my video player decided to fast-forward an hour's worth of video.</p>",
        "id": 249312452,
        "sender_full_name": "Amanieu",
        "timestamp": 1628817790
    },
    {
        "content": "<p>The counterpoint example to that is anything doing network or IO, since the rest of the world is <em>not</em> paused when the CPU enters suspend.</p>\n<p>As it stands, you can't use <code>Instant</code> for what you're describing either - if you depended on it in that way for video playback, Windows would skip ahead, but Linux would not.</p>",
        "id": 249312743,
        "sender_full_name": "Matthew Maurer",
        "timestamp": 1628818154
    },
    {
        "content": "<p>Instant can be used for frame by frame calculation, but if the time reported is much more than a few frames total you sorta have to assume that the system is somehow incoherent and reset your perspective.</p>",
        "id": 249319160,
        "sender_full_name": "Lokathor",
        "timestamp": 1628826019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132491\">Matthew Maurer</span> <a href=\"#narrow/stream/219381-t-libs/topic/Clocks.20in.20Suspend.20.28.60Instant.60.29/near/249312743\">said</a>:</p>\n<blockquote>\n<p>The counterpoint example to that is anything doing network or IO, since the rest of the world is <em>not</em> paused when the CPU enters suspend.</p>\n</blockquote>\n<p>Your network connection is going to die anyway when your machine wakes up from suspend. And whether it's a good idea to \"rush\" all the queued up work also depends on the use-case. And if your task is scheduled at small intervals it doesn't matter anyway.</p>\n<blockquote>\n<p>As it stands, you can't use <code>Instant</code> for what you're describing either - if you depended on it in that way for video playback, Windows would skip ahead, but Linux would not.</p>\n</blockquote>\n<p>That's a reasonable argument against that someone may rely on the current behavior although it could still break single-platform code.</p>\n<p>My concern is more about conditioning the wrong behavior. If it works on all but a few platforms then people may start relying on implementation details. If it's wildly inconsistent across major platforms then that's less of a risk. So as long as we can't guarantee this for all platforms inconsistent behavior is kind of good because it forces people to deal with those inconsistencies rather than breaking users on less common systems.</p>",
        "id": 249328887,
        "sender_full_name": "The 8472",
        "timestamp": 1628837547
    },
    {
        "content": "<p>I think nearly all platforms, at least in their most recent version, give access to a clock that has this behavior.</p>\n<p>(I become a lot less sympthetic to this reasoning when \"less common\" also includes \"several years out of date\", since then nothing can improve).</p>\n<p>Taking a look, AFAICT <code>freebsd</code> <em>might</em> not (it's unclear if <code>CLOCK_UPTIME</code> increments during suspend.</p>",
        "id": 249330726,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628839424
    },
    {
        "content": "<blockquote>\n<p>since then nothing can improve</p>\n</blockquote>\n<p>But it can, by introducing a new API that guarantees boot time. At the expense of not being supported on all platforms</p>",
        "id": 249332071,
        "sender_full_name": "The 8472",
        "timestamp": 1628840784
    },
    {
        "content": "<p>Having an API that doesn't guarantee boot time officially but coaxes people to rely on it anyway seems like bad practice.</p>",
        "id": 249332102,
        "sender_full_name": "The 8472",
        "timestamp": 1628840826
    },
    {
        "content": "<p>We're getting a similar opinion split here to the one on the bug, which is why I was trying to appeal to deciding on a general principle -</p>\n<p>When we have a std function which can't be consistent across operating systems, what should we do? So far, the opinions I've seen expressed for the <code>Instant</code> case are:</p>\n<ul>\n<li>Use the \"best\" support we can get from the operating system (there is some discussion of which is \"best\" in the instant case, but I think that's orthogonal to the main question here). The main argument for this one is that above all else, we want developers to be able to write useful programs that work the way they expect.</li>\n<li>Intentionally pick the least useful variants on each operating system to prevent developers from depending on properties which may not be present on other platforms. The main argument here is to keep the Rust ecosystem as portable as possible by preventing developers from implicitly depending on features without explicitly requiring them.</li>\n<li>Split the API, and only provide each API half on platforms which support it. This is probably optimal if the API is in an early phase, but if the incompatibility is discovered later (as with <code>Instant</code>), there is still a question of how the default/legacy code should behave, which goes back to the first two options. Concretizing with <code>Instant</code>, if we added <code>::sleeping_now()</code> <code>::waking_now()</code> (probably with less terrible names), each of which were only available on some platforms, that would <em>still</em> need to answer the question of what <code>::now()</code> should do.</li>\n</ul>\n<p>While choosing clocks for <code>Instant</code> is a particular case of this issue, I was looking for guidance on how we should approach this class of issues because this won't be the last time this happens.</p>",
        "id": 249413035,
        "sender_full_name": "Matthew Maurer",
        "timestamp": 1628888082
    },
    {
        "content": "<p>Note that I wasn't arguing about \"best\" or \"least useful\" at all. Imo including and not including suspend time are simply different use-cases. Sometimes you want a program to just do something regularly as long as it is running and sometimes you care more about something that's closer to elapsed wall time. </p>\n<p><code>clock_gettime</code> (and timers, sleep methods etc.) let you specify different clock sources for that reason... different needs.</p>",
        "id": 249414188,
        "sender_full_name": "The 8472",
        "timestamp": 1628888646
    },
    {
        "content": "<p>and in other cases one doesn't care at all because any issues around wakeups will be transient</p>",
        "id": 249414339,
        "sender_full_name": "The 8472",
        "timestamp": 1628888723
    },
    {
        "content": "<p>So I was only arguing about pretending there is consistency when we can't guarantee it.</p>",
        "id": 249414474,
        "sender_full_name": "The 8472",
        "timestamp": 1628888775
    },
    {
        "content": "<p>That said there are some areas where a best effort is made but it doesn't work on some platforms. But that's often around optimizations (e.g. using <code>vfork</code>) or plugging race conditions (<code>FD_CLOEXEC</code>).</p>",
        "id": 249415321,
        "sender_full_name": "The 8472",
        "timestamp": 1628889285
    },
    {
        "content": "<p>Ah, here's an example where best-effort is made to get one observable behavior but on a few platforms it's another one: <a href=\"https://doc.rust-lang.org/std/fs/fn.hard_link.html\">https://doc.rust-lang.org/std/fs/fn.hard_link.html</a></p>",
        "id": 249415727,
        "sender_full_name": "The 8472",
        "timestamp": 1628889475
    },
    {
        "content": "<p>OK, so you're suggesting we already do the first option, but in this case it's not clear that <code>CLOCK_BOOTTIME</code> is a best choice?</p>",
        "id": 249416656,
        "sender_full_name": "Matthew Maurer",
        "timestamp": 1628890088
    },
    {
        "content": "<p>e.g. <code>hard_link</code> explicitly is biased towards \"do not follow symlink\"</p>",
        "id": 249416690,
        "sender_full_name": "Matthew Maurer",
        "timestamp": 1628890129
    },
    {
        "content": "<p>I have difficulty parsing your question</p>\n<blockquote>\n<p>so you're suggesting we already do the first option, but [...]?</p>\n</blockquote>\n<p>Are you asking me whether this already is THE policy and I only disagree with choice is being made for the preferred behavior? Then no, that's not what I meant to say. I was just throwing several unrelated things out there that don't tie together into a single argument.</p>\n<p>Yes, <code>hard_link</code> is an example of picking one behavior among several possible (it was dubbed \"somewhat arbitrary\" in the PR, so not necessarily \"best\") and then making an effort to stick to it where possible. But that doesn't make it a universal policy.</p>\n<p>When it comes to CLOCK_MONOTONIC vs. CLOCK_BOOTTIME... I don't think one is better than the other. Sometimes one or the other would be the wrong choice and other times it doesn't make a difference. So in the long run the 3rd option of providing more specific APIs would be needed. Perhaps not in std and just using a library or calling libc directly would be enough but currently that's not possible because libraries can't construct instants with a different time base.</p>",
        "id": 249423224,
        "sender_full_name": "The 8472",
        "timestamp": 1628895111
    }
]