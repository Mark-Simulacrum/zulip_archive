[
    {
        "content": "<p>The discussion of macros for function names reminds me of a macro I wish existed: <code>path_of!($path)</code>, which would take some in-scope path, and give me an absolute path to that location. EG <code>path_of!(Debug) -&gt; ::core::fmt::Debug</code> or <code>path_of!(imported_fn) -&gt; ::crate_name::module::imported_fn</code>. I can see some issues around, say, pub-in-priv or such, but it would be really nice to be able to generate some arbitrary 'side' data in a macro, then access it later.<br>\nA current workaround is to generate an item in a different namespace alongside, so an import of the item can use that macro. However, this is brittle as there's no single namespace for all cases, and also is fragile to the user wanting to do the same thing. So only one 'alongside' item can generally exist.</p>",
        "id": 269620689,
        "sender_full_name": "CraftSpider",
        "timestamp": 1643309919
    },
    {
        "content": "<p>The other issue is that this would have to take place at a 'weird' level, as it would need to know enough to resolve but not yet have fully expanded all macros. I'm not sure if the existing module_path macro architecture works for this or not, as I'm not super deep into the compiler's internal magic</p>",
        "id": 269621310,
        "sender_full_name": "CraftSpider",
        "timestamp": 1643310168
    },
    {
        "content": "<p>But this could be useful for things 'alongside' at module level, but also enum variants (if only some are in scope), and I fell would make a lot of macro-based interpretation of items less brittle</p>",
        "id": 269621450,
        "sender_full_name": "CraftSpider",
        "timestamp": 1643310235
    },
    {
        "content": "<blockquote>\n<p>can see some issues around, say, pub-in-priv or such</p>\n</blockquote>",
        "id": 269621825,
        "sender_full_name": "bstrie",
        "timestamp": 1643310387
    },
    {
        "content": "<p>I don't think item privacy actually tries to hide items, it just prevents you from using them</p>",
        "id": 269621843,
        "sender_full_name": "bstrie",
        "timestamp": 1643310399
    },
    {
        "content": "<p>unless I'm misunderstanding the problem?</p>",
        "id": 269621878,
        "sender_full_name": "bstrie",
        "timestamp": 1643310423
    },
    {
        "content": "<p>Actually you're right, I don't think this would allow anything previously disallowed. I think previously to avoid the question around where in item resolution this falls, I instead considered whether something like a magic <code>Self</code> path qualifier could exist, which would possibly allow naming previously unnameable types, but this sidesteps that issue if it just gets you the path.</p>",
        "id": 269622151,
        "sender_full_name": "CraftSpider",
        "timestamp": 1643310554
    }
]