[
    {
        "content": "<p>I'm taking a stab at implementing Read::read_buf_vectored. Has anyone thought about the design much?</p>",
        "id": 268424170,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642525768
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span></p>",
        "id": 268432159,
        "sender_full_name": "Amanieu",
        "timestamp": 1642529010
    },
    {
        "content": "<p>I had a partial API or implementation somewhere, let me see if I can track it down</p>",
        "id": 268468738,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1642546908
    },
    {
        "content": "<p>Here we go: <a href=\"https://github.com/sfackler/read-buf/blob/master/src/read_bufs.rs\">https://github.com/sfackler/read-buf/blob/master/src/read_bufs.rs</a></p>",
        "id": 268468925,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1642547015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> why does it track only which data is initialised (and implicitly the capacity) whereas ReadBuf tracks how much of the buffer is filled too?</p>",
        "id": 268718296,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642695884
    },
    {
        "content": "<p>Oh yeah I think that repo is from an older iteration of the RFC before we started tracking the read pointer in ReadBuf</p>",
        "id": 268719174,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1642696230
    },
    {
        "content": "<p>looks like the ReadBuf in there does the same thing</p>",
        "id": 268719204,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1642696244
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 268721844,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642697382
    },
    {
        "content": "<p>Why do we have read_buf_exact but not read_vectored_exact?</p>",
        "id": 271264736,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644407155
    },
    {
        "content": "<p>And neither buf nor vectored versions of read_to_end?</p>",
        "id": 271264899,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644407252
    },
    {
        "content": "<p>Different abstraction/convenience levels I think.</p>",
        "id": 271264975,
        "sender_full_name": "The 8472",
        "timestamp": 1644407294
    },
    {
        "content": "<p>vectored read_to_end doesn't really make sense - if you're doing a read_to_end you by definition just have one buffer to write to (the vec).</p>",
        "id": 271820478,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1644842546
    },
    {
        "content": "<p>On the buf side, read_to_end takes advantage of the buf-based API internally to avoid re-initializing regions of the buffer, but it still interacts with a raw Vec. You could add a new version of that that works with a wrapper type around Vec that persistently tracks the initialization state so repeated read_to_end calls could avoid re-initializing but I don't know how common that is.</p>",
        "id": 271820724,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1644842666
    },
    {
        "content": "<p>read_vectored_exact could definitely exist though - I think there was a PR adding it, but it ends up being a bit tricky to implement since it may require modifying the input slice in place as you go</p>",
        "id": 271820800,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1644842717
    },
    {
        "content": "<p>Thanls!</p>",
        "id": 271823094,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644844057
    }
]