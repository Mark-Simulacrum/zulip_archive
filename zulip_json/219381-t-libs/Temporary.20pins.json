[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132829\">@Christopher Durham</span> Continuing from <a href=\"https://github.com/rust-lang/rust/pull/94114#issuecomment-1085982828\">https://github.com/rust-lang/rust/pull/94114#issuecomment-1085982828</a></p>",
        "id": 277428209,
        "sender_full_name": "David Koloski",
        "timestamp": 1648824105
    },
    {
        "content": "<p><span aria-label=\"ear\" class=\"emoji emoji-1f442\" role=\"img\" title=\"ear\">:ear:</span></p>",
        "id": 277429099,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648824479
    },
    {
        "content": "<p>Changing the definition of <code>Pin</code> would indeed require changing <code>Future</code> because of the case you described. I bounced around a few ideas, but I think the most promising one would be an <code>IntoFuture</code> trait that looks something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// Safety: `into_future` must emplace its future into `out` and return a pinned pointer to it</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">IntoFuture</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Future</span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">into_future</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">out</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Future</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">Future</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So async blocks would return some <code>IntoFuture</code> that then gets emplaced and pinned in one step. Since the future can only be polled through a <code>Pin</code>, it's safe for us to drop the pin and then move the future around. Even though it has internal references that have been messed up, we can't poll it any more.</p>",
        "id": 277429421,
        "sender_full_name": "David Koloski",
        "timestamp": 1648824600
    },
    {
        "content": "<p>One nice thing about this is that it formalizes the notion of the first poll making the future unmoveable. An <code>IntoFuture</code> is safe to move, but its <code>Future</code> is not.</p>",
        "id": 277429594,
        "sender_full_name": "David Koloski",
        "timestamp": 1648824662
    },
    {
        "content": "<p>One limitation of <code>IntoFuture</code> is that it mandates a move from pre-first-poll to post-first-poll, i.e. if you have <code>Box&lt;impl IntoFuture&lt;Future=Self&gt;&gt;</code> (~today's semantics), you can't poll it in place</p>",
        "id": 277432799,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648825874
    },
    {
        "content": "<p>I'm also (cautious? doubtful? can't find the fully correct word) about any changes to <code>Pin</code>/<code>Future</code>'s <code>unsafe</code> contract due to the fact that these are pervasively implemented by hand and relied upon by hand</p>",
        "id": 277433066,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648825982
    },
    {
        "content": "<p>That could be mitigated with a slightly uglier <code>into_future</code> that takes just <code>&amp;'a MaybeUninit&lt;Self&gt;</code>. Making it unsafe with the requirement that the <code>MaybeUninit</code> contains a fresh unpolled future should be sufficient.</p>\n<p>All of this is really in theoretical terms, I think that _actually_ changing the safety contract of <code>Pin</code> and <code>Future</code> is untenable with the current ecosystem. While I do lean towards this being a more accurate formulation, there are obviously a lot of practical considerations. I think it's a good place for us to explore out from. If it ever leads to concrete change we'd certainly have to put it behind a big edition change.</p>",
        "id": 277433616,
        "sender_full_name": "David Koloski",
        "timestamp": 1648826222
    }
]