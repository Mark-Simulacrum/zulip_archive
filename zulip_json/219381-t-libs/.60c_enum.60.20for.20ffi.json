[
    {
        "content": "<p>It's currently a little cumbersome to deal with c defined enums. I wonder if it's a good idea to have a <code>c_enum</code> macro for transpiling </p>\n<div class=\"codehilite\"><pre><span></span><code>enum A {\n    X = 0,\n    Y = 1,\n    Z = 2,\n}\n</code></pre></div>\n<p>to</p>\n<div class=\"codehilite\"><pre><span></span><code>struct A(u8);\nimpl A {\n    const X: A = A(0);\n    const Y: A = A(1);\n    const Z: A = A(2);\n}\n</code></pre></div>\n<p>or something.</p>",
        "id": 273591189,
        "sender_full_name": "Charles Lew",
        "timestamp": 1646110502
    },
    {
        "content": "<p><a href=\"https://github.com/Lokathor/sola_kesto/blob/main/src/macros.rs#L172\">https://github.com/Lokathor/sola_kesto/blob/main/src/macros.rs#L172</a></p>\n<p>like some sort of \"foreign enum\" macro? ;3</p>",
        "id": 273592202,
        "sender_full_name": "Lokathor",
        "timestamp": 1646111273
    },
    {
        "content": "<p>It can work surprisingly well with just a <code>macro_rules</code> macro: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c12edf15aa6b6e143e6cc28c1d990061\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=c12edf15aa6b6e143e6cc28c1d990061</a></p>\n<p>It wouldn't even need the explicit variant values with a bit more macro-foo.</p>",
        "id": 273592424,
        "sender_full_name": "scottmcm",
        "timestamp": 1646111478
    },
    {
        "content": "<p>scott don't forget the fancy debug impl!</p>",
        "id": 273593180,
        "sender_full_name": "Lokathor",
        "timestamp": 1646112261
    },
    {
        "content": "<p>I have a crate for this:<br>\n<a href=\"https://lib.rs/fake-enum\">https://lib.rs/fake-enum</a></p>",
        "id": 273628871,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646135798
    },
    {
        "content": "<blockquote>\n<p>It wouldn't even need the explicit variant values with a bit more macro-foo.</p>\n</blockquote>\n<p>Isn’t that “counting in a macro”, which is notoriously hard?</p>",
        "id": 273631662,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646137338
    },
    {
        "content": "<p>or would you just let the normal discriminant values be added by the compiler￼?</p>",
        "id": 273631757,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646137388
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60c_enum.60.20for.20ffi/near/273631662\">said</a>:</p>\n<blockquote>\n<p>Isn’t that “counting in a macro”, which is notoriously hard?</p>\n</blockquote>\n<p>It's legal to define the discriminants using expressions, like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so some sort of accumulator could probably do it.  (If it <em>had</em> to be <code>C = 2</code> with a literal then yes, it would be at least very hard, AFAIK.)</p>\n<p>Though TBH if I was doing this I'd probably require the discriminants as a feature, since if you don't need to know what they are or don't care if they accidentally change than you probably don't need them to be c-enum-style.</p>",
        "id": 273682201,
        "sender_full_name": "scottmcm",
        "timestamp": 1646157160
    },
    {
        "content": "<p>That's how you get quadratic behavior.</p>",
        "id": 273682311,
        "sender_full_name": "The 8472",
        "timestamp": 1646157207
    },
    {
        "content": "<p>well if you're trying to make an enum to work with FFI you <em>almost always</em> want to specify the specific value of each variant anyway</p>",
        "id": 273682415,
        "sender_full_name": "Lokathor",
        "timestamp": 1646157240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60c_enum.60.20for.20ffi/near/273682311\">said</a>:</p>\n<blockquote>\n<p>That's how you get quadratic behavior.</p>\n</blockquote>\n<p>I mean, you can do <a href=\"https://github.com/rust-lang/rust/blob/f0c4da49983aa699f715caf681e3154b445fb60b/compiler/rustc_serialize/src/serialize.rs#L480-L491\">https://github.com/rust-lang/rust/blob/f0c4da49983aa699f715caf681e3154b445fb60b/compiler/rustc_serialize/src/serialize.rs#L480-L491</a> presumably?</p>",
        "id": 273682738,
        "sender_full_name": "simulacrum",
        "timestamp": 1646157352
    },
    {
        "content": "<p>And eventually just use <a href=\"https://github.com/rust-lang/rfcs/pull/3086\">https://github.com/rust-lang/rfcs/pull/3086</a></p>",
        "id": 273682892,
        "sender_full_name": "scottmcm",
        "timestamp": 1646157404
    }
]