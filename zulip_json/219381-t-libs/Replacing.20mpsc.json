[
    {
        "content": "<p>Hello. I've heard on-and-off that STD's MPSC implementation is due for replacement. While discussing this with a friend, I remembered that I'd written my own implementation a while ago: <a href=\"https://github.com/zesterer/flume\" target=\"_blank\" title=\"https://github.com/zesterer/flume\">https://github.com/zesterer/flume</a></p>\n<p>Advantages include:</p>\n<ul>\n<li>It beats std's mpsc in almost every benchmark I've thrown at it, often by a large margin. It's also competitive with crossbeam's mpsc.</li>\n<li>It uses no <code>unsafe</code>, so it's simple to audit</li>\n<li>It has no dependencies (except one that I can easily replace with stuff from <code>std::sync</code>)</li>\n<li>It's simple so it compiles very quickly</li>\n</ul>\n<p>I gather that the intention was to replace mpsc with crossbeam, but I feel that crossbeam isn't particularly suitable as a \"simple, general-purpose default\" owing to its complexity and frequent use of <code>unsafe</code>, and that my crate might be a suitable alternative with a bit of work to clean it up.</p>\n<p>Does anybody have any thoughts?</p>",
        "id": 190303524,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583944998
    },
    {
        "content": "<p>my initial thought is that we might want to deprecate std::mpsc instead of replacing it.</p>",
        "id": 190304571,
        "sender_full_name": "BurntSushi",
        "timestamp": 1583945590
    },
    {
        "content": "<p>Oh? For what reason?</p>",
        "id": 190304701,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583945651
    },
    {
        "content": "<p>Just removing things without replacing them sounds very poor</p>",
        "id": 190305130,
        "sender_full_name": "Lokathor",
        "timestamp": 1583945858
    },
    {
        "content": "<p>Personally, I think that a channel primitive in std is absolutely essential: Rust prides itself on being great for concurrent programming, and to not have at least a simple channel available in std would be quite detrimental to that reputation.</p>",
        "id": 190305596,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583946060
    },
    {
        "content": "<p>i don't really agree. but also don't really feel like having a grand debate either. the problems with mpsc extend beyond its implementation. others have penned more careful thoughts on this: <a href=\"https://stjepang.github.io/2019/03/02/new-channels.html\" target=\"_blank\" title=\"https://stjepang.github.io/2019/03/02/new-channels.html\">https://stjepang.github.io/2019/03/02/new-channels.html</a></p>",
        "id": 190305704,
        "sender_full_name": "BurntSushi",
        "timestamp": 1583946117
    },
    {
        "content": "<p>Oh, regarding a point raised in that article: Flume's <code>Sender</code> is <code>Sync</code>, unlike <code>std</code>'s <code>mpsc</code>.</p>",
        "id": 190305903,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583946223
    },
    {
        "content": "<blockquote>\n<p>I gather that the intention was to replace mpsc with crossbeam, but I feel that crossbeam isn't particularly suitable as a \"simple, general-purpose default\" owing to its complexity and frequent use of unsafe, and that my crate might be a suitable alternative with a bit of work to clean it up.</p>\n</blockquote>\n<p>I second this, esp. since crossbeam has had several soundness holes in the past, and probably has them now too, e.g. due to the use of memoffset</p>",
        "id": 190305935,
        "sender_full_name": "centril",
        "timestamp": 1583946238
    },
    {
        "content": "<p>I also agree that channels feel like a very basic thing you expect from a language, esp. from more functional crowds, e.g. say in Erlang.</p>",
        "id": 190306066,
        "sender_full_name": "centril",
        "timestamp": 1583946288
    },
    {
        "content": "<p>and given that we already have channels, why not work on improving them rather than deprecating them -- from the discussion so far, it didn't seem like the API boundary itself was so problematic.</p>",
        "id": 190306140,
        "sender_full_name": "centril",
        "timestamp": 1583946332
    },
    {
        "content": "<p>and even if we deprecate, we must ensure the current implementation is sound</p>",
        "id": 190306264,
        "sender_full_name": "centril",
        "timestamp": 1583946384
    },
    {
        "content": "<p>I agree: For me, I think that it's clear that compile times have become far and away the biggest (user-facing) problem for Rust: at least, user surveys seem to suggest that. A simpler mpsc implementation will go a long way to improving that, especially as mpsc appears to be prolific throughout the ecosystem.</p>",
        "id": 190306778,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583946634
    },
    {
        "content": "<p>Is there a process for proposed inclusions to std?</p>",
        "id": 190312751,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583949735
    },
    {
        "content": "<p>I think for this scale of a change I would suggest an issue to start off with and try to find someone on libs who agrees that we should replace mpsc with a more complete, better implementation if that's the road we want to go down</p>",
        "id": 190312994,
        "sender_full_name": "simulacrum",
        "timestamp": 1583949879
    },
    {
        "content": "<p>(I tend to feel that channels are pretty complex no matter where they are if done well, so maybe not having them in std is reasonable)</p>",
        "id": 190313050,
        "sender_full_name": "simulacrum",
        "timestamp": 1583949910
    },
    {
        "content": "<p>Not having them in std is not really an option though at this point; we have them, at most we can deprecate, but they still must be sound regardless</p>",
        "id": 190316263,
        "sender_full_name": "centril",
        "timestamp": 1583951791
    },
    {
        "content": "<blockquote>\n<p>It beats std's mpsc in almost every benchmark I've thrown at it, often by a large margin. It's also competitive with crossbeam's mpsc.</p>\n</blockquote>\n<p>I see that you're using <code>spin::Mutex&lt;VecDeque&lt;T&gt;&gt;</code> -- it seems like that could have some bad edge cases, like a <code>send</code> requiring allocation while another thread spins trying to <code>recv</code></p>",
        "id": 190319618,
        "sender_full_name": "cuviper",
        "timestamp": 1583953781
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> The crate is designed such that it attempts to spin with exponential backoff for a very short period, and then uses a condvar to enter into a scheduler-driven sleep until the mutex is available. In effect, it never hits that \"bad edge case\".</p>",
        "id": 190320057,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583954006
    },
    {
        "content": "<p>I'm talking about blocking on <code>self.queue.lock()</code> -- unless you mean <code>spin</code> has the backoff?</p>",
        "id": 190320422,
        "sender_full_name": "cuviper",
        "timestamp": 1583954197
    },
    {
        "content": "<p>(I don't think it does)</p>",
        "id": 190320434,
        "sender_full_name": "cuviper",
        "timestamp": 1583954205
    },
    {
        "content": "<p>I've implementing the backoff within the crate: <code>.recv()</code> Checks the mutex once, then does some spinning and backoff for a few ns, and then finally if the mutex still isn't available it enters into a sleep.</p>",
        "id": 190320650,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583954355
    },
    {
        "content": "<p>I'm not talking about having items available in the channel queue, but lower level:</p>\n<ul>\n<li><code>send</code> unconditionally acquires the lock, then pushes the value, which could take a while for allocation</li>\n<li><code>try_recv</code> unconditionally acquires the same lock, which will spin the CPU until available</li>\n</ul>",
        "id": 190321447,
        "sender_full_name": "cuviper",
        "timestamp": 1583954875
    },
    {
        "content": "<p>I'll address these issues.</p>",
        "id": 190321620,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583954979
    },
    {
        "content": "<p>anyway, the larger point is that there are benefits <em>and</em> trade-offs in choices like these, which are hard to balance for everyone in <code>std</code></p>",
        "id": 190321901,
        "sender_full_name": "cuviper",
        "timestamp": 1583955124
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> when has there ever not been benefits and trade-offs in std/language/...? ;)</p>",
        "id": 190322449,
        "sender_full_name": "centril",
        "timestamp": 1583955478
    },
    {
        "content": "<p>That's fair. Are there any specific use-cases you'd be interested in me trying to benchmark?</p>",
        "id": 190322520,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583955500
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> ok fine, but universal truths are still true</p>",
        "id": 190325037,
        "sender_full_name": "cuviper",
        "timestamp": 1583956966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> have you tried porting all of crossbeam's benchmarks? e.g. their mpmc seems like it could bottleneck</p>",
        "id": 190325131,
        "sender_full_name": "cuviper",
        "timestamp": 1583957041
    },
    {
        "content": "<p>and I'd be interested in scalability too, on many-CPU machines if you can</p>",
        "id": 190325330,
        "sender_full_name": "cuviper",
        "timestamp": 1583957142
    },
    {
        "content": "<p>I'll look into that, for sure. I've just done a tonne of refactoring, fixing the issues you mentioned. I'm getting significantly better results now. I'll have a go at porting crossbeam's benchmarks as you say. Right now, I'm testing this on a 4 physical / 8 logical Ryzen 7 machine.</p>",
        "id": 190326631,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583957986
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> yes, but I think deciding whether we want a good impl in std is the first question to ask. of course it should be correct, but that's secondary</p>",
        "id": 190328906,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959167
    },
    {
        "content": "<p>if we were to deprecate I would advocate for replacing with something like Mutex&lt;VecDeque&lt;T&gt;&gt; in fact, simplest possible and still decently good enough for most cases (e.g. low-volume channels)</p>",
        "id": 190328996,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959205
    },
    {
        "content": "<p>I don't feel strongly that it needs to be a competitive impl myself; but that it should exist, not be deprecated, and should be correct (and focus on that, even if that makes it somewhat slower)</p>",
        "id": 190329009,
        "sender_full_name": "centril",
        "timestamp": 1583959218
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span></p>",
        "id": 190329010,
        "sender_full_name": "Amanieu",
        "timestamp": 1583959219
    },
    {
        "content": "<p>in some sense if we're fine with a non-competitive impl, I think the calculus changes: it's much easier to approve a noncompetitive replacement</p>",
        "id": 190329053,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959261
    },
    {
        "content": "<p>otoh, there's some question in my mind about channels even being a fundamental building block (unlike, e.g., Mutex, Condvar)</p>",
        "id": 190329075,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959285
    },
    {
        "content": "<p>Do they need to be a fundamental building block though?</p>",
        "id": 190329121,
        "sender_full_name": "centril",
        "timestamp": 1583959317
    },
    {
        "content": "<p>I think a lot of folks expect channels to be there as an important tool in building stuff</p>",
        "id": 190329171,
        "sender_full_name": "centril",
        "timestamp": 1583959342
    },
    {
        "content": "<p>even if they are not fundamental in the \"decomposition\" sense</p>",
        "id": 190329177,
        "sender_full_name": "centril",
        "timestamp": 1583959350
    },
    {
        "content": "<p>I think it's an open question in my mind whether deprecating is worse than replacing with a \"slow\" (but definitely correct) impl.</p>",
        "id": 190329368,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959460
    },
    {
        "content": "<p>How slow are we talking? ;)</p>",
        "id": 190329456,
        "sender_full_name": "centril",
        "timestamp": 1583959536
    },
    {
        "content": "<p>I mean, IMO, plenty fast</p>",
        "id": 190329490,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959559
    },
    {
        "content": "<p>but I don't think I've ever worked with an application in Rust using channels for something that sends particularly often</p>",
        "id": 190329546,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959580
    },
    {
        "content": "<p>(I don't have numbers, but I'd guess roughly in the ballpark of 1000 msgs/second is what you'd get with a Mutex with light contention. I could be wrong.)</p>",
        "id": 190329587,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959621
    },
    {
        "content": "<p>Doesn't servo use channels intensively?</p>",
        "id": 190329741,
        "sender_full_name": "Amanieu",
        "timestamp": 1583959723
    },
    {
        "content": "<p>So I think the message passing idiom is important to support in the standard library in some manner; it's a convenient form of writing code, and I don't think you should have to use crossbeam for this</p>",
        "id": 190329758,
        "sender_full_name": "centril",
        "timestamp": 1583959738
    },
    {
        "content": "<p>I think deprecating mpsc is the wrong move. Just because it isn't the best implementation, doesn't mean it isn't good enough for most people, and having mpsc builtin has been immensely useful.</p>",
        "id": 190329765,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1583959744
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> I think any heavy user of channels today would presumably not be using mpsc from std, since it's not the best out there performance wise (or usability wise)</p>",
        "id": 190329789,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959770
    },
    {
        "content": "<p>it sounded like we could make usability improvements though</p>",
        "id": 190329824,
        "sender_full_name": "centril",
        "timestamp": 1583959800
    },
    {
        "content": "<p>I'm not too familiar with mspc from std. Is there a fundamental issue with the current API that would require us to deprecate it?</p>",
        "id": 190329875,
        "sender_full_name": "Amanieu",
        "timestamp": 1583959812
    },
    {
        "content": "<p>specialized apps will always want a more specialized impl for things though</p>",
        "id": 190329895,
        "sender_full_name": "centril",
        "timestamp": 1583959826
    },
    {
        "content": "<p>If it's just that the implementation is slow, then we should improve/replace the implementation, not deprecate the API.</p>",
        "id": 190329917,
        "sender_full_name": "Amanieu",
        "timestamp": 1583959849
    },
    {
        "content": "<p>I know the API is clunky and not very nice, but I have not looked too much at whether we can improve it without breakage</p>",
        "id": 190329943,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959875
    },
    {
        "content": "<p>I believe there are correctness concerns wrt. the impl, not just slowness</p>",
        "id": 190329959,
        "sender_full_name": "centril",
        "timestamp": 1583959880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> It is definitely a worse API in a lot of ways that for example <code>crossbeam</code> isn't.</p>",
        "id": 190329963,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1583959882
    },
    {
        "content": "<p>Like, <code>Vec&lt;T&gt;</code> exists, but <code>SmallVec&lt;[T; N]&gt;</code> is often used for specialized cases as well</p>",
        "id": 190330011,
        "sender_full_name": "centril",
        "timestamp": 1583959914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"126931\">centril</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20mpsc/near/190329959\" title=\"#narrow/stream/219381-t-libs/topic/Replacing.20mpsc/near/190329959\">said</a>:</p>\n<blockquote>\n<p>I believe there are correctness concerns wrt. the impl, not just slowness</p>\n</blockquote>\n<p>This is definitely true. e.g. I know Cargo recently replaced channels with Mutex&lt;VecDeque&lt;T&gt;&gt; because we were hitting a deadlock or something like that and didn't want to try to fix it</p>",
        "id": 190330071,
        "sender_full_name": "simulacrum",
        "timestamp": 1583959930
    },
    {
        "content": "<p>Well it's not just specialised cases. <code>mpsc::Sender</code> is <code>!Sync</code>. <code>crossbeam_channel::Sender</code> is <code>Sync</code>.</p>",
        "id": 190330146,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1583959993
    },
    {
        "content": "<p>This is big limitation in the API imo.</p>",
        "id": 190330185,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1583960015
    },
    {
        "content": "<p>I think at the very least we should have a mpmc impl in std if we believe channels to be important enough (which is naturally more general than mpsc). To my knowledge, if we don't aim for performance (and I think there's no need to ; as Centril notes any use case that wants to be super performant is likely going to want a more specialized impl for its particular conditions), then a  mpmc impl should be relatively straightforward.</p>",
        "id": 190330203,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960029
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> it is <code>Send</code>, but not <code>Sync</code></p>",
        "id": 190330257,
        "sender_full_name": "cuviper",
        "timestamp": 1583960046
    },
    {
        "content": "<p>and since putting mpmc inside the existing mpsc impl seems... odd, presumably we'd deprecate and replace</p>",
        "id": 190330261,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960049
    },
    {
        "content": "<p>It sounded like the auto trait situation was fixable from what <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> said</p>",
        "id": 190330279,
        "sender_full_name": "centril",
        "timestamp": 1583960062
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> god damn it, yes sorry.</p>",
        "id": 190330282,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1583960064
    },
    {
        "content": "<p>Always mix them up <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 190330302,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1583960089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> of course it is? like it's trivially true that you can write a mpmc Send/Sync pieces channel</p>",
        "id": 190330325,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960109
    },
    {
        "content": "<p>but to do so would need changes internally, and I don't think we can modify the existing impl -- it's too big and no one knows it well enough to review that change</p>",
        "id": 190330356,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960140
    },
    {
        "content": "<p>right but if we replace the impl</p>",
        "id": 190330377,
        "sender_full_name": "centril",
        "timestamp": 1583960158
    },
    {
        "content": "<p>This feels similar to the move to replace std's Mutex with parking_lot::Mutex. Basically std::sync::Mutex will end up as a wrapper around parking_lot::Mutex, but with a \"worse\" API since it is already stable. (\"worse\" in this case refers to poisoning, which nobody cares about, but that's off-topic)</p>",
        "id": 190330406,
        "sender_full_name": "Amanieu",
        "timestamp": 1583960163
    },
    {
        "content": "<p>which I think was one of the proposals</p>",
        "id": 190330429,
        "sender_full_name": "centril",
        "timestamp": 1583960170
    },
    {
        "content": "<p>So I believe there's a couple proposals floating around:</p>\n<ol>\n<li>replace the existing impl with a trivially correct mpmc impl, fixing API warts (lack of Sync, mpsc vs. mpmc, etc.)</li>\n<li>replace existing impl with a mpsc impl (fast or slow)</li>\n<li>deprecating mpsc module in std, directing people to <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a></li>\n</ol>",
        "id": 190330578,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960276
    },
    {
        "content": "<p>I've just pushed a big refactor of Flume to the repo. I'm getting... bizarrely impressive results. I'm skeptical of the quality of my benchmarks (I've yet to port <code>crossbeam</code>'s), but the benchmarks I have show performance easily on-par with <code>crossbeam</code>. I'm not going to take that at face value without more rugged testing, but still. Just thought I'd mention it.</p>",
        "id": 190330646,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583960300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> one thing to be super cautious about is that if you're just using a spinlock you'll be 'trivially great' but that doesn't necessarily mean you're actually good</p>",
        "id": 190330710,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960343
    },
    {
        "content": "<p>i.e., spinlocks can be horrible under contention but have great latency so lead to misleading results</p>",
        "id": 190330783,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960381
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> That's true, although I'm not \"just\" using spinlocks: There is exponential backoff and a condvar-based blocking system to compliment it.</p>",
        "id": 190330949,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583960436
    },
    {
        "content": "<p>sure, yes, I'm not saying there's necessarily a problem :)</p>",
        "id": 190330974,
        "sender_full_name": "simulacrum",
        "timestamp": 1583960455
    },
    {
        "content": "<p>I've just published a new version of the crate that resolves the problems <span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> pointed out. The new benchmarks seem promising (although I've not yet ported <code>crossbeam_channel</code>'s benchmarks). The only thing that holds it back from being API-compatible with <code>std</code>'s <code>mpsc</code> is the lack of <code>SyncSender</code>, but I'll be adding that soon.</p>",
        "id": 190346483,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583972535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> fwiw, SyncSender IMO is an API wart, but if you really mean bounded channels, then those are indeed necessary</p>",
        "id": 190347299,
        "sender_full_name": "simulacrum",
        "timestamp": 1583973590
    },
    {
        "content": "<p>(basically ideally IMO you'd not have a separate type for bounded channels on the sender half)</p>",
        "id": 190347349,
        "sender_full_name": "simulacrum",
        "timestamp": 1583973610
    },
    {
        "content": "<p>I did some experimental work making the channel bounded by default, but I'm probably going to redo the work since it had a few issues. I'll definitely be avoiding separate types for both. <code>SyncSender</code> can just be a thin wrapper around <code>Sender</code>.</p>",
        "id": 190347434,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583973739
    },
    {
        "content": "<p>Sure, yes, I think the ideal is basically just <code>struct SyncSender(Sender);</code> and forwarding all the 2(?) methods</p>",
        "id": 190347547,
        "sender_full_name": "simulacrum",
        "timestamp": 1583973868
    },
    {
        "content": "<p>I think due to backwards compat reasons we can't straight up make them aliases anyway in std, but there's no reason for external libraries to make the same mistakes</p>",
        "id": 190347559,
        "sender_full_name": "simulacrum",
        "timestamp": 1583973894
    },
    {
        "content": "<p>I'd also be in favour of adding a <code>channel</code> module to <code>std::sync</code> (or just <code>std</code>) that exposes the same code but with a much cleaner interface.</p>",
        "id": 190347728,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1583974106
    },
    {
        "content": "<p>in my view, the problem with mpsc is that it is mpsc. it's such a strange and specialized primitive with weird cliffs. \"oh, you want to have multiple consumers? ah okay, then either go use crossbeam or wrap your single consuming channel in a mutex and share it that way.\" it's a lot of friction. it's also missing key primitives like <code>select!</code> which crossbeam-channel has. all of these are, IMO, serious deficiencies. there are very few scenarios i can think of where i'd recommend someone use <code>std::sync::mpsc</code> over crossbeam-channel. this is why i brought up deprecation. i think we should either deprecate (or similarish) and leave it to <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a>, or more long term, eventually bring crossbeam's mpmc channels into std. although i lean more towards the former.</p>\n<p>i am unconvinced by arguments about compile times because this is not generally a criterion we've used when determining whether something should go in std. i'm more swayed by \"channels are core primitives that belong in std,\" but we could say that about a lot of things that aren't in std: random number generation, automatic serialization support, and so on. if channels were things that appeared more frequently in public APIs, then i think i'd find this argument more compelling. but they are usually implementation details that do not require libraries to agree on the same channel implementation.</p>\n<p>much of the complexity from the existing mpsc implementation in std, AIUI, was from supporting <code>select!</code>, but that's gone now. <span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span>  <a href=\"https://github.com/rust-lang/rust/pull/42397#issuecomment-315881774\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/42397#issuecomment-315881774\">noted this a while back</a>. it seems to me like just replacing the existing implementation with something simpler now that <code>select!</code> is gone is probably fine. it seems reasonable to treat that as orthogonal from the deprecation question. i think the most important bits there are 1) ensuring all semantics remain the same such that there are no breaking changes and 2) performance is roughly competitive, particularly under contention. IIRC, crossbeam-channel has some good benchmarking here. cc <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span></p>",
        "id": 190385705,
        "sender_full_name": "BurntSushi",
        "timestamp": 1584017722
    },
    {
        "content": "<p>It is true that some of the current implementation's complexity comes from select! support, but it's also sufficiently embedded without an easy way to pull it apart -- also, there's not really anyone who can review those changes to my knowledge (without re-learning the whole implementation, pretty much). That makes me hesitant to treat \"let's fix the current impl\" as viable, which means we need something essentially fully new. Maybe that means just deprecating and pointing at <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a> for channels -- that's fine with me -- maybe it means deprecating std and replacing with a (relatively) slower and much simpler mutex-based channel abstraction.</p>",
        "id": 190386846,
        "sender_full_name": "simulacrum",
        "timestamp": 1584018423
    },
    {
        "content": "<p>There are also a couple of longstanding bugs with recv_timeout iirc</p>",
        "id": 190386911,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1584018472
    },
    {
        "content": "<p>If the problem is with mpsc rather than mpmc, then we could ostensibly still use most of the same API but reexport it under <code>::channels</code> or something and just deprecate the old path, but not deprecate channels in std overall</p>",
        "id": 190387067,
        "sender_full_name": "centril",
        "timestamp": 1584018548
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> i think we're on the same page?</p>",
        "id": 190387120,
        "sender_full_name": "BurntSushi",
        "timestamp": 1584018590
    },
    {
        "content": "<p>I think we're on the same page up to whether we should have a good impl in std. I personally don't think it's necessary, I would be in favor of deprecating the existing impl (and maybe replacing it with a relatively unperformant one, just to fix bugs, though I'm not even sure about doing that).</p>",
        "id": 190387314,
        "sender_full_name": "simulacrum",
        "timestamp": 1584018711
    },
    {
        "content": "<p>I basically don't think a patchwork fix is going to cut it for std, no one knows the channel impl in std well enough, and that means a wholesale replacement, and I personally don't think channels are important enough to be in std for us to motivate seeking out a good implementation and such, especially as there's quite a few different knobs to tune</p>",
        "id": 190387471,
        "sender_full_name": "simulacrum",
        "timestamp": 1584018834
    },
    {
        "content": "<p>I would find references to rng, serialization, etc. more compelling if channels weren't already in std; but they are, so I think providing a rock solid definitely-correct-&amp;-sound implementation is valuable</p>",
        "id": 190387493,
        "sender_full_name": "centril",
        "timestamp": 1584018842
    },
    {
        "content": "<p>(and by rock solid I don't necessarily mean competitive with crossbeam in terms of perf)</p>",
        "id": 190387561,
        "sender_full_name": "centril",
        "timestamp": 1584018882
    },
    {
        "content": "<p>I personally don't consider current inclusion to be meaningful -- it is mostly because in the (distant) past channels were considered \"the\" primitive for concurrency in Rust. These days, that's definitely not true I think.</p>",
        "id": 190387621,
        "sender_full_name": "simulacrum",
        "timestamp": 1584018912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> sorry, just to clarify, i'm not suggesting we do a patchwork thing here.</p>",
        "id": 190387642,
        "sender_full_name": "BurntSushi",
        "timestamp": 1584018928
    },
    {
        "content": "<p>Ah. Okay. Then I agree we are on the same page about the options, though I think that the right path forward is a deprecation without in-std replacement. I'm not sure if you agree.</p>",
        "id": 190388059,
        "sender_full_name": "simulacrum",
        "timestamp": 1584019222
    },
    {
        "content": "<p>(good replacement that is, which would be competitive performance wise)</p>",
        "id": 190388116,
        "sender_full_name": "simulacrum",
        "timestamp": 1584019260
    },
    {
        "content": "<p>yeah, that's where i lean.</p>",
        "id": 190388262,
        "sender_full_name": "BurntSushi",
        "timestamp": 1584019358
    },
    {
        "content": "<p>I think it flies in the face of our stability message and our \"concurrency made easy\" message if a stable module in the standard library is deprecated and people are told to just go scrounge through <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a> for the current best crate (which is probably an unstable crate).</p>",
        "id": 190406479,
        "sender_full_name": "Lokathor",
        "timestamp": 1584028486
    },
    {
        "content": "<p>I would definitely at this point say that the right API for channels is still somewhat of an open question, so adding another API to std would feel premature. Whether we deprecate std mpsc or not after replacing the innards with a slowish impl is a hard question, I agree. I would suspect that having it not be deprecated implies that it's the right thing to reach for though which is never going to be true in the short term at least.</p>\n<p>I also think if we just don't have a good implementation that's 1.0 in the ecosystem maybe that's something to acknowledge and deprecating the std module may drive people to innovate (otherwise, you're competing with std... and likely winning in some sense, but still a bit unfortunate).</p>",
        "id": 190408792,
        "sender_full_name": "simulacrum",
        "timestamp": 1584029443
    },
    {
        "content": "<p>Why should we replace mpsc with a slow implementation? Is it just because of the maintenance burden? If that's the only concern then we could do the same thing we did with <code>hashbrown</code>: <code>std</code> would add <code>crossbeam-channel</code> as a dependency and <code>mpsc</code> would be a wrapper around it.</p>",
        "id": 190412999,
        "sender_full_name": "Amanieu",
        "timestamp": 1584031407
    },
    {
        "content": "<p>Deprecating mpsc is a separate decision. I don't think we should mix the two together.</p>",
        "id": 190413129,
        "sender_full_name": "Amanieu",
        "timestamp": 1584031450
    },
    {
        "content": "<p>Well if we deprecate then a slow and simple impl means let code to vet, meaning we can be more confident in the soundness, etc.</p>",
        "id": 190416427,
        "sender_full_name": "centril",
        "timestamp": 1584032939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> because the current implementation is broken in subtle ways</p>",
        "id": 190417896,
        "sender_full_name": "simulacrum",
        "timestamp": 1584033731
    },
    {
        "content": "<p>(no known soundness holes, but deadlocks and panics are definitely known, if not easily reproducible)</p>",
        "id": 190417936,
        "sender_full_name": "simulacrum",
        "timestamp": 1584033755
    },
    {
        "content": "<p>I'd prefer replacing the implementation with a wrapper around <code>crossbeam-channel</code>. It would avoid any issues in case someone is relying on the performance of <code>mpsc</code>.</p>",
        "id": 190418215,
        "sender_full_name": "Amanieu",
        "timestamp": 1584033881
    },
    {
        "content": "<p>I'm not so sure that a compromise between both positions is necessary. <code>std</code>'s <code>mpsc</code> is not particularly fast and from what I can see; trivial implementations can outpace it without much work. I'm sure there are corner cases that need smoothing that I've not considered, but I've not found anything insummountable so far.</p>",
        "id": 190418487,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584033998
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> if wrapping crossbeam-channel (or another, perhaps safer, crate) is viable, then that seems like a good path forward to me. My main worry there is that we may not have time to invest in reviewing the (new) implementation.</p>\n<p>I believe <span class=\"user-mention\" data-user-id=\"126931\">@centril</span> at least has historically been against wrapping crossbeam's channels directly, but I don't know that we have good reasons not to do so.</p>",
        "id": 190418725,
        "sender_full_name": "simulacrum",
        "timestamp": 1584034107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20mpsc/near/190418725\" title=\"#narrow/stream/219381-t-libs/topic/Replacing.20mpsc/near/190418725\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> if wrapping crossbeam-channel (or another, perhaps safer, crate) is viable, then that seems like a good path forward to me. My main worry there is that we may not have time to invest in reviewing the (new) implementation.</p>\n<p>I believe <span class=\"user-mention silent\" data-user-id=\"126931\">centril</span> at least has historically been against wrapping crossbeam's channels directly, but I don't know that we have good reasons not to do so.</p>\n</blockquote>\n<p>I don't know that I have had thoughts about this really. But the point made earlier in this topic about crossbeam's use of unsafe is apt. See e.g, <a href=\"https://github.com/crossbeam-rs/crossbeam/issues/315\" target=\"_blank\" title=\"https://github.com/crossbeam-rs/crossbeam/issues/315\">https://github.com/crossbeam-rs/crossbeam/issues/315</a>, its use of memoffset, etc. for problematic cases.</p>",
        "id": 190419004,
        "sender_full_name": "centril",
        "timestamp": 1584034232
    },
    {
        "content": "<p>So if we wrap it, then I think crossbeam needs to go though reviews, and add appropriate <code>// SAFETY:</code> rationales</p>",
        "id": 190419129,
        "sender_full_name": "centril",
        "timestamp": 1584034289
    },
    {
        "content": "<p>I just checked crossbeam-channel and it doesn't seem to support <code>#[no_std]</code>, which would be a requirement for including it as a dependency of <code>std</code>. As such maybe we should consider <code>flume</code> instead (which has a very simple &amp; easy to review implementation).</p>",
        "id": 190421697,
        "sender_full_name": "Amanieu",
        "timestamp": 1584035375
    },
    {
        "content": "<p>Ah nevermind, we can't use an external crate as a dependency due to the use of <code>Instant</code> in the <code>mpsc</code> API. This is the same issue that <code>parking_lot</code> encountered.</p>",
        "id": 190421850,
        "sender_full_name": "Amanieu",
        "timestamp": 1584035434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> can you tl;dr the Instant problem?</p>",
        "id": 190422264,
        "sender_full_name": "centril",
        "timestamp": 1584035602
    },
    {
        "content": "<p><code>Instant</code> is defined in libstd. So libstd can't depend on a crate that uses <code>Instant</code> since that would lead to a circular dependency.</p>",
        "id": 190422394,
        "sender_full_name": "Amanieu",
        "timestamp": 1584035643
    },
    {
        "content": "<p>Basically crates that libstd depends on (<code>hashbrown</code>, <code>backtrace</code>, etc) must be <code>#[no_std} + alloc</code>.</p>",
        "id": 190422470,
        "sender_full_name": "Amanieu",
        "timestamp": 1584035665
    },
    {
        "content": "<p>The plan with <code>parking_lot</code> was to use a submodule which is injected directly in the libstd crate. It would be similar to the way <code>stdarch</code> is included in <code>libcore</code>.</p>",
        "id": 190422610,
        "sender_full_name": "Amanieu",
        "timestamp": 1584035726
    },
    {
        "content": "<p>Ah, that's hacky, but it seems like it would work :D</p>",
        "id": 190423146,
        "sender_full_name": "centril",
        "timestamp": 1584035920
    },
    {
        "content": "<p>flume is fairly small. we could just copy it.</p>",
        "id": 190429034,
        "sender_full_name": "BurntSushi",
        "timestamp": 1584038936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> I just tested the <code>0.3.1</code> release of <code>flume</code> in <code>tokei</code>. I didn't notice any speed bumps compared to crossbeam, but it wasn't  really slower either, which I think is pretty positive considering it's relatively new implementation. I've pasted the hyperfine test results below.</p>\n<ul>\n<li><code>target/release/tokei</code> — built with flume</li>\n<li><code>tokei</code> — Current released version</li>\n</ul>\n<h3>Rust Repo (93102 files)</h3>\n<div class=\"codehilite\"><pre><span></span><span class=\"go\">Benchmark #1: target/release/tokei ../rust</span>\n<span class=\"go\">  Time (mean ± σ):      3.410 s ±  0.113 s    [User: 11.471 s, System: 5.096 s]</span>\n<span class=\"go\">  Range (min … max):    3.253 s …  3.676 s    10 runs</span>\n\n<span class=\"go\">Benchmark #2: tokei ../rust</span>\n<span class=\"go\">  Time (mean ± σ):      3.286 s ±  0.260 s    [User: 10.967 s, System: 5.305 s]</span>\n<span class=\"go\">  Range (min … max):    2.882 s …  3.676 s    10 runs</span>\n\n<span class=\"go\">Summary</span>\n<span class=\"go\">  &#39;tokei ../rust&#39; ran</span>\n<span class=\"go\">    1.04 ± 0.09 times faster than &#39;target/release/tokei ../rust&#39;</span>\n</pre></div>\n\n\n<h3>UnrealEngine (117857 files)</h3>\n<div class=\"codehilite\"><pre><span></span><span class=\"go\">Benchmark #1: target/release/tokei ../../UnrealEngine</span>\n<span class=\"go\">  Time (mean ± σ):      5.453 s ±  0.167 s    [User: 22.769 s, System: 6.960 s]</span>\n<span class=\"go\">  Range (min … max):    5.157 s …  5.679 s    10 runs</span>\n\n<span class=\"go\">Benchmark #2: tokei ../../UnrealEngine</span>\n<span class=\"go\">  Time (mean ± σ):      5.078 s ±  0.224 s    [User: 21.323 s, System: 6.965 s]</span>\n<span class=\"go\">  Range (min … max):    4.883 s …  5.615 s    10 runs</span>\n\n<span class=\"go\">Summary</span>\n<span class=\"go\">  &#39;tokei ../../UnrealEngine&#39; ran</span>\n<span class=\"go\">    1.07 ± 0.06 times faster than &#39;target/release/tokei ../../UnrealEngine&#39;</span>\n</pre></div>",
        "id": 190467249,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1584069152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> That's good news! Any chance you could get a similar benchmark with std's mpsc? It seems that std's is extremely good at single use one-shot channels and rapid channel construction. From what I can see flume improves upon crossbeam a lot for such use-cases, but it's still the use-case that flume seems to fall behind std in.</p>\n<p>I've not focussed too much on this use-case yet since I feel that it's a forgivable issue when compared to speed improvements elsewhere and is unlikely to be a bottleneck (who in their right mind is creating millions of queues per second?!) but I think there's more I can do on this front regardless.</p>",
        "id": 190484283,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584091331
    },
    {
        "content": "<p>I've gone over Flume's code, fully documenting everything.</p>",
        "id": 190488572,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584095169
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> Hmm, testing <code>std::mpsc</code> gives similar performance, I remember when I originally added <code>crossbeam</code> it was a noticable speed bump, but it seems like the channels aren't any kind of bottleneck anymore in tokei.</p>",
        "id": 190590889,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1584181107
    },
    {
        "content": "<p>I've just added experimental support for bounded queues, as well as implementing <code>Sync</code> for <code>Sender</code>s (I previously didn't permit sharing senders since I was not certain that it was possible, but I've now confirmed that it is). Contrary to my expectations, it didn't have as much of an impact on performance as I initially imagined. As far as I can tell, this puts <code>flume</code> at feature parity with <code>std</code>'s <code>mpsc</code>.</p>",
        "id": 190621052,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584230420
    },
    {
        "content": "<p>Bounded queue support is now properly working and is in the latest release.</p>",
        "id": 190656561,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584292318
    },
    {
        "content": "<p>I've also added experimental support for a <code>select!</code>-like interface. It supports sending and receiving.</p>",
        "id": 190878192,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584463975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222471\">@BurntSushi</span> Do you have any thoughts on <code>async</code> support being in <code>std</code>'s mpscs? It's being added to <code>flume</code> and it turns out that the implementation is pretty trivial.</p>",
        "id": 191243674,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584711757
    },
    {
        "content": "<p>hi! on this subject, the other options would be 1. remove it from whatever version of flume gets into std or 2. do 1, but also use async flume to replace futures's channels (from my small tests it is a lot faster)</p>",
        "id": 191244158,
        "sender_full_name": "Restioson",
        "timestamp": 1584712042
    },
    {
        "content": "<p>update on flume - catching up to crossbeam on windows and linux now in many benches in some branches</p>",
        "id": 191348577,
        "sender_full_name": "Restioson",
        "timestamp": 1584801416
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222471\">@BurntSushi</span> Did you happen to have that benchmark you did for Reddit hanging around? We've spent the last week optimising Flume and I was wondering if we could run it up against the latest version.</p>",
        "id": 191405856,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584897107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> which benchmark? can you share the reddit link?</p>",
        "id": 191406431,
        "sender_full_name": "BurntSushi",
        "timestamp": 1584897812
    },
    {
        "content": "<p>Apologies, I managed to get you confused with <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> .</p>",
        "id": 191407264,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584898987
    },
    {
        "content": "<p>I've now run the benchmarks, results are here: <a href=\"https://github.com/crossbeam-rs/crossbeam/pull/481\" target=\"_blank\" title=\"https://github.com/crossbeam-rs/crossbeam/pull/481\">https://github.com/crossbeam-rs/crossbeam/pull/481</a></p>",
        "id": 191411334,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1584904363
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/70340\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/70340\">https://github.com/rust-lang/rust/issues/70340</a> (just dropping here...)</p>",
        "id": 191550908,
        "sender_full_name": "simulacrum",
        "timestamp": 1585005897
    },
    {
        "content": "<p>I've been doing some work recently on the <code>flavour-refactor</code> branch of Flume (<a href=\"https://github.com/zesterer/flume/tree/flavour-refactor\" title=\"https://github.com/zesterer/flume/tree/flavour-refactor\">https://github.com/zesterer/flume/tree/flavour-refactor</a>). It massively simplifies a lot of the internals and fixes all existing issues that I'm aware of (expanding the test suite too). It's not merged to <code>master</code> yet owning to the fact that is lacks <code>async</code> and <code>select</code> support at the moment, but I'm fairly happy with the implementation regarding features that would be needed for it to replace <code>std::sync::mpsc</code>. It brings a lot of very useful features to Flume:</p>\n<ul>\n<li><code>Sender</code> and <code>Receiver</code> are both <code>Sync + Send</code></li>\n<li>MPMC is now supported (i.e: you can clone a <code>Receiver</code>)</li>\n<li><code>send_timeout</code>/<code>send_deadline</code></li>\n<li>Rendezvous channels are now working great</li>\n</ul>\n<p>As far as I'm aware, this addresses all of the wishlist items in <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> 's 'New Channels' proposal that can be found here: <a href=\"https://stjepang.github.io/2019/03/02/new-channels.html\" title=\"https://stjepang.github.io/2019/03/02/new-channels.html\">https://stjepang.github.io/2019/03/02/new-channels.html</a></p>\n<p>It's also performing pretty well on benchmarks (both our now fairly extensive benchmark suite, and <code>crossbeam-channel</code>'s benchmarks). I think there's still more that can be done with the performance of rendezvous and low-bound channels (something I'd love to talk with <span class=\"user-mention\" data-user-id=\"128448\">@stjepang</span> about), but it's at least beating <code>std::sync::mpsc</code> on every benchmark with at least a ~50% margin (and by much, much more on most).</p>\n<p>This implementation isn't \"ready\" yet (I still need to adjust some things to make sure it performs similarly on non-POSIX platforms) but I'd say that it's in a good state for an initial review, should anybody be interested.</p>",
        "id": 196715972,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1588812392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> Great work! :) Btw, crossbeam-channel has a very extensive test suite (380 tests total!). I suggest stealing those and porting to flume to make sure the codebase is correct (it shouldn't be too much work, it's mostly copy-paste). Some of those tests are from the standard library and some are from the Go codebase. If you pass those tests (and use <code>SeqCst</code> whenever in doubt about memory orderings), you can be 99.99% confident flume is correct. </p>\n<p>Regarding performance, it seems channels with large capacity are plenty fast already and only low-capacity channels are left to improve. I think what could help is to expose <code>head</code> and <code>tail</code> (<code>AtomicUsize</code>s) outside the main channel mutex. That way, send/receive operation can check whether they can make progress or not without locking any mutexes. So perhaps you could restructure channels as follows:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">head</span>: <span class=\"nc\">AtomicUsize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"n\">tail</span>: <span class=\"nc\">AtomicUsize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"n\">buffer</span>: <span class=\"nc\">Mutex</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"n\">sig_depot</span>: <span class=\"nc\">Depot</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196750960,
        "sender_full_name": "stjepang",
        "timestamp": 1588846835
    },
    {
        "content": "<p>Thanks for the advice! I might try special-casing channels under a certain capacity in the hope of gaining some performance wins.</p>\n<p>I just ported all of the <code>crossbeam-channel</code> tests (with the exception of those that required <code>select!</code> since I've not yet reimplemented it). The tests caught a few minor bugs that I'd missed during refactoring (forgetting to rename error variants, etc.), but otherwise everything passes, so that's nice.</p>",
        "id": 196790498,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1588866470
    },
    {
        "content": "<p>If possible, try running that on an an architecture with weaker memory ordering too</p>",
        "id": 196798080,
        "sender_full_name": "cuviper",
        "timestamp": 1588869933
    },
    {
        "content": "<p>if someone can point me at a specific repo to just clone and \"cargo test\" i can run it on my raspberry pi, i'm told that ARM has a weaker memory ordering than the Intel chips.</p>",
        "id": 196800739,
        "sender_full_name": "Lokathor",
        "timestamp": 1588871072
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <code>git clone git@github.com:zesterer/flume.git &amp;&amp; git checkout flavour-refactor &amp;&amp; cargo test</code></p>",
        "id": 196804708,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1588872847
    },
    {
        "content": "<p>I just went to try that on a big POWER9 (128 cpus), but there are a bunch of compilation errors</p>",
        "id": 196849478,
        "sender_full_name": "cuviper",
        "timestamp": 1588900622
    },
    {
        "content": "<p>unknown fields, methods not found -- seems to be in a bad state</p>",
        "id": 196849502,
        "sender_full_name": "cuviper",
        "timestamp": 1588900649
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> Could you send a pastebin of the errors you found?</p>",
        "id": 196875664,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1588931369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> <a href=\"https://gist.github.com/cuviper/3ebd0330d11fe0867a2f919282003b07\" title=\"https://gist.github.com/cuviper/3ebd0330d11fe0867a2f919282003b07\">https://gist.github.com/cuviper/3ebd0330d11fe0867a2f919282003b07</a></p>",
        "id": 196919768,
        "sender_full_name": "cuviper",
        "timestamp": 1588956398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> Oh, apologies. I forgot to mention that you'll need to build with <code>--no-default-features</code> to disable <code>select</code> and <code>async</code> support (neither of which are working right now)</p>",
        "id": 196924587,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1588958527
    },
    {
        "content": "<p>OK, then <code>tests/zero.rs</code> complains that it can't find <code>rand</code></p>",
        "id": 196925226,
        "sender_full_name": "cuviper",
        "timestamp": 1588958821
    },
    {
        "content": "<p>also:</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0507]: cannot move out of a shared reference\n   --&gt; tests/iter.rs:108:20\n    |\n108 |     let mut iter = (&amp;r).into_iter();\n    |                    ^^^^ move occurs because value has type `flume::Receiver&lt;i32&gt;`, which does not implement the `Copy` trait\n</code></pre></div>",
        "id": 196925267,
        "sender_full_name": "cuviper",
        "timestamp": 1588958842
    },
    {
        "content": "<p>I'm still interested but my ISP died (posting from my phone) so that put git cloning anything on hold</p>",
        "id": 196931153,
        "sender_full_name": "Lokathor",
        "timestamp": 1588961648
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> My bad, I forgot to commit the very latest changes. Schoolboy error on my part. It should work now!</p>",
        "id": 196934407,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1588963391
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> OK, that built, but it's currently stuck on:</p>\n<div class=\"codehilite\"><pre><span></span><code>test hydra ... test hydra has been running for over 60 seconds\n</code></pre></div>",
        "id": 196934986,
        "sender_full_name": "cuviper",
        "timestamp": 1588963675
    },
    {
        "content": "<p>oh now it's done</p>",
        "id": 196936708,
        "sender_full_name": "cuviper",
        "timestamp": 1588964498
    },
    {
        "content": "<p>all passed</p>",
        "id": 196936715,
        "sender_full_name": "cuviper",
        "timestamp": 1588964501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> FWIW I ran <code>hydra</code> again to time it:</p>\n<ul>\n<li>debug: <code>1316.53user 334.04system 7:16.05elapsed 378%CPU</code></li>\n<li>release: <code>682.85user 435.12system 2:06.66elapsed 882%CPU</code></li>\n</ul>",
        "id": 196951899,
        "sender_full_name": "cuviper",
        "timestamp": 1588972747
    },
    {
        "content": "<p>maybe that's to be expected, I don't know...</p>",
        "id": 196952023,
        "sender_full_name": "cuviper",
        "timestamp": 1588972821
    },
    {
        "content": "<p>Great to hear that it works! <code>hydra</code> is expected to take some time: I was using it as a poor man's fuzzing test for spurious race issues early in development.</p>",
        "id": 196964345,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1588983756
    },
    {
        "content": "<blockquote>\n<p>Safe: No unsafe code anywhere in the codebase!</p>\n</blockquote>\n<p>Wait what? I naively thought it would be impossible to implement a concurrent data structure entirely in safe code, what is this magic?^^</p>",
        "id": 196980574,
        "sender_full_name": "RalfJ",
        "timestamp": 1589012966
    },
    {
        "content": "<p>Like, somehow this has to arrange ownership transfer across threads, and the compiler cannot possibly understand that you did all the synchronization required for this when you use atomics yourself... I must be missing something.</p>",
        "id": 196981927,
        "sender_full_name": "RalfJ",
        "timestamp": 1589015476
    },
    {
        "content": "<p>oh I see, you are using <code>Mutex</code> and friends from std. that makes sense.</p>",
        "id": 196981933,
        "sender_full_name": "RalfJ",
        "timestamp": 1589015514
    },
    {
        "content": "<p>now I am surprised that this can be fast :D</p>",
        "id": 196981936,
        "sender_full_name": "RalfJ",
        "timestamp": 1589015519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I was quite surprised myself that I could manage to get things running this fast. Based on my experimentation so far, it seems that reducing contention is a far more important factor than implementing a lock-free algorithm. Right now, we do this with simple backoff spinning and yielding which seems to perform well on most platforms.</p>",
        "id": 196985639,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1589021629
    },
    {
        "content": "<p>impressive</p>",
        "id": 196985690,
        "sender_full_name": "RalfJ",
        "timestamp": 1589021667
    },
    {
        "content": "<p>on which host OS did you measure? also did you compare with using parking_lot <code>Mutex</code> instead?</p>",
        "id": 196985703,
        "sender_full_name": "RalfJ",
        "timestamp": 1589021691
    },
    {
        "content": "<p>ah you mentioned non-POSIX still has perf issues</p>",
        "id": 196985720,
        "sender_full_name": "RalfJ",
        "timestamp": 1589021728
    },
    {
        "content": "<p>Swapping out <code>spin::Mutex</code> and backoff with plain old <code>std::sync::Mutex</code> on Windows seems to recooperate similar performance gains. I don't personally run Windows, but <span class=\"user-mention\" data-user-id=\"274649\">@Restioson</span> does.</p>",
        "id": 196985785,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1589021807
    },
    {
        "content": "<p>Can test windows again probably today or tomorrow</p>",
        "id": 196987859,
        "sender_full_name": "Restioson",
        "timestamp": 1589024857
    },
    {
        "content": "<p>oh you are using <code>spin</code>? that's where the unsafe code is then :D<br>\nthat crate <a href=\"https://github.com/mvdnes/spin-rs\" title=\"https://github.com/mvdnes/spin-rs\">is unmaintained</a> unfortunately</p>",
        "id": 196988118,
        "sender_full_name": "RalfJ",
        "timestamp": 1589025209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Indeed. We only use <code>spin::Mutex</code> which is pretty much just a sample CAS and is trivially sound though. I might just copy the code and bring it into the repo in time.</p>",
        "id": 196988185,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1589025292
    },
    {
        "content": "<p>might be worth trying <code>parking_lot::Mutex</code> first</p>",
        "id": 196988312,
        "sender_full_name": "RalfJ",
        "timestamp": 1589025442
    },
    {
        "content": "<p>to avoid local unsafe code :D</p>",
        "id": 196988314,
        "sender_full_name": "RalfJ",
        "timestamp": 1589025446
    },
    {
        "content": "<p>Perhaps, although that might hinder attempts to have Flume be included in <code>std</code> (since I believe there are several obstacles preventing <code>parking_lot</code> in <code>std</code>). I did some benchmarks earlier in development with <code>parking_lot</code>, and I found about a 30% performance improvement across the board.</p>",
        "id": 196988800,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1589026289
    },
    {
        "content": "<p>there are many obstacles to using parking_lot for <code>std::Mutex</code> etc... I am not sure how many of those also apply to just using it internally in some lib</p>",
        "id": 196992207,
        "sender_full_name": "RalfJ",
        "timestamp": 1589031688
    },
    {
        "content": "<p>if we're able to pull it into std and willing to use it, I think we'd probably be at the point where we'd use it for std::Mutex</p>",
        "id": 196994383,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589034814
    },
    {
        "content": "<p>What <em>is</em> blocking the use of <code>parking_lot</code> in std?</p>",
        "id": 197011941,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1589057034
    },
    {
        "content": "<p>There were concerns that parking_lot didn't have enough tests.</p>",
        "id": 197012141,
        "sender_full_name": "Amanieu",
        "timestamp": 1589057288
    },
    {
        "content": "<p>Alex did a pretty thorough review: <a href=\"https://github.com/faern/parking_lot/pull/1\" title=\"https://github.com/faern/parking_lot/pull/1\">https://github.com/faern/parking_lot/pull/1</a></p>",
        "id": 197012164,
        "sender_full_name": "Amanieu",
        "timestamp": 1589057356
    },
    {
        "content": "<p>We've been doing quite a bit of work on Flume recently. We're now a few more releases down the line and the code is now quite rugged and feature-filled. All of the old constraints are gone (<code>Sender</code>/<code>Receiver</code> are both <code>Clone + Send + Sync</code> now) and several new APIs are now available (<code>is_empty</code>, <code>is_disconnected</code>, etc.). <code>async</code> support is now fairly mature (it's being used in an asynchronous context in a large codebase developed by the company I work for). What  approach would be needed if I wanted to push for inclusion of Flume in <code>std</code>? Is it worth forking Rust and opening a draft PR?</p>",
        "id": 212407919,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1601979543
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"250715\">@Joshua Barretto</span> That’s super exciting! I think there are a couple avenues open. To get the source into std I think we could:</p>\n<ul>\n<li>Inline and replace the existing implementation of <code>mpsc</code>.</li>\n<li>Look at pulling <code>flume</code> into <code>rust-lang</code> and adding it as a dependency so mpsc can use it (I think this might be my personal preference if the API has expanded, but might also depend on whether <code>flume</code> has dependencies of its own and is no-std. <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> might have better thoughts from experience with <code>hashbrown</code>)</li>\n</ul>\n<p>I think for either of these cases we’ll want to run through a thorough review of <code>flume</code> itself.</p>\n<p>If we want to offer a better API than <code>std::sync::mpsc</code> in the future we could look at reviving the <code>std::channel</code> proposal which would fit nicely into the “break up <code>std::sync</code>” story.</p>",
        "id": 212415814,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1601985135
    },
    {
        "content": "<p>Hello! To address your points:</p>\n<ul>\n<li>\n<p>One of the (personal) aims I've had for <code>flume</code> is to fulfill the channel proposal that Stjepang proposed some time ago. Although the blog post doesn't seem to be publicly available any longer (perhaps it was moved?) I believe that <code>flume</code> currently addresses all of the points mentioned in the post. In this regard, I think it would be a shame not to aim for the <code>std::channel</code> proposal.</p>\n</li>\n<li>\n<p>Having <code>flume</code> be a dependency of <code>std</code> would be the ideal option but unfortunately it would likely be blocked by the fact that <code>flume</code> depends on <code>std</code>'s thread parking. That said, the thread parking has been deliberately decoupled from the main channel impl (which should only depend on <code>core</code>) so it should be possible to reach a compromise whereby <code>std</code> depends on <code>flume</code>, but has a small amount of glue code to tell <code>flume</code> how to park threads (trivial for the compiler to inline, of course).</p>\n</li>\n</ul>",
        "id": 212416463,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1601985517
    },
    {
        "content": "<p>I’m sure we could cook something up 🙂 Some libraries have a crate feature that’s used when they’re a dependency of <code>std</code>. How would you feel about possibly moving <code>flume</code> into <code>rust-lang</code> if we wanted to pull it in?</p>",
        "id": 212418301,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1601986553
    },
    {
        "content": "<p>I'm not completely adverse to such a thing. No doubt being a member of <code>rust-lang</code> would make it more 'immune' to maintainer disappearance. That said, with a stable Rust job and a lot of projects written in the language, I've got absolutely no intention of departing from the Rust ecosystem any time in the near future. I also feel that several of <code>flume</code>'s features are things that we might not initially want to stabilise and I'd be adverse to having the codebase split in such a manner (for example, <code>flume</code> has select, async and fairness support, all behind feature flags).</p>",
        "id": 212421832,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1601988412
    },
    {
        "content": "<p>i think my position is still something like this:</p>\n<ul>\n<li>Either deprecate mpsc or keep its API the same and replace it with a simpler implementation from flume. Possibly even by just copying code. I imagine that only implementing the mpsc API would permit some simplifications.</li>\n<li>Keep flume outside of std for now. i'd like to see it bake in the ecosystem before even considering it for std personally. its API looks very similar to crossbeam-channel (sans async), but without the nice <code>select!</code> macro. so to me, it seems like there is some healthy competition there, and i don't really see a reason to bless one over the other. (which is maybe an argument for keeping it out of the rust-lang org too.)</li>\n</ul>",
        "id": 212424056,
        "sender_full_name": "BurntSushi",
        "timestamp": 1601989475
    },
    {
        "content": "<p>That makes sense. In your view, what would constitute sufficient maturity for this to be taken to the next stage?</p>",
        "id": 212452673,
        "sender_full_name": "Joshua Barretto",
        "timestamp": 1602001743
    },
    {
        "content": "<p>it's hard to quantify it precisely, but some combination of \"widespread adoption\" and \"stability over a period of time\" maybe? basically, some kind of evidence that a mass of people are happy with its API and implementation. given the API similarity between it and crossbeam-channel, there's probably an argument that could be made that the API at least has been partially proved out. but there are differences: flume has a non-macro select and has async APIs. are those the right choices? i'm not sure.</p>",
        "id": 212459678,
        "sender_full_name": "BurntSushi",
        "timestamp": 1602005531
    },
    {
        "content": "<p>What about having a official blessed channel library in <code>rust-lang</code> and point the deprecation message<br>\nof <code>mpsc</code> to e.g. <code>flume</code> as a compromis.</p>\n<p>I remember that a few years back the consensus was that it was a mistake to place <code>mpsc</code> in <code>std</code> as there are to many different ways to do channels with to different nonces which are useful for different contexts, I think.</p>\n<p>But then I guess this (the consensus)  might very likely have changed since then.</p>\n<p>Having better channels in <code>std</code> wouldn't be bad, but then having a \"blessed\" 3rd party library would be as good for me.</p>\n<p>What I think is important that everyone looking for channels will fastely  find  a channel library which they don't need to review as it's not from a arbitrary 3rd party but a trust source (e.g. rust-lang github org).</p>",
        "id": 212611758,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602100865
    },
    {
        "content": "<p>I think one think which makes me favor having it as a independent crate in <code>rust-lang</code> and having doc references to it from std is that it has some neat features we would have to drop elsewise:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">features</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">select</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[]</span><span class=\"w\"></span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"s\">\"futures-sink\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"futures-core\"</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">eventual</span><span class=\"o\">-</span><span class=\"n\">fairness</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"s\">\"async\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"nanorand\"</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">default</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"s\">\"async\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"select\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"eventual-fairness\"</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Because lets be honest <code>futures</code> isn't ready or meant to be pulled into <code>std</code> and even through it originally was meant to be the standard library for handling futures it kinda didn't play out that way has has become somewhat messy and many libraries now depend on things like <code>futures-lite</code> or role their own ad-hoc async/await based combinators.</p>",
        "id": 212612790,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602101326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209646\">@Philipp Korber</span> that was mentioned. and why are we going to play favorites and bless flume by moving it into rust-lang when there is also crossbeam-channel? are there meaningful differences there?</p>",
        "id": 212615473,
        "sender_full_name": "BurntSushi",
        "timestamp": 1602102776
    },
    {
        "content": "<p>I just think it is important to have one or multiple well trusted channel libraries .</p>",
        "id": 212615616,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602102843
    },
    {
        "content": "<p>Or channels in <code>std</code>.</p>",
        "id": 212615627,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602102854
    },
    {
        "content": "<p>I would prefer not to link to any particular (not-owned-by-<code>rust-lang</code>-org) crate from the standard library documentation.  A category might be fine, though.  (I just don't want to do anything to encourage people to send PRs linking to their crates from std, or to <code>Itertools</code> from <code>Iterator</code>, or ...)</p>",
        "id": 212616421,
        "sender_full_name": "scottmcm",
        "timestamp": 1602103288
    },
    {
        "content": "<p>but that's something that almost nobody will disagree with. it doesn't really move us forward. \"i think it's important to have one or multiple well trusted random number libraries\" is likely also something a lot of people would agree with. but <code>rand</code> is not in rust-lang and AFAIK there is no push to move it there.</p>\n<p>if flume was the only game in town, that might be one thing. but <code>crossbeam-channel</code>, IMO, satisfies the \"well trusted\" crtierion already. why should we going to play favorites and pick one over the other? i'm not saying we shouldn't or can't, but i'd like a good reason to do it.</p>",
        "id": 212616590,
        "sender_full_name": "BurntSushi",
        "timestamp": 1602103387
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> i believe that is our currently policy, although there have been some references to external crates that have slipped through the cracks. i do think it would be nice to link to external crates from std docs, but don't have the resources to champion that effort. (because any such policy would have to of course carefully address very valid concerns like yours.)</p>",
        "id": 212616741,
        "sender_full_name": "BurntSushi",
        "timestamp": 1602103456
    }
]