[
    {
        "content": "<p>I've been thinking about how mem::uninitialized was not just deprecated, but \"deprecated with extreme prejudice\", in recognition of the fact that it's impossible to use safely. Now that it's been deprecated for a good while, it occurs to me that this function could be made safe, without technically causing an API change... by replacing its inner call to <code>MaybeUninit::uninit().assume_init()</code> with <code>mem::zeroed()</code>. This would de-fang any remaining uses of mem::uninitialized in the wild and the only effect would be performance-related. (With shades of the apocryphal tale of the library that once deprecated an API by inserting successively larger <code>sleep()</code> calls in every release.)</p>",
        "id": 244030355,
        "sender_full_name": "bstrie",
        "timestamp": 1624735627
    },
    {
        "content": "<p>zero-byte bit pattern is not always a valid pattern for a type to have.</p>",
        "id": 244030410,
        "sender_full_name": "nagisa",
        "timestamp": 1624735693
    },
    {
        "content": "<p>both mem::uninitialized and mem::zeroed are already guaranteed to panic if the type contains invalid bit representations</p>",
        "id": 244030416,
        "sender_full_name": "bstrie",
        "timestamp": 1624735724
    },
    {
        "content": "<p>Oh, nice.</p>",
        "id": 244030419,
        "sender_full_name": "nagisa",
        "timestamp": 1624735740
    },
    {
        "content": "<p>I remember that now, it was a recent change too, I remember people complaining about the change not being backwards compatible ^^</p>",
        "id": 244030432,
        "sender_full_name": "nagisa",
        "timestamp": 1624735776
    },
    {
        "content": "<p>Could this lead to an OOM when zeroing a large amount of memory where unitialized wouldn't?</p>",
        "id": 244030601,
        "sender_full_name": "The 8472",
        "timestamp": 1624736035
    },
    {
        "content": "<p>presumably the program would attempt to actually initialize that memory at some point before proceeding, thus hitting the same OOM, yes?</p>",
        "id": 244030643,
        "sender_full_name": "bstrie",
        "timestamp": 1624736070
    },
    {
        "content": "<p>Not if they're using sparse arrays for some reason</p>",
        "id": 244030866,
        "sender_full_name": "The 8472",
        "timestamp": 1624736356
    },
    {
        "content": "<p>if you have a contiguous block of uninitialized array elements and then try to access the last element in the array, wouldn't that trigger a reservation for the entire block and cause the OOM?</p>",
        "id": 244031133,
        "sender_full_name": "bstrie",
        "timestamp": 1624736704
    },
    {
        "content": "<p>or not even the last element, any element at all?</p>",
        "id": 244031215,
        "sender_full_name": "bstrie",
        "timestamp": 1624736823
    },
    {
        "content": "<p>On linux, at least, the memory is materialized on a per-page basis.</p>",
        "id": 244031228,
        "sender_full_name": "nagisa",
        "timestamp": 1624736848
    },
    {
        "content": "<p>perhaps I'm naive, but I don't see how that's possible. If I have an uninitialized  <code>x = [u8; A_ZILLION]</code>, then attempt to say <code>x[A_ZILLION-1] = 2</code>, then the system has to ensure that the address of <code>&amp;x[A_ZILLION-1]</code> is offset by exactly a zillion from <code>&amp;x</code>. it couldn't use those inner addresses for anything at all</p>",
        "id": 244031456,
        "sender_full_name": "bstrie",
        "timestamp": 1624737184
    },
    {
        "content": "<p>The kernel will reserve the address space but not back it by physical memory. touching a specific address will cause a page fault for that page which will then back it with memory and return to userspace as if it had always been there.</p>",
        "id": 244031517,
        "sender_full_name": "The 8472",
        "timestamp": 1624737304
    },
    {
        "content": "<p>okay, I'm mixing up my virtual address spaces with physical address space</p>",
        "id": 244031541,
        "sender_full_name": "bstrie",
        "timestamp": 1624737362
    },
    {
        "content": "<p>Then again, can it even be used to get memory like that or would it always blow the stack?</p>",
        "id": 244031723,
        "sender_full_name": "The 8472",
        "timestamp": 1624737618
    },
    {
        "content": "<p>also, is it even possible for that to be safe, in Rust terms?</p>",
        "id": 244031826,
        "sender_full_name": "bstrie",
        "timestamp": 1624737828
    },
    {
        "content": "<p>Maybe if you somehow remember which bits you have initialized and don't hand out references to the whole array. Using <code>Box::new_zeroed()</code> would be easier. That way it wouldn't have to write zeroes to your allocation and use calloc instead which gets you the same virtual memory optimization.</p>",
        "id": 244032127,
        "sender_full_name": "The 8472",
        "timestamp": 1624738122
    },
    {
        "content": "<p>But that's still unstable.</p>",
        "id": 244032138,
        "sender_full_name": "The 8472",
        "timestamp": 1624738154
    },
    {
        "content": "<p>Rust doesn't really place any constraints on the implementation of stack – it doesn't even need to be a single chunk of virtual memory.</p>",
        "id": 244032270,
        "sender_full_name": "nagisa",
        "timestamp": 1624738348
    },
    {
        "content": "<p>So depending on target and/or other particularities you may be able to allocate large structures on the stack. Very non-portable though.</p>",
        "id": 244032278,
        "sender_full_name": "nagisa",
        "timestamp": 1624738373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244031826\">said</a>:</p>\n<blockquote>\n<p>also, is it even possible for that to be safe, in Rust terms?</p>\n</blockquote>\n<p>WDYM by \"that\" precisely?</p>",
        "id": 244032287,
        "sender_full_name": "nagisa",
        "timestamp": 1624738409
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244032287\">said</a>:</p>\n<blockquote>\n<p>WDYM by \"that\" precisely?</p>\n</blockquote>\n<p>Passing around an array whose elements may or may not be uninitialized. A piece of code that uses mem::uninitialized not in the standard sense of \"I want to initialize this thing piece-by-piece, and then reach a point where I call it \"initialized\", and do normal operations on the now-initialized thing\", but instead to say \"I don't know <em>when</em> this array will be fully (or even partially) initialized, and it's possible that this array will <em>never</em> be fully initialized; I want the memory for each individual element of this array to be lazily reserved on-demand.\" If you're trying to do the latter, is it safe to, e.g., return that array from a function, or take a reference to it, or clone it, or call any stdlib function on it?</p>",
        "id": 244033122,
        "sender_full_name": "bstrie",
        "timestamp": 1624739715
    },
    {
        "content": "<p>So, not an authoritative answer here, but I want to say that passing by itself is <em>probably</em> okay as long as the uninit elements are not ever read. Alas clone and most stdlib functions do count as reading the elements, so the line is blurry?</p>",
        "id": 244033267,
        "sender_full_name": "nagisa",
        "timestamp": 1624739995
    },
    {
        "content": "<p>At the end of the day I think the broader question boils down to: does the API for mem::uninitialized actually include the guarantee that no memory is actually reserved, or does it just guarantee that you will receive an implementation-defined (possibly unspecified, possibly undefined) value? Because the latter interpretation of mem::uninitialized, while practically useless, is at least possible to specify, implement, and use. As it currently exists it would seem to be the height of absurdity for a theoretical Rust specification to attempt to specify the behavior of mem::uninitialized--we might imagine an exasperated author just writing \"invoke this function in order to produce undefined behavior\"--and it would be likewise absurd for any alternative implementation to be forced to implement it.</p>",
        "id": 244034971,
        "sender_full_name": "bstrie",
        "timestamp": 1624742382
    },
    {
        "content": "<p>It is definitely expected behavior on linux for <code>Box::new_uninit</code> and <code>Box::new_zeroed</code>. I'm less sure about <code>mem::uninitialized</code> or how one would use that in a meaningful way.</p>",
        "id": 244035715,
        "sender_full_name": "The 8472",
        "timestamp": 1624743604
    },
    {
        "content": "<p>mem::uninitialized is in core, so it surely doesn't use the heap, but otherwise it doesn't assure you of anything.</p>",
        "id": 244035985,
        "sender_full_name": "Lokathor",
        "timestamp": 1624744078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> I'm unclear, are you arguing that the stdlib has the latitude to consider such a change to the implementation of mem::uninitialized?</p>",
        "id": 244036103,
        "sender_full_name": "bstrie",
        "timestamp": 1624744296
    },
    {
        "content": "<p>absolutely it does</p>",
        "id": 244036152,
        "sender_full_name": "Lokathor",
        "timestamp": 1624744332
    },
    {
        "content": "<p>It's UB anyway so we can choose to have the UB end up being \"you get a zeroed value\".</p>",
        "id": 244036241,
        "sender_full_name": "Lokathor",
        "timestamp": 1624744516
    },
    {
        "content": "<p>I don't disagree, but I can already see people coming with complaints on how rust is not backwards compatible at all.</p>",
        "id": 244036320,
        "sender_full_name": "nagisa",
        "timestamp": 1624744664
    },
    {
        "content": "<p>Soundness fixes have always been am exception</p>\n<p>and absolute performance has very rarely been assured. Some places will guarantee \"this doesn't reallocate except in these conditions\", but that is not the same as a perfect performance guarantee.</p>",
        "id": 244036465,
        "sender_full_name": "Lokathor",
        "timestamp": 1624744912
    },
    {
        "content": "<p>UB isn't guarenteed to be backwards compatible. The one thing that's kind of unfortunate (in my very inexperienced opinion) is that we didn't used to be so clear about exactly <em>how</em> UB it was. That being said, it's been deprecated for ages now, so...</p>",
        "id": 244036580,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1624745157
    },
    {
        "content": "<p>I mean, the other alternative is to outright remove it, but I'm trying to be conservative in this proposal :P</p>",
        "id": 244036635,
        "sender_full_name": "bstrie",
        "timestamp": 1624745234
    },
    {
        "content": "<p>Too bad IIRC we can't remove functions from libstd based on the edition.</p>",
        "id": 244036646,
        "sender_full_name": "nagisa",
        "timestamp": 1624745278
    },
    {
        "content": "<p>this is the backcompat-friendly option, where the behavior changes slightly but no code stops compiling and there's no semantic runtime difference</p>",
        "id": 244036650,
        "sender_full_name": "bstrie",
        "timestamp": 1624745281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> <a href=\"https://github.com/rust-lang/rfcs/pull/3088\">https://github.com/rust-lang/rfcs/pull/3088</a></p>",
        "id": 244036693,
        "sender_full_name": "bstrie",
        "timestamp": 1624745309
    },
    {
        "content": "<p>At what point would you be comfortable removing it? Or are you suggesting to not remove it at all?</p>",
        "id": 244036695,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1624745315
    },
    {
        "content": "<p>Oh, hmm. I read that PR and it says that currently nothing can be removed from <code>std</code> at all. I guess I'd always assumed that deprecated things could be removed after enough time had passed.</p>",
        "id": 244036879,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1624745743
    },
    {
        "content": "<p>I'm seeking to avoid the question of whether or not this should be removed, or when. My goal right now is to place mem::uninitialized on the same level as every other deprecated API, i.e., I want to take this function from \"this is actively hazardous\" to \"this is merely discouraged\".</p>",
        "id": 244036930,
        "sender_full_name": "bstrie",
        "timestamp": 1624745802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244036320\">said</a>:</p>\n<blockquote>\n<p>I don't disagree, but I can already see people coming with complaints on how rust is not backwards compatible at all.</p>\n</blockquote>\n<p>tbh, already mem::uninitialized has already been the biggest backwards compat issue in rust in practice IME. i have several old projects that no longer run because they call into a library that apparently does some UB with mem::uninitialized, but there's nothing i can do about it since they didn't get fixed for several versions, and have many breaking changes before they ultimately got fixed.</p>\n<p>even just theoretically, i'd argue (and have before) the functions existence was a promise that there was a correct way to use it, and apparently the consensus since then is that there is not.</p>\n<p>anyway, i guess that's all to say, that this function is already a disaster of rust's backwards compat story in many ways, i don't think this would meaningfully move the needle on it.</p>",
        "id": 244037069,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1624746014
    },
    {
        "content": "<p>Should the mem::uninitialized deprecation be changed into an forward compat lint even if there is no intention to ever remove it?</p>",
        "id": 244037145,
        "sender_full_name": "bjorn3",
        "timestamp": 1624746182
    },
    {
        "content": "<p>well, it's effectively wrong to ever call the function ever, so linting against ot doesn't seem unreasonable, but using deprecated things is already linted against, isn't it?</p>",
        "id": 244038538,
        "sender_full_name": "Lokathor",
        "timestamp": 1624748456
    },
    {
        "content": "<p>I think the main problem is in old code that's not being updated and is being used as a dependency with lints capped</p>",
        "id": 244038555,
        "sender_full_name": "Lokathor",
        "timestamp": 1624748495
    },
    {
        "content": "<p>the future compatibility lint is only for things that will eventually be removed from all editions, so you wouldn't use it unless people had agreed to remove mem::uninitialized from std</p>",
        "id": 244038556,
        "sender_full_name": "bstrie",
        "timestamp": 1624748502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244037069\">said</a>:</p>\n<blockquote>\n<p>i have several old projects that no longer run because they call into a library that apparently does some UB with mem::uninitialized</p>\n</blockquote>\n<p>are these projects failing to run because of the mandatory panic on certain types (all types that contain uninhabited values), or are they failing to run because of some wild UB memory corruption? because if it's the latter, then this proposal would actually fix that.</p>",
        "id": 244038664,
        "sender_full_name": "bstrie",
        "timestamp": 1624748669
    },
    {
        "content": "<p>slightly aside: rust is so \"stable\" but we assume that all code is  being actively maintained at all times. I think the better fix is to change the implementation so that old code gets a fix applied without them having to update at all. i mean the long term ideal is that we eventually start to have libraries that we don't have to update, right?</p>",
        "id": 244038690,
        "sender_full_name": "Lokathor",
        "timestamp": 1624748748
    },
    {
        "content": "<p>thus, make it just do a <code>zeroed</code> as bstrie is saying, rather than adjusting lints and hoping some devs sees a lint.</p>",
        "id": 244038747,
        "sender_full_name": "Lokathor",
        "timestamp": 1624748789
    },
    {
        "content": "<p>FWIW, in theory you could ask the memory allocator for zeroed memory, and if it gets new pages from the OS it can assume they're zero.</p>",
        "id": 244040336,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624751063
    },
    {
        "content": "<p>If they're new pages, rather than reused.</p>",
        "id": 244040389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1624751095
    },
    {
        "content": "<p>vec already has that optimization</p>",
        "id": 244040524,
        "sender_full_name": "The 8472",
        "timestamp": 1624751340
    },
    {
        "content": "<p>for some std-owned types</p>",
        "id": 244040578,
        "sender_full_name": "The 8472",
        "timestamp": 1624751413
    },
    {
        "content": "<p>I don't think I'd want <code>mem::uninitialized()</code> to become <em>safe</em> -- that's even more of an invitation to use it for the invariant check, and if people want that we should make an actual function/trait for it -- but I'd certainly be open to potentially tweaking its implementation to reduce footguns for old code, given that it could update to <code>MaybeUninit</code> to recover the perf impact.</p>",
        "id": 244041367,
        "sender_full_name": "scottmcm",
        "timestamp": 1624752618
    },
    {
        "content": "<p>Like the classic \"write <code>DEADBEEF</code> into the first 4 bytes\" or something.</p>",
        "id": 244041373,
        "sender_full_name": "scottmcm",
        "timestamp": 1624752653
    },
    {
        "content": "<p>Well, the advantage of zeroed memory is that more types can be all 0s than can be most other sentinel bits. Though if the sentinel pattern were say <code>0x01</code> in all bytes that would probably be fine too. If libstd wasn't prebuilt all the time we could even have sentinel in debug and plain zeroed in release.</p>",
        "id": 244042675,
        "sender_full_name": "Lokathor",
        "timestamp": 1624755042
    },
    {
        "content": "<blockquote>\n<p>are these projects failing to run because of the mandatory panic on certain types (all types that contain uninhabited values)</p>\n</blockquote>\n<p>yes, it's this. I don't expect anything to fix it, but think it's quite unfortunate since that code for the most part worked (it was part of an outdated offsetof-alike, iirc — again, it wasn't my code, it was in a lib i used (glium, i think)), but running that code requires figuring out which version of rust it last ran on.</p>",
        "id": 244043738,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1624757297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244042675\">said</a>:</p>\n<blockquote>\n<p>Well, the advantage of zeroed memory is that more types can be all 0s than can be most other sentinel bits.</p>\n</blockquote>\n<p>Given <code>NonNull</code> and references and such, I'm less certain of that.  I guess it depends if you weight to enums or data structures.</p>",
        "id": 244048128,
        "sender_full_name": "scottmcm",
        "timestamp": 1624765966
    },
    {
        "content": "<p>yeah if we wanted to always get it right no matter what we'd have to do some specialization steps</p>",
        "id": 244048359,
        "sender_full_name": "Lokathor",
        "timestamp": 1624766452
    },
    {
        "content": "<p>zeroed memory has the special panic check already at least</p>",
        "id": 244048367,
        "sender_full_name": "Lokathor",
        "timestamp": 1624766474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244041367\">said</a>:</p>\n<blockquote>\n<p>I don't think I'd want <code>mem::uninitialized()</code> to become <em>safe</em></p>\n</blockquote>\n<p>What I'm proposing is not to remove the <code>unsafe</code> marker from this function, but merely to replace the implementation with something that is (arguably!) semantically equivalent and eliminates all existing memory safety risk--even at the cost of making this function effectively just an alias of mem::zeroed, which I'll argue is fine since 1) this function is inherently broken, and cannot possibly be used safely any other way, and 2) mem::MaybeUninit is a mature replacement for its original use case</p>",
        "id": 244050695,
        "sender_full_name": "bstrie",
        "timestamp": 1624771531
    },
    {
        "content": "<p>(and if there's some other solution other than mem::zeroed, that's fine too, I don't care about the exact replacement as much as I care about disarming the safety risk and making it actually possible to specify and implement)</p>",
        "id": 244050752,
        "sender_full_name": "bstrie",
        "timestamp": 1624771640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244048367\">said</a>:</p>\n<blockquote>\n<p>zeroed memory has the special panic check already at least</p>\n</blockquote>\n<p>both mem::zeroed and mem::uninitialized have panic checks; mem::zeroed panics if a type must not be zeroes, whereas mem::uninitialized panics if a type has any uninhabited values at all. in theory, replacing the innards of mem::uninitialized with mem::zeroed could allow mem::uninitialized's current panic check to be loosened, which might help <span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span>'s use case</p>",
        "id": 244050960,
        "sender_full_name": "bstrie",
        "timestamp": 1624772054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244030355\">said</a>:</p>\n<blockquote>\n<p>it occurs to me that this function could be made safe</p>\n</blockquote>\n<p>^ Ah, when you said this that to me meant \"remove the <code>unsafe</code>\" marker.</p>",
        "id": 244051322,
        "sender_full_name": "scottmcm",
        "timestamp": 1624772922
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244036646\">said</a>:</p>\n<blockquote>\n<p>Too bad IIRC we can't remove functions from libstd based on the edition.</p>\n</blockquote>\n<p>we could. it's not too hard to implement. but in practice just making this specific deprecation a (hard) error in the new edition is probably easier and a better idea. thatt way, the documentation is still visible etc.</p>",
        "id": 244060240,
        "sender_full_name": "Mara",
        "timestamp": 1624789267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244037145\">said</a>:</p>\n<blockquote>\n<p>Should the mem::uninitialized deprecation be changed into an forward compat lint even if there is no intention to ever remove it?</p>\n</blockquote>\n<p>yeah, maybe</p>",
        "id": 244060242,
        "sender_full_name": "Mara",
        "timestamp": 1624789269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244038555\">said</a>:</p>\n<blockquote>\n<p>I think the main problem is in old code that's not being updated and is being used as a dependency with lints capped</p>\n</blockquote>\n<p>that'd be fixed by making it a future incompatibility lint. cargo does show those for dependencies</p>",
        "id": 244060255,
        "sender_full_name": "Mara",
        "timestamp": 1624789311
    },
    {
        "content": "<p>and with <span class=\"user-mention\" data-user-id=\"224872\">@rylev</span>'s recent change, we could add a <code>FutureIncompatibilityReason::Unsound</code> or something with a more specific message than just \"this will break in a future release\".</p>",
        "id": 244060326,
        "sender_full_name": "Mara",
        "timestamp": 1624789394
    },
    {
        "content": "<p>\"this is already unsound, and will break in more unpredictable ways in the future\"</p>",
        "id": 244060333,
        "sender_full_name": "Mara",
        "timestamp": 1624789427
    },
    {
        "content": "<p>or insert some kind of empty asm block that can write to the buffer. then llvm can't know whether the buffer was written to or not and no longer sees it as undef</p>",
        "id": 244060458,
        "sender_full_name": "Mara",
        "timestamp": 1624789605
    },
    {
        "content": "<p>that 'works' because it takes the address of the data, forcing it to be in memory instead of in a register.</p>",
        "id": 244060730,
        "sender_full_name": "Mara",
        "timestamp": 1624790150
    },
    {
        "content": "<p>the proper way seems to be llvm's <code>freeze</code> instruction: <a href=\"https://llvm.org/docs/LangRef.html#freeze-instruction\">https://llvm.org/docs/LangRef.html#freeze-instruction</a></p>",
        "id": 244062212,
        "sender_full_name": "Mara",
        "timestamp": 1624792645
    },
    {
        "content": "<p>apparently the OS makes that whole thing a lot harder, because it might swap pages away if you haven't written to them, causing multiple reads to actually return different results: <a href=\"https://internals.rust-lang.org/t/what-the-hardware-does-is-not-what-your-program-does-uninitialized-memory/10561/27?u=ralfjung\">see this comment</a></p>",
        "id": 244064566,
        "sender_full_name": "Mara",
        "timestamp": 1624796512
    },
    {
        "content": "<p>Afaik the kernel always gives you zeroed pages (except on some embedded systems). It's the allocator's doing if you're getting back reused pages.</p>",
        "id": 244064731,
        "sender_full_name": "The 8472",
        "timestamp": 1624796755
    },
    {
        "content": "<p>sure, with 'OS' i mean the combination of kernel and libc etc.</p>",
        "id": 244070512,
        "sender_full_name": "Mara",
        "timestamp": 1624805997
    },
    {
        "content": "<p>Is that relevant to mem::uninitialized though? What would tell the allocator to free memory under our nose while we still anything referring to the span of memory?</p>",
        "id": 244070648,
        "sender_full_name": "The 8472",
        "timestamp": 1624806137
    },
    {
        "content": "<p>Worth noting also that stack is also memory and it is not generally zeroed.</p>",
        "id": 244070713,
        "sender_full_name": "nagisa",
        "timestamp": 1624806272
    },
    {
        "content": "<p>I'm surprised though that reads from allocated but not written-to memory can produce different results on different reads.</p>",
        "id": 244070729,
        "sender_full_name": "nagisa",
        "timestamp": 1624806314
    },
    {
        "content": "<p>Ah. MADV_FREE is a delayed action and only undone by writes, not reads. So yeah, if the allocator recycles memory that way it's true that your reads will be non-deterministic</p>",
        "id": 244070861,
        "sender_full_name": "The 8472",
        "timestamp": 1624806489
    },
    {
        "content": "<p>yeah</p>",
        "id": 244070963,
        "sender_full_name": "Mara",
        "timestamp": 1624806652
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244060242\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244037145\">said</a>:</p>\n<blockquote>\n<p>Should the mem::uninitialized deprecation be changed into an forward compat lint even if there is no intention to ever remove it?</p>\n</blockquote>\n<p>yeah, maybe</p>\n</blockquote>\n<p>Recent conversations lead me to believe that people want to tighten up the meaning of the future compat lint, rather than dilute it. <a href=\"#narrow/stream/268952-edition-2021/topic/pat_2021.20on.202018/near/243697632\">https://rust-lang.zulipchat.com/#narrow/stream/268952-edition-2021/topic/pat_2021.20on.202018/near/243697632</a></p>\n<p>That said, it could be made future-incompat, with an intention to remove (via the soundness exception to the stability policy), but that removal could very well happen ten years from now.</p>",
        "id": 244073190,
        "sender_full_name": "bstrie",
        "timestamp": 1624810028
    },
    {
        "content": "<p>I don't think it's clear that there are <em>no</em> sound uses, so I'm not convinced that removing it is ok.</p>",
        "id": 244073354,
        "sender_full_name": "scottmcm",
        "timestamp": 1624810259
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> that's reasonable (and to reiterate, the original proposal was not to remove the function), but as an exercise, all unsafe functions in the stdlib are supposed to be documented with a \"Safety\" section describing the invariants that the caller needs to uphold. mem::uninitialized doesn't have such a section today; what would you suggest that this section would say?</p>",
        "id": 244073566,
        "sender_full_name": "bstrie",
        "timestamp": 1624810607
    },
    {
        "content": "<p>I'd start with \"UB if T has any validity invariants\", though that's not sufficient.</p>",
        "id": 244073629,
        "sender_full_name": "scottmcm",
        "timestamp": 1624810689
    },
    {
        "content": "<p>I ask because the current guts of mem::uninitialized is just <code>MaybeUninit::uninit().assume_init()</code>, and if we look at the Safety section of <code>assume_init()</code>, it reads: \"It is up to the caller to guarantee that the MaybeUninit&lt;T&gt; really is in an initialized state. Calling this when the content is not yet fully initialized causes immediate undefined behavior.\" The type level documentation also contains the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// undefined behavior! ⚠️</span>\n</code></pre></div>\n<p>So it's possible that the MaybeUninit docs are just being overly conservative, but as written they imply that <em>any</em> call to mem::uninitialized is immediate and unavoidable UB</p>",
        "id": 244073916,
        "sender_full_name": "bstrie",
        "timestamp": 1624811127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244073190\">said</a>:</p>\n<blockquote>\n<p>Recent conversations lead me to believe that people want to tighten up the meaning of the future compat lint, rather than dilute it.</p>\n</blockquote>\n<p>Huh. This isn't about 'tightening' or 'diluting'. just about being correct. in that that case you linked i was arguing against having edition compat lints be future incompat lints because these aren't things that are or will be broken without manual action.</p>",
        "id": 244073922,
        "sender_full_name": "Mara",
        "timestamp": 1624811153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244073916\">said</a>:</p>\n<blockquote>\n<p>So it's possible that the MaybeUninit docs are just being overly conservative, but as written they imply that <em>any</em> call to mem::uninitialized is immediate and unavoidable UB</p>\n</blockquote>\n<p>Well, the docs already say:</p>\n<blockquote>\n<p>The reason for deprecation is that the function basically cannot be used correctly</p>\n</blockquote>",
        "id": 244074221,
        "sender_full_name": "Mara",
        "timestamp": 1624811564
    },
    {
        "content": "<p>Yes, I'm just quoting the MaybeUninit docs in response to the idea that there might be sound uses of this function</p>",
        "id": 244074230,
        "sender_full_name": "bstrie",
        "timestamp": 1624811625
    },
    {
        "content": "<p>And to reiterate, I believe this function could be made sound, if the call to <code>MaybeUninit::uninit.assume_init()</code> were replaced by <code>zeroed()</code>. It would also be made pointless, yes, but still better than the current state, in that the resulting Rust program would at least be valid.</p>",
        "id": 244074617,
        "sender_full_name": "bstrie",
        "timestamp": 1624812160
    },
    {
        "content": "<blockquote>\n<p>So it's possible that the MaybeUninit docs are just being overly conservative, but as written they imply that any call to mem::uninitialized is immediate and unavoidable UB</p>\n</blockquote>\n<p>Technically speaking you <em>can</em> legally create a MaybeUninit value using <code>MaybeUninit::uninit().assume_init()</code>, or an array of such values.</p>",
        "id": 244076966,
        "sender_full_name": "Lokathor",
        "timestamp": 1624815819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244060255\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244038555\">said</a>:</p>\n<blockquote>\n<p>I think the main problem is in old code that's not being updated and is being used as a dependency with lints capped</p>\n</blockquote>\n<p>that'd be fixed by making it a future incompatibility lint. cargo does show those for dependencies</p>\n</blockquote>\n<p>The downside is that just the lint doesn't actually fix the code. Someone still has to go actually make a change and publish a new version.</p>\n<p>If it was a lint + it gives you a zeroed (which is enough in many many cases) then that would be better.</p>",
        "id": 244086392,
        "sender_full_name": "Lokathor",
        "timestamp": 1624830118
    },
    {
        "content": "<blockquote>\n<p>s it currently exists it would seem to be the height of absurdity for a theoretical Rust specification to attempt to specify the behavior of mem::uninitialized--we might imagine an exasperated author just writing \"invoke this function in order to produce undefined behavior\"</p>\n</blockquote>\n<p>it's not quite <em>that</em> bad. ;) the function is actually specified pretty easily: <code>mem::uninitialized::&lt;T&gt;</code> returns the value obtained by interpreting <code>size_of::&lt;T&gt;()</code> many uninit bytes at type <code>T</code>. (likewise, <code>mem::zeroed::&lt;T&gt;</code> returns the value obtained by interpreting <code>size_of::&lt;T&gt;()</code> many 0x00 bytes at type <code>T</code>.)<br>\nit's just that for the vast majority of types, \"<code>size_of::&lt;T&gt;()</code> many uninit bytes\" does not represent <em>any</em> value, and hence we have UB.</p>\n<p>(also FWIW, \"invoke this function in order to produce undefined behavior\" is actually a very useful function, it's called <code>unreachable_unchecked</code>)</p>",
        "id": 245576728,
        "sender_full_name": "RalfJ",
        "timestamp": 1625958762
    },
    {
        "content": "<blockquote>\n<p>eliminates all existing memory safety risk</p>\n</blockquote>\n<p>that's impossible... <code>mem::zeroed</code> is still <code>unsafe</code>, after all<br>\nlater you say you think the function can be made 'sound', but soundness is a property of a <em>safe</em> API, so I don't know what you mean by this.</p>",
        "id": 245576811,
        "sender_full_name": "RalfJ",
        "timestamp": 1625958916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/244070648\">said</a>:</p>\n<blockquote>\n<p>Is that relevant to mem::uninitialized though? What would tell the allocator to free memory under our nose while we still anything referring to the span of memory?</p>\n</blockquote>\n<p>what the allocator and hardware do is <a href=\"https://www.ralfj.de/blog/2019/07/14/uninit.html\">almost entirely irrelevant</a> for the purpose of this discussion</p>",
        "id": 245576863,
        "sender_full_name": "RalfJ",
        "timestamp": 1625958999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/245576811\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>eliminates all existing memory safety risk</p>\n</blockquote>\n<p>that's impossible... <code>mem::zeroed</code> is still <code>unsafe</code>, after all</p>\n</blockquote>\n<p>this is something I've been meaning to ask... I don't see how <code>zeroed</code> is unsafe these days. Back in 2018 you added an assertion that guarantees a panic if it is ever used with a type that can' t be zero, and I'm not aware of any other safety invariants</p>",
        "id": 245577050,
        "sender_full_name": "bstrie",
        "timestamp": 1625959347
    },
    {
        "content": "<p>Arbitrary user-provided types can have arbitrary safety invariants. And the non_zero check is only a \"here's us being nice to you because you wrote unreachable_unchecked() by accident\", AFAIK (It's not actually guaranteed).</p>",
        "id": 245577211,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625959676
    },
    {
        "content": "<p>Interesting, I was putting too much faith in the zeroed check. Regardless, I don't think that changes anything about the PR, as the point is that <code>zeroed</code> can be used safely, while <code>unintialized</code> (currently) can't</p>",
        "id": 245577405,
        "sender_full_name": "bstrie",
        "timestamp": 1625959953
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/245577211\">said</a>:</p>\n<blockquote>\n<p>Arbitrary user-provided types can have arbitrary safety invariants. And the non_zero check is only a \"here's us being nice to you because you wrote unreachable_unchecked() by accident\", AFAIK (It's not actually guaranteed).</p>\n</blockquote>\n<p>That's the call to <code>unreachable_unchecked()</code> that's the issue then, not <code>mem::zeroed()</code>. If <code>mem::zeroed()</code> always results in a valid value (and apparently there's a check for this), then it's memory safe.</p>",
        "id": 245577432,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1625960031
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> apparently it's not the case that the zeroed check catches <em>all</em> cases where a type can't be zero, see <a href=\"https://github.com/rust-lang/rust/issues/66151\">https://github.com/rust-lang/rust/issues/66151</a></p>",
        "id": 245577486,
        "sender_full_name": "bstrie",
        "timestamp": 1625960092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/245577432\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/245577211\">said</a>:</p>\n<blockquote>\n<p>Arbitrary user-provided types can have arbitrary safety invariants. And the non_zero check is only a \"here's us being nice to you because you wrote unreachable_unchecked() by accident\", AFAIK (It's not actually guaranteed).</p>\n</blockquote>\n<p>That's the call to <code>unreachable_unchecked()</code> that's the issue then, not <code>mem::zeroed()</code>. If <code>mem::zeroed()</code> always results in a valid value (and apparently there's a check for this), then it's memory safe.</p>\n</blockquote>\n<p>I was comparing <code>mem::zeroed::&lt;NonZeroU8&gt;()</code> and the like to <code>unreachable_unchecked()</code> because they are semantically identical. Rustc just decided to panic instead when the person may have unintentionally written a function call that is identical to <code>unreachable_unchecked()</code>. Additionally, it's not memory safe to produce an zeroed bitpattern for any general type, even if it's not an invalid value, so whether or not it's stabily guaranteed to panic for a type that cannot be zero-initialized, it still cannot be safe.</p>",
        "id": 245577565,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625960241
    },
    {
        "content": "<p>User defined types can have any rules it wants, even \"cannot be created on a Tuesday\". In that case, if you created such a type with <code>mem::zeroed()</code> on a Tuesday, you've violated the invariant of that type, even if, according to the rust language, such a value is valid.</p>",
        "id": 245577621,
        "sender_full_name": "Connor Horman",
        "timestamp": 1625960373
    },
    {
        "content": "<p>hm, originally I was deliberately overlooking user-defined types as I was only considering types with invalid values (which AFAIK only the stdlib has the ability to define, and should in theory be able to perfectly detect), but yes, it certainly is true that there are plenty of other invariants that you could violate this way</p>",
        "id": 245577985,
        "sender_full_name": "bstrie",
        "timestamp": 1625961047
    },
    {
        "content": "<p>still, the goal of this is not and has never been to remove the <code>unsafe</code> from these functions, only to make <code>uninitialized</code> not be an immediate footgun</p>",
        "id": 245577995,
        "sender_full_name": "bstrie",
        "timestamp": 1625961086
    },
    {
        "content": "<p>is it possible this actually makes things <em>more</em> (rather than less) likely to cause problems with LLVM? C++ code has uninitialized values all the time, it's not really UB until you initialize it as UB, which using mem::zeroed() would do</p>",
        "id": 245585426,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1625974264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/disarming.20mem.3A.3Auninitialized/near/245577995\">said</a>:</p>\n<blockquote>\n<p>still, the goal of this is not and has never been to remove the <code>unsafe</code> from these functions, only to make <code>uninitialized</code> not be an immediate footgun</p>\n</blockquote>\n<p>yes that makes sense, but you claiming that this would make things \"safe\" muddied the waters a lot^^</p>",
        "id": 245603374,
        "sender_full_name": "RalfJ",
        "timestamp": 1626004383
    },
    {
        "content": "<p>it seems like we now agree that <code>zeroed</code> even with the best panic check we could write (which we dont currently do) is still very much an <code>unsafe</code> function? The one-sentence summary is that the best rustc can do is check <a href=\"https://www.ralfj.de/blog/2018/08/22/two-kinds-of-invariants.html\">the validity invariant, but it cannot know about the safety invariant</a>.</p>",
        "id": 245603432,
        "sender_full_name": "RalfJ",
        "timestamp": 1626004453
    },
    {
        "content": "<p>The <a href=\"https://doc.rust-lang.org/nightly/std/mem/union.MaybeUninit.html#safety\"><code>assume_init</code> docs</a> explicitly call this out, though maybe not with the best example. Do we need to also be more explicit about this in the <code>uninitialized</code> and <code>zeroed</code> docs?</p>",
        "id": 245603449,
        "sender_full_name": "RalfJ",
        "timestamp": 1626004523
    },
    {
        "content": "<p>yes, I'm guilty of being too informal here, and I need to reread that blog post because I'm sure I've also used \"safety invariant\" when I might have meant \"validity invariant\" :P</p>",
        "id": 245622560,
        "sender_full_name": "bstrie",
        "timestamp": 1626031328
    },
    {
        "content": "<p>I do think more documentation would be useful here, though I'm not sure if the unsafe code guidelines WG has a better place to put it than in the MaybeUninit docs. For example, I found it useful to understand that the only types that are allowed to be uninitialized are ZSTs, (maybe) unions with a ZST field, and arrays (and tuples?) of the same. Knowing what <em>is</em> allowed to be uninitialized helps to alleviate the surprise of simply being told that i32 can't be uninitialized.</p>",
        "id": 245624212,
        "sender_full_name": "bstrie",
        "timestamp": 1626034174
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> I'd love for you to share your issues at <a href=\"https://github.com/rust-lang/rust/issues/66151\">https://github.com/rust-lang/rust/issues/66151</a>. A discussion could be had about taming down that panic -- I honestly expected such a discussion much earlier than this and am rather surprised it has not happened yet.</p>",
        "id": 245786971,
        "sender_full_name": "RalfJ",
        "timestamp": 1626160814
    },
    {
        "content": "<p>I've closed the original PR, but opened a new issue for \"initialized\" <code>mem::uninitialized</code> with the idea that Rust could leverage its understanding of niches to produce a valid initialized value for any given type: <a href=\"https://github.com/rust-lang/rust/issues/87675\">https://github.com/rust-lang/rust/issues/87675</a></p>",
        "id": 247826727,
        "sender_full_name": "bstrie",
        "timestamp": 1627770435
    }
]