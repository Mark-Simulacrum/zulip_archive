[
    {
        "content": "<p>Currently there is an issue where <code>Iterator::take(size)</code> on slices is not autovectorized, when it is when indexed using <code>[..size]</code> (for example: <a href=\"https://godbolt.org/z/hqz6jMh33\">https://godbolt.org/z/hqz6jMh33</a>)</p>\n<p>How would one go about fixing this issue?</p>",
        "id": 266196838,
        "sender_full_name": "Redzic",
        "timestamp": 1640632054
    },
    {
        "content": "<p>try replacing <code>for ... in iter</code> with <code>iter.for_each</code></p>",
        "id": 266197536,
        "sender_full_name": "The 8472",
        "timestamp": 1640632698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Autovectorization.20issue.20with.20Iterator.3A.3Atake.20on.20slices/near/266197536\">said</a>:</p>\n<blockquote>\n<p>try replacing <code>for ... in iter</code> with <code>iter.for_each</code></p>\n</blockquote>\n<p>Looks like that does cause it to autovectorize it (<a href=\"https://godbolt.org/z/1h4a5qnG9\">https://godbolt.org/z/1h4a5qnG9</a>), however it seems like the loop is not unrolled as much as compared to <code>[..size]</code>. Shouldn't the same code be generated for all 3 versions?</p>",
        "id": 266197820,
        "sender_full_name": "Redzic",
        "timestamp": 1640633010
    },
    {
        "content": "<p>It would be nice if that were the case but iterator performance is heavily dependent on llvm optimizations and the IR generated by iterators is more complicated than direct slice accesses and sometimes the optimizer doesn't recognize the code patterns.<br>\nPart of the purpose of <code>for_each</code> is that should be easier to optimize. If that still performs significantly worse in benchmarks that might be worth filing an issue.</p>",
        "id": 266198494,
        "sender_full_name": "The 8472",
        "timestamp": 1640633372
    },
    {
        "content": "<p>I could see a specialization on <code>Take</code> where <code>I: TrustedRandomAccessNoCoerce</code> or something like that</p>",
        "id": 266247080,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1640686530
    },
    {
        "content": "<p>Essentially computing the minimum between <code>I</code>'s length and the max length given to <code>Take</code> when <code>Take</code> is created</p>",
        "id": 266247151,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1640686587
    },
    {
        "content": "<p>Another possible optimization (but this might make things worse) is specializing <code>Take::fold</code> and friends on <code>I: ExactSizeIterator</code>, skipping <code>Take</code>'s checks if <code>I</code>'s size is smaller than <code>Take</code>'s max length, though this might result in <code>Take</code> yielding more items if <code>I</code> misbehaves</p>",
        "id": 266247275,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1640686733
    },
    {
        "content": "<p>ESI can't be used for specialization, only TrustedLen and TRA</p>",
        "id": 266259888,
        "sender_full_name": "The 8472",
        "timestamp": 1640698759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"422686\">Redzic</span> <a href=\"#narrow/stream/219381-t-libs/topic/Autovectorization.20issue.20with.20Iterator.3A.3Atake.20on.20slices/near/266197820\">said</a>:</p>\n<blockquote>\n<p>Shouldn't the same code be generated for all 3 versions?</p>\n</blockquote>\n<p>See &lt;<a href=\"https://medium.com/@veedrac/rust-is-slow-and-i-am-the-cure-32facc0fdcb\">https://medium.com/@veedrac/rust-is-slow-and-i-am-the-cure-32facc0fdcb</a>&gt; for the usual reading material about the problem.</p>\n<p>TLDR: internal iteration is just easier to optimize, so sometimes this happens.</p>",
        "id": 267502055,
        "sender_full_name": "scottmcm",
        "timestamp": 1641849814
    }
]