[
    {
        "content": "<p>Hi, all. I’m interested in add a Comparator API in ordered collections such as BTreeMap or BinaryHeap. </p>\n<p>Currently, it can be done by wrapped types based on customized Ord implementation, but there are some problems. The entry types may need to be compared based on some extra dynamic information. E.g there are Row type in database, they may be composed as multiple fields a, b, c. And the compare rule may be dynamic generated by user sql “ORDER BY a ASC, b DESC, c ASC”, we may introduce a custom type OrderRule to describe the behavior. Then if we want to store Row in BTreeMap, we have to introduce a wrapper, OrderedRow with Row and a reference to OrderRule. Then we can implement Ord for OrederedRow. But the OrederedRow is at least 8 (raw reference, which is hard to use with lifetime) or 16 (Rc) bytes bigger then the original Row type, which is meaningless overhead. We also have to do unnecessary check in Ord implementation of OrderedRow that the OrderRule are same (in fact, they are always identical).</p>\n<p>A best solution is introducing comparator into generic argument in  ordered collection, which is similar in C++.</p>\n<p>I’m not sure whether there are some existing discussions about it. If not yet, I’d like to submit an RFC for it.</p>",
        "id": 266055801,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1640432708
    },
    {
        "content": "<p>For heaps, see <a href=\"https://crates.io/crates/binary-heap-plus\">https://crates.io/crates/binary-heap-plus</a> and their references to past discussions.</p>",
        "id": 266061135,
        "sender_full_name": "cuviper",
        "timestamp": 1640441745
    },
    {
        "content": "<p>IIRC they did try adding a generic arg in std, and even with a default it caused a lot of type inference problems.</p>",
        "id": 266061245,
        "sender_full_name": "cuviper",
        "timestamp": 1640441893
    },
    {
        "content": "<p>I’ve found <a href=\"https://github.com/rust-lang/rust/issues/69454\">#69454</a>, it seems that it was rejected due to potential compatibility breaking (but I think it is similar to allocator_api).</p>\n<p>I’ve also found a pre-RFC in rust forum, but not any formal RFC to describe it.</p>",
        "id": 266070272,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1640457163
    },
    {
        "content": "<p>If the data isn't mutated frequently you could also try a sorted vec + binary search, those take comparison functions.</p>",
        "id": 266071280,
        "sender_full_name": "The 8472",
        "timestamp": 1640458882
    },
    {
        "content": "<p>Thanks, but unfortunately we are implementing a database, and the BTreeMap is a part of memory component. It’s impossible to assume the frequency of mutations.</p>",
        "id": 266071407,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1640459138
    }
]