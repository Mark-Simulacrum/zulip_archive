[
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/pull/3192\">https://github.com/rust-lang/rfcs/pull/3192</a></p>\n<p>Hi libs team (and libs-interested folk), I posted this RFC last week. It proposes adding a new module to libcore for adding type-driven access to data in trait objects. It is somewhat related to the any module in that it is a dynamic/reflective capability. The motivation is for retrieving context from Error objects and is part of the Error WG's roadmap. It is fairly high priority for the Error WG, so I would be very grateful if people could take a look!</p>",
        "id": 260970184,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636540067
    },
    {
        "content": "<p>I'm happy to discuss here or on the RFC. Or, if anyone is interested, I'm happy to have a call to discuss things in depth</p>",
        "id": 260970255,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636540104
    },
    {
        "content": "<p>I've nominated it for discussion. (That doesn't guarantee we'll get to it this week.)</p>",
        "id": 260974687,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636542647
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 260975457,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636543111
    },
    {
        "content": "<p>So, the fully general answer for \"I want to provide a field of type T but the type is already doing so\" is \"wrap it in a newtype\"?</p>",
        "id": 260976219,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543561
    },
    {
        "content": "<p>yes</p>",
        "id": 260978052,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636544692
    },
    {
        "content": "<p>Or use a different tag type I think</p>",
        "id": 260990299,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636551845
    },
    {
        "content": "<p>Tho not sure if that is exposed atm</p>",
        "id": 260990330,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636551864
    },
    {
        "content": "<p>It is exposed and users could do that</p>",
        "id": 260991778,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636552564
    },
    {
        "content": "<p>Interesting API; having a \"single <code>Error</code> API addition to rule them all\" seems very appealing indeed <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n<p>Some remarks:</p>\n<p>Given the complexity of non-<code>'static</code>-<code>Any </code> erasure (many programmers may not be well acquainted with the pattern), I'd suggest some intro or dedicated blog post to the matter, similar to how Niko wrote all those blog posts regarding <code>async fn</code> in traits. I've personally made the effort to \"reduce\" that pattern down to a file, and to try and rename stuff for, I hope, maximal clarity: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=501cada82665f147615b504bccac14dd\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=501cada82665f147615b504bccac14dd</a></p>\n<hr>\n<p>I do think think that the example ought to show usage of newtypes right away; otherwise the risk of conflicts would be too big ( and it would have the tangential benefit of \"naming\" the fields that we are querying):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">lib</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[derive(::ref_cast::RefCast)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[repr(transparent)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Context</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">provide_context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">req</span>: <span class=\"nc\">Requisition</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">req</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">provide_ref</span>::<span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">lib</span>::<span class=\"n\">Context</span><span class=\"o\">&lt;</span><span class=\"n\">Backtrace</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">RefCast</span>::<span class=\"n\">ref_cast</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">backtrace</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">provide_ref</span>::<span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">lib</span>::<span class=\"n\">Context</span><span class=\"o\">&lt;</span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">RefCast</span>::<span class=\"n\">ref_cast</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">suggestion</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>although it is a bit cumbersome. Taking <span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby [she/her]</span>'s suggestion, it would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">lib</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">static_ty_constructors</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Ref</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&lt;'</span><span class=\"na\">lt</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">lt</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">provide_context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">req</span>: <span class=\"nc\">Requisition</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">req</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">provide</span>::<span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">lib</span>::<span class=\"n\">Ref</span><span class=\"o\">&lt;</span><span class=\"n\">Backtrace</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">backtrace</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">provide</span>::<span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">lib</span>::<span class=\"n\">Ref</span><span class=\"o\">&lt;</span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">suggestion</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It's a bit better, but both cases are a bit too cumbersome / complex for downstream users, although I guess either case could be handled by a lib-provided <code>provide_context</code> macro?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">provide_context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">req</span>: <span class=\"nc\">Requisition</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">lib</span>::<span class=\"n\">provide_context</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">req</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">&amp;</span><span class=\"n\">Backtrace</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">backtrace</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">&amp;</span><span class=\"kt\">str</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">suggestion</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So even though newtypes would solve conflicts in a robust fashion, as well as provide a way to name these things, I think a more intuitive API would be to just provide names altogether, assuming generic <code>const &amp;str</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">provide_context</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">req</span>: <span class=\"nc\">Requisition</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">req</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">provide_ref</span>::<span class=\"o\">&lt;</span><span class=\"n\">Backtrace</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"lib::backtrace\"</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">backtrace</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">provide_ref</span>::<span class=\"o\">&lt;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"lib::suggestion\"</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">suggestion</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261022751,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636564857
    },
    {
        "content": "<p>Maybe i ask a perhaps naive question about <code>Error</code> and <code>backtrace</code>.   If the <code>Backtrace</code> type was a extern type defined in \"C\", the <code>Error</code>-in-<code>core</code> problem is immediately solved, right?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">downstream</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Backtrace</span><span class=\"p\">;</span><span class=\"w\">   </span><span class=\"c1\">// fictional syntax;</span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">fn</span> <span class=\"nf\">backtrace</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Backtrace</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>just like in C++:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"c1\">/// core.h</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Backtrace</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">class</span> <span class=\"nc\">IError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">virtual</span><span class=\"w\"> </span><span class=\"o\">~</span><span class=\"n\">IError</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">virtual</span><span class=\"w\"> </span><span class=\"n\">Backtrace</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"nf\">get_backtrace</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I mean, i'm a little confused, what's exactly stopping us from allowing declaring an existential type that will be defined in a downstream crate?</p>",
        "id": 261243895,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636719386
    },
    {
        "content": "<p>Language support</p>",
        "id": 261244104,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636719546
    },
    {
        "content": "<p>We could do that but what would the advantage be? You'd still have to provide the implemention when in no_std and as far as I can tell it would be no different in practice to the backtrace in core RFC</p>",
        "id": 261244305,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636719663
    },
    {
        "content": "<p>When providing implementation, if one don't have/need <code>alloc</code>, they can just implement <code>backtrace</code> fn with <code>{ None }</code>. After far as i can tell, there's no need for <code>Backtrace</code>'s layout or other information if we know that it's <code>Sized</code> (somehow) here.</p>",
        "id": 261244690,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636719908
    },
    {
        "content": "<p>How would Backtrace::capture work?</p>",
        "id": 261244830,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636719983
    },
    {
        "content": "<p>Also to be clear, I'm not against this idea I just don't know how to make it work and my current impression is that it's not worth it since we know we want generic member access either way</p>",
        "id": 261244936,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636720079
    },
    {
        "content": "<p>Sure, i'm not against generic member access as a functionality. Just not sure if it's something that's better opt-in than living in core :)</p>",
        "id": 261245233,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636720288
    },
    {
        "content": "<p>And i know <a href=\"https://github.com/tokio-rs/valuable\">https://github.com/tokio-rs/valuable</a>  provides another approach for accessing members.</p>",
        "id": 261245399,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636720409
    },
    {
        "content": "<p>How would it integrate with the error trait without being in core?</p>",
        "id": 261245491,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636720449
    },
    {
        "content": "<p>Maybe by defining another trait with error trait as super trait?</p>",
        "id": 261245599,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636720552
    },
    {
        "content": "<p>That can't work as shown by the Fail trait from the failure crate, it would require that everyone switched to the new trait</p>",
        "id": 261245727,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636720636
    },
    {
        "content": "<p>Also it would have to implement its own source method that returns the super trait to be able to report context from sources</p>",
        "id": 261245776,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636720676
    },
    {
        "content": "<p>Tho technically that could be avoided by using the generic member access method from the new trait to supercede the source method, but this would be incredibly hard (probably impossible) to coordinate across the ecosystem</p>",
        "id": 261245890,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636720736
    },
    {
        "content": "<p>I'd love to see a proposal based on valuable though</p>",
        "id": 261246005,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636720798
    },
    {
        "content": "<p>I've taken a look at it but my assumption is that it's more focused on letting the callee inform the caller of which data it has so that it can basically push information into logging and other systems. Whereas generic number access is more pull-based where the reporter grabs out the context it believes is relevant when creating an error report</p>",
        "id": 261246130,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636720869
    },
    {
        "content": "<p>i think the central difference is that, whether the caller learn information from the callee, or the caller making assumptions based on outband knowledge (an error maybe has a backtrace, etc)</p>",
        "id": 261246386,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636721031
    },
    {
        "content": "<p>And maybe an error has two backtraces... now which?</p>",
        "id": 261246742,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636721209
    },
    {
        "content": "<p>If anything that seems like an argument for generic member access since you can return a &amp;[Backtrace] or use a different tag type for each one, whereas fn backtrace is far more restrictive</p>",
        "id": 261246844,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636721269
    },
    {
        "content": "<p>Or an iterator</p>",
        "id": 261246863,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636721277
    },
    {
        "content": "<p>Or some specific trait wrapper, whatever makes sense for your application</p>",
        "id": 261246932,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636721299
    },
    {
        "content": "<p>Though I have trouble imagining an error where a single error in the chain would store multiple Backtraces. Do you have an example scenario in mind?</p>",
        "id": 261246991,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636721339
    },
    {
        "content": "<p>Sure, imagine parallel rustc collects 10 ICEs (definitely impossible) from a single run. Now here's an error report with 10 backtraces.</p>",
        "id": 261247158,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636721415
    },
    {
        "content": "<p>That sounds more like a report with 10 source errors to me</p>",
        "id": 261247230,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636721461
    },
    {
        "content": "<p>Maybe. Now this is semantic inspection without schema but with lots of singletons (identified by typetags), without any support for enums, arrays, maps and other reprs. I feel there's something not entirely correct with this approach.</p>",
        "id": 261247672,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636721741
    },
    {
        "content": "<blockquote>\n<p>I mean, i'm a little confused, what's exactly stopping us from allowing declaring an existential type that will be defined in a downstream crate?</p>\n</blockquote>\n<p>It would break if there were multiple downstream crates defining that type. so you'd need to define exactly which crate will define that type. but then you basically need to depend on a downstream crate, which introduces a cycle.</p>\n<p>a general way for downstream crates to plug implementations into upstream crates would be super useful for many things though. right now we only have that for panic handling and allocation basically (and the <code>main</code> funciton, depending how you look at it), each with their own specific mechanism. it could be used for many more things, such as providing os/platform-specific parts of <code>std</code> through a separate crate. definitely not going to be easy to design this though.</p>\n<p>your C++ example isn't easily transferrable to Rust, because if two translation units would have their own version of <code>struct Backtrace</code>, <code>IError</code> in the header would still compile fine, resulting in all kind of unsoundness when one of those <code>Backtrace</code> structs gets interpreted as the other.</p>",
        "id": 261251441,
        "sender_full_name": "Mara",
        "timestamp": 1636723796
    },
    {
        "content": "<p>is downstream even the right place for that? it could be a dependency-shaped hole in a crate that needs to be filled before you can build anything depending on it</p>",
        "id": 261252493,
        "sender_full_name": "The 8472",
        "timestamp": 1636724242
    },
    {
        "content": "<p>sure, whether you would call it 'up' or 'down' depends on your definitions i suppose. but it's not something that the crate 'with the hole' defines as a dependency by itself. something else ('downstream') will have to fill that hole.</p>",
        "id": 261252712,
        "sender_full_name": "Mara",
        "timestamp": 1636724330
    },
    {
        "content": "<p>well, a depenceny hole could be filled by cargo by inserting it before building core (so assuming Zbuild-std). that might require less compiler magic.</p>",
        "id": 261253201,
        "sender_full_name": "The 8472",
        "timestamp": 1636724558
    },
    {
        "content": "<p>sure, but there are also many downsides to that approach. but let's not derail the provide_any discussion.</p>",
        "id": 261253311,
        "sender_full_name": "Mara",
        "timestamp": 1636724624
    },
    {
        "content": "<p>I think there's an extern trait rfc that more or less proposed this kind of mechanism that I really liked</p>",
        "id": 261255647,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636725674
    }
]