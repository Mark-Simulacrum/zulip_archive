[
    {
        "content": "<p>I see that the current stance on <code>Either&lt;A, B&gt;</code> is that it's a bad idea; has such a type been considered but specifically as some kind of \"iterator adapter\"? I was trying to write code like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">some_iter</span><span class=\"p\">.</span><span class=\"n\">flat_map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">val</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">some_cond</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">one_iter</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">two_iter</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where the iterators yielded by <code>one_iter</code> and <code>two_iter</code> can't be tricked into being the same type, but getting this to compile is actually a bit of a pain. The options here seem to be to fold into a <code>Vec</code>, create <code>Box&lt;dyn Iterator&gt;</code>s, or to create my own type that is basically <code>Either</code> with only an <code>Iterator</code> impl. Has an <code>EitherIter&lt;A: Iterator, B: Iterator&gt;</code> type been considered that is there specifically to address this kind of situation? Or is this a \"this belongs in <code>Itertools</code>\" type situation?</p>",
        "id": 261301240,
        "sender_full_name": "Jake",
        "timestamp": 1636746156
    },
    {
        "content": "<p>Slight complication here is that I can't find a way to cleanly express this as an iterator adapter, maybe someone has a better idea than me though</p>",
        "id": 261301506,
        "sender_full_name": "Jake",
        "timestamp": 1636746283
    },
    {
        "content": "<p>For iterator additions, I would definitely assume that if it hasn't been prototyped in itertools and that's the first place to start</p>",
        "id": 261302139,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1636746565
    },
    {
        "content": "<p>itertools does have an <code>Either</code> type that implements <code>Iterator</code> with these semantics, but it doesn't require its contents to be iterators and has a bunch of other implementations that make it a more or less general purpose Either type. This seems to be the version of things that rust has decided <code>std</code> should not have</p>",
        "id": 261302622,
        "sender_full_name": "Jake",
        "timestamp": 1636746809
    },
    {
        "content": "<p>Do you mean EitherIter&lt;A: Iterator, B: Iterator&gt; where A::Item == B::Item ?</p>",
        "id": 261303182,
        "sender_full_name": "The 8472",
        "timestamp": 1636747057
    },
    {
        "content": "<p>Yeah, I'll edit to clarify</p>",
        "id": 261303221,
        "sender_full_name": "Jake",
        "timestamp": 1636747079
    },
    {
        "content": "<p>I mean you can kind fudge that by cobbling them together serially... <code>some_option.iter().chain(other_option)</code> and just have one of the options be <code>None</code>. That's how you can work around <code>flat_map</code>.</p>",
        "id": 261303427,
        "sender_full_name": "The 8472",
        "timestamp": 1636747193
    },
    {
        "content": "<p>Yeah, I had asked on the community discord about this at first and someone suggested that, but between the readability and ergonomics of that I'd rather just write a one-time <code>Either</code> equivalent type</p>",
        "id": 261303705,
        "sender_full_name": "Jake",
        "timestamp": 1636747308
    },
    {
        "content": "<p>Yeah, but that's basically just one particular instance of the many ways where mismatched concrete types can arise. if you have more complex control flow in your closure then you might need a \"any one of these 3 types, or sometimes a chain, occasionally None\"</p>",
        "id": 261304137,
        "sender_full_name": "The 8472",
        "timestamp": 1636747490
    },
    {
        "content": "<p>Yeah, I was thinking about that as well. Between that and the issue around a nice signature for this, I might try writing a macro that covers these cases with good ergonomics</p>",
        "id": 261304620,
        "sender_full_name": "Jake",
        "timestamp": 1636747781
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">flat_map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">val</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_condition</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">iter</span>::<span class=\"n\">from_fn</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">cond</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"n\">do_something_with_val</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"n\">do_other_thing</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">})</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Allows more complex control flow.</p>",
        "id": 261305258,
        "sender_full_name": "The 8472",
        "timestamp": 1636748148
    },
    {
        "content": "<p>well, doesn't help when you have to give up ownership</p>",
        "id": 261305428,
        "sender_full_name": "The 8472",
        "timestamp": 1636748237
    },
    {
        "content": "<p>Hm, yeah, this seems like it covers some cases but not others (and unfortunately not my original one)</p>",
        "id": 261305604,
        "sender_full_name": "Jake",
        "timestamp": 1636748324
    },
    {
        "content": "<p>Actually, I don't see how this really addresses the issue. Can you try and provide an example of a use?</p>",
        "id": 261305783,
        "sender_full_name": "Jake",
        "timestamp": 1636748409
    },
    {
        "content": "<p>I don't have a concrete use-case, most of the time I get by by stuffing things into <code>[Option::IntoIter&lt;_&gt;; N]</code> or chains and flatten those.</p>",
        "id": 261308231,
        "sender_full_name": "The 8472",
        "timestamp": 1636749855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60EitherIter.60.20type/near/261302622\">said</a>:</p>\n<blockquote>\n<p>itertools does have an <code>Either</code> type that implements <code>Iterator</code> with these semantics, </p>\n</blockquote>\n<p>FWIW, that version is just a re-export from the <code>either</code> crate.</p>",
        "id": 261308584,
        "sender_full_name": "cuviper",
        "timestamp": 1636750083
    },
    {
        "content": "<p>Damn rustdoc being smart enough to make me not notice <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 261308761,
        "sender_full_name": "Jake",
        "timestamp": 1636750191
    },
    {
        "content": "<p>they also use it for <code>Itertools::partition_map</code>, which is a neat adapter</p>",
        "id": 261309068,
        "sender_full_name": "cuviper",
        "timestamp": 1636750366
    },
    {
        "content": "<p><code>partition_map</code> is great!</p>\n<p>Last I heard the big uncertainty with <code>Either</code> is that it can't be both <code>IntoIterator</code> when both types are <code>IntoIterator</code> <em>and</em> <code>Iterator</code> when both types are <code>Iterator</code>, because of the blanket.  Which made people sad.</p>",
        "id": 261319113,
        "sender_full_name": "scottmcm",
        "timestamp": 1636755750
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/.60EitherIter.60.20type/near/261319113\">said</a>:</p>\n<blockquote>\n<p><code>partition_map</code> is great!</p>\n<p>Last I heard the big uncertainty with <code>Either</code> is that it can't be both <code>IntoIterator</code> when both types are <code>IntoIterator</code> <em>and</em> <code>Iterator</code> when both types are <code>Iterator</code>, because of the blanket.  Which made people sad.</p>\n</blockquote>\n<p>Interesting, although I don't think this would be an issue with the proposed <code>EitherIter</code> as it is less general, so we can just have both types require <code>IntoIterator</code> and have <code>EitherIter: Iterator</code> (doing the <code>.into_iterator()</code> call when the type is constructed, however that ends up happening)</p>",
        "id": 261324538,
        "sender_full_name": "Jake",
        "timestamp": 1636759650
    },
    {
        "content": "<p>Yes, if you have a separate <code>Iterator</code> type, it should be fine. In the <code>either</code> crate, it already did implement <code>Iterator</code> before I came along wanting <code>IntoIterator</code>: <a href=\"https://github.com/bluss/either/pull/12\">https://github.com/bluss/either/pull/12</a></p>",
        "id": 261330308,
        "sender_full_name": "cuviper",
        "timestamp": 1636765504
    },
    {
        "content": "<p>Ehhh, sorry, I misspoke earlier. What I meant was that I think there's no need for an <code>IntoIterator</code> type; we can just have an <code>IntoIterator</code> version of the constructor (again, not sure how this would actually be constructed yet) and that seems like it would be enough</p>",
        "id": 261330786,
        "sender_full_name": "Jake",
        "timestamp": 1636766089
    }
]