[
    {
        "content": "<p>Hi everyone :) not sure who I should address this to so here we are :-) </p>\n<p>The <code>std::path::{PathBuf, Path}::{push, join}</code> have a weird (albeit documented) behavior.  In particular,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">PathBuf</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"/some/root\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">PathBuf</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"/foo\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">real_foo_path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">root</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Documentation not withstanding, one would expect a join (or a push) to append foo to root, and for <code>real_foo_path</code> to contain <code>/some/root/foo</code>.  However the current (admittedly documented) behavior is that real_foo_path becomes <code>\"/foo\"</code>  ... Given that semantically one should expect a <code>join</code> to do a <code>join</code> (and a push to perform an append) instead of a replace. If misunderstood by programmers (which I feel this has a better than 50% chance of being misunderstood) can lead to weird and subtle bugs that would be hard to trace if someone made  (a reasonably) assumptive mistake that join and push work identically to the behaviors in:</p>\n<table>\n<thead>\n<tr>\n<th>Call</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>std::collections::BinaryHeap::push</code></td>\n<td>Pushes an item onto the binary heap.</td>\n</tr>\n<tr>\n<td><code>std::ffi::OsString::push</code></td>\n<td>Extends the string with the given &amp;OsStr slice.</td>\n</tr>\n<tr>\n<td><code>std::path::PathBuf::push</code></td>\n<td>Extends self with path.</td>\n</tr>\n<tr>\n<td><code>std::string::String::push</code></td>\n<td>Appends the given char to the end of this String.</td>\n</tr>\n<tr>\n<td><code>std::vec::Vec::push</code></td>\n<td>Appends an element to the back of a collection.</td>\n</tr>\n<tr>\n<td><code>std::string::String::push_str</code></td>\n<td>Appends a given string slice onto the end of this String.</td>\n</tr>\n<tr>\n<td><code>std::collections::LinkedList::push_back</code></td>\n<td>Appends an element to the back of a list.</td>\n</tr>\n<tr>\n<td><code>std::collections::VecDeque::push_back</code></td>\n<td>Appends an element to the back of the VecDeque.</td>\n</tr>\n<tr>\n<td><code>std::collections::linked_list::CursorMut::push_back</code></td>\n<td>Appends an element to the back of the cursor's parent</td>\n</tr>\n<tr>\n<td><code>std::collections::LinkedList::push_front</code></td>\n<td>Adds an element first in the list.</td>\n</tr>\n<tr>\n<td><code>std::collections::VecDeque::push_front</code></td>\n<td>Prepends an element to the VecDeque.</td>\n</tr>\n<tr>\n<td><code>std::collections::linked_list::CursorMut::push_front</code></td>\n<td>Appends an element to the front of the cursorâ€™s parent.</td>\n</tr>\n</tbody>\n</table>\n<p>similarly for <code>slice::join</code> the behavior is to join two thing together.</p>\n<p>From the summary above, PathBuf reads as if it would behave the way I was expecting and not in the way that it does.</p>\n<p>My question is, is this something that should be changed? Or what would be the procedure to extend help with this? </p>\n<p>Cheers,</p>",
        "id": 256919819,
        "sender_full_name": "Ahmed Masud",
        "timestamp": 1633835792
    },
    {
        "content": "<p>PathBuf::push's doc reads:</p>\n<blockquote>\n<p>Extends self with path.</p>\n<p>If path is absolute, it replaces the current path.</p>\n</blockquote>",
        "id": 256920522,
        "sender_full_name": "Gary Guo",
        "timestamp": 1633836613
    },
    {
        "content": "<p>This behaviour is documented and being relied on, so no, it couldn't changed.</p>",
        "id": 256920540,
        "sender_full_name": "Gary Guo",
        "timestamp": 1633836646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> yes. and TY</p>",
        "id": 256932179,
        "sender_full_name": "Ahmed Masud",
        "timestamp": 1633849502
    },
    {
        "content": "<p>this is consistent with filesystem behavior (openat) and path resolution of various other programming languages. Even URL parsers. absolute resolved on another path just returns the absolute one</p>",
        "id": 256935877,
        "sender_full_name": "The 8472",
        "timestamp": 1633853294
    },
    {
        "content": "<p>perhaps it should have been named better. some other langs call it <code>resolve</code></p>",
        "id": 256935920,
        "sender_full_name": "The 8472",
        "timestamp": 1633853362
    },
    {
        "content": "<p>I do think there should be a <code>push_relative</code> (or similar) for when you don't want this behaviour.</p>",
        "id": 256936522,
        "sender_full_name": "Chris Denton",
        "timestamp": 1633853960
    },
    {
        "content": "<p>why is your path starting with a / though if you want it to be relative?</p>",
        "id": 256936659,
        "sender_full_name": "The 8472",
        "timestamp": 1633854114
    },
    {
        "content": "<p>and how would it work on windows if you push <code>C:\\</code> ?</p>",
        "id": 256936843,
        "sender_full_name": "The 8472",
        "timestamp": 1633854283
    }
]