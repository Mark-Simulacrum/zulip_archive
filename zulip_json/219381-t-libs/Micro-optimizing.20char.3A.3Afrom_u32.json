[
    {
        "content": "<p><code>char::from_u32</code> currently checks <code>(i &gt; char::MAX) || (i &gt;= 0xD800 &amp;&amp; i &lt;= 0xDFFF)</code>. This could be done with fewer instructions as <code>(i ^ 0xffff2000) + 2048 &lt;= 0xffef07ff</code>. Does this seem worthwhile? Is <code>char::from_u32</code> an important building block somewhere?</p>",
        "id": 272146171,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1645031597
    },
    {
        "content": "<p>I think it could be worthwhile to optimize it a bit.</p>",
        "id": 272146565,
        "sender_full_name": "bjorn3",
        "timestamp": 1645031743
    },
    {
        "content": "<p>we'll need heavy comments to explain what's going on there</p>",
        "id": 272148129,
        "sender_full_name": "cuviper",
        "timestamp": 1645032310
    },
    {
        "content": "<p>why put the <code>+ 2048</code> on the left instead of subtracting it from the right value?</p>",
        "id": 272148213,
        "sender_full_name": "cuviper",
        "timestamp": 1645032347
    },
    {
        "content": "<p>I think it's definitely worth optimizing.</p>",
        "id": 272148934,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645032610
    },
    {
        "content": "<p>Well it should be a wrapping_add so the <code>+ 2048</code> can't be moved to the other side. And unfortunately it's kinda hard to explain, I don't have any short explanation, maybe someone else has :-)</p>",
        "id": 272149788,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1645032934
    },
    {
        "content": "<p>\"hard to explain\" is all the more reason that it <em>needs</em> to be explained :)</p>",
        "id": 272150047,
        "sender_full_name": "cuviper",
        "timestamp": 1645033032
    },
    {
        "content": "<p>I don't think the explanation needs to be short, fwiw</p>",
        "id": 272150876,
        "sender_full_name": "simulacrum",
        "timestamp": 1645033360
    },
    {
        "content": "<p>We have some other many-line comments explaining bit twiddling around string and int operations</p>",
        "id": 272153820,
        "sender_full_name": "The 8472",
        "timestamp": 1645034475
    },
    {
        "content": "<p>FWIW I think it would be easier to understand if written as <code>(i ^ !0xDFFF).wrapping_add(0x800) &lt;= !0x10F800</code></p>",
        "id": 272154076,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645034547
    },
    {
        "content": "<p>the right hand constant <code>!0x10F800</code> can also be written as <code>u32::MAX - char::MAX as u32</code></p>",
        "id": 272154367,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645034647
    },
    {
        "content": "<p>oh, that definitely helps me! it's still not <em>obvious</em>, but at least the connection to the surrogate range and MAX is there.</p>",
        "id": 272154488,
        "sender_full_name": "cuviper",
        "timestamp": 1645034691
    },
    {
        "content": "<p>Is this a generalizable pattern?  Because part of me says that this transformation should be something that LLVM does, like how (IIRC) it knows about things like <code>a &lt; x &lt; b</code> into <code>(x - a) ULT (b-a)</code>...</p>",
        "id": 272155552,
        "sender_full_name": "scottmcm",
        "timestamp": 1645035074
    },
    {
        "content": "<p>I'm still working through it, but there is a bit more to it than just that. That explains the <code>value + const &lt; const</code> part but not the XOR, which is doing something like reversing the entire range in chunks</p>",
        "id": 272155998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645035238
    },
    {
        "content": "<p>basically there are two ranges of interest, <code>0xD800..=0xDFFF</code> and <code>0x110000..</code>. The XOR inverts everything but the significant bits of that first range, placing it at the top, while the second range ends up at the bottom. Then the wrapping add puts us into one contiguous range, ready for a single comparison.</p>",
        "id": 272157418,
        "sender_full_name": "cuviper",
        "timestamp": 1645035841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/Micro-optimizing.20char.3A.3Afrom_u32/near/272154367\">said</a>:</p>\n<blockquote>\n<p>the right hand constant <code>!0x10F800</code> can also be written as <code>u32::MAX - char::MAX as u32</code></p>\n</blockquote>\n<p>it's also <code>+ 0x800</code> to include the surrogate range</p>",
        "id": 272158271,
        "sender_full_name": "cuviper",
        "timestamp": 1645036213
    },
    {
        "content": "<p>It's also possible to do without the inversion of the whole range: <code>(i ^ 0xDFFF).wrapping_sub(0x800) &gt;= 0x10F800</code> generates approximately equivalent machine code (same number and strength of instructions) and is IMO a little easier to think about</p>",
        "id": 272159419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645036777
    },
    {
        "content": "<p>you can also use <code>0xD800</code> instead of <code>0xDFFF</code> in the XOR. <code>(i ^ 0xD800).wrapping_sub(0x800) &gt; 0x10FFFF - 0x800</code> is the most perspicuous version I can find</p>",
        "id": 272159980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645037071
    },
    {
        "content": "<p>the wrapping sub looks like this would be more readable in i32</p>",
        "id": 272161780,
        "sender_full_name": "The 8472",
        "timestamp": 1645037956
    },
    {
        "content": "<p>no, it's an unsigned less than</p>",
        "id": 272161824,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645037980
    },
    {
        "content": "<p>if you tried to do the same trick on <code>i32</code> you would still need <code>wrapping_sub</code>, and <code>i32::MAX</code> would get involved as well</p>",
        "id": 272161976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645038020
    },
    {
        "content": "<p>Here's a shot at an explainer:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">is_bad_char</span><span class=\"p\">(</span><span class=\"n\">i</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// This is an optimized version of the check</span>\n<span class=\"w\">    </span><span class=\"c1\">// i &gt;= 0x110000 || (i &gt;= 0xD800 &amp;&amp; i &lt; 0xE000).</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"c1\">// The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is</span>\n<span class=\"w\">    </span><span class=\"c1\">// mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.</span>\n<span class=\"w\">    </span><span class=\"c1\">// In particular, numbers &gt;= 0x110000 stay in this range.</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"c1\">// Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single</span>\n<span class=\"w\">    </span><span class=\"c1\">// unsigned comparison against 0x110000 - 0x800 will detect both the wrapped</span>\n<span class=\"w\">    </span><span class=\"c1\">// surrogate range as well as the numbers originally larger than 0x110000.</span>\n<span class=\"w\">    </span><span class=\"c1\">//</span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">^</span><span class=\"w\"> </span><span class=\"mh\">0xD800</span><span class=\"p\">).</span><span class=\"n\">wrapping_sub</span><span class=\"p\">(</span><span class=\"mh\">0x800</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"w\"> </span><span class=\"mh\">0x110000</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mh\">0x800</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272162338,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645038179
    },
    {
        "content": "<p>I decided to use only multiples of 0x800 in the description, instead of using numbers one less than a multiple of 0x800 in some places. This makes the bit tricks a little easier to follow, but weakens the connection to <code>char::MAX</code> and the surrogate range (depending on how it is presented)</p>",
        "id": 272162580,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645038288
    },
    {
        "content": "<p>\"swapped with\" might be easier to understand than \"mapped to\"</p>",
        "id": 272162903,
        "sender_full_name": "The 8472",
        "timestamp": 1645038415
    },
    {
        "content": "<p>That kind of sounds like nothing else is being swapped though, when this is really swapping lots of things</p>",
        "id": 272163203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645038544
    },
    {
        "content": "<p>It might be my math brain, but I didn't intend to claim it was a swap, simply a permutation that puts <code>0xD800..0xE000</code> -&gt; <code>0x0000..0x0800</code> and puts <code>0x0000..0x0800</code> somewhere else</p>",
        "id": 272163272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645038579
    },
    {
        "content": "<p>and it's not really relevant where the original 0-based range ends up</p>",
        "id": 272163378,
        "sender_full_name": "cuviper",
        "timestamp": 1645038611
    },
    {
        "content": "<p>It is relevant that the original 0-based range doesn't end up at &gt;= 0x110000.</p>",
        "id": 272166133,
        "sender_full_name": "bjorn3",
        "timestamp": 1645039765
    },
    {
        "content": "<p>in some cases, it's more optimal to use the original code: <code>(i &gt; MAX as u32) || (i &gt;= 0xD800 &amp;&amp; i &lt;= 0xDFFF)</code> because it can be executed in 2 cycles if a cpu has a ternary logic operator (as we're working on adding to OpenPower as part of Libre-SOC, x86 also has that as the <a href=\"https://www.felixcloutier.com/x86/vpternlogd:vpternlogq\"><code>vpternlogd</code> instruction</a>), allowing it to do <code>a | (b &amp; c)</code> in one operation:<br>\nall 3 comparison instructions are run in parallel in the first clock cycle, then the results are all combined with the ternary operator in the second clock cycle.</p>",
        "id": 272166292,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1645039819
    },
    {
        "content": "<p>libstd is probably not going to be compiled with <code>-Ctarget-feature=+avx512f,+avx512vl</code> most of the time, so i think this optimization is still worth doing, since it benefits most users. I also think that the case where this operation will be vectorized is pretty small</p>",
        "id": 272167466,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645040291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437892\">Falk Hüffner</span> <a href=\"#narrow/stream/219381-t-libs/topic/Micro-optimizing.20char.3A.3Afrom_u32/near/272146171\">said</a>:</p>\n<blockquote>\n<p>Is <code>char::from_u32</code> an important building block somewhere?</p>\n</blockquote>\n<p>I think it's probably not all that common, since things tend to deal in UTF-8 directly.  For example, <code>from_utf8</code> just checks for valid UTF-8 sequences instead of decoding to <code>u32</code> and checking that: <a href=\"https://github.com/rust-lang/rust/blob/cc946fcd326f7d85d4af096efdc73538622568e9/library/core/src/str/validations.rs#L171-L182\">https://github.com/rust-lang/rust/blob/cc946fcd326f7d85d4af096efdc73538622568e9/library/core/src/str/validations.rs#L171-L182</a></p>",
        "id": 272167474,
        "sender_full_name": "scottmcm",
        "timestamp": 1645040295
    },
    {
        "content": "<p>fwiw, this would also affect <code>TryFrom&lt;u32&gt; for char</code>, which is more annoying to find actual uses</p>",
        "id": 272168541,
        "sender_full_name": "cuviper",
        "timestamp": 1645040755
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> this looks really nice, would you be interested in sending a pull request? (The code is in <code>library/core/src/char/convert.rs</code> <code>char_try_from_u32</code>)</p>",
        "id": 272173923,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1645043361
    },
    {
        "content": "<p>About adding this to llvm: It seems like the right thing to do but from what I understand, it's quite hard to introduce such optimizations since we have to define this as the canonical form of this kind of comparison, and then various other optimizations have to deal with comparisons possibly being in this form and unwrap it again to see if other transformations apply.</p>",
        "id": 272174137,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1645043475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/Micro-optimizing.20char.3A.3Afrom_u32/near/272167466\">said</a>:</p>\n<blockquote>\n<p>libstd is probably not going to be compiled with <code>-Ctarget-feature=+avx512f,+avx512vl</code> most of the time, so i think this optimization is still worth doing, since it benefits most users. I also think that the case where this operation will be vectorized is pretty small</p>\n</blockquote>\n<p>It does suggest this sort of optimization is better suited for LLVM though, which has the knowledge necessary to pick the best implementation.</p>",
        "id": 272340817,
        "sender_full_name": "nagisa",
        "timestamp": 1645141666
    },
    {
        "content": "<p>I mean, even if the &amp; and | are a single operation, it's still <code>[xor, sub, compare]</code> vs <code>[3 compares, ternary]</code> (which can perhaps be simplified a bit further). but it's not clear to me that this is actually a case where it wouldn't be faster with the change everywhere.</p>",
        "id": 272341042,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645141841
    },
    {
        "content": "<p>The three comparisons could all be executed in a single instruction with SIMD or executed on different execution units (how many of them there are is yet another that's only known to codegen backend) for execution and retire in the same cycle. xor sub compare approach imposes a linear register dependency requiring each prior instruction to retire before the next one can be executed. OTOH there's something to be said about xor sub compare being straightforward to autovectorize when dealing with data in an array. And the potential perf benefit of the ternary cmp will be very minor (fractional parts of a cycle on modern designs) suggests there's little reason to not make this change in libstd.</p>",
        "id": 272343782,
        "sender_full_name": "nagisa",
        "timestamp": 1645143798
    },
    {
        "content": "<p>Yeah, I suppose that might come into play. I feel like in practice this sort of thing tends to come out being beneficial most of the time (those execution units often have other work to do, i suppose). It's also a lot better in debug builds: <a href=\"https://godbolt.org/z/dTbEo5vW5\">https://godbolt.org/z/dTbEo5vW5</a> (I guess this doesnt really matter for std, though).</p>",
        "id": 272358841,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645157813
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437892\">Falk Hüffner</span> <a href=\"#narrow/stream/219381-t-libs/topic/Micro-optimizing.20char.3A.3Afrom_u32/near/272173923\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> this looks really nice, would you be interested in sending a pull request? (The code is in <code>library/core/src/char/convert.rs</code> <code>char_try_from_u32</code>)</p>\n</blockquote>\n<p>This has been submitted as <a href=\"https://github.com/rust-lang/rust/issues/94112\">#94112</a></p>",
        "id": 272359538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645158660
    }
]