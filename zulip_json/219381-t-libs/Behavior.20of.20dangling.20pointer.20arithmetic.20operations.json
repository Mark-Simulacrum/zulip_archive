[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/272861975\">said</a>:</p>\n<blockquote>\n<p>Hmm, seems like we need more words here then, since the topic mentions <code>Unique::dangling</code>, so that's how I was interpreting it.</p>\n<p>So are you saying that <code>.add(0)</code> after moving out side an allocated object would be UB?  Like <code>.wrapping_offset(100).add(0)</code>?  That would make sense to me.</p>\n</blockquote>\n<p>I renamed the topic name since this has shifted a bit. Hopefully it makes more sense now.</p>\n<p>The main question now is under which conditions the pointer <code>add()</code> operation has UB when dealing with dangling pointers. I can also move this discussion to  <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines\">#t-lang/wg-unsafe-code-guidelines</a> if it's a better channel for that.</p>\n<p>Thanks again for all the answers.</p>",
        "id": 272863626,
        "sender_full_name": "Celina V.",
        "timestamp": 1645562562
    },
    {
        "content": "<p>I guess, from the perspective of validation, you could think of <code>dangling()</code> as being</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">empty</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">empty</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where it returns a pointer to an allocated object, so the <code>add(0)</code> on that is valid, but if you move it off that allocated object at all (like <code>.wrapping_offset(1)</code>) then then <code>.add(0)</code> is no longer valid any more.</p>\n<p>(That particular implementation doesn't compile today, though, since it -- possibly erroneously? -- requires <code>T: 'static</code>.)</p>",
        "id": 272865011,
        "sender_full_name": "scottmcm",
        "timestamp": 1645563274
    },
    {
        "content": "<p>I was reading about this issue a bit more and I found <a href=\"https://doc.rust-lang.org/nomicon/vec/vec-alloc.html\">this Rustonomicon document on vector allocation</a>. In this document, they do allocate even for <code>0</code> capacity vector to ensure safe alias analysis.</p>",
        "id": 272886348,
        "sender_full_name": "Celina V.",
        "timestamp": 1645575901
    },
    {
        "content": "<p>Oh, interesting implementation idea. The following, by the way, does compile on stable Rust:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">dangling</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Generic</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">EMPTY_SLICE</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Generic</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">EMPTY_SLICE</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Generic</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">EMPTY_SLICE</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272960828,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1645628795
    },
    {
        "content": "<p>I think that's equivalent to <code>[].as_ptr()</code>, since it's a <code>const</code> not a <code>static</code>, and that also compiles -- but returns (AFAICT) a pointer to the ZST local.</p>\n<p>Perhaps that's another case of the \"it pointed to an object that's definitely no longer around\" and thus is UB despite being a properly-aligned ZST?</p>",
        "id": 272980242,
        "sender_full_name": "scottmcm",
        "timestamp": 1645636659
    },
    {
        "content": "<p>No, that gets static promotion. <br>\nAlthough it gives zero guarantees of returning the same pointer each time</p>",
        "id": 272980519,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645636785
    },
    {
        "content": "<p>Going back to the initial issue that triggered this topic, I don't think the current iterator implementation for empty vector is safe. The usage of <code>add</code> and underlying <code>getelementptr inbounds</code> in the code bellow when <code>ptr</code> is a dangling pointer violates the safety condition that the base pointer has an in bounds address of an <strong>allocated object</strong>.</p>\n<div class=\"codehilite\"><pre><span></span><code>            let end = if mem::size_of::&lt;T&gt;() == 0 {\n                (ptr as *const u8).wrapping_add(slice.len()) as *const T\n            } else {\n                ptr.add(slice.len())\n            };\n</code></pre></div>\n<p>ref: <a href=\"https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/library/core/src/slice/iter.rs#L93\">https://github.com/rust-lang/rust/blob/ecb867ec3cefa97a5807453a68758392730e3ed9/library/core/src/slice/iter.rs#L93</a></p>\n<p>I don't think the ZST exception applies here, since the code is explicitly checking that <code>T</code> is not ZST. There is no exception as far as I can tell if the offset value is 0.</p>\n<p>In practice, LLVM may mark <code>end</code> as carrying poison value, which allows the compiler to optimize its value and replace by any value of its type.</p>",
        "id": 274455315,
        "sender_full_name": "Celina V.",
        "timestamp": 1646686281
    },
    {
        "content": "<p>as in, <code>dangling + 0 = poison</code> ?</p>",
        "id": 274472168,
        "sender_full_name": "cuviper",
        "timestamp": 1646694412
    },
    {
        "content": "<p>I believe the distinction here is that wrapping_add can go out of bounds as long as you don't use it until it's back in bounds</p>",
        "id": 274472842,
        "sender_full_name": "Lokathor",
        "timestamp": 1646694819
    },
    {
        "content": "<p>sure, but I think <span class=\"user-mention\" data-user-id=\"442621\">@Celina V.</span> is saying that even <code>ptr.add(0)</code> is poisoned if <code>ptr</code> is not an allocated object</p>",
        "id": 274476726,
        "sender_full_name": "cuviper",
        "timestamp": 1646697552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/274472168\">said</a>:</p>\n<blockquote>\n<p>as in, <code>dangling + 0 = poison</code> ?</p>\n</blockquote>\n<p>where <code>+</code> = <code>getelementptr inbounds</code>, yes<br>\ngepi (and <code>pointer::add</code>) require the base pointer to be inbounds of an allocated object<br>\nthe index being 0 doesn't matter<br>\n<a href=\"https://llvm.org/docs/LangRef.html#id234\">https://llvm.org/docs/LangRef.html#id234</a></p>",
        "id": 274479314,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646699190
    },
    {
        "content": "<p>(unfortunately) i can't easily demonstrate this with dangling pointers because alive doesn't support inttoptr (and llvm seems to not exploit this currently)<br>\nyou can see it when going oob of a normal allocation <a href=\"https://alive2.llvm.org/ce/z/xynnkM\">https://alive2.llvm.org/ce/z/xynnkM</a></p>",
        "id": 274479379,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646699265
    },
    {
        "content": "<p>i guess it depends on the semantics of <code>inttoptr</code> (which the langref is very light on...), which we use to create the dangling pointer<br>\nbecause stuff like this should work i think</p>\n<div class=\"codehilite\" data-code-language=\"LLVM\"><pre><span></span><code><span class=\"c\">; address of some memory-mapped device</span>\n<span class=\"nv\">%regs</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">inttoptr</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"m\">123456</span><span class=\"w\"> </span><span class=\"k\">to</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">*</span><span class=\"w\"></span>\n<span class=\"nv\">%enable</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">getelementptr</span><span class=\"w\"> </span><span class=\"k\">inbounds</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"nv\">%regs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"m\">42</span><span class=\"w\"></span>\n<span class=\"k\">store</span><span class=\"w\"> </span><span class=\"k\">volatile</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"w\"> </span><span class=\"m\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i8</span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"nv\">%enable</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and that's basically the same</p>",
        "id": 274481100,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646700510
    },
    {
        "content": "<hr>\n<p>okay, i'm no longer convinced either way <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n<p>from the perspective of llvm ir:</p>\n<p>if the pointer is dangling because it points to, e.g. a local variable that's out of scope, then <code>dangling + 0 = poison</code> (<a href=\"https://alive2.llvm.org/ce/z/tUpYpG\">https://alive2.llvm.org/ce/z/tUpYpG</a>)<br>\nif the pointer is dangling because we created it out of thin air with <code>inttoptr</code>, it may or may not be poison, i don't know</p>\n<p>from the perspective of \"<a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.add\">https://doc.rust-lang.org/std/primitive.pointer.html#method.add</a> safety comments\":</p>\n<p>it's probably UB, because it says</p>\n<blockquote>\n<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object.</p>\n</blockquote>\n<p>although \"allocated object\" is not rigorously defined</p>",
        "id": 274482891,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646701868
    },
    {
        "content": "<p>For the purpose of ZSTs, we generally seem to consider there to be an \"allocated object\" at every correctly-aligned non-null address.</p>\n<p>I think basically the problem is that a bunch of these things no longer make much sense without the C rule of \"every object (that's not a sub-object, in C++) has a distinct address\".</p>",
        "id": 274485989,
        "sender_full_name": "scottmcm",
        "timestamp": 1646704602
    },
    {
        "content": "<p>llvm ir doesn't seem to have those semantics: <a href=\"https://alive2.llvm.org/ce/z/ejchHX\">https://alive2.llvm.org/ce/z/ejchHX</a><br>\nat least when the pointer is derived from an existing allocation (can't use <code>inttoptr</code> in alive)</p>",
        "id": 274503000,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646722270
    },
    {
        "content": "<blockquote>\n<p>For the purpose of ZSTs, we generally seem to consider there to be an \"allocated object\" at every correctly-aligned non-null address.</p>\n</blockquote>\n<p>this seems equivalent to \"every nonnull pointer is inbounds\"<br>\nsince by that reasoning there's a <code>()</code> at every nonnull address</p>\n<p>this would mean that <code>.add(0)</code> would be defined for any nonnull pointer</p>\n<p>(i have no comment on whether this is desirable)</p>",
        "id": 274503006,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646722282
    },
    {
        "content": "<blockquote>\n<p>I think basically the problem is that a bunch of these things no longer make much sense without the C rule of \"every object (that's not a sub-object, in C++) has a distinct address\".</p>\n</blockquote>\n<p>yeah</p>\n<p>llvm ir does have zsts though, and still has these rules<br>\nbut i don't know if its semantics around this are actually consistent</p>",
        "id": 274503009,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646722299
    },
    {
        "content": "<p>I suppose one option here is just for us to define that <code>offset</code> on a pointer-to-ZST is always defined as identity, and do that by not emitting anything to LLVM for those cases, so thus we're not impacted by their semantics for it.</p>",
        "id": 274585899,
        "sender_full_name": "scottmcm",
        "timestamp": 1646764821
    },
    {
        "content": "<p>The exception already exists for  ZST: <a href=\"https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts\">https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts</a>.</p>\n<blockquote>\n<p>pointer offsets are no-ops</p>\n</blockquote>\n<p>However, this is a pointer to a sized type:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"c1\">// This should be a no-op.</span>\n<span class=\"w\">                </span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">).</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"c1\">// ------ This is the branch with UB.</span>\n<span class=\"w\">                </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That said, I'm not sure why the ZST branch is doing a wrapping_add since it should be a no-op. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 274588930,
        "sender_full_name": "Celina V.",
        "timestamp": 1646766025
    },
    {
        "content": "<p>the ZST side is adding as <code>*const u8</code>, so that's not a no-op for non-zero length</p>",
        "id": 274589990,
        "sender_full_name": "cuviper",
        "timestamp": 1646766395
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ptr</span>: <span class=\"nc\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">end</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// If T is a ZST, this is actually ptr+len.  This encoding is picked so that</span>\n<span class=\"w\">    </span><span class=\"c1\">// ptr == end is a quick test for the Iterator being empty, that works</span>\n<span class=\"w\">    </span><span class=\"c1\">// for both ZST and non-ZST.</span>\n<span class=\"w\">    </span><span class=\"n\">_marker</span>: <span class=\"nc\">PhantomData</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274590009,
        "sender_full_name": "cuviper",
        "timestamp": 1646766404
    },
    {
        "content": "<p>where <code>ptr+len</code> in that comment is raw numeric addition, ignoring the size of T</p>",
        "id": 274590127,
        "sender_full_name": "cuviper",
        "timestamp": 1646766452
    },
    {
        "content": "<p>Indeed. You are correct! It makes me wonder why, but I don't' want to diverge this thread.</p>\n<p>edit: I guess this is trying to get an iterator that has the correct number of iterations and ignoring the pointer value.</p>",
        "id": 274593133,
        "sender_full_name": "Celina V.",
        "timestamp": 1646767614
    },
    {
        "content": "<p>That's right.  For ZSTs it always returns the begin pointer, and uses the end pointer to track the length.  That's why the end isn't <em>also</em> a <code>NonNull&lt;T&gt;</code>.</p>\n<p>(It might be clearer to have end be a pointer-or-usize union, and just treat <code>end</code> as <code>len</code> directly for ZSTs.  Probably not worth changing, though.)</p>",
        "id": 274600544,
        "sender_full_name": "scottmcm",
        "timestamp": 1646770711
    },
    {
        "content": "<p>ah, see <a href=\"https://github.com/rust-lang/rust/pull/77844\">https://github.com/rust-lang/rust/pull/77844</a> and the linked email thread (particularly here forward: <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2019-March/131048.html\">https://lists.llvm.org/pipermail/llvm-dev/2019-March/131048.html</a>)</p>\n<blockquote>\n<p>The conclusion for me at least was that <code>getelementptr inbounds</code> with offset 0 is _not_ the identity function, but can sometimes return <code>poison</code> even when the input is a regular pointer -- specifically, it returns <code>poison</code> when this pointer points into something that LLVM \"knows has been deallocated\", i.e., a former LLVM-managed allocation. It is however the identity function on pointers obtained by casting integers.</p>\n</blockquote>\n<p>(this is consistent with observed behavior--my ub examples above always use pointers derived from allocations that are definitely out of scope, or pointers moved out of bounds, since i couldn't use <code>inttoptr</code>)</p>\n<p>so, because the vec iter code in question here creates the dangling pointer via <code>inttoptr</code>, it doesn't have ub<br>\nat least with our current knowledge of llvm semantics</p>",
        "id": 274629201,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646786595
    },
    {
        "content": "<p>I understood the opposite from the <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2019-March/131366.html\">last email</a> of the thread you just posted:</p>\n<blockquote>\n<p>That last part is given by the lang-ref (imo):<br>\n  \"If the inbounds keyword is present, the result value of the<br>\n   getelementptr is a poison value if the base pointer is not an in<br>\n   bounds address of an allocated object\"</p>\n<p>I read this as: If you have a GEPi, you get poison if the base pointer<br>\nis not an allocated object. That is a dangling pointer (b) causes the<br>\nGEPi to be poison and a pointer from **integer (a) may, if the address<br>\ndenoted by the integer is not inside, or one past, an allocated object.**<br>\nNow any offset except 0 will add more possible ways to generate a poison<br>\nvalue.</p>\n</blockquote>",
        "id": 274630446,
        "sender_full_name": "Celina V.",
        "timestamp": 1646787582
    },
    {
        "content": "<p>I think this comes into the problem of \"allocated object\" being unclear.  I might interpret all this using the \"<em>based</em> on\" rules in <a href=\"https://llvm.org/docs/LangRef.html#pointeraliasing\">https://llvm.org/docs/LangRef.html#pointeraliasing</a></p>\n<p>If it's based on an <code>alloca</code> or a thing marked a an allocator (<code>__rust_alloc</code>), then it can become no longer an allocated object despite being a ZST.  But if it's not <em>based on</em> anything (just an int2ptr from a literal) then the options are \"that's never allowed for anything\" or \"we have to assume it's a legal object on the target\", and the former is impractical for certain real uses, so I think it always does the latter.</p>\n<p>But we could resolve the issue by making one ZST that's max-aligned and always returning that address from <code>dangling</code>, if desired.  Then it'd be based on that one static, and always a valid allocated object.</p>",
        "id": 274631838,
        "sender_full_name": "scottmcm",
        "timestamp": 1646788590
    },
    {
        "content": "<p>I think the author of that email gets confused by that point in the thread. \"The address denoted by the integer is not inside, or one past, an allocated object\" is not something knowable by LLVM, because pointers created from integer constants can refer to memory allocated outside LLVM. So we can just say \"there's a {ZST/memory mapped io/etc.} at that address\" and it can't assume otherwise.</p>\n<p>This is definitely unsatisfying. There doesn't seem to be a clear answer--LLVM IR semantics are <a href=\"https://github.com/rust-lang/rust/pull/77844#discussion_r524992199\">quicksand</a>, the best we can do is try not to <del>sink completely</del> cause miscompiles in practice</p>",
        "id": 274646874,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646805683
    },
    {
        "content": "<blockquote>\n<p>But we could resolve the issue by making one ZST that's max-aligned and always returning that address from dangling, if desired. Then it'd be based on that one static, and always a valid allocated object.</p>\n</blockquote>\n<p>We could do that, and Alive agrees that using a global ZST with gepi offset 0 is well defined: <a href=\"https://alive2.llvm.org/ce/z/LKPkVG\">https://alive2.llvm.org/ce/z/LKPkVG</a>.<br>\nOr something like the empty slice implementation from upthread</p>",
        "id": 274646878,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1646805691
    },
    {
        "content": "<p>This might be a dumb question, but Is the <code>inbounds</code> version of <code>gep</code> required for this case?</p>",
        "id": 275310687,
        "sender_full_name": "Celina V.",
        "timestamp": 1647299665
    },
    {
        "content": "<p><em>Technically</em> it's never required: it would be legal for an LLVM pass to drop <code>inbounds</code> from all gep instructions.</p>\n<p>But not having it inhibits optimizations, e.g. in this quickly-thrown-together example, removing <code>inbounds</code> (from everywhere) prevents vectorization, probably because LLVM can no longer tell that pointers computed from <code>x</code> and <code>y</code> can't alias: <a href=\"https://godbolt.org/z/o6WsG96oq\">https://godbolt.org/z/o6WsG96oq</a>.</p>\n<p>And since the slice iter code in question is often used in hot loops, removing <code>inbounds</code> in this case would probably cause perf regressions for the same reason.</p>",
        "id": 275331900,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1647322884
    },
    {
        "content": "<p>I'm only talking about the specific dangling pointer case, which only happens when capacity is 0.</p>",
        "id": 275434625,
        "sender_full_name": "Celina V.",
        "timestamp": 1647378069
    },
    {
        "content": "<p>I don't quite understand what you're getting at. <code>inttoptr</code> does inhibit alias analysis, but that doesn't seem 100% relevant here--my last godbolt example doesn't include <code>intttoptr</code>, and <code>x</code> is an argument that could be dangling or not at runtime, yet optimizations are still affected by the presence/absense of <code>inbounds</code>.</p>\n<p>If you mean changing the code to not execute the gep for 0:</p>\n<div class=\"codehilite\"><pre><span></span><code>if slice.len() &gt; 0 {\n    ptr.add(slice.len())\n} else {\n    ptr\n}\n</code></pre></div>\n<p>...that is also likely to cause perf regressions, since it introduces a branch in hot code.</p>",
        "id": 275441754,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1647381627
    },
    {
        "content": "<p>I understand that it would inflict some performance issue, but there's a question of how much that would be and whether it is worth it. If using <code>gepi</code> here can lead to incorrect behavior, it might be worth considering a different implementation, even if it causes some performance deterioration.</p>",
        "id": 276108232,
        "sender_full_name": "Celina V.",
        "timestamp": 1647894128
    },
    {
        "content": "<p>BTW, I bumped into this paper today that is quite interesting: <a href=\"https://dl.acm.org/doi/10.1145/3276495\">https://dl.acm.org/doi/10.1145/3276495</a></p>",
        "id": 276108313,
        "sender_full_name": "Celina V.",
        "timestamp": 1647894177
    },
    {
        "content": "<p>relevant to this thread:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276138165\">said</a>:</p>\n<blockquote>\n<p>llvm underspecifies it, i got the llvm maintainers to agree it's a reasonable interpretation that there are allocations of size 0 everywhere</p>\n</blockquote>",
        "id": 276140399,
        "sender_full_name": "cuviper",
        "timestamp": 1647920373
    },
    {
        "content": "<p>Just to make sure I understand, we are saying that dangling pointer arithmetic operations are well defined because the dangling pointer was created by casting an integer. If that's the case, any chance we can update the safety rules for pointer arithmetic operations such as <code>add</code>? Maybe something like:</p>\n<blockquote>\n<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object, or the starting pointer was created by casting any non-zero integer.</p>\n</blockquote>",
        "id": 277040012,
        "sender_full_name": "Celina V.",
        "timestamp": 1648575125
    },
    {
        "content": "<p>I think what I quoted only makes the no-op <code>add(0)</code> ok</p>",
        "id": 277050410,
        "sender_full_name": "cuviper",
        "timestamp": 1648580323
    },
    {
        "content": "<p>So what about something like:</p>\n<blockquote>\n<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object. This does not apply if the requested offset is 0, in which case the operation is a no-op.</p>\n</blockquote>",
        "id": 277178119,
        "sender_full_name": "Celina V.",
        "timestamp": 1648660637
    },
    {
        "content": "<p>i don't think there are non-zero sized allocations everywhere though</p>",
        "id": 277190065,
        "sender_full_name": "Lokathor",
        "timestamp": 1648666141
    },
    {
        "content": "<p>in fact i know there aren't</p>",
        "id": 277190105,
        "sender_full_name": "Lokathor",
        "timestamp": 1648666161
    },
    {
        "content": "<p>Yeah, I think that the <code>dangling().add(0)</code> is ok, but <code>dangling().wrapping_offset(10).add(0)</code> <strong>isn't</strong>, because the <code>wrapping_offset</code> moved off of the zero-sized allocation, and thus the <code>.add(0)</code> is invalid despite the <code>0</code>.</p>",
        "id": 277190943,
        "sender_full_name": "scottmcm",
        "timestamp": 1648666539
    },
    {
        "content": "<p>Any suggestion on how to capture the conditions necessary for this to be safe and not an UB?</p>",
        "id": 277215970,
        "sender_full_name": "Celina V.",
        "timestamp": 1648683338
    },
    {
        "content": "<p>I think as long as LLVM doesn't fully specify it, Rust can't either. What Rust can offer is a subset of what LLVM can perform.</p>",
        "id": 277223311,
        "sender_full_name": "Lokathor",
        "timestamp": 1648690672
    },
    {
        "content": "<p>I totally agree with that. But to me that is basically the definition of UB. If we cannot guarantee LLVM behavior, the safe thing to do is for Rust to assume this is UB.</p>",
        "id": 277345113,
        "sender_full_name": "Celina V.",
        "timestamp": 1648763717
    },
    {
        "content": "<p>The middle ground is that we accept the soft promise of LLVM's behavior for our implementation in std, but we don't make any external promises about this ourselves in docs/reference/etc.</p>",
        "id": 277347460,
        "sender_full_name": "cuviper",
        "timestamp": 1648765060
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/272980519\">said</a>:</p>\n<blockquote>\n<p>Although it gives zero guarantees of returning the same pointer each time</p>\n</blockquote>\n<p>It's a zero argument <code>const</code> function, it's guaranteed to always return the same value.</p>",
        "id": 277354788,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1648770564
    },
    {
        "content": "<p>Heh, want to bet?</p>",
        "id": 277354993,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648770750
    },
    {
        "content": "<p>So I've skimmed this thread and I wanted to share a few thoughts:</p>\n<p>My take is that it is perfectly reasonable for the stdlib to depend on specific behavior of LLVM (i.e., \"this is theoretically UB but not in reality\"). The premise is: if LLVM were to change their behavior, we could adapt the stdlib to do something different, and everybody's code would be fixed. This works because nobody gets to choose not to upgrade libstd when they upgrade Rust (and hence get the new LLVM). </p>\n<p>In contrast, I think that people putting code in <a href=\"http://crates.io\">crates.io</a> wouldn't want to rely on these assumptions.</p>\n<p>Effectively, relying on LLVM's behavior here is the equivalent of relying on any other <em>unstable feature of rustc</em> -- it works in a certain way right now, but it might change in the future, and that's ok because libstd can change to match.</p>\n<p>What I am <strong>not</strong> super happy about that is that this reliance is very implicit. I wonder if it woudl make sense to add an internal intrinsic or other function that clearly documents the guarantee in question and call that instead. Internally, it would just be the same as pointer-add, but then <span class=\"user-mention\" data-user-id=\"442621\">@Celina V.</span>'s tool could detect that we are using it and ignore that code as \"not UB\" (the compiler documented it was ok!), while still detecting code in the <a href=\"http://crates.io\">crates.io</a> ecosystem that makes a similar assumption.</p>\n<p>Moreover, we would have that assumption more clearly documented for ourselves.</p>\n<p>Thoughts?</p>",
        "id": 277465566,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1648840118
    },
    {
        "content": "<p>Those seem like good steps; how does this interact with compatibility across LLVM versions? Is there a potential hazard here where we accidentally make some rustc versions and some LLVM versions incompatible in a way that we don't want to?</p>",
        "id": 277467550,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648841289
    },
    {
        "content": "<p>that is certainly a <em>potential</em> hazard, yes.</p>",
        "id": 277474415,
        "sender_full_name": "Lokathor",
        "timestamp": 1648845271
    },
    {
        "content": "<p>\"The premise is: if LLVM were to change their behavior, we could adapt the stdlib to do something different, and everybody's code would be fixed. This works because nobody gets to choose not to upgrade libstd when they upgrade Rust (and hence get the new LLVM).\" - I would not like to rely on this property too much. Although it is a long way off and a big change, I think that if we could make std more like a regular crate, it would have a lot of advantages around versioning, etc.</p>",
        "id": 277700918,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649062489
    },
    {
        "content": "<p>I would like to make std more like a regular crate, but I'm not sure I like the idea of allowing you to select std's version. I'm thinking <code>[dependencies] std = { default-features = false, features = [\"core\", \"alloc\"] }</code>, with presumably it being an error to use a version field there. Maybe it would be fine, but I need to think about the consequences</p>",
        "id": 277729631,
        "sender_full_name": "bstrie",
        "timestamp": 1649078495
    },
    {
        "content": "<p>How do you use this w/o cargo?</p>",
        "id": 277729915,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649078624
    },
    {
        "content": "<p>however Cargo passes the -Zbuild-std information to rustc today</p>",
        "id": 277730002,
        "sender_full_name": "bstrie",
        "timestamp": 1649078654
    },
    {
        "content": "<p>Which is build the stdlib crate using cargo.</p>",
        "id": 277730084,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649078701
    },
    {
        "content": "<p>where \"using Cargo\" ultimately just means using rustc</p>",
        "id": 277730135,
        "sender_full_name": "bstrie",
        "timestamp": 1649078723
    },
    {
        "content": "<p>The important part is that it builds a matching std shipped with rustc.</p>",
        "id": 277730265,
        "sender_full_name": "The 8472",
        "timestamp": 1649078775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277730135\">said</a>:</p>\n<blockquote>\n<p>where \"using Cargo\" ultimately just means using rustc</p>\n</blockquote>\n<p>Well... resolving dependencies, determining rustc args, then invoking rustc a dozen or so times.</p>",
        "id": 277732920,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649080028
    },
    {
        "content": "<p>sure, just like building dependencies generally, so I'm not sure what the objection is</p>",
        "id": 277733011,
        "sender_full_name": "bstrie",
        "timestamp": 1649080078
    },
    {
        "content": "<p>(Oh, and since vendoring doesn't work with stdlib deps IIRC, good luck if you need to build w/o an internet connection)</p>",
        "id": 277733067,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649080087
    },
    {
        "content": "<p>That is a limitation of the way the standard library source is distributed. IMO it should be distributed with vendored dependencies just like the full rust source tarball.</p>",
        "id": 277744253,
        "sender_full_name": "bjorn3",
        "timestamp": 1649084621
    },
    {
        "content": "<p>without getting too much into the weeds here, I would prefer to avoid design choices which limit our options with ways in which std can be built, if possible. Whether we should change the way std is built is a question which might change over time</p>",
        "id": 277744524,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649084739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277347460\">said</a>:</p>\n<blockquote>\n<p>The middle ground is that we accept the soft promise of LLVM's behavior for our implementation in std, but we don't make any external promises about this ourselves in docs/reference/etc.</p>\n</blockquote>\n<p>I think that makes sense. What do you think about adding an internal function that would be used by <code>std</code>, like suggested by <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>? That way we can document the exact behavior of each function and explicitly call out the assumption we are making inside <code>std</code>.</p>",
        "id": 278065069,
        "sender_full_name": "Celina V.",
        "timestamp": 1649269039
    },
    {
        "content": "<p>I think the strict provenance stuff might be leading somewhere close to that.  Like we could potentially say \"if you used <code>ptr::invalid</code>, then it's UB even to <code>.offset(0)</code>\", and have a different thing (maybe <code>conjure_zst_ref</code> like I posited in <a href=\"https://github.com/rust-lang/rust/pull/95385#issuecomment-1086472902\">https://github.com/rust-lang/rust/pull/95385#issuecomment-1086472902</a> ) for getting a fresh \"zero size allocation\", on which <code>.offset(0)</code> <em>would</em> be completely legal -- even if they both happen to just do an <code>as</code> cast today.</p>",
        "id": 278073153,
        "sender_full_name": "scottmcm",
        "timestamp": 1649272915
    },
    {
        "content": "<p>Oh I had entirely missed this thread, and yet it seems very relevant to the stuff I think about. ;)</p>",
        "id": 278543763,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679104
    },
    {
        "content": "<p>FWIW I think the following is a nice symmetry principle that Miri implements and that I use as guide when figuring out inbounds ptr arithmetic rules: <code>ptr.add(n)</code> is allowed if and only if doing an <code>n*size</code>-byte load starting at <code>ptr</code> would be considered allowed as far as bounds checks goes (i.e., ignoring aliasing restrictions).</p>",
        "id": 278543877,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679173
    },
    {
        "content": "<p>also see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/299\">https://github.com/rust-lang/unsafe-code-guidelines/issues/299</a> and <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/93\">https://github.com/rust-lang/unsafe-code-guidelines/issues/93</a> for the specific case of <code>.add(0)</code></p>",
        "id": 278544015,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277190943\">said</a>:</p>\n<blockquote>\n<p>Yeah, I think that the <code>dangling().add(0)</code> is ok, but <code>dangling().wrapping_offset(10).add(0)</code> <strong>isn't</strong>, because the <code>wrapping_offset</code> moved off of the zero-sized allocation, and thus the <code>.add(0)</code> is invalid despite the <code>0</code>.</p>\n</blockquote>\n<p>hm, my symmetry principle doesn't really answer this one. what Miri currently implements is: if <code>dangling</code> here is <code>ptr::invalid(n)</code> with n ≠ 0, then both of these are allowed. <code>invalid</code> does not have provenance, so <code>invalid(10)</code> and <code>invalid(5).wrapping_offset(5)</code> produce fully identical results.</p>",
        "id": 278544188,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679340
    },
    {
        "content": "<p>I don't see any good reason to make <code>invalid(5).wrapping_offset(5).add(0)</code> be UB, other than \"LLVM makes it UB\" -- and whether it does that, I do not know.</p>",
        "id": 278544387,
        "sender_full_name": "RalfJ",
        "timestamp": 1649679459
    },
    {
        "content": "<p>Maybe we should just ask LLVM (again) about their stance on this, and get them to commit <em>something</em> to the LangRef? I've been meaning to bring up this question in their forum for a while now...</p>",
        "id": 278582163,
        "sender_full_name": "RalfJ",
        "timestamp": 1649695516
    },
    {
        "content": "<p>Definitely getting <em>something</em> in the LangRef would be nice.  I don't know if <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276138165\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/strict.20provenance.20std.20compat.20notes/near/276138165</a> got in, for example.</p>",
        "id": 278589812,
        "sender_full_name": "scottmcm",
        "timestamp": 1649698763
    },
    {
        "content": "<p>it didnt :/</p>",
        "id": 278590137,
        "sender_full_name": "RalfJ",
        "timestamp": 1649698829
    },
    {
        "content": "<p>and I dont know of any public record of that discussion either</p>",
        "id": 278590169,
        "sender_full_name": "RalfJ",
        "timestamp": 1649698836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/278544387\">said</a>:</p>\n<blockquote>\n<p>and whether it does that, I do not know.</p>\n</blockquote>\n<p>I don't either, but it seems to me like the \"there are zero-size allocations\" everywhere model means that it'd be UB because it moved outside the allocation, then did an <code>inbounds</code>.</p>",
        "id": 278591183,
        "sender_full_name": "scottmcm",
        "timestamp": 1649699234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277744524\">said</a>:</p>\n<blockquote>\n<p>without getting too much into the weeds here, I would prefer to avoid design choices which limit our options with ways in which std can be built, if possible. Whether we should change the way std is built is a question which might change over time</p>\n</blockquote>\n<p>I don't believe that this decision moves us any further-or-closer to that goal in particular. I'm generally on board with std being less reliant on nightly features; but in this case, it's a relatively minor deal to remove later, albeit at some performance penalty.</p>",
        "id": 278592937,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1649699956
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/278591183\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/278544387\">said</a>:</p>\n<blockquote>\n<p>and whether it does that, I do not know.</p>\n</blockquote>\n<p>I don't either, but it seems to me like the \"there are zero-size allocations\" everywhere model means that it'd be UB because it moved outside the allocation, then did an <code>inbounds</code>.</p>\n</blockquote>\n<p>yeah... but I dont want to generate a unique provenance for each of these zero-sized allocations in Miri :/</p>",
        "id": 278594020,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700416
    },
    {
        "content": "<p>and I dont think LLVM actually <em>gains</em> anything by making that UB. so it feels rather silly.</p>",
        "id": 278594056,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Behavior.20of.20dangling.20pointer.20arithmetic.20operations/near/277700918\">said</a>:</p>\n<blockquote>\n<p>\"The premise is: if LLVM were to change their behavior, we could adapt the stdlib to do something different, and everybody's code would be fixed. This works because nobody gets to choose not to upgrade libstd when they upgrade Rust (and hence get the new LLVM).\" - I would not like to rely on this property too much. Although it is a long way off and a big change, I think that if we could make std more like a regular crate, it would have a lot of advantages around versioning, etc.</p>\n</blockquote>\n<p>FWIW, there are quite a few things in std that rely on being able to break rustc's abstraction boundary (i.e., rely on unspecified implementation details). <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/90\">https://github.com/rust-lang/unsafe-code-guidelines/issues/90</a> is a very incomplete list of such situations.</p>",
        "id": 278594350,
        "sender_full_name": "RalfJ",
        "timestamp": 1649700542
    },
    {
        "content": "<p>Hmm, <code>if d != 0 { x.add(d) } else { x }</code> optimizes to a <strong>non</strong>-<code>inbounds</code> GEP (<a href=\"https://rust.godbolt.org/z/vrdK8bMGs\">https://rust.godbolt.org/z/vrdK8bMGs</a>), which suggests that at least right now they don't believe <code>.add(0)</code> is always ok.</p>\n<p>EDIT: oh, that's just because the pointer is nullable, per alive2</p>",
        "id": 278596709,
        "sender_full_name": "scottmcm",
        "timestamp": 1649701635
    },
    {
        "content": "<p>Hmm, no matter how hard I try I can't convince alive that <code>.add(0)</code> is a nop: <a href=\"https://alive2.llvm.org/ce/z/WuQ7Kr\">https://alive2.llvm.org/ce/z/WuQ7Kr</a></p>",
        "id": 278598757,
        "sender_full_name": "scottmcm",
        "timestamp": 1649702341
    }
]