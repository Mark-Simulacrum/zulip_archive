[
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/88714\">https://github.com/rust-lang/rust/pull/88714</a>, which changes <code>std::time::Instant</code> to use CLOCK_BOOTTIME instead of CLOCK_MONOTONIC on Linux, was approved to be merged recently. This means that Instant now will include time spent while the machine is asleep, whereas it did not before.</p>\n<p>The discussion for this was scattered between here and a few different issues. If I understand correctly, it seems like the argument that this makes Windows and Linux more consistent, and that embedded and mobile developers found this semantic more useful so it was better to change Linux than to change Windows. (It sounds like maybe it also makes Linux more consistent with other OSes, but I didn't quite follow the details, and I don't have any experience with time outside of Linux and Windows.)</p>\n<p>However, std::thread::sleep still uses CLOCK_MONOTONIC on Linux and the equivalent on Windows. So sleep time still won't be accounting for across suspend on Linux or Windows platforms. This is an odd inconsistency, since I think one generally wants to measure elapsed time using the same clock that they are using to express timeouts and delays.</p>\n<p>Other languages and environments (Go, Android SDK, libc) seem to be settling on exposing multiple clock sources for both elapsed time and timers, which allows the developer to choose the correct timer based on the behavior they want.</p>\n<p>Is there a kind of time vision document or anything describing what the libs team is aiming for here? I'm a little worried that this change to Instant might make further improvements to Rust's time handling more difficult.</p>",
        "id": 260697302,
        "sender_full_name": "John Starks",
        "timestamp": 1636395419
    },
    {
        "content": "<p>Can you give an example of how this might make it difficult to improve things in the future? I don't have an opinion on this issue, but it seems that exposing both behaviors would just involve adding one new alternative API for the option that <code>Instant</code> doesn't support, yes?</p>",
        "id": 260703849,
        "sender_full_name": "bstrie",
        "timestamp": 1636398450
    },
    {
        "content": "<p>Do you personally have a vision for the future of time handling in std? Because I'm sure people would be interested to hear one :)</p>",
        "id": 260704118,
        "sender_full_name": "bstrie",
        "timestamp": 1636398584
    },
    {
        "content": "<p>One possible use of elapsed active time (i.e. excluding hibernation) is for periodic task schedulers so that they get spread out over time. If sleep time causes all timeouts to be met at once then schedules can get crushed into a single time slot instead of spreading out.</p>\n<p>And general performance measurements. When you want to count work processed / units of time that the program was actually running.</p>",
        "id": 260705559,
        "sender_full_name": "The 8472",
        "timestamp": 1636399296
    },
    {
        "content": "<p>And yeah, those selectable clock-source APIs exist for a reason. A pity that rust didn't learn from that design.</p>",
        "id": 260705654,
        "sender_full_name": "The 8472",
        "timestamp": 1636399329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Clock.20evolution.3F/near/260705559\">said</a>:</p>\n<blockquote>\n<p>One possible use of elapsed active time (i.e. excluding hibernation) is for periodic task schedulers so that they get spread out over time. If sleep time causes all timeouts to be met at once then schedules can get crushed into a single time slot instead of spreading out.</p>\n</blockquote>\n<p>That's a good reason why <code>sleep</code> should continue using <code>CLOCK_MONOTONIC</code>.</p>\n<blockquote>\n<p>And general performance measurements. When you want to count work processed / units of time that the program was actually running.</p>\n</blockquote>\n<p>That's always going to be fraught with scheduling questions though -- for program-running time you'd be better off with something like <code>getrusage</code></p>",
        "id": 260707188,
        "sender_full_name": "cuviper",
        "timestamp": 1636400078
    },
    {
        "content": "<p>Not when you're measuring download speed</p>",
        "id": 260708576,
        "sender_full_name": "The 8472",
        "timestamp": 1636400761
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Clock.20evolution.3F/near/260705654\">said</a>:</p>\n<blockquote>\n<p>And yeah, those selectable clock-source APIs exist for a reason. A pity that rust didn't learn from that design.</p>\n</blockquote>\n<p>I don't think the current design precludes any better design, if anybody would like to propose one. :P afaik the time module is just the sole remnant of the pre-1.0 desire to have datetime in std, until people realized it was too big of a task for 1.0</p>",
        "id": 260718033,
        "sender_full_name": "bstrie",
        "timestamp": 1636405165
    },
    {
        "content": "<p>At least <code>Duration</code> was stabilized after 1.0. We have a deprecated <code>std::thread::sleep_ms</code> function as <code>Duration</code> wasn't stabilized at 1.0 yet.</p>",
        "id": 260718513,
        "sender_full_name": "bjorn3",
        "timestamp": 1636405362
    },
    {
        "content": "<p>sure, Duration is as new as 1.3, but that doesn't mean that the time module wouldn't welcome a broader vision. :) I'm sure people would love to have datetime APIs in std itself, if only datetime APIs were a solved problem</p>",
        "id": 260719364,
        "sender_full_name": "bstrie",
        "timestamp": 1636405770
    },
    {
        "content": "<p>Methods like <code>sleep_until</code> that take not a duration but the time at which sleep should terminate are fairly common in async ecosystems such as tokio.</p>",
        "id": 261231870,
        "sender_full_name": "nagisa",
        "timestamp": 1636711156
    },
    {
        "content": "<p>this would be a natural way to support either kind of sleep, I think.</p>",
        "id": 261231902,
        "sender_full_name": "nagisa",
        "timestamp": 1636711180
    },
    {
        "content": "<p>(this makes me wonder if e.g. tokio's implementation actually handles suspends correctly now ^^)</p>",
        "id": 261232089,
        "sender_full_name": "nagisa",
        "timestamp": 1636711241
    }
]