[
    {
        "content": "<p>With GATs closing in on stabilization, I'm wondering if people have thoughts to what APIs might end up in std that use GATs. I'm thinking, for example, <code>LendingIterator</code>. Curious what peoples' thoughts are on starting to land those APIs as unstable?</p>",
        "id": 268091434,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642205879
    },
    {
        "content": "<p>Somewhat off-topic, but I think the name <code>LendingIterator</code> might need more discussion since usually the terms \"borrow\" or \"ref[erence]\" are used rather than \"loan\".</p>",
        "id": 268093843,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642208173
    },
    {
        "content": "<p>It could be that it's the clearest name among the possibilities, though.</p>",
        "id": 268093867,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642208196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268091434\">said</a>:</p>\n<blockquote>\n<p>With GATs closing in on stabilization, I'm wondering if people have thoughts to what APIs might end up in std that use GATs. I'm thinking, for example, <code>LendingIterator</code>. Curious what peoples' thoughts are on starting to land those APIs as unstable?</p>\n</blockquote>\n<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> imo</p>",
        "id": 268099556,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1642214362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Noah Lev</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268093843\">said</a>:</p>\n<blockquote>\n<p>Somewhat off-topic, but I think the name <code>LendingIterator</code> might need more discussion since usually the terms \"borrow\" or \"ref[erence]\" are used rather than \"loan\".</p>\n</blockquote>\n<p>and discussions about specific GAT apis like this can go in the PRs/tracking issues for those unstable APIs</p>",
        "id": 268099617,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1642214405
    },
    {
        "content": "<p>no need to hash that out rn</p>",
        "id": 268099630,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1642214423
    },
    {
        "content": "<p>do you think we'll be able to have <code>impl&lt;I: Iterator&gt; LendingIterator for I</code>?</p>",
        "id": 268100182,
        "sender_full_name": "cuviper",
        "timestamp": 1642215174
    },
    {
        "content": "<p>Is <code>LendingIterator</code> the same idea as <a href=\"https://docs.rs/streaming-iterator\">https://docs.rs/streaming-iterator</a> ?</p>",
        "id": 268106262,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1642224400
    },
    {
        "content": "<p>They are the same thing, but it seems that StreamingIterator is an even worse name than LendingIterator.</p>",
        "id": 268106318,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1642224494
    },
    {
        "content": "<p>well I'm assuming it wouldn't be constrained to <code>&amp;Item</code> like <code>StreamingIterator</code> does</p>",
        "id": 268106752,
        "sender_full_name": "cuviper",
        "timestamp": 1642225218
    },
    {
        "content": "<p>GAT should allow stuff like <code>Ref&lt;'a, T&gt;</code></p>",
        "id": 268106758,
        "sender_full_name": "cuviper",
        "timestamp": 1642225239
    },
    {
        "content": "<p>It seems that it's possible to impl&lt;I: Iterator&gt; LendingIterator for I, but the same method name <code>next</code> looks a little strange.<br>\n<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6f9642a08cd346a3be2002035445ba13\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6f9642a08cd346a3be2002035445ba13</a></p>",
        "id": 268120238,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1642244906
    },
    {
        "content": "<p>Also, we may need another trait IntoLendingIterator</p>",
        "id": 268120257,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1642244960
    },
    {
        "content": "<p>I imagine that once we have <code>AsyncIterator</code>, people may want a <code>LendingAsyncIterator</code> trait.<br>\nAlso GAT versions of the function traits could be useful for closures that return references to captured variables.</p>",
        "id": 268122425,
        "sender_full_name": "Dominik Stolz",
        "timestamp": 1642248191
    },
    {
        "content": "<p>I don't thing GAT is the thing preventing such closures to exist, <span class=\"user-mention\" data-user-id=\"302700\">@Dominik Stolz</span> :</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyFnOnce</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">my_call_once</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Args</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Ret</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyFnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Ret</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">my_call_once</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">F</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">()</span>: <span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">      </span>-&gt; <span class=\"nc\">R</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">any</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;'</span><span class=\"na\">any</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nc\">MyFnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Ret</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">any</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">f</span><span class=\"p\">).</span><span class=\"n\">my_call_once</span><span class=\"p\">(());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=e5d7ae25e0cbee35b33da9bc3739504f\">Playground</a></li>\n</ul>\n<p>works in current Rust, and the <code>MyFnOnce</code> alias is not even needed on nightly Rust with <code>fn_traits</code> around (we only need the explicit <code>.call_once(â€¦)</code> syntax: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=bad54ccfd76b47b60e2a5c49c28e079d\">Playground</a>).</p>\n<p>The issue lies rather in <em>literal closure expressions</em>, such as <code>{ let x = 42; move || &amp;x }</code> being unable to be imbued with such a signature. We'd need a way to assert such signatures for closures.</p>",
        "id": 268127006,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642254972
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268100182\">said</a>:</p>\n<blockquote>\n<p>do you think we'll be able to have <code>impl&lt;I: Iterator&gt; LendingIterator for I</code>?</p>\n</blockquote>",
        "id": 268135828,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642266554
    },
    {
        "content": "<p>I feel like that would give problems with coherence</p>",
        "id": 268135839,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642266568
    },
    {
        "content": "<p>Then, nobody can impl LendingIterator because somebody else could impl Iterator</p>",
        "id": 268135858,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642266596
    },
    {
        "content": "<p>This is something I'd like to think about though</p>",
        "id": 268135938,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642266679
    },
    {
        "content": "<p>Another alternative is to somehow just add a lifetime to Iterator::Item, and somehow make it use a default lifetime. But unsure how that would work</p>",
        "id": 268136008,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642266743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268136008\">said</a>:</p>\n<blockquote>\n<p>Another alternative is to somehow just add a lifetime to Iterator::Item, and somehow make it use a default lifetime. But unsure how that would work</p>\n</blockquote>\n<p>Maybe it would default to <code>'static</code> if the lifetime wasn't used anyway?</p>",
        "id": 268139013,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642270428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268135858\">said</a>:</p>\n<blockquote>\n<p>Then, nobody can impl LendingIterator because somebody else could impl Iterator</p>\n</blockquote>\n<p>I don't think that's a coherence issue? You can't implement <code>Iterator</code> or <code>LendingIterator</code> on types from another crate, and the crate itself can choose whether to implement <code>Iterator</code> or <code>LendingIterator</code> on its own types.</p>",
        "id": 268139664,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642271332
    },
    {
        "content": "<p>It would only prevent you from implementing <em>both</em> yourself, but I admit sometimes that could be useful for wrapper types. e.g. <code>Either</code> was blocked from implementing <code>IntoIterator</code> because we already had <code>Iterator</code>, and the blanket impl would make that overlap.</p>",
        "id": 268142145,
        "sender_full_name": "cuviper",
        "timestamp": 1642274621
    },
    {
        "content": "<p>In the case of <code>Either</code>, why would you want to manually implement <code>IntoIterator</code>? (I'm curious)</p>",
        "id": 268142487,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642275092
    },
    {
        "content": "<p>If you have <code>Either&lt;Vec&lt;T&gt;, Option&lt;T&gt;&gt;</code>, you might want that to transform to <code>Either&lt;vec::IntoIter&lt;T&gt;, option::IntoIter&lt;T&gt;&gt;</code>, and then that is a useful <code>Iterator</code>. But we couldn't do that directly because of the overlap, so we settled for an inherent <code>into_iter()</code>.</p>",
        "id": 268142743,
        "sender_full_name": "cuviper",
        "timestamp": 1642275418
    },
    {
        "content": "<p>In retrospect, <code>either</code>'s <code>Iterator</code> should have been a separate type.</p>",
        "id": 268142758,
        "sender_full_name": "cuviper",
        "timestamp": 1642275451
    },
    {
        "content": "<p>Another thing is that you would need a different type to wrap <code>LendingIterator</code> separately from <code>Iterator</code>.</p>",
        "id": 268143733,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642276590
    },
    {
        "content": "<p>You wouldn't be able extend any of the iterator adaptors to also be used for <code>LendingIterator</code>, for example.</p>",
        "id": 268144068,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642276924
    },
    {
        "content": "<p>Hmm, true. It's not obvious to me that we <em>should</em> reuse those adaptors, but I guess we could.</p>",
        "id": 268144342,
        "sender_full_name": "cuviper",
        "timestamp": 1642277262
    },
    {
        "content": "<p>The trade-off is that all source <code>Iterator</code>s that don't need GAT will have to manually implement <code>LendingIterator</code>.</p>",
        "id": 268144429,
        "sender_full_name": "cuviper",
        "timestamp": 1642277346
    },
    {
        "content": "<p>If we make that automatic, we might even switch <code>for</code> loops to lending.</p>",
        "id": 268144452,
        "sender_full_name": "cuviper",
        "timestamp": 1642277379
    },
    {
        "content": "<p>Any chance we could make <code>trait Iterator = LendingIterator&lt;...something here...&gt;;</code> work?</p>",
        "id": 268145149,
        "sender_full_name": "scottmcm",
        "timestamp": 1642278107
    },
    {
        "content": "<p>Not sure, but note that a lot of <code>Iterator</code> methods are not compatible, like <code>collect</code>. Perhaps those could be <code>where Self: ...something...</code></p>",
        "id": 268145352,
        "sender_full_name": "cuviper",
        "timestamp": 1642278347
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268142758\">said</a>:</p>\n<blockquote>\n<p>In retrospect, <code>either</code>'s <code>Iterator</code> should have been a separate type.</p>\n</blockquote>\n<p>I'm getting the general impression that in retrospect almost all types want to return a <em>different</em> type for their <code>Iterator</code> rather than using themselves.</p>",
        "id": 268147647,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642281477
    },
    {
        "content": "<p>(see also <code>Range*</code> types)</p>",
        "id": 268147688,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642281486
    },
    {
        "content": "<p>Is that the reason <code>Range*</code> aren't <code>Copy</code>?</p>",
        "id": 268149264,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642283926
    },
    {
        "content": "<p>(I seem to recall it had something to do with <code>for</code> loops)</p>",
        "id": 268149272,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642283947
    },
    {
        "content": "<p>Yes; iterators are generally not <code>Copy</code> because iterating a copy of something is often not what people expect.</p>\n<p>IIRC sfackler had started on a plan splitting Range for 2021, but it didn't end up landing.  I can't find the conversation about it, but here's a previous related comment I'd made: <a href=\"#narrow/stream/219381-t-libs/topic/ridiculousfish.20Range.20feedback/near/211055146\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/ridiculousfish.20Range.20feedback/near/211055146</a></p>\n<p>And a comment from mouse: <a href=\"https://github.com/rust-lang/rust/pull/82489#issuecomment-785874949\">https://github.com/rust-lang/rust/pull/82489#issuecomment-785874949</a></p>",
        "id": 268149937,
        "sender_full_name": "scottmcm",
        "timestamp": 1642284813
    },
    {
        "content": "<p>Anyways, for things like <code>LendingIterator</code>, I don't personally have the bandwidth to make these PRs myself (and ensure there's good documentation). But I would be very willing to work with someone else that's interested to get things added.</p>",
        "id": 268164794,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642308565
    },
    {
        "content": "<p><code>LendingIterator</code> was the obvious one - but I'm not sure if there are others that are interesting to add</p>",
        "id": 268164800,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642308586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268127006\">said</a>:</p>\n<blockquote>\n<p>The issue lies rather in <em>literal closure expressions</em>, such as <code>{ let x = 42; move || &amp;x }</code> being unable to be imbued with such a signature. We'd need a way to assert such signatures for closures.</p>\n</blockquote>\n<p>Couldn't the same argument be made for iterators?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;</span><span class=\"n\">I</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">iter</span>: <span class=\"nc\">I</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">any</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">any</span><span class=\"w\"> </span><span class=\"n\">I</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">any</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">iter</span><span class=\"p\">).</span><span class=\"n\">next</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>also works in current Rust, which does not mean it is possible to implement <code>Iterator</code> such that the bound is satisfied.<br>\nWhich traits should the closure expression you gave as an example implement?<br>\nThis could be a new <code>BikeshedFn</code> trait with an <code>Output</code> GAT. (we might then also want <code>BikeshedFnMut</code> and <code>BikeshedFnOnce</code>)</p>",
        "id": 268175618,
        "sender_full_name": "Dominik Stolz",
        "timestamp": 1642326480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/268136008\">said</a>:</p>\n<blockquote>\n<p>Another alternative is to somehow just add a lifetime to Iterator::Item, and somehow make it use a default lifetime. But unsure how that would work</p>\n</blockquote>\n<p>I would love if that worked in a backward-compatible fashion. However, a previous <a href=\"https://internals.rust-lang.org/t/closures-that-can-return-references-to-captured-variables/14756\">discussion on IRLO</a> concluded that a problem might arise with <code>I: Iterator</code> bounds that do not specify the associated type. To remain compatible, these would have to allow only non-lending iterators, which then poses the question how to write a bound that allows all iterators, lending or not.</p>",
        "id": 268176002,
        "sender_full_name": "Dominik Stolz",
        "timestamp": 1642327111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"302700\">@Dominik Stolz</span> you can \"GAT-ize\" an API where the method does not introduce \"anonymous\" lifetime parameters itself. This, in turn, requires that any methods be taking a <code>self: Self</code> receiver â€”hence why \"GAT closures\" will involve <code>FnOnce()</code> bounds, rather than <code>FnMut</code> or <code>Fn</code>â€”; <code>Iterator</code>'s <code>.next()</code>, however, is <code>&amp;'_ mut Self</code>-based, with that <code>'_</code> being unnameable in the return type.</p>\n<ul>\n<li>An interesting thing to notice is that in a world where Rust would fully figure out higher-order signatures, <code>F : FnMut(Argsâ€¦) -&gt; R</code> is \"an alias\" for <code>for&lt;'_&gt; &amp;'_ mut F : FnOnce(Argsâ€¦) -&gt; R</code>.<br>\n    This seems relevant here given the <code>FnMut() -&gt; Option&lt;T&gt;</code> &lt;-&gt; <code>Iterator</code> equivalence (thanks to <code>move || iterator.next()</code> in one direction, and <code>iter::from_fn(fn_mut)</code> in the other).<br>\n    So if <code>Iterator</code> is <code>FnMut() -&gt; Option&lt;T&gt;</code>, <em>i.e.</em>, <code>for&lt;'_&gt; &amp;'_ mut Self : FnOnce() -&gt; Option&lt;T&gt;</code>, then <code>LendingIterator</code> or other GAT constructs are <code>for&lt;'next&gt; &amp;'next mut Self : FnOnce() -&gt; Option&lt;T&lt;'next&gt;&gt;</code>, whereby the return type can depend on <code>'next</code>, the lifetime representing \"the span of the current <code>.next()</code> call\". <code>StreamingIterator</code> is a reduced example, wherein <code>T&lt;'next&gt; = &amp;'next U</code></li>\n</ul>",
        "id": 268182666,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642337523
    },
    {
        "content": "<p>This reminds me of a subtle detail that would need to be resolved beforehand: in order to write <code>.filter()</code>-like adaptors without having to resort to <code>unsafe</code>, one currently (without Polonius) needs to have that <code>.advance()</code> / <code>.get()</code> split, which I think doesn't generalize as well to GATed <code>Item</code>s:</p>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=2784c37ea61cf2738759f4328dc1211a\">minimal repro of <code>StreamingIterator</code>'s problem</a></li>\n</ul>",
        "id": 268182714,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642337598
    },
    {
        "content": "<p>It would be <em>amazing</em> if traits like <code>Deref</code>, <code>Borrow</code>, and <code>Index</code> could be GAT-ified in a backwards compataible way.</p>",
        "id": 268197264,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642354595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator/near/269137918\">said</a>:</p>\n<blockquote>\n<p>Okay, for those following along: the next step here is probably to come up with some \"user stories\" for how we might expect people to use LendingIterator or a GATified Iterator (<a href=\"https://github.com/rust-lang/generic-associated-types-initiative/issues/1\">https://github.com/rust-lang/generic-associated-types-initiative/issues/1</a>). We need to update the repo to have a place for them, but if you have some thoughts, please feel free to file an issue there, and I'll make sure it gets included. (Also welcome examples of other traits too, like Deref)</p>\n</blockquote>",
        "id": 269138159,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643044542
    },
    {
        "content": "<blockquote>\n<p>It would be <em>amazing</em> if traits like <code>Deref</code>, <code>Borrow</code>, and <code>Index</code> could be GAT-ified in a backwards compataible way.</p>\n</blockquote>\n<p>Could you expand a bit on what such GATified traits would enable?</p>",
        "id": 269213046,
        "sender_full_name": "Sean Chen (he/him)",
        "timestamp": 1643090323
    },
    {
        "content": "<p>The best example that comes to mind is the annoyance of <code>Pin&lt;&amp;mut _&gt;</code> not featuring _implicit reborrowing_, requiring people to call <code>.as_mut()</code> all the time. Instead, it would be nice if an <code>&amp;'reborrow mut Pin&lt;&amp;'_ mut _&gt;</code> could just magically become a <code>Pin&lt;&amp;'reborrow mut _&gt;</code>, and <code>DerefMut</code> looks like the ideal candidate for this.</p>\n<ul>\n<li>If reborrowing sounds a bit alien, you can also consider <code>&amp;mut Pin&lt;Box&lt;â€¦&gt;&gt;</code> being able to become <code>Pin&lt;&amp;mut _&gt;</code> automagically as well.</li>\n</ul>\n<p>But it turns out that the current definitions of <code>Deref{,Mut}</code> are too restrictive in that regard:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">deref_mut</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">Target</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With <code>Self = Pin&lt;Box&lt;T&gt;&gt;</code>, we end up with:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">deref_mut</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">???</span><span class=\"w\"></span>\n</code></pre></div>\n<p>when we wanted:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">deref_mut</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If, instead, there was a <code>DerefMut</code> definition as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">BetterDerefMut</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">TargetMut</span><span class=\"o\">&lt;'</span><span class=\"nb\">__</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">deref_mut</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">TargetMut</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then we'd be able to say <code>type TargetMut&lt;'__&gt; = Pin&lt;&amp;'__ mut T&gt;;</code> <em>and voilÃ </em>.</p>\n<p>But then the challenge is making it retro-compatible (on top of a consistent <code>DerefMut : Deref</code>-like hierarchy). With a bunch of associated type defaults, and/or <strong>trait aliases</strong>, I believe it could be possible.</p>\n<p>FWIW, the same applies to <code>Index</code> and <code>IndexMut</code> trait. Consider the <em>Realistic example</em> section of <code>::ref_cast</code>:</p>\n<ul>\n<li><a href=\"https://docs.rs/ref-cast/1.0.6/ref_cast/index.html#realistic-example\">https://docs.rs/ref-cast/1.0.6/ref_cast/index.html#realistic-example</a></li>\n</ul>\n<p>They end up having to use an <code>unsafe</code> transmutation just to accomodate to the restrictive <code>Index</code> traits.</p>\n<p>And that's just not possible for all the borrowing types: the <code>Out&lt;'_, T&gt;</code> pointer type from the <code>::uninit</code> crate, would love to be able to feature mut-indexing with the handy <code>[â€¦]</code> sugar, but it just can't, and has to use a method instead:</p>\n<ul>\n<li><a href=\"https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.get_out\">https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.get_out</a></li>\n</ul>",
        "id": 269249708,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643114056
    },
    {
        "content": "<p>Even recently, there has been this thread: <a href=\"#narrow/stream/122651-general/topic/GPU.20Slices\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/GPU.20Slices</a> which does talk of how the fact it's \"reference to slice\" type, by virtue of having to feature an FFI-compatible and well-defined behavior, can't be a <code>&amp; _</code> type, and how when they tried to use a custom borrowing type, they lost the <code>[â€¦]</code> indexing sugar</p>",
        "id": 269249986,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643114186
    },
    {
        "content": "<p>Same goes for <code>CStr</code>, which could have been featured as a slim pointer type (and thus, FFI-compatible, which is the whole <em>raison-d'Ãªtre</em> of such a type to begin with!) had it been defined as a reference type rather than a referee type, like it is done in <a href=\"https://docs.rs/safer-ffi/0.0.6/safer_ffi/prelude/char_p/index.html\">other crates</a>. But then we wouldn't have <code>CString : Deref&lt;Target = CStr&gt;</code>, <em>etc.</em></p>\n<p>Consider also the <a href=\"https://doc.rust-lang.org/1.58.1/std/os/unix/io/trait.AsFd.html\"><code>AsFd</code> more correct abstraction for file descriptors on Unix</a>: we have, again, a reference type (<code>BorrowedFd&lt;'_&gt;</code>), and thus, something like <a href=\"https://doc.rust-lang.org/1.58.1/std/os/unix/io/struct.OwnedFd.html\"><code>OwnedFd</code></a> can't <code>Deref&lt;Target&lt;'__&gt; = BorrowedFd&lt;'__&gt;&gt;</code>.</p>\n<p>The reality is that currently, only the Rust references types / referess get the love, and that any custom reference type is doomed to be awfully unergonomic. I do believe GATs could help that situation by a significant margin</p>",
        "id": 269250568,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643114480
    },
    {
        "content": "<p>are these changes backwards-compatible?</p>",
        "id": 269254093,
        "sender_full_name": "bstrie",
        "timestamp": 1643116230
    },
    {
        "content": "<p>I think the more realistic approach to these things would be to have new gat traits (which the sugared ops would change to unsugar to), and then have blanket impls from the current ones to the new ones:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">IndexGat</span><span class=\"o\">&lt;</span><span class=\"n\">Idx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"o\">&lt;'</span><span class=\"na\">index</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">index</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">index</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Idx</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Idx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">IndexGat</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"nc\">Index</span><span class=\"o\">&lt;</span><span class=\"n\">Idx</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"o\">&lt;'</span><span class=\"na\">index</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">index</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;'</span><span class=\"na\">index</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Index</span><span class=\"o\">&lt;</span><span class=\"n\">Idx</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">index</span><span class=\"w\"> </span><span class=\"c1\">// â€¦</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>A thorny point is what the hierarchy with the <code>â€¦Mut</code> traits should be: the new gat traits would have their own GAT for the <code>mut</code> case, and I imagine some relationship would be expected between the non-mut GAT and the mut GAT? (such as some higher-order <code>AsRef</code> <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span>)</p>",
        "id": 269299344,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643134521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/269299344\">said</a>:</p>\n<blockquote>\n<p>I think the more realistic approach to these things would be to have new gat traits (which the sugared ops would change to unsugar to), and then have blanket impls from the current ones to the new ones.</p>\n</blockquote>\n<p>I want to push back on this a little. At least in my opinion, this is pretty unergonomic. I would <em>really</em> like to hear how people would like to use these traits (<code>Index</code>, <code>Deref</code>, <code>Iterator</code>, etc.) with GATs (and of course without). I don't want this to beholden to \"realistic\" - because then that really limits what our \"shiny future\" is. Let's start with what people want to do - and then we can worry about how we'll get there. GATs are stable yet - there might be design decisions we can make that allow us to get the best of both worlds.</p>",
        "id": 269310075,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643138816
    },
    {
        "content": "<p>I implore people to open issues (on the GATs initiative repo - or on the rust repo if you really must) on specific \"I wish you could just do this\" examples</p>",
        "id": 269310229,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643138878
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/generic-associated-types-initiative\">GATs initiative repo</a> for others like myself.</p>",
        "id": 269310456,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643138954
    },
    {
        "content": "<p>Is \"making <code>foo[bar]</code> return something that isn't <code>&amp;_</code>\" something that's in the realm of GAT things? That's something that comes up fairly regularly, IMO.</p>",
        "id": 269310714,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643139049
    },
    {
        "content": "<p>for example, <code>ndarray</code> would want to return <code>ArrayView&lt;'_, ..&gt;</code></p>",
        "id": 269311001,
        "sender_full_name": "cuviper",
        "timestamp": 1643139165
    },
    {
        "content": "<p>but for mutable, it would want <code>ArrayViewMut&lt;'_, ..&gt;</code>, so GAT indexing would need distinct <code>type Output&lt;'_&gt;</code></p>",
        "id": 269311235,
        "sender_full_name": "cuviper",
        "timestamp": 1643139255
    },
    {
        "content": "<p>currently without GAT, they use <code>slice</code> and <code>slice_mut</code> methods</p>",
        "id": 269311516,
        "sender_full_name": "cuviper",
        "timestamp": 1643139371
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300743\">Sean Chen (he/him)</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/269213046\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>It would be <em>amazing</em> if traits like <code>Deref</code>, <code>Borrow</code>, and <code>Index</code> could be GAT-ified in a backwards compataible way.</p>\n</blockquote>\n<p>Could you expand a bit on what such GATified traits would enable?</p>\n</blockquote>\n<p>Returning something other than <code>&amp;T</code>.</p>",
        "id": 269315775,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643141050
    },
    {
        "content": "<p>ie: <code>T&lt;'_&gt;</code></p>",
        "id": 269315809,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643141073
    },
    {
        "content": "<p>For a second, my mind was thinking this was a weird method call lol. I'm not sure; this isn't necessarily a GAT problem in and of itself. I imagine you would need some way to change the Index trait to make Output have a lifetime param and simultaneously change the output of <code>index</code> to return <code>Output</code> rather than <code>&amp;Output</code>.</p>",
        "id": 269316298,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643141324
    },
    {
        "content": "<p>It's a good use case though. Can someone file an issue on the initiative repo?</p>",
        "id": 269316751,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643141518
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/generic-associated-types-initiative/issues/2\">Extending core::ops::Index to return non-references</a></p>",
        "id": 269319622,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643142704
    },
    {
        "content": "<p>Thank you so much <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span></p>",
        "id": 269323340,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643144446
    },
    {
        "content": "<p>Another one is using borrowed versions of an enum for hashmap lookups.</p>",
        "id": 269324197,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144767
    },
    {
        "content": "<p>Example?</p>",
        "id": 269324230,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643144780
    },
    {
        "content": "<p>like if you have</p>",
        "id": 269324272,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144799
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Xy</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"p\">(</span><span class=\"nb\">String</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Y</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269324302,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144812
    },
    {
        "content": "<p>and you want to lookup where the key is <code>Xy(\"foo\")</code></p>",
        "id": 269324325,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144821
    },
    {
        "content": "<p>you don't want to allocate a string for a lookup</p>",
        "id": 269324345,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144828
    },
    {
        "content": "<p>Ooh that would be cool</p>",
        "id": 269324398,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643144851
    },
    {
        "content": "<p>ideally you could have <code>enum BorrowedXy&lt;'a&gt; { X(&amp;'a str), Y(i32) }</code></p>",
        "id": 269324402,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144854
    },
    {
        "content": "<p>and <code>impl Borrow for Xy { type Borrowed&lt;'a&gt; = BorrowedXy&lt;'a&gt; ... }</code></p>",
        "id": 269324422,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144866
    },
    {
        "content": "<p>there's a way to do this with <code>dyn</code>, but it's very hacky</p>",
        "id": 269324497,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643144887
    },
    {
        "content": "<p><code>dyn</code> version: <a href=\"https://stackoverflow.com/q/36480845/155423\">How to avoid temporary allocations when using a complex key for a HashMap?</a> (not top answer)</p>",
        "id": 269324553,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643144930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs/near/269311235\">said</a>:</p>\n<blockquote>\n<p>but for mutable, it would want <code>ArrayViewMut&lt;'_, ..&gt;</code>, so GAT indexing would need distinct <code>type Output&lt;'_&gt;</code></p>\n</blockquote>\n<p>I don't know if I follow this. Isn't the currently differentiated based on <code>Index</code> vs <code>IndexMut</code>?</p>",
        "id": 269335122,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643149871
    },
    {
        "content": "<p>They're currently forced together, essentially:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">IndexMut</span><span class=\"o\">&lt;</span><span class=\"n\">Idx</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span>: <span class=\"nc\">Index</span><span class=\"o\">&lt;</span><span class=\"n\">Idx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">index_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">index</span>: <span class=\"nc\">Idx</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Index</span><span class=\"o\">&gt;</span>::<span class=\"n\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269335548,
        "sender_full_name": "cuviper",
        "timestamp": 1643150088
    },
    {
        "content": "<p>written as <code>Self::Output</code> in the implementation and docs, but that's the effect</p>",
        "id": 269335629,
        "sender_full_name": "cuviper",
        "timestamp": 1643150129
    },
    {
        "content": "<p>Ah that's...rough. Almost like we need an <code>OutputMut</code> that defaults to <code>Self::Output</code></p>",
        "id": 269357464,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643167026
    },
    {
        "content": "<p>I think it's worse than that, for something like <code>vec[idx].method()</code>, the choice of <code>Index</code> vs. <code>IndexMut</code> depends on the receiver type of the method: <a href=\"https://github.com/rust-lang/generic-associated-types-initiative/issues/2#issuecomment-1021611276\">https://github.com/rust-lang/generic-associated-types-initiative/issues/2#issuecomment-1021611276</a></p>",
        "id": 269429695,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1643211111
    },
    {
        "content": "<p>I think we'd need to do something like take mutability as a type parameter, e.g.</p>\n<div class=\"codehilite\"><pre><span></span><code>trait Index&lt;Idx&gt; {\n    type Output&lt;&#39;a, ?mut&gt;;\n\n    fn index&lt;&#39;a&gt;(&amp;&#39;a self, index: Idx) -&gt; Self::Output&lt;&#39;a, const&gt;;\n}\n\ntrait IndexMut&lt;Idx&gt;: Index&lt;Idx&gt; {\n    fn index_mut&lt;&#39;a&gt;(&amp;&#39;a self, index: Idx) -&gt; Self::Output&lt;&#39;a, mut&gt;;\n}\n\nimpl&lt;T&gt; Index&lt;usize&gt; for Vec&lt;T&gt; {\n    type Output&lt;&#39;a, ?mut&gt; = &amp;&#39;a ?mut T;\n    ...\n}\n</code></pre></div>",
        "id": 269430220,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1643211314
    },
    {
        "content": "<p>(or if we can be generic over mutability, maybe <code>Index</code> should just have  a mutabilty parameter instead of a separate <code>IndexMut</code>)</p>",
        "id": 269430755,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1643211511
    },
    {
        "content": "<blockquote>\n<p>I think we'd need to do something like take mutability as a type parameter</p>\n</blockquote>\n<p>With programming languages, in the end we want to be able to parametrize over everything ;)</p>",
        "id": 269485034,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643232438
    },
    {
        "content": "<p>Fwiw, since gat traits will probably involve new traits, there could be an <code>OutputMut</code> assoc trait for <code>IndexMut</code>; the issue is indeed about method resolution leading to up to an exponential number of candidates as indexing is chained; with the classic <code>&amp;Output</code> / <code>&amp;mut Output</code>, the two mutability choices could be deferred up until the end, and \"squashed\" down to either always index or always indexmut.</p>",
        "id": 269498367,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643239404
    },
    {
        "content": "<p>But that gives me an idea: what if chained sugared indexing always required there to be a consistent choice?</p>",
        "id": 269498430,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643239441
    },
    {
        "content": "<p>That would take care of the exponentiality, and then we'd only have a good old ambiguity issue in some situations, which is not different than what we have with the current traits (I suspect it favors index in that case?)</p>",
        "id": 269498572,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643239504
    }
]