[
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from\">https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from</a> has pretty steep safety requirements. Is it possible to build a safe API like it that works on slices and is fallible? (returns <code>None</code> if the parameter is not a sub-slice)</p>",
        "id": 246055839,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1626329818
    },
    {
        "content": "<p>In particular: how to check whether pointers are from the same allocated object, without the check itself invoking provenance daemons?</p>",
        "id": 246055947,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1626329942
    },
    {
        "content": "<p>You can't. It is a compiler concept, not something physically represented after compilation.</p>",
        "id": 246056753,
        "sender_full_name": "bjorn3",
        "timestamp": 1626330919
    },
    {
        "content": "<p>I ended up doing <code>usize</code> arithmetic without using <code>ptr::offset_from</code>. Does this look correct?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">address_range</span><span class=\"p\">(</span><span class=\"n\">slice</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">std</span>::<span class=\"n\">ops</span>::<span class=\"n\">RangeInclusive</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">end</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">start</span><span class=\"o\">..=</span><span class=\"n\">end</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">slice_addresses</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">address_range</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">as_bytes</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">on_disk_addresses</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">address_range</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">dirstate_map</span><span class=\"p\">.</span><span class=\"n\">on_disk</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">on_disk_addresses</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">slice_addresses</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">on_disk_addresses</span><span class=\"p\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">slice_addresses</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice_addresses</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">on_disk_addresses</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">offset_from_usize</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246059532,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1626333530
    },
    {
        "content": "<p>It matters what offset_from_usize is offsetting from. If it's working off <code>on_disk_address</code> then this seems right to me</p>",
        "id": 246061716,
        "sender_full_name": "nagisa",
        "timestamp": 1626335222
    },
    {
        "content": "<p>you will end up with a pointer with the <code>on_disk_address</code>'s provenance. And since that object is strict superset of <code>slice</code> you aren't at risk of making an invalid pointer.</p>",
        "id": 246061815,
        "sender_full_name": "nagisa",
        "timestamp": 1626335317
    },
    {
        "content": "<p>(Sorry I didn’t remove the parts less relevant, <code>offset_from_usize</code> does not offset pointers but returns a <code>struct Offset([u8; 4])</code> for 32-bit big-endian without alignment, for writing in a binary file format)</p>",
        "id": 246066164,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1626338095
    },
    {
        "content": "<p>Why does <code>ptr::offset_from</code> have so much safety requirements compared to converting to <code>usize</code> and subtracting?</p>",
        "id": 246066521,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1626338307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219747\">Simon Sapin</span> <a href=\"#narrow/stream/219381-t-libs/topic/Safe.20offset_from.3F/near/246066521\">said</a>:</p>\n<blockquote>\n<p>Why does <code>ptr::offset_from</code> have so much safety requirements compared to converting to <code>usize</code> and subtracting?</p>\n</blockquote>\n<p>I'd expect the semantics are inherited from C. Part of requiring the offset to be divisible by <code>size_of::&lt;T&gt;()</code> is so the compiler can use fancy math to convert the division into a shift and/or multiplication.</p>",
        "id": 246072543,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626342446
    },
    {
        "content": "<p>It preserves provenance of the object being offset from, which gives the compiler information about what the object ought to be.</p>",
        "id": 246076753,
        "sender_full_name": "nagisa",
        "timestamp": 1626345449
    },
    {
        "content": "<p>i.e. the operation of offsetting from a pointer to an object that compiler otherwise might not know anything about gives it useful information about what the object may be (e.g. its size)</p>",
        "id": 246076850,
        "sender_full_name": "nagisa",
        "timestamp": 1626345496
    },
    {
        "content": "<p>You can use <code>wrapping_offset</code> for a less strong variant.</p>",
        "id": 246076953,
        "sender_full_name": "nagisa",
        "timestamp": 1626345586
    },
    {
        "content": "<p>casting to an integer is the most flexible and most optimization defeating option.</p>",
        "id": 246077036,
        "sender_full_name": "nagisa",
        "timestamp": 1626345636
    },
    {
        "content": "<p>Ah, I guess we don't have a <code>wrapping_offset_from</code> <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 246077107,
        "sender_full_name": "nagisa",
        "timestamp": 1626345719
    },
    {
        "content": "<p>There used to be, but it was deprecated a year and a bit ago: <a href=\"https://github.com/rust-lang/rust/pull/73580\">https://github.com/rust-lang/rust/pull/73580</a></p>",
        "id": 246627999,
        "sender_full_name": "scottmcm",
        "timestamp": 1626804462
    },
    {
        "content": "<p><code>offset_from</code> returns <code>isize</code>, not another pointer. What does preserving provenance even mean there?</p>",
        "id": 248378779,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628096934
    },
    {
        "content": "<p>provenance is not a feature of a type, but of a value, but you are right, that returned <code>isize</code> has no provenance if used on two pointers with the same provenance, you need a pointer with provenance in order to obtain a real pointer again. Using two pointers with different provenance as arguments to <code>offset_from</code> is UB as we don't have the concept of values with two separate provenances, and thus any behaviour with such values is undefined</p>",
        "id": 248379334,
        "sender_full_name": "oli",
        "timestamp": 1628097213
    },
    {
        "content": "<p>Why is it useful to declare UB when <code>offset_from</code> arguments have different provenance, given that the return value does not have any provenance itself?</p>",
        "id": 248380591,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628097787
    },
    {
        "content": "<p>the return value will have <em>two</em> provenances if you pass two args of different provenance, and we haven't defined what the meaning of two provenances is. There's probably more subtlety here, but this is as far as my understanding goes</p>",
        "id": 248385511,
        "sender_full_name": "oli",
        "timestamp": 1628100171
    },
    {
        "content": "<p>if you pass two arguments with the same provenance, the return value is indeed provenance-free</p>",
        "id": 248385550,
        "sender_full_name": "oli",
        "timestamp": 1628100194
    },
    {
        "content": "<p>I don’t understand what having two provenances means, or what an integer having any provenance means</p>",
        "id": 248767905,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628425164
    },
    {
        "content": "<p>it has no meaning, that why it is UB. Think about it this way: each pointer is actually a <code>(symbolic_id42, 99)</code> pair, where the <code>99</code> is some offset from the base address. if the symbolic ids are the same when subtracting two pointers, you get a <code>(None, 42)</code> like result, where the symbols cancel out and the offsets are subtracted as integers. This result has no provenance. Subtracting <code>(id69, 42)</code> from <code>(id21, 12)</code> would give you <code>(id21 - id69, -30)</code>, for which we are \"simply\" lacking rules for the meaning of. When I say \"two provenances\" that is wrong, what I mean is that the provenance is built from two distinct ones, which we haven't defined at all</p>",
        "id": 248775539,
        "sender_full_name": "oli",
        "timestamp": 1628436129
    },
    {
        "content": "<p>types are irrelevant for provenances (mostly). values can have provenance or not.</p>",
        "id": 248775569,
        "sender_full_name": "oli",
        "timestamp": 1628436223
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219747\">Simon Sapin</span> <a href=\"#narrow/stream/219381-t-libs/topic/Safe.20offset_from.3F/near/246055839\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from\">https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset_from</a> has pretty steep safety requirements. Is it possible to build a safe API like it that works on slices and is fallible? (returns <code>None</code> if the parameter is not a sub-slice)</p>\n</blockquote>\n<p>i opened an rfc for such a feature a while ago: <a href=\"https://github.com/rust-lang/rfcs/pull/2796\">https://github.com/rust-lang/rfcs/pull/2796</a>, but it got stuck</p>",
        "id": 248775858,
        "sender_full_name": "Mara",
        "timestamp": 1628436656
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span>, it looks like if the RFC sticks to the proposed slice methods without the raw pointer alternative, then it only needs fixes to the proposed implementation? Would it help if I write up another proposed implementation based on the feedback?</p>",
        "id": 248785734,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628451881
    },
    {
        "content": "<p>sure, that'd help :)   i should also read the comments again to figure out the state of it. it's been ages since i submitted that rfc ^^'</p>",
        "id": 248785841,
        "sender_full_name": "Mara",
        "timestamp": 1628452049
    },
    {
        "content": "<p>An RFC comment gives this example <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7b663101329adc698e7b527c4af771b3\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=7b663101329adc698e7b527c4af771b3</a> where safe code can create slices where “The distance between the pointers, in bytes, must be an exact multiple of the size of T” does not hold. Given that, I have a hard time coming up for <em>any</em> use case where <code>offset_from</code> is valid and helpful to use. If I already need to manipulate addresses  as integers to do a modulo operation to check for that multiple constraint, I might as well do the division to implement the rest of what <code>offset_from</code> does.</p>",
        "id": 248845232,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628515450
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">bytemuck</span>::<span class=\"n\">cast_slice</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[[</span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">],[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">]];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[[</span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cast_slice</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">cast_slice</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)[</span><span class=\"mi\">1</span><span class=\"o\">..</span><span class=\"mi\">3</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// x: [[1,2],[3,4]]</span>\n<span class=\"w\">    </span><span class=\"c1\">// y: [[2,3]]</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248845268,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628515469
    },
    {
        "content": "<p>New proposed implementation for offset_of and range_of: <a href=\"https://github.com/rust-lang/rfcs/pull/2796#issuecomment-895296202\">https://github.com/rust-lang/rfcs/pull/2796#issuecomment-895296202</a></p>",
        "id": 248858738,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628521162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219747\">@Simon Sapin</span> what happens if the subslice has a length of zero? i think it's sound to create a slice with <code>std::slice::from_raw_parts</code> to any place even outside any allocations as long as the length is zero and the pointer is aligned and non-null.  so you could make a zero-length slice from another allocation with an out-of-bounds offset that falls into another allocation. breaking provenance rules again?</p>",
        "id": 248868181,
        "sender_full_name": "Mara",
        "timestamp": 1628524880
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// Safety: All fine because the length is 0.</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">().</span><span class=\"n\">offset</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"a start = {:p}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"a   end = {:p}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">..</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"b start = {:p}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"b   end = {:p}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">..</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"slice   = {:p}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>a start = 0x7ffd3d103aa0\na   end = 0x7ffd3d103aa8\nb start = 0x7ffd3d103aa8\nb   end = 0x7ffd3d103ab0\nslice   = 0x7ffd3d103aac\n</code></pre></div>",
        "id": 248868671,
        "sender_full_name": "Mara",
        "timestamp": 1628525068
    },
    {
        "content": "<p><code>slice</code> here is made from <code>a</code>, but happens to point inside <code>b</code>. <code>b.range_of(slice)</code> would run into UB now, right?</p>",
        "id": 248868820,
        "sender_full_name": "Mara",
        "timestamp": 1628525122
    },
    {
        "content": "<p>As far as I understand in that example <code>range_of</code> would run into UB if it used <code>&lt;*const T&gt;::offset_from</code></p>",
        "id": 248868980,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628525182
    },
    {
        "content": "<p>But my proposed implementation doesn’t</p>",
        "id": 248868985,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628525188
    },
    {
        "content": "<blockquote>\n<p>so you could make a zero-length slice from another allocation with an out-of-bounds offset</p>\n</blockquote>\n<p>I'm not sure that is legally doable in any way</p>",
        "id": 248869501,
        "sender_full_name": "oli",
        "timestamp": 1628525397
    },
    {
        "content": "<p>hm. well you're not using unsafe anyway, so must be fine ^^'. i wonder what it all looks like to llvm. subtracting usizes vs pointers.</p>",
        "id": 248869624,
        "sender_full_name": "Mara",
        "timestamp": 1628525433
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> why not? the docs say that a dangling pointer is fine with length zero</p>",
        "id": 248869664,
        "sender_full_name": "Mara",
        "timestamp": 1628525451
    },
    {
        "content": "<p>oh right, <code>offset</code> is unsafe and requires \"same-object\"</p>",
        "id": 248869668,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628525452
    },
    {
        "content": "<p><code>wrapping_offset</code> is safe but says using the returned pointer may be unsound</p>",
        "id": 248869821,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628525515
    },
    {
        "content": "<p>idk if that includes zero-length \"uses\"</p>",
        "id": 248869881,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628525525
    },
    {
        "content": "<p>one-past-the-end pointers are valid too. so change the <code>3</code> for a <code>2</code> in my example to fix that, and the problem is still there</p>",
        "id": 248869942,
        "sender_full_name": "Mara",
        "timestamp": 1628525560
    },
    {
        "content": "<p>then you can even do it safely. <code>let slice = a[2..];</code></p>",
        "id": 248870041,
        "sender_full_name": "Mara",
        "timestamp": 1628525602
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">range_of</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"o\">..</span><span class=\"p\">]));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>gives either</p>\n<div class=\"codehilite\"><pre><span></span><code>[src/main.rs:118] b.range_of(&amp;a[2..]) = Some(\n    0..0,\n)\n</code></pre></div>\n<p>or</p>\n<div class=\"codehilite\"><pre><span></span><code>[src/main.rs:118] b.range_of(&amp;a[2..]) = None\n</code></pre></div>\n<p>depending on the phase of the moon</p>",
        "id": 248870298,
        "sender_full_name": "Mara",
        "timestamp": 1628525702
    },
    {
        "content": "<p>what i'm wondering is if llvm may assume that this is always None (because different allocations), even though it might be Some().</p>",
        "id": 248870553,
        "sender_full_name": "Mara",
        "timestamp": 1628525809
    },
    {
        "content": "<p>(that'd be a bigger problem than just this rfc though. since it's all safe code ^^)</p>",
        "id": 248870923,
        "sender_full_name": "Mara",
        "timestamp": 1628525979
    },
    {
        "content": "<blockquote>\n<p>depending on the phase of the moon</p>\n</blockquote>\n<p>Is that with <code>offset_from</code>?</p>",
        "id": 248872686,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628526781
    },
    {
        "content": "<p>nope. with your implementation.</p>",
        "id": 248872800,
        "sender_full_name": "Mara",
        "timestamp": 1628526841
    },
    {
        "content": "<p>'phase of the moon' here means whether a and b are stored right next to eachother with b right after a, or not. (e.g. debug vs release build)</p>",
        "id": 248872922,
        "sender_full_name": "Mara",
        "timestamp": 1628526876
    },
    {
        "content": "<p>Ah I see. What <em>should</em> the behavior be in that case? If <code>&amp;a[2..]</code> and <code>&amp;b[..0]</code> have the same address and length they’re indistinguishable at runtime</p>",
        "id": 248884532,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628532102
    },
    {
        "content": "<p>yes. i don't know</p>",
        "id": 249121213,
        "sender_full_name": "Mara",
        "timestamp": 1628694468
    },
    {
        "content": "<p>I think it's a concept of the abstract machine. Like, the optimizer can assume they're different even if they are \"physically\" the same.</p>",
        "id": 249122277,
        "sender_full_name": "cuviper",
        "timestamp": 1628694957
    },
    {
        "content": "<p>if the optimizer can assume that in this case with Simon's implementation, we can cause UB without any unsafe code. that'd be bad.</p>",
        "id": 249131302,
        "sender_full_name": "Mara",
        "timestamp": 1628698780
    },
    {
        "content": "<p>I think we can have an unspecified outcome (among two possibilities, and may be affected by optimizer decisions) that is not necessarily UB</p>",
        "id": 249208651,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628756476
    },
    {
        "content": "<p>UB would be: the optimizer is allowed to <em>assume</em> a particular outcome and eliminate a call based on things it \"knows\" about the inputs. Then if assumptions are violated \"impossible\" things can happen, and therefore anything can happen</p>",
        "id": 249208785,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1628756599
    }
]