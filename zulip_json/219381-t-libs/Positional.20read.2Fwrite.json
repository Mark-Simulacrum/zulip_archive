[
    {
        "content": "<p>Has there been any discussion about or is anyone interested in supporting positional read/writes? Context is that for async a number of people have told me that a positional read is better than seek + read (and respectively for writes). The motivation is stronger for async and the underlying OS APIs often support it directly. I'm wondering if this is something that has come up before? And/or if people have thoughts about this sort of thing should be added to the Read/Write traits or be on separate traits (I assume the latter because not all readers would support positional read). And if separate traits, should PosRead: Read  + Seek, or just one or neither? Plus any other thoughts about the necessary-ness of this, or what the API should look like.</p>",
        "id": 276452970,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1648116113
    },
    {
        "content": "<p>I think PosRead shouldn't require either Read or Seek. That allows implementing it for a type without internal seek position like <code>&amp;[u8]</code>.</p>",
        "id": 276458097,
        "sender_full_name": "bjorn3",
        "timestamp": 1648119110
    },
    {
        "content": "<p>there's a platform-specific trait for preadv/pwritev. <a href=\"https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html\">https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html</a></p>",
        "id": 276528155,
        "sender_full_name": "The 8472",
        "timestamp": 1648150163
    },
    {
        "content": "<p>Wow. I've been using <code>libc::pread</code> <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 276528915,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648150615
    },
    {
        "content": "<p>Any idea why it’s Unix only rather than cross platform? Just because the Unix api exists? (That may sound like a silly question, but it could be derived at least elsewhere, if it doesn’t exist)</p>",
        "id": 276532500,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1648152362
    },
    {
        "content": "<p>No idea, maybe check the issue that introduced it if there were cross-platform concerns.</p>",
        "id": 276533847,
        "sender_full_name": "The 8472",
        "timestamp": 1648153077
    },
    {
        "content": "<p>I don't think it can be derived on other platforms so easily because it wouldn't be an atomic operation - other threads could observe the file pointer being moved. Maybe if it took <code>&amp;mut self</code> it could be added though. I also heard that the closest Windows equivalent (a single syscall that seeks and reads at the same time) is async only.</p>",
        "id": 276534814,
        "sender_full_name": "Kestrer",
        "timestamp": 1648153572
    },
    {
        "content": "<p>Taking &amp;mut self is not enough. Libstd implements <code>Read</code>, <code>Write</code> and <code>Seek</code> for <code>&amp;File</code>, <code>&amp;TcpStream</code> and a couple of other types. This allows performing these operations from multiple threads without locks.</p>",
        "id": 276536463,
        "sender_full_name": "bjorn3",
        "timestamp": 1648154382
    },
    {
        "content": "<p>Windows has its own similar <code>FileExt</code>:<br>\n<a href=\"https://doc.rust-lang.org/std/os/windows/fs/trait.FileExt.html\">https://doc.rust-lang.org/std/os/windows/fs/trait.FileExt.html</a></p>",
        "id": 276536676,
        "sender_full_name": "cuviper",
        "timestamp": 1648154488
    },
    {
        "content": "<p>and those <code>seek_read</code>/<code>write</code> <em>do</em> affect the file cursor</p>",
        "id": 276536722,
        "sender_full_name": "cuviper",
        "timestamp": 1648154520
    },
    {
        "content": "<p>and then WASI only has <code>read</code>/<code>write_vectored_at</code><br>\n<a href=\"https://doc.rust-lang.org/std/os/wasi/fs/trait.FileExt.html\">https://doc.rust-lang.org/std/os/wasi/fs/trait.FileExt.html</a></p>",
        "id": 276536968,
        "sender_full_name": "cuviper",
        "timestamp": 1648154639
    },
    {
        "content": "<p>oh, nvm, that has provided versions of <code>read_at</code> and <code>write_at</code> too</p>",
        "id": 276537134,
        "sender_full_name": "cuviper",
        "timestamp": 1648154726
    },
    {
        "content": "<p>Windows' trait is different than the Unix trait; in Windows, the stream remembers the position, as if it were a seek followed by a read/write</p>",
        "id": 276537179,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648154756
    },
    {
        "content": "<p>that's what I meant by affecting the file cursor</p>",
        "id": 276537301,
        "sender_full_name": "cuviper",
        "timestamp": 1648154803
    },
    {
        "content": "<p>I wonder if there's any atomicity in that, at least?</p>",
        "id": 276537457,
        "sender_full_name": "cuviper",
        "timestamp": 1648154889
    },
    {
        "content": "<p>I have a <code>read_at</code> implementation for Windows <a href=\"https://docs.rs/system-interface/latest/src/system_interface/fs/file_io_ext.rs.html#631\">here</a>; effectively, it does <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-reopenfile\"><code>ReOpenFile</code></a> to get an independent handle and does <code>seek_read</code> on that. It isn't perfect; <code>ReOpenFile</code> requires permission to re-open the file, but it's enough for some use cases.</p>",
        "id": 276538071,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648155244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/219381-t-libs/topic/Positional.20read.2Fwrite/near/276536463\">said</a>:</p>\n<blockquote>\n<p>Taking &amp;mut self is not enough. Libstd implements <code>Read</code>, <code>Write</code> and <code>Seek</code> for <code>&amp;File</code>, <code>&amp;TcpStream</code> and a couple of other types. This allows performing these operations from multiple threads without locks.</p>\n</blockquote>\n<p>The function would take <code>&amp;mut File</code> not <code>&amp;mut &amp;File</code>, so you'd have the guarantee that no <code>&amp;File</code>s exist</p>",
        "id": 276541885,
        "sender_full_name": "Kestrer",
        "timestamp": 1648157296
    },
    {
        "content": "<p><code>dup</code>'d file descriptors share offsets iirc</p>",
        "id": 276542015,
        "sender_full_name": "The 8472",
        "timestamp": 1648157379
    },
    {
        "content": "<p>try_clone:</p>\n<blockquote>\n<p>Creates a new File instance that shares the same underlying file handle as the existing File instance. Reads, writes, and seeks will affect both File instances simultaneously.</p>\n</blockquote>",
        "id": 276542192,
        "sender_full_name": "The 8472",
        "timestamp": 1648157473
    },
    {
        "content": "<p>If the trait is implemented for &amp;File, the function would take <code>&amp;mut &amp;File</code>, not <code>&amp;mut File</code>.</p>",
        "id": 276542897,
        "sender_full_name": "bjorn3",
        "timestamp": 1648157945
    },
    {
        "content": "<p><code>ReOpenFile</code> on Windows obtains a new handle that has an independent offset.</p>",
        "id": 276548444,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648161559
    },
    {
        "content": "<p>Huh, I was always under impression that <code>ReadFile</code> won't update any file-specific state if using the <code>OVERLAPPED</code> argument.</p>",
        "id": 276725085,
        "sender_full_name": "nagisa",
        "timestamp": 1648299755
    },
    {
        "content": "<p><a href=\"https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntreadfile\"><code>NtReadFile</code></a> has some more details on what's happening:</p>\n<blockquote>\n<p>If the call to NtCreateFile set either of the CreateOptions flags FILE_SYNCHRONOUS_IO_ALERT or FILE_SYNCHRONOUS_IO_NONALERT, the I/O Manager maintains the current file position...</p>\n<p>Even when the I/O Manager is maintaining the current file position, the caller can reset this position by passing an explicit ByteOffset value to NtReadFile. Doing this automatically changes the current file position to that ByteOffset value, performs the read operation, and then updates the position according to the number of bytes actually read. This technique gives the caller atomic seek-and-read service.</p>\n</blockquote>\n<p>Note that <code>CreateFileW</code> opens files with <code>FILE_SYNCHRONOUS_IO_NONALERT</code> unless <code>FILE_FLAG_OVERLAPPED</code> is used.</p>",
        "id": 276728747,
        "sender_full_name": "Chris Denton",
        "timestamp": 1648304949
    }
]