[
    {
        "content": "<p>a while ago there was a plan to split libc out into multiple crates, one for each supported platform, in pursuit of improving the libc versioning situation by acknowledging the fact that platform APIs aren't stable and we can't avoid breaking changes. <a href=\"https://github.com/rust-lang/libc/issues/547#issuecomment-576158988\">https://github.com/rust-lang/libc/issues/547#issuecomment-576158988</a> . that seems to have stalled, but in the meantime I find myself building a codebase for <code>x86_64-unknown-none</code> that also needs access to libc's <code>x86_64-unknown-linux-gnu</code> items, so if anyone's interested in pursuing the original plan I'm happy to do the labor of splitting out libc into individual platform crates since either way I'll need to do so for linux anyway. is there anyone highly involved in the libc crate these days?</p>",
        "id": 273704901,
        "sender_full_name": "bstrie",
        "timestamp": 1646166325
    },
    {
        "content": "<p>I'm invested in the design aspects and would like to help with that discussion. I'd be happy to join whatever meeting ends up happening to discuss it.</p>",
        "id": 273705113,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646166438
    },
    {
        "content": "<p>I'm not sure to what degree we want to omit all of the myriad platform specific APIs from libc and put them in their own crate. But I can imagine some options there.</p>",
        "id": 273705241,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646166503
    },
    {
        "content": "<p>Would it help if the stability markers mechanism that we use in the standard library were also available for use in crates?</p>",
        "id": 273705254,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646166514
    },
    {
        "content": "<p>right, I'd love some guidance design-wise.</p>\n<p>regarding stability markers, how would you see them being used? right now I'm just thinking about moving existing items into new crates, not introducing any new unstable items.</p>",
        "id": 273705654,
        "sender_full_name": "bstrie",
        "timestamp": 1646166665
    },
    {
        "content": "<p>The people involved in the libc crate are mainly <span class=\"user-mention\" data-user-id=\"217081\">@Yuki Okushi</span> and myself.</p>",
        "id": 273709072,
        "sender_full_name": "Amanieu",
        "timestamp": 1646168334
    },
    {
        "content": "<p>The problem with the libc crate is that it is used by a <em>huge</em> portion of the ecosystem, which makes even slight breaking changes a non-starter.</p>",
        "id": 273709128,
        "sender_full_name": "Amanieu",
        "timestamp": 1646168364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> What kind of changes do you have in mind for libc exactly?</p>",
        "id": 273709269,
        "sender_full_name": "Amanieu",
        "timestamp": 1646168414
    },
    {
        "content": "<p>Is it just about splitting things from the linux headers which don't depend on libc into a separate crate?</p>",
        "id": 273709472,
        "sender_full_name": "Amanieu",
        "timestamp": 1646168452
    },
    {
        "content": "<p>So that you can use them with raw syscalls without libc.</p>",
        "id": 273709492,
        "sender_full_name": "Amanieu",
        "timestamp": 1646168463
    },
    {
        "content": "<p>yes, the goal is to disentangle the essential bits of libc from the platform-specific bits. I don't foresee any breaking changes, the goal would be to re-export these definitions from libc just as they are (although I think gnzlbg might have had grander designs beyond this that might have <em>someday</em> involved breaking changes)</p>",
        "id": 273711066,
        "sender_full_name": "bstrie",
        "timestamp": 1646169119
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 273712430,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646169789
    },
    {
        "content": "<p>So, there'd be a <code>libc-core</code> (not trying to bikeshed a name) that <em>only</em> has portable C entry points?</p>",
        "id": 273712499,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646169818
    },
    {
        "content": "<p>And then (say) <code>libc-linux</code> with all the Linux-y bits?</p>",
        "id": 273712537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646169835
    },
    {
        "content": "<p>And some random target that regularly breaks API compat might be <del>0.1.0</del> <del>0.2.0</del> <del>0.3.0</del> <del>0.4.0</del> 0.5.0, while a stable one wouldn't break API?</p>",
        "id": 273712725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646169898
    },
    {
        "content": "<p>yep, that's the idea.</p>",
        "id": 273713022,
        "sender_full_name": "bstrie",
        "timestamp": 1646170037
    },
    {
        "content": "<p>obviously as long as libc still re-exports any of these unstable platform APIs it will suffer the instability that presents, but if I read between the lines I think that some people were proposing that a 0.3 release of libc might only expose the core APIs (which is to say, whatever APIs are required to <em>not</em> cause a second libcpocalypse), while forcing users to explicitly depend on platform-specific crates that might be on major version 200 or what have you</p>",
        "id": 273713294,
        "sender_full_name": "bstrie",
        "timestamp": 1646170173
    },
    {
        "content": "<p>That seems potentially interesting. Especially if we can manage to auto-generate more of the platform-specific bits.</p>",
        "id": 273713438,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170219
    },
    {
        "content": "<p>Another approach that was proposed is to get rid of all the manual bindings and just have something that is generated by bindgen from the platform headers.</p>",
        "id": 273713556,
        "sender_full_name": "Amanieu",
        "timestamp": 1646170233
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 273713574,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170242
    },
    {
        "content": "<p>I would <em>love</em> to see that happen. We'd have to snapshot the latest platform headers and ship those (since we shouldn't depend on what's on the user's system, they might have something older/newer than we support), but it'd be much more maintainable.</p>",
        "id": 273713645,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170279
    },
    {
        "content": "<p>keeping in mind that the libc crate is so old that it predates things like unions, so a straightforward generation will result in breaking changes on its own</p>",
        "id": 273713820,
        "sender_full_name": "bstrie",
        "timestamp": 1646170343
    },
    {
        "content": "<p>Oh yea I think we're well into libc 0.3 territory here.</p>",
        "id": 273713846,
        "sender_full_name": "Amanieu",
        "timestamp": 1646170360
    },
    {
        "content": "<p>Perhaps this should be prototyped as an external crate first.</p>",
        "id": 273713887,
        "sender_full_name": "Amanieu",
        "timestamp": 1646170383
    },
    {
        "content": "<p>I also think, before we make any kind of breaking change, we should establish an MSRV policy.</p>",
        "id": 273713975,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170435
    },
    {
        "content": "<p>Right now, libc's MSRV policy is \"support ALL the Rusts\". That's painful.</p>",
        "id": 273714034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170445
    },
    {
        "content": "<p>I think it'd be <em>completely</em> reasonable to say \"stable and stable-minus-one, nothing older\".</p>",
        "id": 273714063,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170462
    },
    {
        "content": "<p>Perhaps we could take some inspiration from Zig for the auto-generated bindings: <a href=\"https://github.com/ziglang/zig/tree/master/lib/libc\">https://github.com/ziglang/zig/tree/master/lib/libc</a></p>",
        "id": 273714100,
        "sender_full_name": "Amanieu",
        "timestamp": 1646170492
    },
    {
        "content": "<p>I think all of these concerns would be helped by precisely identifying the core bits of libc, since those would be the foundation of any libc 0.3, and are what any experimental external crate would need to re-export anyway, and could very well be so minimal that an extremely old MSRV might be trivial to achieve</p>",
        "id": 273714346,
        "sender_full_name": "bstrie",
        "timestamp": 1646170595
    },
    {
        "content": "<p>Why couldn't the core bits also be generated from C headers? The only things that are core are the base types which would come from <code>core::ffi</code>.</p>",
        "id": 273714589,
        "sender_full_name": "Amanieu",
        "timestamp": 1646170694
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273714346\">said</a>:</p>\n<blockquote>\n<p>I think all of these concerns would be helped by precisely identifying the core bits of libc, since those would be the foundation of any libc 0.3, and are what any experimental external crate would need to re-export anyway, and could very well be so minimal that an extremely old MSRV might be trivial to achieve</p>\n</blockquote>\n<p>\"extremely old MSRV\" means no unions, no <code>repr(align)</code>, no <code>repr(packed)</code>, no <code>#[non_exhaustive]</code>...</p>",
        "id": 273714662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170722
    },
    {
        "content": "<p>would that involve moving more things into core::ffi? currently it's just c_void, yeah?</p>",
        "id": 273714693,
        "sender_full_name": "bstrie",
        "timestamp": 1646170736
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273714693\">said</a>:</p>\n<blockquote>\n<p>would that involve moving more things into core::ffi? currently it's just c_void, yeah?</p>\n</blockquote>\n<p>Yes, and we should absolutely do that.</p>",
        "id": 273714739,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170751
    },
    {
        "content": "<p>I'm thinking of sending that PR today, actually.</p>",
        "id": 273714764,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170760
    },
    {
        "content": "<p>sounds good to me, maybe the \"core\" of libc should just be core::ffi :P</p>",
        "id": 273714816,
        "sender_full_name": "bstrie",
        "timestamp": 1646170783
    },
    {
        "content": "<p>I've been holding off because it'd be hard to do with stability markers, but I can just do it <em>without</em> stability markers and FCP it being insta-stable.</p>",
        "id": 273714826,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Thoughts on such a PR?</p>",
        "id": 273714910,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170811
    },
    {
        "content": "<p>(with re-export in the existing location)</p>",
        "id": 273714943,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170821
    },
    {
        "content": "<p>I have a half-finish branch from 2018 which also does that. So yes, I'm in favor.</p>",
        "id": 273714960,
        "sender_full_name": "Amanieu",
        "timestamp": 1646170835
    },
    {
        "content": "<p>I'm curious about what you'd need <code>non_exhaustive</code> for with libc</p>",
        "id": 273715048,
        "sender_full_name": "Lokathor",
        "timestamp": 1646170889
    },
    {
        "content": "<p>Why would this be insta-stable? It's just typedefs for <code>c_int</code>, etc.</p>",
        "id": 273715081,
        "sender_full_name": "Amanieu",
        "timestamp": 1646170912
    },
    {
        "content": "<p>Yeah I'm unclear why a type alias would need to be insta-stable</p>",
        "id": 273715177,
        "sender_full_name": "Lokathor",
        "timestamp": 1646170955
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273715081\">said</a>:</p>\n<blockquote>\n<p>Why would this be insta-stable? It's just typedefs for <code>c_int</code>, etc.</p>\n</blockquote>\n<p>I was assuming we wanted them to be the same types, re-exported.</p>",
        "id": 273715212,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170974
    },
    {
        "content": "<p>If we make them visibly type aliases that could work.</p>",
        "id": 273715264,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646170988
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/compare/master...Amanieu:core_ctypes\">https://github.com/rust-lang/rust/compare/master...Amanieu:core_ctypes</a></p>",
        "id": 273715281,
        "sender_full_name": "Amanieu",
        "timestamp": 1646171001
    },
    {
        "content": "<p>They've always been visibly type aliases and i think it would be an unexpected and unwanted change to make them newtypes or anything of the sort</p>",
        "id": 273715395,
        "sender_full_name": "Lokathor",
        "timestamp": 1646171055
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273715395\">said</a>:</p>\n<blockquote>\n<p>They've always been visibly type aliases and i think it would be an unexpected and unwanted change to make them newtypes or anything of the sort</p>\n</blockquote>\n<p>No, I don't mean newtypes.</p>",
        "id": 273715407,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646171063
    },
    {
        "content": "<p>I meant, I <em>had</em> been planning to move the type aliases to core and then re-export them all from std.</p>",
        "id": 273715424,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646171075
    },
    {
        "content": "<p>And re-exports can't have different stability markers.</p>",
        "id": 273715439,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646171083
    },
    {
        "content": "<p>But it could absolutely work to instead move all the type aliases to core, then make std contain type aliases for the types in core.</p>",
        "id": 273715486,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646171104
    },
    {
        "content": "<p>And those <em>could</em> have different stability markers, I think.</p>",
        "id": 273715505,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646171114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Yeah, that's a much better approach. Thanks!</p>",
        "id": 273715636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646171164
    },
    {
        "content": "<p>(feel free to base your PR off my code, I haven't touched it in years)</p>",
        "id": 273715827,
        "sender_full_name": "Amanieu",
        "timestamp": 1646171273
    },
    {
        "content": "<p>Haven't we stabilized re-exports in std before core/alloc in the past?</p>",
        "id": 273715836,
        "sender_full_name": "cuviper",
        "timestamp": 1646171278
    },
    {
        "content": "<p>I don't recall cases where we've done that, and from a technical perspective we can't do that with just re-exports, it only works if there's some other mechanism in play to allow the stability markers to differ.</p>",
        "id": 273715963,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646171327
    },
    {
        "content": "<p>I was thinking like <code>core::panic</code>, but I guess that was actually a distinct module from <code>std::panic</code>, and actual re-exports within?</p>",
        "id": 273716735,
        "sender_full_name": "cuviper",
        "timestamp": 1646171664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> <a href=\"https://github.com/rust-lang/rust/pull/94503\">https://github.com/rust-lang/rust/pull/94503</a></p>",
        "id": 273724373,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646175461
    },
    {
        "content": "<p>(still waiting to see if CI passes)</p>",
        "id": 273724386,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646175471
    },
    {
        "content": "<p>Argh. <code>cfg_if</code> isn't usable from core. :(</p>",
        "id": 273726129,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646176300
    },
    {
        "content": "<p><code>cfg_if</code> really should either be in core or we should add an equivalent language feature. I'm still not sure what such a language feature would look like though.</p>",
        "id": 273726746,
        "sender_full_name": "Amanieu",
        "timestamp": 1646176756
    },
    {
        "content": "<p>At the moment, I'm <em>tempted</em> to copy-paste the implementation of <code>cfg_if</code> into core and just not export it. :)</p>",
        "id": 273727270,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646177035
    },
    {
        "content": "<p>I'm also tempted to just temporarily revert the patch that used <code>cfg_if</code> in <code>std::os::raw</code>.</p>",
        "id": 273727365,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646177066
    },
    {
        "content": "<p>Incidentally, if the compiler starts evaluating all cfg paths, that extra cost that was mentioned in today's T-lang meeting hits cfg-if the hardest (because it generates big big piles of cfg)</p>",
        "id": 273729052,
        "sender_full_name": "Lokathor",
        "timestamp": 1646177951
    },
    {
        "content": "<p>my concern with splitting libc (or this plan anyway) is that it will make it more annoying to support cross-platform dev, for example, consider the case where some non-standard function is available on a handful of unix targets. now i need to check each extension libc, and a new OS that has that functionality won't work out of the box until I add another crate dependency.</p>\n<p>Also, long term, once we have <code>#[cfg(available(...))]</code>, it'd be nice if <code>#[cfg(available(libc::getloadavg))]</code> or something worked to support \"all systems with this API\", whereas there's no way to do that cleanly if we split things up</p>",
        "id": 273767950,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646207680
    },
    {
        "content": "<p>cfg available is not correct for this use case. Some OSes may give it a different api or different semantics.</p>",
        "id": 273768488,
        "sender_full_name": "bjorn3",
        "timestamp": 1646208007
    },
    {
        "content": "<p>It's imperfect in that it's prone to a compile error if they have different types. I suppose in principal they could give it different behavior too, but that's fairly unlikely in practice. It's also no worse than what you'd get in C.</p>",
        "id": 273770586,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646209290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273767950\">said</a>:</p>\n<blockquote>\n<p>my concern with splitting libc (or this plan anyway) is that it will make it more annoying to support cross-platform dev, for example, consider the case where some non-standard function is available on a handful of unix targets. now i need to check each extension libc, and a new OS that has that functionality won't work out of the box until I add another crate dependency.</p>\n<p>Also, long term, once we have <code>#[cfg(available(...))]</code>, it'd be nice if <code>#[cfg(available(libc::getloadavg))]</code> or something worked to support \"all systems with this API\", whereas there's no way to do that cleanly if we split things up</p>\n</blockquote>\n<p>libc would also still be hardcoded with platform support. I'd like to see that cease to be a thing.</p>",
        "id": 273797898,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646223695
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273767950\">said</a>:</p>\n<blockquote>\n<p>my concern with splitting libc (or this plan anyway) is that it will make it more annoying to support cross-platform dev, for example, consider the case where some non-standard function is available on a handful of unix targets. now i need to check each extension libc, and a new OS that has that functionality won't work out of the box until I add another crate dependency.</p>\n<p>Also, long term, once we have <code>#[cfg(available(...))]</code>, it'd be nice if <code>#[cfg(available(libc::getloadavg))]</code> or something worked to support \"all systems with this API\", whereas there's no way to do that cleanly if we split things up</p>\n</blockquote>\n<p>that's an argument in favor of continuing to provide a libc facade that exports all the platform-specific crates, but not an argument against merely having those platform specific crates, which is what my own use case requires, since libc's built-in <code>cfg</code>s mean that  the symbols that I need aren't visible on the target I'm compiling for</p>",
        "id": 273810481,
        "sender_full_name": "bstrie",
        "timestamp": 1646229579
    },
    {
        "content": "<p>the crates could still live in the same git repo anyway</p>",
        "id": 273812240,
        "sender_full_name": "The 8472",
        "timestamp": 1646230240
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273797898\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273767950\">said</a>:</p>\n<blockquote>\n<p>my concern with splitting libc (or this plan anyway) is that it will make it more annoying to support cross-platform dev, for example, consider the case where some non-standard function is available on a handful of unix targets. now i need to check each extension libc, and a new OS that has that functionality won't work out of the box until I add another crate dependency.</p>\n<p>Also, long term, once we have <code>#[cfg(available(...))]</code>, it'd be nice if <code>#[cfg(available(libc::getloadavg))]</code> or something worked to support \"all systems with this API\", whereas there's no way to do that cleanly if we split things up</p>\n</blockquote>\n<p>libc would also still be hardcoded with platform support. I'd like to see that cease to be a thing.</p>\n</blockquote>\n<p>That's a policy question that isn't obvious. The <em>downside</em> of not checking platform support in libc is that you would no longer know at compile time if a function is supported on the target you're compiling for.</p>",
        "id": 273856500,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646246526
    },
    {
        "content": "<p>I like that this works at compile time since <code>cargo check --target=blah</code>  is very handy.</p>",
        "id": 273859714,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646247727
    },
    {
        "content": "<p>You can still check without hardcoding, albeit it takes more build time from clean.</p>",
        "id": 273861660,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646248525
    },
    {
        "content": "<p>Hm, I must have misunderstood what you mean. Would I need to have headers installed then?</p>",
        "id": 273863947,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646249505
    },
    {
        "content": "<p>For those checks, yes.</p>",
        "id": 273864089,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646249570
    },
    {
        "content": "<p>not requiring headers is better, if possible (I'm not sure if it's possible here).</p>",
        "id": 273864538,
        "sender_full_name": "Lokathor",
        "timestamp": 1646249776
    },
    {
        "content": "<p>Would the <code>libc-linux-glibc</code> crate have features corresponding to versions of glibc that introduce new API surface? (Does such a question even make sense?)</p>",
        "id": 273866466,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646250625
    },
    {
        "content": "<p>Right. We should <em>never</em> depend on the installed system's headers and the features of those. Being able to build using libc without having headers available is a great Rust feature we shouldn't abandon.</p>",
        "id": 273868807,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646251528
    },
    {
        "content": "<p>The other side of that, though, is that you can end up with targets being unsupported because they aren't (with no technical reason),</p>",
        "id": 273869640,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646251880
    },
    {
        "content": "<p>There is a technical reason: because we don't know what they support, and we don't do compile-time detection of platform capabilities because that makes the capabilities depend on the system we build on.</p>",
        "id": 273870317,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646252260
    },
    {
        "content": "<p>That is absolutely a tradeoff, with positives and negatives in both directions.</p>",
        "id": 273870336,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646252275
    },
    {
        "content": "<p>In general, I do understand and acknowledge your preference for being able to best-effort a target without having to get support upstream. I don't think that's what we should do in libc or std or rustc, though.</p>",
        "id": 273870424,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646252316
    },
    {
        "content": "<p>I've dealt with <code>./configure</code> scripts far too many times, and AFAICT Linux distributors systematically override the autodetection by passing explicit <code>--enable-</code> and <code>--disable-</code> flags for everything, to make the build less fragile.</p>",
        "id": 273870545,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646252385
    },
    {
        "content": "<p>And that's leaving aside the issue that we want to work towards better support for building on a system with new libc and running on a system with old, or vice versa.</p>",
        "id": 273870628,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646252408
    },
    {
        "content": "<p>Right now you can build on a system with old libc and still build code that calls new functions your headers don't have.</p>",
        "id": 273870673,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646252433
    },
    {
        "content": "<p>Indeed. I like the \"if there's no reason why it can't, then it should work\" perspective because it minimizes the issues where support is impossible because something somewhere in a dep tree has zero clue a target even exists.</p>",
        "id": 273870796,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646252519
    },
    {
        "content": "<p>FWIW, I <em>do</em> want to move away from hand-written libc bindings to something like bindgen, but I think we should do that by shipping a copy of the newest headers, not by ever using the system headers.</p>",
        "id": 273871184,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646252676
    },
    {
        "content": "<p>I think Zig just ships a huge pile of info to have data on all the libc variations across all their major cross compile targets so that you can always cross compile to anywhere from anywhere. And that's probably fine enough really because it's not a radical amount of extra code for each target (compared to the size of the rest of the toolchain).</p>",
        "id": 273873483,
        "sender_full_name": "Lokathor",
        "timestamp": 1646253643
    },
    {
        "content": "<p>(I don't know if it's C headers or Zig files or what format exactly)</p>",
        "id": 273873592,
        "sender_full_name": "Lokathor",
        "timestamp": 1646253698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/the.20splittening.20of.20libc/near/273873592\">said</a>:</p>\n<blockquote>\n<p>(I don't know if it's C headers or Zig files or what format exactly)</p>\n</blockquote>\n<p>It's <a href=\"https://github.com/ziglang/glibc-abi-tool/\"><code>.abilist</code></a> files, if this is what you are talking about. IIRC someone came on here not too long ago with a rust parser for these files</p>",
        "id": 273875528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646254622
    },
    {
        "content": "<p><a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Integrating.20Zig's.20.60abilists.60.20project.20for.20.60glibc.60.20symbols/near/272194000\">https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Integrating.20Zig's.20.60abilists.60.20project.20for.20.60glibc.60.20symbols/near/272194000</a></p>",
        "id": 273875709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646254694
    },
    {
        "content": "<p>Zig uses both C headers and abilist symbols: the C headers are parsed to get function prototypes and the abilist is used to figure out which symbol to link to.</p>",
        "id": 273947384,
        "sender_full_name": "Amanieu",
        "timestamp": 1646300691
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"220097\">@Erich Gubler</span> you may be interested in this conversation, or at least its recent turn.</p>",
        "id": 274211859,
        "sender_full_name": "Jubilee",
        "timestamp": 1646445054
    },
    {
        "content": "<p>Heck yes I am, thanks <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span>! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 274266813,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1646517071
    },
    {
        "content": "<p>For context of others, I'm the someone who <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> mentioned wrote an <code>abilists</code> parser.</p>",
        "id": 274266889,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1646517212
    }
]