[
    {
        "content": "<p>I'd like to add impls like <code>impl From&lt;Option&lt;NonZeroU64&gt;&gt; for u64</code>, translating None to 0. It's a little annoying to write that normally, requiring something like <code>opt_nonzero.map_or(0, u64::from)</code>. Since trait impls are insta-stable, I wanted to confirm if others on libs-api think this seems reasonable.</p>",
        "id": 255100863,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632768856
    },
    {
        "content": "<p>While I'm not on the libs-api team, this impl would seem to rely on the internal representation quite a bit. Even though it's guaranteed, it seems somewhat surprising that such an impl would exist.</p>",
        "id": 255102111,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1632769307
    },
    {
        "content": "<p>the implementation detail and the semantics are separate. it could be implemented as a simple <code>match</code> statement</p>",
        "id": 255102451,
        "sender_full_name": "The 8472",
        "timestamp": 1632769430
    },
    {
        "content": "<p>Either way I still find it somewhat surprising. The <em>reason</em> for the impl at least appears to be over the internal representation.</p>",
        "id": 255102750,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1632769537
    },
    {
        "content": "<p>it's the inverse of NonZeroU64::new</p>",
        "id": 255102847,
        "sender_full_name": "The 8472",
        "timestamp": 1632769568
    },
    {
        "content": "<p>hm. it's a shame that a method on <code>Option&lt;NonZeroU64&gt;</code> would appear on the <code>Option</code> page in the docs, not on the <code>NonZeroU64</code> page.</p>",
        "id": 255102926,
        "sender_full_name": "Mara",
        "timestamp": 1632769602
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/219381-t-libs/topic/impl.20From.3COption.3CNonZeroU64.3E.20for.20u64/near/255102111\">said</a>:</p>\n<blockquote>\n<p>While I'm not on the libs-api team, this impl would seem to rely on the internal representation quite a bit. Even though it's guaranteed, it seems somewhat surprising that such an impl would exist.</p>\n</blockquote>\n<p>I have no intention of relying on the internal representation in the impl.</p>",
        "id": 255102965,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632769620
    },
    {
        "content": "<p>I'm hoping the compiler will be smart enough to turn the implementation into a no-op.</p>",
        "id": 255103003,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632769640
    },
    {
        "content": "<p>My proposed implementation looks like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">            </span><span class=\"cp\">#[stable(feature = </span><span class=\"s\">\"from_option_nonzero\"</span><span class=\"cp\">, since = </span><span class=\"s\">\"1.57.0\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"cp\">$Ty</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"cp\">$Int</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"cp\">#[doc = concat!(</span><span class=\"s\">\"Converts an `Option&lt;\"</span><span class=\"cp\">, stringify!($Ty), </span><span class=\"s\">\"&gt;` into an `\"</span><span class=\"cp\">, stringify!($Int), </span><span class=\"s\">\"`\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">fn</span> <span class=\"nf\">from</span><span class=\"p\">(</span><span class=\"n\">opt_nonzero</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"cp\">$Ty</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">opt_nonzero</span><span class=\"p\">.</span><span class=\"n\">map_or</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">nonzero</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">nonzero</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 255103076,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632769671
    },
    {
        "content": "<p>i'm a bit worried that both <code>Option&lt;NonZeroU64&gt;</code> and <code>NonZeroU64</code> can then be <code>.into()</code>'d into a <code>u64</code>. if someone is using <code>.into()</code> instead of <code>.get()</code>, changing the type of something to an Option would silently keep working and introduce a 0 where there probably shouldn't be one.</p>",
        "id": 255103251,
        "sender_full_name": "Mara",
        "timestamp": 1632769745
    },
    {
        "content": "<p>I suppose what I'm saying is it doesn't seem like <code>Option</code> should be used to represent the niche semantically.</p>",
        "id": 255103319,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1632769780
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/impl.20From.3COption.3CNonZeroU64.3E.20for.20u64/near/255103251\">said</a>:</p>\n<blockquote>\n<p>i'm a bit worried that both <code>Option&lt;NonZeroU64&gt;</code> and <code>NonZeroU64</code> can then be <code>.into()</code>'d into a <code>u64</code>. if someone is using <code>.into()</code> instead of <code>.get()</code>, changing the type of something to an Option would silently keep working and introduce a 0 where there probably shouldn't be one.</p>\n</blockquote>\n<p>That thought occurred to me as well. The flip side is, if you're converting to u64, which allows zeroes, presumably you're doing that for a reason, rather than just passing NonZeroU64 onwards.</p>",
        "id": 255103475,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632769830
    },
    {
        "content": "<p>But Option is a pretty central example for that.</p>",
        "id": 255103483,
        "sender_full_name": "The 8472",
        "timestamp": 1632769833
    },
    {
        "content": "<p>if I may invoke slippery-slope, would you also do <code>Option&lt;NonNull&lt;T&gt;&gt;</code> to <code>*mut T</code>? or <code>Option&lt;&amp;T&gt;</code> to <code>*const T</code>? or any other cases where FFI already guarantees pseudo-transparent options?</p>",
        "id": 255103557,
        "sender_full_name": "cuviper",
        "timestamp": 1632769880
    },
    {
        "content": "<p>(not that this is about FFI)</p>",
        "id": 255103567,
        "sender_full_name": "cuviper",
        "timestamp": 1632769885
    },
    {
        "content": "<blockquote>\n<p>That thought occurred to me as well. The flip side is, if you're converting to u64, which allows zeroes, presumably you're doing that for a reason, rather than just passing NonZeroU64 onwards.</p>\n</blockquote>\n<p>It's pretty common to have operations on a regular u64 (or u32/i32/...) that will panic or are UB when the value is zero. e.g. passing a u64 to a FFI function, or dividing by a u64, etc.</p>",
        "id": 255103602,
        "sender_full_name": "Mara",
        "timestamp": 1632769900
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/impl.20From.3COption.3CNonZeroU64.3E.20for.20u64/near/255103483\">said</a>:</p>\n<blockquote>\n<p>But Option is a pretty central example for that.</p>\n</blockquote>\n<p>How so?</p>",
        "id": 255103620,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1632769907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> I didn't plan to write those impls, but I see nothing wrong with having those impls as well.</p>",
        "id": 255103622,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632769908
    },
    {
        "content": "<p>For what it's worth, safe-transmute will allow this once implemented, we'd just be giving people are more obvious way to do it</p>",
        "id": 255103717,
        "sender_full_name": "Lokathor",
        "timestamp": 1632769937
    },
    {
        "content": "<p>Yeah, I don't think this is appropriate. Option is for the absence of something, using <code>into()</code> would essentially always assert the presence of it.</p>",
        "id": 255103756,
        "sender_full_name": "Jubilee",
        "timestamp": 1632769958
    },
    {
        "content": "<p><code>.or_zero()</code>, <code>.or_null()</code> etc. would be nicer to read. but it's a bit annoying that they all end up on the <code>Option&lt;T&gt;</code> type for many different <code>T</code></p>",
        "id": 255103759,
        "sender_full_name": "Mara",
        "timestamp": 1632769959
    },
    {
        "content": "<p>it doesn't end up on the u64 page?</p>",
        "id": 255103854,
        "sender_full_name": "Lokathor",
        "timestamp": 1632770008
    },
    {
        "content": "<p>Yeah, I wouldn't be opposed to <code>.get_or_zero()</code> or similar</p>",
        "id": 255103882,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1632770025
    },
    {
        "content": "<p>And yes, an alternate API would be appropriate.</p>",
        "id": 255103904,
        "sender_full_name": "Jubilee",
        "timestamp": 1632770038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/219381-t-libs/topic/impl.20From.3COption.3CNonZeroU64.3E.20for.20u64/near/255103620\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/impl.20From.3COption.3CNonZeroU64.3E.20for.20u64/near/255103483\">said</a>:</p>\n<blockquote>\n<p>But Option is a pretty central example for that.</p>\n</blockquote>\n<p>How so?</p>\n</blockquote>\n<p>In fact Option is the <em>only</em> type for which we have normative guarantees about niche optimizations. All other types that have them are still in the \"would be nice if that were part of the spec too\" stage.</p>",
        "id": 255103911,
        "sender_full_name": "The 8472",
        "timestamp": 1632770040
    },
    {
        "content": "<p>just like <code>vec.len()</code> doesn't appear on the <code>usize</code> page. nope</p>",
        "id": 255103912,
        "sender_full_name": "Mara",
        "timestamp": 1632770040
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> That's an interesting idea. Seems a little annoying to have to use a special-case method, though.</p>",
        "id": 255103935,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632770042
    },
    {
        "content": "<p>oh, <code>impl From&lt;u16&gt; for u64</code> is on the u64 page though</p>",
        "id": 255104004,
        "sender_full_name": "Lokathor",
        "timestamp": 1632770069
    },
    {
        "content": "<p>sure. because Self is u64 there.</p>",
        "id": 255104018,
        "sender_full_name": "Mara",
        "timestamp": 1632770079
    },
    {
        "content": "<p>but in <code>impl From&lt;Option&lt;NonZeroU64&gt;&gt; for u64</code>, isn't Self also still u64?</p>",
        "id": 255104069,
        "sender_full_name": "Lokathor",
        "timestamp": 1632770109
    },
    {
        "content": "<p>i'm talking about a method like <code>.or_zero()</code></p>",
        "id": 255104099,
        "sender_full_name": "Mara",
        "timestamp": 1632770125
    },
    {
        "content": "<p>oh oh ohhhhhh</p>",
        "id": 255104107,
        "sender_full_name": "Lokathor",
        "timestamp": 1632770130
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> Is niche value optimization not guaranteed for Option-like enums? It's not specific to <code>Option</code> as far as I knew.</p>",
        "id": 255104111,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1632770130
    },
    {
        "content": "<p>&lt;dryly&gt; FromOption</p>",
        "id": 255104227,
        "sender_full_name": "Jubilee",
        "timestamp": 1632770167
    },
    {
        "content": "<p>8472 is correct, technically it's not guaranteed right now for Option-like enums, just Option itself</p>",
        "id": 255104332,
        "sender_full_name": "Lokathor",
        "timestamp": 1632770207
    },
    {
        "content": "<p>It just <em>feels</em> wrong. Safe transmute feels like the way to go here, as you'd effectively be declaring that you are aware of the niche value optimization and wish to take advantage of it.</p>",
        "id": 255104746,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1632770390
    },
    {
        "content": "<p>I don't object to waiting for safe transmute, if the general consensus is that the <code>From</code> impl would be too error-prone.</p>",
        "id": 255104904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632770444
    },
    {
        "content": "<p>I don't personally think this is tied to the niche optimization or the internal representation. But I do understand the objection that people might invoke this via <code>.into()</code> accidentally when they expected to process the <code>None</code> first.</p>",
        "id": 255105051,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632770502
    },
    {
        "content": "<p>We already have <code>NonZero*::new</code> to do this in the opposite direction, to convert 0 to None. having the opposite is useful. but i'm a bit worried that a <code>From</code> impl is too subtle. also because we'd have to directly stabilize it, without the chance to first try it out as unstable to see how it goes</p>",
        "id": 255105584,
        "sender_full_name": "Mara",
        "timestamp": 1632770700
    },
    {
        "content": "<p>Yeah, the method should exist, it just likely has the wrong semantics.<br>\nIt feels too much like<br>\ntake a hypothetical ExitCode type (may (not) exist), and ExitErr, which internally is a NonZero because if it's 0 it's success.<br>\ni.e. We're Unix now.<br>\nIt feels too much like it risks a translation of<br>\nExitCode -&gt; Option&lt;ExitErr&gt; -&gt; ExitErr -&gt; Option&lt;ExitErr&gt; -&gt; ExitCode<br>\nsuddenly becoming simplified to omit the middle two steps.</p>",
        "id": 255107565,
        "sender_full_name": "Jubilee",
        "timestamp": 1632771503
    },
    {
        "content": "<p>I agree that having a way to go from an Option&lt;NonZeroU64&gt; to a u64 would be useful but also don't think the From impl would be the right way to do it. IMO the None here isn't semantically equivalent to a 0 even if they're represented the same way, I can imagine in many cases users would want to default to <code>1</code> or some other non-zero number, and introducing a zero on accident would cause issues</p>",
        "id": 255107726,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1632771572
    },
    {
        "content": "<p>in the hypothetical where it is 5 steps, you \"know\" from the trip through ExitErr that you have a 1+ value, and you might write code based on that assumption, which is wrong if it gets simplified too readily. You have <strong>eliminated</strong> the possibility which is exactly what such a type transition is for.</p>\n<p>And the Option might exist because you are performing a transformation in the program which unites two paths with disjoint control flow: the 3-step path and the 5-step path exist simultaneously, and you may reason based on this number's value on which branch you took.</p>",
        "id": 255108610,
        "sender_full_name": "Jubilee",
        "timestamp": 1632771953
    },
    {
        "content": "<p>I am not recommending anyone write code like this, I am just saying that mixing type and value-oriented reasoning in surprising ways and hinging control flow on it is very easy for programmers and I would call such a function<code>maybe_zero</code> just to hammer home the point. &lt;_&lt;</p>",
        "id": 255109347,
        "sender_full_name": "Jubilee",
        "timestamp": 1632772216
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/process/struct.ExitStatusError.html\">https://doc.rust-lang.org/std/process/struct.ExitStatusError.html</a> oh it does exist.<br>\n<a href=\"https://doc.rust-lang.org/std/process/struct.ExitStatus.html#method.code\">https://doc.rust-lang.org/std/process/struct.ExitStatus.html#method.code</a> and ExitStatus does return Option&lt;i32&gt; if you ask it what the code is because the None case represents sigterm. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 255109818,
        "sender_full_name": "Jubilee",
        "timestamp": 1632772429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/impl.20From.3COption.3CNonZeroU64.3E.20for.20u64/near/255105584\">said</a>:</p>\n<blockquote>\n<p>We already have <code>NonZero*::new</code> to do this in the opposite direction, to convert 0 to None. having the opposite of that is useful too. but i'm a bit worried that a <code>From</code> impl is too subtle.</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"kt\">u64</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">v</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">NonZeroU64</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">map_or</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">nonzero</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">nonzero</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>:&gt;</p>",
        "id": 255203406,
        "sender_full_name": "jplatte",
        "timestamp": 1632829960
    },
    {
        "content": "<p>hah.</p>",
        "id": 255248247,
        "sender_full_name": "Jubilee",
        "timestamp": 1632847275
    },
    {
        "content": "<p>It’s the same behavior in the end but to me the \"intent\" of <code>NonZeroU64::new</code> is not to convert zero to None but more like: do a fallible conversion that would return something like <code>Result&lt;_, NonZeroFromZeroError&gt;</code> but since the error type is zero-size and has no interesting method we cut a corner and used <code>Option&lt;_&gt;</code> to represent that result. In hindsight maybe it should really have been a <code>Result</code></p>",
        "id": 255526138,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1632984639
    },
    {
        "content": "<p>I agree with the general sentiment that a whole <code>From</code> impl on <code>Option</code> seems to be too broad. Since such a method would belong to <code>Option</code>, it would be nice to find a more general alternative. In this case, it seems to be a <code>.map_into_or()</code> operation of sorts, which could be shortened, modulo bikeshed, to <code>.into_or()</code>. The resulting adapter remains too niche imho (if <code>.unwrap_or_default()</code> is to be deprecated in favor of <code>.unwrap_or_else(&lt;_&gt;::default)</code>, the following addition seems to go in the opposite direction). What about an extension trait for the current needs, and see how often you reach out for such a helper?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[extension_trait]</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">OptionIntoOr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">into_or</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">else_</span>: <span class=\"nc\">U</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"nb\">Into</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">map_or</span><span class=\"p\">(</span><span class=\"n\">else_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Into</span>::<span class=\"n\">into</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">opt_nonzero</span><span class=\"p\">.</span><span class=\"n\">into_or</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 255570208,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1633007214
    },
    {
        "content": "<blockquote>\n<p>I agree with the general sentiment that a whole From impl on Option seems to be too broad</p>\n</blockquote>\n<p>It wouldn't really be <em>on</em> option though since it's an impl for <code>u64</code>. Where stuff shows up in rustdoc is mostly an issue of rustdoc not knowing which part of a trait impl is the most significant one.</p>",
        "id": 255573090,
        "sender_full_name": "The 8472",
        "timestamp": 1633008361
    },
    {
        "content": "<p>yeah you'd call it as <code>u64::from(opt_nz)</code></p>",
        "id": 255574683,
        "sender_full_name": "Lokathor",
        "timestamp": 1633008945
    },
    {
        "content": "<p>Slight distraction: particularly in std, and for blanket impls in std, it would be nice if e.g. <code>Into</code> impls showed up on the relevant rustdoc pages... i.e. that the <code>From</code> being on one page leads to the <code>Into</code> being on the other type</p>",
        "id": 255581646,
        "sender_full_name": "Daniel Wagner-Hall",
        "timestamp": 1633011436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/impl.20From.3COption.3CNonZeroU64.3E.20for.20u64/near/255573090\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I agree with the general sentiment that a whole From impl on Option seems to be too broad</p>\n</blockquote>\n<p>It wouldn't really be <em>on</em> option though since it's an impl for <code>u64</code>. Where stuff shows up in rustdoc is mostly an issue of rustdoc not knowing which part of a trait impl is the most significant one.</p>\n</blockquote>\n<p>To clarify, there are <em>two</em> points here:</p>\n<ul>\n<li>\n<p>One is the initial proposal of a <code>From&lt;Opt&lt;NZUn&gt;&gt;</code> for <code>un</code>; which is based off an implicit unwrap which \"arbitrarily\" assigns <code>0</code> to <code>None</code>. Not only can it be mixed up with <code>From&lt;NZUn&gt; for un</code>, but having a <code>From</code> impl which altogether performs unwrap can be deemed a bit too terse.</p>\n</li>\n<li>\n<p>So there is a second idea floating around of adding some method to <code>Opt&lt;NZUn&gt;</code>, such as <code>.get_or(0)</code>. This seems way more reasonable already, but has a documentation issue which imho is just a symptom of a deeper design issue: such a method would show up on the docs for <code>Option</code> rather than the docs for <code>NZUn</code>; hence my suggesting a <em>broader</em> API, <code>into_or</code> (modulo name bikeshedding), which is the one thing that could qualify as an API addition for <code>Option</code>.</p>\n</li>\n</ul>\n<p>I could live with the simpler <code>.get_or</code>, though; but I remain a bit skeptical of the <code>From</code> approach.</p>",
        "id": 255585490,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1633012793
    },
    {
        "content": "<blockquote>\n<p>but having a From impl which altogether performs unwrap can be deemed a bit too terse.</p>\n</blockquote>\n<p>For the general case I would agree. But for <code>Option&lt;NonZero*&gt;</code> it doesn't seem that bad considering it's the opposite of what <code>::new</code> already does.</p>\n<blockquote>\n<p>But has a documentation issue which imho is just a symptom of a deeper design issue: such a method would show up on the docs for Option rather than the docs for NZUn</p>\n</blockquote>\n<p>Instead we could improve the docs. We have other cases where such confusion happens. E.g. <code>impl&lt;T&gt; *const [T]</code>  should probably show up in the slice docs instead of the pointer docs. Similar with some <code>MaybeUninit</code> APIs being scattered over several types.<br>\nMaybe an attribute that tells rustdoc which the most important type in an impl is would help.</p>",
        "id": 255590374,
        "sender_full_name": "The 8472",
        "timestamp": 1633014428
    },
    {
        "content": "<p>I agree with Simon and Jane on this, I think.</p>\n<p>The piece I'll add here is that I think the <code>From</code> proposed here extends poorly to other potential <code>From</code>/<code>TryFrom</code>s.  If we ever have <code>NonZeroU32: TryFrom&lt;u64&gt;</code> -- which I think is reasonable same as we have <code>NonZeroU32: TryFrom&lt;NonZeroU64&gt;</code> -- then it loses the \"0 turns into None\" property of the current <code>NonZeroU32: TryFrom&lt;u32&gt;</code>.  And having <code>u64: From&lt;Option&lt;NonZeroU32&gt;&gt;</code> turn <code>None</code> into <code>0</code> doesn't seem as justifiable as it might be for <code>u32: From&lt;Option&lt;NonZeroU32&gt;&gt;</code>.</p>",
        "id": 255680613,
        "sender_full_name": "scottmcm",
        "timestamp": 1633055496
    }
]