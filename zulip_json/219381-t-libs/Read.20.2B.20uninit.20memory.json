[
    {
        "content": "<p>I have a prototype of a more robust approach towards use of uninitialized buffers in the Read trait, if people are interested: <a href=\"https://paper.dropbox.com/doc/IO-Buffer-Initialization--AneImNfaJpZ0LCvEngs0_eFTAg-MvytTgjIOTNpJAS6Mvw38\" target=\"_blank\" title=\"https://paper.dropbox.com/doc/IO-Buffer-Initialization--AneImNfaJpZ0LCvEngs0_eFTAg-MvytTgjIOTNpJAS6Mvw38\">https://paper.dropbox.com/doc/IO-Buffer-Initialization--AneImNfaJpZ0LCvEngs0_eFTAg-MvytTgjIOTNpJAS6Mvw38</a> for background, and <a href=\"https://github.com/sfackler/read-buf\" target=\"_blank\" title=\"https://github.com/sfackler/read-buf\">https://github.com/sfackler/read-buf</a> for the code</p>",
        "id": 185173844,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578530793
    },
    {
        "content": "<p>I'm going to start writing an RFC for it all this week</p>",
        "id": 185173853,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578530812
    },
    {
        "content": "<p>I've been looking into some of this stuff for non-libstd work.</p>",
        "id": 185197173,
        "sender_full_name": "Amanieu",
        "timestamp": 1578563469
    },
    {
        "content": "<p>One thing that I find very useful is for <code>read</code> to return an initialized slice rather than a <code>usize</code>.</p>",
        "id": 185197183,
        "sender_full_name": "Amanieu",
        "timestamp": 1578563493
    },
    {
        "content": "<p>Basically it returns the part of the buffer that has been filled.</p>",
        "id": 185197185,
        "sender_full_name": "Amanieu",
        "timestamp": 1578563502
    },
    {
        "content": "<p>You can easily get the <code>usize</code> back by calling <code>.len()</code>.</p>",
        "id": 185197263,
        "sender_full_name": "Amanieu",
        "timestamp": 1578563574
    },
    {
        "content": "<p>Regarding the buffer argument, what I had in mind what a <code>ReadBuf</code> trait which is implemented by both <code>&amp;mut [u8]</code> and <code>&amp;mut [MaybeUninit&lt;u8&gt;]</code>. The read method would then become <code>fn read(buf: impl ReadBuf) -&gt; &amp;[u8]</code>.</p>",
        "id": 185197775,
        "sender_full_name": "Amanieu",
        "timestamp": 1578564070
    },
    {
        "content": "<p>However this is no longer object-safe since it uses generics.</p>",
        "id": 185197790,
        "sender_full_name": "Amanieu",
        "timestamp": 1578564085
    },
    {
        "content": "<p>Taking an impl ReadBuf makes it not object safe which we need.</p>",
        "id": 185212421,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578577339
    },
    {
        "content": "<p>The returning a slice approach ends up being pretty awkward - there are no guarantees as to where that slice actually points, which you need if you're trying to have an interface that converts <code>[MaybeUninit&lt;u8&gt;]</code> into <code>[u8]</code>.</p>",
        "id": 185212491,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578577395
    },
    {
        "content": "<p>I don't understand the problem with returning a slice. The slice points to the buffer that was provided by the caller. Specifically the part of the buffer that was filled by the read operation (the rest of the buffer still being uninitialized).</p>",
        "id": 185212770,
        "sender_full_name": "Amanieu",
        "timestamp": 1578577614
    },
    {
        "content": "<p>Read is not an unsafe trait, so all a caller knows is that the returned buffer points to some slice of initialized bytes. It is hopefully a slice from the head of the input buffer, but it could be a slice from the middle of it, or a slice into static memory, or something else</p>",
        "id": 185214201,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578578765
    },
    {
        "content": "<p>code doing something like e.g. read_exact needs to know that the head of the input buffer is the bit being initialized if it's going to be able to return the entire buffer as initialized memory at the end</p>",
        "id": 185214242,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578578798
    },
    {
        "content": "<p>you can always check the pointer address if you care that much about the exact location.</p>",
        "id": 185240082,
        "sender_full_name": "Lokathor",
        "timestamp": 1578594054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> thinking a bit more about this, I'm wondering if the right way to think about the RFC is that we are adding a type to the std library for working with partially initialized buffers -- and then using that in the Read trait? (In other words, this is a general abstraction that may have use elsewhere, presumably..?)</p>",
        "id": 185391011,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1578751405
    },
    {
        "content": "<p>that could make sense, though I'm not totally sure what other use cases would come up. Minimally we could parameterize it instead of being locked down to u8</p>",
        "id": 185397751,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578763125
    },
    {
        "content": "<p>the version for vectored IO is going to have to be locked down to being read specific since we need to match up with readv's ABI</p>",
        "id": 185397853,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578763277
    },
    {
        "content": "<blockquote>\n<p>code doing something like e.g. read_exact needs to know that the head of the input buffer is the bit being initialized if it's going to be able to return the entire buffer as initialized memory at the end</p>\n</blockquote>\n<p>Actually, this is interesting. As I read it again I realize that maybe I don't understand the imagined usage pattern. Can you give an example?</p>\n<p>I've not yet seen code that makes an uninit buffer, fills it a part at a time, and then returns that whole thing to some outer scope for some reason.</p>",
        "id": 185403815,
        "sender_full_name": "Lokathor",
        "timestamp": 1578774121
    },
    {
        "content": "<p><code>fn read_exact2(&amp;mut self, buf: &amp;mut [MaybeUninit&lt;u8&gt;]) -&gt; io::Result&lt;&amp;[u8]&gt;</code></p>",
        "id": 185404113,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578774657
    },
    {
        "content": "<p>right, so you get some buffer of initialized bytes back, that seems like a totally fine API</p>",
        "id": 185404556,
        "sender_full_name": "Lokathor",
        "timestamp": 1578775452
    },
    {
        "content": "<p>when you're done with that pass, you just go again with the full MaybeUninit slice from last pass</p>",
        "id": 185404591,
        "sender_full_name": "Lokathor",
        "timestamp": 1578775524
    },
    {
        "content": "<p>read_exact needs to do multiple reads, but if the returned buffers aren't consecutive (i.e., may not be from the head) then you can't return a consecutive buffer</p>",
        "id": 185404593,
        "sender_full_name": "simulacrum",
        "timestamp": 1578775561
    },
    {
        "content": "<p>oh you mean for the default read_exact method?</p>",
        "id": 185404637,
        "sender_full_name": "Lokathor",
        "timestamp": 1578775600
    },
    {
        "content": "<p>well, it too, but yes</p>",
        "id": 185404639,
        "sender_full_name": "simulacrum",
        "timestamp": 1578775610
    },
    {
        "content": "<p>well if you're not using a default read_exact method, then whatever internals did the first read clearly can continue to do the second read  until the read_exact is complete</p>",
        "id": 185404656,
        "sender_full_name": "Lokathor",
        "timestamp": 1578775674
    },
    {
        "content": "<p>I want you to write the default implementation of that read_exact2 method</p>",
        "id": 185404709,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578775743
    },
    {
        "content": "<p>Maybe? But the default is not possible to write I think is the point</p>",
        "id": 185404717,
        "sender_full_name": "simulacrum",
        "timestamp": 1578775754
    },
    {
        "content": "<p>If you have a new <code>read_exact</code>, you have a new <code>read</code> also, naturally, wouldn't you say?</p>",
        "id": 185404768,
        "sender_full_name": "Lokathor",
        "timestamp": 1578775814
    },
    {
        "content": "<p>so you'd have read2 and then read_exact2, right?</p>",
        "id": 185404769,
        "sender_full_name": "Lokathor",
        "timestamp": 1578775836
    },
    {
        "content": "<p>yes</p>",
        "id": 185404770,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578775839
    },
    {
        "content": "<p>Write the implementation of read_exact2 that uses read2</p>",
        "id": 185404771,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578775850
    },
    {
        "content": "<p>i am on my phone, so please understand this will take a moment, but sure</p>",
        "id": 185404778,
        "sender_full_name": "Lokathor",
        "timestamp": 1578775873
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"sd\">/// you should init from the front of the buffer</span>\n<span class=\"k\">fn</span> <span class=\"nf\">read2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">MaybrUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">io</span>::<span class=\"n\">result</span><span class=\"o\">&lt;&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"c1\">// assumed</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// the default impl fails if your read2 doesn&#39;t fill from the front of the buffer</span>\n<span class=\"k\">fn</span> <span class=\"nf\">read_exact2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">start</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">MaybrUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">io</span>::<span class=\"n\">result</span><span class=\"o\">&lt;&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">start</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">in_addr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">out</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">in_addr</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"c1\">// didn&#39;t fill from the fromt</span>\n<span class=\"w\">      </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">they</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"c1\">// this much is init now  chop away and continue</span>\n<span class=\"w\">      </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">split_at_mut</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tail</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"c1\">// all of it is init now</span>\n<span class=\"w\">  </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">transmute_slice_however</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 185405147,
        "sender_full_name": "Lokathor",
        "timestamp": 1578776621
    },
    {
        "content": "<p>Right, and so everyone else that wants to incrementally fill a buffer like read_exact2 does has to compare raw pointers, which is not a great experience</p>",
        "id": 185405269,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578776816
    },
    {
        "content": "<p>..what did you expect from MaybeUninit?</p>",
        "id": 185405283,
        "sender_full_name": "Lokathor",
        "timestamp": 1578776851
    },
    {
        "content": "<p>MaybeUninit isn't a great experience in the first place.</p>",
        "id": 185405285,
        "sender_full_name": "Lokathor",
        "timestamp": 1578776864
    },
    {
        "content": "<p>I seem to recall something to the effect of it not being sound to stitch together buffers like this even if you compare pointers</p>",
        "id": 185405329,
        "sender_full_name": "simulacrum",
        "timestamp": 1578776885
    },
    {
        "content": "<p>as i also said, If you override the read_exact2 your own version of read_exact2 can skip the pointer comparison step because you know what your own internal read2 method does</p>",
        "id": 185405332,
        "sender_full_name": "Lokathor",
        "timestamp": 1578776907
    },
    {
        "content": "<p>in this case it's not stitching, it's making sure they're the same thing all along so that should be fine</p>",
        "id": 185405333,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578776913
    },
    {
        "content": "<p>I don't agree that we should accept a bad user experience because some part of the API has a non-ideal user experience</p>",
        "id": 185405340,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578776940
    },
    {
        "content": "<p>there's no stitching! please note the part where we have <code>start</code>, then reborrow it, and edit along the reborrowed one, and then <em>release that reborrow</em> and transmute <code>start</code> once at the end</p>",
        "id": 185405346,
        "sender_full_name": "Lokathor",
        "timestamp": 1578776948
    },
    {
        "content": "<p>I guess yeah, it seems plausibly fine to do this \"stitching\" (yes, not really, but at a high level)</p>",
        "id": 185405358,
        "sender_full_name": "simulacrum",
        "timestamp": 1578777001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> Users are always free to override a default method</p>",
        "id": 185405408,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777018
    },
    {
        "content": "<p>rather, people implementing the trait i should say</p>",
        "id": 185405409,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777036
    },
    {
        "content": "<p>I don't understand how that's relevant to the claim that this read2 API forces awkward pointer double-checking</p>",
        "id": 185405413,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777058
    },
    {
        "content": "<p>because if you overwrite read_exact2 with your own version you don't need to pointer check at all</p>",
        "id": 185405424,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777084
    },
    {
        "content": "<p>someone implementing the Read trait doesn't need to do any checking of any kind in read_exact2 because they don't need to write it in the first place!</p>",
        "id": 185405482,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777226
    },
    {
        "content": "<p>I am talking about other code in other places that wants to do a similar thing of incrementally initializing a buffer</p>",
        "id": 185405529,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777245
    },
    {
        "content": "<p>that's what i asked for an example for that you never really gave a usage of :P</p>",
        "id": 185405532,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777269
    },
    {
        "content": "<p>read_exact is an example. Unless you're claiming that that is the <em>only code</em> that ever incrementally initializes a buffer, then there are other instances of that thing</p>",
        "id": 185405552,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777330
    },
    {
        "content": "<p>for example read_to_end</p>",
        "id": 185405554,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777333
    },
    {
        "content": "<p>but in any case, the other major problem with that version of read2 is that the default implementation of read2 itself that needs to delegate to read can't be implemented sufficiently efficiently</p>",
        "id": 185405596,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777365
    },
    {
        "content": "<p>there are also APIs like parsers that take in a slice of bytes and either process them or say \"no, I need more stuff\"</p>",
        "id": 185405610,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777426
    },
    {
        "content": "<p>which then needs to incrementally fill a buffer</p>",
        "id": 185405620,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777437
    },
    {
        "content": "<p>So the usual desired usage of MaybeUninit for a buffer that I see is something like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">cap</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5000</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Vec</span>::<span class=\"n\">with_capacity</span><span class=\"p\">(</span><span class=\"n\">cap</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cap</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">while</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">bytes_this_pass</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">source</span><span class=\"p\">.</span><span class=\"n\">read_to_unit_buffer</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">do_work</span><span class=\"p\">(</span><span class=\"n\">bytes_this_pass</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and people usually do not desire to actually _keep_ the bytes from pass to pass of the loop</p>",
        "id": 185405628,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777459
    },
    {
        "content": "<p>what happens when do_work says \"bytes_this_pass is too small for me to do anything with\"?</p>",
        "id": 185405677,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777492
    },
    {
        "content": "<p>then you return Err :P</p>\n<p>there's always the possibilty of problems</p>",
        "id": 185405684,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777533
    },
    {
        "content": "<p>but it's not an error condition</p>",
        "id": 185405690,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777546
    },
    {
        "content": "<p>or you can use read_uninit_exact if you <em>must</em> have some quantity</p>",
        "id": 185405693,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777552
    },
    {
        "content": "<p>you don't always know the exact quantity</p>",
        "id": 185405697,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777579
    },
    {
        "content": "<p>e.g. you are trying to parse a single json object</p>",
        "id": 185405701,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777584
    },
    {
        "content": "<p>if you're steaming in json then be prepared to handle part of a json; that's a problem you might have both with and without an uninit buffer. a normal read might also cut out partway through an object, you just plain need to be able to handle that somehow</p>",
        "id": 185405754,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777646
    },
    {
        "content": "<p>you handle it by reading the rest of the object</p>",
        "id": 185405764,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777676
    },
    {
        "content": "<p>so if your buffer is 10 (to pick a number), and you read 10, and then you're partway through an object.. you gotta do something with that 10 before you can read another 10 bytes, so you already have to be able to handle partial objects</p>",
        "id": 185405812,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777739
    },
    {
        "content": "<p>also, before I forget: I absolutely wouldn't suggest putting an uninit based read onto the existing Read trait as ant sort of \"default method\" on top of <code>read</code>, that would be crazy.</p>",
        "id": 185405816,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777765
    },
    {
        "content": "<p>read2 would be like, a totally different method on a new trait for types that are able to handle having MaybeUninit buffers safely</p>",
        "id": 185405825,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777799
    },
    {
        "content": "<p>why would that be crazy</p>",
        "id": 185405826,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777804
    },
    {
        "content": "<p>i mean what would the read2 default impl even be?</p>",
        "id": 185405886,
        "sender_full_name": "Lokathor",
        "timestamp": 1578777893
    },
    {
        "content": "<p>the problem with that proposal is that it doesn't have a good default impl</p>",
        "id": 185405897,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777910
    },
    {
        "content": "<p>it is important to not bifurcate the read trait</p>",
        "id": 185405902,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777927
    },
    {
        "content": "<p>code should be able to take advantage of readers that can work with uninit memory when possible, without needing to just forbid other readers in the type signature</p>",
        "id": 185405908,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777955
    },
    {
        "content": "<p>there are other proposals that do have a good default impl, and don't force a second trait</p>",
        "id": 185405955,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578777989
    },
    {
        "content": "<p>Well, returning the slice of what you wrote is mostly just better for a lot of uses, for both <code>&amp;[u8]</code> or <code>&amp;[MaybeUninit&lt;u8&gt;]</code></p>",
        "id": 185405971,
        "sender_full_name": "Lokathor",
        "timestamp": 1578778040
    },
    {
        "content": "<p>better than what?</p>",
        "id": 185405976,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578778077
    },
    {
        "content": "<p>so, in the sense that, people who want Result&lt;usize&gt; are somehow already best served by getting Result&lt;usize&gt;, yes that trait should continue to use Result&lt;usize&gt; even for the uninit buffer version</p>",
        "id": 185405980,
        "sender_full_name": "Lokathor",
        "timestamp": 1578778081
    },
    {
        "content": "<p>i mean better than Result&lt;usize&gt;</p>",
        "id": 185406019,
        "sender_full_name": "Lokathor",
        "timestamp": 1578778090
    },
    {
        "content": "<p><code>read2</code> could just guarantee that the returned slice starts at the beginning of the buffer.</p>",
        "id": 185406938,
        "sender_full_name": "Amanieu",
        "timestamp": 1578780042
    },
    {
        "content": "<p>Since the trait overall is safe, the writer of the trait is technically within their rights to just not do that though, and <code>unsafe</code> code can't simply rely  on it correctly being start of buffer, so they'd have to do the pointer value check.</p>",
        "id": 185407002,
        "sender_full_name": "Lokathor",
        "timestamp": 1578780222
    },
    {
        "content": "<p>I think that would only end up happening with a deliberately hostile impl, but it could still happen at all.</p>",
        "id": 185407049,
        "sender_full_name": "Lokathor",
        "timestamp": 1578780267
    },
    {
        "content": "<p>Anyways, I kinda like the <code>ReadBuf</code> proposal.</p>",
        "id": 185407060,
        "sender_full_name": "Amanieu",
        "timestamp": 1578780355
    },
    {
        "content": "<p>And I believe we've pretty much agreed that we don't want to make Read (or an equivalent, but new) trait <code>unsafe</code>, even if we ignore backwards compat concerns? i.e., it's too common to write to force people to think about the unsafety aspects?</p>",
        "id": 185407099,
        "sender_full_name": "simulacrum",
        "timestamp": 1578780379
    },
    {
        "content": "<p>However I would make one small change: have <code>read2</code> update the <code>ReadBuf</code> in-place to set the number of bytes read, and give <code>ReadBuf</code> a way to safely extract the initialized portion of the buffer.</p>",
        "id": 185407101,
        "sender_full_name": "Amanieu",
        "timestamp": 1578780415
    },
    {
        "content": "<p>This would works for <code>ReadBufs</code> too.</p>",
        "id": 185407102,
        "sender_full_name": "Amanieu",
        "timestamp": 1578780422
    },
    {
        "content": "<p>Basically I want to be able to, with only safe code, create a [MaybeUninit&lt;u8&gt;], pass it to <code>read2</code> and get a <code>[u8]</code> back.</p>",
        "id": 185407152,
        "sender_full_name": "Amanieu",
        "timestamp": 1578780490
    },
    {
        "content": "<p>All the unsafe code should be in the <code>read2</code> implementation.</p>",
        "id": 185407154,
        "sender_full_name": "Amanieu",
        "timestamp": 1578780498
    },
    {
        "content": "<p>(or in <code>ReadBuf</code> if the <code>read2</code> implementation doesn't use unsafe code)</p>",
        "id": 185407163,
        "sender_full_name": "Amanieu",
        "timestamp": 1578780564
    },
    {
        "content": "<p>how does one make <code>[MaybeUninit&lt;u8&gt;]</code> in safe code again?<br>\nis there like a nightly box api for that or something?</p>",
        "id": 185407392,
        "sender_full_name": "Lokathor",
        "timestamp": 1578781015
    },
    {
        "content": "<p>MaybeUninit::uninit() is safe</p>",
        "id": 185407398,
        "sender_full_name": "Amanieu",
        "timestamp": 1578781026
    },
    {
        "content": "<p>You can create an uninitialized value just note read inside it.</p>",
        "id": 185407400,
        "sender_full_name": "Amanieu",
        "timestamp": 1578781038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> After having a chance to fully review your proposal, I really like the ReadBuf abstraction. The only change I would recommend is for <code>read2</code> to return <code>Result&lt;()&gt;</code> and instead always update the length of the ReadBuf in-place. This makes it more ergonomic to obtain the result of a read.</p>",
        "id": 185407452,
        "sender_full_name": "Amanieu",
        "timestamp": 1578781155
    },
    {
        "content": "<p>oh so you mean like, <code>[MaybeUninit::&lt;u8&gt;::unint(); 1024]</code>, okay i get it</p>",
        "id": 185407505,
        "sender_full_name": "Lokathor",
        "timestamp": 1578781246
    },
    {
        "content": "<p>Then again I'm having second thoughts on how well that would work with ReadBufs...</p>",
        "id": 185407691,
        "sender_full_name": "Amanieu",
        "timestamp": 1578781639
    },
    {
        "content": "<p><code>ReadBuf</code>doesn't track the length of \"read\" data internally, it tracks the amount of initialized memory. It's important that that's monotonically increasing so that you don't end up repeatedly re-zeroing bits of the buffer</p>",
        "id": 185409643,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1578785472
    },
    {
        "content": "<p>Ah fair enough. In that case I have no objections.</p>",
        "id": 185409674,
        "sender_full_name": "Amanieu",
        "timestamp": 1578785523
    },
    {
        "content": "<p>I finally got around to writing the RFC for this, if anyone wants to take a look before I open it up: <a href=\"https://github.com/sfackler/rfcs/blob/read-buf/text/0000-read-buf.md\">https://github.com/sfackler/rfcs/blob/read-buf/text/0000-read-buf.md</a></p>",
        "id": 197867428,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589747357
    },
    {
        "content": "<p>might be worth saying that <code>let mut buf: [u8; 1024] = unsafe { MaybeUninit::uninit().assume_init() };</code> is also UB already even with a known reader according to the current rules (but those rules are under discussion)</p>",
        "id": 197870464,
        "sender_full_name": "RalfJ",
        "timestamp": 1589751904
    },
    {
        "content": "<p>(it doesn't affect the discussion much I think, but just to make sure that people don't read that code and think it is officially blessed.)</p>",
        "id": 197870484,
        "sender_full_name": "RalfJ",
        "timestamp": 1589751946
    },
    {
        "content": "<p>shameless plug: if you want a citation for \"uninitialized memory does not just have an arbitrary value\", you could link to my blog post: <a href=\"https://www.ralfj.de/blog/2019/07/14/uninit.html\">https://www.ralfj.de/blog/2019/07/14/uninit.html</a></p>",
        "id": 197870537,
        "sender_full_name": "RalfJ",
        "timestamp": 1589751995
    },
    {
        "content": "<p>though you already have a pretty convincing example in there :)</p>",
        "id": 197870553,
        "sender_full_name": "RalfJ",
        "timestamp": 1589752034
    },
    {
        "content": "<blockquote>\n<p>Sometimes, working with uninitialized buffers can be more complex than working with regular initialized buffers!</p>\n</blockquote>\n<p>I'd add \"however\", as in: \"Sometimes, however, working with ...\"</p>",
        "id": 197870615,
        "sender_full_name": "RalfJ",
        "timestamp": 1589752115
    },
    {
        "content": "<p>what about <code>assert_initialized</code> -&gt; <code>assume_init</code>, to match  <code>MaybeUninit</code>?</p>",
        "id": 197870763,
        "sender_full_name": "RalfJ",
        "timestamp": 1589752337
    },
    {
        "content": "<p>so <code>ReadBuf</code> has an invariant <code>initialized &gt;= written</code>? might be worth stating explicitly.</p>",
        "id": 197870785,
        "sender_full_name": "RalfJ",
        "timestamp": 1589752408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/Read.20.2B.20uninit.20memory/near/197870763\">said</a>:</p>\n<blockquote>\n<p>what about <code>assert_initialized</code> -&gt; <code>assume_init</code>, to match  <code>MaybeUninit</code>?</p>\n</blockquote>\n<p>oh it already is <code>assume</code> later, just not in the example code</p>",
        "id": 197870919,
        "sender_full_name": "RalfJ",
        "timestamp": 1589752605
    },
    {
        "content": "<p><code>initialize_unwriten_to</code> is an odd name, to me that sounds like a function that sets all uninit memory <em>to</em> some value <code>n</code></p>",
        "id": 197870932,
        "sender_full_name": "RalfJ",
        "timestamp": 1589752641
    },
    {
        "content": "<p>But overall, big <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> :-)</p>",
        "id": 197871324,
        "sender_full_name": "RalfJ",
        "timestamp": 1589753120
    },
    {
        "content": "<p>Thanks! Yeah I'm not sure about the naming of some of the methods on ReadBuf</p>",
        "id": 197874867,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589757843
    },
    {
        "content": "<p>in particular initialize_unwritten/initialize_unwritten_to</p>",
        "id": 197874871,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589757855
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> love it! great RFC. i very much like the <code>ReadBuf</code> type. the way it works feels very transparent and makes a lot of sense. i always agree with your decision on <code>io::Result&lt;()&gt;</code> vs <code>io::Result&lt;usize&gt;</code>. having all of that encapsulated in <code>ReadBuf</code> feels like the right way to go. (i say this as someone who hasn't really tracked progress on this issue.)</p>\n<p>i think my \"biggest\" criticism is definitely that trivial <code>Read</code> impls become possible. it's kind of a bummer. a lint would definitely help with that. the other aspect of this that stinks though is the docs. today, it's clear that there is one single required method to implement, and i'd guess that <code>read</code> is what most folks will continue using even with <code>read_buf</code>. in the new world, there will be no required methods listed in the place one expects, which seems like kind of  a bummer.</p>\n<p>how much has the case of not making <code>read</code> have a default impl been considered? it would create some guaranteed boiler plate for some subset of impls which stinks, but maybe it's not _that_ terrible?</p>",
        "id": 197875665,
        "sender_full_name": "BurntSushi",
        "timestamp": 1589759472
    },
    {
        "content": "<p>I'd hope that people would actually start implementing read_buf by default rather than read as time goes on. We can provide APIs like <code>ReadBuf::append</code> to avoid making people mess with unsafe while still avoiding initialization.</p>\n<p>I'll add leaving <code>read</code> required as an alternative.</p>",
        "id": 197878068,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589762747
    },
    {
        "content": "<p>I imagine that if we wanted to it wouldn't be <em>too</em> hard to add a compiler lint/error that required you to implement one of read or read_buf, fwiw -- it'd be a perma-unstable attribute pair or something like that</p>",
        "id": 197929265,
        "sender_full_name": "simulacrum",
        "timestamp": 1589806307
    },
    {
        "content": "<p>one downside of the current approach of mutually recursive defaults it that e.g. rust-analyzer's \"add required methods\" assist stops working etc, since there's no required methods</p>",
        "id": 197929395,
        "sender_full_name": "simulacrum",
        "timestamp": 1589806351
    },
    {
        "content": "<p>in the ideal world we'd e.g. make 2021 edition code have read_buf be required and prior editions get read defaulted</p>",
        "id": 197929473,
        "sender_full_name": "simulacrum",
        "timestamp": 1589806392
    },
    {
        "content": "<p>which in theory isn't impossible</p>",
        "id": 197929509,
        "sender_full_name": "simulacrum",
        "timestamp": 1589806410
    },
    {
        "content": "<p>Yeah I think the lint check would be pretty easy to add, and we could probably even just upgrade it to some rustc-only annotation to make it a hard error</p>",
        "id": 197939130,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589810772
    },
    {
        "content": "<p>which rust-analyzer could pick up on as well</p>",
        "id": 197939143,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589810779
    },
    {
        "content": "<p>yeah -- I wouldn't mind a hard error personally -- one downside of the mutually default approach is due to LLVM treating recursion without side effects as UB it would make it pretty easy to accidentally trigger that (whereas today it's sort of hard(er) to accidentally hit that)</p>",
        "id": 197939336,
        "sender_full_name": "simulacrum",
        "timestamp": 1589810875
    },
    {
        "content": "<p>I would love to see attributes for what the minimum required implementation is.</p>",
        "id": 197963598,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1589820778
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/pull/2930\">https://github.com/rust-lang/rfcs/pull/2930</a></p>",
        "id": 197997291,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589837023
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> hm, I think I don't see anything about the possibility of an custom attribute to force either read or read_buf to get implemented? do you just consider that out of scope?</p>",
        "id": 197997506,
        "sender_full_name": "simulacrum",
        "timestamp": 1589837142
    },
    {
        "content": "<p>IMO, it well may be -- tying the two together could just lead to unnecessary noise</p>",
        "id": 197997526,
        "sender_full_name": "simulacrum",
        "timestamp": 1589837161
    },
    {
        "content": "<p>There's a note about a lint</p>",
        "id": 197997548,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589837162
    },
    {
        "content": "<blockquote>\n<p>We would ideally create a lint that exactly one of the two methods is implemented, but that is not a hard requirement.</p>\n</blockquote>",
        "id": 197997596,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589837185
    },
    {
        "content": "<p>ah okay, thanks! I had skimmed and mostly paid attention to unresolved questions / future work section</p>",
        "id": 197997721,
        "sender_full_name": "simulacrum",
        "timestamp": 1589837264
    },
    {
        "content": "<p>I don't think it'll be very hard to implement that check, so I'm not too worried about it</p>",
        "id": 197999542,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1589838394
    },
    {
        "content": "<p>sure, yeah</p>",
        "id": 198002476,
        "sender_full_name": "simulacrum",
        "timestamp": 1589840358
    },
    {
        "content": "<p>I agree it seems separate and not something that really needs to be RFCd (though probably deserves check boxes or whatever)</p>",
        "id": 198002494,
        "sender_full_name": "simulacrum",
        "timestamp": 1589840378
    },
    {
        "content": "<p>Discussion on the RFC has trailed off - might be time to FCP it? I think people are generally aligned on the current text.</p>",
        "id": 203039979,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1594069170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> Did you address the point about making ReadBuf generic over <code>T</code> instead of only supporting <code>u8</code>?</p>",
        "id": 203268932,
        "sender_full_name": "Amanieu",
        "timestamp": 1594216074
    },
    {
        "content": "<p>Oh yeah, I'll add a bit about that to the text</p>",
        "id": 203269863,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1594216528
    },
    {
        "content": "<p>If there is reading into uninitialized buffer, is there writing into uninitialized buffer?</p>",
        "id": 203838067,
        "sender_full_name": "pickfire",
        "timestamp": 1594736106
    },
    {
        "content": "<p>Is there a difference between reading <em>into</em> and writing <em>into</em>?</p>",
        "id": 203870287,
        "sender_full_name": "Peter Rabbit",
        "timestamp": 1594751735
    },
    {
        "content": "<p>What do you mean by that? Generally speaking, one \"side\" of each of Read and Write interact with a byte buffer, but they differ in which side it is</p>",
        "id": 203950531,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1594817441
    },
    {
        "content": "<p>I mean as in writing directly to uninitialized buffer like what this proposal does.</p>",
        "id": 204078978,
        "sender_full_name": "pickfire",
        "timestamp": 1594904347
    },
    {
        "content": "<p>The Write trait doesn't involve any mutable buffers.</p>",
        "id": 204084330,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1594906692
    },
    {
        "content": "<p>I'm way late to this thread, but +1 to wishing we had a way to allow different \"required\" sets on traits -- it came up for <code>Iterator</code> a while ago too, since either <code>next</code> or <code>try_fold</code> are enough to do everything else.</p>",
        "id": 205667902,
        "sender_full_name": "scottmcm",
        "timestamp": 1596263257
    },
    {
        "content": "<p>I finally updated the RFC text. There is also a PR open on Tokio updating their async read/write traits to use ReadBuf (currently vendored into the library) as a reference: <a href=\"https://github.com/tokio-rs/tokio/pull/2758\">https://github.com/tokio-rs/tokio/pull/2758</a></p>",
        "id": 207096132,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1597622374
    },
    {
        "content": "<p>The Tokio PR doesn't have the proposed <code>ReadBufs</code> for vectored I/O, is that intentional?</p>",
        "id": 207097540,
        "sender_full_name": "Amanieu",
        "timestamp": 1597624909
    },
    {
        "content": "<p>BTW I'm very excited about this change since it will allow me to significantly reduce the amount of unsafe code in my I/O logic :)</p>",
        "id": 207097584,
        "sender_full_name": "Amanieu",
        "timestamp": 1597624948
    },
    {
        "content": "<p>Not sure about readbufs and the tokio PR - I imagine sean's just working incrementally</p>",
        "id": 207097969,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1597625644
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> Do you feel that RFC is ready for FCP or are there still unresolved questions?</p>",
        "id": 207163091,
        "sender_full_name": "Amanieu",
        "timestamp": 1597680689
    },
    {
        "content": "<p>I think it's ready</p>",
        "id": 207163112,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1597680701
    },
    {
        "content": "<p>While preparing the PR to add ReadBuf to std, I came across a potential problem in the API: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=af920f318b4918c39788957414ae2ee4\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=af920f318b4918c39788957414ae2ee4</a></p>",
        "id": 209321630,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599505643
    },
    {
        "content": "<p>specifically, a malicious Read implementation can <em>replace</em> the ReadBuf passed into read_buf with another (I think the only way to do this without unsafe is to leak the buffer). This can invalidate assumptions callers make about the relation of the initialization information to the buffer they're working with</p>",
        "id": 209321706,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599505711
    },
    {
        "content": "<p>A potential solution is to have a <code>ReadBufRef</code> type (or something like that) which is passed to read_buf by value to prevent replacement of the buffer reference, but that's an unfortunate layer of complication :(</p>",
        "id": 209321736,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599505746
    },
    {
        "content": "<p>Can we <code>Pin</code> it?</p>",
        "id": 209323967,
        "sender_full_name": "Amanieu",
        "timestamp": 1599508125
    },
    {
        "content": "<p>That could work, though it'd be a bit of an \"abuse\" of Pin, since ReadBuf morally should be Unpin</p>",
        "id": 209324906,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599509346
    },
    {
        "content": "<p>Otherwise we could redesign the API to have <code>ReadBuf</code> passed by value instead of by reference.</p>",
        "id": 209325750,
        "sender_full_name": "Amanieu",
        "timestamp": 1599510482
    },
    {
        "content": "<p>Yeah, that's the ReadBufRef idea, but it's a bit unfortunate since there'll be 2 types with very similar APIs :(</p>",
        "id": 209329584,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599515545
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span>  so turning <code>ReadBuf</code> itself into a reference type (and thus only having 1 type) wouldn't work well?</p>",
        "id": 209755608,
        "sender_full_name": "RalfJ",
        "timestamp": 1599814683
    },
    {
        "content": "<p>I don't think we easily can, since it needs to store the initialized filled counts in addition to the slice</p>",
        "id": 209766916,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599822430
    },
    {
        "content": "<p>that could be a private inner type that it points to though?</p>",
        "id": 209768326,
        "sender_full_name": "RalfJ",
        "timestamp": 1599823454
    },
    {
        "content": "<p>A type that references these fields should work. Then you still have a single lifetime. And overwriting the struct with a different buffer is benign. Then grab the result from the original fields. So</p>\n<div class=\"codehilite\"><pre><span></span><code>struct ReadBuf&lt;&#39;buf&gt; {\n    inner: &amp;&#39;buf mut [MaybeUninit&lt;u8&gt;],\n    filled: &amp;&#39;buf mut usize,\n    initialized: &amp;&#39;buf mut usize,\n};\n</code></pre></div>",
        "id": 209769036,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599824000
    },
    {
        "content": "<p>That's what one of the types would look like, but where are those filled and initialized pointers pointing without a second type?</p>",
        "id": 209777514,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599829399
    },
    {
        "content": "<p>Somewhere in the caller's stack, potentially. For the purpose of a  wrapper that provides safe access and can constructed from a <code>[MaybeUnint&lt;u8&gt;]</code>, yes, you would need a second struct. The main difference is that this second struct is never exposed to the callee.</p>",
        "id": 209777970,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599829640
    },
    {
        "content": "<p>Oh yeah that's what the proposal would look like. The reference type is passed by value into <code>read_buf</code>.</p>",
        "id": 209779558,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599830478
    },
    {
        "content": "<p>Any naming considerations? I would keep <code>ReadBuf</code> for the argument type honestly. And rather introduce a new name for the second typically hidden type, something like <code>ReadVec</code>paralleling io_vec and clarifying that it temporarily owns something.. Just my 2</p>",
        "id": 209780097,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599830770
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> I was thinking more of <code>struct ReadBuf&lt;'buf&gt;(&amp;'buf mut ReadBufInner)</code>, with <code>ReadBufInner</code> being a private type defined like the RFC's <code>ReadBuf</code></p>",
        "id": 209786063,
        "sender_full_name": "RalfJ",
        "timestamp": 1599833890
    },
    {
        "content": "<p>but maybe it cannot be private</p>",
        "id": 209786146,
        "sender_full_name": "RalfJ",
        "timestamp": 1599833926
    },
    {
        "content": "<p>Yeah, since you need to be able to stick a ReadBufInner on the stack of the caller</p>",
        "id": 209786170,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599833940
    },
    {
        "content": "<p>We could maybe use one type with an enum type for the filled and initialized counts to allow them to be either by value or by reference?</p>",
        "id": 209786222,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599833965
    },
    {
        "content": "<p><code>enum MaybeRef&lt;'a, T&gt; { Value(T), Ref(&amp;'a mut T), } struct ReadBuf&lt;'a&gt; { buf: &amp;'a mut [MaybeUninit&lt;u8&gt;], filled: MaybeRef&lt;'a, usize&gt;, initialized: MaybeRef&lt;'a, usize&gt; }</code>?</p>",
        "id": 209786361,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599834016
    },
    {
        "content": "<p>You can't move <code>initialized</code> to the callee. How would you ensure that you get the value back afterwards?</p>",
        "id": 209786526,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599834097
    },
    {
        "content": "<p>Doesn't <code>ReadBuf&lt;'buf&gt;(&amp;'buf mut Inner)</code> have the problem that <code>Inner</code> stores a <code>&amp;mut [MaybeUninit&lt;u8&gt;]</code> and thus has as second lifetime?  Well, coercion would probably shorten it behind the reference. Yeah, that might be better.</p>",
        "id": 209786919,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599834269
    },
    {
        "content": "<p>It wouldn't move into the callee - you'd construct a readbuf that stores a reference for the filled and initialized fields that refer to the root readbuf</p>",
        "id": 209788103,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599834766
    },
    {
        "content": "<p>I see, you want to use the same type for both representations and sides of the function call. That's clever.</p>",
        "id": 209788661,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599835040
    },
    {
        "content": "<p>Shouldn't <code>filled</code> and <code>initialized</code> have the same type for <code>MaybeRef</code>? Would it be useful for one to be <code>Value</code> and the other one to be <code>Ref</code>?</p>",
        "id": 209800412,
        "sender_full_name": "pickfire",
        "timestamp": 1599840332
    },
    {
        "content": "<p>sure they could be in a single enum</p>",
        "id": 209800997,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599840587
    },
    {
        "content": "<p>Doesn't <code>MaybeRef</code> sounds like <code>Cow</code>? Or the difference is only the <code>&amp;'mut T</code>?</p>",
        "id": 209801208,
        "sender_full_name": "pickfire",
        "timestamp": 1599840690
    },
    {
        "content": "<p>If anything, a <code>Cow&lt;'_, Cell&lt;_&gt;&gt;</code> could be possible in this case but that's hardly optimal.</p>",
        "id": 209801391,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599840759
    },
    {
        "content": "<p>Or maybe we could have a new type, <code>CowMut&lt;'a, B&gt;</code>? Difference being <code>Borrowed(&amp;'a mut B)</code> rather than <code>Borrowed(&amp;'a B)</code>. Not sure if it's useful.</p>",
        "id": 209801478,
        "sender_full_name": "pickfire",
        "timestamp": 1599840807
    },
    {
        "content": "<p>It doesn't need to be exposed, it could stay an implementation detail. The exposed interface would be</p>\n<blockquote>\n<p><code>fn as_mut(&amp;mut self) -&gt; ReadBuf&lt;'_&gt;</code> </p>\n</blockquote>\n<p>or something along those lines. Doing the matching and borrowing internally.</p>",
        "id": 209802027,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599841060
    },
    {
        "content": "<p>Cute, that would make it reasonably easy to forward toan inner reader and do some post-processing on the initialized portion.</p>",
        "id": 209802281,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599841165
    },
    {
        "content": "<p>At this point I'm tempted to just go with \"unsafe code should check that the <code>ReadBuf</code> still points to the same buffer\" in the docs.</p>",
        "id": 209803166,
        "sender_full_name": "Amanieu",
        "timestamp": 1599841576
    },
    {
        "content": "<p>Safe code doesn't need to worry about this since it safely accesses the read data via methods on the <code>ReadBuf</code> and never touches the original buffer.</p>",
        "id": 209803294,
        "sender_full_name": "Amanieu",
        "timestamp": 1599841643
    },
    {
        "content": "<p>I'm a bit worried too much unsafe code will forget to do that. It's an easy thing to miss during review.</p>",
        "id": 209819135,
        "sender_full_name": "RalfJ",
        "timestamp": 1599849628
    },
    {
        "content": "<p>That's my worry as well. I didn't notice it for quite a while myself!</p>",
        "id": 209820273,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1599850253
    },
    {
        "content": "<p>The methods to turn it into an initialized buffer could take an 'expected buffer' argument as well to avoid this mistake.<br>\nBut that feels less ergonomic? However it only affects buffers so it may be fine</p>",
        "id": 209820574,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599850427
    }
]