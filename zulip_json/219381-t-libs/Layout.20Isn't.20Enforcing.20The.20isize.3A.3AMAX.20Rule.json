[
    {
        "content": "<p><a href=\"https://twitter.com/eddyb_r/status/1486881336099024900\">https://twitter.com/eddyb_r/status/1486881336099024900</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/eddyb_r/status/1486881336099024900\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/dc31d1183786da189edd2bbfd54d1909bfff6348/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313239313534353934383332323232363137382f7472416d494174395f6e6f726d616c2e6a7067\"></a><p>waking up today: confused about <a href=\"https://twitter.com/rustlang\">@rustlang</a> alloc sizes/ptr offsets vs isize::MAX, docs are inconsistent (Layout/GlobalAlloc don't mention size limits)\n\njust now: first #[global_allocator] crate I try causes UB in a stable Rc&lt;[T]&gt; API\n\nwg-allocators should've accounted for this IMO <a href=\"https://t.co/eRnG4Uk3dX\">https://twitter.com/eddyb_r/status/1486881336099024900/photo/1</a></p><span>- ᵉᵈᵈʸᵇ (@eddyb_r)</span><div class=\"twitter-image\"><a href=\"https://t.co/eRnG4Uk3dX\"><img src=\"https://uploads.zulipusercontent.net/24706a759852c4eace64ba9900ef63d0a4002170/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f464b4a3077464258494149466735362e6a70673a6c61726765\"></a></div></div></div><p>Apparently people actually use Layout now and trust its output so now no one checks the isize::MAX rule in their own code (above tweet shows the <code>Rc&lt;[T]&gt;</code> allocation code is busted because of this!)</p>",
        "id": 276394411,
        "sender_full_name": "Gankra",
        "timestamp": 1648066904
    },
    {
        "content": "<p>via eddyb:</p>\n<p>Cargo.toml:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mi\">123456789</span><span class=\"p\">[</span><span class=\"n\">package</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"badlloc32\"</span><span class=\"w\"></span>\n<span class=\"n\">version</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"0.1.0\"</span><span class=\"w\"></span>\n<span class=\"n\">edition</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"2021\"</span><span class=\"w\"></span>\n\n#<span class=\"w\"> </span><span class=\"n\">See</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">keys</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">their</span><span class=\"w\"> </span><span class=\"n\">definitions</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">https</span>:<span class=\"c1\">//doc.rust-lang.org/cargo/reference/manifest.html</span>\n\n<span class=\"p\">[</span><span class=\"n\">dependencies</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">wee_alloc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"0.4.5\"</span><span class=\"w\"></span>\n</code></pre></div>\n<p>src/main/rs</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[global_allocator]</span><span class=\"w\"></span>\n<span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">ALLOC</span>: <span class=\"nc\">wee_alloc</span>::<span class=\"n\">WeeAlloc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">wee_alloc</span>::<span class=\"n\">WeeAlloc</span>::<span class=\"n\">INIT</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">sz</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0x9000_0000</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"attempting to allocate {:#x} ({:?} than isize::MAX = {:#x})\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sz</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sz</span><span class=\"p\">.</span><span class=\"n\">cmp</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)),</span><span class=\"w\"> </span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">sz</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">_</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">()).</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">_</span><span class=\"p\">]</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">sz</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"success! rc.len() = {:#x}, rc.iter().next() = {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">rc</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"n\">sz</span><span class=\"p\">].</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">next</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">first</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"c1\">// unsafe { first.add(sz - 1) };</span>\n<span class=\"w\">               </span><span class=\"n\">rc</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"n\">sz</span><span class=\"p\">].</span><span class=\"n\">last</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"first = {:?} {:?} than last = {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">first</span><span class=\"p\">.</span><span class=\"n\">cmp</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">last</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">last</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>run w/ cargo run --release --target i686-unknown-linux-gnu</p>",
        "id": 276395249,
        "sender_full_name": "Gankra",
        "timestamp": 1648067253
    },
    {
        "content": "<p>Should Layout enforce the <code>isize::MAX</code> rule? There are some corner cases where it may be needed if I'm not mistaken, e.g. memory mapping <code>usize::MAX</code> bytes on 32-bit systems that have physical address extension - people might do fun stuff as writing their own mmap allocator :P I would expect checking for <code>isize::MAX</code> is the responsibility of the implementation that makes the assumption about the pointer to the allocation, not that of Layout (note that the <code>Allocator</code> trait also has no clause in its safety contract about the maximum size of allocations, it just returns a <code>NonNull</code> pointer, which also can be larger than <code>isize::MAX</code> bytes).</p>",
        "id": 276399014,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648068942
    },
    {
        "content": "<p>best i can remember, allocations can't be more than <code>isize</code> big because of llvm limits (pointer offsets are signed, and in bytes), so it doesn't matter how you got your slice more than isize bytes large, it's not gonna work properly.</p>",
        "id": 276399485,
        "sender_full_name": "Lokathor",
        "timestamp": 1648069145
    },
    {
        "content": "<p>Hmm, I guess you can call wrapping_offset() twice?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"p\">).</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276400059,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648069346
    },
    {
        "content": "<p>Yeah C says you can't acctually offset more than isize::MAX and mandates you do two offsets to cross a large allocation, and then every compiler backend hardcoded that rule so no one can just use usize offsets and be happy, so we collectively said \"this is garbage\" and just mandated that you can't have allocations larger than isize::MAX</p>",
        "id": 276400670,
        "sender_full_name": "Gankra",
        "timestamp": 1648069643
    },
    {
        "content": "<p>Actually, once should work too:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"p\">).</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">offset_ptr2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">wrapping_add</span><span class=\"p\">(</span><span class=\"n\">offset</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// cast to `isize` internally, which does a negative offset instead</span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">core</span>::<span class=\"n\">ptr</span>::<span class=\"n\">eq</span><span class=\"p\">(</span><span class=\"n\">offset_ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">offset_ptr2</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276400807,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648069692
    },
    {
        "content": "<p>rust almost never uses wrapping_add, so that's irrelevant</p>",
        "id": 276400851,
        "sender_full_name": "Gankra",
        "timestamp": 1648069719
    },
    {
        "content": "<p>like if you take a slice to that allocation you will get UB</p>",
        "id": 276400863,
        "sender_full_name": "Gankra",
        "timestamp": 1648069729
    },
    {
        "content": "<p>and just generally, if you hand that allocation to anyone, including any reasonable person doing C, they will do an UB</p>",
        "id": 276401055,
        "sender_full_name": "Gankra",
        "timestamp": 1648069838
    },
    {
        "content": "<p>I guess it's just handy for when you want to take a subslice near the end of a <code>usize::MAX</code> slice pointer, for which the subslice itself is less than or equal to <code>isize::MAX</code> bytes long, then it can do useful stuff with the subslice.</p>",
        "id": 276401078,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648069854
    },
    {
        "content": "<p>yes that I fully agree hehe</p>",
        "id": 276401118,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648069876
    },
    {
        "content": "<p>Even if the slice len is limited to isize::MAX you can still get a larger allocation by stuffing it into a custom DST with the slice as tail, e.g. RcBox. And that won't immediately cause UB, I think.</p>",
        "id": 276401780,
        "sender_full_name": "The 8472",
        "timestamp": 1648070203
    },
    {
        "content": "<p>So it makes sense for Layout to allow larger types</p>",
        "id": 276401889,
        "sender_full_name": "The 8472",
        "timestamp": 1648070267
    },
    {
        "content": "<p>Back in the 00s there was was a time when people used PAE to stuff extra RAM into their 32-bit workstations. From what I've heard, programs kept crashing a lot but eventually the management listened to people telling to migrate to 64-bit XP.</p>",
        "id": 276401931,
        "sender_full_name": "Bot+",
        "timestamp": 1648070283
    },
    {
        "content": "<p>In the case of the interesting example here I think the check for <code>isize::MAX</code> bytes should go here: <a href=\"https://doc.rust-lang.org/src/alloc/rc.rs.html#1986-2011\">https://doc.rust-lang.org/src/alloc/rc.rs.html#1986-2011</a> It is missing currently.</p>",
        "id": 276401988,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648070301
    },
    {
        "content": "<p>yeah like, you can make a machine give you a Huge alloc but it's just a really bad idea, programming languages do not support it</p>",
        "id": 276402095,
        "sender_full_name": "Gankra",
        "timestamp": 1648070371
    },
    {
        "content": "<p>This is screamed at the top of its lungs in many places in std and the nomicon</p>",
        "id": 276402144,
        "sender_full_name": "Gankra",
        "timestamp": 1648070393
    },
    {
        "content": "<p>Like I am not going to stop you from doing evil stuff but std should absolutely refuse to let this happen</p>",
        "id": 276402467,
        "sender_full_name": "Gankra",
        "timestamp": 1648070554
    },
    {
        "content": "<p>which is to say Layout should prevent this from happening</p>",
        "id": 276404271,
        "sender_full_name": "Gankra",
        "timestamp": 1648071522
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276401988\">said</a>:</p>\n<blockquote>\n<p>In the case of the interesting example here I think the check for <code>isize::MAX</code> bytes should go here: <a href=\"https://doc.rust-lang.org/src/alloc/rc.rs.html#1986-2011\">https://doc.rust-lang.org/src/alloc/rc.rs.html#1986-2011</a> It is missing currently.</p>\n</blockquote>\n<p>I'll make a PR for that</p>",
        "id": 276404360,
        "sender_full_name": "The 8472",
        "timestamp": 1648071572
    },
    {
        "content": "<p>From a soundness point-of-view, should stdlib check for <code>isize::MAX</code> when collecting an iterator? Or is the iterator then considered unsound if it yields more than <code>isize::MAX</code> elements?</p>",
        "id": 276404401,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648071602
    },
    {
        "content": "<p>That's a specialization, the default impl goes through Vec which already has those checks.</p>",
        "id": 276404474,
        "sender_full_name": "The 8472",
        "timestamp": 1648071642
    },
    {
        "content": "<p>Layout/Allocator are also places where it can be caught, but it is not airtight, people could still mmap <code>usize::MAX</code> bytes and create an iterator from that (carefully, so that it doesn't take a slice to the whole memory space)</p>",
        "id": 276404495,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648071653
    },
    {
        "content": "<p>Ah nice, thanks <span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> !</p>",
        "id": 276404606,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648071721
    },
    {
        "content": "<p>mmap is going to libc, we can't sandbox the OS from having bad APIs</p>",
        "id": 276404657,
        "sender_full_name": "Gankra",
        "timestamp": 1648071736
    },
    {
        "content": "<p>Could you take look at try_reserve too. As I mentioned in <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/vec.20max.20length/near/276392353\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/vec.20max.20length/near/276392353</a> it does not return CapacityOverflow as often as it should.</p>",
        "id": 276404893,
        "sender_full_name": "Bot+",
        "timestamp": 1648071876
    },
    {
        "content": "<p>out of curiousity, what is the usecase of distinguishing the different error cases?</p>",
        "id": 276405229,
        "sender_full_name": "Gankra",
        "timestamp": 1648072064
    },
    {
        "content": "<p>I think that should be a separate issue since it's seems to be less of a safety issue compared to the (A)Rc specializations.</p>",
        "id": 276405394,
        "sender_full_name": "The 8472",
        "timestamp": 1648072159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276405229\">said</a>:</p>\n<blockquote>\n<p>out of curiousity, what is the usecase of distinguishing the different error cases?</p>\n</blockquote>\n<p>For my code CapacityOverflow would mean there is either bad case of bitrot that demands a system reboot, or presence of a serious mem safety issues. AllocError should mean \"experiencing high memory pressure, please try again later\"</p>\n<p>I'm also hoping for a minor early return performance wins.</p>",
        "id": 276406591,
        "sender_full_name": "Bot+",
        "timestamp": 1648072840
    },
    {
        "content": "<p>does Vec actually guarantee that it will yield one or the other?</p>",
        "id": 276406700,
        "sender_full_name": "Gankra",
        "timestamp": 1648072885
    },
    {
        "content": "<p>that seems... needlessly restrictive on the implementation</p>",
        "id": 276406721,
        "sender_full_name": "Gankra",
        "timestamp": 1648072896
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/95252\">#95252</a> for the (A)Rc issue</p>",
        "id": 276408546,
        "sender_full_name": "The 8472",
        "timestamp": 1648073843
    },
    {
        "content": "<p><code>*const [T]</code> has <code>get_unchecked()</code> and  <code>as_uninit_slice()</code>. The latter warns about <code>isize::MAX</code> and the other doesn't. If I were foolish enough to reason about negative space I could come to the wrong conclusion here.</p>",
        "id": 276409923,
        "sender_full_name": "The 8472",
        "timestamp": 1648074420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276404401\">said</a>:</p>\n<blockquote>\n<p>From a soundness point-of-view, should stdlib check for <code>isize::MAX</code> when collecting an iterator? Or is the iterator then considered unsound if it yields more than <code>isize::MAX</code> elements?</p>\n</blockquote>\n<p>An iterator can return infinite things; that's fine -- see <code>std::iter::repeat(0)</code>.</p>\n<p>The <code>collect</code> (well, <code>from_iter</code>) implementation has to handle it, but that it easily does because <code>reserve</code> and/or <code>push</code> will do the right thing.</p>",
        "id": 276409982,
        "sender_full_name": "scottmcm",
        "timestamp": 1648074453
    },
    {
        "content": "<p>Taken together with <code>Allocator</code> returning <code>NonNull&lt;[u8]&gt;</code> this hides the fact that ptr::add gets used.</p>",
        "id": 276410034,
        "sender_full_name": "The 8472",
        "timestamp": 1648074480
    },
    {
        "content": "<p>the isize::MAX rule is a global rule of the language</p>",
        "id": 276410136,
        "sender_full_name": "Gankra",
        "timestamp": 1648074533
    },
    {
        "content": "<p>For slices? Or for any allocation at all?</p>",
        "id": 276410357,
        "sender_full_name": "The 8472",
        "timestamp": 1648074657
    },
    {
        "content": "<p>we have always said allocation</p>",
        "id": 276410617,
        "sender_full_name": "Gankra",
        "timestamp": 1648074824
    },
    {
        "content": "<p>like, we cannot Stop You but everything in Rust will assume it does not happen and you will very quickly hit practical UB</p>",
        "id": 276410693,
        "sender_full_name": "Gankra",
        "timestamp": 1648074855
    },
    {
        "content": "<p>I think that's more a library rule than a language rule. Like I said earlier, <code>RcBox</code> can grow slightly larger than isize::MAX and I think it's still safe even when it does that because it goes from *RcBox-&gt;T-&gt;T[i] so that's two separate offsets.</p>",
        "id": 276410881,
        "sender_full_name": "The 8472",
        "timestamp": 1648074969
    },
    {
        "content": "<p>if <em>std</em> ever does it it's a bug and should be reported and fixed</p>",
        "id": 276410934,
        "sender_full_name": "Gankra",
        "timestamp": 1648075010
    },
    {
        "content": "<p>Absolutely</p>",
        "id": 276410947,
        "sender_full_name": "The 8472",
        "timestamp": 1648075019
    },
    {
        "content": "<p>Layout and Allocator are lower-level though. They must be able to construct that RcBox for example.</p>",
        "id": 276411029,
        "sender_full_name": "The 8472",
        "timestamp": 1648075073
    },
    {
        "content": "<p>n-no they must not</p>",
        "id": 276411082,
        "sender_full_name": "Gankra",
        "timestamp": 1648075085
    },
    {
        "content": "<p>What if you have a [u8; isize::MAX] and put that into an Rc? Should that fail?</p>",
        "id": 276411119,
        "sender_full_name": "The 8472",
        "timestamp": 1648075112
    },
    {
        "content": "<p>you cannot have that</p>",
        "id": 276411136,
        "sender_full_name": "Gankra",
        "timestamp": 1648075120
    },
    {
        "content": "<p>oh sorry, misread</p>",
        "id": 276411147,
        "sender_full_name": "Gankra",
        "timestamp": 1648075129
    },
    {
        "content": "<p>yes it should fail</p>",
        "id": 276411150,
        "sender_full_name": "Gankra",
        "timestamp": 1648075133
    },
    {
        "content": "<p>Hrm. I'm not immediately seeing any unsafety from it because it's a private type and you can't do any pointer arithmetic on it.</p>",
        "id": 276411214,
        "sender_full_name": "The 8472",
        "timestamp": 1648075192
    },
    {
        "content": "<p>so you would like a compilation model where the compiler is never free to combine offsets into one larger offset?</p>",
        "id": 276411690,
        "sender_full_name": "Gankra",
        "timestamp": 1648075390
    },
    {
        "content": "<p>these situations are chaos, they aren't worth supporting</p>",
        "id": 276411752,
        "sender_full_name": "Gankra",
        "timestamp": 1648075438
    },
    {
        "content": "<p>Does CI have a 32-bit runner testing out all these quirky edge cases and OOM interactions?</p>",
        "id": 276412102,
        "sender_full_name": "Bot+",
        "timestamp": 1648075665
    },
    {
        "content": "<blockquote>\n<p>so you would like a compilation model where the compiler is never free to combine offsets into one larger offset?</p>\n</blockquote>\n<p>Do we have a language level rule though that allows this optimiztion?</p>",
        "id": 276412490,
        "sender_full_name": "The 8472",
        "timestamp": 1648075880
    },
    {
        "content": "<p>alright i'm checking out, i'm not relitigating stuff from 2015</p>",
        "id": 276412597,
        "sender_full_name": "Gankra",
        "timestamp": 1648075961
    },
    {
        "content": "<p>I'm not trying to religitate, I'm just looking for the documentation that explicitly says this. Like pointer only says this in reference to individual ptr::add calls.</p>",
        "id": 276412763,
        "sender_full_name": "The 8472",
        "timestamp": 1648076068
    },
    {
        "content": "<p>E.g. <a href=\"https://doc.rust-lang.org/std/ptr/index.html#allocated-object\">https://doc.rust-lang.org/std/ptr/index.html#allocated-object</a> is silent on this.</p>",
        "id": 276412818,
        "sender_full_name": "The 8472",
        "timestamp": 1648076111
    },
    {
        "content": "<p>Look at ptr.offset and ptr.offset_from</p>",
        "id": 276412848,
        "sender_full_name": "Bot+",
        "timestamp": 1648076142
    },
    {
        "content": "<p>As I said</p>\n<blockquote>\n<p>Like pointer only says this in reference to individual ptr::add calls.</p>\n</blockquote>\n<p>That doesn't forbid chaining two ptr::add calls, I think? Which in turn means it's not a license for the compiler to merge offset calculations.</p>",
        "id": 276413036,
        "sender_full_name": "The 8472",
        "timestamp": 1648076270
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/reference/type-layout.html\">https://doc.rust-lang.org/reference/type-layout.html</a> doesn't say anything about isize::MAX either.<br>\nNeither do the UCG.</p>",
        "id": 276413108,
        "sender_full_name": "The 8472",
        "timestamp": 1648076297
    },
    {
        "content": "<p>If this is something LLVM relies on we need to improve the docs somewhere.</p>",
        "id": 276413139,
        "sender_full_name": "The 8472",
        "timestamp": 1648076332
    },
    {
        "content": "<p>Ah, it's in the scalars section of the UCG, not the struct layout.</p>\n<p><a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html\">https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html</a></p>",
        "id": 276413879,
        "sender_full_name": "The 8472",
        "timestamp": 1648076716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276411119\">said</a>:</p>\n<blockquote>\n<p>What if you have a [u8; isize::MAX] and put that into an Rc? Should that fail?</p>\n</blockquote>\n<p>If you try <code>Rc::new</code>, that array value takes half your memory already (on the stack!), leaving no room for a heap allocation.</p>",
        "id": 276415146,
        "sender_full_name": "cuviper",
        "timestamp": 1648077533
    },
    {
        "content": "<p><code>Rc::new_uninit</code> can't do it either:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: values of the type `rc::RcBox&lt;MaybeUninit&lt;[u8; 2147483647]&gt;&gt;` are too big for the current architecture\n</code></pre></div>",
        "id": 276415173,
        "sender_full_name": "cuviper",
        "timestamp": 1648077558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276410357\">said</a>:</p>\n<blockquote>\n<p>For slices? Or for any allocation at all?</p>\n</blockquote>\n<p>For any allocation at all, because <code>array::as_ref</code> (and thus <code>slice::as_ref</code>) allow turning any object into a slice in any safe code.</p>",
        "id": 276415378,
        "sender_full_name": "scottmcm",
        "timestamp": 1648077693
    },
    {
        "content": "<p>even if you get it past rustc, glibc malloc will refuse to allocate more than <code>PTRDIFF_MAX</code> (since 2.30)</p>",
        "id": 276415794,
        "sender_full_name": "cuviper",
        "timestamp": 1648077945
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">Memory</span><span class=\"w\"> </span><span class=\"n\">allocation</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"w\"> </span><span class=\"n\">malloc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">calloc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">realloc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">reallocarray</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">valloc</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">pvalloc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">memalign</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">posix_memalign</span><span class=\"w\"> </span><span class=\"n\">fail</span><span class=\"w\"> </span><span class=\"n\">now</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"n\">total</span><span class=\"w\"> </span><span class=\"n\">object</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">larger</span><span class=\"w\"> </span><span class=\"n\">than</span><span class=\"w\"> </span><span class=\"n\">PTRDIFF_MAX</span><span class=\"p\">.</span><span class=\"w\">  </span><span class=\"n\">This</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">avoid</span><span class=\"w\"> </span><span class=\"n\">potential</span><span class=\"w\"> </span><span class=\"n\">undefined</span><span class=\"w\"> </span><span class=\"n\">behavior</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">pointer</span><span class=\"w\"> </span><span class=\"n\">subtraction</span><span class=\"w\"> </span><span class=\"n\">within</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">allocated</span><span class=\"w\"> </span><span class=\"n\">object</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">results</span><span class=\"w\"> </span><span class=\"n\">might</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">overflow</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">ptrdiff_t</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276415805,
        "sender_full_name": "cuviper",
        "timestamp": 1648077956
    },
    {
        "content": "<p>looks like jemalloc also limits this since 4.1</p>",
        "id": 276415987,
        "sender_full_name": "cuviper",
        "timestamp": 1648078088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276413879\">said</a>:</p>\n<blockquote>\n<p>Ah, it's in the scalars section of the UCG, not the struct layout.</p>\n<p><a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html\">https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html</a></p>\n</blockquote>\n<blockquote>\n<p>Note: in the current Rust implementation, the layouts of isize and usize determine the following:</p>\n<ul>\n<li>\n<p>the maximum size of Rust allocations is limited to isize::MAX. The LLVM getelementptr instruction uses signed-integer field offsets. Rust calls getelementptr with the inbounds flag which assumes that field offsets do not overflow,</p>\n</li>\n<li>\n<p>the maximum number of elements in an array is usize::MAX ([T; N: usize]). Only ZST arrays can probably be this large in practice, non-ZST arrays are bound by the maximum size of Rust values,</p>\n</li>\n<li>\n<p>the maximum value in bytes by which a pointer can be offseted using ptr.add or ptr.offset is isize::MAX.</p>\n</li>\n</ul>\n<p>These limits have not gone through the RFC process and are not guaranteed to hold.</p>\n</blockquote>\n<p>Interesting. These non-guaranteed claims do not seem to apply to the wrapping variants for pointer arithmetic as its phrased now. Also, what are \"Rust allocations\" exactly? e.g. do custom <code>Allocator</code> trait implementations in Rust also yield \"Rust allocations\", or does this only include allocators shipped with <code>alloc</code>/stdlib?</p>",
        "id": 276467141,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648124612
    },
    {
        "content": "<p>any individual variable, including all stack variables that aren't explicitly \"allocated\" via an allocator, are all \"allocations\".</p>",
        "id": 276490704,
        "sender_full_name": "Lokathor",
        "timestamp": 1648135083
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// this is \"an allocation\"</span>\n</code></pre></div>",
        "id": 276490924,
        "sender_full_name": "Lokathor",
        "timestamp": 1648135192
    },
    {
        "content": "<p>These \"allocations\" are what you'll see in the LLVM docs as an \"allocated object\":</p>\n<blockquote>\n<p>These rules are based on the assumption that no allocated object may cross the unsigned address space boundary, and no allocated object may be larger than half the pointer index type space.<br>\n~ <a href=\"https://llvm.org/docs/LangRef.html#getelementptr-instruction\">https://llvm.org/docs/LangRef.html#getelementptr-instruction</a></p>\n</blockquote>\n<p>It's an open question, AFAIK, whether you can split things into different \"allocations\" yourself (for example what all this means if you're writing an allocator).  But at the very least locals (LLVM <code>alloca</code>), statics (LLVM <a href=\"https://llvm.org/docs/LangRef.html#getelementptr-instruction\"><code>global</code></a>), and the rust allocation functions <a href=\"https://github.com/rust-lang/llvm-project/commit/59b1d748157ddce5f701dfcaa4fae9a553fc9775\">that we tell LLVM about</a> create \"allocations\".</p>",
        "id": 276492625,
        "sender_full_name": "scottmcm",
        "timestamp": 1648135898
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 276493922,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648136392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276415173\">said</a>:</p>\n<blockquote>\n<p><code>Rc::new_uninit</code> can't do it either:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: values of the type `rc::RcBox&lt;MaybeUninit&lt;[u8; 2147483647]&gt;&gt;` are too big for the current architecture\n</code></pre></div>\n\n</blockquote>\n<p>I have found that at least <code>Rc::new_uninit_slice</code> is also affected.</p>",
        "id": 276547873,
        "sender_full_name": "The 8472",
        "timestamp": 1648161108
    },
    {
        "content": "<p>ah, that will compile, but fails the allocation at runtime</p>",
        "id": 276555008,
        "sender_full_name": "cuviper",
        "timestamp": 1648166268
    },
    {
        "content": "<p>I filed <a href=\"https://github.com/rust-lang/rust/pull/95295\">https://github.com/rust-lang/rust/pull/95295</a> to fix this in <code>Layout</code>; the changes are fairly minimal, just changing the limit from <code>usize::MAX</code> to <code>isize::MAX</code> and changing checked math from being done in <code>usize</code> space to <code>isize</code> space.</p>",
        "id": 276577299,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648185019
    },
    {
        "content": "<p>Note that this doesn't \"refuse to enable [layouts sized greater than isize::MAX]\", as <code>from_size_align_unchecked</code> is still truly unchecked. However, code doing such is already suspect.</p>",
        "id": 276577446,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648185251
    },
    {
        "content": "<p>I wonder if it'd be worth making a non-exposed type that only allows for <code>0..=isize::MAX</code>, as that way MIRI will automatically catch violations of this.</p>\n<p>Should be pretty easy, just a newtype with a pointer-width-cfg_attr'd <code>rustc_layout_scalar_valid_range_end</code>s and a few more <code>.0</code>s.</p>",
        "id": 276577772,
        "sender_full_name": "scottmcm",
        "timestamp": 1648185670
    },
    {
        "content": "<p>Doing a quick search over the rustc repo, it looks like <code>GlobalAlloc::realloc</code> (and the free fn version) doesn't require <code>new_size &lt;= isize::MAX</code>, but all other allocation APIs go through <code>Layout</code>.</p>",
        "id": 276577858,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648185754
    },
    {
        "content": "<p>I suspect that's just an oversight, not an intentional freedom.</p>",
        "id": 276577912,
        "sender_full_name": "scottmcm",
        "timestamp": 1648185842
    },
    {
        "content": "<p>Also interesting: PR fails some collections tests due to changing <code>Err(CapacityOverflow)</code> to <code>Err(AllocError { .. })</code>.</p>",
        "id": 276577969,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648185925
    },
    {
        "content": "<p>Specifically, the <code>try_reserve</code> tests are <code>try_reserve</code>ing <code>isize::MAX + 1</code> to test that <code>try_reserve</code> treats it as a capacity overflow</p>",
        "id": 276578052,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648186023
    },
    {
        "content": "<p>If I'm reading <a href=\"https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/library/alloc/src/raw_vec.rs#L494-L510\">https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/library/alloc/src/raw_vec.rs#L494-L510</a> right, raw_vec is deliberately breaking the alloc size &lt;= <code>isize::MAX</code> rule (on 64+ bit platforms) and just relying on the underlying allocation API failing</p>",
        "id": 276578234,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648186245
    },
    {
        "content": "<p>In (one of the) failing test(s): <a href=\"https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/library/alloc/tests/string.rs#L696-L699\">https://github.com/rust-lang/rust/blob/661e8beec1fa5f3c58bf6e4362ae3c3fe0b4b1bd/library/alloc/tests/string.rs#L696-L699</a></p>\n<blockquote>\n<p>On 16/32-bit, we check that allocations don't exceed isize::MAX, on 64-bit, we assume the OS will give an OOM for such a ridiculous size. Any platform that succeeds for these requests is technically broken with ptr::offset because LLVM is the worst.</p>\n</blockquote>",
        "id": 276578436,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648186504
    },
    {
        "content": "<p>Wait, I was a bit confused; those tests are testing that they get <code>AllocError</code> (on 64+ bit platforms) but now provide <code>CapacityOverflow</code> (like &lt;64 bit platforms), not the other way around.</p>",
        "id": 276578866,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648187064
    },
    {
        "content": "<p><code>try_reserve</code> tests are currently disabled on miri because it doesn't support signalling OOM; now that we aren't checking for <code>AllocError</code> on 64 bit targets, these tests might be able to be run on miri? I didn't change that; I just changed them to always take the \"I'm checking <code>isize::MAX</code>\" path.</p>",
        "id": 276579597,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648187946
    },
    {
        "content": "<p>Are there any historic comments to be found somewhere about why the implementation of <code>Layout</code> allows <code>usize::MAX</code> in the first place instead of <code>isize::MAX</code>?</p>",
        "id": 276601026,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648204962
    },
    {
        "content": "<p>Hmm this is the only bread-crumb I could find so far that shows it was briefly considered before to already use <code>isize::MAX</code> from the start :)  <a href=\"https://github.com/rust-lang/rust/pull/42313#discussion_r119537741\">https://github.com/rust-lang/rust/pull/42313#discussion_r119537741</a> It did not materialize yet back in 2017 though.</p>",
        "id": 276602840,
        "sender_full_name": "Pointerbender",
        "timestamp": 1648206101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276601026\">said</a>:</p>\n<blockquote>\n<p>Are there any historic comments to be found somewhere about why the implementation of <code>Layout</code> allows <code>usize::MAX</code> in the first place instead of <code>isize::MAX</code>?</p>\n</blockquote>\n<p>it's not just Layout, a lot of the allocator APIs do <em>not</em> consider the size limit and my impression from wg-allocators is that is by design -- allocators <em>can</em> support large allocations and it's up to the user to get them right. I wasnt happy but from a purely formal perspective this is not wrong so I didnt want to interfere with the WG work.</p>",
        "id": 276695590,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255248
    },
    {
        "content": "<p>I can say that as my participation in wg-allocators was a) after <code>Layout</code> was originally designed and b) completely not thinking about the <code>isize::MAX</code> limitation</p>",
        "id": 276695637,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648255318
    },
    {
        "content": "<p>I think I remember an exchange about the <code>allocate</code> function imposing isize::MAX as a limit and there was pushback since allocators <em>could</em> support that if they wanted and users are careful, but maybe I am misremembering and anyway it's not worth digging into this</p>",
        "id": 276695717,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255427
    },
    {
        "content": "<p>the relevant point is that we have hard evidence that the current APIs are too easy to use wrong</p>",
        "id": 276695725,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255439
    },
    {
        "content": "<p>(wait that's a sentence fragment) that I'm in favor of just always applying the <code>isize::MAX</code>; the liballoc bug shows how overly onerous pushing the requirement onto consumers is</p>",
        "id": 276695777,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648255463
    },
    {
        "content": "<p>so looking at <a href=\"https://github.com/rust-lang/rust/pull/95252\">https://github.com/rust-lang/rust/pull/95252</a> I wonder where exactly a safety contract was broken. (unfortunately Miri cannot really run the UB examples as they require too much memory... maybe a 32bit target on a 64bit host would work, I'll have to try this locally). <code>allocate</code> is (supposed to be) fine with the big allocation so that's not it. I guess it must be when the actual wide ptr is constructed? certainly constructing the slice is bad but I think just having an <code>&amp;RcBox</code> whose size is too big is already UB -- no wide ptr must ever be so big that <code>size_of_val</code> would return more than <code>isize::MAX</code></p>",
        "id": 276695809,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255540
    },
    {
        "content": "<p>I am not sure what exactly Miri implements there though</p>",
        "id": 276695815,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255552
    },
    {
        "content": "<p>It's also worth noting that you had us specify <code>size_of_val_raw</code> to limit size to <code>isize::MAX</code> as well</p>",
        "id": 276695877,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648255613
    },
    {
        "content": "<p>the \"dangling pointers\" section at <a href=\"https://doc.rust-lang.org/reference/behavior-considered-undefined.html#dangling-pointers\">https://doc.rust-lang.org/reference/behavior-considered-undefined.html#dangling-pointers</a> could be clearer but I would read it as: any reference where size_of_val is too big is automatically dangling</p>",
        "id": 276695891,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255647
    },
    {
        "content": "<p>(side note)</p>\n<blockquote>\n<p>I wonder if it'd be worth making a non-exposed type that only allows for <code>0..=isize::MAX</code>, as that way MIRI will automatically catch violations of this.</p>\n<p>Should be pretty easy, just a newtype with a pointer-width-cfg_attr'd <code>rustc_layout_scalar_valid_range_end</code>s and a few more <code>.0</code>s.</p>\n</blockquote>\n<p>Even easier, actually, since it can store <code>isize</code> and <code>valid_range_start</code> 0. But I think it's better to keep that separate from fixing the allowed bounds; my PR makes it library UB to exceed that range and thus legal to add the restriction afterwards.</p>",
        "id": 276695894,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648255665
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276695877\">said</a>:</p>\n<blockquote>\n<p>It's also worth noting that you had us specify <code>size_of_val_raw</code> to limit size to <code>isize::MAX</code> as well</p>\n</blockquote>\n<p>ah yes it says</p>\n<blockquote>\n<p>the size of the entire value (dynamic tail length + statically sized prefix) must fit in isize.</p>\n</blockquote>\n<p>so that is pretty clear</p>",
        "id": 276695935,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255690
    },
    {
        "content": "<p>the reference should say something equivalent about validity for references</p>",
        "id": 276695941,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255702
    },
    {
        "content": "<p>Miri's implementation of size_of_val and friends indeed checks this: <a href=\"https://github.com/rust-lang/rust/blob/b92a60586a3f121592bded64a1556fae0f69c302/compiler/rustc_const_eval/src/interpret/eval_context.rs#L682\">https://github.com/rust-lang/rust/blob/b92a60586a3f121592bded64a1556fae0f69c302/compiler/rustc_const_eval/src/interpret/eval_context.rs#L682</a></p>",
        "id": 276696009,
        "sender_full_name": "RalfJ",
        "timestamp": 1648255825
    },
    {
        "content": "<p>so technically UB happens <a href=\"https://github.com/rust-lang/rust/blob/189e8c9231204aa6ba9ef9df04bdaee6b5eb93b0/library/alloc/src/rc.rs#L341\">here</a>, which I think is the first time a reference is created</p>",
        "id": 276696131,
        "sender_full_name": "RalfJ",
        "timestamp": 1648256004
    },
    {
        "content": "<p><code>Rc</code> stores a <code>NonNull</code> which <em>is</em> allowed to be \"too large\" but the <code>Rc</code> code has a (safety) invariant that it is not (since it wants to create that reference)</p>",
        "id": 276696187,
        "sender_full_name": "RalfJ",
        "timestamp": 1648256056
    },
    {
        "content": "<p>So to be explicit: would <code>Rc</code> be \"okay\" to allocate &gt;<code>isize::MAX</code> if (and only if) it always delt in <code>ptr::NonNull&lt;RcInner&lt;[T]&gt;&gt;</code>, <code>&amp;RcInner&lt;()&gt;</code>, and <code>&amp;[T]</code>, never creating <code>&amp;RcInner&lt;[T]&gt;</code>?<br>\nExcept no... it's also using <code>size_of_val_raw::&lt;RcInner&lt;[T]&gt;</code> to deallocate the place, so even with being that careful, it'd have to do shenanigans to recreate the too-large <code>Layout</code> as well.<br>\nI'm fairly convinced that the reasonable solution is to push this guarantee into <code>Layout</code> and just require that any \"Rust allocation\" is &lt;= <code>isize::MAX</code> bytes, but I'll leave the decision up to T-lang ofc</p>",
        "id": 276697396,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1648257636
    },
    {
        "content": "<p>@rfcbot fcp merge</p>",
        "id": 276697863,
        "sender_full_name": "scottmcm",
        "timestamp": 1648258294
    },
    {
        "content": "<blockquote>\n<p>I'm fairly convinced that the reasonable solution is to push this guarantee into Layout and just require that any \"Rust allocation\" is &lt;= isize::MAX bytes,</p>\n</blockquote>\n<p>Yeah that just seems a lot more robust. Even if we relaxed the rules you'd still be toast for just slightly larger slices once you actually create a <code>&amp;[T]</code> and someone indexes into it and the <code>offset</code> becomes too big...</p>",
        "id": 276701190,
        "sender_full_name": "RalfJ",
        "timestamp": 1648263093
    },
    {
        "content": "<p>well we can probably stop just short of that and say that any \"Rust type\"  is &lt;= isize::MAX bytes, including dynamically (via size_of_val[_raw])</p>",
        "id": 276701689,
        "sender_full_name": "RalfJ",
        "timestamp": 1648263887
    },
    {
        "content": "<p>and the default allocation methods help you ensure that</p>",
        "id": 276701691,
        "sender_full_name": "RalfJ",
        "timestamp": 1648263894
    },
    {
        "content": "<p>but if you got other allocation methods, only use raw pointers, and never try to capture the entire allocation in a single type -- then you can still try to have fun with &gt;2GB allocations on 32bit</p>",
        "id": 276701707,
        "sender_full_name": "RalfJ",
        "timestamp": 1648263938
    },
    {
        "content": "<p>so when can we replace mem::size_of with an API that returns an Option&lt;isize&gt; instead? :P</p>",
        "id": 276724833,
        "sender_full_name": "bstrie",
        "timestamp": 1648299437
    },
    {
        "content": "<p><code>size_of</code> fails with a post monomorphization error, so <code>Option</code> is not necessary <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 276725713,
        "sender_full_name": "oli",
        "timestamp": 1648300680
    },
    {
        "content": "<p>Make allocations work with <code>type asize = PositiveNonZeroIsize</code>?</p>",
        "id": 276725877,
        "sender_full_name": "Bot+",
        "timestamp": 1648300912
    },
    {
        "content": "<p>Thinking more about it, enforcing allocation size with the type system might not be just a joke.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Layout</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">size_</span>: <span class=\"nc\">asize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align_</span>: <span class=\"nc\">NonZeroUsize</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">core</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">const_allocate</span><span class=\"p\">(</span><span class=\"n\">size</span>: <span class=\"nc\">asize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Let the caller deal with size validation. <br>\nWould the breakage be manageable?</p>",
        "id": 276727177,
        "sender_full_name": "Bot+",
        "timestamp": 1648302739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276695941\">said</a>:</p>\n<blockquote>\n<p>the reference should say something equivalent about validity for references</p>\n</blockquote>\n<p><a href=\"https://github.com/rust-lang/reference/pull/1186\">https://github.com/rust-lang/reference/pull/1186</a></p>",
        "id": 276727988,
        "sender_full_name": "RalfJ",
        "timestamp": 1648303864
    },
    {
        "content": "<p>and here is the UB Miri reports on a 32bit target:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span>: <span class=\"nc\">Undefined</span><span class=\"w\"> </span><span class=\"n\">Behavior</span>: <span class=\"nc\">invalid</span><span class=\"w\"> </span><span class=\"n\">metadata</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">wide</span><span class=\"w\"> </span><span class=\"n\">pointer</span>: <span class=\"nc\">slice</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">bigger</span><span class=\"w\"> </span><span class=\"n\">than</span><span class=\"w\"> </span><span class=\"n\">largest</span><span class=\"w\"> </span><span class=\"n\">supported</span><span class=\"w\"> </span><span class=\"n\">object</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">-</span>-&gt; <span class=\"o\">/</span><span class=\"n\">home</span><span class=\"o\">/</span><span class=\"n\">r</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"n\">rustup</span><span class=\"o\">/</span><span class=\"n\">toolchains</span><span class=\"o\">/</span><span class=\"n\">miri</span><span class=\"o\">/</span><span class=\"n\">lib</span><span class=\"o\">/</span><span class=\"n\">rustlib</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rust</span><span class=\"o\">/</span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">1326</span>:<span class=\"mi\">24</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">1326</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">             </span><span class=\"n\">ptr</span>::<span class=\"n\">write</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">inner</span><span class=\"p\">).</span><span class=\"n\">strong</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">|</span><span class=\"w\">                        </span><span class=\"o\">^^^^^^^^^^^^^^^^^^^^</span><span class=\"w\"> </span><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"n\">metadata</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">wide</span><span class=\"w\"> </span><span class=\"n\">pointer</span>: <span class=\"nc\">slice</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">bigger</span><span class=\"w\"> </span><span class=\"n\">than</span><span class=\"w\"> </span><span class=\"n\">largest</span><span class=\"w\"> </span><span class=\"n\">supported</span><span class=\"w\"> </span><span class=\"n\">object</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">help</span>: <span class=\"nc\">this</span><span class=\"w\"> </span><span class=\"n\">indicates</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">bug</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">program</span>: <span class=\"nc\">it</span><span class=\"w\"> </span><span class=\"n\">performed</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">invalid</span><span class=\"w\"> </span><span class=\"n\">operation</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">and</span><span class=\"w\"> </span><span class=\"n\">caused</span><span class=\"w\"> </span><span class=\"n\">Undefined</span><span class=\"w\"> </span><span class=\"n\">Behavior</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">help</span>: <span class=\"nc\">see</span><span class=\"w\"> </span><span class=\"n\">https</span>:<span class=\"c1\">//doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information</span>\n\n<span class=\"w\">     </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">inside</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">try_allocate_for_layout</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">closure</span><span class=\"o\">@</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">allocate_for_slice</span>::<span class=\"p\">{</span><span class=\"n\">closure</span>#<span class=\"mi\">0</span><span class=\"p\">}],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">closure</span><span class=\"o\">@</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">allocate_for_slice</span>::<span class=\"p\">{</span><span class=\"n\">closure</span>#<span class=\"mi\">1</span><span class=\"p\">}]</span><span class=\"o\">&gt;</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"n\">home</span><span class=\"o\">/</span><span class=\"n\">r</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"n\">rustup</span><span class=\"o\">/</span><span class=\"n\">toolchains</span><span class=\"o\">/</span><span class=\"n\">miri</span><span class=\"o\">/</span><span class=\"n\">lib</span><span class=\"o\">/</span><span class=\"n\">rustlib</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rust</span><span class=\"o\">/</span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">1326</span>:<span class=\"mi\">24</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">inside</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">allocate_for_layout</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">closure</span><span class=\"o\">@</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">allocate_for_slice</span>::<span class=\"p\">{</span><span class=\"n\">closure</span>#<span class=\"mi\">0</span><span class=\"p\">}],</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">closure</span><span class=\"o\">@</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">allocate_for_slice</span>::<span class=\"p\">{</span><span class=\"n\">closure</span>#<span class=\"mi\">1</span><span class=\"p\">}]</span><span class=\"o\">&gt;</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"n\">home</span><span class=\"o\">/</span><span class=\"n\">r</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"n\">rustup</span><span class=\"o\">/</span><span class=\"n\">toolchains</span><span class=\"o\">/</span><span class=\"n\">miri</span><span class=\"o\">/</span><span class=\"n\">lib</span><span class=\"o\">/</span><span class=\"n\">rustlib</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rust</span><span class=\"o\">/</span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">1295</span>:<span class=\"mi\">13</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">inside</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">allocate_for_slice</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"n\">home</span><span class=\"o\">/</span><span class=\"n\">r</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"n\">rustup</span><span class=\"o\">/</span><span class=\"n\">toolchains</span><span class=\"o\">/</span><span class=\"n\">miri</span><span class=\"o\">/</span><span class=\"n\">lib</span><span class=\"o\">/</span><span class=\"n\">rustlib</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rust</span><span class=\"o\">/</span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">1375</span>:<span class=\"mi\">13</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">inside</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">std</span>::<span class=\"n\">rc</span>::<span class=\"n\">Rc</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">new_uninit_slice</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"o\">/</span><span class=\"n\">home</span><span class=\"o\">/</span><span class=\"n\">r</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"n\">rustup</span><span class=\"o\">/</span><span class=\"n\">toolchains</span><span class=\"o\">/</span><span class=\"n\">miri</span><span class=\"o\">/</span><span class=\"n\">lib</span><span class=\"o\">/</span><span class=\"n\">rustlib</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rust</span><span class=\"o\">/</span><span class=\"n\">library</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"o\">/</span><span class=\"n\">src</span><span class=\"o\">/</span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">691</span>:<span class=\"mi\">31</span><span class=\"w\"></span>\n<span class=\"n\">note</span>: <span class=\"nc\">inside</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">main</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">5</span>:<span class=\"mi\">13</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">rc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">5</span>:<span class=\"mi\">13</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">5</span><span class=\"w\">    </span><span class=\"o\">|</span><span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Rc</span>::<span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">new_uninit_slice</span><span class=\"p\">(</span><span class=\"kt\">isize</span>::<span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"o\">|</span><span class=\"w\">             </span><span class=\"o\">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276728117,
        "sender_full_name": "RalfJ",
        "timestamp": 1648304051
    },
    {
        "content": "<p>that's at the <code>inner</code> which requires a non-dangling ptr (and a too large pointee always dangles)</p>",
        "id": 276728137,
        "sender_full_name": "RalfJ",
        "timestamp": 1648304099
    },
    {
        "content": "<blockquote>\n<p>dynamic size of a Rust value (as determined by <code>size_of_val</code>) must never exceed <code>isize::MAX</code>.</p>\n</blockquote>\n<p>Should <code>slice::len</code> have copy of this notice in plainer language for better visibility? \"For technical reasons slice/str/etc cannot be longer than isize::MAX bytes.\" with link to full explanation.</p>",
        "id": 276728292,
        "sender_full_name": "Bot+",
        "timestamp": 1648304327
    },
    {
        "content": "<blockquote>\n<p>Rc::&lt;[u8]&gt;::new_uninit_slice(isize::MAX as usize + 1);</p>\n</blockquote>\n<p>The +1 shouldn't be necessary, it should fail with a slice length of isize::MAX too. Technically that's due to an implementation detail but I don't see that changing anytime soon.</p>",
        "id": 276728489,
        "sender_full_name": "The 8472",
        "timestamp": 1648304599
    },
    {
        "content": "<p>also seems like we dont have an issue for this yet, so I created <a href=\"https://github.com/rust-lang/rust/issues/95334\">https://github.com/rust-lang/rust/issues/95334</a></p>",
        "id": 276728914,
        "sender_full_name": "RalfJ",
        "timestamp": 1648305226
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276728489\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Rc::&lt;[u8]&gt;::new_uninit_slice(isize::MAX as usize + 1);</p>\n</blockquote>\n<p>The +1 shouldn't be necessary, it should fail with a slice length of isize::MAX too. Technically that's due to an implementation detail but I don't see that changing anytime soon.</p>\n</blockquote>\n<p>yes agreed (and verified on Miri just before I saw your message^^)</p>",
        "id": 276728919,
        "sender_full_name": "RalfJ",
        "timestamp": 1648305236
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420380\">Bot+</span> <a href=\"#narrow/stream/219381-t-libs/topic/Layout.20Isn't.20Enforcing.20The.20isize.3A.3AMAX.20Rule/near/276728292\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>dynamic size of a Rust value (as determined by <code>size_of_val</code>) must never exceed <code>isize::MAX</code>.</p>\n</blockquote>\n<p>Should <code>slice::len</code> have copy of this notice in plainer language for better visibility? \"For technical reasons slice/str/etc cannot be longer than isize::MAX bytes.\" with link to full explanation.</p>\n</blockquote>\n<p><code>len</code> is safe so the caller shouldnt worry about it at that point. <code>slice::from_raw_parts</code> does have a notice like this.</p>",
        "id": 276728978,
        "sender_full_name": "RalfJ",
        "timestamp": 1648305286
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <br>\nIt would be purely educational and intednted for beginners who do not venture deep into docs.</p>\n<p>If I made a poll that asked whether <code>let x = [0u8; usize::MAX];</code> would compile I bet many would answer yes.</p>",
        "id": 276730011,
        "sender_full_name": "Bot+",
        "timestamp": 1648306813
    },
    {
        "content": "<p>yeah but the compiler will tell them no so that's okay</p>",
        "id": 276730403,
        "sender_full_name": "RalfJ",
        "timestamp": 1648307371
    },
    {
        "content": "<p>the general slice docs might be a good place to mention this, maybe -- but putting it on any specific (safe) slice method seems odd to me</p>",
        "id": 276730416,
        "sender_full_name": "RalfJ",
        "timestamp": 1648307396
    },
    {
        "content": "<p>if people usually think it works and the compiler is the only one who knows otherwise that's still quite unfortunate</p>",
        "id": 276730472,
        "sender_full_name": "Lokathor",
        "timestamp": 1648307469
    },
    {
        "content": "<p>Well, inspired by this thread I made a PR <a href=\"https://github.com/rust-lang/rust/issues/95361\">#95361</a> so that UB alignments can also be caught:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">E0080</span><span class=\"p\">]</span>: <span class=\"nc\">it</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">undefined</span><span class=\"w\"> </span><span class=\"n\">behavior</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"cp\">$DIR</span><span class=\"o\">/</span><span class=\"n\">alloc</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">13</span>:<span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"n\">LL</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LAYOUT_INVALID_THREE</span>: <span class=\"nc\">Layout</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Layout</span>::<span class=\"n\">from_size_align_unchecked</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">validation</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"n\">align_</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"o\">&lt;</span><span class=\"k\">enum</span><span class=\"o\">-</span><span class=\"n\">tag</span><span class=\"o\">&gt;</span>: <span class=\"nc\">encountered</span><span class=\"w\"> </span><span class=\"mh\">0x0000000000000003</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">but</span><span class=\"w\"> </span><span class=\"n\">expected</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"n\">valid</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">tag</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">The</span><span class=\"w\"> </span><span class=\"n\">rules</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">what</span><span class=\"w\"> </span><span class=\"n\">exactly</span><span class=\"w\"> </span><span class=\"n\">is</span><span class=\"w\"> </span><span class=\"n\">undefined</span><span class=\"w\"> </span><span class=\"n\">behavior</span><span class=\"w\"> </span><span class=\"n\">aren</span><span class=\"o\">'</span><span class=\"na\">t</span><span class=\"w\"> </span><span class=\"n\">clear</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">so</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">check</span><span class=\"w\"> </span><span class=\"n\">might</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">overzealous</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Please</span><span class=\"w\"> </span><span class=\"n\">open</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">issue</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">rustc</span><span class=\"w\"> </span><span class=\"n\">repository</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">you</span><span class=\"w\"> </span><span class=\"n\">believe</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"n\">should</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">considered</span><span class=\"w\"> </span><span class=\"n\">undefined</span><span class=\"w\"> </span><span class=\"n\">behavior</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">the</span><span class=\"w\"> </span><span class=\"n\">raw</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"n\">constant</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">size</span>: <span class=\"mi\">16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">align</span>: <span class=\"mi\">8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">               </span><span class=\"mi\">09</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">03</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"err\">│</span><span class=\"w\"> </span><span class=\"o\">................</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276777452,
        "sender_full_name": "scottmcm",
        "timestamp": 1648372126
    },
    {
        "content": "<p>Oh that is a cute trick :D</p>",
        "id": 276789335,
        "sender_full_name": "RalfJ",
        "timestamp": 1648388985
    }
]