[
    {
        "content": "<p>Is the output of <code>Hash</code> (both derived impls and the manual impls in <code>std</code>) guaranteed to be stable across compilations? I assume it may differ across different Rust versions, but I hope it's at least stable across compilations using the same compiler and stdlib.</p>",
        "id": 269326529,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643145744
    },
    {
        "content": "<p>Not if you use a hashing state with randomization :-)</p>",
        "id": 269326988,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643145943
    },
    {
        "content": "<blockquote>\n<p>For each instance of BuildHasher, the Hashers created by build_hasher should be identical. That is, if the same stream of bytes is fed into each hasher, the same output will also be generated.<br>\n<a href=\"https://doc.rust-lang.org/std/hash/trait.BuildHasher.html\"><code>BuildHasher</code></a></p>\n</blockquote>",
        "id": 269327243,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643146035
    },
    {
        "content": "<p>Ah, good to know, thanks!</p>",
        "id": 269327505,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643146138
    },
    {
        "content": "<p>or are you asking the other way; if this is a valid implementation of <code>Hash</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">X</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">hash</span>::<span class=\"n\">Hash</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">X</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">hash</span><span class=\"o\">&lt;</span><span class=\"n\">H</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">state</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">H</span>: <span class=\"nc\">core</span>::<span class=\"n\">hash</span>::<span class=\"n\">Hasher</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">write_u8</span><span class=\"p\">(</span><span class=\"n\">rand</span>::<span class=\"n\">random</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269327716,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1643146236
    },
    {
        "content": "<p>It's also not stable across targets, Noah.  Even with the same compiler version and same code, different <code>usize</code> widths can affect the resulting value, as can different byte orders.</p>\n<p>For anything that you're using across multiple processes, I'd suggest making a different trait.</p>",
        "id": 269328547,
        "sender_full_name": "scottmcm",
        "timestamp": 1643146653
    },
    {
        "content": "<p>I'm asking from the point of view of storing hash results on disk, so it sounds like it should work :)</p>",
        "id": 269328776,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643146768
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/Hash.20stability/near/269328547\">said</a>:</p>\n<blockquote>\n<p>It's also not stable across targets, Noah.  Even with the same compiler version and same code, different <code>usize</code> widths can affect the resulting value, as can different byte orders.</p>\n<p>For anything that you're using across multiple processes, I'd suggest making a different trait.</p>\n</blockquote>\n<p>Ah, that makes sense!</p>",
        "id": 269328799,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643146781
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/std/hash/trait.Hash.html#portability\">https://doc.rust-lang.org/nightly/std/hash/trait.Hash.html#portability</a></p>",
        "id": 269332887,
        "sender_full_name": "The 8472",
        "timestamp": 1643148814
    },
    {
        "content": "<p>That says it's not stable across compiler versions, but it would be stable <em>within</em> the same compiler version, right?</p>",
        "id": 269482599,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643231381
    },
    {
        "content": "<p>If you could link two executables to each other and the types would be compatible then yeah. There could be some cases where incompatible compile results also hash differently, e.g. if layout is optimized by PGO and we just feed the raw memory representation of a type to a hasher.</p>",
        "id": 269483996,
        "sender_full_name": "The 8472",
        "timestamp": 1643231997
    },
    {
        "content": "<p>I mean I'm not aware of any such thing existing today, but they might in the future.</p>",
        "id": 269484410,
        "sender_full_name": "The 8472",
        "timestamp": 1643232167
    },
    {
        "content": "<p>In my particular use case, I just want to make sure that running the same executable twice won't have different <code>Hash</code> behavior, ignoring hashers with random state</p>",
        "id": 269484451,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643232181
    },
    {
        "content": "<p>Hrm, something could be hashing global state? Like pointers of a static or something?</p>",
        "id": 269484640,
        "sender_full_name": "The 8472",
        "timestamp": 1643232250
    },
    {
        "content": "<p>Do you mean in <code>std</code> or in my code?</p>",
        "id": 269484739,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643232302
    },
    {
        "content": "<p>uhh, don't pointers implement Hash? so if someone hashes function pointers they could change due to ASLR?</p>",
        "id": 269484888,
        "sender_full_name": "The 8472",
        "timestamp": 1643232365
    },
    {
        "content": "<p>It appears so...</p>",
        "id": 269485351,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643232588
    },
    {
        "content": "<p>I guess I'll just have to define my own Hash trait and derive</p>",
        "id": 269485360,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643232596
    },
    {
        "content": "<p>Thanks for your help with this :)</p>",
        "id": 269485478,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643232637
    }
]