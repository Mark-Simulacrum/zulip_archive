[
    {
        "content": "<p>Starting a different thread for this.</p>\n<p>I know there have been many people unhappy with the PartialOrd/Ord split, and wishing it could go away.  But we could <em>never</em> add <code>impl Ord for f32</code>, right, without breaking the existing <code>Ord</code> rules?</p>\n<p>That says to me that if we did want to remove the difference, it would need to be more about changing trait bounds to <code>PartialOrd</code> instead of <code>Ord</code>, rather than making floats <code>Ord</code>.  And thus we'd be fine to put <code>impl !Ord for f32</code> in core, and use that as a place to document <em>why</em> it needs to be that way.</p>\n<p>Is that correct?  I could open a PR for the negative impls...</p>",
        "id": 269802270,
        "sender_full_name": "scottmcm",
        "timestamp": 1643403955
    },
    {
        "content": "<p>I think the only way we could add <code>Ord</code> for <code>f32</code> and <code>f64</code> would be if we also added <code>Eq</code> and made <code>NAN == NAN</code>. Which would be a substantial change and not how other languages behave, though personally I would be thrilled if we'd done that from day 1.</p>",
        "id": 269803780,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643404663
    },
    {
        "content": "<p>it's pretty expensive in terms of time though, because hardware doesn't do that directly</p>",
        "id": 269809033,
        "sender_full_name": "Lokathor",
        "timestamp": 1643407366
    },
    {
        "content": "<p>surely the authors of the floating-point standard had <em>some</em> good reason to make NaN != NaN, right?</p>",
        "id": 270021715,
        "sender_full_name": "bstrie",
        "timestamp": 1643631447
    },
    {
        "content": "<p>It's because <code>NaN</code> is intended to be an error, so it indicates that error by being incomparable with all values, including other NaNs, would could be caused by other unrelated errors, and thus making them compare equal could \"hide\" other errors.</p>\n<p>See, for example,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"k\">f32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Pretend x comes from some input, possibly a computation on user-controlled input</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f32</span>::<span class=\"n\">INFINTIY</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Likewise</span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">sqrt</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">==</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// Pretend this is some check of two functions that makes sense</span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Succeeded\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270026323,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643633800
    },
    {
        "content": "<p>hot take: f32 and f64 shouldn't have supported NaN at all, and Result&lt;f64, NaN&gt; should've been the type representing ieee754 floats.</p>",
        "id": 270037930,
        "sender_full_name": "Mara",
        "timestamp": 1643638795
    },
    {
        "content": "<p>subnormal numbers and infinities can also represent exceptional conditions, depending on application, right? so you might need a family of \"error\" types for a float type</p>",
        "id": 270042400,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1643640510
    },
    {
        "content": "<p>floats aren't numbers, they're just some packed bitfield with special abi treatment</p>",
        "id": 270044548,
        "sender_full_name": "The 8472",
        "timestamp": 1643641264
    },
    {
        "content": "<p>To avoid hiding the error <code>f32::NaN == x</code> should <em>just</em> return <code>bool::NaN</code>, the third boolean value ;)</p>",
        "id": 270245466,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1643734641
    },
    {
        "content": "<p>or maybe <code>bool::NaB</code> for not-a-boolean</p>",
        "id": 270245631,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1643734686
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <code>bool::FileNotFound</code></p>",
        "id": 270246984,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643735124
    },
    {
        "content": "<p>don't forget <code>bool::Inf</code> for the result of <code>true / false</code></p>",
        "id": 270247030,
        "sender_full_name": "bstrie",
        "timestamp": 1643735134
    },
    {
        "content": "<p>(reference, for folks who haven't seen it: <a href=\"https://thedailywtf.com/articles/What_Is_Truth_0x3f_\">https://thedailywtf.com/articles/What_Is_Truth_0x3f_</a> )</p>",
        "id": 270247391,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643735242
    },
    {
        "content": "<p>(I wonder if it would break anything to define <code>bool</code> as an enum in std as opposed to making it a primitive...)</p>",
        "id": 270248586,
        "sender_full_name": "bstrie",
        "timestamp": 1643735636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> It'd have to be a language item so that <code>if</code> and <code>while</code> similar can expect it.</p>",
        "id": 270248899,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643735745
    },
    {
        "content": "<p>And I suspect it'd have performance issues if the compiler didn't \"natively\" understand it.</p>",
        "id": 270248984,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643735765
    },
    {
        "content": "<p>But I don't think in <em>principle</em> it'd be impossible.</p>",
        "id": 270249000,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643735771
    },
    {
        "content": "<p>RFC replacing bools with intuitionistic logic when?</p>",
        "id": 270249008,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1643735773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248984\">said</a>:</p>\n<blockquote>\n<p>And I suspect it'd have performance issues if the compiler didn't \"natively\" understand it.</p>\n</blockquote>\n<p>I doubt it. Aren't C-like enums as-performant as the underlying integer type?</p>",
        "id": 270250313,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643736211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248586\">said</a>:</p>\n<blockquote>\n<p>(I wonder if it would break anything to define <code>bool</code> as an enum in std as opposed to making it a primitive...)</p>\n</blockquote>\n<p>You can use <code>bool</code> and <code>true</code>/<code>false</code> in the global namespace w/o a prelude, which would be impossible if it was defined in <code>std</code>.</p>",
        "id": 270250667,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643736329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248899\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> It'd have to be a language item so that <code>if</code> and <code>while</code> similar can expect it.</p>\n</blockquote>\n<p>ah, but clearly we should redefine <code>if</code> and <code>while</code> in terms of <code>ops::ControlFlow</code> :P</p>",
        "id": 270250830,
        "sender_full_name": "bstrie",
        "timestamp": 1643736392
    },
    {
        "content": "<p>ngl, that kinda makes sense for <code>while</code>. IDK how <code>if</code> would work, though? <code>Continue</code> enters body, <code>Break</code> doesn't/goes to else?</p>",
        "id": 270251001,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643736448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270250313\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248984\">said</a>:</p>\n<blockquote>\n<p>And I suspect it'd have performance issues if the compiler didn't \"natively\" understand it.</p>\n</blockquote>\n<p>I doubt it. Aren't C-like enums as-performant as the underlying integer type?</p>\n</blockquote>\n<p>Integer type, yes. But I'm not sure if all the optimizations the compiler does with <code>bool</code> are true for integers. The compiler sometimes generates code using an architecture's condition codes for bool control flow, rather than (for instance) having to compare the bool to 1 or 0.</p>",
        "id": 270256067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643738204
    },
    {
        "content": "<p>I don't know if we could do all those optimizations just as well if we translated to <code>enum bool { false, true }</code>.</p>",
        "id": 270256104,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643738221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270250830\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270248899\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> It'd have to be a language item so that <code>if</code> and <code>while</code> similar can expect it.</p>\n</blockquote>\n<p>ah, but clearly we should redefine <code>if</code> and <code>while</code> in terms of <code>ops::ControlFlow</code> :P</p>\n</blockquote>\n<p>Imaging control flow aware loop and exhaustive patterns</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ControlFlow</span>::<span class=\"n\">Break</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"kr\">try</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// ... };</span>\n</code></pre></div>",
        "id": 270259777,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1643739597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270256067\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270250313\">said</a>:</p>\n<blockquote>\n<p>I doubt it. Aren't C-like enums as-performant as the underlying integer type?</p>\n</blockquote>\n<p>Integer type, yes. But I'm not sure if all the optimizations the compiler does with <code>bool</code> are true for integers. The compiler sometimes generates code using an architecture's condition codes for bool control flow, rather than (for instance) having to compare the bool to 1 or 0.</p>\n</blockquote>\n<p>afaict llvm is only ever told that you have an 8-bit integer, not that that 8-bit integer is a <code>bool</code> (except debug info). llvm has to handle C code which often uses an integer or <code>enum</code> instead of <code>bool</code>, so it should be pretty optimal.</p>",
        "id": 270268596,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643742947
    },
    {
        "content": "<p>llvm gets an i1, not i8</p>",
        "id": 270270736,
        "sender_full_name": "The 8472",
        "timestamp": 1643743729
    },
    {
        "content": "<p>hmm, from what i can see, llvm treats <code>bool</code> and an enum identically here,even merging them into the same llvm ir function:<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3</a></p>",
        "id": 270274006,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643744995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"411291\">Taylor Yu [they/she]</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270042400\">said</a>:</p>\n<blockquote>\n<p>subnormal numbers and infinities can also represent exceptional conditions, depending on application, right? so you might need a family of \"error\" types for a float type</p>\n</blockquote>\n<p>nah, not really. not much more than that <code>0.0</code> or negative numbers might be exceptional for certain calculations.</p>",
        "id": 270701006,
        "sender_full_name": "Mara",
        "timestamp": 1643973733
    },
    {
        "content": "<p>Oh yes.<br>\nYeah, from the IEEE754 perspective, any value <code>-inf..=+inf</code> is <strong>a well-defined result</strong>.<br>\nNow, the standard talks about how e.g. division by zero signals the \"divideByZero\" exception, even though it has a well-defined result (one of the infinities). But that's because it means that observing the exception state should be possible, not that it is mandatory to e.g. signal a hardware interrupt and \"trap\" the calculation. The intent was to allow it to be something a debugger could notice.</p>\n<p>This is mostly: undersupported in hardware, unsupported in most PLs and compiler backends.</p>",
        "id": 270851780,
        "sender_full_name": "Jubilee",
        "timestamp": 1644098730
    },
    {
        "content": "<p>I once worked on an F77 codebase which at the end of the program would print which floating-point exceptions that had occurred during execution. I think that's similar but not the same as what you're talking about? In any case, it was helpful.</p>",
        "id": 271718332,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1644712837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/219381-t-libs/topic/Can.20we.20commit.20to.20.60impl.20!Ord.20for.20f32.60.3F/near/270274006\">said</a>:</p>\n<blockquote>\n<p>hmm, from what i can see, llvm treats <code>bool</code> and an enum identically here,even merging them into the same llvm ir function:<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=9de79677464a46a4883ff788ec4d51f3</a></p>\n</blockquote>\n<p>It is dependent on location, yes. For ABI purposes <code>bool</code> is an <code>i8</code>, for SSA purposes it is usually a <code>i1</code>. For what it is worth the enum in question will (I <em>believe</em>) eventually become the same due to how some LLVM pass reduces bit-width to account for valid value range.</p>",
        "id": 272342356,
        "sender_full_name": "nagisa",
        "timestamp": 1645142723
    }
]