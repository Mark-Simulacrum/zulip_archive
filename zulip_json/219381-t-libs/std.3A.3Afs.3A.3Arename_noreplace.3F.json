[
    {
        "content": "<p>As far as I can see the standard library currently has no way of renaming a file such that if the destination already exists, the operation fails. Note that checking if the destination exists before renaming is unsatisfactory due to race conditions.</p>\n<p>I believe we could support this on Linux using <code>renameat2</code> with <code>RENAME_NOREPLACE</code> and on Windows as we do now using <code>MoveFileExW</code>, just without specifying <code>MOVEFILE_REPLACE_EXISTING</code>.</p>",
        "id": 261420177,
        "sender_full_name": "orlp",
        "timestamp": 1636899989
    },
    {
        "content": "<p>windows and linux support isn't sufficient though, afaik the BSDs don't have support for that</p>",
        "id": 261420903,
        "sender_full_name": "The 8472",
        "timestamp": 1636900731
    },
    {
        "content": "<p>On BSD we could do the equivalent of <code>std::fs::hard_link(src, dst)?; std::fs::remove_file(src)?;</code> maybe? It is not quite atomic because we could lose permissions to remove the src file after the creation of the hard link</p>",
        "id": 261424905,
        "sender_full_name": "orlp",
        "timestamp": 1636906495
    },
    {
        "content": "<p>src could also be replaced between hardlink and remove_file</p>",
        "id": 261425066,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636906705
    },
    {
        "content": "<p>Which I would think is a larger concern than the file sticking arround.</p>",
        "id": 261425082,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636906747
    },
    {
        "content": "<p>(Also, hard_link doesn't work accross filesystems, but I presume rename does)</p>",
        "id": 261425108,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636906795
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/std.3A.3Afs.3A.3Arename_noreplace.3F/near/261425108\">said</a>:</p>\n<blockquote>\n<p>(Also, hard_link doesn't work accross filesystems, but I presume rename does)</p>\n</blockquote>\n<p>rename(2) works only if source and destination are on the same filesystem.</p>",
        "id": 261425266,
        "sender_full_name": "Hans Kratz",
        "timestamp": 1636907008
    },
    {
        "content": "<p>Ah, nvm then. My point about potentially deleting a replacement stands, though.</p>",
        "id": 261425405,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636907240
    },
    {
        "content": "<p><code>link</code> does not replace the destination</p>",
        "id": 261426614,
        "sender_full_name": "The 8472",
        "timestamp": 1636908835
    },
    {
        "content": "<p>also, not all filesystems support hardlinks</p>",
        "id": 261426666,
        "sender_full_name": "The 8472",
        "timestamp": 1636908866
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/std.3A.3Afs.3A.3Arename_noreplace.3F/near/261420903\">said</a>:</p>\n<blockquote>\n<p>windows and linux support isn't sufficient though, afaik the BSDs don't have support for that</p>\n</blockquote>\n<p>Supporting it for those platforms thanks to the platform-specific extension traits would already be a start, wouldn't it?</p>",
        "id": 261431191,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636914186
    },
    {
        "content": "<p>Not all filesystems support <code>RENAME_NOREPLACE</code> either</p>",
        "id": 261431263,
        "sender_full_name": "cuviper",
        "timestamp": 1636914277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/219381-t-libs/topic/std.3A.3Afs.3A.3Arename_noreplace.3F/near/261431191\">said</a>:</p>\n<blockquote>\n<p>Supporting it for those platforms thanks to the platform-specific extension traits would already be a start, wouldn't it?</p>\n</blockquote>\n<p>Then we'd have the same method on different traits and people would have to import them with separate cfg's which means it's not a great abstraction</p>",
        "id": 261436683,
        "sender_full_name": "The 8472",
        "timestamp": 1636921599
    },
    {
        "content": "<p>What about adding it anyway (as <code>std::fs::rename_noreplace</code>, not platform-specific names), returning an error with <code>ErrorKind::Unsupported</code> on platforms that don't support it (yet)? Then we can slowly add implementations for platforms as support becomes available, and we're not limited to compile-time platform support detection either (e.g. if the operation is only supported on a certain filesystem).</p>",
        "id": 261480978,
        "sender_full_name": "orlp",
        "timestamp": 1636972818
    },
    {
        "content": "<p>well, and what would users do on error? implement a fallback? then we might as well put the fallback in the standard library and put a warning on it that it's not atomic on all systems.</p>",
        "id": 261481684,
        "sender_full_name": "The 8472",
        "timestamp": 1636973300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/std.3A.3Afs.3A.3Arename_noreplace.3F/near/261481684\">said</a>:</p>\n<blockquote>\n<p>well, and what would users do on error? implement a fallback? then we might as well put the fallback in the standard library and put a warning on it that it's not atomic on all systems.</p>\n</blockquote>\n<p>I don't agree. Some users might be okay with a non-atomic fallback, other users might want to bubble up the error/or fail entirely if atomicity can't be guaranteed. With an error the choice is theirs.</p>",
        "id": 261483783,
        "sender_full_name": "orlp",
        "timestamp": 1636974683
    },
    {
        "content": "<p>E.g.:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">std</span>::<span class=\"n\">fs</span>::<span class=\"n\">rename_noreplace</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">).</span><span class=\"n\">or_else</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">e</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">io</span>::<span class=\"n\">ErrorKind</span>::<span class=\"n\">Unsupported</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">.</span><span class=\"n\">exists</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">io</span>::<span class=\"n\">Error</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">io</span>::<span class=\"n\">ErrorKind</span>::<span class=\"n\">AlreadyExists</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"rename_noreplace\"</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">std</span>::<span class=\"n\">fs</span>::<span class=\"n\">rename</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">dst</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261484450,
        "sender_full_name": "orlp",
        "timestamp": 1636975163
    },
    {
        "content": "<p>What could be possible is to add a boolean flag, so it's <code>std::fs::rename_noreplace(src: &amp;Path, dst: &amp;Path, require_atomic: bool)</code> and <code>std::fs::rename_noreplace(src, dst, false)</code> gives you the above behavior whereas <code>std::fs::rename_noreplace(src, dst, true)</code> would return the error.</p>",
        "id": 261484757,
        "sender_full_name": "orlp",
        "timestamp": 1636975399
    },
    {
        "content": "<p>(or two functions)</p>",
        "id": 261484844,
        "sender_full_name": "orlp",
        "timestamp": 1636975447
    },
    {
        "content": "<p>That feels like an awkward interface, especially for the hopeful future case where users can count on it.</p>",
        "id": 261506639,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636987939
    }
]