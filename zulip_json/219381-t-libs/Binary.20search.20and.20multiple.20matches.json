[
    {
        "content": "<p>A  note about <code>binary_search</code> and friends: when there are multiple matches, any one of the matches might be returned. I'm currently writing code that wants all the matches, so it uses <code>binary_search_by</code> and then has to scan forward and backward to find additional matches.</p>\n<p>I suspect the current behaviour gives maximum performance, but it is a little inconvenient for my current use case. I'm not saying anything should necessarily change, but perhaps this is a useful anecdote for the libs team <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 270473651,
        "sender_full_name": "nnethercote",
        "timestamp": 1643843330
    },
    {
        "content": "<p><code>partition_point</code> will give you the first index</p>",
        "id": 270473939,
        "sender_full_name": "The 8472",
        "timestamp": 1643843482
    },
    {
        "content": "<p>I've wanted something like C++'s <code>equal_range</code> for ages.  It could return a <code>Range&lt;usize&gt;</code> of the found positions -- and if it's empty, it'd be the place to insert to keep the sequence in sorted order.</p>\n<p>Approaching-5-year-old RFCs issue: <a href=\"https://github.com/rust-lang/rfcs/issues/2184\">https://github.com/rust-lang/rfcs/issues/2184</a></p>",
        "id": 270474775,
        "sender_full_name": "scottmcm",
        "timestamp": 1643844002
    },
    {
        "content": "<p>I looked at <code>partition_point</code>. I have a sorted slice of strings, and I want to find all the strings that match a given prefix. <code>partition_point</code> didn't seem like it would fit, but I guess the predicate could be <code>|s| s.starts_with(prefix) || s.cmp(prefix) == Ordering::Greater</code> ?</p>",
        "id": 270476904,
        "sender_full_name": "nnethercote",
        "timestamp": 1643845214
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> To find the lower bound, use <code>|s| s &lt; prefix</code>, and to find the upper bound use <code>|s| s.starts_with(prefix)</code> on the subslice from the first operation</p>",
        "id": 270477884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643845858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> From the RFC, it looks like progress stalled after <code>partition_point</code> landed. I think that <code>partition_point</code> does make <code>lower_bound</code> and <code>upper_bound</code> obsolete, but <code>equal_range</code> can be implemented more efficiently than two calls to <code>partition_point</code></p>",
        "id": 270478074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643845993
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Oh, I see! Thanks for the suggestion. (I was hoping someone would tell me a better way to do it, and you did <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> )</p>",
        "id": 270478102,
        "sender_full_name": "nnethercote",
        "timestamp": 1643846021
    },
    {
        "content": "<p>Hmm, I have to be a bit careful for the case where there are no matches.</p>",
        "id": 270479193,
        "sender_full_name": "nnethercote",
        "timestamp": 1643846594
    },
    {
        "content": "<p>Here's what I've got now:</p>\n<div class=\"codehilite\"><pre><span></span><code>            let i = rlibs.partition_point(|spf| spf.file_name_str &lt; rlib_prefix);\n            let binary_matches: SmallVec&lt;[usize; 4]&gt; = if let Some(true) =\n                rlibs.get(i).map(|spf| spf.file_name_str.starts_with(&amp;rlib_prefix))\n            {\n                let mut j = i;\n                while j &lt; rlibs.len() - 1 &amp;&amp; rlibs[j + 1].file_name_str.starts_with(&amp;rlib_prefix) {\n                    j += 1;\n                }\n                (i..=j).collect()\n            } else {\n                SmallVec::new()\n            };\n</code></pre></div>",
        "id": 270480758,
        "sender_full_name": "nnethercote",
        "timestamp": 1643847625
    },
    {
        "content": "<p>It's more concise than the binary search version, but it was harder to get right, with more edge cases.</p>",
        "id": 270480815,
        "sender_full_name": "nnethercote",
        "timestamp": 1643847660
    },
    {
        "content": "<p>E.g. getting an index that's out of bounds</p>",
        "id": 270480852,
        "sender_full_name": "nnethercote",
        "timestamp": 1643847703
    },
    {
        "content": "<p>that's more complicated than I expected. No promises on this being syntactically correct but I was expecting something more like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rlibs</span><span class=\"p\">.</span><span class=\"n\">partition_point</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">spf</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">spf</span><span class=\"p\">.</span><span class=\"n\">file_name_str</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">rlib_prefix</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">j</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">rlibs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">..</span><span class=\"p\">].</span><span class=\"n\">partition_point</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">spf</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">spf</span><span class=\"p\">.</span><span class=\"n\">file_name_str</span><span class=\"p\">.</span><span class=\"n\">starts_with</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">rlib_prefix</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"n\">rlibs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">..</span><span class=\"n\">j</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270481967,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643848410
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span></p>",
        "id": 270482156,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643848532
    },
    {
        "content": "<p>it's also faster than your version in the case where the list of matches is long (since it does binary search to find the end point instead of linear search), although linear search often wins in small-to-medium cases</p>",
        "id": 270482324,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643848641
    },
    {
        "content": "<p>I believe this seamlessly handles the case where there are no matches: the first search will return the point at which the prefix would live, and the second search makes <code>j = i</code></p>",
        "id": 270482442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643848712
    },
    {
        "content": "<p>In my case the number of matches is rarely greater than 1, alas</p>",
        "id": 270485592,
        "sender_full_name": "nnethercote",
        "timestamp": 1643850759
    },
    {
        "content": "<p>After more fiddling I got it down to this:</p>\n<div class=\"codehilite\"><pre><span></span><code>            let i = rmetas.partition_point(|spf| spf.file_name_str &lt; rmeta_prefix);\n            let mut j = i;\n            while let Some(true) =\n                rmetas.get(j).map(|spf| spf.file_name_str.starts_with(&amp;rmeta_prefix))\n            {\n                j += 1;\n            }\n\n           // Then iterate over `&amp;rmetas[i..j]`\n</code></pre></div>",
        "id": 270492648,
        "sender_full_name": "nnethercote",
        "timestamp": 1643855975
    },
    {
        "content": "<p>Thanks again for the suggestions</p>",
        "id": 270492783,
        "sender_full_name": "nnethercote",
        "timestamp": 1643856036
    },
    {
        "content": "<p>Imo the sub-slice based approach would be more rusty</p>",
        "id": 270526403,
        "sender_full_name": "The 8472",
        "timestamp": 1643883534
    },
    {
        "content": "<p>\"sort in place but return a subslice\" seems like an unusual and error-prone interface.</p>",
        "id": 270526537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643883593
    },
    {
        "content": "<p>In particular, the subslice will only differ from the original iff you have NaNs present.</p>",
        "id": 270526634,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643883623
    },
    {
        "content": "<p>And in the common case where you don't, people could ignore that and use the original.</p>",
        "id": 270526666,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643883639
    }
]