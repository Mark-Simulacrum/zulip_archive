[
    {
        "content": "<p>I view the behavior of <code>x / y</code> in rust to be unavoidable baggage from our desire to be C-like and make it possible to translate things more or less faithfully, but needless to say I think <code>x.div_floor(y)</code> should definitely exist</p>",
        "id": 251102023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630208080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/Division.2Fmodulus.20operators.20and.20C-compatibility/near/251101369\">said</a>:</p>\n<blockquote>\n<p>That has the nicest mathematical properties, and also happens to be what most processors implement</p>\n</blockquote>\n<p>That's not true. Both x86 IDIV and RISC-V DIV are truncated divison</p>",
        "id": 251157362,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630270535
    },
    {
        "content": "<p>From hardware point of view, truncated division is easier to implement</p>",
        "id": 251157434,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630270607
    },
    {
        "content": "<p>It also gives nice property of (-a)/b=-(a/b)=a/(-b) which isn't true for floor division</p>",
        "id": 251157508,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630270684
    },
    {
        "content": "<p>Yeah, negative divisors in integer math are weird.</p>",
        "id": 251167661,
        "sender_full_name": "scottmcm",
        "timestamp": 1630281353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/Division.2Fmodulus.20operators.20and.20C-compatibility/near/251157362\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/Division.2Fmodulus.20operators.20and.20C-compatibility/near/251101369\">said</a>:</p>\n<blockquote>\n<p>That has the nicest mathematical properties, and also happens to be what most processors implement</p>\n</blockquote>\n<p>That's not true. Both x86 IDIV and RISC-V DIV are truncated divison</p>\n</blockquote>\n<p>Ah, I take it back. Not the part about the naturalness of implementing it in hardware though; I'm pretty sure truncated division requires an <code>if x &lt; 0 { acc++ }</code> fixup step in hardware</p>",
        "id": 251167744,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630281450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/Division.2Fmodulus.20operators.20and.20C-compatibility/near/251157508\">said</a>:</p>\n<blockquote>\n<p>It also gives nice property of (-a)/b=-(a/b)=a/(-b) which isn't true for floor division</p>\n</blockquote>\n<p>All three conventions have some nice properties that the others don't. I think it is good that the modulus is always nonnegative in euclidean division, that saves a bit and adds some type safety.</p>\n<p>By the way, this property is true essentially by definition: I looked around for (truncating) signed integer division circuits and they seem to amount to <code>if (x &lt; 0) != (y &lt; 0) { -(x.abs() / y.abs()) } else { x.abs() / y.abs() }</code> where <code>x / y</code> is unsigned division</p>",
        "id": 251168483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630282157
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/Division.2Fmodulus.20operators.20and.20C-compatibility/near/251167744\">said</a>:</p>\n<blockquote>\n<p>Ah, I take it back. Not the part about the naturalness of implementing it in hardware though; I'm pretty sure truncated division requires an <code>if x &lt; 0 { acc++ }</code> fixup step in hardware</p>\n</blockquote>\n<p>No. Division, unlikely multiplication, doesn't naturally work with 2's complement. What hardware implementations do is to separate the sign and magnitude, perform an unsigned division, and then fixup the signs after division. And that's where the property (or definition) is used. Other types of division would requires a fixup which complicates the logic.</p>",
        "id": 251234230,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630332287
    }
]