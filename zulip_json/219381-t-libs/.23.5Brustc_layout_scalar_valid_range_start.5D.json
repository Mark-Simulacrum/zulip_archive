[
    {
        "content": "<p>The <code>#[rustc_layout_scalar_valid_range_start]</code> and <code>#[rustc_layout_scalar_valid_range_end]</code> attributes clearly state that they will never be stable. Is there any reason these attributes couldn't be exposed to end users in some form (naturally under a different name)? It looks like the necessary safety checks are already in place.</p>",
        "id": 247288849,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627354423
    },
    {
        "content": "<p>I'd like to take advantage of them for the <code>deranged</code> crate, which provides range-bound integers. This would need adapting the attribute to accept any const value (deranged uses const generics) instead of just literals, but I'd be willing to give it a shot if there's a reasonable path forwards on this.</p>",
        "id": 247288936,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627354489
    },
    {
        "content": "<p>If users do access it as an attribute that would be more T-lang than T-libs.</p>\n<p>But yeah, users should be able to use this functionality in some way.</p>",
        "id": 247298697,
        "sender_full_name": "Lokathor",
        "timestamp": 1627367606
    },
    {
        "content": "<p>Would it be better to expose this as a struct with const generics (like <code>NonZero</code>) rather than exposing the attributes directly?</p>",
        "id": 247304104,
        "sender_full_name": "Amanieu",
        "timestamp": 1627372588
    },
    {
        "content": "<p>If it were generic in some magical way that supported only scalar values where you can set the range, then sure. However, that's currently so far off from what const generics supports that if you try something like it you're not even told about a feature you could maybe turn on.</p>",
        "id": 247304529,
        "sender_full_name": "Lokathor",
        "timestamp": 1627372890
    },
    {
        "content": "<p>I mean that is <em>basically</em> my intended use case (ranged integers with niche value optimization). The problem with const generics is it requires a concrete type (and i128 and u128 are both reasonable to desire)</p>",
        "id": 247304623,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627372936
    },
    {
        "content": "<p>We've got X many integer types already, and C has a proposal for generic integers, so Rust will need to get moving and have them too at some point, at which point it will be totally unreasonable to offer one bounded type per integer type.</p>",
        "id": 247304748,
        "sender_full_name": "Lokathor",
        "timestamp": 1627373032
    },
    {
        "content": "<p>That's what I've already done (deranged crate), it's just missing niche value optimization. In an ideal world it wouldn't be necessary to manually declare the backing type (even if it can be done with a macro), but that would require compiler integration because of the aforementioned issue with concrete types. afaik the compiler uses bigint internally for things like this</p>",
        "id": 247305016,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627373211
    },
    {
        "content": "<p>Just trying to get one step closer to having native-like ranged integers</p>",
        "id": 247305077,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627373251
    },
    {
        "content": "<blockquote>\n<p>I'd like to take advantage of them for the <code>deranged</code> crate, which provides range-bound integers.</p>\n</blockquote>\n<p>Hey, you <a href=\"https://docs.rs/bounded-integer\">stole my idea</a> :P.</p>",
        "id": 247305086,
        "sender_full_name": "Kestrer",
        "timestamp": 1627373261
    },
    {
        "content": "<p>oh well <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 247305200,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627373323
    },
    {
        "content": "<p><code>range_start</code> and <code>range_end</code> couldn't express something like <code>char</code> though which has a gap in its valid range for the surrogates.</p>",
        "id": 247305905,
        "sender_full_name": "The 8472",
        "timestamp": 1627373922
    },
    {
        "content": "<p>Yes, and that's been the subject of many discussions regarding how to best permit for arbitrary niche values. I think it's worth noting that even just start/end bounds provides for a very large number of niches (far more than the typical use case) in most situations.</p>",
        "id": 247306046,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627374011
    },
    {
        "content": "<p>and it doesn't work for alignment gaps either</p>",
        "id": 247306355,
        "sender_full_name": "The 8472",
        "timestamp": 1627374247
    },
    {
        "content": "<p>I'd honestly be fine if this were limited to newtypes. It seems like the most likely use-case.</p>",
        "id": 247307308,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627374936
    },
    {
        "content": "<p>ftr, the limitation to range is a pragmatic implementation choice. taking advantage of other \"shapes\" of niches would make <code>enum</code> encoding/decoding more expensive, or at the very least it would require the compiler to more expensively track every layout's available niches - as-is, it's always just two integers</p>",
        "id": 247318226,
        "sender_full_name": "eddyb",
        "timestamp": 1627383483
    },
    {
        "content": "<p>also, you only need unsigned integers (e.g. <code>u128</code>) to express the validity range: it's a \"wraparound\" range, meaning <code>start &gt; end</code> actually makes sense, and lets you do negative ranges like for an <code>u8</code>, the range <code>0xfe..=0x02</code> is the equivalent to the <code>-2..=2</code> range on <code>i8</code></p>",
        "id": 247318369,
        "sender_full_name": "eddyb",
        "timestamp": 1627383592
    },
    {
        "content": "<p>So... On this topic, I have had <del>awesome</del> horrible ideas. Instead of inventing more and more fine grained systems for layout stuff (bit fields, field range restrictions, ...), we add procedural types to Rust. Right now we have declarative types. You define the type and the layout is autogenerated by the compiler. Just like we added procedural macros on top of declarative macros, we will add a concept <code>type Foo = const { ... };</code> where the <code>...</code> is const code that generates arbitrarily complex instances of something similar to <code>ty::Layout</code> in the compiler. So you both generate the type representation as well as the layout of that representation.</p>",
        "id": 247318508,
        "sender_full_name": "oli",
        "timestamp": 1627383638
    },
    {
        "content": "<p>whether we want to expose the wraparound range to users is another question, so it's possible that for now we'd have something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">RangedU16</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FIRST</span>: <span class=\"kt\">u16</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LAST</span>: <span class=\"kt\">u16</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"p\">()</span>: <span class=\"nc\">IsTrue</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"n\">FIRST</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">LAST</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">inner</span>: <span class=\"kt\">u16</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 247318683,
        "sender_full_name": "eddyb",
        "timestamp": 1627383730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247318508\">said</a>:</p>\n<blockquote>\n<p>So... On this topic, I have had <del>awesome</del> horrible ideas. Instead of inventing more and more fine grained systems for layout stuff (bit fields, field range restrictions, ...), we add procedural types to Rust. Right now we have declarative types. You define the type and the layout is autogenerated by the compiler. Just like we added procedural macros on top of declarative macros, we will add a concept <code>type Foo = const { ... };</code> where the <code>...</code> is const code that generates arbitrarily complex instances of something similar to <code>ty::Layout</code> in the compiler. So you both generate the type representation as well as the layout of that representation.</p>\n</blockquote>\n<p>yeah... that's not happening without dependent types :P</p>",
        "id": 247318743,
        "sender_full_name": "eddyb",
        "timestamp": 1627383771
    },
    {
        "content": "<p>you need <em>a lot</em> of infrastructure to make that kind of thing <em>remotely</em> sane</p>",
        "id": 247318771,
        "sender_full_name": "eddyb",
        "timestamp": 1627383787
    },
    {
        "content": "<p>whaat, why?</p>",
        "id": 247318773,
        "sender_full_name": "oli",
        "timestamp": 1627383787
    },
    {
        "content": "<p>who said anything about sane?</p>",
        "id": 247318784,
        "sender_full_name": "oli",
        "timestamp": 1627383795
    },
    {
        "content": "<p>idk, having a sound language is nice? :P</p>",
        "id": 247318800,
        "sender_full_name": "eddyb",
        "timestamp": 1627383806
    },
    {
        "content": "<p><code>type Foo = const unsafe { ... };</code></p>",
        "id": 247318808,
        "sender_full_name": "oli",
        "timestamp": 1627383811
    },
    {
        "content": "<p>Why would it return a <code>Layout</code>? Given enough imagination it could <em>just</em> be a function that checks if the value belongs to the type :P</p>",
        "id": 247318953,
        "sender_full_name": "bjorn3",
        "timestamp": 1627383898
    },
    {
        "content": "<p>at most I could see some kind of very limited <code>unsafe fn</code> encode/decode, e.g. of the high-level discriminant value of an <code>enum</code> into/from an array of bytes. but then you also need the variant data. maybe it could be done with attributes on fields and that could be checked but that's pretty limited (<code>#[repr(align(N))]</code> is also pretty limited tbh)</p>",
        "id": 247319647,
        "sender_full_name": "eddyb",
        "timestamp": 1627384417
    },
    {
        "content": "<p>Just echoing that I would also love the valid range feature because it would be useful for some optimisations (I made a topic about always positive signed integers before.), and for modelling ASN.1 integers which can be arbitrarily constrained.</p>",
        "id": 247496084,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1627496031
    },
    {
        "content": "<p>I remember a long time ago we had a discussion about stabilizing this in some form.</p>",
        "id": 247498223,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627497006
    },
    {
        "content": "<p>If we're going to stabilize it, I'd love to be able to ensure that users can write values that aren't just unsigned, and <em>ideally</em> reference compile-time constants (e.g. <code>i32::MAX</code>).</p>",
        "id": 247498341,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627497067
    },
    {
        "content": "<p>I would like having this via const generics, so some sort of <code>struct Ranged&lt;T: SomeTraitBound, const MIN: T, const MAX: T&gt;(T);</code> that we can extend in the future with more types that implement <code>SomeTraitBound</code></p>",
        "id": 247499407,
        "sender_full_name": "oli",
        "timestamp": 1627497563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247498341\">said</a>:</p>\n<blockquote>\n<p>If we're going to stabilize it, I'd love to be able to ensure that users can write values that aren't just unsigned, and <em>ideally</em> reference compile-time constants (e.g. <code>i32::MAX</code>).</p>\n</blockquote>\n<p>if we can do <code>MIN &lt;= MAX</code> bounds, then the bounds for e.g. <code>RangedI32</code> would be typed as <code>i32</code>, and \"wraparound range\" would be limited to being an implementation detail</p>",
        "id": 247501123,
        "sender_full_name": "eddyb",
        "timestamp": 1627498312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I'd love to use const generics, but I don't want to force people to use those types <em>in place of</em> the types they would have written.</p>",
        "id": 247502541,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627498877
    },
    {
        "content": "<p>That would force an API break for existing code, for instance.</p>",
        "id": 247502570,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627498889
    },
    {
        "content": "<p>It should be possible to write <code>struct MyType(i32)</code> and add min/max bounds to that without changing the <code>i32</code> to something like <code>Ranged&lt;...&gt;</code>.</p>",
        "id": 247502628,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627498921
    },
    {
        "content": "<p>it would already be a breaking change, as it would become unsafe to access the <code>i32</code></p>",
        "id": 247503487,
        "sender_full_name": "oli",
        "timestamp": 1627499321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247498341\">said</a>:</p>\n<blockquote>\n<p><em>ideally</em> reference compile-time constants (e.g. <code>i32::MAX</code>).</p>\n</blockquote>\n<p>That's something I mentioned at the top of this thread — I'd be willing to at least investigate what would be necessary to permit arbitrary const values in this position.</p>",
        "id": 247503507,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627499331
    },
    {
        "content": "<p>I may be missing something here, I am strictly thinking about how <code>rustc_layout_scalar_valid_range_start</code> works</p>",
        "id": 247503556,
        "sender_full_name": "oli",
        "timestamp": 1627499350
    },
    {
        "content": "<p><em>Accessing</em> is safe, but any assignment (including construction) is unsafe from what I can see.</p>",
        "id": 247503656,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627499396
    },
    {
        "content": "<p>It may be worthwhile, at least at first, to restrict the attributes to newtypes around integers, as I'm pretty sure it's permitted on things like arrays internally.</p>",
        "id": 247503819,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627499466
    },
    {
        "content": "<p>and newtypes would cover most use cases</p>",
        "id": 247503833,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627499475
    },
    {
        "content": "<p>I see <code>Ranged</code> occupying a similar role to <code>UnsafeCell</code>, communicating the low-level details to the compiler, while you'll probably newtype that into your own specific thing</p>",
        "id": 247504042,
        "sender_full_name": "cuviper",
        "timestamp": 1627499560
    },
    {
        "content": "<p>On the contrary I'd prefer it be quite widespread in APIs that would otherwise perform validation on parameters.</p>",
        "id": 247504167,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627499615
    },
    {
        "content": "<p>possibly these are two separate APIs?</p>",
        "id": 247504296,
        "sender_full_name": "bstrie",
        "timestamp": 1627499664
    },
    {
        "content": "<p>The other reason I'm concerned about <code>Ranged</code> is that like <code>NonZero</code> types, it can be rather inconvenient to use, sufficiently so that sometimes even when something can't be zero people still use the unconstrained type.</p>",
        "id": 247504418,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627499744
    },
    {
        "content": "<p>With a newtype, you can just <code>.0</code> to get the inner type out, and then do normal operators like <code>+</code> or <code>*</code>.</p>",
        "id": 247504519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627499779
    },
    {
        "content": "<p>but it needs to be unsafe to change <code>.0</code></p>",
        "id": 247504556,
        "sender_full_name": "cuviper",
        "timestamp": 1627499802
    },
    {
        "content": "<p>already is from what I can tell</p>",
        "id": 247504581,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627499816
    },
    {
        "content": "<p>when using the attributes</p>",
        "id": 247504601,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627499825
    },
    {
        "content": "<p>ah, ok</p>",
        "id": 247504665,
        "sender_full_name": "cuviper",
        "timestamp": 1627499865
    },
    {
        "content": "<p>If we go down the road of having a <code>Ranged</code> type, there would need to be some sort of compiler integration to permit the user to not care about the backing type (a problem deranged has)</p>",
        "id": 247504942,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627500000
    },
    {
        "content": "<p>Couldn't it have the type <code>Ranged&lt;T: Number, const LO: T, const HI: T&gt;</code> for some <code>Number</code> trait? That's not within <code>min_const_generics</code> but that never seems to stop std</p>",
        "id": 247509242,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627502210
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I would consider the <code>NonZero</code> inconvenience to be something that’s worth addressing as it’s own thing. You should be able to create newtypes that are drop-in replacements for the integer types (with the exception of being able to use <code>as</code>).</p>",
        "id": 247509287,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1627502238
    },
    {
        "content": "<p>Or just <code>RangedU8</code>, <code>RangedU16</code> etc</p>",
        "id": 247509311,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627502250
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> in theory, yes. As you've noted we'd need full <code>const_generics</code> for that.</p>",
        "id": 247509341,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627502269
    },
    {
        "content": "<p>Having <code>RangedU8</code> is precisely what deranged does, and it's not exactly convenient.</p>",
        "id": 247509405,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627502286
    },
    {
        "content": "<p>This seems to interact at least a little with the \"better literals\" story that has been lurking in the background for a while.</p>",
        "id": 247510877,
        "sender_full_name": "Lokathor",
        "timestamp": 1627503005
    },
    {
        "content": "<p>Ideally we'd someday be able to write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">k</span>: <span class=\"nc\">NonZeroUsize</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">RangedI32</span><span class=\"o\">&lt;</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// or bikeshed the type name here, the point is that \"6\" becomes a valid instance.</span>\n</code></pre></div>",
        "id": 247511096,
        "sender_full_name": "Lokathor",
        "timestamp": 1627503123
    },
    {
        "content": "<p>Having language/syntactical integration with ranged/nonzero integers would be ideal, but when I brought it up before it was desired to have some experimentation in crates first. Both myself and <span class=\"user-mention\" data-user-id=\"360486\">@Kestrer</span> have created crates that do this with extremely similar APIs.</p>",
        "id": 247511201,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627503176
    },
    {
        "content": "<p>I'm not clear on what whoever asked for that wanted the crates to experiment about, since crates can't just decide for themselves that literals mean new things.</p>",
        "id": 247511659,
        "sender_full_name": "Lokathor",
        "timestamp": 1627503427
    },
    {
        "content": "<p>I think there <em>is</em> value in being able to have the equivalent of a u7 or u24, or an integer that can only be 1-5 but nothing else. But I don't think that should be a gate on the ability to enable the incredibly useful niche optimization.</p>",
        "id": 247511826,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627503507
    },
    {
        "content": "<p>It might make sense to have <code>Ranged</code>. But I don't want that to be the <em>only</em> way to get at the niche-defining attributes.</p>",
        "id": 247511875,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627503538
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> it was more regarding the API itself, not the custom literals. But the API seems quite straightforward imo</p>",
        "id": 247512152,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627503678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  Currently these attributes <em>happen to</em> work on integer newtypes, so they're applied at the struct level. If you don't want it locked to a particular type, are you suggesting that valid range attributes be allowed on single fields within a struct?</p>",
        "id": 247512158,
        "sender_full_name": "Lokathor",
        "timestamp": 1627503679
    },
    {
        "content": "<p><em>Personally</em> I'd be fine with just having a <code>Ranged</code> type, but I would imagine there's use cases for the <code>valid_range_*</code> attributes.</p>",
        "id": 247512282,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627503732
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247512158\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span>  Currently these attributes <em>happen to</em> work on integer newtypes, so they're applied at the struct level. If you don't want it locked to a particular type, are you suggesting that valid range attributes be allowed on single fields within a struct?</p>\n</blockquote>\n<p>Long-term, I'd ideally love to have them apply to fields, but if that's problematic or difficult, I'd also be fine with saying they only apply to one-field (or one-non-ZST-field) types.</p>",
        "id": 247512570,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627503892
    },
    {
        "content": "<p>if they do only apply to one-field structs that seems to be so close to just having a Ranged type that it's fine, isn't it?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[valid_range(3, 7)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ExampleA</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ExampleB</span><span class=\"p\">(</span><span class=\"n\">Ranged</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 247512993,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504143
    },
    {
        "content": "<p>if you can put a range on any field within a struct that would be significantly different of course</p>",
        "id": 247513142,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504215
    },
    {
        "content": "<p>With ExampleA, I can pass <code>some_a.0</code> to something expecting a <code>u32</code>, or do <code>some_a.0 &lt;&lt; 3 | 1</code> to construct a bitfield.</p>",
        "id": 247513152,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627504222
    },
    {
        "content": "<p>I can't do that with ExampleB.</p>",
        "id": 247513166,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627504226
    },
    {
        "content": "<p>With ExampleB, I'd expect to see a <em>lot</em> of <code>u32::from</code> calls in my code...</p>",
        "id": 247513221,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627504258
    },
    {
        "content": "<p>(Or in practice I'd probably provide an <code>.as_u32()</code> method for simple postfix syntax.)</p>",
        "id": 247513273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627504287
    },
    {
        "content": "<p>Wouldn't it just be something like <code>b.0.get()</code>?</p>",
        "id": 247513286,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504296
    },
    {
        "content": "<p>yeah, a postfix call</p>",
        "id": 247513312,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504309
    },
    {
        "content": "<p>That would certainly help.</p>",
        "id": 247513486,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627504409
    },
    {
        "content": "<p>So in my mind what this comes down to is that: right now if you name a field you can read or write it. If there's \"the same type but with a range on it\" then sometimes you'll name a field but not be able write to it, or the write will implicitly have a check that can panic or something.</p>",
        "id": 247513623,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504470
    },
    {
        "content": "<p>(assuming isn't not through a shared reference, yada yada, i think you probably know what i mean)</p>",
        "id": 247513680,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504504
    },
    {
        "content": "<p>one answer to this would be to allow an implicit one-way conversion so that Ranged&lt;Number&gt; will implicitly convert to Number as necessary, so that it can still participate in math expressions without too much cruft</p>",
        "id": 247514110,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504730
    },
    {
        "content": "<p>I don't think we want to add any more <em>implicit</em> coercions. <code>.get()</code> seems reasonable enough to make it easy to do math and similar on these.</p>",
        "id": 247514285,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627504824
    },
    {
        "content": "<p>(It's not <em>quite</em> as convenient as <code>.0</code>, but it seems good enough.)</p>",
        "id": 247514411,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627504886
    },
    {
        "content": "<p>That is what the non-zero types use already, and it mostly works</p>",
        "id": 247514432,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504892
    },
    {
        "content": "<p>and if we want better literal support, that's a discussion so big that we should start it yesterday and it might be ready for the 2027 edition</p>",
        "id": 247514661,
        "sender_full_name": "Lokathor",
        "timestamp": 1627504995
    },
    {
        "content": "<p>I don't think there's anything that would actually preclude literals for compiler-provided types being introduced in a normal release, unless I'm missing something?</p>",
        "id": 247515094,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627505194
    },
    {
        "content": "<p>*numeric literals</p>",
        "id": 247515126,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627505210
    },
    {
        "content": "<p>From a strict syntax standpoint, it basically falls into the \"allowing a program that wasn't valid before\" bucket.</p>\n<p>but from a bikeshed standpoint</p>",
        "id": 247516103,
        "sender_full_name": "Lokathor",
        "timestamp": 1627505737
    },
    {
        "content": "<p>which is allowed, no?</p>",
        "id": 247516332,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627505836
    },
    {
        "content": "<p>yeah, allowing additional programs that weren't valid before is generally allowed. (unless you really upset previous assumptions, like allowing Drop on Copy types)</p>",
        "id": 247516474,
        "sender_full_name": "Lokathor",
        "timestamp": 1627505890
    },
    {
        "content": "<p>there's edge cases (such as automatic formatting captures), but this wouldn't be one of them in any way i can think.</p>",
        "id": 247516580,
        "sender_full_name": "Lokathor",
        "timestamp": 1627505942
    },
    {
        "content": "<p>Note that we can \"just\" make the field of <code>NonZero</code>public. Then you get the <code>.0</code> field access convenience, but writing is unsafe</p>",
        "id": 247585137,
        "sender_full_name": "oli",
        "timestamp": 1627566452
    },
    {
        "content": "<p>read-only-public would be perfect for such fields, I guess (<a href=\"https://internals.rust-lang.org/t/pre-rfc-read-only-visibility/11280\">https://internals.rust-lang.org/t/pre-rfc-read-only-visibility/11280</a>)</p>",
        "id": 247589251,
        "sender_full_name": "krdln",
        "timestamp": 1627568352
    },
    {
        "content": "<p>Opened an issue for read-only-public fields since I couldn't find one: <a href=\"https://github.com/rust-lang/rfcs/issues/3157\">https://github.com/rust-lang/rfcs/issues/3157</a></p>",
        "id": 247625373,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627584683
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247288849\">said</a>:</p>\n<blockquote>\n<p>Is there any reason these attributes couldn't be exposed to end users in some form (naturally under a different name)?</p>\n</blockquote>\n<p>Personally I'm not a fan of the two-attributes form.  Ideally I'd like to see it as something that integrates better with const generics -- that seems like an obvious desire to use with this, but I'm never a fan of putting locals or paths into attributes since scoping and name lookup and types and autocomplete and such are all weird.</p>\n<p>Now that const generics exist, I'd be tempted to move this away from attributes and into \"real\" types.  So we could have <code>I32&lt;4, i32::MAX&gt;</code> or similar.</p>\n<p>(The attributes don't seem to make sense on things like structs anyway.)</p>",
        "id": 247823448,
        "sender_full_name": "scottmcm",
        "timestamp": 1627764561
    },
    {
        "content": "<p>Possibly way overkill: <code>type u16 = U16&lt;0, 65535&gt;;</code></p>\n<p>And allow subtyping.</p>",
        "id": 247823510,
        "sender_full_name": "scottmcm",
        "timestamp": 1627764669
    },
    {
        "content": "<p>I'd prefer that as well to be honest. I should probably write a pre-RFC at some point.</p>",
        "id": 247878704,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627854438
    },
    {
        "content": "<p>It could use the attributes internally. That would just mean accepting any const value as opposed to literals only for the attribute.</p>",
        "id": 247878754,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627854486
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247823510\">said</a>:</p>\n<blockquote>\n<p>Possibly way overkill: <code>type u16 = U16&lt;0, 65535&gt;;</code></p>\n</blockquote>\n<p>yes please</p>",
        "id": 247910939,
        "sender_full_name": "oli",
        "timestamp": 1627904047
    },
    {
        "content": "<p>you get into bootstrap problems with that, but hell it would be cool</p>",
        "id": 247910972,
        "sender_full_name": "oli",
        "timestamp": 1627904065
    },
    {
        "content": "<p>like we'd need \"user defined\" literals first</p>",
        "id": 247911000,
        "sender_full_name": "oli",
        "timestamp": 1627904091
    },
    {
        "content": "<p>and defining the range would be super weird, as you'd be defining it in terms of itself</p>",
        "id": 247911034,
        "sender_full_name": "oli",
        "timestamp": 1627904116
    },
    {
        "content": "<p>but the builtin integers being well <em>builtin</em> can make this work out without cycle errors</p>",
        "id": 247911046,
        "sender_full_name": "oli",
        "timestamp": 1627904134
    },
    {
        "content": "<p>Seems similar to « Add for u16 » being implemented with « + », built in types solve that</p>",
        "id": 247911216,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1627904272
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247823510\">said</a>:</p>\n<blockquote>\n<p>Possibly way overkill: <code>type u16 = U16&lt;0, 65535&gt;;</code></p>\n</blockquote>\n<p>Possibly way way overkill: <code>type u16 = FixedSizeNumeric&lt;2, UNSIGNED, 0..=65535&gt;;</code></p>",
        "id": 247932001,
        "sender_full_name": "bstrie",
        "timestamp": 1627917595
    },
    {
        "content": "<p>what's the 2?</p>",
        "id": 247938833,
        "sender_full_name": "Lokathor",
        "timestamp": 1627921665
    },
    {
        "content": "<p>2 bytes?</p>",
        "id": 247938890,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627921685
    },
    {
        "content": "<p>You can't make <code>FixedSizeNumeric&lt;2, UNSIGNED, 0..=9&gt;</code> be the same type as <code>FixedSizeNumeric&lt;2, UNSIGNED, 0..10&gt;</code> though</p>",
        "id": 247945025,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1627924809
    },
    {
        "content": "<p>we could add a normalization trait that normalizes the type to a single representation</p>",
        "id": 247946475,
        "sender_full_name": "oli",
        "timestamp": 1627925570
    },
    {
        "content": "<p>and yet it wouldn't work for char</p>",
        "id": 247946592,
        "sender_full_name": "The 8472",
        "timestamp": 1627925613
    },
    {
        "content": "<p>sure, but we don't need to support <em>every</em> use case from the get go</p>",
        "id": 247946871,
        "sender_full_name": "oli",
        "timestamp": 1627925745
    },
    {
        "content": "<p>even if we had an all powerful feature later, we'd want a convenient easy API in the spirit of <code>U16&lt;10, 20&gt;</code></p>",
        "id": 247946919,
        "sender_full_name": "oli",
        "timestamp": 1627925770
    },
    {
        "content": "<p>and we can always rewrite those in the more powerful API later if/when that comes</p>",
        "id": 247946948,
        "sender_full_name": "oli",
        "timestamp": 1627925792
    },
    {
        "content": "<p>I don't think I've seen anyone mention what should happen when the number exceeds its range. for <code>let x: U16&lt;10, 20&gt; = 15;</code>, what does <code>x + x</code> do? normal overflow rules, where it panics in debug and \"wraps\" (i.e. just proceeds) in release?</p>",
        "id": 247950155,
        "sender_full_name": "bstrie",
        "timestamp": 1627927416
    },
    {
        "content": "<p>or are people actually proposing full-fledged dependent types, where an operation like this would refuse to compile?</p>",
        "id": 247950258,
        "sender_full_name": "bstrie",
        "timestamp": 1627927460
    },
    {
        "content": "<p>I would expect that to be treated the same as 250u8 + 250u8.</p>",
        "id": 247954592,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627929896
    },
    {
        "content": "<p>Runtime overflow. Optional compile-time warning <em>if</em> the compiler happens to detect it statically, but no guarantees.</p>",
        "id": 247954634,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627929914
    },
    {
        "content": "<p>yeah it would just overflow and wrap around</p>",
        "id": 247959970,
        "sender_full_name": "Lokathor",
        "timestamp": 1627932454
    },
    {
        "content": "<p>these weird types aren't gonna be the slightest bit efficient, but you go get what you asked for at least.</p>",
        "id": 247960098,
        "sender_full_name": "Lokathor",
        "timestamp": 1627932498
    },
    {
        "content": "<p>with these semantics I don't see why they would be any more or less efficient than the normal numeric types, unless you were expecting that <code>U64&lt;999_999_999_998, 999_999_999_999&gt;</code> would only take up a single byte or something</p>",
        "id": 247961354,
        "sender_full_name": "bstrie",
        "timestamp": 1627933039
    },
    {
        "content": "<p>figuring out how to do wraparound correctly for <code>100</code> when the type is valid only for <code>37..42</code> seems like some messy modular arithmetic</p>",
        "id": 247961555,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933133
    },
    {
        "content": "<p>not sure exactly what wraparound means when the type is <code>37..37</code> though</p>",
        "id": 247961622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933177
    },
    {
        "content": "<p>I don't think it should literally wrap around, I think it should just... do it. if you have <code>x: U16&lt;10, 20&gt; = 15</code>, then <code>x + x</code> is 30, not 20</p>",
        "id": 247961625,
        "sender_full_name": "bstrie",
        "timestamp": 1627933179
    },
    {
        "content": "<p>but that is type incorrect</p>",
        "id": 247961699,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933206
    },
    {
        "content": "<p>that would be like having a bool that has 3 in it</p>",
        "id": 247961713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933217
    },
    {
        "content": "<p>oh right, you wanted to use these for niches</p>",
        "id": 247961740,
        "sender_full_name": "bstrie",
        "timestamp": 1627933226
    },
    {
        "content": "<p>also I think it would be 10, not 20</p>",
        "id": 247961807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933283
    },
    {
        "content": "<p>might as well just saturate at that point and avoid wrapping :P</p>",
        "id": 247961813,
        "sender_full_name": "bstrie",
        "timestamp": 1627933287
    },
    {
        "content": "<p>I can't imagine anyone wanting such bizarre wrapping types in the general case</p>",
        "id": 247961993,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933364
    },
    {
        "content": "<p>actually I think they should just not have <code>+</code></p>",
        "id": 247962083,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933411
    },
    {
        "content": "<p>and only provide checked_add?</p>",
        "id": 247962117,
        "sender_full_name": "bstrie",
        "timestamp": 1627933433
    },
    {
        "content": "<p>adding a regular integer would make sense with either checked add or panic add</p>",
        "id": 247962276,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933508
    },
    {
        "content": "<p>adding two bounded integers seems like a place you want fancy dependent types</p>",
        "id": 247962353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933543
    },
    {
        "content": "<p>as in <code>x + y: U16&lt;A + B, C + D&gt;</code> where <code>x: U16&lt;A, C&gt;</code> and <code>y: U16&lt;B, D&gt;</code></p>",
        "id": 247962489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933610
    },
    {
        "content": "<p>lots of issues there though</p>",
        "id": 247962505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627933615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247961622\">said</a>:</p>\n<blockquote>\n<p>not sure exactly what wraparound means when the type is <code>37..37</code> though</p>\n</blockquote>\n<p>I'd say a type with a range of <code>37..37</code> should just be an uninhabited type, like <code>!</code> or an <code>enum</code> with no variants.</p>",
        "id": 247963191,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627933967
    },
    {
        "content": "<p>I think a good idea might be to initially just not implement <code>Add</code> for bounded-integer types, we can add implementations later once const generics are good enough to give the result type we want.</p>",
        "id": 247963493,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627934143
    },
    {
        "content": "<p>similar to what happened with the non-zero types.</p>",
        "id": 247963606,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627934204
    },
    {
        "content": "<p>looking at the deranged crate mentioned by OP, it doesn't impl Add for its types</p>",
        "id": 247963687,
        "sender_full_name": "bstrie",
        "timestamp": 1627934265
    },
    {
        "content": "<p>we might be getting off-topic, if the goal is to stabilize something that lets users specify their own niches, are there any types besides numerics that would want to use this? if so, then only providing ranged numeric types might not be enough</p>",
        "id": 247964441,
        "sender_full_name": "bstrie",
        "timestamp": 1627934619
    },
    {
        "content": "<p>For composite objects I think you can usually express any niches in terms of niches on the fields</p>",
        "id": 247964557,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627934674
    },
    {
        "content": "<p>so I think it does actually just boil down to bounded integral types, unless you want to consider other kinds of predicates like even integers</p>",
        "id": 247964620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1627934721
    },
    {
        "content": "<p>if eddyb thinks that supporting non-contiguous niche ranges isn't worth it, then that's good enough for me :P</p>",
        "id": 247965420,
        "sender_full_name": "bstrie",
        "timestamp": 1627935144
    },
    {
        "content": "<p>supporting things like even integers will be useful since it lets us express <code>(&amp;u16, i1)</code> all packed into one <code>usize</code>, since <code>&amp;u16</code> is known to be even and the <code>i1</code> can be stored in the lowest bit.</p>",
        "id": 247969930,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627937513
    },
    {
        "content": "<p>I think ranged integers are on-topic, tho the topic name could probably be changed. deranged intentionally does not implement <code>Add</code> and other arithmetic operations. With full const generics, I'd like to have the min and max added (and likewise for <code>Sub</code>, <code>Mul</code>, and <code>Div</code>). imo the bigger problem would be figuring out inter-conversions, like <code>int&lt;200, 250&gt; + int&lt;200, 250&gt;</code> would have to convert from <code>u8 + u8</code> to a <code>u16</code> internally.</p>",
        "id": 247971709,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1627938483
    },
    {
        "content": "<blockquote>\n<p>since &amp;u16 is known to be even</p>\n</blockquote>\n<p>Well yeah, but that should be implemented in the compiler, so it doesn't need a special even-integers type.</p>",
        "id": 247976895,
        "sender_full_name": "The 8472",
        "timestamp": 1627941587
    },
    {
        "content": "<blockquote>\n<p>supporting things like even integers will be useful since it lets us express <code>(&amp;u16, i1)</code> all packed into one <code>usize</code>, since <code>&amp;u16</code> is known to be even and the <code>i1</code> can be stored in the lowest bit.</p>\n</blockquote>\n<p>Not necessarily. IIRC, rust uses the abi mandated alignment, which could be 1 on some platform. There isn't any requirement I've seen that scalar types have alignment match their size. Also that can't be packed anyways, since you can read and write the &amp;u16 via references.</p>",
        "id": 247979220,
        "sender_full_name": "Connor Horman",
        "timestamp": 1627943372
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247976895\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>since &amp;u16 is known to be even</p>\n</blockquote>\n<p>Well yeah, but that should be implemented in the compiler, so it doesn't need a special even-integers type.</p>\n</blockquote>\n<p>I guess I meant known-even integers would be useful for things like where <code>a: &amp;u16</code>: <code>a as *const u16 as EvenUsize</code>, except that the type should be more general than <code>EvenUsize</code></p>",
        "id": 247979233,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627943390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/.23.5Brustc_layout_scalar_valid_range_start.5D/near/247979220\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>supporting things like even integers will be useful since it lets us express <code>(&amp;u16, i1)</code> all packed into one <code>usize</code>, since <code>&amp;u16</code> is known to be even and the <code>i1</code> can be stored in the lowest bit.</p>\n</blockquote>\n<p>Not necessarily. IIRC, rust uses the abi mandated alignment, which could be 1 on some platform. There isn't any requirement I've seen that scalar types have alignment match their size. Also that can't be packed anyways, since you can read and write the &amp;u16 via references.</p>\n</blockquote>\n<p>that can be fixed with <code>#[bitpacked] struct S&lt;'a&gt;(&amp;'a u16, i1)</code> on all normal platforms where <code>u16</code> has alignment 2</p>",
        "id": 247979382,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627943507
    },
    {
        "content": "<p>I don't find the \"all even numbers\" example compelling. Ranged integers are useful for correctness, and enabling niche optimizations is a nice cherry on top, but I don't think we should go around packing integers like that. If libraries want to do so, then they can build that on top of ranged integers</p>",
        "id": 248242626,
        "sender_full_name": "bstrie",
        "timestamp": 1628006850
    },
    {
        "content": "<p>Several libraries (including LLVM and clang) have the previously mentioned packing extra things into the pointer's LSB bits optimization, since it saves a bunch of space (50% in some cases). If one were to try to express the ranges needed for an integer with LSB bits that are zero, basically anything larger than <code>u8</code> would be prohibitively expensive in compile time since a <code>u32</code> with the lower 3 bits set to zero would need 536870912 separate ranges to express, hence why I think the compiler should eventually provide more efficient support for that.</p>",
        "id": 248262459,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628016450
    },
    {
        "content": "<p>that has to be a separate feature from what we're considering here, a library can't store arbitrary data in a niche</p>",
        "id": 248269222,
        "sender_full_name": "bstrie",
        "timestamp": 1628019453
    },
    {
        "content": "<p>yea, niches for ranges and niches for specific bit masks seem like two separate features that could get their own support each</p>",
        "id": 248349280,
        "sender_full_name": "oli",
        "timestamp": 1628083631
    }
]