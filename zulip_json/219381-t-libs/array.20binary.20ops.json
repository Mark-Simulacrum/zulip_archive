[
    {
        "content": "<p>Previously I was playing around with doing binary element-wise ops on arrays (Add, Mul etc). For simple code, I had experimented with a combination of <code>a.zip(b).map(|(a, b)| a + b)</code>, but I noticed that this code <a href=\"https://godbolt.org/z/WMxvTvrjv\">doesn't like to optimise well</a>.</p>\n<p>I started to work on an alternative impl that optimises to an equivalent hand written for loop (or faster by utilising uninit), and providing fast paths and slow paths depending on whether drops are required or not. You can find that here: <a href=\"https://github.com/conradludgate/array-bin-ops\">https://github.com/conradludgate/array-bin-ops</a></p>\n<p>I'm wondering if this addition would be appreciated to be added back into core (under some <code>.zip_map</code> func). It also improves regular zip by proxy.</p>\n<p>It obviously adds more maintenance and unsafe overhead, so I would understand if it's not worth it. I haven't yet done proper benchmarks, I've mostly been optimising it to reduce the raw asm instructions, which I know isn't the best metric</p>",
        "id": 273337644,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1645878186
    },
    {
        "content": "<p>Well... just ran a benchmark and it's quite conclusive. I took a slice of 512 i32s, and did a reduce sum over array_chunks of 32.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code>#<span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">nightly</span><span class=\"w\"> </span><span class=\"n\">zip</span><span class=\"w\"> </span><span class=\"n\">then</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"></span>\n<span class=\"n\">zip</span><span class=\"o\">+</span><span class=\"n\">map32</span><span class=\"w\">               </span><span class=\"n\">time</span>:   <span class=\"p\">[</span><span class=\"mf\">1.3415</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"mf\">1.3428</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"w\"> </span><span class=\"mf\">1.3441</span><span class=\"w\"> </span><span class=\"n\">us</span><span class=\"p\">]</span><span class=\"w\"></span>\n\n#<span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">my</span><span class=\"w\"> </span><span class=\"n\">zip_map</span><span class=\"w\"> </span><span class=\"n\">method</span><span class=\"w\"></span>\n<span class=\"n\">zip_map32</span><span class=\"w\">               </span><span class=\"n\">time</span>:   <span class=\"p\">[</span><span class=\"mf\">115.97</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"mf\">116.16</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"w\"> </span><span class=\"mf\">116.36</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which is 11.5x faster!</p>",
        "id": 273346852,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1645889324
    },
    {
        "content": "<p>Source: <a href=\"https://github.com/conradludgate/array-bin-ops/blob/main/benches/sum.rs\">https://github.com/conradludgate/array-bin-ops/blob/main/benches/sum.rs</a><br>\nRunning on a modern AMD x86 Ryzen desktop processor on Linux.<br>\nI'll also run it on my M1 Macbook later in the day to see if performance is good on arm too</p>",
        "id": 273347264,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1645889736
    },
    {
        "content": "<p>Unfortunately it's just true in general that chaining array methods seems to optimize poorly.  To the extent that it's unclear how many operations make sense to provide on it, vs finding a better way.  Like maybe it needs an iterator-like chaining mechanism for building arrays -- maybe literally iterators with some smart way to turn them into arrays, who knows.</p>\n<p>But you can probably just send a PR for <code>zip_with</code> if you want.  <code>zip</code> is unstable too (<a href=\"https://github.com/rust-lang/rust/issues/80094\">#80094</a>), so it's a small addition that wouldn't be a big deal to add.  After all, it can always just be removed again later if libs-api decides it's unwanted.  That said, anything that duplicates the array building unsafe code is probably not going to be accepted from an implementation perspective, so you'll need to find a way to merge your improvements with what core is already doing, not just copy-paste wholesale.</p>\n<p>I'll note that skipping zip+map and just using <code>from_fn</code> gives something much better: &lt;<a href=\"https://rust.godbolt.org/z/Yb66hfMcr\">https://rust.godbolt.org/z/Yb66hfMcr</a>&gt;</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(array_from_fn)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">add_i64x32</span><span class=\"p\">(</span><span class=\"n\">lhs</span>: <span class=\"p\">[</span><span class=\"kt\">i64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">rhs</span>: <span class=\"p\">[</span><span class=\"kt\">i64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"kt\">i64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">array</span>::<span class=\"n\">from_fn</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">i</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">lhs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">rhs</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>How much of your improvement is just from skipping the drop guards for <code>!needs_drop</code> types?  As a first PR, you might experiment with just adding a \"<code>T</code> isn't <code>needs_drop</code> so we can skip the guard\" path in <a href=\"https://github.com/rust-lang/rust/blob/8c9640e34c73dc45bfd38eca49fa1405b11b6cae/library/core/src/array/mod.rs#L793-L856\">https://github.com/rust-lang/rust/blob/8c9640e34c73dc45bfd38eca49fa1405b11b6cae/library/core/src/array/mod.rs#L793-L856</a></p>",
        "id": 273350496,
        "sender_full_name": "scottmcm",
        "timestamp": 1645893711
    },
    {
        "content": "<p>using iterator methods and collecting into a vec yields decent assembly. so as usual we're lacking a way to collect into arrays</p>",
        "id": 273350799,
        "sender_full_name": "The 8472",
        "timestamp": 1645894086
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/81615\">#81615</a></p>",
        "id": 273350810,
        "sender_full_name": "The 8472",
        "timestamp": 1645894114
    },
    {
        "content": "<p>I mean at the risk of self-promotion, this is basically what std::simd will be for. &lt;_&lt;</p>",
        "id": 273357782,
        "sender_full_name": "Jubilee",
        "timestamp": 1645902888
    },
    {
        "content": "<p>Well, i think I'll still make a PR. I had already started on it before and I think i mostly got it to fit into the existing <code>Iter</code> based impl</p>",
        "id": 273362066,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1645908392
    },
    {
        "content": "<p>Another thing that might be worth trying is changing the loop in that method to be <code>for i in 0..N</code> instead of being a loop on the iterator.  I thought there was a PR recently that said that improved the codegen, though I'm currently failing to find it.</p>",
        "id": 273365222,
        "sender_full_name": "scottmcm",
        "timestamp": 1645912748
    }
]