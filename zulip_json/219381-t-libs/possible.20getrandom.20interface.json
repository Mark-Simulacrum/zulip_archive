[
    {
        "content": "<p>Brought up in the 2022 roadmap as likely to be a smaller addition.<br>\nI think it would be beneficial to prefer the non-blocking form for this?<br>\nIs a non-blocking getrandom-like function valid on the Big Three?</p>",
        "id": 272440256,
        "sender_full_name": "Jubilee",
        "timestamp": 1645209546
    },
    {
        "content": "<p>Non-blocking as in asynchronous? Or as in, \"doesn't do blocking I/O\"</p>",
        "id": 272441215,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645210007
    },
    {
        "content": "<p>I think the stdlib having <code>async fn get_random</code> would be pretty annoying in practice. A very large portion of the time I need entropy I'm not already in an async function.</p>",
        "id": 272441312,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645210067
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272441215\">said</a>:</p>\n<blockquote>\n<p>Non-blocking as in asynchronous? Or as in, \"doesn't do blocking I/O\"</p>\n</blockquote>\n<p>Not async. The Linux-y version which I think is also POSIX-y? allows you to use a flag when invoking it and then if there's not enough entropy in the system to service the request it fails fast instead of blocking.</p>",
        "id": 272441417,
        "sender_full_name": "Jubilee",
        "timestamp": 1645210109
    },
    {
        "content": "<p>In practical cases, from the <strong>user</strong> perspective, it should have effectively 0 difference since the function should return a Result anyways (probably because it implements Read?) and they should be handling the cases where it doesn't return the value they want. Even if it's just \"okay I'll busy-wait until there is.\"</p>",
        "id": 272441794,
        "sender_full_name": "Jubilee",
        "timestamp": 1645210348
    },
    {
        "content": "<p>I believe it is the other way around. The default blocks if there is not enough entropy and there is a flag to return immediately if there is not enough entropy.</p>",
        "id": 272442031,
        "sender_full_name": "bjorn3",
        "timestamp": 1645210493
    },
    {
        "content": "<p>yeah, I think that's the case. I just suspect that our default should be to use the flag.<br>\nThe interface is still \"sync\" in both cases.</p>",
        "id": 272442115,
        "sender_full_name": "Jubilee",
        "timestamp": 1645210548
    },
    {
        "content": "<p>I don't think so. People likely are going to handle the not enough entropy case incorrectly. For this reason for example fuchsia never returns an error from the random number syscall. It always blocks or I think crashes the target process.</p>",
        "id": 272442270,
        "sender_full_name": "bjorn3",
        "timestamp": 1645210630
    },
    {
        "content": "<p>kaboom.</p>",
        "id": 272442333,
        "sender_full_name": "Jubilee",
        "timestamp": 1645210675
    },
    {
        "content": "<p><a href=\"https://fuchsia.dev/fuchsia-src/reference/syscalls/cprng_draw\">https://fuchsia.dev/fuchsia-src/reference/syscalls/cprng_draw</a>: It terminates the process if the provided buffer pointer is not valid. It doesn't return an error in any other case. According to <a href=\"https://fuchsia.dev/fuchsia-src/concepts/kernel/cprng\">https://fuchsia.dev/fuchsia-src/concepts/kernel/cprng</a> it may block during initial seeding but doesn't block afterwards.</p>",
        "id": 272442843,
        "sender_full_name": "bjorn3",
        "timestamp": 1645210849
    },
    {
        "content": "<p>Blocking during initial seeding and never afterwards is what linux is moving to (or has already moved to) I believe.</p>",
        "id": 272442910,
        "sender_full_name": "bjorn3",
        "timestamp": 1645210874
    },
    {
        "content": "<p>Has moved to in 5.6.</p>",
        "id": 272443694,
        "sender_full_name": "Hans Kratz",
        "timestamp": 1645211273
    },
    {
        "content": "<p>Hm, if we expose it through a Read implementation then that would raise the question of whether Read is being handled correctly at all.<br>\nThough read_exact could attempt to block.</p>",
        "id": 272443857,
        "sender_full_name": "Jubilee",
        "timestamp": 1645211369
    },
    {
        "content": "<p>That caused a problem in early-boot though. systemd then had to switch to a non-blocking, best-effort call that was needed to generate UUIDs where low-quality randomness is acceptable</p>",
        "id": 272446380,
        "sender_full_name": "The 8472",
        "timestamp": 1645212631
    },
    {
        "content": "<p>In linux &gt;=4.8 , if <code>/dev/random</code> blocks, then it generally hasn't been seeded and the user may wish to wait. After initial seeding <code>/dev/urandom</code> can be used which never blocks. <a href=\"https://www.2uo.de/myths-about-urandom/#whats-wrong-with-blocking\">https://www.2uo.de/myths-about-urandom/#whats-wrong-with-blocking</a>  <br>\nThe <code>getrandom</code> crate chooses to always blocks</p>",
        "id": 272446674,
        "sender_full_name": "lyinch",
        "timestamp": 1645212782
    },
    {
        "content": "<p>I think we're talking about the getrandom syscall since that doesn't assume acccess to the filesystem, not the /dev devices</p>",
        "id": 272446789,
        "sender_full_name": "The 8472",
        "timestamp": 1645212843
    },
    {
        "content": "<p><a href=\"https://man7.org/linux/man-pages/man2/getrandom.2.html\">https://man7.org/linux/man-pages/man2/getrandom.2.html</a></p>",
        "id": 272446851,
        "sender_full_name": "The 8472",
        "timestamp": 1645212884
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 272447410,
        "sender_full_name": "Jubilee",
        "timestamp": 1645213219
    },
    {
        "content": "<p>Possibly relevant, (esp. for background): <a href=\"https://lwn.net/SubscriberLink/884875/58f88e6eb7913686/\">Uniting the Linux random-number devices</a></p>",
        "id": 272447551,
        "sender_full_name": "Chris Denton",
        "timestamp": 1645213288
    },
    {
        "content": "<p>Thinking about it, \"don't wait\" vs. \"wait\" actually mirrors the semantics of <code>read</code> vs <code>read_exact</code>.</p>",
        "id": 272447639,
        "sender_full_name": "Jubilee",
        "timestamp": 1645213324
    },
    {
        "content": "<p>The idea that we can't have an error case at all because users might write bad error handling code is probably not a good one to lean on too much. We have a Result type for a reason, and if you can't trust the user to interact with that then <em>most of the standard library</em> goes up in smoke.</p>",
        "id": 272447703,
        "sender_full_name": "Lokathor",
        "timestamp": 1645213365
    },
    {
        "content": "<p>Also C code doesn't ever <strong>have</strong> to interact with a Result type, Rust code is more obnoxious to avoid that case in.</p>",
        "id": 272447890,
        "sender_full_name": "Jubilee",
        "timestamp": 1645213476
    },
    {
        "content": "<p>We could provide a function <code>f() -&gt; Result&lt;[u8; N], RandSourceError&gt;</code> and then be confident that the user would be absolutely have to handle the error somehow.</p>",
        "id": 272448081,
        "sender_full_name": "Lokathor",
        "timestamp": 1645213590
    },
    {
        "content": "<p>Also true.</p>",
        "id": 272448155,
        "sender_full_name": "Jubilee",
        "timestamp": 1645213640
    },
    {
        "content": "<p>If you don't handle short reads on <code>Read</code> then all kinds of things will go wrong, not just your crypto.</p>",
        "id": 272448428,
        "sender_full_name": "The 8472",
        "timestamp": 1645213785
    },
    {
        "content": "<p>should the <code>GRND_NONBLOCK</code> flag be allowed to control the blocking behaviour?</p>",
        "id": 272448458,
        "sender_full_name": "lyinch",
        "timestamp": 1645213800
    },
    {
        "content": "<p>aiui <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> suggested to make that flag implicit in the read vs. read_exact distinction</p>",
        "id": 272448649,
        "sender_full_name": "The 8472",
        "timestamp": 1645213900
    },
    {
        "content": "<p>I.e. have <code>impl Read for Random</code> implement both methods.</p>",
        "id": 272448702,
        "sender_full_name": "The 8472",
        "timestamp": 1645213923
    },
    {
        "content": "<p>Yes.<br>\nIt at the very least feels obvious to me that we want to make something equivalent to nonblocking randomness <strong>accessible</strong> for the very likely case that someone is writing a filesystem or init daemon or even, yes, a kernel, or just honestly doesn't care much, and then probably make another for the \"block until entropy available\" approach.</p>",
        "id": 272448819,
        "sender_full_name": "Jubilee",
        "timestamp": 1645213988
    },
    {
        "content": "<blockquote>\n<p>If you don't handle short reads on <code>Read</code> then all kinds of things will go wrong, not just your crypto.</p>\n</blockquote>\n<p>Yes, but in practice theres a lot of code in the wild that doesn't handle short reads on <code>Read</code> correctly, and just relies on things happening to work out most of the time. A function returning a <code>Result&lt;[u8; N], Error&gt;</code> would avoid this though, at the cost of some copying.</p>",
        "id": 272448993,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214085
    },
    {
        "content": "<p>it usually will fully fill the buffer if they ask for a reasonable-sized buffer but also someone out there will be like eh, \"16 bytes is good enough, I'm just seeding my game state, not writing crypto, here.\"</p>",
        "id": 272449007,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214089
    },
    {
        "content": "<p>Perhaps an unreasonable amount of copying</p>",
        "id": 272449017,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214095
    },
    {
        "content": "<p>and it would be annoying to use to populate a vec with a dynamic amount of entropy</p>",
        "id": 272449059,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214117
    },
    {
        "content": "<p>(so to be clear, i'm not sure i'm in favor of it)</p>",
        "id": 272449123,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214148
    },
    {
        "content": "<p>If it's like a video game or something I'd <em>like</em> good randomness, but I can also get bad randomness a number of ways if I have to. So not blocking and just letting me have an error and then i can go to a backup is fine.</p>",
        "id": 272449246,
        "sender_full_name": "Lokathor",
        "timestamp": 1645214198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272448993\">said</a>:</p>\n<blockquote>\n<p>Yes, but in practice theres a lot of code in the wild that doesn't handle short reads on <code>Read</code> correctly, and just relies on things happening to work out most of the time.</p>\n</blockquote>\n<p><span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span></p>",
        "id": 272449247,
        "sender_full_name": "The 8472",
        "timestamp": 1645214200
    },
    {
        "content": "<p>tbh I have written code like that but only for the impl of Read on an existing <code>[u8]</code>.<br>\nlike<br>\nmany things fall apart if I can't rely on LOAD and STORE working, my fellow crab.</p>",
        "id": 272449410,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214247
    },
    {
        "content": "<p>Yeah ok, but that's not a generic read. You have knowledge that this read impl cannot fail.</p>",
        "id": 272449723,
        "sender_full_name": "The 8472",
        "timestamp": 1645214305
    },
    {
        "content": "<p>yes.</p>",
        "id": 272449889,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  you probably wouldn't want to do that in a video game anyway since it'd involve a syscall. Userspace PRNG would be preferable for a game.</p>",
        "id": 272449997,
        "sender_full_name": "The 8472",
        "timestamp": 1645214364
    },
    {
        "content": "<p>You'd like to seed the PRNG with some higher-quality randomness tho'.</p>",
        "id": 272450037,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214394
    },
    {
        "content": "<p>Yeah, but that's done once at startup</p>",
        "id": 272450107,
        "sender_full_name": "The 8472",
        "timestamp": 1645214408
    },
    {
        "content": "<p>Yeah but that doesn't change my request at all</p>",
        "id": 272450318,
        "sender_full_name": "Lokathor",
        "timestamp": 1645214458
    },
    {
        "content": "<p>I still want \"just error right now and I'll handle it\", not blocking, and certainly not process death.</p>",
        "id": 272450391,
        "sender_full_name": "Lokathor",
        "timestamp": 1645214492
    },
    {
        "content": "<p>process death in fuschia is when you pass an invalid pointer</p>",
        "id": 272450491,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214532
    },
    {
        "content": "<p>not insufficient entropy</p>",
        "id": 272450545,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214569
    },
    {
        "content": "<p>I mentioned a Read impl mostly because <span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> requested it, but I am beginning to wonder if allowing the use of <code>read_to_end</code> on the entropy source is too mischievous. :^)</p>",
        "id": 272450728,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214674
    },
    {
        "content": "<p>assuming it's urandom it would still be fairly fast, no worse than filling something from /dev/urandom</p>",
        "id": 272450804,
        "sender_full_name": "The 8472",
        "timestamp": 1645214717
    },
    {
        "content": "<p>it's essentially a CSPRNG in the kernel that gets reseeded whenever additionally entrop is available.</p>",
        "id": 272450893,
        "sender_full_name": "The 8472",
        "timestamp": 1645214758
    },
    {
        "content": "<p>I mean, true, but draining <strong>all</strong> the entropy in urandom?</p>",
        "id": 272450974,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214772
    },
    {
        "content": "<p>urandom doesn't do that</p>",
        "id": 272451022,
        "sender_full_name": "The 8472",
        "timestamp": 1645214796
    },
    {
        "content": "<p>random does (did?)</p>",
        "id": 272451039,
        "sender_full_name": "The 8472",
        "timestamp": 1645214806
    },
    {
        "content": "<p>hmm.</p>",
        "id": 272451040,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214806
    },
    {
        "content": "<p>Oh, I don't mean about performance, I mean that it would be uh \"unfriendly\" to other guests in the system.</p>",
        "id": 272451118,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214856
    },
    {
        "content": "<p>AIUI urandom effectively doesn't do entropy accounting once it's seeded.</p>",
        "id": 272451220,
        "sender_full_name": "The 8472",
        "timestamp": 1645214913
    },
    {
        "content": "<p>Ahh.</p>",
        "id": 272451251,
        "sender_full_name": "Jubilee",
        "timestamp": 1645214935
    },
    {
        "content": "<p>well...</p>\n<div class=\"codehilite\"><pre><span></span><code>$ dd if=/dev/random bs=1M count=1000 of=/dev/null\n1000+0 records in\n1000+0 records out\n1048576000 bytes (1.0 GB, 1000 MiB) copied, 19.7782 s, 53.0 MB/s\n$ dd if=/dev/urandom bs=1M count=1000 of=/dev/null\n1000+0 records in\n1000+0 records out\n1048576000 bytes (1.0 GB, 1000 MiB) copied, 20.3227 s, 51.6 MB/s\n</code></pre></div>",
        "id": 272451400,
        "sender_full_name": "The 8472",
        "timestamp": 1645215025
    },
    {
        "content": "<p>welp.</p>",
        "id": 272451485,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215095
    },
    {
        "content": "<p>What're the Mac and WIndows CPRNG interfaces like?</p>",
        "id": 272451520,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215119
    },
    {
        "content": "<p>on windows I found this: <a href=\"https://docs.microsoft.com/en-us/windows/win32/seccng/cng-portal\">https://docs.microsoft.com/en-us/windows/win32/seccng/cng-portal</a></p>",
        "id": 272451629,
        "sender_full_name": "lyinch",
        "timestamp": 1645215179
    },
    {
        "content": "<p>The usual windows one is this, IIRC: <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom\">https://docs.microsoft.com/en-us/windows/win32/api/wincrypt/nf-wincrypt-cryptgenrandom</a></p>",
        "id": 272451657,
        "sender_full_name": "scottmcm",
        "timestamp": 1645215201
    },
    {
        "content": "<p>We use <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\"><code>BCryptGenRandom</code></a></p>",
        "id": 272451758,
        "sender_full_name": "Chris Denton",
        "timestamp": 1645215269
    },
    {
        "content": "<p>With a good reseedable XOF there's really no need to worry about output length.  Like it can be a sponge where you add new entropy when available for extra safety.</p>",
        "id": 272451764,
        "sender_full_name": "scottmcm",
        "timestamp": 1645215271
    },
    {
        "content": "<p>on osx there's <code>getentropy</code></p>",
        "id": 272451928,
        "sender_full_name": "lyinch",
        "timestamp": 1645215372
    },
    {
        "content": "<p>Ahhh, that one only allows 256 bytes at a time.</p>",
        "id": 272451972,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215416
    },
    {
        "content": "<p>interestingly, the man page says </p>\n<blockquote>\n<p>The maximum buffer size permitted is 256 bytes</p>\n</blockquote>",
        "id": 272451976,
        "sender_full_name": "lyinch",
        "timestamp": 1645215419
    },
    {
        "content": "<p><a href=\"https://man7.org/linux/man-pages/man3/getentropy.3.html\">https://man7.org/linux/man-pages/man3/getentropy.3.html</a></p>\n<blockquote>\n<p>The maximum permitted value for the length argument is 256.</p>\n</blockquote>",
        "id": 272452125,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215500
    },
    {
        "content": "<p>there seems to be a bit more to it, they also have alternatives</p>\n<blockquote>\n<p>However, it should be noted that getentropy() is primarily intended for use in the construction and seeding of userspace PRNGs like arc4random(3) or CC_crypto(3).  Clients who simply require random data should use arc4random(3), CCRandomGenerateBytes() from CC_crypto(3), or SecRandomCopyBytes() from the Security framework instead of getentropy() or random(4)</p>\n</blockquote>",
        "id": 272452145,
        "sender_full_name": "lyinch",
        "timestamp": 1645215513
    },
    {
        "content": "<p>I'm copying from <code>man getentropy</code> on osx 12.1</p>",
        "id": 272452216,
        "sender_full_name": "lyinch",
        "timestamp": 1645215557
    },
    {
        "content": "<p>Ohh.</p>",
        "id": 272452228,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215563
    },
    {
        "content": "<p>I would hope they don't actually somehow check to see if the buffer is in fact 257 bytes long and just mean they look at the length arg. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 272452350,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215625
    },
    {
        "content": "<p>We could of course wrap a userspace CPRNG around the kernel source. Although that'd mean pulling some crypto lib into std.</p>",
        "id": 272452478,
        "sender_full_name": "The 8472",
        "timestamp": 1645215697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272451758\">said</a>:</p>\n<blockquote>\n<p>We use <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom\"><code>BCryptGenRandom</code></a></p>\n</blockquote>\n<p>Which perhaps causes problems too... <a href=\"https://github.com/rust-lang/rust/issues/94098\">https://github.com/rust-lang/rust/issues/94098</a></p>",
        "id": 272452603,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645215749
    },
    {
        "content": "<p>Sounds like it's limited to some broken systems and could be worked around. That wouldn't be a blocker to providing a std API</p>",
        "id": 272452700,
        "sender_full_name": "The 8472",
        "timestamp": 1645215814
    },
    {
        "content": "<p>i agree</p>",
        "id": 272452723,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645215831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479478\">lyinch</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272452145\">said</a>:</p>\n<blockquote>\n<p>there seems to be a bit more to it, they also have alternatives</p>\n<blockquote>\n<p>However, it should be noted that getentropy() is primarily intended for use in the construction and seeding of userspace PRNGs like arc4random(3) or CC_crypto(3).  Clients who simply require random data should use arc4random(3), CCRandomGenerateBytes() from CC_crypto(3), or SecRandomCopyBytes() from the Security framework instead of getentropy() or random(4)</p>\n</blockquote>\n</blockquote>\n<p>Thank you, this is good to know.</p>",
        "id": 272452929,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215924
    },
    {
        "content": "<p>as for the choice on osx, the <code>getentropy</code> syscall also claims to be a bit more secure and _always_ available</p>\n<blockquote>\n<p>Unlike the random(4) pseudo-devices, it is not vulnerable to file descriptor exhaustion attacks and is available when sandboxed or in a chroot, making it more reliable for security-critical applications.</p>\n</blockquote>",
        "id": 272452937,
        "sender_full_name": "lyinch",
        "timestamp": 1645215931
    },
    {
        "content": "<p>Interesting.</p>",
        "id": 272452963,
        "sender_full_name": "Jubilee",
        "timestamp": 1645215946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272452478\">said</a>:</p>\n<blockquote>\n<p>We could of course wrap a userspace CPRNG around the kernel source.</p>\n</blockquote>\n<p>I think we should just use the OS facility here, and provide access to whatever crypto-XOF the OS does.</p>\n<p>Anyone needing <em>specifically</em> entropy or whatever is doing something specific enough that I think it might even be good for them to use the OS things directly, since the implications on the system of consuming entropy can be bad.</p>",
        "id": 272452985,
        "sender_full_name": "scottmcm",
        "timestamp": 1645215959
    },
    {
        "content": "<p>Ok, then we should document it potentially being terribly slow. Perhaps <code>Read</code> isn't necessary then and <code>Result&lt;[u8; N], Error&gt;</code> is fine.</p>",
        "id": 272453166,
        "sender_full_name": "The 8472",
        "timestamp": 1645216061
    },
    {
        "content": "<p>Yeah, I think we should avoid introducing our own CPRNG here if the OS offers one, and basically say that it's probably for seeding your own higher-quality randomness function.</p>",
        "id": 272453298,
        "sender_full_name": "Jubilee",
        "timestamp": 1645216125
    },
    {
        "content": "<p><code>std::io::Entropy</code>?</p>",
        "id": 272453388,
        "sender_full_name": "bstrie",
        "timestamp": 1645216192
    },
    {
        "content": "<p>And since this would ostensibly be for making <code>rand</code>-like crates easier to write, we should probably ask the rand maintainer(s) what they'd find useful.</p>",
        "id": 272453708,
        "sender_full_name": "Jubilee",
        "timestamp": 1645216306
    },
    {
        "content": "<p>they already offer this in their own <a href=\"https://docs.rs/getrandom/latest/getrandom/\">https://docs.rs/getrandom/latest/getrandom/</a> crate</p>",
        "id": 272453787,
        "sender_full_name": "lyinch",
        "timestamp": 1645216339
    },
    {
        "content": "<p><del>or what they think were mistakes in their getrandom crate's API</del></p>",
        "id": 272453864,
        "sender_full_name": "Jubilee",
        "timestamp": 1645216388
    },
    {
        "content": "<p><code>fn std::rand::seed&lt;const N: usize&gt;() -&gt; Result&lt;[u8; N], Error&gt;</code> might be a way to paint the bikeshed that makes it clear its just for seeding other rngs, and may be very slow</p>",
        "id": 272453889,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645216405
    },
    {
        "content": "<p>Yeah, I was thinking we should say <code>seed</code> somewhere, so that sounds good to me.</p>",
        "id": 272454065,
        "sender_full_name": "Jubilee",
        "timestamp": 1645216504
    },
    {
        "content": "<blockquote>\n<p>There is no blanket implementation on unix targets that reads from /dev/urandom. This ensures all supported targets are using the recommended interface and respect maximum buffer sizes.</p>\n</blockquote>",
        "id": 272454177,
        "sender_full_name": "Jubilee",
        "timestamp": 1645216573
    },
    {
        "content": "<p>there's also a draft rfc from many years ago: <a href=\"https://github.com/dhardy/rfcs/blob/system-random/text/0000-system-random.md\">https://github.com/dhardy/rfcs/blob/system-random/text/0000-system-random.md</a>  . There might be a bunch of issues with discussions which are worth at digging out</p>",
        "id": 272454180,
        "sender_full_name": "lyinch",
        "timestamp": 1645216579
    },
    {
        "content": "<p>signalling that \"this is potentially slow and not a general-purpose RNG API\" is the reason that I proposed putting this in std::io :P</p>",
        "id": 272454463,
        "sender_full_name": "bstrie",
        "timestamp": 1645216760
    },
    {
        "content": "<p>std::io to me implies that its implemented in terms of doing IO, tbh</p>",
        "id": 272454561,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645216815
    },
    {
        "content": "<p>well it involves a syscall, it's not a userspace PRNG</p>",
        "id": 272454617,
        "sender_full_name": "bstrie",
        "timestamp": 1645216851
    },
    {
        "content": "<p>given that that's a reasonable way of implementing it but probably not the way we're doing it, i'm not sure</p>",
        "id": 272454622,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645216855
    },
    {
        "content": "<p>(in linux, everything is a file, so this is correct)</p>",
        "id": 272454632,
        "sender_full_name": "lyinch",
        "timestamp": 1645216861
    },
    {
        "content": "<p>also <code>std::io::Entropy</code> doesn't really indicate that it's non-general purpose to me. I also would expect it to implement std::io::Read, which i think is kind of a footgun</p>",
        "id": 272454702,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645216914
    },
    {
        "content": "<p>for this case</p>",
        "id": 272454708,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645216917
    },
    {
        "content": "<p>Yeah, I think that given that some OS will give you basically-whatever amounts of entropy but others will glare at you for asking for more than 256 bytes, we should be hesitant to implement a general-purpose Read interface.</p>",
        "id": 272455052,
        "sender_full_name": "Jubilee",
        "timestamp": 1645217124
    },
    {
        "content": "<p>my suggestion to use Read was more-or-less just exuberance, I don't care how this gets added to std, I just want it :P</p>",
        "id": 272455373,
        "sender_full_name": "bstrie",
        "timestamp": 1645217315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272449723\">said</a>:</p>\n<blockquote>\n<p>Yeah ok, but that's not a generic read. You have knowledge that this read impl cannot fail.</p>\n</blockquote>\n<p>In particular, I wish I had some way of using a read interface on a slice or similar infallible thing where the type checker could <em>see</em> that it can' fail.</p>",
        "id": 272455667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217500
    },
    {
        "content": "<p>at the same time, I don't think an interface that lets the user ask for an arbitrary number of bytes is infeasible. we can batch multiple calls under the hood if we need to. and even for Read::read, we're allowed to read less than the user asked for: \"It is not an error if the returned value n is smaller than the buffer size, even when the reader is not at the end of the stream yet. This may happen for example because fewer bytes are actually available right now (e. g. being close to end-of-file) or because read() was interrupted by a signal.\"</p>",
        "id": 272455671,
        "sender_full_name": "bstrie",
        "timestamp": 1645217501
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272451220\">said</a>:</p>\n<blockquote>\n<p>AIUI urandom effectively doesn't do entropy accounting once it's seeded.</p>\n</blockquote>\n<p>Per the LWN article linked above: random doesn't either, anymore.</p>",
        "id": 272455750,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217538
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272453166\">said</a>:</p>\n<blockquote>\n<p>Ok, then we should document it potentially being terribly slow.</p>\n</blockquote>\n<p>I mean, if we say that it's from the OS, then it's up to the OS.</p>\n<p>Are there any tier 1 OSs that don't expose a reasonable-speed CS-XOF to contexts that would be using <code>std</code>?</p>\n<p>It being secure and slower, so you use it to seed a user-space RNG if you care about fast instead, seems very in line with what I'd expect a default in <code>std</code> to do.</p>",
        "id": 272455827,
        "sender_full_name": "scottmcm",
        "timestamp": 1645217593
    },
    {
        "content": "<p>We're allowed, but the argument above is that short reads are handled poorly \"in the wild\".</p>",
        "id": 272455835,
        "sender_full_name": "Jubilee",
        "timestamp": 1645217598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272452478\">said</a>:</p>\n<blockquote>\n<p>We could of course wrap a userspace CPRNG around the kernel source. Although that'd mean pulling some crypto lib into std.</p>\n</blockquote>\n<p>I would love to have a seedable CSPRNG in core, and a get-random-bytes mechanism in std that could be used to seed it.</p>",
        "id": 272455846,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217607
    },
    {
        "content": "<p>I am not <em>against</em> exposing a Rust CSPRNG in <code>std</code>, but atm we're discussing the second part, not the first. ^_^</p>",
        "id": 272455949,
        "sender_full_name": "Jubilee",
        "timestamp": 1645217657
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span>, and I'm happy with having those separated.</p>",
        "id": 272455960,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217668
    },
    {
        "content": "<p>I'd also love to have an actual PRNG in std \"someday\", but for now I'd just like people to be able to seed their own RNGs without having to resort to tokio's awful HashMap hack</p>",
        "id": 272455968,
        "sender_full_name": "bstrie",
        "timestamp": 1645217677
    },
    {
        "content": "<p>Not least of which because I don't think there's much value in having the CSPRNG in core <em>until</em> we have a sensible mechanism for seeding it.</p>",
        "id": 272455983,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217690
    },
    {
        "content": "<p>I would actually expect that a CSPRNG would <em>not</em> be seedable via any stdlib API</p>",
        "id": 272456227,
        "sender_full_name": "bstrie",
        "timestamp": 1645217828
    },
    {
        "content": "<p>?</p>",
        "id": 272456253,
        "sender_full_name": "The 8472",
        "timestamp": 1645217843
    },
    {
        "content": "<p>I worry that anything that really <em>needs</em> a CSPRNG would have compliance restrictions that would keep them from being able to use anything we implement in <code>std</code> anyway.  I'd much rather people fix a specific audited version of rustsec, for example, than the version of their rust toolchain.</p>",
        "id": 272456265,
        "sender_full_name": "scottmcm",
        "timestamp": 1645217851
    },
    {
        "content": "<p>CSPRNGs should have a disjoint interface from PRNGs used for simulation</p>",
        "id": 272456274,
        "sender_full_name": "bstrie",
        "timestamp": 1645217855
    },
    {
        "content": "<p>Oh, sure. I don't think josh was proposing an integrated API. Just two building blocks that can be joined manually</p>",
        "id": 272456363,
        "sender_full_name": "The 8472",
        "timestamp": 1645217889
    },
    {
        "content": "<p>one needs to be misuse-resistant and not seedable, and the other needs to be seedable and deterministic</p>",
        "id": 272456364,
        "sender_full_name": "bstrie",
        "timestamp": 1645217889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272456364\">said</a>:</p>\n<blockquote>\n<p>one needs to be misuse-resistant and not seedable, and the other needs to be seedable and deterministic</p>\n</blockquote>\n<p>I don't think there's any use case for a seedable PRNG that isn't satisfied by a seedable CSPRNG.</p>",
        "id": 272456411,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217926
    },
    {
        "content": "<p>I think in both cases we want \"misuse-resistant\".</p>",
        "id": 272456428,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> the problem that we ran into at Rust 1.0 is that if we <em>do</em> ship a non-cryptographically-secure RNG but <em>don't</em> ship a cryptographically-secure RNG, then we know that people will reach for the former when they should be using the latter</p>",
        "id": 272456492,
        "sender_full_name": "bstrie",
        "timestamp": 1645217983
    },
    {
        "content": "<p>I'd ideally want 1) an underlying CSPRNG that takes a seed and gives you random numbers, and 2) a default binding of that together with a secure seeding mechanism from the OS, that we encourage people to use by default for any purpose that <em>doesn't</em> want replayability.</p>",
        "id": 272456505,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645217986
    },
    {
        "content": "<blockquote>\n<p>I worry that anything that really needs a CSPRNG would have compliance restrictions that would keep them from being able to use anything we implement in std anyway. I'd much rather people fix a specific audited version of rustsec, for example, than the version of their rust toolchain.</p>\n</blockquote>\n<p>I know I used the same rand hashing hack tokio uses explicitly because using the hashmap api for this was okay but pulling in a 3rd party rng wasnt (this was in earlier times of rust in firefox, when security crates needed a separate audit).</p>",
        "id": 272456519,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645217992
    },
    {
        "content": "<p>for macos, what do you think about allowing &gt;256 bytes by just calling <code>getentropy()</code> repeatedly? I don't think people who do cross-platform development care or even know about this limit</p>",
        "id": 272456763,
        "sender_full_name": "lyinch",
        "timestamp": 1645218026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272456265\">said</a>:</p>\n<blockquote>\n<p>I worry that anything that really <em>needs</em> a CSPRNG would have compliance restrictions that would keep them from being able to use anything we implement in <code>std</code> anyway.  I'd much rather people fix a specific audited version of rustsec, for example, than the version of their rust toolchain.</p>\n</blockquote>\n<p>No, I don't think this is how compliance auditing works.</p>",
        "id": 272456941,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272456492\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> the problem that we ran into at Rust 1.0 is that if we <em>do</em> ship a non-cryptographically-secure RNG but <em>don't</em> ship a cryptographically-secure RNG, then we know that people will reach for the former when they should be using the latter</p>\n</blockquote>\n<p>Totally agreed, but I think what I'm proposing here is <em>just</em> having the OS's CS-XOF exposed in <code>std</code> and leaving everything else to elsewhere.  Since those other things can seed from the non-seedable OS XOF we expose, if they want.</p>",
        "id": 272457019,
        "sender_full_name": "scottmcm",
        "timestamp": 1645218138
    },
    {
        "content": "<p>That's 256 <em>bytes</em>. To resist quantum attacks you might need <em>maybe</em> 512<em>bits</em>. So the limit should be enough for seeding about anything.</p>",
        "id": 272457064,
        "sender_full_name": "The 8472",
        "timestamp": 1645218171
    },
    {
        "content": "<p>At least, not for a <strong>lot</strong> of users.<br>\nFor a lot of people, the way auditing is going to work will actually be oriented around verifying the Rust toolchain first.</p>",
        "id": 272457107,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218212
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272456265\">said</a>:</p>\n<blockquote>\n<p>I worry that anything that really <em>needs</em> a CSPRNG would have compliance restrictions that would keep them from being able to use anything we implement in <code>std</code> anyway.  I'd much rather people fix a specific audited version of rustsec, for example, than the version of their rust toolchain.</p>\n</blockquote>\n<p>So, I don't think we should give <em>any</em> thought to things like FIPS. Those should remain the domain of specialized crates.</p>",
        "id": 272457203,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218258
    },
    {
        "content": "<p>When we built the abseil RNG library we decided to make it difficult to seed. What we had found was that people misused RNGs in tests and blessed the results. This made it impossible to execute large scale changes. Very few people are dealing with multi-million package repos, so this concern might not generalize.</p>",
        "id": 272457234,
        "sender_full_name": "Brendan Hickey",
        "timestamp": 1645218283
    },
    {
        "content": "<p>The case of \"I need something actually secure\" should be covered by a CSPRNG. The case of \"I need something on some particular approved/vetted list\" is entirely different.</p>",
        "id": 272457305,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272457305\">said</a>:</p>\n<blockquote>\n<p>The case of \"I need something actually secure\" should be covered by a CSPRNG. The case of \"I need something on some particular approved/vetted list\" is entirely different.</p>\n</blockquote>\n<p>This is true, I just wanted to note that saying that it shouldn't be in std for compliance concerns is getting it the wrong way around.</p>",
        "id": 272457435,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218379
    },
    {
        "content": "<p>Okay done futzing I think that groups everything appropriately. &lt;_&lt;</p>",
        "id": 272458109,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218762
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> So, not especially urgent, but I feel like the whole line of discussion between scottmcm and myself about seedable RNGs potentially locking down the algorithm doesn't actually belong in the \"RNGs in tests\" topic, it's part of the more general topic.</p>",
        "id": 272458372,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218895
    },
    {
        "content": "<p>well~</p>",
        "id": 272458424,
        "sender_full_name": "Jubilee",
        "timestamp": 1645218920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272458372\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> So, not especially urgent, but I feel like the whole line of discussion between scottmcm and myself about seedable RNGs potentially locking down the algorithm doesn't actually belong in the \"RNGs in tests\" topic, it's part of the more general topic.</p>\n</blockquote>\n<p>kinda but also this is mostly about the interface one might use to seed things with as opposed to whether another interface is seedable! also afaik I have no special powers, if everyone disagrees you are all free to move your messages back into this topic, I think.</p>",
        "id": 272458607,
        "sender_full_name": "Jubilee",
        "timestamp": 1645219025
    },
    {
        "content": "<p>what do you think about the <code>no_std</code> idea from here: <a href=\"https://github.com/dhardy/rfcs/blob/system-random/text/0000-system-random.md#no_std-support\">https://github.com/dhardy/rfcs/blob/system-random/text/0000-system-random.md#no_std-support</a>  ? Add an implementation to <code>libcore</code> which always fails and which <code>no_std</code> users have to implement themselves. The actual implementation will be in<code>libstd</code>.</p>",
        "id": 272458941,
        "sender_full_name": "lyinch",
        "timestamp": 1645219205
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479478\">lyinch</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272458941\">said</a>:</p>\n<blockquote>\n<p>what do you think about the <code>no_std</code> idea from here: <a href=\"https://github.com/dhardy/rfcs/blob/system-random/text/0000-system-random.md#no_std-support\">https://github.com/dhardy/rfcs/blob/system-random/text/0000-system-random.md#no_std-support</a>  ? Add an implementation to <code>libcore</code> which always fails and which <code>no_std</code> users have to implement themselves. The actual implementation will be in<code>libstd</code>.</p>\n</blockquote>\n<p>So the first thing hinges on whether <code>io::Error</code> can be used. I think our E for this Result should be designed for the particularities of the use case, rather than using <code>io::Error</code>. I think because this domain is so exceptionally security-sensitive, we don't want to couple it to anything else.</p>\n<p>But I also doubt we should provide an implementation for <code>core</code>, unless we can do so by simply directly issuing the relevant hardware instructions across most architectures.</p>",
        "id": 272460298,
        "sender_full_name": "Jubilee",
        "timestamp": 1645219945
    },
    {
        "content": "<p>for AMD and Intel x86-64 there is <code>RDRAND</code> and <code>RDSEED</code> and for ARM V8 there seems to be support for <code>RNDR</code></p>",
        "id": 272463580,
        "sender_full_name": "lyinch",
        "timestamp": 1645221627
    },
    {
        "content": "<p>See the other thread, those are being discussed there too :D</p>",
        "id": 272463759,
        "sender_full_name": "The 8472",
        "timestamp": 1645221715
    },
    {
        "content": "<p>I think, based on the fact that it seems the security community lacks consensus for whether it is acceptable to do that, and it would still break on some <code>#!{no_std]</code> targets assuredly, and a lot else requires the machine to be configured properly by the bare-metal user, and by then they have much better access to sources of randomness than we can generically implement, it existing in libcore should simply be eschewed. GIve people a compiler error, not a runtime error.</p>",
        "id": 272464165,
        "sender_full_name": "Jubilee",
        "timestamp": 1645221952
    },
    {
        "content": "<p>Rdrand also breaks rr due to being non-deterministic in a way that rr can't capture and replay.</p>",
        "id": 272466318,
        "sender_full_name": "bjorn3",
        "timestamp": 1645223023
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272466318\">said</a>:</p>\n<blockquote>\n<p>Rdrand also breaks rr due to being non-deterministic in a way that rr can't capture and replay.</p>\n</blockquote>\n<p><a href=\"https://github.com/systemd/systemd/pull/17115\">https://github.com/systemd/systemd/pull/17115</a> can be disabled with systemd</p>",
        "id": 272466980,
        "sender_full_name": "lyinch",
        "timestamp": 1645223373
    },
    {
        "content": "<p>That disables it specifically for systemd's <code>/sbin/init</code> and not for arbitrary user programs, right?</p>",
        "id": 272468011,
        "sender_full_name": "bjorn3",
        "timestamp": 1645223960
    },
    {
        "content": "<p>how will this continue? I guess this addition requires an RFC</p>",
        "id": 272707076,
        "sender_full_name": "lyinch",
        "timestamp": 1645459508
    },
    {
        "content": "<p>yes, I would expect something of this magnitude to have an RFC. and correct me if I'm wrong, but I don't think this is a case of needing to add a new external dependency to std; std should <em>already</em> have all the code necessary for this, in order to support HashMaps, it just needs an interface. In fact I think the getrandom crate might have just been copied out of std directly.</p>",
        "id": 272717268,
        "sender_full_name": "bstrie",
        "timestamp": 1645465009
    },
    {
        "content": "<p>indeed, I was not aware that so much is already implemented in <a href=\"https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/rand.rs\">https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/rand.rs</a></p>",
        "id": 272721624,
        "sender_full_name": "lyinch",
        "timestamp": 1645467972
    },
    {
        "content": "<p>Technically this is only a single function, so, following the libs policy, we could just add it... :^)<br>\nBut I think the <strong>import</strong> of it is, in fact, yes<br>\nhigh-magnitude, and will certainly require RFC-like levels of talking to people,<br>\nwhether or not it goes through the RFC process.</p>",
        "id": 272732069,
        "sender_full_name": "Jubilee",
        "timestamp": 1645475207
    },
    {
        "content": "<p>Yeah, I think in particular exposing a function to provide secure randomness has lots of implications about target support.</p>",
        "id": 272732133,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645475267
    },
    {
        "content": "<p>Like, \"does this require an RFC?\" idk, procedurally no, but morally yes, it requires running down every person who has a thought on this matter and broadcasting they can get their remarks in.</p>",
        "id": 272732251,
        "sender_full_name": "Jubilee",
        "timestamp": 1645475347
    },
    {
        "content": "<p>Given that <a href=\"https://doc.rust-lang.org/nightly/rustc/platform-support.html\">https://doc.rust-lang.org/nightly/rustc/platform-support.html</a> already says \"the full standard library is available\" for <code>wasm32-unknown-unknown</code>, I'm not sure that it really says all that much about target support, since this could just be another thing that's stubbed out.</p>",
        "id": 272732383,
        "sender_full_name": "scottmcm",
        "timestamp": 1645475429
    },
    {
        "content": "<p>Sure, but there are other platforms where randomness may not be available either. Embedded for instance.</p>",
        "id": 272732536,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645475552
    },
    {
        "content": "<p>Well, needs to be in std for !embedded.</p>",
        "id": 272732613,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645475630
    },
    {
        "content": "<p>Might be a good idea to allow it to be implemented via a userspace CSPRNG, though, as a fallback.</p>",
        "id": 272732721,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645475700
    },
    {
        "content": "<p>That much seems fine, but you still have to seed it.</p>",
        "id": 272732768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645475760
    },
    {
        "content": "<p>If you have a piece of hardware with <em>no</em> source of randomness, you can't really produce randomness ex nihilo.</p>",
        "id": 272732836,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645475788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272732536\">said</a>:</p>\n<blockquote>\n<p>Sure, but there are other platforms where randomness may not be available either. Embedded for instance.</p>\n</blockquote>\n<p>I just mean that we have precedent for \"it just panics\" counting as enough support to be Tier2.</p>",
        "id": 272732998,
        "sender_full_name": "scottmcm",
        "timestamp": 1645475937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272732768\">said</a>:</p>\n<blockquote>\n<p>That much seems fine, but you still have to seed it.</p>\n</blockquote>\n<p>Yeah. Ultimately, the answer could be is it's allowed to be seeded the same way every execution. I would expect this solution to be \"few and far between\" though.</p>",
        "id": 272733013,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645475954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272733013\">said</a>:</p>\n<blockquote>\n<p>the answer could be is it's allowed to be seeded the same way every execution</p>\n</blockquote>\n<p>I'd email <a href=\"mailto:security@rust-lang.org\">security@rust-lang.org</a> if I found any platforms doing that in the official bits, personally.</p>",
        "id": 272733124,
        "sender_full_name": "scottmcm",
        "timestamp": 1645476034
    },
    {
        "content": "<p>Yeah. I'd rather have a target panic than do that.</p>",
        "id": 272733197,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645476108
    },
    {
        "content": "<p>If someone wants the same randomness every time, they can run the seedable RNG with a fixed seed.</p>",
        "id": 272733252,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645476123
    },
    {
        "content": "<p>Maybe. I know old Mingw did that for <code>std::random_device</code></p>",
        "id": 272733260,
        "sender_full_name": "Connor Horman",
        "timestamp": 1645476129
    },
    {
        "content": "<p>I think that was a bug</p>\n<blockquote>\n<p>A notable implementation where std::random_device is deterministic is old versions of MinGW (bug 338, fixed since GCC 9.2). <br>\n<a href=\"https://en.cppreference.com/w/cpp/numeric/random/random_device\">https://en.cppreference.com/w/cpp/numeric/random/random_device</a></p>\n</blockquote>",
        "id": 272733427,
        "sender_full_name": "lyinch",
        "timestamp": 1645476286
    },
    {
        "content": "<p>Honestly, I don't think the <code>wasm*-?-?</code> target bears much consideration. It essentially is a shim for a real <code>wasm*-wasi</code> target, or <code>wasm*-browser</code></p>",
        "id": 272736205,
        "sender_full_name": "Jubilee",
        "timestamp": 1645478518
    },
    {
        "content": "<p>Not saying this to bag on anyone who uses it or contributed to it, it's just that it's more valuable than it is coherent, and trying to bend everything around rationalizing-as-coherent what is essentially a point of explicit decoherence strikes me as an unwise approach.</p>",
        "id": 272736494,
        "sender_full_name": "Jubilee",
        "timestamp": 1645478724
    },
    {
        "content": "<p>In general, it feels like those targets want some kind of capability mechanism for \"what your particular target has\". Some embedded targets want that too.</p>",
        "id": 272736614,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645478801
    },
    {
        "content": "<p>Isn't that just the slicing-std-into-features thing again?</p>",
        "id": 272744834,
        "sender_full_name": "The 8472",
        "timestamp": 1645486312
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/possible.20getrandom.20interface/near/272732536\">said</a>:</p>\n<blockquote>\n<p>Sure, but there are other platforms where randomness may not be available either. Embedded for instance.</p>\n</blockquote>\n<p>I don't envision this random interface being in libcore, only in libstd. no_std things will be on their own.</p>",
        "id": 272795261,
        "sender_full_name": "bstrie",
        "timestamp": 1645532711
    },
    {
        "content": "<p>for the same reason that HashMap is defined in libstd, whereas all the other std::collections are defined in liballoc</p>",
        "id": 272795417,
        "sender_full_name": "bstrie",
        "timestamp": 1645532824
    },
    {
        "content": "<p>does anyone know if <code>/dev/urandom</code> possibly block on macos &lt; 10.12 like on linux? Or does it return lower-entropy values like on some BSD distros? </p>\n<blockquote>\n<p>When  read,  /dev/urandom  device  will return as many bytes as are re quested.  As a result, if there is not sufficient entropy  in  the  entropy pool, the returned values are theoretically vulnerable to a cryptographic attack on the algorithms used by the  driver.<br>\n<a href=\"https://www.freebsd.org/cgi/man.cgi?query=urandom&amp;apropos=0&amp;sektion=0&amp;manpath=Red+Hat+9&amp;arch=default&amp;format=html\">https://www.freebsd.org/cgi/man.cgi?query=urandom&amp;apropos=0&amp;sektion=0&amp;manpath=Red+Hat+9&amp;arch=default&amp;format=html</a></p>\n</blockquote>\n<p>I don't know where I can find man pages of different macos versions online</p>",
        "id": 273013161,
        "sender_full_name": "lyinch",
        "timestamp": 1645651391
    },
    {
        "content": "<p>Is that really a freebsd manpage? Or as the url implies Red Hat 9 which would be ancient...</p>",
        "id": 273013893,
        "sender_full_name": "cuviper",
        "timestamp": 1645651798
    },
    {
        "content": "<p>yes, you're right... This should be the corresponding freedsb 14 page: <a href=\"https://www.freebsd.org/cgi/man.cgi?query=random&amp;sektion=4&amp;apropos=0&amp;manpath=FreeBSD+14.0-current\">https://www.freebsd.org/cgi/man.cgi?query=random&amp;sektion=4&amp;apropos=0&amp;manpath=FreeBSD+14.0-current</a>  which says that it's blocking:</p>\n<blockquote>\n<p>The generator will start in an unseeded state, and will block reads until it is seeded for the first time.</p>\n</blockquote>",
        "id": 273014882,
        "sender_full_name": "lyinch",
        "timestamp": 1645652310
    }
]