[
    {
        "content": "<p>In both nom and clap, we are looking at allowing APIs to take ranges (<code>10..</code>) and individual integers (<code>10</code>).</p>\n<p>For more details, I've written a <a href=\"https://github.com/epage/range_bounds_example/blob/main/scalar-range-bounds.md\">draft RFC</a> and  <a href=\"https://github.com/epage/range_bounds_example/tree/main/examples\">different strawman implementations</a></p>\n<p>Is this something the libs team thinks is worth moving forward?  Would the next step be finishing my RFC and creating a PR for it?</p>",
        "id": 254076667,
        "sender_full_name": "Ed Page",
        "timestamp": 1632154834
    },
    {
        "content": "<p>I think this could be clearer about what it's proposing (I think having the summary describe the goals rather than the change is not ideal in this case).</p>\n<p>It took a while for me to realize that it's proposing adding impl RangeBounds&lt;T&gt; for T: Ord, as in <a href=\"https://github.com/epage/range_bounds_example/blob/main/scalar-range-bounds.md#reference-level-explanation\">https://github.com/epage/range_bounds_example/blob/main/scalar-range-bounds.md#reference-level-explanation</a>.</p>",
        "id": 254078066,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632155425
    },
    {
        "content": "<p>I think this means you won't be able to impl RangeBounds for Ord types though? Would that introduce coherence problems?</p>",
        "id": 254078372,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632155548
    },
    {
        "content": "<p>Wouldn't a  bunch of <code>From</code> impls be sufficient? Then APIs that need RangeBounds can do a <code>where U: Into&lt;RangeBounds&lt;T&gt;&gt;</code>.</p>",
        "id": 254078753,
        "sender_full_name": "The 8472",
        "timestamp": 1632155688
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> thanks for that feedback, I've updated the summary and an added an additional drawback.  I'm not too tied to what we <code>impl</code> for (<code>T: Ord</code>, concrete types, etc).  They have different trade offs but all meet the goal.  The question is if the goal is worth the trade offs.</p>",
        "id": 254084546,
        "sender_full_name": "Ed Page",
        "timestamp": 1632158022
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> as we explored options for <code>nom</code>, we realized that <code>trait RangeBounds</code> is effectively a <code>trait IntoBounds</code> with <code>(Bound&lt;T&gt;, Bound&lt;T&gt;)</code> being the universal concrete type for ranges.  It seems like it might be overkill to also add <code>impl&lt;'r, T&gt; From&lt;&amp;'r Range&gt; for (Bound&lt;&amp;'r T&gt;, Bound&lt;&amp;'r T&gt;)</code> for each range type (<code>&amp;'r</code> so it follows the rest of <code>Range</code> types and not assume <code>Copy</code> or <code>Clone</code>).</p>\n<p>I'll add this as an alternative though.</p>",
        "id": 254085201,
        "sender_full_name": "Ed Page",
        "timestamp": 1632158306
    },
    {
        "content": "<p>A new blanket impl is a major breaking change.</p>",
        "id": 254115770,
        "sender_full_name": "cuviper",
        "timestamp": 1632171017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/RangeBounds.20for.20scalar.20integers.3F/near/254115770\">said</a>:</p>\n<blockquote>\n<p>A new blanket impl is a major breaking change.</p>\n</blockquote>\n<p>Did not know that; thanks!  Could you expand on why so I have a better grasp of this?</p>\n<p>Any thoughts an alternative, like implementing for specific types, say the same set as <code>std::iter::Step</code>?</p>",
        "id": 254117532,
        "sender_full_name": "Ed Page",
        "timestamp": 1632171714
    },
    {
        "content": "<p>because people may have their own implementations, which are now incompatible. i think you kind of allude to this here:</p>\n<blockquote>\n<p>If nom is the first to do this and merges their approach, we'll break them if we do this later</p>\n</blockquote>\n<p>E.g. the fact that this change can break user code is why.</p>\n<hr>\n<p>I suspect there are no issues with implementing this for concrete types like the set used for Step (although I haven't checked which types implement step)</p>",
        "id": 254118418,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632172082
    },
    {
        "content": "<p>Thanks, I've updated the recommendation</p>\n<blockquote>\n<p>i think you kind of allude to this here:</p>\n</blockquote>\n<blockquote>\n<p>I suspect there are no issues with implementing this for concrete types like the set used for Step (although I haven't checked which types implement step)</p>\n</blockquote>\n<p>I think there might be a misunderstanding with the breakage with the nom PR.  From my limited understanding of integer literal coercion, it looks like by adding a <code>RangeBounds</code> impl for concrete types, when the compiler sees <code>many(10)</code>, it is no longer choosing <code>usize</code> and picking <code>impl IntoRangeBounds&lt;RangeInclusive&lt;usize&gt;&gt; for usize</code> but instead it first sees  <code>impl RangeBounds&lt;i32&gt; for i32</code> and fails since we need the <code>usize</code> coercion.</p>\n<p>Feel free to play with this, I've updated the <a href=\"https://github.com/epage/range_bounds_example/tree/main/examples/combined\">broken case</a>.</p>",
        "id": 254121038,
        "sender_full_name": "Ed Page",
        "timestamp": 1632173190
    },
    {
        "content": "<p>yeah, in that case I'm mistaken, and the breakage is unrelated to your change. One example of breakage would be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyOrdRange</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* stuff here */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">RangeBounds</span><span class=\"o\">&lt;</span><span class=\"n\">MyOrdRange</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyOrdRange</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If we add a blanket, this will break, as <code>MyOrdRange</code> now has two <code>RangeBound&lt;Self&gt;</code> impls. This is a bit contrived, but there are plausibly more realistic breakages too.</p>",
        "id": 254123487,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1632174350
    },
    {
        "content": "<p>RFC 1023 discusses this: <a href=\"https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html#practical-effect\">https://rust-lang.github.io/rfcs/1023-rebalancing-coherence.html#practical-effect</a></p>",
        "id": 254126277,
        "sender_full_name": "cuviper",
        "timestamp": 1632175812
    }
]