[
    {
        "content": "<p>I'm trying to implement a <code>#[global allocator]</code> that allocates from a <code>thread_local!</code> data structure. The thread local needs a drop implementation to return memory to a global heap on thread exit. This works fine on x86-64 linux when I run <code>cargo test</code>. However, when I run miri, I seem to hit recursive initialization. Specifically, accessing the thread local the first time tries to register it's destructor, but registering the destructor allocates (using the global allocator).</p>\n<p>I'm using a <code>const</code> initialized thread local, which is implemented here: <a href=\"https://doc.rust-lang.org/src/std/thread/local.rs.html#195-248\">https://doc.rust-lang.org/src/std/thread/local.rs.html#195-248</a></p>\n<p>There is a <code>#[thread_local] static mut VAL: ...</code> which is the actual thread local, and a <code>#[thread_local] static mut STATE: ...</code> to keep track of whether the destructor has been/is currently being registered. Eventually, it calls <a href=\"https://doc.rust-lang.org/src/std/thread/local.rs.html#233-236\"><code>register_dtor</code></a> which is <a href=\"https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/thread_local_dtor.rs#L20-L44\">this</a> on my platform</p>\n<p><code>register_dtor</code> looks for a weak <code>__cxa_thread_atexit_impl</code> symbol which it uses if present; otherwise, it calls <a href=\"https://github.com/rust-lang/rust/blob/master/library/std/src/sys_common/thread_local_dtor.rs#L19-L49\"><code>register_dtor_fallback</code></a>. I'm assuming this symbol is present when building for debug/test/release, but is not under miri (or it is shim'ed). <code>register_dtor_fallback</code> allocates a <code>Box&lt;Vec&lt;_&gt;&gt;</code>, which may also allocate when the vector gets pushed to, using the global allocator (this <code>Box&lt;Vec&lt;_&gt;&gt;</code> is a list of destructor functions that will be called on thread exit)</p>\n<p>So the following happens (when running under miri):</p>\n<ol>\n<li>global allocator gets called</li>\n<li>global allocator tries to access the thread local heap</li>\n<li>standard library tries to register the destructor</li>\n<li>registering the destructor allocates</li>\n<li>global allocator is called recursively</li>\n</ol>\n<p>I've been stuck on this for a while; I can't see how one can implement a general purpose global allocator using thread locals if registering a thread local destructor allocates. If someone has an idea how to avoid this, I'd love to hear. Alternatively (a big \"alternatively\"), I believe it should be possible to implement <code>register_dtor_fallback</code> so it doesn't need a box or a vector. And for this use, it would be nice if the standard library could guarantee that registering the destructor never allocates; otherwise such a global allocator implemented in rust would not be portable</p>\n<p>As for the \"alternative\", roughly speaking, each thread local defined through <code>thread_local!</code> already has a <code>#[thread_local] static mut STATE</code>. That macro could also define something like a</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">DtorFallback</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">t</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">dtor</span>: <span class=\"nc\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">next</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and pass/thread it through to <code>register_dtor_fallback</code>, which can maintain an intrusive linked list of these destructors. (This was just an idea I had; I'm not sure if there are larger problems)</p>\n<p>If anyone has any ideas what I can do it would be greatly appreciated!</p>",
        "id": 278097066,
        "sender_full_name": "Raekye",
        "timestamp": 1649285809
    },
    {
        "content": "<p>If the type you store in a thread local doesn't require drop glue I believe libstd skips register_dtor_fallback in the current implementation.</p>",
        "id": 278097775,
        "sender_full_name": "bjorn3",
        "timestamp": 1649286192
    },
    {
        "content": "<p>I don't think register_dtor_fallback can be implemented without allocating. Where would it store the destructor otherwise?</p>",
        "id": 278097902,
        "sender_full_name": "bjorn3",
        "timestamp": 1649286246
    },
    {
        "content": "<p>I'm using the drop glue to return memory from the dying thread to the global heap. Otherwise, is there a way to implement it so the memory doesn't get lost/can be reclaimed?</p>",
        "id": 278099603,
        "sender_full_name": "Raekye",
        "timestamp": 1649287435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/219381-t-libs/topic/Global.20allocator.20with.20thread.20locals.20fallback.20initialization/near/278097902\">said</a>:</p>\n<blockquote>\n<p>I don't think register_dtor_fallback can be implemented without allocating. Where would it store the destructor otherwise?</p>\n</blockquote>\n<p>Each thread local declared with <code>thread_local!</code> basically needs additional storage (another <code>#[thread_local]</code> which is const initialized and doesn't run drop) which <code>register_dtor_fallback</code> can use as an intrusive linked list containing all the destructors from thread locals declared with <code>thread_local!</code>. Note that <code>thread_local!</code> already creates a <code>#[thread_local] static mut STATE</code> to keep track of the destructor state, so requiring/creating additional storage isn't unprecedented. But the linked list of <code>#[thread_local] static</code> items might be sketchy...</p>",
        "id": 278100039,
        "sender_full_name": "Raekye",
        "timestamp": 1649287739
    },
    {
        "content": "<p>I gave an example definition for the additional storage at the bottom of my original post</p>",
        "id": 278101083,
        "sender_full_name": "Raekye",
        "timestamp": 1649288525
    },
    {
        "content": "<p>One thing you could do is add a thread local bool that signals that you are currently initializing the thread local allocator and should thus forward all allocations to the real global allocator</p>",
        "id": 278119114,
        "sender_full_name": "oli",
        "timestamp": 1649309381
    },
    {
        "content": "<p>The problem I'm not sure doing that is that at least naively, when deallocating the memory you don't know whether it came from the real global allocator (e.g. malloc) or custom allocator. Extra bookkeeping is possible, but doesn't seem ideal</p>",
        "id": 278119417,
        "sender_full_name": "Raekye",
        "timestamp": 1649309726
    },
    {
        "content": "<p>Hmm... dropping the thread local dtor alloc happens after calling the dtor, so you can set the thread local bool again to use the real global alloc</p>",
        "id": 278119581,
        "sender_full_name": "oli",
        "timestamp": 1649309922
    },
    {
        "content": "<p>But yea, any alloc and dealloc will now first go through the thread local bool</p>",
        "id": 278119590,
        "sender_full_name": "oli",
        "timestamp": 1649309945
    },
    {
        "content": "<p>Hmmm I may have misunderstood. I was imagining something this:</p>\n<ul>\n<li><code>#[thread_local] static mut REENTRANT: bool = false</code></li>\n<li>call to <code>Global.allocate</code></li>\n<li>see that <code>REENTRANT</code> is false, set it to true for future calls (set it to false before return)</li>\n<li>access the thread local heap with <code>THREAD_LOCAL.with(|local| ...)</code></li>\n<li>standard library registers the dtor, allocating with the global allocator<br>\n    - reentrant call to <code>Global.allocate</code><br>\n    - see that <code>REENTRANT</code> is true<br>\n    - instead of allocating with <code>THREAD_LOCAL.with(|local| ...)</code> (which will try registering the dtor again because it hasn't completed the first time), call <code>System.allocate</code></li>\n<li>standard library finishes registering the dtor</li>\n<li>do the original allocation with <code>THREAD_LOCAL</code>, set <code>REENTRANT</code> to false before returning</li>\n</ul>\n<p>But later given a pointer in <code>Global.deallocate</code>, how do I know whether it was allocated with the system allocator or my allocator?</p>",
        "id": 278120110,
        "sender_full_name": "Raekye",
        "timestamp": 1649310619
    },
    {
        "content": "<p>As in whether it came from the reentrant call or non-reentrant call</p>",
        "id": 278120209,
        "sender_full_name": "Raekye",
        "timestamp": 1649310762
    },
    {
        "content": "<p>You don't know</p>",
        "id": 278123743,
        "sender_full_name": "oli",
        "timestamp": 1649314525
    },
    {
        "content": "<p>You just set it up in a way that alloc/dealloc happens with the reentrant flag set correctly</p>",
        "id": 278123804,
        "sender_full_name": "oli",
        "timestamp": 1649314574
    },
    {
        "content": "<p>You set the flag to false within the <code>with</code> closure and <code>true</code> otherwise</p>",
        "id": 278123851,
        "sender_full_name": "oli",
        "timestamp": 1649314629
    },
    {
        "content": "<p>And to true in the dtor</p>",
        "id": 278123875,
        "sender_full_name": "oli",
        "timestamp": 1649314652
    },
    {
        "content": "<p>After the dtor, it doesn't matter anyway, as nothing will use the thread local allocator</p>",
        "id": 278123890,
        "sender_full_name": "oli",
        "timestamp": 1649314678
    },
    {
        "content": "<p>Tho...</p>",
        "id": 278123938,
        "sender_full_name": "oli",
        "timestamp": 1649314692
    },
    {
        "content": "<p>Unless you stored things in another thread local</p>",
        "id": 278123953,
        "sender_full_name": "oli",
        "timestamp": 1649314707
    },
    {
        "content": "<p>And... not sure how you would migrate things from the thread local to the global one in the dtor at all</p>",
        "id": 278123978,
        "sender_full_name": "oli",
        "timestamp": 1649314735
    },
    {
        "content": "<p>Oh I think I see, are you saying it works because the allocations for setting up the dtor (with the reentrant flag set correctly) will be freed in the dtor (with the reentrant flag set correctly)? Hmmm, is it not a problem though that other unrelated thread locals with dtors get pushed on to the vec which then allocates and deallocates non-reentrantly when it grows?</p>",
        "id": 278127209,
        "sender_full_name": "Raekye",
        "timestamp": 1649317149
    },
    {
        "content": "<p>Also, are there any problems with my idea of making <code>registor_dtor_fallback</code> not allocate by using a linked list of <code>#[thread_local] static</code> items per <code>thread_local!</code> variable/declaration? At least naively, I don't see any drawbacks, and if it's just needing an implementation/proof of concept, I'm willing to give it a shot</p>",
        "id": 278127475,
        "sender_full_name": "Raekye",
        "timestamp": 1649317347
    },
    {
        "content": "<p>Idk, let's open a separate thread in  <a class=\"stream\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler\">#t-compiler</a> and see if people have opinions on it</p>",
        "id": 278137281,
        "sender_full_name": "oli",
        "timestamp": 1649323447
    },
    {
        "content": "<p>I <a href=\"#narrow/stream/131828-t-compiler/topic/Making.20register_dtor_fallback.20for.20thread.20locals.20not.20allocate\">made a thread</a> but haven't gotten any opinions... I'm not sure how to feel about it :s I think it would be a useful change and wouldn't even mind trying to implement it (something more concrete than just an idea), but I wouldn't want to submit a PR and also get no response</p>",
        "id": 278432320,
        "sender_full_name": "Raekye",
        "timestamp": 1649540328
    },
    {
        "content": "<p>Things are slower over the weekend.</p>",
        "id": 278432845,
        "sender_full_name": "The 8472",
        "timestamp": 1649541137
    }
]