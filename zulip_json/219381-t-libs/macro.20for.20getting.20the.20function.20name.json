[
    {
        "content": "<p>C++ has a standard <code>__func__</code> builtin that returns the name of the function that it's within. It occurs to me that it's a bit odd that Rust doesn't have something analogous, since we already have <code>file!</code> and <code>module_path!</code> and <code>line!</code> and <code>column!</code> for similar things. Is this something that people would be interested in having?</p>",
        "id": 269583366,
        "sender_full_name": "bstrie",
        "timestamp": 1643295174
    },
    {
        "content": "<p>I've wished for it once or twice, especially for logging macros or such. It feels like a bit of an odd hole. My one thought is that maybe it has more design choices, so was skipped. For example, should <code>impl Struct { fn foo() { function!() } }</code> be <code>foo</code> or <code>Struct::foo</code>, as the second might be nicer for logging (<code>module_path!() + function!()</code> is the whole resolution, not possible to mix up with a top-level <code>foo</code>), but the first is the more intuitive 'current function name'</p>",
        "id": 269589855,
        "sender_full_name": "CraftSpider",
        "timestamp": 1643297706
    },
    {
        "content": "<p><code>module_path!()</code> doesn't include the function name if a <code>mod{}</code> is nested inside a function.</p>",
        "id": 269593946,
        "sender_full_name": "bjorn3",
        "timestamp": 1643299269
    },
    {
        "content": "<p>IIRC there was a hack that went something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">path</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">type_name_of</span><span class=\"p\">(</span><span class=\"o\">&amp;||</span><span class=\"w\"> </span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"n\">path</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"n\">path</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"s\">\"::{{closure}}\"</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()].</span><span class=\"n\">rsplit</span><span class=\"p\">(</span><span class=\"s\">\"::\"</span><span class=\"p\">).</span><span class=\"n\">next</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But I can't find where I found it originally <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 269596152,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1643300087
    },
    {
        "content": "<p>like here <a href=\"https://twitter.com/mitsuhiko/status/1486126762346045442\">https://twitter.com/mitsuhiko/status/1486126762346045442</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/mitsuhiko/status/1486126762346045442\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/9f6ba0d6a01ff0690885fdcc3b67b259a3eba105/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313433333938323032382f70726f66696c655f6e6f726d616c2e706e67\"></a><p>I finally found a somewhat reliable name to determine the test function name. This should make insta pick more reliable snapshot names but the hack is … interesting. <a href=\"https://t.co/2r10pJpF4A\">https://twitter.com/mitsuhiko/status/1486126762346045442/photo/1</a></p><span>- Armin “vax ffs” Ronacher (@mitsuhiko)</span><div class=\"twitter-image\"><a href=\"https://t.co/2r10pJpF4A\"><img src=\"https://uploads.zulipusercontent.net/9bef4ba2ce6ecb1cac4836d360ea069ed8a0e09c/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f464a5f495a6530586f414d422d4a4e2e6a70673a736d616c6c\"></a></div></div></div>",
        "id": 269596449,
        "sender_full_name": "lqd",
        "timestamp": 1643300217
    },
    {
        "content": "<p>Personally, I'd be fine with a <code>function!()</code> that returns the simple function name, but I'd also really like a <code>full_path!()</code> or something that gives a 'proper' current path.</p>",
        "id": 269597395,
        "sender_full_name": "CraftSpider",
        "timestamp": 1643300618
    },
    {
        "content": "<p>ah, found the prior wishlist issue: <a href=\"https://github.com/rust-lang/rfcs/issues/1743\">https://github.com/rust-lang/rfcs/issues/1743</a></p>",
        "id": 269600423,
        "sender_full_name": "bstrie",
        "timestamp": 1643301861
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"213696\">@Armin Ronacher</span>'s RFC from 2014: <a href=\"https://github.com/rust-lang/rfcs/pull/466\">https://github.com/rust-lang/rfcs/pull/466</a><br>\n<span class=\"user-mention\" data-user-id=\"301846\">@Sebastian Dröge</span>'s RFC from 2016: <a href=\"https://github.com/rust-lang/rfcs/pull/1719\">https://github.com/rust-lang/rfcs/pull/1719</a><br>\n<span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>'s RFC from 2019: <a href=\"https://github.com/rust-lang/rfcs/pull/2818\">https://github.com/rust-lang/rfcs/pull/2818</a></p>",
        "id": 269603928,
        "sender_full_name": "bstrie",
        "timestamp": 1643303193
    },
    {
        "content": "<p>in all of these cases it looks like people were enthusiastic about it, but nobody had the time to really push it forward</p>",
        "id": 269603974,
        "sender_full_name": "bstrie",
        "timestamp": 1643303214
    },
    {
        "content": "<p>since the primary use case for this appears to be diagnostic/error reporting and has some overlap with backtraces, maybe <span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby [she/her]</span> has thoughts?</p>",
        "id": 269611598,
        "sender_full_name": "bstrie",
        "timestamp": 1643306199
    },
    {
        "content": "<p>it looks like <code>__func__</code> in C++ has implementation-defined output <a href=\"https://eel.is/c++draft/dcl.fct.def#general-8\">https://eel.is/c++draft/dcl.fct.def#general-8</a> , although <a href=\"https://docs.microsoft.com/en-us/cpp/cpp/func?view=msvc-170\">https://docs.microsoft.com/en-us/cpp/cpp/func?view=msvc-170</a> says it's \"the unqualified and unadorned name of the enclosing function\"</p>",
        "id": 269612548,
        "sender_full_name": "bstrie",
        "timestamp": 1643306478
    },
    {
        "content": "<p>if people are just going to be gluing the output of this macro onto <code>module_path!</code> then we might as well just provide <code>function_path!</code> for the fully-qualified name. but if people have use cases for both the qualified and unqualified function names, rather than forcing them to glue/split strings we could have both <code>function!</code> and <code>function_path!</code></p>",
        "id": 269613217,
        "sender_full_name": "bstrie",
        "timestamp": 1643306686
    },
    {
        "content": "<p>The perfect topic to have a lot of bikeshedding about :)</p>",
        "id": 269613383,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643306744
    },
    {
        "content": "<p>what's your specific use case? you've been requesting this since 2014, I'm curious if your use cases have changed since then</p>",
        "id": 269613521,
        "sender_full_name": "bstrie",
        "timestamp": 1643306790
    },
    {
        "content": "<p>So the most recent use case where I am using it for is to discover the name of the test function that contains an assertion. For that I'm now using the type_name hack that was linked above as a replacement for using the thread name which is unreliable. A lot of the use cases for accessing function name are error reporting and utiltiies for tests</p>",
        "id": 269613728,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643306872
    },
    {
        "content": "<p>I will say that I have since learned that closures make this slightly more complex but not excessively so.</p>",
        "id": 269613806,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643306899
    },
    {
        "content": "<p>There is also <a href=\"https://docs.rs/function_name/latest/function_name\">https://docs.rs/function_name/latest/function_name</a>, although it needs that companion attribute, severely hindering its usefulness</p>",
        "id": 269615822,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643307776
    },
    {
        "content": "<p>Also, <em>w.r.t</em> <code>module_path!</code>, I've found it to be more disappointing than useful, given the lack of eager expansion. I'd love to see CPS-style macros for these things, so that other macros can work off that:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">with_module_path</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$($module_path</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* other macros can inspect the $module_path */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">$($module_path</span><span class=\"p\">)</span><span class=\"o\">*</span>::<span class=\"n\">SomeThing</span><span class=\"w\"></span>\n<span class=\"p\">)}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>function_name!</code> also seems relevant in that regard:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">recurse</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$($args</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">with_function_name</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$function_name</span>:<span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span>::<span class=\"cp\">$function_name</span><span class=\"p\">(</span><span class=\"cp\">$($args</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)}</span><span class=\"w\"></span>\n<span class=\"p\">)}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269616418,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643308017
    },
    {
        "content": "<p>here's a contrived example using Armin 's macro <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=bab3ba760b83eecbec326018dd0eb243\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=bab3ba760b83eecbec326018dd0eb243</a> , demonstrating that it gets the fully-qualified path (including mods, traits, generics, and mods-inside-fns), but omitting <code>::{{closure}}</code> if it's the very last component of the path. I think that an implementation in std wouldn't want to omit the <code>::{{closure}}</code> part, but several of the previous proposals suggest making it more useful, such as <code>::{{closure#N}}</code> where <code>N</code> represents some sort of disambiguator. <span class=\"user-mention\" data-user-id=\"213696\">@Armin Ronacher</span> , does that sound like something you would use?</p>",
        "id": 269618884,
        "sender_full_name": "bstrie",
        "timestamp": 1643309116
    },
    {
        "content": "<p>I think it’s better for {{closure}} to be left in. Users can always easily remove it</p>",
        "id": 269619601,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643309406
    },
    {
        "content": "<p>The N part would likely make this more complex though</p>",
        "id": 269619625,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643309420
    },
    {
        "content": "<p>one of the RFCs mentions as an alternative that generalizing this to <code>item_path!</code> might be useful:</p>",
        "id": 269619668,
        "sender_full_name": "bstrie",
        "timestamp": 1643309451
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// item_path!() ==&gt; foo</span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">item_path</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// foo::X</span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">A</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Y</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">item_path</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// foo::A::Y</span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">fun</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// item_path!() ==&gt; foo::A::fun</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">type</span> <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Stuff</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"n\">item_path</span><span class=\"o\">!</span><span class=\"p\">()}</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"c1\">// Stuff&lt;\"foo::T\"&gt;</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269619689,
        "sender_full_name": "bstrie",
        "timestamp": 1643309462
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/219381-t-libs/topic/macro.20for.20getting.20the.20function.20name/near/269611598\">said</a>:</p>\n<blockquote>\n<p>since the primary use case for this appears to be diagnostic/error reporting and has some overlap with backtraces, maybe <span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> has thoughts?</p>\n</blockquote>\n<p>I don't have strong thoughts other than that i've wanted this for tracing as well</p>",
        "id": 269620228,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1643309703
    },
    {
        "content": "<p>where the spans don't get to include the function name and so the module path is sometimes misleading iirc</p>",
        "id": 269620416,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1643309788
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216718\">@Hoverbear (飘飘熊)</span>  brought this up recently and might have better details than I do</p>",
        "id": 269620455,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1643309810
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/macro.20for.20getting.20the.20function.20name/near/269620455\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"216718\">Hoverbear (飘飘熊)</span>  brought this up recently and might have better details than I do</p>\n</blockquote>\n<p>In my case it was the struct associated with a function (eg the <code>fn foo()</code> of an impl block.</p>",
        "id": 269626115,
        "sender_full_name": "Hoverbear (飘飘熊)",
        "timestamp": 1643312281
    },
    {
        "content": "<p>Is this needed as a macro (so it can be used as input to other macros), or would it suffice to have it like <code>Location::caller()</code>, essentially being a function that you call and that returns a <code>&amp;'static str</code>?</p>",
        "id": 269626597,
        "sender_full_name": "oli",
        "timestamp": 1643312476
    },
    {
        "content": "<p>The latter is straight forward to implement. For the former I have various questions. Not about the impl, but the expected behaviour in general</p>",
        "id": 269626796,
        "sender_full_name": "oli",
        "timestamp": 1643312563
    },
    {
        "content": "<p>good question, lots of these are macros by dint of being \"too weird to be a normal function\", but that doesn't mean that they couldn't be a wrapper over an intrinsic or something</p>",
        "id": 269626835,
        "sender_full_name": "bstrie",
        "timestamp": 1643312587
    },
    {
        "content": "<p>It would be a breaking change to make <code>file!</code> be backed by an intrinsic</p>",
        "id": 269627006,
        "sender_full_name": "oli",
        "timestamp": 1643312659
    },
    {
        "content": "<p>Because then you can't do <code>concat!(file!(), \"foo\")</code></p>",
        "id": 269627065,
        "sender_full_name": "oli",
        "timestamp": 1643312689
    },
    {
        "content": "<p>sure, but with improved const machinery maybe we could have a <code>concat</code> function that outputs a static str? <code>let x: &amp;'static str = const { \"foo\".concat(\"bar\") };</code></p>",
        "id": 269627597,
        "sender_full_name": "bstrie",
        "timestamp": 1643312905
    },
    {
        "content": "<p>people really, <em>really</em> would love that</p>",
        "id": 269628024,
        "sender_full_name": "Lokathor",
        "timestamp": 1643313083
    },
    {
        "content": "<p>i can't tell you how much people want that, English lacks the words, etc</p>",
        "id": 269628111,
        "sender_full_name": "Lokathor",
        "timestamp": 1643313117
    },
    {
        "content": "<p>That's not the issue. The issue is that you can use the concatenated result as input to format strings or even <code>include!</code>. I can make concat in CTFE right now, possibly even on stable</p>",
        "id": 269633081,
        "sender_full_name": "oli",
        "timestamp": 1643315375
    },
    {
        "content": "<p>Lol what if we made the concat macro use CTFE where it currently errors due to non-literal arguments? EDIT: off topic, moving this specific thread to the const eval stream</p>",
        "id": 269633278,
        "sender_full_name": "oli",
        "timestamp": 1643315469
    },
    {
        "content": "<p>My hunch is that it does not matter if this is a macro vs the <code>Location::caller</code> but it has to be a static string slice to be useful</p>",
        "id": 269636617,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643317029
    },
    {
        "content": "<p><code>__func__</code> in C++ is also not a macro that expands to a string literal.  it's an implicit <code>static const char[]</code> variable.</p>",
        "id": 269638704,
        "sender_full_name": "Mara",
        "timestamp": 1643317930
    },
    {
        "content": "<p>Which somewhat makes sense because it's easier to implement for most compilers probably</p>",
        "id": 269650732,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643322992
    },
    {
        "content": "<p>knowhing in which function you are form the preprocessor sounds insane</p>",
        "id": 269650788,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643323015
    },
    {
        "content": "<p>I would love to have <code>item_path!</code> as well, giving the full path to the containing function or item.</p>",
        "id": 269650814,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643323025
    },
    {
        "content": "<p>Though I can imagine an ambiguity there.</p>",
        "id": 269650989,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643323110
    },
    {
        "content": "<p>If you write a struct definition inside a function, and use <code>item_path!</code>, would you want the struct included in the item path?</p>",
        "id": 269651103,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643323167
    },
    {
        "content": "<p>In any case, I'm curious: if both <code>module_path!</code> and <code>item_path!</code> existed, would folks still want a <code>function!</code> that returns <em>just</em> the containing function name and no context for where that function is?</p>",
        "id": 269651149,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643323192
    },
    {
        "content": "<p>my hunch is no, because of closures. a <code>function!</code> that might return <code>{{closure}}</code> exclusively does not seem useful without always having to combine it with <code>item_path!</code></p>",
        "id": 269651861,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643323549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/macro.20for.20getting.20the.20function.20name/near/269651103\">said</a>:</p>\n<blockquote>\n<p>If you write a struct definition inside a function, and use <code>item_path!</code>, would you want the struct included in the item path?</p>\n</blockquote>\n<p>I guess it should report the path the same way as we encode it before mangling. That can be misleading though, because something like <code>fn foo() { fn bar() {} }</code> becomes <code>::foo::bar</code>, even though you can't actually call it that way.</p>",
        "id": 269652231,
        "sender_full_name": "cuviper",
        "timestamp": 1643323714
    },
    {
        "content": "<p>you can even shadow that in nested blocks</p>",
        "id": 269652793,
        "sender_full_name": "cuviper",
        "timestamp": 1643324027
    },
    {
        "content": "<p>I’m starting to think that Location::caller is the right place for this</p>",
        "id": 270427032,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643823761
    },
    {
        "content": "<p>But it’s kinda odd that Location is placed in std::panic</p>",
        "id": 270427130,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1643823794
    },
    {
        "content": "<p>it's possible for a type to move, as long as the old location exports it too</p>",
        "id": 270447076,
        "sender_full_name": "Mara",
        "timestamp": 1643831515
    },
    {
        "content": "<p>I've needed the Location outside of a panic, but it has never bothered me that the module path mentions panic stuff. It's fine either way</p>",
        "id": 270447248,
        "sender_full_name": "Lokathor",
        "timestamp": 1643831586
    },
    {
        "content": "<p>Does anyone know if there is some movement here in making this work?</p>",
        "id": 274836364,
        "sender_full_name": "Armin Ronacher",
        "timestamp": 1646919975
    },
    {
        "content": "<p>i'm not aware of anyone working on this</p>",
        "id": 274859540,
        "sender_full_name": "Mara",
        "timestamp": 1646929716
    },
    {
        "content": "<p>FYI, just yesterday I opened an issue in GitHub regarding adding the function name to Location: <a href=\"https://github.com/rust-lang/rust/issues/95529\">https://github.com/rust-lang/rust/issues/95529</a> (since we'd like to use Location for a kind of fast error call trace for productive purposes with async code, where neither backtrace nor other options are good enough). I added some reasoning why there. <span class=\"user-mention\" data-user-id=\"273349\">@Waffle Lapkin</span> pointed me to this thread from there.</p>\n<p>(note: until today, I was not aware of the existence of Zulip at all and of this thread in particular, so bear with me)</p>",
        "id": 277395831,
        "sender_full_name": "Ivan Schréter",
        "timestamp": 1648808235
    }
]