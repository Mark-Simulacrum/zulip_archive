[
    {
        "content": "<p>I'm wondering if the optimization here is correct: <a href=\"https://github.com/rust-lang/rust/blob/ae90dcf0207c57c3034f00b07048d63f8b2363c8/library/core/src/slice/specialize.rs#L22-L28\">https://github.com/rust-lang/rust/blob/ae90dcf0207c57c3034f00b07048d63f8b2363c8/library/core/src/slice/specialize.rs#L22-L28</a></p>\n<p>Specifically if T is <code>MaybeUninit&lt;u8&gt;</code>. It momentarily transmutes that to an u8 before passing it to <code>write_bytes</code>.</p>",
        "id": 248871405,
        "sender_full_name": "The 8472",
        "timestamp": 1628526180
    },
    {
        "content": "<p>Heh, good point. We may want to use <code>MaybeUninit&lt;u8&gt;</code> here</p>",
        "id": 248872271,
        "sender_full_name": "oli",
        "timestamp": 1628526589
    },
    {
        "content": "<p><code>write_bytes</code> wants a <code>u8</code> though.</p>",
        "id": 248872390,
        "sender_full_name": "Mara",
        "timestamp": 1628526631
    },
    {
        "content": "<p>oh, but then <code>write_bytes</code> can't work <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span></p>",
        "id": 248872391,
        "sender_full_name": "oli",
        "timestamp": 1628526632
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">MaybeUninit</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">fill</span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>error: Undefined Behavior: using uninitialized data, but this operation requires initialized memory\n    --&gt; /home/mara/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics.rs:2191:14\n     |\n2191 |     unsafe { write_bytes(dst, val, count) }\n     |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ using uninitialized data, but this operation requires initialized memory\n     |\n     = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n     = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n</code></pre></div>",
        "id": 248872663,
        "sender_full_name": "Mara",
        "timestamp": 1628526767
    },
    {
        "content": "<p>:(</p>",
        "id": 248872665,
        "sender_full_name": "Mara",
        "timestamp": 1628526770
    },
    {
        "content": "<p>we could add an intrinsic similar to <a href=\"https://doc.rust-lang.org/core/intrinsics/fn.assert_zero_valid.html\">https://doc.rust-lang.org/core/intrinsics/fn.assert_zero_valid.html</a> that returns <code>true</code> instead of panicking, so we can make decisions on that</p>",
        "id": 248872770,
        "sender_full_name": "oli",
        "timestamp": 1628526827
    },
    {
        "content": "<p>time to make <code>std::panic::catch_unwind(|| assert_zero_valid::&lt;T&gt;()).is_none()</code> a const fn. ;)</p>",
        "id": 248872998,
        "sender_full_name": "Mara",
        "timestamp": 1628526914
    },
    {
        "content": "<p><span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 248873113,
        "sender_full_name": "oli",
        "timestamp": 1628526964
    },
    {
        "content": "<p>How do get uninitialized bytes normally get moved around?</p>",
        "id": 248873133,
        "sender_full_name": "The 8472",
        "timestamp": 1628526974
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 248873173,
        "sender_full_name": "Mara",
        "timestamp": 1628526999
    },
    {
        "content": "<p>you can move them, you just can't put them into a type that expects to be initialized</p>",
        "id": 248873189,
        "sender_full_name": "oli",
        "timestamp": 1628527009
    },
    {
        "content": "<p>yeah, but if you can move them something has to do the moving without blowing up</p>",
        "id": 248873264,
        "sender_full_name": "The 8472",
        "timestamp": 1628527037
    },
    {
        "content": "<p>most of our code around moving things is generic</p>",
        "id": 248873280,
        "sender_full_name": "oli",
        "timestamp": 1628527045
    },
    {
        "content": "<p>can write_bytes be taught to do the same?</p>",
        "id": 248873290,
        "sender_full_name": "The 8472",
        "timestamp": 1628527049
    },
    {
        "content": "<p>oh heh</p>",
        "id": 248873306,
        "sender_full_name": "oli",
        "timestamp": 1628527055
    },
    {
        "content": "<p>not sure</p>",
        "id": 248873317,
        "sender_full_name": "oli",
        "timestamp": 1628527062
    },
    {
        "content": "<p>you'd need a write_bytes that takes a MaybeUninit&lt;u8&gt; instead of a u8</p>",
        "id": 248873332,
        "sender_full_name": "Mara",
        "timestamp": 1628527067
    },
    {
        "content": "<p>depends on what the underlying LLVM intrinsic is</p>",
        "id": 248873342,
        "sender_full_name": "oli",
        "timestamp": 1628527072
    },
    {
        "content": "<p>we can't change the library function, but this is in libcore, we can use intrinsics</p>",
        "id": 248873423,
        "sender_full_name": "oli",
        "timestamp": 1628527091
    },
    {
        "content": "<p>but such a write_maybe_uninit_bytes might not have a nice implementation as write_bytes</p>",
        "id": 248873431,
        "sender_full_name": "Mara",
        "timestamp": 1628527097
    },
    {
        "content": "<p>the LLVM docs don't make it clear to me whether the value arg can be undef: <a href=\"https://llvm.org/docs/LangRef.html#llvm-memset-intrinsics\">https://llvm.org/docs/LangRef.html#llvm-memset-intrinsics</a></p>",
        "id": 248873697,
        "sender_full_name": "oli",
        "timestamp": 1628527231
    },
    {
        "content": "<p><code>assert_zero_valid</code> also wouldn't be quite the right tool since you could do <code>slice.fill(NonZeroU8::new(1))</code> and ideally that would become a memset.</p>",
        "id": 248874458,
        "sender_full_name": "The 8472",
        "timestamp": 1628527576
    },
    {
        "content": "<p>yeah, not exactly that instrinsic, but something similar that checks that it can't be undef.</p>",
        "id": 248874519,
        "sender_full_name": "Mara",
        "timestamp": 1628527610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> generally there's no reason uninit cannot be used as a value. But there's also no reason LLVM wouldn't just remove the memset immediately.</p>",
        "id": 248874707,
        "sender_full_name": "nagisa",
        "timestamp": 1628527722
    },
    {
        "content": "<p>that's fine. copying/assigning an uninit MaybeUninit is also a nop</p>",
        "id": 248874742,
        "sender_full_name": "Mara",
        "timestamp": 1628527743
    },
    {
        "content": "<p>yea, then we can fix our intrinsic</p>",
        "id": 248874776,
        "sender_full_name": "oli",
        "timestamp": 1628527759
    },
    {
        "content": "<p>not sure what to do on the libs level, but that seems orthogonal</p>",
        "id": 248874791,
        "sender_full_name": "oli",
        "timestamp": 1628527769
    },
    {
        "content": "<p>so if that's fine, we should just change the intrinsic signature to take a MaybeUninit&lt;u8&gt;</p>",
        "id": 248874794,
        "sender_full_name": "Mara",
        "timestamp": 1628527770
    },
    {
        "content": "<p>do we need that <code>if size == 1</code> case there at all btw? for e.g. u64 llvm is smart enough to turn that loop in the <code>else</code> branch into a <code>memset</code> too.</p>",
        "id": 248875743,
        "sender_full_name": "Mara",
        "timestamp": 1628528270
    },
    {
        "content": "<p>i am no expert in this area, but IIRC, i thought that it hadn't been decided whether unitialized <code>u8</code> was UB or not? (of course, reading from it would be, but i had thought it was still an open question as to whether it simply exists would make it insta UB.) i can't find the words i have in my memory, but i thought they were from <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> a while back. (which i could be misrepresenting here.)</p>",
        "id": 248876870,
        "sender_full_name": "BurntSushi",
        "timestamp": 1628528696
    },
    {
        "content": "<p>i remember that it wasn't entirely decided whether a <code>&amp;mut u8</code> pointing to an uninit u8 is UB, but not sure about <code>u8</code>s by themselves.</p>",
        "id": 248877005,
        "sender_full_name": "Mara",
        "timestamp": 1628528752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/potential.20UB.20in.20slice.3A.3Afill/near/248875743\">said</a>:</p>\n<blockquote>\n<p>do we need that <code>if size == 1</code> case there at all btw? for e.g. u64 llvm is smart enough to turn that loop in the <code>else</code> branch into a <code>memset</code> too.</p>\n</blockquote>\n<p>There was some speculation about it being potentially useful for less optimizing backends, but no concrete answers.</p>",
        "id": 248877080,
        "sender_full_name": "The 8472",
        "timestamp": 1628528770
    },
    {
        "content": "<p>filed this topic as an issue btw: <a href=\"https://github.com/rust-lang/rust/issues/87891\">https://github.com/rust-lang/rust/issues/87891</a></p>",
        "id": 248877081,
        "sender_full_name": "Mara",
        "timestamp": 1628528770
    },
    {
        "content": "<p>not sure if this is still the latest thinking on the topic or not: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/active_discussion/validity.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/active_discussion/validity.md</a></p>",
        "id": 248877235,
        "sender_full_name": "BurntSushi",
        "timestamp": 1628528845
    },
    {
        "content": "<p>\"Integers and floating point types\" -&gt; \"Do we allow values that contain uninitialized bits?\"</p>",
        "id": 248877287,
        "sender_full_name": "BurntSushi",
        "timestamp": 1628528872
    },
    {
        "content": "<p>and assembly was smaller with this specialization, a few avoided branches. but those would only be significant for short slices</p>",
        "id": 248877346,
        "sender_full_name": "The 8472",
        "timestamp": 1628528886
    },
    {
        "content": "<p>i'd assume that llvm is pretty good at picking the right threshold between an (unrolled) loop and calling memset</p>",
        "id": 248877546,
        "sender_full_name": "Mara",
        "timestamp": 1628528986
    },
    {
        "content": "<p><a href=\"https://rust.godbolt.org/z/P1ePM7r3W\">https://rust.godbolt.org/z/P1ePM7r3W</a></p>",
        "id": 248877828,
        "sender_full_name": "The 8472",
        "timestamp": 1628529103
    },
    {
        "content": "<p>rust 1.50 didn't have the Copy specialization either, so that's not really a good comparison</p>",
        "id": 248878274,
        "sender_full_name": "Mara",
        "timestamp": 1628529271
    },
    {
        "content": "<p>1.52 has the Copy specialization but not the size==1 specialization, but it has no #[inline] on them, so that doesn't work either.</p>",
        "id": 248878481,
        "sender_full_name": "Mara",
        "timestamp": 1628529362
    },
    {
        "content": "<p><a href=\"https://rust.godbolt.org/z/vWrfWvbvE\">https://rust.godbolt.org/z/vWrfWvbvE</a></p>",
        "id": 248878640,
        "sender_full_name": "The 8472",
        "timestamp": 1628529418
    },
    {
        "content": "<p>i tried a few different things locally, but so far i haven't found anything where the <code>size == 1</code> case results in better code.</p>",
        "id": 248878699,
        "sender_full_name": "Mara",
        "timestamp": 1628529443
    },
    {
        "content": "<p>oh nvm, it can only do it if it knows the bytes are constant, d'uh.</p>",
        "id": 248878768,
        "sender_full_name": "The 8472",
        "timestamp": 1628529465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/potential.20UB.20in.20slice.3A.3Afill/near/248878640\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://rust.godbolt.org/z/vWrfWvbvE\">https://rust.godbolt.org/z/vWrfWvbvE</a></p>\n</blockquote>\n<p>sure. memset can't write arbitrary u64s. only works if all bytes of it are identical. e.g. 0u64.</p>",
        "id": 248878769,
        "sender_full_name": "Mara",
        "timestamp": 1628529465
    },
    {
        "content": "<p>yeah</p>",
        "id": 248878782,
        "sender_full_name": "The 8472",
        "timestamp": 1628529472
    },
    {
        "content": "<p>it produces one extra jump with a fixed u64</p>",
        "id": 248879038,
        "sender_full_name": "The 8472",
        "timestamp": 1628529578
    },
    {
        "content": "<p>to avoid it for zero sized slices. depends on the situation whether that's a good or bad thing</p>",
        "id": 248879329,
        "sender_full_name": "Mara",
        "timestamp": 1628529688
    },
    {
        "content": "<p>(if you change it to a <code>&amp;mut [u64; 200]</code> it disappears)</p>",
        "id": 248879606,
        "sender_full_name": "Mara",
        "timestamp": 1628529780
    },
    {
        "content": "<p>refresher: <code>&amp;mut T</code> must point to a valid <code>T</code>, absolutely, but since <code>u8</code> <em>might</em> be valid when uninit (this is the part that isn't decided).</p>\n<p>If <code>u8</code> is valid when uninit, then <code>&amp;mut u8</code> can point at an uninit u8 and still be valid.</p>",
        "id": 248907743,
        "sender_full_name": "Lokathor",
        "timestamp": 1628543006
    },
    {
        "content": "<blockquote>\n<p>&amp;mut T must point to a valid T, absolutely,</p>\n</blockquote>\n<p>I mean this rule is still something I want to abolish ;) and Miri doesn't implement it -- but it's what we currently document since it is the most conservative choice</p>",
        "id": 248982660,
        "sender_full_name": "RalfJ",
        "timestamp": 1628604064
    },
    {
        "content": "<p>ralf pulling the rug out from under me yet again.</p>\n<p>though if i remember my llvm ir lore properly then it would seem to make sense to relax that rule.</p>",
        "id": 249002865,
        "sender_full_name": "Lokathor",
        "timestamp": 1628613331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/potential.20UB.20in.20slice.3A.3Afill/near/248907743\">said</a>:</p>\n<blockquote>\n<p>refresher: <code>&amp;mut T</code> must point to a valid <code>T</code>, absolutely, but <code>u8</code> <em>might</em> be valid when uninit (this is the part that isn't decided).</p>\n<p>If <code>u8</code> is valid when uninit, then <code>&amp;mut u8</code> can point at an uninit u8 and still be valid.</p>\n</blockquote>\n<p>that's just not true. right now an uninit <code>u8</code> is not okay, but we do use &amp;mut's to uninit data in some parts of std::io right now, which is 'okay'*-ish. (e.g. <a href=\"https://doc.rust-lang.org/stable/std/io/struct.Initializer.html#method.initialize\">this</a>)</p>",
        "id": 249121156,
        "sender_full_name": "Mara",
        "timestamp": 1628694434
    },
    {
        "content": "<p>the validity of integers is still an open question, the topic is here: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/71\">https://github.com/rust-lang/unsafe-code-guidelines/issues/71</a></p>\n<p>As to the other part, Ralf covered that.</p>",
        "id": 249122552,
        "sender_full_name": "Lokathor",
        "timestamp": 1628695016
    },
    {
        "content": "<p>it might be an open question as to whether to relax it, but right now it causes UB and/or angry miri. that's not the case for the <code>&amp;mut</code> thing.</p>",
        "id": 249130937,
        "sender_full_name": "Mara",
        "timestamp": 1628698612
    },
    {
        "content": "<p>yes, that's what Ralf said.</p>",
        "id": 249139796,
        "sender_full_name": "Lokathor",
        "timestamp": 1628702613
    },
    {
        "content": "<p>in the mean time we can just adjust the intrinsic until we know more</p>",
        "id": 249159691,
        "sender_full_name": "oli",
        "timestamp": 1628711088
    },
    {
        "content": "<blockquote>\n<p>ralf pulling the rug out from under me yet again.</p>\n</blockquote>\n<p>sorry. :/ but I think I've been very consistent in my stanza on reference validity for several years now</p>",
        "id": 249340237,
        "sender_full_name": "RalfJ",
        "timestamp": 1628847447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/potential.20UB.20in.20slice.3A.3Afill/near/249121156\">said</a>:</p>\n<blockquote>\n<p>that's just not true. right now an uninit <code>u8</code> is not okay, but we do use &amp;mut's to uninit data in some parts of std::io right now, which is 'okay'*-ish. (e.g. <a href=\"https://doc.rust-lang.org/stable/std/io/struct.Initializer.html#method.initialize\">this</a>)</p>\n</blockquote>\n<p>libstd is using privileged compiler knowledge here. this is explicitly violating the rules we currently have in the reference.</p>\n<p>under the rules as I think they should be, this would not be UB, but it's still unsafe to give uninit <code>u8</code> to unknown code implementing the <code>Write</code> trait, so this libstd API is doomed anyway (and a better replacement has already been RFCd)</p>",
        "id": 249340412,
        "sender_full_name": "RalfJ",
        "timestamp": 1628847564
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/potential.20UB.20in.20slice.3A.3Afill/near/249130937\">said</a>:</p>\n<blockquote>\n<p>it might be an open question as to whether to relax it, but right now it causes UB and/or angry miri. that's not the case for the <code>&amp;mut</code> thing.</p>\n</blockquote>\n<p>creating uninit <code>u8</code> doesnt cause angry miri. only actually using it for arithmetic does.<br>\nso this is UB according to the reference but Miri currently does not complain (but I plan to add a flag to make it complain):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249340503,
        "sender_full_name": "RalfJ",
        "timestamp": 1628847634
    },
    {
        "content": "<p>so a big part of the problem in the above discussion is that saying \"is not okay\" is very ambiguous. do you mean okay wrt</p>\n<ul>\n<li>the rules as written in the reference</li>\n<li>the rules as implemented in Miri</li>\n<li>the rules as actually exploited by the compiler</li>\n<li>the rules as I think they should be</li>\n</ul>\n<p>(and this is all just about UB; soundness adds another layer of questions)</p>",
        "id": 249340580,
        "sender_full_name": "RalfJ",
        "timestamp": 1628847711
    },
    {
        "content": "<p>this code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">().</span><span class=\"n\">assume_init</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is okay according to what is implemented in Miri or exploited by the compiler,<br>\nbut not okay according to the reference or according to how I think the rules should be.</p>",
        "id": 249340967,
        "sender_full_name": "RalfJ",
        "timestamp": 1628848005
    },
    {
        "content": "<p>this code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xref</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">assume_init_mut</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is okay according to what is implemented in Miri, exploited by the compiler, and how I think the rules should be;<br>\nbut not okay according to the reference.</p>",
        "id": 249341095,
        "sender_full_name": "RalfJ",
        "timestamp": 1628848089
    },
    {
        "content": "<p>this code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xref</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">assume_init_mut</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is okay according to what is implemented in Miri, or exploited by the compiler;<br>\nbut not okay according to the reference or how I think the rules should be.</p>",
        "id": 249341154,
        "sender_full_name": "RalfJ",
        "timestamp": 1628848153
    },
    {
        "content": "<p>that almost needs a state of the undefined union table</p>",
        "id": 249367779,
        "sender_full_name": "The 8472",
        "timestamp": 1628865249
    },
    {
        "content": "<p>Yeah I wasn't aware that the documented rules here were out of sync.</p>\n<p>Doesn't have to be a grand essay, but some bullet points would probably be good.</p>",
        "id": 249369573,
        "sender_full_name": "Lokathor",
        "timestamp": 1628866127
    },
    {
        "content": "<p>yeah this UCG validity thing is dragging on longer than I anticipated</p>",
        "id": 249458862,
        "sender_full_name": "RalfJ",
        "timestamp": 1628946016
    }
]