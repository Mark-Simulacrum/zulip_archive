[
    {
        "content": "<p>the definition of <code>ffi::c_void</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// N.B., for LLVM to recognize the void pointer type and by extension</span>\n<span class=\"c1\">//     functions like malloc(), we need to have it represented as i8* in</span>\n<span class=\"c1\">//     LLVM bitcode. The enum used here ensures this and prevents misuse</span>\n<span class=\"c1\">//     of the \"raw\" type by only having private variants. We need two</span>\n<span class=\"c1\">//     variants, because the compiler complains about the repr attribute</span>\n<span class=\"c1\">//     otherwise and we need at least one variant as otherwise the enum</span>\n<span class=\"c1\">//     would be uninhabited and at least dereferencing such pointers would</span>\n<span class=\"c1\">//     be UB.</span>\n<span class=\"cp\">#[repr(u8)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[stable(feature = </span><span class=\"s\">\"core_c_void\"</span><span class=\"cp\">, since = </span><span class=\"s\">\"1.30.0\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">c_void</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[unstable(</span>\n<span class=\"cp\">        feature = </span><span class=\"s\">\"c_void_variant\"</span><span class=\"cp\">,</span>\n<span class=\"cp\">        reason = </span><span class=\"s\">\"temporary implementation detail\"</span><span class=\"cp\">,</span>\n<span class=\"cp\">        issue = </span><span class=\"s\">\"none\"</span><span class=\"cp\"></span>\n<span class=\"cp\">    )]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[doc(hidden)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">__variant1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[unstable(</span>\n<span class=\"cp\">        feature = </span><span class=\"s\">\"c_void_variant\"</span><span class=\"cp\">,</span>\n<span class=\"cp\">        reason = </span><span class=\"s\">\"temporary implementation detail\"</span><span class=\"cp\">,</span>\n<span class=\"cp\">        issue = </span><span class=\"s\">\"none\"</span><span class=\"cp\"></span>\n<span class=\"cp\">    )]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[doc(hidden)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">__variant2</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The comment gives the reason for the dummy variants, but I'm not sure why they're noted as \"temporary implementation details\". What is the long-term non-temporary solution?</p>",
        "id": 273650386,
        "sender_full_name": "bstrie",
        "timestamp": 1646145625
    },
    {
        "content": "<p>Enum variants can't be made private so they are made unstable here instead.</p>",
        "id": 273651165,
        "sender_full_name": "bjorn3",
        "timestamp": 1646146025
    },
    {
        "content": "<p>Sure, but what's the temporary aspect? I'm trying to do some archaeology and maybe it looks like people were hoping to someday change the layout of c_void, but I'm not sure what that would be useful for and I'm also not sure how feasible that is</p>",
        "id": 273651752,
        "sender_full_name": "bstrie",
        "timestamp": 1646146268
    },
    {
        "content": "<p>I have a question regarding <code>#[repr(u8)]</code> usage in here -- it looks like it works on enums with only a single variant, doesn't it?</p>",
        "id": 273653595,
        "sender_full_name": "lovelymono",
        "timestamp": 1646146884
    },
    {
        "content": "<p><code>#[repr(u8)]</code> works just fine with multiple variants.</p>",
        "id": 273653733,
        "sender_full_name": "bjorn3",
        "timestamp": 1646146934
    },
    {
        "content": "<p>Yes, but the comment there is</p>\n<blockquote>\n<p>We need two variants, because the compiler complains about the repr attribute otherwise</p>\n</blockquote>\n<p>Wouldn't just a single variant be sufficient?</p>",
        "id": 273653857,
        "sender_full_name": "lovelymono",
        "timestamp": 1646146995
    },
    {
        "content": "<p>I assume the One True Form would be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">c_void</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This isn't obviously an <code>i8*</code> though:</p>\n<div class=\"codehilite\" data-code-language=\"LLVM\"><pre><span></span><code><span class=\"nv\">%c_void</span><span class=\"w\"> </span><span class=\"p\">=</span><span class=\"w\"> </span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273659753,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646149276
    },
    {
        "content": "<p>And it does look like a single variant is fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(u8)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">c_void</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_X</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">c_void</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"LLVM\"><pre><span></span><code><span class=\"k\">define</span><span class=\"w\"> </span><span class=\"k\">void</span><span class=\"w\"> </span><span class=\"vg\">@_ZN10playground7example17haf1118224540cb67E</span><span class=\"p\">(</span><span class=\"kt\">i8</span><span class=\"p\">*</span><span class=\"w\"> </span><span class=\"nv\">%_1</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">unnamed_addr</span><span class=\"w\"> </span><span class=\"vg\">#0</span><span class=\"w\"> </span><span class=\"nv\">!dbg</span><span class=\"w\"> </span><span class=\"nv nv-Anonymous\">!12</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273660152,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646149442
    },
    {
        "content": "<p>I wonder if the opaque pointer work in LLVM would help here, as hopefully <code>malloc</code> wouldn't be hardcoded to <code>i8*</code> anymore.</p>",
        "id": 273660572,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646149603
    },
    {
        "content": "<p>Shall we at least file an issue for this?</p>",
        "id": 273661034,
        "sender_full_name": "bstrie",
        "timestamp": 1646149789
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ git grep &#39;issue = &quot;none&quot;&#39; | wc -l\n575\n</code></pre></div>\n<p>sigh...</p>",
        "id": 273661234,
        "sender_full_name": "bstrie",
        "timestamp": 1646149856
    },
    {
        "content": "<p>Many of those are intentionally perma-unstable, and a tracking issue doesn't really make sense for them, IMO, since we would not really entertain a request to stabilize them directly.</p>",
        "id": 273661490,
        "sender_full_name": "simulacrum",
        "timestamp": 1646149933
    },
    {
        "content": "<p>yes, there are plenty of tests that make use of dummy stability attributes, but it does make it somewhat hard to find places like the above that should have issues but just don't</p>",
        "id": 273661674,
        "sender_full_name": "bstrie",
        "timestamp": 1646149990
    },
    {
        "content": "<p>The enum variants above don't seem like they should have issues? Those look permanently unstable to me</p>",
        "id": 273662170,
        "sender_full_name": "simulacrum",
        "timestamp": 1646150139
    },
    {
        "content": "<p>Maybe a FIXME comment separately should point to an issue, but not the variants.</p>",
        "id": 273662220,
        "sender_full_name": "simulacrum",
        "timestamp": 1646150162
    },
    {
        "content": "<p>if it's perma unstable, then \"temporary implementation detail\" is misleading. Just changing the comment to say \"perma unstable\" would be fine though.</p>",
        "id": 273667624,
        "sender_full_name": "Lokathor",
        "timestamp": 1646151934
    },
    {
        "content": "<p>temporary things should be expressed through a FIXME and an issue, no?</p>",
        "id": 273670338,
        "sender_full_name": "The 8472",
        "timestamp": 1646152986
    },
    {
        "content": "<p>\"temporary implementation detail\" is ah<br>\naspirational wording</p>",
        "id": 273671333,
        "sender_full_name": "Jubilee",
        "timestamp": 1646153402
    },
    {
        "content": "<p>why doesn't rustc just treat pointers to <code>()</code> as equivalent to pointers to <code>void</code>, and tell LLVM it's a <code>i8*</code>?</p>",
        "id": 273678660,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646155864
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273660572\">said</a>:</p>\n<blockquote>\n<p>I wonder if the opaque pointer work in LLVM would help here, as hopefully <code>malloc</code> wouldn't be hardcoded to <code>i8*</code> anymore.</p>\n</blockquote>\n<p>This sounds like the real fix to me.  That and hopefully it can become an <code>extern type</code> at some point.</p>",
        "id": 273682682,
        "sender_full_name": "scottmcm",
        "timestamp": 1646157326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273678660\">said</a>:</p>\n<blockquote>\n<p>why doesn't rustc just treat pointers to <code>()</code> as equivalent to pointers to <code>void</code>, and tell LLVM it's a <code>i8*</code>?</p>\n</blockquote>\n<p>In part because <code>()</code> is a ZST and <code>i8</code> isn't.</p>",
        "id": 273712057,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646169626
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273712057\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273678660\">said</a>:</p>\n<blockquote>\n<p>why doesn't rustc just treat pointers to <code>()</code> as equivalent to pointers to <code>void</code>, and tell LLVM it's a <code>i8*</code>?</p>\n</blockquote>\n<p>In part because <code>()</code> is a ZST and <code>i8</code> isn't.</p>\n</blockquote>\n<p>hmm, just because we might tell LLVM it's a <code>i8*</code> doesn't mean we can't keep treating it as a ZST, where loads/stores are no-ops so no LLVM instructions are generated. In my opinion, treating <code>*const ()</code> -&gt; <code>i8*</code> as the canonical ABI lowering seems beneficial.</p>",
        "id": 273716263,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646171486
    },
    {
        "content": "<p>In a way it'd almost be good for c_void to be <code>[u8; usize::MAX/4]</code> or something so that any by-value use would end up being an error.</p>\n<p>But that's probably not worth doing if we can eventually do it properly with <code>extern type</code>.</p>",
        "id": 273718747,
        "sender_full_name": "scottmcm",
        "timestamp": 1646172526
    },
    {
        "content": "<p>/me stares at <code>usize::MAX/4</code>. what?</p>",
        "id": 273719174,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646172704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273719174\">said</a>:</p>\n<blockquote>\n<p>/me stares at <code>usize::MAX/4</code>. what?</p>\n</blockquote>\n<p>Well-formed, but big enough to likely cause a mono-time error if used by value.</p>",
        "id": 273730810,
        "sender_full_name": "scottmcm",
        "timestamp": 1646178956
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Ah, I see.</p>",
        "id": 273730872,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646178981
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273730810\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273719174\">said</a>:</p>\n<blockquote>\n<p>/me stares at <code>usize::MAX/4</code>. what?</p>\n</blockquote>\n<p>Well-formed, but big enough to likely cause a mono-time error if used by value.</p>\n</blockquote>\n<p>/me allocates one in segmented i86</p>",
        "id": 273736746,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646182684
    },
    {
        "content": "<p>reminds me of huge pointers on borland's compilers for dos...you could have arrays several times bigger than the max size_t iirc</p>",
        "id": 273737153,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646182924
    },
    {
        "content": "<p>Sounds fun. Can't wait to do that in lccc.</p>\n<p>But yes, I don't think that making <code>c_void</code> a huge array will rule it out either statically or dynamically everywhere. It should in most places, but segmented 8086 or even IA-32 would be an exception since you could shove it in it's entirely own domain of memory, both as a static or on the stack (since an isolated stack segment could easily give you free reign over the entire address space in the stack if PAE or Long (Compatibility) Mode is in use, or 16-bit protected mode/v8086 mode).</p>",
        "id": 273737381,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646183133
    },
    {
        "content": "<p>(Or even on an old 8086, or a 286, since you got 20 bits of address space, and 16-bits of address.)</p>",
        "id": 273738037,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646183544
    },
    {
        "content": "<p>I do think, rather than a hack like that, we should just have a \"never allow by-value use of this\" attribute that we can use.</p>",
        "id": 273738067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646183571
    },
    {
        "content": "<p>Which, in practice, would probably be handled most easily by finishing <code>extern type</code> support.</p>",
        "id": 273738088,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646183586
    },
    {
        "content": "<p>man a type you can never construct?</p>",
        "id": 273738109,
        "sender_full_name": "Jubilee",
        "timestamp": 1646183612
    },
    {
        "content": "<p>a type you can <strong>never</strong> construct, you say???</p>",
        "id": 273738115,
        "sender_full_name": "Jubilee",
        "timestamp": 1646183621
    },
    {
        "content": "<p>a type you can <strong>never</strong> construct<strong>!!!</strong></p>",
        "id": 273738124,
        "sender_full_name": "Jubilee",
        "timestamp": 1646183630
    },
    {
        "content": "<p>But has size 1, align 1, is ABI compatible with (when used behind a pointer) i8.</p>",
        "id": 273738171,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646183650
    },
    {
        "content": "<p>/me snrks.</p>",
        "id": 273738174,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646183651
    },
    {
        "content": "<p>I'd prefer avoiding a guarantee that <code>*const !</code> has the same abi as <code>*const i8</code>, tbh (similar for <code>*const ()</code>). Likewise for <code>*const (u8, !)</code> (of course, if it wasn't a guarantee, I could just be smarter than llvm, and not special-case the signature of <code>malloc</code>).</p>",
        "id": 273738399,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646183843
    },
    {
        "content": "<p>wait is it actually important that <code>void*</code> have a size and align of 1</p>",
        "id": 273738570,
        "sender_full_name": "Jubilee",
        "timestamp": 1646183990
    },
    {
        "content": "<p>Well, the important part (to llvm at least) is that <code>*const c_void</code> has pointer-to-character abi.</p>",
        "id": 273738650,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273738570\">said</a>:</p>\n<blockquote>\n<p>wait is it actually important that <code>void*</code> have a size and align of 1</p>\n</blockquote>\n<p>Yeah, if people use <code>c_void</code> as a type they expect an alignment of 1, and the ability to offset in terms of bytes. At one point doing math with <code>void *</code> required a C compiler extension, and strictly conforming C had to cast to <code>char *</code> first. I don't know if that is still required, or if standards-compliant C can do math directly on <code>void *</code> now.</p>",
        "id": 273738860,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646184172
    },
    {
        "content": "<p>It's still a GNU extension to do math on <code>void*</code>.</p>",
        "id": 273738900,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184202
    },
    {
        "content": "<p>Since pointer arithmetic is defined in terms of elements of an array, and you can't have an array of <code>void</code>.</p>",
        "id": 273738975,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184242
    },
    {
        "content": "<p>/me wonders how hard it would be to get that ratified as part of C2x or C2y.</p>",
        "id": 273739040,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646184271
    },
    {
        "content": "<p>no chance for C23</p>",
        "id": 273739064,
        "sender_full_name": "Jubilee",
        "timestamp": 1646184282
    },
    {
        "content": "<p>you are too late.</p>",
        "id": 273739069,
        "sender_full_name": "Jubilee",
        "timestamp": 1646184284
    },
    {
        "content": "<p>(It's also a general restriction - you can't do pointer arithmetic on any pointer to an incomplete type, mostly because it requires knowing the size of the type)</p>",
        "id": 273739073,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184287
    },
    {
        "content": "<p>Yeah, if C's release schedule is anything like C++'s, C23 is feature frozen. IDK if there even willl be a C2y. So, earliest is probably 2029 (if at all).</p>",
        "id": 273739133,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184324
    },
    {
        "content": "<p>C23 got feature frozen <em>very</em> recently, like in the past two weeks or so. There was a whole thing about it on twitter.</p>",
        "id": 273739637,
        "sender_full_name": "Lokathor",
        "timestamp": 1646184667
    },
    {
        "content": "<p><em>shrug</em>, not too worried about the timeline of such a change getting into C, given that compilers support it already.</p>",
        "id": 273739667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646184709
    },
    {
        "content": "<p>Mostly just thinking that it's a sufficiently widely used extension that it'd be nice to standardize it.</p>",
        "id": 273739714,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646184725
    },
    {
        "content": "<p>it's not quiiiite \"feature frozen\" I think, more that all the papers that will be considered are in, everything is hashing out the details.</p>",
        "id": 273739743,
        "sender_full_name": "Jubilee",
        "timestamp": 1646184771
    },
    {
        "content": "<p>Yes, that's what \"feature freeze\" is. They've  frozen the set of features that will be in the standard, and aren't accepting new ones. Not necessarily the forms those features take.</p>",
        "id": 273739923,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646184941
    },
    {
        "content": "<p>welllll~ okay.</p>",
        "id": 273740393,
        "sender_full_name": "Jubilee",
        "timestamp": 1646185247
    },
    {
        "content": "<p>I've heard people use it both ways, tbh. &lt;_&lt; ...and somewhat more importantly, anything accepted as a paper for consideration can still be booted, though I think they are close to settling all of the \"go/no-go\"s.</p>",
        "id": 273740490,
        "sender_full_name": "Jubilee",
        "timestamp": 1646185324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273738860\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273738570\">said</a>:</p>\n<blockquote>\n<p>wait is it actually important that <code>void*</code> have a size and align of 1</p>\n</blockquote>\n<p>Yeah, if people use <code>c_void</code> as a type they expect an alignment of 1, and the ability to offset in terms of bytes. At one point doing math with <code>void *</code> required a C compiler extension, and strictly conforming C had to cast to <code>char *</code> first. I don't know if that is still required, or if standards-compliant C can do math directly on <code>void *</code> now.</p>\n</blockquote>\n<p>The alignment of both <code>!</code> and <code>()</code> are 1, fwiw, in spite of them being ZSTs.</p>",
        "id": 273740843,
        "sender_full_name": "Jubilee",
        "timestamp": 1646185681
    },
    {
        "content": "<p>size has to be a multiple of align, but 0 is a multiple of 1.</p>",
        "id": 273740989,
        "sender_full_name": "Lokathor",
        "timestamp": 1646185807
    },
    {
        "content": "<p>alignment also needs to be a power of two.</p>",
        "id": 273741066,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646185891
    },
    {
        "content": "<p>2^0 is 1. :D</p>",
        "id": 273741098,
        "sender_full_name": "Jubilee",
        "timestamp": 1646185918
    },
    {
        "content": "<p>Yep, exactly.</p>",
        "id": 273741145,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646185935
    },
    {
        "content": "<p>(And alignment of <code>0</code> also wouldn't make sense)</p>",
        "id": 273741171,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646185956
    },
    {
        "content": "<p>I recall <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> mentioning a trick like that for making an impossible reference: something with an align of 0 has to have a byte value which is a multiple of zero, and hence zero, but also must not be zero because it's a reference</p>",
        "id": 273747942,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646190490
    },
    {
        "content": "<p>Kind of like your <code>NonZeroU0</code> example</p>",
        "id": 273748012,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646190540
    },
    {
        "content": "<p><code>NonZeroU0</code> is just <code>!</code>, tbh. Just a scalar <code>!</code>.</p>",
        "id": 273753292,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646194840
    },
    {
        "content": "<p>I don't think a type with alignment <code>0</code> could possibly exist, mostly because alignment as a property is always a power of two.</p>",
        "id": 273753373,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646194912
    },
    {
        "content": "<p>Yes, that was my point, a type with alignment zero is a type that can't be pointed to because any valid pointer to it would have to be 0 and hence not valid</p>",
        "id": 273753695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646195110
    },
    {
        "content": "<p>Obviously 0 is not a power of 2 in the usual interpretation, but it can be interpreted as the limit of 2^n as n approaches infinity in the 2-adic valuation. Put another way, if you left shift 1 by too much you get 0, so 0 acts like an \"infinitely large\" alignment</p>",
        "id": 273753906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646195283
    },
    {
        "content": "<p>well, i hope Rust eventually gets something sorta like align = 1/8 aka. bitfields</p>",
        "id": 273754388,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646195676
    },
    {
        "content": "<p>honestly I am fine with just having scalar integers and bitpacking operations.</p>",
        "id": 273755085,
        "sender_full_name": "Jubilee",
        "timestamp": 1646196275
    },
    {
        "content": "<p>if we get generic integer sizes then we can have a function that takes a u32 and unpacks it into a u10, u10, u10, and u2, operates on them, etc.</p>",
        "id": 273755243,
        "sender_full_name": "Jubilee",
        "timestamp": 1646196461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/219381-t-libs/topic/c_void.20.22temporary.22.20hacks/near/273747942\">said</a>:</p>\n<blockquote>\n<p>I recall <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> mentioning a trick like that for making an impossible reference: something with an align of 0 has to have a byte value which is a multiple of zero, and hence zero, but also must not be zero because it's a reference</p>\n</blockquote>\n<p>FWIW I dont know what you mean^^ I argued <code>&amp;!</code> should be validity-uninhabited but that seems rather orthogonal to the c_void discussion</p>",
        "id": 273875607,
        "sender_full_name": "RalfJ",
        "timestamp": 1646254654
    },
    {
        "content": "<p>no worries, I'm probably just slowly going insane :) Happens to the best of us</p>",
        "id": 273876182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646254824
    }
]