[
    {
        "content": "<p>Hello! A while ago I noticed that, while there was a <code>split_inclusive</code> method (<a href=\"https://doc.rust-lang.org/std/primitive.str.html#method.split_inclusive\">https://doc.rust-lang.org/std/primitive.str.html#method.split_inclusive</a>) to include the separator at the end of the split slices, there was no equivalent that included the separator at the beginning. After asking on Internals (<a href=\"https://internals.rust-lang.org/t/potential-rsplit-inclusive/15721\">https://internals.rust-lang.org/t/potential-rsplit-inclusive/15721</a>) I began a \"quick\" PR to add the missing method. But it turns out there are a lot more potential variants of <code>split</code> than I thought:</p>\n<ul>\n<li>Forward or reverse (2)</li>\n<li>Unlimited or limited to n segments (2)</li>\n<li>Separators not included, included on right, or included on left (3)<br>\n2 *  2 * 3 = 12 different variants. And for slices, there are also the <code>mut </code>variants, so 24 possible variants of <code>split</code> for slices.</li>\n</ul>\n<p>My \"quick\" PR is at <a href=\"https://github.com/rust-lang/rust/pull/91546\">https://github.com/rust-lang/rust/pull/91546</a>, but in its present form it includes all of these variants. But 24 methods is a lot for slight variations on the same operation. On the other hand inconsistency in what variants are available is also annoying. So there needs to be a discussion on the best way to proceed here.</p>",
        "id": 267665061,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1641945788
    },
    {
        "content": "<p>Maybe we can have some sort of a generic API?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">split_generic</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">P</span>: <span class=\"nc\">Pattern</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">limit</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sepincl</span>: <span class=\"nc\">SearatorInclusion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pat</span>: <span class=\"nc\">P</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">SplitGeneric</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">rsplit_generic</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">P</span>: <span class=\"nc\">Pattern</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">limit</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sepincl</span>: <span class=\"nc\">SearatorInclusion</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pat</span>: <span class=\"nc\">P</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">RSplitGeneric</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">P</span>::<span class=\"n\">Searcher</span>: <span class=\"nc\">ReverseSearcher</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">enum</span> <span class=\"nc\">SearatorInclusion</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Excluded</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">IncludedRight</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">IncludedLeft</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Mayve the <code>r-</code> version is not even needed, since you can always do <code>split_generic(...).rev()</code></p>",
        "id": 267679616,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1641959339
    },
    {
        "content": "<p>Note: the reverse versions are equivalent to <code>.rev()</code> for the slice split iterators, but for the string split iterators they differ in that <code>.rev()</code> is only available for <code>DoubleEndedSearcher</code> while reversed variants also work with <code>ReverseSearcher</code>.</p>",
        "id": 267680871,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1641960844
    },
    {
        "content": "<p>i think the most important bit here is not consistency, but use cases and how common/useful they are.</p>\n<p>(i am generally very opposed to adding methods to std just because there is a matrix of possibilities. there has to be more to it than that. especially when we're talking about 24 new methods.)</p>",
        "id": 267740567,
        "sender_full_name": "BurntSushi",
        "timestamp": 1642001601
    },
    {
        "content": "<p>StrLikeBidiSplitBuilder</p>",
        "id": 267756955,
        "sender_full_name": "The 8472",
        "timestamp": 1642008147
    },
    {
        "content": "<p>The <code>n</code> variants could easily be exposed using an associated method on the base iterator (something like <code>my_slice.split(sep).max_segments(3);</code>) that would cut the number of needed methods defined directly on the slice type in 2</p>",
        "id": 267820818,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1642046011
    },
    {
        "content": "<p>Deprecate rsplit and allow const params in functions to have default values, then we could have</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">Side</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Start</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">End</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">SplitType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Exclude</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Include</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Terminate</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">one_split_to_rule_them_all</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FROM</span>: <span class=\"nc\">Side</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Side</span>::<span class=\"n\">Start</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">TYPE</span>: <span class=\"nc\">SplitType</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">SplitType</span>::<span class=\"n\">Exclude</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">limit</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">pattern</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(But a builder is fine too)</p>",
        "id": 267883109,
        "sender_full_name": "Bot+",
        "timestamp": 1642087086
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421518\">Jules Bertholet</span> <a href=\"#narrow/stream/219381-t-libs/topic/Plugging.20holes.20in.20the.20string.2Fslice.20split.20apis/near/267820818\">said</a>:</p>\n<blockquote>\n<p>The <code>n</code> variants could easily be exposed using an associated method on the base iterator (something like <code>my_slice.split(sep).max_segments(3);</code>) that would cut the number of needed methods defined directly on the slice type in 2</p>\n</blockquote>\n<p>This could actually be extended to a lot of additional iterator types, like <code>split_whitespace</code> and <code>chunks</code>.</p>",
        "id": 268163191,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1642305671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222471\">BurntSushi</span> <a href=\"#narrow/stream/219381-t-libs/topic/Plugging.20holes.20in.20the.20string.2Fslice.20split.20apis/near/267740567\">said</a>:</p>\n<blockquote>\n<p>i think the most important bit here is not consistency, but use cases and how common/useful they are.</p>\n</blockquote>\n<p>For context, I started this PR because I found myself wishing for the forward unlimited included-on-left variant. Said variant is useful when you have a sequence of items prefixed by some pattern, and you also have a function that operates on an individual item, and you want to iterate over and process all the items.</p>",
        "id": 268164104,
        "sender_full_name": "Jules Bertholet",
        "timestamp": 1642307240
    }
]