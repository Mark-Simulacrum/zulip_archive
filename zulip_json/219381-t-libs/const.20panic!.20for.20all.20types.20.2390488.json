[
    {
        "content": "<p>I am assigned <a href=\"https://github.com/rust-lang/rust/issues/90488\">#90488</a> but am unsure whether to merge and am looking for more opinions. The TLDR is that that PR will allow you to format any type that works at runtime in const contexts, but if there is no <code>const Display</code> impl (but a regular <code>Display</code>) it will just fall back to <code>&lt;could not format X&gt;</code> in the message. If we stabilize this, we will never be able to restrict panic formatting to just <code>const Display</code> or <code>const Debug</code> types, but will keep the silent fallback. On the other hand, this is just during panicking, so not sure how problematic/relevant my concern is at all.</p>",
        "id": 262490339,
        "sender_full_name": "oli",
        "timestamp": 1637689831
    },
    {
        "content": "<p>I'd definitely lean towards preferring being able to enforce that types can be displayed</p>",
        "id": 262492411,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637690761
    },
    {
        "content": "<p>Wouldn't it be possible to use a wrapper to provide the \"could not format\" fallback display for types that don't impl const display?</p>",
        "id": 262492550,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637690827
    },
    {
        "content": "<p>I think we should, at least for now, only allow compile-time panic formatting for types that we are pretty sure will be <code>const Display</code> eventually</p>",
        "id": 262493509,
        "sender_full_name": "RalfJ",
        "timestamp": 1637691320
    },
    {
        "content": "<p>Otherwise we end up with a permanent inconsistency between format strings in panic and format strings elsewhere, and that does not seem great</p>",
        "id": 262493616,
        "sender_full_name": "RalfJ",
        "timestamp": 1637691367
    },
    {
        "content": "<p>I think we should be very careful here because I think there is a significant risk of users unknowingly failing to include important information in hard to reproduce panics which would bite people continuously and might be impossible to undo</p>",
        "id": 262493745,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637691439
    },
    {
        "content": "<p>Tho I need to look more into the issues around constification of Result unwrap, which we need to be balanced against the cost of lossy panic messages</p>",
        "id": 262493888,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637691514
    },
    {
        "content": "<p>Is that the only issue really pushing us towards having the silent fallback?</p>",
        "id": 262493917,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637691530
    },
    {
        "content": "<p>for panic messages, I'd say that we use the looser bound of <code>const Debug</code>, since you can derive a Debug but you can't derive a Display.</p>",
        "id": 262497801,
        "sender_full_name": "Lokathor",
        "timestamp": 1637693565
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262497801\">said</a>:</p>\n<blockquote>\n<p>for panic messages, I'd say that we use the looser bound of <code>const Debug</code>, since you can derive a Debug but you can't derive a Display.</p>\n</blockquote>\n<p>we should use whatever the format string uses -- <code>{}</code> needs <code>const Display</code>, <code>:?</code> needs <code>const Debug</code></p>",
        "id": 262498165,
        "sender_full_name": "RalfJ",
        "timestamp": 1637693739
    },
    {
        "content": "<p>Ah, I'd forgot we aren't panicing raw values any more.</p>",
        "id": 262498924,
        "sender_full_name": "Lokathor",
        "timestamp": 1637694045
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262493888\">said</a>:</p>\n<blockquote>\n<p>Tho I need to look more into the issues around constification of Result unwrap, which we need to be balanced against the cost of lossy panic messages</p>\n</blockquote>\n<p>It's mostly a question of how fast we want to get there. We don't expect <code>impl const Display</code> to be a thing in the near future or even next year. So unwrap would come after that.</p>",
        "id": 262506338,
        "sender_full_name": "oli",
        "timestamp": 1637697868
    },
    {
        "content": "<p>It doesn't affect runtime, so the panic messages would just be bad at compile time</p>",
        "id": 262506380,
        "sender_full_name": "oli",
        "timestamp": 1637697889
    },
    {
        "content": "<p>But we'll have to support that fallback machinery forever</p>",
        "id": 262506409,
        "sender_full_name": "oli",
        "timestamp": 1637697904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262493745\">said</a>:</p>\n<blockquote>\n<p>I think we should be very careful here because I think there is a significant risk of users unknowingly failing to include important information in hard to reproduce panics which would bite people continuously and might be impossible to undo</p>\n</blockquote>\n<p>That's the reason why I think it's important to allow everything to be used in const panic.</p>",
        "id": 262527635,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637709217
    },
    {
        "content": "<p>Because otherwise people will delete info that can't be formatted in const panic.</p>",
        "id": 262527660,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637709235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262506380\">said</a>:</p>\n<blockquote>\n<p>It doesn't affect runtime, so the panic messages would just be bad at compile time</p>\n</blockquote>\n<p>ooh that's an interesting point. I could see that being much less of an issue</p>",
        "id": 262527768,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637709293
    },
    {
        "content": "<p>Note though that it's \"transitive\" compile-time -- e.g., panicking with a debug of <code>Vec&lt;T&gt;</code> in crate A gives you no warning until some downstream crate B actually invokes that code, potentially</p>",
        "id": 262527910,
        "sender_full_name": "simulacrum",
        "timestamp": 1637709375
    },
    {
        "content": "<p>so I'm not sure it's a huge difference, in some sense</p>",
        "id": 262527919,
        "sender_full_name": "simulacrum",
        "timestamp": 1637709384
    },
    {
        "content": "<p>yea, the main issue I am worried about is the potential for very long turn around on noticing an error message with insufficient information, fixing that error message, and reproducing the error</p>",
        "id": 262528001,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637709453
    },
    {
        "content": "<p>At minimum it seems worthwhile to have a lint (at some level, I'd suggest warn) that indicates when you've not provided the appropriate bound -- though that gets complicated where the bound isn't stable yet</p>",
        "id": 262528004,
        "sender_full_name": "simulacrum",
        "timestamp": 1637709457
    },
    {
        "content": "<p>if its runtime you run the risk of that error being in a very hard to reach code path, but with compile time I imagine that once you've encountered an error with insufficient info reproducing that error will be trivial</p>",
        "id": 262528078,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637709490
    },
    {
        "content": "<p>and you can always still use patch deps to fix the missing info if it comes from a dependency</p>",
        "id": 262528099,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637709507
    },
    {
        "content": "<p>My plan is just to dump all fields (like a dervied Debug) if it couldn't be formatted.</p>",
        "id": 262528150,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637709559
    },
    {
        "content": "<p>With a note saying that this probably isn't what you'll see in runtime.</p>",
        "id": 262528167,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637709583
    },
    {
        "content": "<p>that sounds okay I think</p>",
        "id": 262528234,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1637709613
    },
    {
        "content": "<p>And the cost is what <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> said, this needs a fallback machinary that needs to be kept even if we have <code>const Debug</code> in the future.</p>",
        "id": 262528249,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637709628
    },
    {
        "content": "<p>(I am very pessimistic about when <code>const Debug</code> would be usable)</p>",
        "id": 262528447,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637709764
    },
    {
        "content": "<p>And I certainly think people need const unwrap now while <code>const Debug</code> can wait.</p>",
        "id": 262528483,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637709796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262528249\">said</a>:</p>\n<blockquote>\n<p>And the cost is what <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> said, this needs a fallback machinary that needs to be kept even if we have <code>const Debug</code> in the future.</p>\n</blockquote>\n<p>the other cost is that if we ever have <code>format_args</code> at const-time there will be an (unfixable) inconsistency between what you can format for a panic and what you can format for other purposes. this is the main reason why I am in favor of requiring a proper bound.</p>",
        "id": 262537555,
        "sender_full_name": "RalfJ",
        "timestamp": 1637718000
    },
    {
        "content": "<p>I also think there is no rush -- we can stabilize the uncontroversial part of the formatting machinery and wait how much of a problem the missing support for <code>const Debug</code> on user types and generic types is. I don't understand why you want to rush this through all at once when we have an uncontroversially useful core part of this feature and we can just wait and see if a magic fallback impl is really needed.</p>",
        "id": 262537694,
        "sender_full_name": "RalfJ",
        "timestamp": 1637718125
    },
    {
        "content": "<p><code>Result::unwrap</code> lives in std so presumably it could use a <code>const Debug</code> bound long before anyone else can (so at last user code calling <code>Result::unwrap</code> on a concrete supported type can get proper formatting -- though I guess it is unlikely that the error type actually falls in the set of supported types)</p>",
        "id": 262537748,
        "sender_full_name": "RalfJ",
        "timestamp": 1637718231
    },
    {
        "content": "<p>The issue is that I don't see how <code>const Debug</code> would work today.</p>",
        "id": 262538145,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637718675
    },
    {
        "content": "<p>So constraining it would require probably a marker trait</p>",
        "id": 262538214,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637718727
    },
    {
        "content": "<p>And then there is the problem of  the<code>dyn Debug</code> used in <code>assert_eq!</code>.</p>",
        "id": 262538234,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637718787
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262537748\">said</a>:</p>\n<blockquote>\n<p>though I guess it is unlikely that the error type actually falls in the set of supported types)</p>\n</blockquote>\n<p>And this is why I think we should accept all types, because otherwise it is just not as useful.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262527660\">said</a>:</p>\n<blockquote>\n<p>Because otherwise people will delete info that can't be formatted in const panic.</p>\n</blockquote>\n<p>^</p>",
        "id": 262538382,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637718973
    },
    {
        "content": "<p>one alternative would also be to do this just for Debug and not for the other formatting traits</p>",
        "id": 262556226,
        "sender_full_name": "oli",
        "timestamp": 1637741215
    },
    {
        "content": "<p>Anyway. In the spirit of getting uncontroversial things out the door quickly, I propose to split the feature into two gates. One for \"obviously fine\" types like builtin types (which will get const impls some day) and one for the \"print everything with fallback\" schemes.</p>",
        "id": 262562711,
        "sender_full_name": "oli",
        "timestamp": 1637745340
    },
    {
        "content": "<p>Wrt the dyn trait thing, we could start experimenting with <code>dyn ~const Trait</code> and make the two feature checks  happen during unsizing, too</p>",
        "id": 262563001,
        "sender_full_name": "oli",
        "timestamp": 1637745492
    },
    {
        "content": "<p>Note that if we had const fn pointers it is possible to emulate const trait objects</p>",
        "id": 262582878,
        "sender_full_name": "fee1-dead",
        "timestamp": 1637757917
    },
    {
        "content": "<p>Maybe we should add a bunch of unstable features like const trait objects and const rn pointers so we can try out the alternatives before committing to new schemes</p>",
        "id": 262586218,
        "sender_full_name": "oli",
        "timestamp": 1637759565
    },
    {
        "content": "<blockquote>\n<p>Because otherwise people will delete info that can't be formatted in const panic.</p>\n</blockquote>\n<p>const panics are already stabilized, so even the version of your PR restricted to types that we know can be const-formatted can only make things strictly better.<br>\nIf, once we ship this, it turns out deleting info is a real problem, then we can go back to the extended version of your PR -- but this change is way too risky (can never be taken back!) to do it based on just an untested hypothesis of what people might do if we dont do this.</p>",
        "id": 262596281,
        "sender_full_name": "RalfJ",
        "timestamp": 1637764461
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262538214\">said</a>:</p>\n<blockquote>\n<p>So constraining it would require probably a marker trait</p>\n</blockquote>\n<p>I think the constrained version would simply have a list of allowed types, no need for a trait</p>",
        "id": 262596415,
        "sender_full_name": "RalfJ",
        "timestamp": 1637764551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262538234\">said</a>:</p>\n<blockquote>\n<p>And then there is the problem of  the<code>dyn Debug</code> used in <code>assert_eq!</code>.</p>\n</blockquote>\n<p>could you elaborate on what that problem is?</p>",
        "id": 262596479,
        "sender_full_name": "RalfJ",
        "timestamp": 1637764581
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262596415\">said</a>:</p>\n<blockquote>\n<p>I think the constrained version would simply have a list of allowed types, no need for a trait</p>\n</blockquote>\n<p>How would you check the types? The current PR touches no typecheck at all. The check needs to be done early before monomorphizing. This also means that you can't panic with a type param anymore, something needed for <code>Result::unwrap</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262596479\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262538234\">said</a>:</p>\n<blockquote>\n<p>And then there is the problem of  the<code>dyn Debug</code> used in <code>assert_eq!</code>.</p>\n</blockquote>\n<p>could you elaborate on what that problem is?</p>\n</blockquote>\n<p><code>assert_eq!</code> delegates failing path to <code>assert_failed_inner</code> that formats with <code>&amp;dyn Debug</code> to avoid code bloat.</p>",
        "id": 262611190,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637771538
    },
    {
        "content": "<p>There are multiple reasons that I used the current approach</p>\n<ul>\n<li>It allows <code>Result::unwrap</code> (more or less guiding principle for me)</li>\n<li>It is the least intrusive approach (it basically just plugs into const eval, no need to modify many different parts of compiler or libs).</li>\n<li>If there is going to be a check for formattable types, it needs to happen in typecheck (or somewhere else before mono)<ul>\n<li><code>const Debug</code> is not doable today without magic, and even if it's doable with magic like <code>rustc_do_not_const_check</code> it's not desirable because that'll allow user code to call <code>Debug::fmt</code> in const context, which we don't want now and we don't know if we want it in the future.</li>\n<li>An additional helper trait (say, <code>ConstDebug</code>) could potentially solve the issue, but that'll require <code>Result::unwrap</code>or <code>assert_eq!</code> to take a <code>~const ConstDebug</code> bound; I am not sure if that could be done in a back-compat way. Plus the helper trait has to be perma-unstable and so code outside std couldn't carry the same bound.</li>\n</ul>\n</li>\n</ul>",
        "id": 262613421,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637772501
    },
    {
        "content": "<blockquote>\n<p>How would you check the types? The current PR touches no typecheck at all.</p>\n</blockquote>\n<p>sounds like a job for const-checking</p>",
        "id": 262813936,
        "sender_full_name": "RalfJ",
        "timestamp": 1637943405
    },
    {
        "content": "<blockquote>\n<p>This also means that you can't panic with a type param anymore, something needed for Result::unwrap.</p>\n</blockquote>\n<p>I specifically mentioned a possible work-around for that (not something for the MVP though): use <code>T: ~const Debug</code> in that function; it is defined in libcore so it can do Magic</p>",
        "id": 262813988,
        "sender_full_name": "RalfJ",
        "timestamp": 1637943455
    },
    {
        "content": "<p>I understand why you picked this approach, but I also think it is the wrong approach for the reasons stated before -- it is an ad-hoc extension of the language that we can never take back. formatting things requires the appropriate trait to be implemented; I dont think we should depart from this important fundamental principle for some short-term gains.</p>",
        "id": 262814164,
        "sender_full_name": "RalfJ",
        "timestamp": 1637943572
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262813936\">said</a>:</p>\n<blockquote>\n<p>sounds like a job for const-checking</p>\n</blockquote>\n<p>I am not really convinced that this is the correct way though; this makes formatting part of the language.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262813988\">said</a>:</p>\n<blockquote>\n<p>I specifically mentioned a possible work-around for that (not something for the MVP though): use <code>T: ~const Debug</code> in that function; it is defined in libcore so it can do Magic</p>\n</blockquote>\n<p>And I specifically mentioned why it wouldn't work. Would <code>&lt;T as Debug&gt;::fmt</code> be considered const if <code>T: const Debug</code>? Have<code>T: const Debug</code> to only mean that it can be used for const panic is simply confusing.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262814164\">said</a>:</p>\n<blockquote>\n<p>it is an ad-hoc extension of the language that we can never take back. formatting things requires the appropriate trait to be implemented; I dont think we should depart from this important fundamental principle for some short-term gains.</p>\n</blockquote>\n<p>This is not an extension to the language, if we say \"you can const panic with anything and diagnostics is not guaranteed to be precise\". From a language perspective then an alternative implementation could just panic without trying to format messages. The compiler is only doing its best-effort to produce better diagnostics. No fundamental concepts are being broken, and formatting things still require appropriate traits. The only difference is that libcore needs a special way to construct format args for panic (which it already has for the limited const panic we support today). If const panic becomes a thing in the future, then the compiler is just doing its best-effort diagnostics in a different way.</p>",
        "id": 262825140,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637951410
    },
    {
        "content": "<p>IMO the only reason for not allowing const panic with anything is that the current separate <code>const_format_args</code> code in library and const panicking code will stay forever. But it's not an ad-hoc extension to the language. Also, I still see it being useful to be able to panic with types that can't be const formatted, e.g. pointers, which could never be formatted accurately during compile time.</p>\n<p>My question is perhaps, do we want perfection to be the enemy of good?</p>",
        "id": 262825564,
        "sender_full_name": "Gary Guo",
        "timestamp": 1637951883
    },
    {
        "content": "<blockquote>\n<p>this makes formatting part of the language.</p>\n</blockquote>\n<p>Your patch makes formatting part of the language, by hard-coding it in the interpreter. So this is really not valid criticism IMO.<br>\nIn fact, making it part of the dynamics of the language (the interpreter) <em>without</em> also making it part of the static checks of the language (const-checking) is an awkward mismatch.</p>",
        "id": 262897237,
        "sender_full_name": "RalfJ",
        "timestamp": 1638053689
    },
    {
        "content": "<blockquote>\n<p>And I specifically mentioned why it wouldn't work. Would &lt;T as Debug&gt;::fmt be considered const if T: const Debug? HaveT: const Debug to only mean that it can be used for const panic is simply confusing.</p>\n</blockquote>\n<p>I don't understand. Assuming a working implementation of const traint bounds, yes, <code>&lt;T as Debug&gt;::fmt </code> is const if <code>T: const Debug</code>. nothing panic-specific there. but Result::unwrap is going to be the only method with that bound, we sure shouldnt expose it for any non-panic-related things.</p>",
        "id": 262897309,
        "sender_full_name": "RalfJ",
        "timestamp": 1638053809
    },
    {
        "content": "<blockquote>\n<p>This is not an extension to the language, if we say \"you can const panic with anything and diagnostics is not guaranteed to be precise\". </p>\n</blockquote>\n<p>The fact that you have to change the interpreter shows very clearly that this <em>is</em> a part of the language. That's what it <em>means</em> to be part of the langauge -- that the interpreter needs special support for it.</p>",
        "id": 262897324,
        "sender_full_name": "RalfJ",
        "timestamp": 1638053860
    },
    {
        "content": "<blockquote>\n<p>From a language perspective then an alternative implementation could just panic without trying to format messages.</p>\n</blockquote>\n<p>The concrete thing that you are making part of the language that I am objecting to is that using Display or Debug-formatting for a panic message in const code is allowed <em>even when the type in question does not const-implement the relevant trait</em>.<br>\nHow exactly the output of that panic looks like is not relevant for my concern. The fact that that code compiles and runs at all is my concern.</p>",
        "id": 262897387,
        "sender_full_name": "RalfJ",
        "timestamp": 1638053972
    },
    {
        "content": "<p>We don</p>",
        "id": 262897494,
        "sender_full_name": "RalfJ",
        "timestamp": 1638054025
    },
    {
        "content": "<blockquote>\n<p>My question is perhaps, do we want perfection to be the enemy of good?</p>\n</blockquote>\n<p>No, we want a coherent language that makes sense and that can be maintained going forward. We don't want ad-hoc language extensions that are insufficiently motivated.</p>\n<p>Note that despite all I said above, <em>if there is clear evidence</em> that formatting things for const-time panics without the appropriate bounds would help a lot in practice, I would consider it a worthwhile tradeoff. But I think it is worth <em>trying</em> to do the principled, minimal, future-compatible thing first.<br>\nThis is the standard approach that Rust has followed many times, and it has served us well. If we can ship something that is clearly useful and future-compatible with more ambitious, but also more questionable / complicated / contentious proposals, then we ship the minimum thing and see how it fares in practice, and that serves as evidence for what is the best next step to take.</p>\n<p>In fact I could turn your question around and ask if you want to make perfection (being able to format <em>all the things</em> in const-panics) be the enemy of the good (being able to format some things). Let's go for the good now and see if we want/need to reach perfection later. ;)</p>",
        "id": 262897678,
        "sender_full_name": "RalfJ",
        "timestamp": 1638054359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262897237\">said</a>:</p>\n<blockquote>\n<p>Your patch makes formatting part of the language, by hard-coding it in the interpreter. So this is really not valid criticism IMO.<br>\nIn fact, making it part of the dynamics of the language (the interpreter) <em>without</em> also making it part of the static checks of the language (const-checking) is an awkward mismatch.</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262897324\">said</a>:</p>\n<blockquote>\n<p>The fact that you have to change the interpreter shows very clearly that this <em>is</em> a part of the language. That's what it <em>means</em> to be part of the langauge -- that the interpreter needs special support for it.</p>\n</blockquote>\n<p>The compiler has all sorts of tricks to produce better diagnostics, and that doesn't make these part of the language.</p>",
        "id": 262911445,
        "sender_full_name": "Gary Guo",
        "timestamp": 1638078256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262897387\">said</a>:</p>\n<blockquote>\n<p>The concrete thing that you are making part of the language that I am objecting to is that using Display or Debug-formatting for a panic message in const code is allowed <em>even when the type in question does not const-implement the relevant trait</em>.<br>\nHow exactly the output of that panic looks like is not relevant for my concern. The fact that that code compiles and runs at all is my concern.</p>\n</blockquote>\n<p>I don't understand why it's a concern. I don't need to have a <code>const Debug</code> to produce a <code>Debug::fmt</code> function pointer in compile time. If how exactly the panic message looks is not relevant, why would a <code>cosnt Debug</code> bound be needed?</p>",
        "id": 262911553,
        "sender_full_name": "Gary Guo",
        "timestamp": 1638078480
    },
    {
        "content": "<p>There are zero language extensions here, and there's nothing non-coherent. I consider all the work I done in the interpreter be purely for diagnositcs, and only the library changes to be substantial.</p>",
        "id": 262911671,
        "sender_full_name": "Gary Guo",
        "timestamp": 1638078647
    },
    {
        "content": "<p>The whole interpreter changes can be removed and replace with some code that produces \"const eval panicked\". How is it a change to the language?</p>",
        "id": 262911732,
        "sender_full_name": "Gary Guo",
        "timestamp": 1638078767
    },
    {
        "content": "<blockquote>\n<p>I don't need to have a const Debug to produce a Debug::fmt function pointer in compile time</p>\n</blockquote>\n<p>Yes, but you cannot call such a fn ptr either.<br>\nYou need a <code>const Debug</code> to produce a <code>const fn</code> ptr at compile time (which have not been implemented yet).<br>\nSo this is a total red herring, has nothing to do with calling functions without the appropriate bounds.</p>",
        "id": 262941365,
        "sender_full_name": "RalfJ",
        "timestamp": 1638123774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/const.20panic!.20for.20all.20types.20.2390488/near/262911732\">said</a>:</p>\n<blockquote>\n<p>The whole interpreter changes can be removed and replace with some code that produces \"const eval panicked\". How is it a change to the language?</p>\n</blockquote>\n<p>the fact that code like this compiles is a change to the language</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Debug</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>this code calls a non-const function (<code>&lt;T as Debug&gt;::fmt</code>) at const-time.<br>\nI know there are hacks in the CTFE interpreter which mean that that non-const function is never actually called, but that does not solve the conceptual issue. We dont accept code like this either:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">panic!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I view these two situations as fairly equivalent.</p>",
        "id": 262941457,
        "sender_full_name": "RalfJ",
        "timestamp": 1638123901
    },
    {
        "content": "<p>At this point it seems clear that neither of us is going to convince the other that this change is a good idea / is a hacky language extension. there haven't really been new arguments in a while. but there is one point I keep making that you have not responded to (or maybe I missed that, in which case I apologize): if we had concrete evidence that the benefits of this change outweigh the problems some people see with it, that would make a huge difference for me. we could gather that evidence by stabilizing a restricted version and seeing how it fares in practice. yes, implementing the checks that enforce those restrictions will take work, but this is not the first time that \"the checks implementing the restrictions\" are the most tricky bit of a feature to get right (min_const_fn is another example of that -- we got a whole second const-checker for that!).</p>",
        "id": 262941717,
        "sender_full_name": "RalfJ",
        "timestamp": 1638124250
    },
    {
        "content": "<p>I'll try to gather some use cases when I have time.</p>",
        "id": 263249360,
        "sender_full_name": "Gary Guo",
        "timestamp": 1638339810
    }
]