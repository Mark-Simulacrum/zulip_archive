[
    {
        "content": "<p>Should we have <code>join</code> on iterator so that we could do the following and maybe have a bit of optimization without creating a <code>Vec</code> just to join an <code>Iterator</code>. Instead of <code>[\"hello\", \"world\"].iter().collect::&lt;Vec&lt;_&gt;&gt;().join(\" \")</code> one could do <code>[\"hello\", \"world\"].iter().join(\" \")</code>?</p>\n<p>A rough idea on how it should look like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">join</span><span class=\"o\">&lt;</span><span class=\"n\">Separator</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sep</span>: <span class=\"nc\">Separator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Join</span><span class=\"o\">&lt;</span><span class=\"n\">Separator</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">[</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">]</span>: <span class=\"nc\">Join</span><span class=\"o\">&lt;</span><span class=\"n\">Separator</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>I was surprised at first that I am not able to join into <code>String</code> from <code>Iterator</code>, I thought since <code>Iterator</code> may have a similar API to <code>slice</code> it would have <code>join</code>, I need to search to be able to know that I first need to get a <code>Vec&lt;String&gt;</code> to only be able to join, I wonder if it would be faster to join without first creating a <code>Vec</code>?</p>",
        "id": 203643505,
        "sender_full_name": "pickfire",
        "timestamp": 1594559845
    },
    {
        "content": "<p>This has been something I've wished for as well, but I think it'd be better to separate it from the existing slice::Join trait so it doesn't have to buffer up the components first at all</p>",
        "id": 203652802,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1594575103
    },
    {
        "content": "<p>FWIW, itertools does have this already: <a href=\"https://docs.rs/itertools/0.9.0/itertools/trait.Itertools.html#method.join\">https://docs.rs/itertools/0.9.0/itertools/trait.Itertools.html#method.join</a></p>",
        "id": 203655321,
        "sender_full_name": "cuviper",
        "timestamp": 1594578985
    },
    {
        "content": "<p><code>format</code> and <code>format_with</code> are neat too</p>",
        "id": 203655330,
        "sender_full_name": "cuviper",
        "timestamp": 1594579021
    },
    {
        "content": "<p>Does it requires a FCP to move it to core? This does seemed like something quite common, not sure if it is good to keep it on itertools. Also, I wouldn't suggest the one on itertools, I don't think we should only be looking on <code>String</code>, <code>PathBuf</code> could be the output as well.</p>",
        "id": 203744922,
        "sender_full_name": "pickfire",
        "timestamp": 1594661676
    },
    {
        "content": "<p>As for me, <code>format</code> and <code>format_with</code> does not seemed to be as useful. I don't quite sure why I would need that, I think <code>dbg!()</code> could do that better.</p>",
        "id": 203745381,
        "sender_full_name": "pickfire",
        "timestamp": 1594661905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"225422\">@pickfire</span> I'm not on the libs team but generally single method additions only require a PR.</p>",
        "id": 203752629,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1594665243
    },
    {
        "content": "<p>Note that they're defined in different crates, <code>core::iter::Iterator</code> vs. <code>alloc::slice::Join</code></p>",
        "id": 203757438,
        "sender_full_name": "cuviper",
        "timestamp": 1594667444
    },
    {
        "content": "<p>I think coherence would prevent moving <code>Join</code> to <code>core</code>, since the impls need to be in <code>alloc</code> to refer to <code>Vec</code> and <code>String</code></p>",
        "id": 203757533,
        "sender_full_name": "cuviper",
        "timestamp": 1594667498
    },
    {
        "content": "<p>I found a related issue: <a href=\"https://github.com/rust-lang/rust/issues/22754\">https://github.com/rust-lang/rust/issues/22754</a><br>\n(<code>connect</code> was later deprecated / renamed to <code>join</code>)</p>",
        "id": 203768274,
        "sender_full_name": "cuviper",
        "timestamp": 1594672892
    },
    {
        "content": "<p>Maybe let me try adding it to itertools first and then send a PR to libs if that works, sounds like it needs an RFC from the comment.</p>",
        "id": 203816200,
        "sender_full_name": "pickfire",
        "timestamp": 1594720875
    },
    {
        "content": "<p>I did some tests on this, it generates the same output as assembly except it requires writing fewer types.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#![feature(slice_concat_trait)]</span><span class=\"w\"></span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">FromIterator</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span>::<span class=\"n\">Join</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">collect</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">iter</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span>: <span class=\"nc\">FromIterator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">collect</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">join</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Separator</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">iter</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sep</span>: <span class=\"nc\">Separator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Join</span><span class=\"o\">&lt;</span><span class=\"n\">Separator</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span>: <span class=\"nc\">Join</span><span class=\"o\">&lt;</span><span class=\"n\">Separator</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// &lt;[S] as std::slice::Join&lt;&amp;str&gt;&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">// &lt;[V] as std::slice::Join&lt;&amp;T&gt;&gt;</span>\n<span class=\"w\">    </span><span class=\"c1\">// &lt;[V] as std::slice::Join&lt;&amp;[T]&gt;&gt;</span>\n<span class=\"w\">    </span><span class=\"n\">Join</span>::<span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">().</span><span class=\"n\">as_slice</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[inline(never)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">test_collect</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">iter</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">String</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">collect</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_slice</span><span class=\"p\">().</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"s\">&quot; &quot;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[inline(never)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">test_join</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">iter</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">String</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">iter</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot; &quot;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[inline(never)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">test_manual</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">iter</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">String</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">sep</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">&quot; &quot;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">for_each</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">s</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">push_str</span><span class=\"p\">(</span><span class=\"n\">sep</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">push_str</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">buf</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">test_join</span><span class=\"p\">([</span><span class=\"s\">&quot;a&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;b&quot;</span><span class=\"p\">].</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">copied</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"s\">&quot;a b&quot;</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">test_collect</span><span class=\"p\">([</span><span class=\"s\">&quot;a&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;b&quot;</span><span class=\"p\">].</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">copied</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"s\">&quot;a b&quot;</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">test_manual</span><span class=\"p\">([</span><span class=\"s\">&quot;a&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;b&quot;</span><span class=\"p\">].</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">copied</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"s\">&quot;a b&quot;</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>In which case, rather than writing</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">collect</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">().</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"s\">&quot; &quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>One can just write the following with the same generated assembly</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"s\">&quot; &quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>Current limitations are that <code>Join</code> API is currently too limited, it implements quite less stuff, I wish it could use <code>AsRef</code> so that we don't need to do conversion on the iterator level.</p>\n<p>I wonder if we could do optimization such as not needing to build a <code>Vec</code> first and directly construct the output but I haven't figure out a way that it could be faster yet, probably performance could improve. CC <span class=\"user-mention\" data-user-id=\"209117\">@lzutao</span> </p>\n<p>However, this is different from the one provided in <code>itertools</code>, <code>itertools</code> already have <code>join</code> but that is only limited to <code>String</code> concatenation, this version is just <code>Iterator</code> with <code>Join</code>. What do you all think?</p>",
        "id": 207067304,
        "sender_full_name": "pickfire",
        "timestamp": 1597577207
    },
    {
        "content": "<p>I am not familiar with these APIs. You probably want to ping people like <span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> .</p>",
        "id": 207068301,
        "sender_full_name": "lzutao",
        "timestamp": 1597578789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209117\">@lzutao</span> No, I was discussing the performance. I was wondering if we could directly construct the output from join without having a separate vec first to make it faster.</p>",
        "id": 207071674,
        "sender_full_name": "pickfire",
        "timestamp": 1597584482
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Do I need to do an RFC for this?</p>",
        "id": 207109598,
        "sender_full_name": "pickfire",
        "timestamp": 1597644382
    },
    {
        "content": "<p>You could look at Zip trait and its module to get more inspiration.<br>\nEspecially TrustedRandomAccess trait and its super trait ExactSizeIterator.</p>",
        "id": 207126094,
        "sender_full_name": "lzutao",
        "timestamp": 1597658958
    },
    {
        "content": "<p>I don't think an RFC is needed.</p>",
        "id": 207132333,
        "sender_full_name": "Amanieu",
        "timestamp": 1597664090
    },
    {
        "content": "<p>I don't understand how is ExactSizeIterator is useful here since we need to get the length of the elements in the vector plus N times the length of the separator? I wonder if we can get the total length mentioned while copying the data so we don't need to iterate two times.</p>",
        "id": 207165756,
        "sender_full_name": "pickfire",
        "timestamp": 1597682002
    },
    {
        "content": "<p>By the way, <code>Box&lt;[T]&gt;</code>'s <code>FromIterator</code> looks way less efficient than <code>Vec&lt;T&gt;</code> when I looked into the generated code, I think I need to look into improving that while working on this.</p>",
        "id": 207165871,
        "sender_full_name": "pickfire",
        "timestamp": 1597682054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> Does it need a tracking issue?</p>",
        "id": 207167530,
        "sender_full_name": "pickfire",
        "timestamp": 1597682910
    },
    {
        "content": "<p><code>Box&lt;[T]&gt;</code> just collects a <code>Vec&lt;T&gt;</code> and converts -- the only way that could be less efficient is in the implied shrink</p>",
        "id": 207167586,
        "sender_full_name": "cuviper",
        "timestamp": 1597682947
    },
    {
        "content": "<p>new unstable APIs always need a tracking issue, but I usually wait until I have a feeling whether it's going to be accepted at all</p>",
        "id": 207167645,
        "sender_full_name": "cuviper",
        "timestamp": 1597682986
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> I understand, but the assembly generated is 2x more (96 -&gt; 184). <a href=\"https://godbolt.org/z/c9ffTT\">https://godbolt.org/z/c9ffTT</a> I will be opening an issue for this.</p>",
        "id": 207167654,
        "sender_full_name": "pickfire",
        "timestamp": 1597682989
    },
    {
        "content": "<p>hmm, some panic handling for \"Tried to shrink to a larger capacity\"</p>",
        "id": 207167995,
        "sender_full_name": "cuviper",
        "timestamp": 1597683174
    },
    {
        "content": "<p>(which should be statically unreachable)</p>",
        "id": 207168062,
        "sender_full_name": "cuviper",
        "timestamp": 1597683218
    },
    {
        "content": "<p>Is that even possible?</p>",
        "id": 207168071,
        "sender_full_name": "pickfire",
        "timestamp": 1597683222
    },
    {
        "content": "<p>no, but I guess it isn't seeing that len&lt;=capacity</p>",
        "id": 207168135,
        "sender_full_name": "cuviper",
        "timestamp": 1597683244
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> <a href=\"https://github.com/rust-lang/rust/issues/75636\">https://github.com/rust-lang/rust/issues/75636</a></p>",
        "id": 207168255,
        "sender_full_name": "pickfire",
        "timestamp": 1597683319
    },
    {
        "content": "<p>maybe it should be guarded like <code>if self.len() &lt; self.capacity() { self.shrink_to_fit(); }</code> -- so the compiler may see that it's never greater</p>",
        "id": 207168397,
        "sender_full_name": "cuviper",
        "timestamp": 1597683392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"225422\">@pickfire</span> still, that should all be cold, not affecting real performance, except <em>maybe</em> icache pressure</p>",
        "id": 207168595,
        "sender_full_name": "cuviper",
        "timestamp": 1597683531
    },
    {
        "content": "<p>icache pressure?</p>",
        "id": 207168616,
        "sender_full_name": "pickfire",
        "timestamp": 1597683548
    },
    {
        "content": "<p>instruction cache memory</p>",
        "id": 207168638,
        "sender_full_name": "cuviper",
        "timestamp": 1597683561
    },
    {
        "content": "<p>pressure -&gt; unused instructions still taking up some space in that cache, leaving less room for useful stuff</p>",
        "id": 207168693,
        "sender_full_name": "cuviper",
        "timestamp": 1597683597
    },
    {
        "content": "<p>but that's very much something that should be measured before it is targeted for optimization</p>",
        "id": 207168840,
        "sender_full_name": "cuviper",
        "timestamp": 1597683652
    },
    {
        "content": "<p>This issue <a href=\"https://github.com/rust-lang/rust/issues/75638\">https://github.com/rust-lang/rust/issues/75638</a></p>",
        "id": 207169718,
        "sender_full_name": "pickfire",
        "timestamp": 1597684155
    },
    {
        "content": "<p>Wow, my first time opening a tracking issue. Please let me work on the implementation, I want to try.</p>",
        "id": 207169821,
        "sender_full_name": "pickfire",
        "timestamp": 1597684212
    },
    {
        "content": "<p>oh, usually I do the implementation before a tracking issue, otherwise this is more of a request issue</p>",
        "id": 207170018,
        "sender_full_name": "cuviper",
        "timestamp": 1597684333
    },
    {
        "content": "<p>Ah, I thought it is the opposite.</p>",
        "id": 207170088,
        "sender_full_name": "pickfire",
        "timestamp": 1597684388
    },
    {
        "content": "<p>By the way, the POC is done so I don't see any issues doing the implementation.</p>",
        "id": 207170113,
        "sender_full_name": "pickfire",
        "timestamp": 1597684400
    },
    {
        "content": "<p>It's like a TODO issue for me, I just left it there, IIRC last time I just create a pull request without a tracking issue.</p>",
        "id": 207170155,
        "sender_full_name": "pickfire",
        "timestamp": 1597684436
    },
    {
        "content": "<p>The big question I still have is how you intend to reconcile this across different crates -- <code>core::iter::Iterator</code> can't reference <code>alloc::slice::Join</code>. The POC doesn't answer this at all.</p>",
        "id": 207170272,
        "sender_full_name": "cuviper",
        "timestamp": 1597684500
    },
    {
        "content": "<p>Oh, I didn't thought about that.</p>",
        "id": 207172924,
        "sender_full_name": "pickfire",
        "timestamp": 1597685743
    },
    {
        "content": "<p>Can we even implement it in <code>std::iter::Iterator</code>?</p>",
        "id": 207173060,
        "sender_full_name": "pickfire",
        "timestamp": 1597685784
    },
    {
        "content": "<p><code>std</code> is just a re-export</p>",
        "id": 207173092,
        "sender_full_name": "cuviper",
        "timestamp": 1597685798
    },
    {
        "content": "<p>I mentioned this before: <a href=\"#narrow/stream/219381-t-libs/topic/join.20on.20Iterator/near/203757438\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/join.20on.20Iterator/near/203757438</a></p>",
        "id": 207173135,
        "sender_full_name": "cuviper",
        "timestamp": 1597685813
    },
    {
        "content": "<p>Ah, I forgot we cannot use <code>Vec</code> in <code>core</code>, <code>Vec</code> is needed to run <code>collect</code> before joining, do we need to do extension trait for this in alloc and reuse it in std?</p>",
        "id": 207500460,
        "sender_full_name": "pickfire",
        "timestamp": 1597912753
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error[E0412]: cannot find type `Vec` in this scope\n    --&gt; library/core/src/iter/traits/iterator.rs:1676:35\n     |\n1676 |         Join::join(self.collect::&lt;Vec&lt;Self::Item&gt;&gt;().as_slice(), sep)\n     |                                   ^^^ not found in this scope\n\nerror[E0038]: the trait `iter::traits::iterator::Iterator` cannot be made into an object\n    --&gt; library/core/src/iter/traits/iterator.rs:17:30\n     |\n17   | fn _assert_is_object_safe(_: &amp;dyn Iterator&lt;Item = ()&gt;) {}\n     |                              ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `iter::traits::iterator::Iterator` cannot be made into an object\n...\n98   | pub trait Iterator {\n     |           -------- this trait cannot be made into an object...\n...\n1672 |     fn join&lt;Separator&gt;(self, sep: Separator) -&gt; &lt;[Self::Item] as Join&lt;Separator&gt;&gt;::Output\n     |        ---- ...because method `join` has generic type parameters\n     |\n     = help: consider moving `join` to another trait\n\nerror: aborting due to 2 previous errors\n</code></pre></div>",
        "id": 207500782,
        "sender_full_name": "pickfire",
        "timestamp": 1597912990
    },
    {
        "content": "<p>I think we cannot put <code>join</code> into <code>Iterator</code> because the output is generic, maybe an extension trait? But I never seen any extension trait for <code>Iterator</code>.</p>",
        "id": 207500939,
        "sender_full_name": "pickfire",
        "timestamp": 1597913073
    },
    {
        "content": "<p>considering that we don't have collections in core, would it make sense to instead add <code>fn intersperse</code> to <code>Iterator</code>, so the example would be</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"p\">[</span><span class=\"s\">&quot;hello&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;world&quot;</span><span class=\"p\">].</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">intersperse</span><span class=\"p\">(</span><span class=\"s\">&quot; &quot;</span><span class=\"p\">).</span><span class=\"n\">fold</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">e</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">append_str</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 207501147,
        "sender_full_name": "lcnr",
        "timestamp": 1597913219
    },
    {
        "content": "<p><code>fn intersperse(self, e: Self::Item) -&gt; ... where Self::Item: Clone</code> and <code>fn intersperse_with&lt;F&gt;(self, f: F) -&gt; ... where F: FnMut() -&gt; Self::Item</code></p>",
        "id": 207501249,
        "sender_full_name": "lcnr",
        "timestamp": 1597913297
    },
    {
        "content": "<p><a href=\"https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:intersperse\">https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:intersperse</a></p>",
        "id": 207501262,
        "sender_full_name": "lcnr",
        "timestamp": 1597913314
    },
    {
        "content": "<p>So it shouldn't be called <code>join</code> but instead <code>intersperse</code>?</p>",
        "id": 207501316,
        "sender_full_name": "pickfire",
        "timestamp": 1597913368
    },
    {
        "content": "<p>The term sounds complicated to me.</p>",
        "id": 207501323,
        "sender_full_name": "pickfire",
        "timestamp": 1597913374
    },
    {
        "content": "<p>But doesn't that only allows the same type of item to be the separator?</p>",
        "id": 207501418,
        "sender_full_name": "pickfire",
        "timestamp": 1597913415
    },
    {
        "content": "<p>Afaik, unlike <code>intersperse</code>, <code>join</code> is eager in other languages</p>",
        "id": 207501450,
        "sender_full_name": "lcnr",
        "timestamp": 1597913434
    },
    {
        "content": "<p>so it makes sense to take the name already used in haskell. We already mostly use that their names for Iterator methods</p>",
        "id": 207501486,
        "sender_full_name": "lcnr",
        "timestamp": 1597913465
    },
    {
        "content": "<p>Well, <code>collect</code> + <code>join</code> is eager too.</p>",
        "id": 207501491,
        "sender_full_name": "pickfire",
        "timestamp": 1597913469
    },
    {
        "content": "<p>exactly, and <code>intersperse</code> is lazy</p>",
        "id": 207501509,
        "sender_full_name": "lcnr",
        "timestamp": 1597913482
    },
    {
        "content": "<p>Yes, then <code>join</code> is the correct term.</p>",
        "id": 207501521,
        "sender_full_name": "pickfire",
        "timestamp": 1597913493
    },
    {
        "content": "<p>We seem to talk about slightly different things rn, sorry</p>",
        "id": 207501594,
        "sender_full_name": "lcnr",
        "timestamp": 1597913524
    },
    {
        "content": "<p>My concern is that we can't really implement <code>join</code> as part of <code>Iterator</code> as it requires allocations, is that right?</p>",
        "id": 207501628,
        "sender_full_name": "lcnr",
        "timestamp": 1597913552
    },
    {
        "content": "<p>Ah, I mean the process is supposed to be eager, not lazy. So it shouldn't be called <code>intersperse</code>.</p>",
        "id": 207501630,
        "sender_full_name": "pickfire",
        "timestamp": 1597913553
    },
    {
        "content": "<p>Yes.</p>",
        "id": 207501637,
        "sender_full_name": "pickfire",
        "timestamp": 1597913559
    },
    {
        "content": "<p>Unless we changed it like <code>collect</code>.</p>",
        "id": 207501670,
        "sender_full_name": "pickfire",
        "timestamp": 1597913583
    },
    {
        "content": "<p>So <code>intersperse</code> is a way to add this to core in a clean manner imo</p>",
        "id": 207501704,
        "sender_full_name": "lcnr",
        "timestamp": 1597913607
    },
    {
        "content": "<p>But I don't see what <code>intersperse</code> solve.</p>",
        "id": 207501743,
        "sender_full_name": "pickfire",
        "timestamp": 1597913640
    },
    {
        "content": "<p>what does <code>join</code> solve <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 207501796,
        "sender_full_name": "lcnr",
        "timestamp": 1597913657
    },
    {
        "content": "<p>It should allow joining with different type.</p>",
        "id": 207501800,
        "sender_full_name": "pickfire",
        "timestamp": 1597913660
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"nf\">intersperse</span> <span class=\"sc\">&#39;,&#39;</span> <span class=\"s\">&quot;abcde&quot;</span>\n</code></pre></div>\n\n\n<p>That looks like the same type to me.</p>",
        "id": 207501816,
        "sender_full_name": "pickfire",
        "timestamp": 1597913680
    },
    {
        "content": "<p>ah, hmm <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 207502007,
        "sender_full_name": "lcnr",
        "timestamp": 1597913837
    },
    {
        "content": "<p>The other issue I faced is that the <code>join</code> I can think of have generics return.</p>",
        "id": 207502199,
        "sender_full_name": "pickfire",
        "timestamp": 1597913989
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">join</span><span class=\"o\">&lt;</span><span class=\"n\">Separator</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sep</span>: <span class=\"nc\">Separator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Join</span><span class=\"o\">&lt;</span><span class=\"n\">Separator</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 207502211,
        "sender_full_name": "pickfire",
        "timestamp": 1597913999
    },
    {
        "content": "<p>But at the end, it probably still needs allocation.</p>",
        "id": 207502321,
        "sender_full_name": "pickfire",
        "timestamp": 1597914069
    },
    {
        "content": "<p>So I don't think it is possible to put it into core.</p>",
        "id": 207502334,
        "sender_full_name": "pickfire",
        "timestamp": 1597914079
    },
    {
        "content": "<p>wouldn't you want <code>&lt;Self::Item as Join&lt;Separater&gt;&gt;::Output</code>?</p>\n<p>I am personally quite interested in adding <code>intersperse</code> to iterator as I needed a few times in the past and I think it can mostly replace join when dealing with iterators.</p>",
        "id": 207502430,
        "sender_full_name": "lcnr",
        "timestamp": 1597914143
    },
    {
        "content": "<blockquote>\n<p>wouldn't you want &lt;Self::Item as Join&lt;Separater&gt;&gt;::Output?</p>\n</blockquote>\n<p>Yes, I want that.</p>",
        "id": 207502454,
        "sender_full_name": "pickfire",
        "timestamp": 1597914170
    },
    {
        "content": "<p>But the tests does not want that.</p>",
        "id": 207502464,
        "sender_full_name": "pickfire",
        "timestamp": 1597914180
    },
    {
        "content": "<p>I mean the compiler.</p>",
        "id": 207502480,
        "sender_full_name": "pickfire",
        "timestamp": 1597914194
    },
    {
        "content": "<p>but yeah, don't know how I feel about adding <code>join</code> to <code>Iterator</code>. I am also not part of <code>T-libs</code>so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 207502518,
        "sender_full_name": "lcnr",
        "timestamp": 1597914225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> Can you do <code>intersperse</code> with different type?</p>",
        "id": 207502525,
        "sender_full_name": "pickfire",
        "timestamp": 1597914227
    },
    {
        "content": "<p>I doubt it</p>",
        "id": 207502538,
        "sender_full_name": "lcnr",
        "timestamp": 1597914233
    },
    {
        "content": "<p>Doubt? So no? Yes?</p>",
        "id": 207502563,
        "sender_full_name": "pickfire",
        "timestamp": 1597914243
    },
    {
        "content": "<blockquote>\n<p>But the tests does not want that.</p>\n</blockquote>\n<p>why</p>",
        "id": 207502587,
        "sender_full_name": "lcnr",
        "timestamp": 1597914247
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error[E0038]: the trait `iter::traits::iterator::Iterator` cannot be made into an object\n    --&gt; library/core/src/iter/traits/iterator.rs:17:30\n     |\n17   | fn _assert_is_object_safe(_: &amp;dyn Iterator&lt;Item = ()&gt;) {}\n     |                              ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `iter::traits::iterator::Iterator` cannot be made into an object\n...\n98   | pub trait Iterator {\n     |           -------- this trait cannot be made into an object...\n...\n1672 |     fn join&lt;Separator&gt;(self, sep: Separator) -&gt; &lt;[Self::Item] as Join&lt;Separator&gt;&gt;::Output\n     |        ---- ...because method `join` has generic type parameters\n     |\n     = help: consider moving `join` to another trait\n</code></pre></div>",
        "id": 207502604,
        "sender_full_name": "pickfire",
        "timestamp": 1597914259
    },
    {
        "content": "<p>you need <code>Self: Sized</code> on <code>join</code> in this case</p>",
        "id": 207502634,
        "sender_full_name": "lcnr",
        "timestamp": 1597914284
    },
    {
        "content": "<p>I think</p>",
        "id": 207502637,
        "sender_full_name": "lcnr",
        "timestamp": 1597914286
    },
    {
        "content": "<p>Oh, <code>collect</code> have that too.</p>",
        "id": 207502661,
        "sender_full_name": "pickfire",
        "timestamp": 1597914305
    },
    {
        "content": "<p>Nice, it worked.</p>",
        "id": 207502675,
        "sender_full_name": "pickfire",
        "timestamp": 1597914311
    },
    {
        "content": "<p>Only one thing left.</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0412]: cannot find type `Vec` in this scope\n    --&gt; library/core/src/iter/traits/iterator.rs:1677:35\n     |\n1677 |         Join::join(self.collect::&lt;Vec&lt;Self::Item&gt;&gt;().as_slice(), sep)\n     |                                   ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0412`.\nerror: could not compile `core`.\n</code></pre></div>",
        "id": 207502684,
        "sender_full_name": "pickfire",
        "timestamp": 1597914325
    },
    {
        "content": "<blockquote>\n<p>Doubt? So no? Yes?</p>\n</blockquote>\n<p>intersperse with different types seems difficult to do cleanly</p>",
        "id": 207502699,
        "sender_full_name": "lcnr",
        "timestamp": 1597914335
    },
    {
        "content": "<p>at least I can't think of a good API rn</p>",
        "id": 207502723,
        "sender_full_name": "lcnr",
        "timestamp": 1597914352
    },
    {
        "content": "<p><code>Join</code> already have those.</p>",
        "id": 207502783,
        "sender_full_name": "pickfire",
        "timestamp": 1597914374
    },
    {
        "content": "<p>That's why I am just making use of the existing stuff to make this.</p>",
        "id": 207502790,
        "sender_full_name": "pickfire",
        "timestamp": 1597914385
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/75738\">https://github.com/rust-lang/rust/pull/75738</a></p>",
        "id": 207510596,
        "sender_full_name": "pickfire",
        "timestamp": 1597921369
    },
    {
        "content": "<p>FWIW I think intersperse is a great idea even if it requires the same types</p>",
        "id": 207516465,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1597926710
    },
    {
        "content": "<p><code>s.split().intersperse (\" \").collect()</code> is a lot easier to write than turbo fish for Vec</p>",
        "id": 207516531,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1597926744
    },
    {
        "content": "<p>And more efficient too I think since you only collect once</p>",
        "id": 207516543,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1597926754
    },
    {
        "content": "<p><code>intersperse</code> is already part of <code>Itertools</code>, it might make sense to promote it to std</p>",
        "id": 207516784,
        "sender_full_name": "lcnr",
        "timestamp": 1597926952
    },
    {
        "content": "<p>yeah, it is brilliant idea, but let's cc <span class=\"user-mention\" data-user-id=\"139363\">@bluss</span> on that</p>",
        "id": 207517585,
        "sender_full_name": "lzutao",
        "timestamp": 1597927472
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> The join I sent also collect once, <code>intersperse</code> looks useful but I see it as being very useful yet, at least not in my case.</p>",
        "id": 207606840,
        "sender_full_name": "pickfire",
        "timestamp": 1597995238
    },
    {
        "content": "<p>I only wish to not type <code>.collect::&lt;Vec&lt;_&gt;&gt;().join(sep)</code>, just <code>.join(sep)</code> would be more than good.</p>",
        "id": 207606902,
        "sender_full_name": "pickfire",
        "timestamp": 1597995272
    },
    {
        "content": "<p>the problem I see with join method on Iterator is that it requires allocation and an extension Trait.<br>\nWhere people use core only, they don't have a lazy iterator to loop over.</p>",
        "id": 207607613,
        "sender_full_name": "lzutao",
        "timestamp": 1597995952
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"225422\">@pickfire</span> no, your suggestion collects twice: once to Vec and once again to join them all by a separator. So it allocates twice.</p>",
        "id": 207619036,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1598005102
    },
    {
        "content": "<p>It improves the ergnomics but not the behavior</p>",
        "id": 207619058,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1598005127
    },
    {
        "content": "<p>Why would join need an extension trait but not collect?</p>",
        "id": 207620841,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598006770
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> because <code>collect</code> just calls <code>FromIterator</code>, generic to any output. This <code>join</code> creates a <code>Vec</code> intermediate, so it can't be in <code>core</code>.</p>",
        "id": 207636991,
        "sender_full_name": "cuviper",
        "timestamp": 1598018323
    },
    {
        "content": "<p>IMO, this isn't worth it just to save a little typing. It would be more motivating if it could build dynamically to the final result, but that will probably need changes to <code>Join</code>.</p>",
        "id": 207637230,
        "sender_full_name": "cuviper",
        "timestamp": 1598018449
    },
    {
        "content": "<p>Isn't <code>join(sep)</code> just <code>intersperse(sep).collect()</code>?</p>",
        "id": 207637249,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598018462
    },
    {
        "content": "<p>Ah, this one uses <code>slice::Join</code></p>",
        "id": 207637716,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598018689
    },
    {
        "content": "<p>With itertools, yes, but then you also have <code>Itertools::join</code></p>",
        "id": 207637722,
        "sender_full_name": "cuviper",
        "timestamp": 1598018693
    },
    {
        "content": "<p>My take on this is that we should totally add <code>intersperse</code> and <code>format</code> from itertools to libcore, but nothing that requires allocation</p>",
        "id": 207638370,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598019071
    },
    {
        "content": "<p>Yeah, I think changes to <code>Join</code> is required. <span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> I didn't noticed that. I am looking for a way to improve it, then all the users that currently do <code>.collect::&lt;Vec&lt;_&gt;&gt;().join()</code> needs to allocate twice then.</p>",
        "id": 207639190,
        "sender_full_name": "pickfire",
        "timestamp": 1598019490
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> No, <code>Join</code> allows different types unlike <code>intersperse</code>.</p>",
        "id": 207639433,
        "sender_full_name": "pickfire",
        "timestamp": 1598019611
    },
    {
        "content": "<p><code>.collect::&lt;Vec&lt;_&gt;&gt;().join()</code> already allocates twice</p>",
        "id": 207639473,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598019636
    },
    {
        "content": "<p>Well, all the users have to do this right now which is the easiest method.</p>",
        "id": 207639498,
        "sender_full_name": "pickfire",
        "timestamp": 1598019646
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"225422\">pickfire</span> <a href=\"#narrow/stream/219381-t-libs/topic/join.20on.20Iterator/near/207639433\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"211727\">Jonas Schievink</span> No, <code>Join</code> allows different types unlike <code>intersperse</code>.</p>\n</blockquote>\n<p>ah, true</p>",
        "id": 207639595,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598019698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> Yes, indeed. What you said is correct. I am looking for a way to both improve the ergonomics and performance. But I don't know how to know how much to allocate at first without having the first <code>Vec</code>? How do you know how much to allocate for the final <code>Vec</code>?</p>",
        "id": 207639704,
        "sender_full_name": "pickfire",
        "timestamp": 1598019741
    },
    {
        "content": "<p>But if we used the <code>collect</code> approach, it would require may more effort than this, although it may gives more performance but everything needs to be added.</p>",
        "id": 207642496,
        "sender_full_name": "pickfire",
        "timestamp": 1598021148
    },
    {
        "content": "<p>that doesn't seem like a ton more effort though, it's <code>iter.join('a')</code> vs <code>iter.intersperse(\"a\").collect()</code></p>",
        "id": 207654160,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1598026963
    },
    {
        "content": "<p>as long as there's an example for it it seems fine to me</p>",
        "id": 207654178,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1598026980
    },
    {
        "content": "<p>opened <a href=\"https://github.com/rust-lang/rust/pull/75784\">https://github.com/rust-lang/rust/pull/75784</a> to add intersperse</p>",
        "id": 207677775,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598039932
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> But you can't do <code>assert_eq!([[1, 2], [3, 4]].iter().copied().join(&amp;[0, 0][..]), [1, 2, 0, 0, 3, 4]);</code> with <code>intersperse</code>, if we want, we may need to add <code>intercalate</code> <a href=\"https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:intercalate\">https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html#v:intercalate</a></p>",
        "id": 207711402,
        "sender_full_name": "pickfire",
        "timestamp": 1598079436
    },
    {
        "content": "<p>I have a new idea today, how about adding an optional <code>Sep</code> to <code>FromIterator</code> so we could reuse <code>collect</code>.</p>",
        "id": 208293510,
        "sender_full_name": "pickfire",
        "timestamp": 1598575698
    },
    {
        "content": "<p>But still, it doesn't seemed to be good enough.</p>",
        "id": 208293521,
        "sender_full_name": "pickfire",
        "timestamp": 1598575707
    }
]