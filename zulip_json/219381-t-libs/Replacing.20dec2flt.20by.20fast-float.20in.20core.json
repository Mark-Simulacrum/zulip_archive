[
    {
        "content": "<p><em>Context</em>: Yesterday Alexhuszagh post a <a href=\"https://github.com/rust-lang/rust/issues/85198\">issue</a> on the rust repository for speeding up the float parsing in the std library by improving the current dec2flt algorithm. I search online to find crate that do better parsing and found <a href=\"https://github.com/aldanor/fast-float-rust/\">fast-float-rust</a> based on the C++ library. I post an issue to know if they have <a href=\"https://github.com/aldanor/fast-float-rust/issues/15\">Consider integration in core and std ?</a>, they responded no. Later Alexhuszagh posted on this issue his <a href=\"https://github.com/aldanor/fast-float-rust/issues/15#issuecomment-840017060\">5 steps</a> plan to drastically improve the current dec2flt algorithm. By talking with him on the issue I proposed to directly replace the dec2flt algorithm by the fast-float. His respond was \"Sure, if the maintainers are up for that\".</p>\n<p><em>fast-float</em>: <a href=\"https://github.com/aldanor/fast-float-rust\">repository</a> <a href=\"https://github.com/aldanor/fast-float-rust#performance\">performence</a> (2-8x times faster than std) <a href=\"https://github.com/aldanor/fast-float-rust/issues/15#issuecomment-840054111\">size</a> (important for IoT; slightly smaller with opt 2 and 3) <a href=\"https://arxiv.org/abs/2101.11408\">academic paper</a></p>\n<p>Would T-Libs considered replacing the dec2flt by fast-float algorithm or would you prefer the 5 steps plan from Alexhuszagh?</p>",
        "id": 238599104,
        "sender_full_name": "Urgau",
        "timestamp": 1620897619
    },
    {
        "content": "<p>So, two thoughts:</p>",
        "id": 238621593,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620912922
    },
    {
        "content": "<p>fast-float-rust says it's directly based on the C++ library. Is the Rust implementation derived from the C++ code or the algorithm in the paper? Asking because the C++ code is just Apache-2.0, but the Rust code says MIT/Apache-2.0.</p>",
        "id": 238622565,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620913358
    },
    {
        "content": "<p>If the Rust code were a derived work of the C++, it wouldn't be able to add the MIT dual license. (And the C++ code has had third-party contributions, so it isn't just the original author who would need to grant permission for that.)</p>",
        "id": 238623023,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620913573
    },
    {
        "content": "<p>The other thought: this seems like a great idea to me, backed up by the benchmarks, but it would be nice to get confirmation of that vs the proposed modifications to dec2flt from Alexhuszagh. Since it sounds like those modifications have already been tried in an external repo, could you confirm with Alexhuszagh if they believe fast-float-rust would be the right path forward even given their proposed modifications?</p>",
        "id": 238623493,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620913804
    },
    {
        "content": "<p>(And if integrating fast-float-rust turns out to be a challenge that takes time, we should go ahead and apply the proposed changes to dec2flt in the interim.)</p>",
        "id": 238623611,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620913865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"327095\">@Urgau</span> Does that answer your question?</p>",
        "id": 238623641,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620913881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20dec2flt.20by.20fast-float.20in.20core/near/238622565\">said</a>:</p>\n<blockquote>\n<p>fast-float-rust says it's directly based on the C++ library. Is the Rust implementation derived from the C++ code or the algorithm in the paper? Asking because the C++ code is just Apache-2.0, but the Rust code says MIT/Apache-2.0.</p>\n</blockquote>\n<p>I don't know, I will ask the maintainers of fast-float, both Rust and C++.<br>\n<span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20dec2flt.20by.20fast-float.20in.20core/near/238623493\">said</a>:</p>\n<blockquote>\n<p>The other thought: this seems like a great idea to me, backed up by the benchmarks, but it would be nice to get confirmation of that vs the proposed modifications to dec2flt from Alexhuszagh. Since it sounds like those modifications have already been tried in an external repo, could you confirm with Alexhuszagh if they believe fast-float-rust would be the right path forward even given their proposed modifications?</p>\n</blockquote>\n<p>Alex said in <a href=\"https://github.com/aldanor/fast-float-rust/issues/15#issuecomment-840017060\">this</a> reply: \"Ideally, we'd remove it, and replace it with your code\". So yes.<br>\n<span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20dec2flt.20by.20fast-float.20in.20core/near/238623641\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"327095\">Urgau</span> Does that answer your question?</p>\n</blockquote>\n<p>Yes absolutely. Thanks you for your response.</p>",
        "id": 238624493,
        "sender_full_name": "Urgau",
        "timestamp": 1620914323
    },
    {
        "content": "<p>Please start by only asking the maintainers of the Rust code; the maintainers of the C++ code aren't responsible for downstream projects of theirs.</p>",
        "id": 238624938,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620914523
    },
    {
        "content": "<p>(And please be diplomatic about it.)</p>",
        "id": 238625019,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620914551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  Okay, no problem.<br>\nI also just saw that the C++ README <a href=\"https://github.com/fastfloat/fast_float#other-programming-languages\">reference</a> the  Rust code as an port.</p>\n<blockquote>\n<p>There is a Rust port of the fast_float library called fast-float-rust.</p>\n</blockquote>",
        "id": 238625965,
        "sender_full_name": "Urgau",
        "timestamp": 1620914992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20dec2flt.20by.20fast-float.20in.20core/near/238623493\">said</a>:</p>\n<blockquote>\n<p>The other thought: this seems like a great idea to me, backed up by the benchmarks, but it would be nice to get confirmation of that vs the proposed modifications to dec2flt from Alexhuszagh. Since it sounds like those modifications have already been tried in an external repo, could you confirm with Alexhuszagh if they believe fast-float-rust would be the right path forward even given their proposed modifications?</p>\n</blockquote>\n<p>I'm fine with either. I'm attempting to make incremental changes in the short term, but I'm more than happy if everything pans out to replace it with fast-float-rust entirely.</p>",
        "id": 238638355,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620920220
    },
    {
        "content": "<p>My goal is merely to get float parsing to go faster. My incremental improvements are mostly to be just that: incremental. If we can get full approval to merge fast-float-rust into core and that's ok with the current maintainers (I see Hanna Kruppe retired), even better.</p>",
        "id": 238639117,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620920591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153718\">@Alexander Huszagh</span> You're confident that fast-float would be faster than your optimized version of dec2flt?</p>",
        "id": 238640352,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620921166
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Absolutely. I'm the author of lexical, and my work currently has been entirely supplanted by the Eisel-Lemire algorithm, and the Rust implementation is a fair bit faster. There's a few, isolated cases where it can be improved upon, however.</p>",
        "id": 238640458,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921227
    },
    {
        "content": "<p>Sounds good to me. Then yeah, assuming there's no license issue, I'd love to see fast-float-rust added, and then incrementally improved from there.</p>",
        "id": 238640584,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620921271
    },
    {
        "content": "<p>1). Disguised fast-path cases. These are cases like <code>1.2345e30</code>, where we can get ~30% improvement in performance of these cases (without affecting other paths) with a trivial modification to float parsing.</p>",
        "id": 238640621,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921291
    },
    {
        "content": "<p>We should consider whether it's going to be larger in terms of code/data size, especially while it's hard to cfg out float support from libcore</p>",
        "id": 238640735,
        "sender_full_name": "simulacrum",
        "timestamp": 1620921339
    },
    {
        "content": "<p>2). There's a few cases where the Clinger's old algorithm Bellerophon covers cases Eisel-Lemire doesn't. Since big-integer arithmetic is slow, it's a suitable fallback and fairly trivial to implement.</p>",
        "id": 238640747,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921344
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> I've done the tests: it's comparable in size for all optimization levels.</p>",
        "id": 238640767,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921358
    },
    {
        "content": "<p>See: <a href=\"https://github.com/aldanor/fast-float-rust/issues/15#issuecomment-840054111\">https://github.com/aldanor/fast-float-rust/issues/15#issuecomment-840054111</a></p>",
        "id": 238640850,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921385
    },
    {
        "content": "<p>Great!</p>",
        "id": 238640891,
        "sender_full_name": "simulacrum",
        "timestamp": 1620921408
    },
    {
        "content": "<p>These are a trivial smoke test for benchmarks, and what I'm basing my incremental improvements on:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// Example fast-path value.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FAST_PATH</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"1.2345e22\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Example disguised fast-path value.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">DISGUISED_FAST_PATH</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"1.2345e30\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Example moderate path value: clearly not halfway `1 &lt;&lt; 53`.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">MODERATE_PATH</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"9007199254740992.0\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Example exactly-halfway value `(1&lt;&lt;53) + 1`.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">HALFWAY</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"9007199254740993.0\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Example large, near-halfway value.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LARGE</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"8.988465674311580536566680e307\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Very long, near-halfway large value.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LONG_LARGE</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"8.9884656743115805365666807213050294962762414131308158973971342756154045415486693752413698006024096935349884403114202125541629105369684531108613657287705365884742938136589844238179474556051429647415148697857438797685859063890851407391008830874765563025951597582513936655578157348020066364210154316532161708031999e+307\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Example denormal, near-halfway value.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">DENORMAL</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"8.442911973260991817129021e-309\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// Very long, near-halfway, denormal value.</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LONG_DENORMAL</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"2.4703282292062327208828439643411068618252990130716238221279284125033775363510437593264991818081799618989828234772285886546332835517796989819938739800539093906315035659515570226392290858392449105184435931802849936536152500319370457678249219365623669863658480757001585769269903706311928279558551332927834338409351978015531246597263579574622766465272827220056374006485499977096599470454020828166226237857393450736339007967761930577506740176324673600968951340535537458516661134223766678604162159680461914467291840300530057530849048765391711386591646239524912623653881879636239373280423891018672348497668235089863388587925628302755995657524455507255189313690836254779186948667994968324049705821028513185451396213837722826145437693412532098591327667236328125001e-324\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238641128,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921541
    },
    {
        "content": "<p>These cover all common pitfalls in terms of performance for float parsing:<br>\n1). Fast path cases, where both the exponent and the significant digits can be represented as native integers.<br>\n2). Disguised fast path cases, where we can move powers of 10 from the exponent to the significant digits.<br>\n3). Moderate path cases, where we force Eisel-Lemire or Bellerophon algorithms.<br>\n4). Halfway cases, which can force slow path algorithms in bad cases.<br>\n5). Large and denormal, which do the same thing, but test implementations with large and small powers.<br>\n6). Long variants of these, which should force slow path (arbitrary-precision) algorithms.</p>",
        "id": 238641437,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921685
    },
    {
        "content": "<p>In the <code>LARGE</code> case,  an optimized version of Bellerophon is still faster than fast-float-rust, since it is forced to go to the slow algorithms.<br>\nIn the <code>DISGUISED_FAST_PATH</code> case, we can improve the performance ~30% with trivial improvements to the algorithm.</p>\n<p>A poorly optimized version of the Bellerophon algorithm is ~20x as fast as fast-float-rust, so we should definitely consider it.</p>",
        "id": 238642051,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620921824
    },
    {
        "content": "<p>Neither of these changes should affect binary size (the disguised fast path case definitely does not), and Bellerophon modifications might introduce a slightly large binary size (I'd have to test), but can trivially be minimized to a very small algorithm:</p>\n<p>1). A struct with a 64-bit mantissa, and 16-bit exponent (stored as an i32 likely)<br>\n2). A 64-bit multiplication algorithm, slightly different than the one used in Eisel-Lemire.<br>\n3). An algorithm to normalize floats, which is essentially the <code>ctlz</code>instruction and then a bitshift.<br>\n4). A trivial approach to count errors. This is like 5 lines of code.<br>\n5). A trivial number of bitshifts and bitmasks to ensure we round-nearest, tie-even.</p>\n<p>This reason these differences occur is because the Bellerophon algorithm and the Eisel-Lemire algorithm don't have perfect overlap in cases they can unambiguously detect. The Eisel-Lemire algorithm does 2 passes if there are truncated digits for <code>mantissa</code> and <code>mantissa+1</code> to ensure there are no halfway rounding cases, and if the first pass fails, we can fallback to Bellerophon.</p>",
        "id": 238642544,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620922047
    },
    {
        "content": "<p>In short, I'm entirely on board, and have a few small additions to suggest for certain corner cases.</p>",
        "id": 238642742,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620922136
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153718\">@Alexander Huszagh (He/Him)</span> Will your proposed changes increase the correctness of dec2float?</p>",
        "id": 238681896,
        "sender_full_name": "Jubilee",
        "timestamp": 1620940248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> It won't affect the correctness (both will be correct), but it will increase performance for certain cases (the former which is relatively common, the latter which is fairly rare) noticeably.</p>\n<p>Basically, Eisel-Lemire is a very fast algorithm that occurs if the fast-path (native floats) don't work, and otherwise it falls back to a slow-path algorithm. Bellerophon only would then be used if Eisel-Lemire fails on the first pass, but before the slow path is used.</p>\n<p>The slow path <strong>always</strong> works, even on trivial floats. It's just very slow, so it's typically not used unless needed.</p>\n<p>They're also relatively simple to implement. The former just got merged into fast-float-rust, although I'm not sure if the latter will.</p>",
        "id": 238689382,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620944185
    },
    {
        "content": "<p>The last change is handy (for a small percentage of floats, it has a major difference in performance), but they're very rare, so they'd have to be specifically designed for slow performance to affect the speed of float parsing in any real world example. The former is much more important, and is about the be merged, so we shouldn't have any issues.</p>\n<p>For 3 examples of floats that might be classified by Eisel-Lemire or Bellerophon, we have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"s\">\"9007199254740992000e-3\"</span><span class=\"w\">   </span><span class=\"c1\">// Exactly represented, (1&lt;&lt;53)</span>\n<span class=\"s\">\"9007199254740993000e-3\"</span><span class=\"w\">   </span><span class=\"c1\">// Halfway, ((1&lt;&lt;53)+1)</span>\n<span class=\"s\">\"9007199254740994000e-3\"</span><span class=\"w\">   </span><span class=\"c1\">// Exactly represented, ((1&lt;&lt;53)+2)</span>\n</code></pre></div>\n<p>Eisel-Lemire cannot determine if any of these are correct, while Bellerophon can correctly round 1 and 3. In these case, Bellerophon is ~20-30x faster than Eisel-Lemire, but this probably affects like 0.1% of all floats, and very few real-world examples.</p>",
        "id": 238690901,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620945079
    },
    {
        "content": "<p>The full implementation of a rather unoptimized version can be found here, and the only routines outside of <a href=\"https://github.com/Alexhuszagh/rust-dec2flt/blob/moderate/src/dec2flt/algorithm.rs#L168-L215\">here</a> are <code>normalize</code> and <code>mul</code>. <code>mul</code> is just a 64-bit multiplication that rounds-up if the lower 64-bits are above or are halfway, and takes the high 64-bits. <code>normalize</code> is just a ctlz operation that adjusts both the binary exponent and the significant digits.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">normalize</span><span class=\"p\">(</span><span class=\"n\">fp</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Fp</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ctlz</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fp</span><span class=\"p\">.</span><span class=\"n\">mant</span><span class=\"p\">.</span><span class=\"n\">leading_zeros</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">fp</span><span class=\"p\">.</span><span class=\"n\">mant</span><span class=\"w\"> </span><span class=\"o\">&lt;&lt;=</span><span class=\"w\"> </span><span class=\"n\">ctlz</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">fp</span><span class=\"p\">.</span><span class=\"n\">exp</span><span class=\"w\"> </span><span class=\"o\">-=</span><span class=\"w\"> </span><span class=\"n\">ctlz</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And that's it. The <code>power_of_ten</code> is also shared with fast-float-rust.</p>\n<p>If we want to get rid of denormal cases, we can remove ~75% of the code for the algorithm.</p>",
        "id": 238692476,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620946041
    },
    {
        "content": "<p>The full <code>mul</code> implementation can be found here (it's already in Rust core):<br>\n<a href=\"https://github.com/Alexhuszagh/rust-dec2flt/blob/ad4596cc85ee3647cb20d594651a6061b16ca6a9/src/diy_float.rs#L15-L29\">https://github.com/Alexhuszagh/rust-dec2flt/blob/ad4596cc85ee3647cb20d594651a6061b16ca6a9/src/diy_float.rs#L15-L29</a></p>",
        "id": 238692598,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1620946090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Just to come to your legal concern, I have receive confirmation by the owner of the crate that the crate is entirely based on the C++ code.<br>\nIn this <a href=\"https://github.com/aldanor/fast-float-rust/issues/15#issuecomment-840649609\">comment </a>, he propose to \"make the original library Apache2/MIT\" or \"make this crate Apache2-only\" (like the C++ code). Which of these 2 solutions do you think would solve the licensing problem?</p>",
        "id": 238730640,
        "sender_full_name": "Urgau",
        "timestamp": 1620978307
    },
    {
        "content": "<p>So, the former would be the only way the code could be added to the Rust standard library, but such a change would require permission from every contributor to the original library (not just the primary author).</p>",
        "id": 238746136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620988068
    },
    {
        "content": "<p>(You can safely skip requesting permission from anyone who has only contributed to the readme or something else other than the C++ code.)</p>",
        "id": 238746249,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620988122
    },
    {
        "content": "<p>So looking for who needs to agree to accept relicensing in the original C++ implementation, there are currently 9 contributors.</p>\n<p>Lemire is the main author, and has said \"+1\".<br>\nTimkpaine only added a compiler <a href=\"https://github.com/fastfloat/fast_float/commit/48d30f789beae7dd6af6ead58854d42b3a808db1\">flag</a> for emscripten, which is irrelevant here.<br>\neugenegfff added support for signalling <a href=\"https://github.com/fastfloat/fast_float/commit/76dec80fbd574c69685c147a0d83d6cc8aaaa9a1\">NaNs</a>, which fast-float-rust does not use.<br>\n0xfloatus fixed the <a href=\"https://github.com/fastfloat/fast_float/commit/82ea4af1079a106c3f1397746ead966fdf5c11ac\">README</a><br>\nnealrichardson added a compiler <a href=\"https://github.com/fastfloat/fast_float/commit/ca0a4646e91e1485e69aea985b53bb22d0f819b1\">flag</a> for Solaris, also irrelevant here.<br>\ngeorg-emg <a href=\"https://github.com/fastfloat/fast_float/commit/0d33df55baf1847ff025a58afd8de0ecb4ff7511\">added</a> <a href=\"https://github.com/fastfloat/fast_float/commit/dfa304a698a19c68e5d35894b076b35b28b714e2\">cmake</a> <a href=\"https://github.com/fastfloat/fast_float/commit/f1681745e47951a35fb823e5438373e1f7b7843b\">targets</a>, although the second commit may contain relevant code for truncated 0s.<br>\nkitisreal only changed <a href=\"https://github.com/fastfloat/fast_float/commit/68633178d56807585a455a2134d2807f425cfc96\">inlining</a></p>\n<p>So it's just biojppm and maybe georg-emg that need to agree to a license change, in addition to lemire, if this was based off an earlier version.</p>\n<p>If not, we need 2 more people who added compiler flags for endian-aware stuff.</p>",
        "id": 238775070,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621002361
    },
    {
        "content": "<p>Since the vast majority of the commits were in January for fast-float-rust, and nothing that changes the actual code has been done since, this would only be kitaisreal and biojppm who is relevant.</p>",
        "id": 238777401,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621003210
    },
    {
        "content": "<p>Ok we've made significant progress on this:</p>\n<p>1). Lemire has emailed biojppm, the only person we need approval from for merging.<br>\n2). I've merged in the optimization for disguised fast-path cases.<br>\n3). I've fixed tests for 32-bit architectures.<br>\n4). I've done comprehensive tests on the following platforms, all of which demonstrate correctness:</p>\n<ul>\n<li>powerpc-unknown-linux-gnu</li>\n<li>armv7-unknown-linux-gnueabihf</li>\n<li>x86_64-unknown-linux-gnu</li>\n</ul>",
        "id": 238921022,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621108028
    },
    {
        "content": "<p>I'll be running tests on all the Tier 1 targets today, and a few more Tier 2 targets just in case. The correctness <a href=\"https://github.com/Alexhuszagh/fast-float-rust/tree/comprehensive/data\">checks</a> use Rust's built-in tests, along with Golang's tests, and a few specialized cases. No errors have been detected. We've also confirmed the accepted float syntax matches nightly (with the special float fixes for case-sensitivity).</p>\n<p>I will be checking:</p>\n<ul>\n<li>aarch64-unknown-linux-gnu</li>\n<li>i686-unknown-linux-gnu</li>\n<li>arm-unknown-linux-gnueabihf</li>\n<li>mips-unknown-linux-gnu</li>\n<li>mips64el-unknown-linux-gnuabi64</li>\n<li>s390x-unknown-linux-gnu</li>\n<li>riscv64gc-unknown-linux-gnu</li>\n</ul>\n<p>I'll get back to you when all these tests pass in like 2 days, but everything should work :D.</p>",
        "id": 238921235,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621108256
    },
    {
        "content": "<p>There's also been talk about adding a <code>from_parts</code> method for <code>f32</code> and <code>f64</code>, that would take a signature as follows:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"kt\">f32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">from_parts</span><span class=\"p\">(</span><span class=\"n\">integral</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fractional</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">exponent</span>: <span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">negative</span>: <span class=\"kt\">bool</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This would be very handy in parser implementations (and would have almost entirely code re-use), since it would allow parsing formats like JSON and TOML which do not have the same syntax as Rust floats (as well as basically every other programming language).</p>\n<p>Obviously, this would need to go through an RFC process, and is beyond the scope of this discussion.</p>",
        "id": 238921414,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621108498
    },
    {
        "content": "<p>My <a href=\"https://github.com/fastfloat/fast_float/pull/70\">pull request</a> for dual licensing the C++ <a href=\"https://github.com/fastfloat/fast_float/\">fast_float</a> with MIT/Apache has been merged. We're now also go to go with licensing. <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 238988013,
        "sender_full_name": "Urgau",
        "timestamp": 1621180386
    },
    {
        "content": "<p>Nicely done!</p>",
        "id": 238995106,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621187482
    },
    {
        "content": "<p>I've expanded my tests to:</p>\n<ul>\n<li>powerpc-unknown-linux-gnu</li>\n<li>armv7-unknown-linux-gnueabihf</li>\n<li>x86_64-unknown-linux-gnu</li>\n<li>s390x-unknown-linux-gnu</li>\n<li>mips64el-unknown-linux-gnuabi64</li>\n<li>mips-unknown-linux-gnu</li>\n<li>arm-unknown-linux-gnueabihf</li>\n<li>i686-unknown-linux-gnu</li>\n<li>aarch64-unknown-linux-gnu</li>\n<li>powerpc64le-unknown-linux-gnu</li>\n<li>armv7-unknown-linux-gnueabihf</li>\n<li>riscv64gc-unknown-linux-gnu</li>\n</ul>\n<p>That should effectively be every Tier-1 and Tier-2 target.</p>",
        "id": 238999863,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621192521
    },
    {
        "content": "<p>Hmm, I'd expect powerpc64le-unknown-linux-gnu to be in the list, instead of/in addition to powerpc-unknown-linux-gnu</p>",
        "id": 239000790,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1621193579
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> It should be, that was a typo (powerpc-unknown-linux-gnu was duplicated). Thank you.</p>",
        "id": 239001878,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621194754
    },
    {
        "content": "<p>x86_64-unknown-linux-gnu is also duplicated</p>",
        "id": 239001923,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1621194824
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">targets</span><span class=\"p\">.</span><span class=\"n\">sort</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">targets</span><span class=\"p\">.</span><span class=\"n\">dedup</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 239008843,
        "sender_full_name": "cuviper",
        "timestamp": 1621201745
    },
    {
        "content": "<p><span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 239008854,
        "sender_full_name": "cuviper",
        "timestamp": 1621201763
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20dec2flt.20by.20fast-float.20in.20core/near/239008843\">said</a>:</p>\n<blockquote>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">targets</span><span class=\"p\">.</span><span class=\"n\">sort</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">targets</span><span class=\"p\">.</span><span class=\"n\">dedup</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>;) Whoooops.</p>",
        "id": 239016839,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1621209926
    },
    {
        "content": "<p>This has been tentatively implemented and submitted as a PR <a href=\"https://github.com/rust-lang/rust/pull/86761\">here</a>.</p>",
        "id": 244493183,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1625089918
    },
    {
        "content": "<p>Ok further updates on this <a href=\"https://github.com/rust-lang/rust/pull/86761\">PR</a>:</p>\n<ol>\n<li>Almost all unsafety has been removed, and all unsafety can be provably correct.</li>\n<li>The implementation can be shown trivially to not panic either.</li>\n<li>Benchmarks have been run, showing excellent <a href=\"https://github.com/rust-lang/rust/pull/86761#issuecomment-873695763\">performance</a>.</li>\n<li>The replaced unsafe functions with safe implementations generate identical <a href=\"https://github.com/Alexhuszagh/fast-float-asm\">ASM</a> in most cases, sometimes faster.</li>\n<li>I've used <a href=\"https://github.com/rust-lang/miri-test-libstd\">Miri</a> to test the core library for the new dec2flt implementation: everything passes.</li>\n<li>All errors in <a href=\"https://github.com/Alexhuszagh/rust/blob/master/src/etc/test-float-parse/runtests.py\">runtests.py</a> for comprehensive float tests have been patched.</li>\n<li>The float library is more correct than before, handling floats with large numbers of digits and subnormal floats without erroring. This fixes numerous outstanding issues.</li>\n<li>Regression tests for the affected issues have been added.</li>\n<li>Compiler workarounds for unparseable float literals have been removed, as they can no longer occur.</li>\n<li>Extensive documentation has been added to ensure the code is maintainable and correct.</li>\n<li>The author of the paper describing the new algorithms has reviewed the code numerous times, and said <a href=\"https://github.com/aldanor/fast-float-rust/issues/15#issuecomment-873640634\">the code looks great</a>.</li>\n<li>Documentation for control-flow paths that may be non-obvious have also been added, including feedback from others who reviewed the library and found parts not obvious immediately.</li>\n<li>References to the library, as well as extensive documentation describing the algorithms have been added, so non-experts should be able to understand the code, including for how constants were <a href=\"https://github.com/Alexhuszagh/rust/blob/73c939107703641be9173d7cf66209f87d10245c/library/core/src/num/dec2flt/float.rs#L35-L52\">generated</a>.</li>\n<li>The binary sizes are comparable or smaller than the previous implementation.</li>\n</ol>\n<p>I believe the PR is in a state where it's ready or decently close to ready to merge: any additional feedback would be greatly appreciated.</p>",
        "id": 244884971,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1625445757
    },
    {
        "content": "<p>After a crater run that found no regression, the <a href=\"https://github.com/rust-lang/rust/pull/86761\">pull-request</a> has been <a href=\"https://github.com/rust-lang/rust/pull/86761#issuecomment-881914858\">merged</a> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 246341014,
        "sender_full_name": "Urgau",
        "timestamp": 1626551654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"327095\">Urgau</span> <a href=\"#narrow/stream/219381-t-libs/topic/Replacing.20dec2flt.20by.20fast-float.20in.20core/near/246341014\">said</a>:</p>\n<blockquote>\n<p>After a crater run that found no regression, the <a href=\"https://github.com/rust-lang/rust/pull/86761\">pull-request</a> has been <a href=\"https://github.com/rust-lang/rust/pull/86761#issuecomment-881914858\">merged</a> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>\n</blockquote>\n<p>Esteban also had a great suggestion now that we can parse float literals: it might be worthwhile having compiler warnings if the value provided by the user for literals substantially differs from the actual value. The classic example would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mf\">9007199254740992.0</span><span class=\"p\">;</span><span class=\"w\">  </span><span class=\"c1\">// 1 &lt;&lt; 53</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_h</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mf\">9007199254740993.0</span><span class=\"w\"> </span><span class=\"c1\">// (1&lt;&lt;53) + 1</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">+</span><span class=\"n\">u</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mf\">9007199254740994.0</span><span class=\"w\"> </span><span class=\"c1\">// (1&lt;&lt;53) + 2</span>\n</code></pre></div>\n<p>In the <code>b_h</code> case (or, <code>b+h</code>, signifying it's a halfway point between <code>b</code> and <code>b+u</code>), we would truncate the value down to <code>9007199254740992.0</code>, which is likely not what the developer wanted (obviously, these warnings could be silenced).</p>\n<p>It would be doable to implement this, since we can use the Dragon4 serializing algorithm with format precision control to see if there's any difference in the significant digits.</p>",
        "id": 246351678,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1626568280
    },
    {
        "content": "<p>For example, if someone inputs '0.1', obviously we wouldn't warn about <code>0.1000000000000000055511151</code>, since <code>0.1</code> is the nearest possible float with 1 significant digit. However, the above case would be a good example to the contrary. It might be a good usability feature, since it avoids correctness issues for literals at compile time (a good alternative to hexadecimal floats).</p>",
        "id": 246351752,
        "sender_full_name": "Alexander Huszagh (He/Him)",
        "timestamp": 1626568431
    },
    {
        "content": "<p>i'm in favor of this but genuinely don't think it's an alternative to hex floats</p>",
        "id": 246354585,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1626573828
    }
]