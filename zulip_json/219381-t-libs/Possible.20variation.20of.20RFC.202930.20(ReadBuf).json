[
    {
        "content": "<p>I'm sure this has been considered, but I couldn't find discussion after a casual dig through the mountain of discussion around reading into uninit memory. Could we introduce a new trait, call it Read2 as a total strawman, that has <code>read</code> with the <code>ReadBuf</code> argument, rather than adding a new method to the existing Read trait?</p>\n<p>We could add a default impl: <code>impl&lt;T: Read&gt; Read2 for T</code> which wraps the u8 slice in a ReadBuf, so all existing impls of Read have baseline compatiblity, then change all uses of Read to Read2. The downside is back compat where you have a Read2 object and something expects a Read argument, in which case you hit a slow path and have to zero memory, but this seems no worse than using the default impl of read_buf in the current proposal.</p>",
        "id": 264166330,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638975500
    },
    {
        "content": "<p>If there is <code>impl&lt;T: Read&gt; Read2 for T</code>, then types can't both</p>\n<ul>\n<li>implement <code>Read</code> (needed for compatability) and</li>\n<li>implement <code>Read2</code> efficiently (ie without going through initialization and <code>Read</code>)</li>\n</ul>",
        "id": 264170144,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638976934
    },
    {
        "content": "<p>I think this can be solved by providing compatability adapter like <code>struct ReadCompat&lt;R: Read2&gt;(R); impl Read for ReadCompat...</code>.<br>\nThis would make calling old code from new code more verbose, but it's a solution.</p>",
        "id": 264170767,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638977132
    },
    {
        "content": "<p>Another way is to invert everything:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Read2</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">ReadCompat</span><span class=\"o\">&lt;</span><span class=\"n\">R</span>: <span class=\"nc\">Read</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">R</span>: <span class=\"nc\">Read</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Read2</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ReadCompat</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This way calling new code from old code is more verbose.</p>",
        "id": 264171202,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638977299
    },
    {
        "content": "<p>I would expect types could just impl Read2, and when migrating, stop impl'ing Read (since the blanket impl exists, it is not needed for compat, though I guess crates would need to cfg based on Rust version if they wanted to support Rust versions from before the blanket impl is added to std)</p>",
        "id": 264172896,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638977854
    },
    {
        "content": "<p>Compat can still be needed if both the <code>impl Read</code> and <code>f(_: impl Read)</code> are coming from immutable dependencies</p>",
        "id": 264173847,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638978204
    },
    {
        "content": "<p>Could you flesh out that example a bit please, I donâ€™t understand</p>",
        "id": 264174433,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638978428
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// std</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Read2</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// coolread (old crate)</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">io</span>::<span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ReadImpl</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// coolwrite (new crate)</span>\n<span class=\"k\">fn</span> <span class=\"nf\">write_to_file</span><span class=\"p\">(</span><span class=\"n\">path</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">AsRef</span><span class=\"o\">&lt;</span><span class=\"n\">Path</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">data</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">io</span>::<span class=\"n\">Read2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// your crate</span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">coolread</span>::<span class=\"n\">ReadImpl</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">coolwrite</span>::<span class=\"n\">write_to_file</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ReadImpl</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">write_to_file</span><span class=\"p\">(</span><span class=\"s\">\"./a\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// compilation error</span>\n</code></pre></div>",
        "id": 264175930,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638978982
    },
    {
        "content": "<p>Ah so, in your original example, the arg to f should be Read2?</p>",
        "id": 264180414,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638980807
    },
    {
        "content": "<p>My suggestion is for the blanket impl to be the other way around, so in this case it should compile, I think?</p>",
        "id": 264180538,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638980871
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264180414\">said</a>:</p>\n<blockquote>\n<p>Ah so, in your original example, the arg to f should be Read2?</p>\n</blockquote>\n<p>Yes, it should have been <code>Read2</code>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264180538\">said</a>:</p>\n<blockquote>\n<p>My suggestion is for the blanket impl to be the other way around, so in this case it should compile, I think?</p>\n</blockquote>\n<p>Yes, <em>this</em> example with your original suggestion works. But there is an example which works the other way around too:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// std</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Read</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Read2</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// coolread (new crate this time)</span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">io</span>::<span class=\"n\">Read2</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ReadImpl</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// coolwrite (old crate this time)</span>\n<span class=\"k\">fn</span> <span class=\"nf\">write_to_file</span><span class=\"p\">(</span><span class=\"n\">path</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">AsRef</span><span class=\"o\">&lt;</span><span class=\"n\">Path</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">data</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">io</span>::<span class=\"n\">Read</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// your crate</span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">coolread</span>::<span class=\"n\">ReadImpl</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">coolwrite</span>::<span class=\"n\">write_to_file</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ReadImpl</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">write_to_file</span><span class=\"p\">(</span><span class=\"s\">\"./a\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// compilation error</span>\n</code></pre></div>",
        "id": 264212021,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638993683
    },
    {
        "content": "<p>right yeah, this kind of situation would suck. I think it would be relatively easy to provide a compat utility struct, but aiui there isn't a very efficient implementation possible because you have to zero out the uninit memory in the buffer provided to Read2::read</p>",
        "id": 264215148,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638995160
    },
    {
        "content": "<p>although, doesn't this happen silently with 2930? As in you don't need any compat shim, but you silently hit slowdown because you have to use the default impl for read?</p>",
        "id": 264215442,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1638995296
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> <span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> any thoughts?</p>",
        "id": 264422191,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639129043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> I love the <em>idea</em> of a legacy-free trait that only uses <code>ReadBuf</code>, but I don't love the need for compat wrappers.</p>",
        "id": 264433635,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639135787
    },
    {
        "content": "<p>I think the RFC discusses the option a bit - my primary concern there was that I wanted libraries consuming an arbitrary <code>Read</code> to be able to take advantage of readbuf without a breaking API change.</p>",
        "id": 264439463,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1639139186
    },
    {
        "content": "<p>And you could make it decently ergonomic with a little bit of compiler work to support e.g. a lint for \"override exactly 1 of read and read_buf\"</p>",
        "id": 264439653,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1639139304
    },
    {
        "content": "<p>I'd <em>love</em> to see compiler support for \"here's what sets of methods of a trait you should implement\".</p>",
        "id": 264441056,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639140094
    },
    {
        "content": "<p>(Minimum and maximum. That would also help for traits that have mutually recursive defaults.)</p>",
        "id": 264441097,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639140121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264439463\">said</a>:</p>\n<blockquote>\n<p>I think the RFC discusses the option a bit - my primary concern there was that I wanted libraries consuming an arbitrary <code>Read</code> to be able to take advantage of readbuf without a breaking API change.</p>\n</blockquote>\n<p>Do you mean that you want libs to be able to use a <code>Read</code> impl where there is only an implementation of read_buf, and use the default impl of read? Or that you want such libraries to be able to get the perf benefits of using a ReadBuf? (I don't understand how the latter is posible)</p>",
        "id": 264443813,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639141661
    },
    {
        "content": "<p>For the lint, I worry that there is a lot to express and at least one of n, or even a min/max is only an approximation. E.g., you might want to force the implementor to impl one of <code>read</code> and <code>read_buf</code> and one of <code>read_vectored</code> and <code>read_buf_vectored</code> (I know we don't actually want this for Read)</p>",
        "id": 264444220,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639141841
    },
    {
        "content": "<p>(I wonder if default methods are also too crude a mechanism, but that is a different story, I think)</p>",
        "id": 264444311,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639141903
    },
    {
        "content": "<p>To summarize, here are the different approaches</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Read and read_buf situation summary</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<h3>1. Add a new <code>Read</code> trait, say <code>ReadIntoReadBuf</code>, with no <code>&amp;'_ mut [u8]</code> API, but a <code>ReadBuf&lt;'_&gt;</code> API.</h3>\n<p>Objective: if one of those two traits is implemented, then it should still be possible to interact with APIs requiring the other trait.</p>\n<p>The gap can be filled with a blanket impl in one direction, and a <code>.compat()</code> adapter in the other. To consider these approaches, let's assume a <code>::user</code>, <code>::provides_read</code>, and <code>::uses_read</code> crates, with <code>::user</code> depending on these other two crates.</p>\n<h4>1.1. <code>impl&lt;R : ?Sized + ReadIntoReadBuf&gt; Read for R {}</code> + <code>.compat()</code> adapter for <code>impl Read -&gt; impl ReadIntoReadBuf</code>.</h4>\n<p>Pros:</p>\n<ul>\n<li>\n<p>all the impls are optimal, except for the code of the <code>Compat&lt;â€¦&gt;</code> adapter (this is good: it's nice to have the noisy one feature the suboptimal impl).</p>\n</li>\n<li>\n<p><strong><code>::provides_read</code> can improve its implementation of <code>Read</code> by replacing it with on of <code>ReadIntoReadBuf</code> instead, without breaking semver</strong> / within a minor bump. If <code>::user</code>, itself, where to have an <code>impl ReadIntoReadBuf</code> requirement, then they're all happy.</p>\n</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li><strong><code>::uses_read</code> can't improve its logic to take advantage of the new <code>ReadIntoReadBuf</code>, at least not for the already existing APIs</strong>. It will need to either add new APIs itself (<code>stuff</code> -&gt; <code>stuff_read_buf</code>), or to perform a major breaking change. If the major change path is taken, and <code>::user</code> wants to use it, while waiting for <code>::provides_read</code> to catch up, they'll have to temporarily append those <code>.compat()</code> adapters.</li>\n</ul>\n<h4>1.2. <code>impl&lt;R : ?Sized + Read&gt; ReadIntoReadBuf for R {}</code> + <code>.compat()</code> adapter for <code>impl ReadIntoReadBuf -&gt; impl Read</code>.</h4>\n<p>Pros/Cons are swapped <em>w.r.t.</em> the previous situation:</p>\n<ul>\n<li>\n<p><code>::uses_read</code> can now say that its APIs expects an <code>impl ReadIntoReadBuf</code>, and not require a major version bump. But if <code>::provides_read</code> now wants to provide a smarter <code>ReadIntoReadBuf</code> implementation for its type, it will have to let go of the original <code>Read</code> impl because of coherence, and thus so doing would require a major version bump. And, again, <code>::user</code> were to use an updated <code>::provides_read</code>, while waiting for <code>::uses_read</code> to catch up, they'd still need to use <code>.compat()</code> adapters.</p>\n</li>\n<li>\n<p>The blanket impl provides a <em>silent</em> suboptimal implementation of <code>ReadIntoReadBuf</code>, whereas the noisy <code>.compat()</code> would just be featuring a true no-op compatibility layer for a suboptimal consumer.</p>\n</li>\n</ul>\n<hr>\n<p>Among these two declinations, I think I personally would lean towards <code>1.1</code></p>\n<p>General takeway of <code>1.</code>: requires a new trait (and thus a new name!), and would lead to sometimes requiring major version bumps and/or <code>.compat()</code> wrappers. On top of a deprecated trait lying around.</p>\n<h3>2. Add a new <code>read_buf()</code> method to <code>Read</code>, with a default dummy impl</h3>\n<ul>\n<li>The default \"dummy\" (zero-filling) impl is needed for retro-compat / to be able to make the method be a default one;</li>\n<li>This is the approach suggested by the RFC</li>\n</ul>\n<p>Pros:</p>\n<ul>\n<li>No new trait</li>\n<li>Everybody is compatible with everybody, any of <code>::uses_read</code> or <code>::provides_read</code> can improve their stuff on their own end, without breaking the other side (it will just lead to a situation where the improved implementation won't be used, as it happened with <code>.compat()</code> which made that explicit, but at the cost of requiring it / of otherwise breaking code). Once both ends provide their improved implementations, <code>::user</code> suddenly benefits from a performance boost, and all happening within \"transparent\" minor bumps.</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>People explicitly overriding <code>read_buf</code> (on top of potentially forgetting to do so!) would still be required to provide an explicit body for <code>fn read()</code>, since it's a mandatory method. Not that big of a deal, but it does leave an after-taste of not-totally-polished design that doesn't suit stdlib-quality APIs.</li>\n</ul>\n<p>I personally have to admit that this doesn't look as bad as <code>1.</code>'s transitioning phase, even if long-term it would be worse <strong>if no palliative measures were applied</strong>. Good news is, we could always provide such measures in the interim to still have a nice mid-to-long-term situation <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<h3>2.1. Palliative measures (potentially requiring new features and/or new lints) for the <code>fn read(â€¦)â€¦; fn read_buf(â€¦) â€¦ { â€¦ }</code></h3>\n<p>Key idea: <strong>make <code>fn read (â€¦) { â€¦ }</code> default as well by delegating to <code>read_buf</code>. But</strong> since <code>read_buf()</code>'s default impl already delegates to <code>read(â€¦)</code>, <strong>people could \"miswrite\" an <code>impl Read</code> and \"forget\" to write any methods, <em>with the compiler not saying anything</em>, and leading to infinite recursions at runtime</strong></p>\n<p>Solution: make the compiler \"say a thing\" when that happens. A basic implementation would be to make <code>Read</code> be a <code>#[lang]</code> item, and hardcode / special-case that impl.</p>\n<p>A nicer way would be to provide a more general tool for this pattern, which technically applies to other traits as well (<em>e.g.</em>, <code>PartialEq::{eq, ne}</code>):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#![requires(fn read_buf)]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">read_buf</span><span class=\"p\">(</span><span class=\"n\">ReadBuf</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">()</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">filled</span><span class=\"p\">().</span><span class=\"n\">len</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">read_buf</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">buf</span>: <span class=\"nc\">ReadBuf</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#![requires(fn read)]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">initialize_unfilled</span><span class=\"p\">()).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">n</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">add_filled</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Read</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyThing</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would cause:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"go\">Error: cycle detected when resolving the default implementations requirements.</span>\n<span class=\"go\">info = `fn read_buf` requires `fn read`, which requires `fn read_buf`, completing the cycle.</span>\n<span class=\"go\">note = you may need to provide an explicit implementation of one of these methods</span>\n</code></pre></div>\n<p>A hacky way would be to make the <code>infinite_recursion</code> smart enough to detect this problem and lint against it; although the error message wouldn't look great</p>\n</div></div>",
        "id": 264451590,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639145194
    },
    {
        "content": "<p>(off topic but how did you do this zulip magic?)</p>",
        "id": 264457788,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1639148098
    },
    {
        "content": "<p>(<a href=\"https://zulip.com/help/format-your-message-using-markdown#spoilers\">https://zulip.com/help/format-your-message-using-markdown#spoilers</a>)</p>",
        "id": 264464646,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639150909
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264439653\">said</a>:</p>\n<blockquote>\n<p>And you could make it decently ergonomic with a little bit of compiler work to support e.g. a lint for \"override exactly 1 of read and read_buf\"</p>\n</blockquote>\n<p>There are <em>so</em> many places where this would be handy.  Here's a relevant old IRLO thread: <a href=\"https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm\">https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm</a></p>",
        "id": 264500296,
        "sender_full_name": "scottmcm",
        "timestamp": 1639166446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264443813\">said</a>:</p>\n<blockquote>\n<p>Do you mean that you want libs to be able to use a <code>Read</code> impl where there is only an implementation of read_buf, and use the default impl of read? Or that you want such libraries to be able to get the perf benefits of using a ReadBuf? (I don't understand how the latter is posible)</p>\n</blockquote>\n<p>I want a library that has a function that looks like <code>pub fn do_a_thing&lt;R&gt;(reader: &amp;mut R) where R: Read</code> to be able to start using the read_buf interface internally without changing the function signature.</p>",
        "id": 264513431,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1639173059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264500296\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/219381-t-libs/topic/Possible.20variation.20of.20RFC.202930.20.28ReadBuf.29/near/264439653\">said</a>:</p>\n<blockquote>\n<p>And you could make it decently ergonomic with a little bit of compiler work to support e.g. a lint for \"override exactly 1 of read and read_buf\"</p>\n</blockquote>\n<p>There are <em>so</em> many places where this would be handy.  Here's a relevant old IRLO thread: <a href=\"https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm\">https://internals.rust-lang.org/t/brainstorming-allowing-implementing-just-try-fold-and-getting-next-free/9417?u=scottmcm</a></p>\n</blockquote>\n<p>Are there any ideas how hard could it be? Since this feature is wanted anyway, maybe we can \"just\" implement it? :D</p>",
        "id": 264586691,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1639259223
    },
    {
        "content": "<p>I think the hardest part is deciding how to expose it.</p>\n<p>If you wanted to start with a <code>#[rustc_must_implement_one_of(read, read_buf)]</code> attribute on the trait and worry about how to expose it publicly later, it might not be that bad.  Track that on the trait metadata, then update the part that checks whether you implemented all the required trait to look at that too?  But I've never done a change like that before, so you'd probably want to check with <a class=\"stream\" data-stream-id=\"182449\" href=\"/#narrow/stream/182449-t-compiler.2Fhelp\">#t-compiler/help</a> for whether there's something obvious I'm missing there.</p>\n<p>And it'd still be useful even if it's only usable in the standard library for a while, since outside the standard library one can make a major version bump if needed.</p>",
        "id": 264592100,
        "sender_full_name": "scottmcm",
        "timestamp": 1639266206
    },
    {
        "content": "<p>Hey! My PR with <code>#[rustc_must_implement_one_of]</code> is finally <a href=\"https://github.com/rust-lang/rust/pull/92164#event-5907607104\">merged</a>!</p>\n<p>There is a lot to be desired for the general feature of overriding minimal complete definition, but it's the start =)</p>",
        "id": 268362562,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1642497239
    },
    {
        "content": "<p>Nice job!  I flipped through the tests and it's already looking great.</p>",
        "id": 268426997,
        "sender_full_name": "scottmcm",
        "timestamp": 1642526849
    },
    {
        "content": "<p>Hrm, we'll probably need a way to do this unstably, no? E.g. if we wanted to change the <code>Iterator</code> interface to require either <code>next()</code> or <code>try_fold()</code> as someone suggested then offering the option to only implement the latter shouldn't be insta-stable.</p>",
        "id": 268429084,
        "sender_full_name": "The 8472",
        "timestamp": 1642527717
    },
    {
        "content": "<p>It works for <code>read_buf</code> because that itself is unstable.</p>",
        "id": 268429241,
        "sender_full_name": "The 8472",
        "timestamp": 1642527775
    },
    {
        "content": "<p>Yeah, figuring out a road to experimentation makes sense as a next step.  Using it with anything stable will probably need rustdoc and such to handle it too.</p>\n<p>That said, new trait <code>impl</code>s get directly FCP'd to stable today.  So it's not impossible that this could just be directly FCP'd on stable traits too.  (Though obviously having the opportunity to gate something is always nicer.)</p>",
        "id": 268445080,
        "sender_full_name": "scottmcm",
        "timestamp": 1642535003
    },
    {
        "content": "<p>For a simple A or B choice that might be ok, but if it gets more complex where you have multiple default implementations depending on which methods are available then imo it becomes too unwieldy to insta-stabilize</p>",
        "id": 268446370,
        "sender_full_name": "The 8472",
        "timestamp": 1642535635
    },
    {
        "content": "<p>Maybe we can have a <code>#[rustc_unstable_default_impl]</code> attribute that marks default body of functions as unstable?</p>",
        "id": 268447436,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1642536062
    },
    {
        "content": "<p>Actually, I think this should be pretty easy to implement <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 268469926,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1642547546
    }
]