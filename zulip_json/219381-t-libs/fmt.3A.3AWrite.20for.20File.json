[
    {
        "content": "<p>Why doesn't File implement fmt::Write? I want my code to accept both files and strings (through <code>&lt;W: fmt::Write&gt;(mut w: W)</code>) but File doesn't implement fmt::Write.</p>\n<p>And I can't switch to io::Write because then it wouldn't work for strings (and I'm only dealing with Unicode anyway).</p>\n<p><em>Original thread, with replies, is <a href=\"#narrow/stream/122651-general/topic/fmt.3A.3AWrite.20for.20File\">here</a>. Someone suggested I post here as well since it's relevant to the libs team.</em></p>",
        "id": 275703082,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647540400
    },
    {
        "content": "<p>As brought up at <a href=\"#narrow/stream/122651-general/topic/fmt.3A.3AWrite.20for.20File/near/275327123\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/fmt.3A.3AWrite.20for.20File/near/275327123</a> doing so would result in ambiguity errors.</p>",
        "id": 275704007,
        "sender_full_name": "bjorn3",
        "timestamp": 1647540835
    },
    {
        "content": "<p>There's no fundamental reason we couldn't add it, but doing so would introduce a lot of inference breakage in any code that has both traits imported and uses <code>write!</code> or <code>writeln!</code> with files.</p>",
        "id": 275704018,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647540841
    },
    {
        "content": "<p><code>write!(file, \"{}\", foo)</code> wouldn't know if it should call <code>fmt::Write::write_fmt</code> or <code>io::Write::write_fmt</code>.</p>",
        "id": 275704094,
        "sender_full_name": "bjorn3",
        "timestamp": 1647540861
    },
    {
        "content": "<p>but doesn't the macro just call write_fmt and then rely on what traits are in scope? So as josh said, it's only a problem when both versions of Write are in scope. Which is certainly possible, but rare. And it is an allowed breakage.</p>",
        "id": 275708712,
        "sender_full_name": "Lokathor",
        "timestamp": 1647543028
    },
    {
        "content": "<p>It's allowed, but many times we don't make changes that would cause even allowed breakage if we feel the breakage is too widespread.</p>",
        "id": 275709315,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647543313
    },
    {
        "content": "<p>And it's not that uncommon to have both traits imported, if you're working with multiple types of objects.</p>",
        "id": 275709346,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647543327
    },
    {
        "content": "<p>I feel like I've run into this issue a few times before too, and it seems unfortunate to not have a simple, intuitive, and ergonomic solution since it is likely to stymie users from executing the design they want. Is there any way the ambiguity issue can be solved or would a new language feature (some kind of annotation that would say to prefer one trait over another when both are implemented?) be required?</p>",
        "id": 275713103,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647545103
    },
    {
        "content": "<p>2nd on my \"write an RFC list\" is something like <a href=\"https://internals.rust-lang.org/t/idea-paths-in-method-names/6834?u=scottmcm\">https://internals.rust-lang.org/t/idea-paths-in-method-names/6834?u=scottmcm</a> to handle that -- especially with supertrait shadowing accepted, and <a href=\"https://github.com/rust-lang/rfcs/pull/3240\">https://github.com/rust-lang/rfcs/pull/3240</a> now under consideration</p>\n<p>But that wouldn't solve the macros, of course.</p>\n<p>Is there a <code>.as_utf8()</code> adapter for <code>io::Write</code> to give a temporary <code>fmt::Write</code> or something?</p>",
        "id": 275715980,
        "sender_full_name": "scottmcm",
        "timestamp": 1647546553
    },
    {
        "content": "<p>adding <code>as_fmt_writer</code> does seem the simplest way</p>",
        "id": 275717569,
        "sender_full_name": "Lokathor",
        "timestamp": 1647547264
    },
    {
        "content": "<p>Would that be a provided trait method or something else?</p>",
        "id": 275717734,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547333
    },
    {
        "content": "<p>Entertaining a completely different direction for a moment: we could also implement <code>io::Write</code> for String.</p>",
        "id": 275717797,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647547369
    },
    {
        "content": "<p>That seems like an interesting idea, at least as a solution until we have something more general. <em>EDIT: This message was in response to the <code>as_utf8</code>/<code>as_fmt_writer</code> comments.</em></p>",
        "id": 275717815,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547375
    },
    {
        "content": "<p>And return <code>io::Error</code> on non-UTF-8.</p>",
        "id": 275717817,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647547377
    },
    {
        "content": "<p>It wouldn't be the first output device to return an error on invalid Unicode; the Windows console does as well.</p>",
        "id": 275717897,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647547409
    },
    {
        "content": "<p>Hmm seems interesting. Although it perhaps doesn't solve the more general problem since there are other implementors of <code>fmt::Write</code></p>",
        "id": 275717902,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547411
    },
    {
        "content": "<p>True, but it solves the \"write to String or File\" problem.</p>",
        "id": 275717948,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647547434
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307537\">@Noah Lev</span> As an aside, in the short term, would your particular use case be solved by using <code>Vec&lt;u8&gt;</code> in place of <code>String</code> (possibly with the help of the bstr crate to make it easier to work with)?</p>",
        "id": 275718060,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647547470
    },
    {
        "content": "<p>It still seems a little fishy to use something named <code>io::Write</code> with a <code>String</code>, but it might be worth it</p>",
        "id": 275718068,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/fmt.3A.3AWrite.20for.20File/near/275718060\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"307537\">Noah Lev</span> As an aside, in the short term, would your particular use case be solved by using <code>Vec&lt;u8&gt;</code> (possibly with the help of the bstr crate to make it easier to work with)?</p>\n</blockquote>\n<p>Hmm... perhaps. FWIW, this is my use case: <a href=\"https://github.com/GuillaumeGomez/minifier-rs/pull/86\">https://github.com/GuillaumeGomez/minifier-rs/pull/86</a></p>",
        "id": 275718140,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547504
    },
    {
        "content": "<p>I want <code>Minified</code> to be able to write to <code>io::Write</code> and work with <code>to_string</code> (or <code>format!</code> in general)</p>",
        "id": 275718184,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547533
    },
    {
        "content": "<p>So perhaps I could write to <code>Vec&lt;u8&gt;</code> and then do <code>String::from_utf8(...).unwrap_or(std::fmt::Error)</code></p>",
        "id": 275718278,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547575
    },
    {
        "content": "<p>I'm surprised that there's a desire for avoiding just having minify return String -- it seems like in practice it's a simpler API and you're probably almost always directly writing the whole thing anyway?</p>",
        "id": 275718672,
        "sender_full_name": "simulacrum",
        "timestamp": 1647547764
    },
    {
        "content": "<p>The issue is that it wastes memory since a ton of small strings are concatenated together and then immediately written out</p>",
        "id": 275718723,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547790
    },
    {
        "content": "<p>I also want to make the API more lazy in general and this is a start</p>",
        "id": 275718738,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547798
    },
    {
        "content": "<p>I don't understand how this helps with that, to be honest</p>",
        "id": 275718860,
        "sender_full_name": "simulacrum",
        "timestamp": 1647547839
    },
    {
        "content": "<p>Are you minifying many-megabyte files or something?</p>",
        "id": 275718891,
        "sender_full_name": "simulacrum",
        "timestamp": 1647547853
    },
    {
        "content": "<p>Can you elaborate?</p>",
        "id": 275718892,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547854
    },
    {
        "content": "<p>I don't know for sure that it'll improve performance but I would like to test it.</p>",
        "id": 275718955,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547883
    },
    {
        "content": "<p>I profiled rustdoc on an empty crate with no_core just to see what came up and minification dominated by far. So I imagine improving it would have some effect, even if it's relatively small, on more complex runs.</p>",
        "id": 275719137,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647547954
    },
    {
        "content": "<p>But writing to a String is <em>by far</em> faster than almost anything else you can do, right?</p>",
        "id": 275719215,
        "sender_full_name": "simulacrum",
        "timestamp": 1647547990
    },
    {
        "content": "<p>(Certainly faster than file i/o, if you're exceeding in-memory page caching in the OS)</p>",
        "id": 275719259,
        "sender_full_name": "simulacrum",
        "timestamp": 1647548017
    },
    {
        "content": "<p>Well, currently the minifier generates a big Vec of tokens that it then concatenates into a string and writes to a file</p>",
        "id": 275719273,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548024
    },
    {
        "content": "<p>So I was hoping to skip the intermediate step</p>",
        "id": 275719291,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548033
    },
    {
        "content": "<p>And then eventually get rid of the intermediate token vec</p>",
        "id": 275719323,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548043
    },
    {
        "content": "<p>FWIW, rustdoc minifies 232 KB of CSS and JS every run. So not super big but not small either</p>",
        "id": 275719425,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548089
    },
    {
        "content": "<p>Perhaps the ideal solution would be to minify them at compile-time – although I guess that might break some debugging that people do so might not be possible</p>",
        "id": 275719528,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548138
    },
    {
        "content": "<p>That token vec is going to consume (likely) much more memory than the string representation of it, for sure</p>",
        "id": 275719592,
        "sender_full_name": "simulacrum",
        "timestamp": 1647548161
    },
    {
        "content": "<p>All right, so maybe I'll try to incrementalize the token vec instead. It seemed like it might be low-hanging fruit to get rid of the intermediate string</p>",
        "id": 275719712,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548203
    },
    {
        "content": "<p>io::Write on String seems \"obvious enough\" for me. There's nearly no reason at all for fmt Write and io Write to be separate traits to begin with.</p>",
        "id": 275719753,
        "sender_full_name": "Lokathor",
        "timestamp": 1647548226
    },
    {
        "content": "<p>io::Write on String seems \"ok\", though is probably a backwards compat hazard so I'm not sure we could pull it off.</p>",
        "id": 275719781,
        "sender_full_name": "simulacrum",
        "timestamp": 1647548243
    },
    {
        "content": "<p>Yeah, wouldn't io::Write on String have the same backcompat issues as fmt::Write on File?</p>",
        "id": 275719834,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Noah Lev</span> <a href=\"#narrow/stream/219381-t-libs/topic/fmt.3A.3AWrite.20for.20File/near/275719712\">said</a>:</p>\n<blockquote>\n<p>All right, so maybe I'll try to incrementalize the token vec instead. It seemed like it might be low-hanging fruit to get rid of the intermediate string</p>\n</blockquote>\n<p>I would try benchmarking the tokenization -- my guess is that the intermediate String is incredibly cheap -- a memcpy of a couple hundred kilobytes is basically what you're saving here, and memcpy is really quite fast.</p>",
        "id": 275719949,
        "sender_full_name": "simulacrum",
        "timestamp": 1647548311
    },
    {
        "content": "<p>Thanks, I'll try that</p>",
        "id": 275720222,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/219381-t-libs/topic/fmt.3A.3AWrite.20for.20File/near/275719781\">said</a>:</p>\n<blockquote>\n<p>io::Write on String seems \"ok\", though is probably a backwards compat hazard so I'm not sure we could pull it off.</p>\n</blockquote>\n<p>It'd have the same backwards compatibility hazard, but it <em>might</em> have less actual breakage. Worth testing with a crater run.</p>",
        "id": 275720973,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647548809
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> The other downside of preparing the whole string and then writing it out is that you start the write later, rather than pipelining the operation with the I/O.</p>",
        "id": 275721053,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647548855
    },
    {
        "content": "<p>In theory, yes, though for anything less than a few megabytes I would expect the whole write to just land in kernel buffers and be written in the background anyway, right?</p>",
        "id": 275721158,
        "sender_full_name": "simulacrum",
        "timestamp": 1647548897
    },
    {
        "content": "<p>Would that apply to non-Linux kernels too?</p>",
        "id": 275721198,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647548920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> That's not what I mean. Suppose it takes 100ms to do the minification, and 100ms to write to disk. If you write to a string first the whole thing takes 200ms. If you start writing to disk right away, it takes 100ms plus however long it takes to <em>start</em> producing minified output.</p>",
        "id": 275722022,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647549256
    },
    {
        "content": "<p>Is the write to disk actually something you need to wait for (even before process end)?</p>",
        "id": 275722384,
        "sender_full_name": "simulacrum",
        "timestamp": 1647549431
    },
    {
        "content": "<p>But yes, you're not wrong that buffering in memory will theoretically could slow you down</p>",
        "id": 275722585,
        "sender_full_name": "simulacrum",
        "timestamp": 1647549535
    },
    {
        "content": "<p>but I would expect the many small writes (that you say would pipeline) are in practice going to be just as slow -- or slower -- if done in small bits due to more syscalls, etc. so it's not an obvious win to do that interleaving</p>",
        "id": 275722642,
        "sender_full_name": "simulacrum",
        "timestamp": 1647549573
    },
    {
        "content": "<p>I definitely wouldn't write bytes or short strings at a time, yeah; I was thinking a buffered writer that wrote kilobytes at a time, at minimum.</p>",
        "id": 275728159,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647551716
    },
    {
        "content": "<p>Naively wrapper the inner writer with BufWriter would help significantly</p>",
        "id": 275731035,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647553002
    },
    {
        "content": "<p>Are <code>File</code>s not automatically buffered? Or are the buffers just small?</p>",
        "id": 275744932,
        "sender_full_name": "Noah Lev",
        "timestamp": 1647561925
    },
    {
        "content": "<p>There are no buffers in Rust with File, so each write is its own syscall.</p>",
        "id": 275745012,
        "sender_full_name": "simulacrum",
        "timestamp": 1647562005
    },
    {
        "content": "<p>and then the kernel will do its own buffering, independent of the process</p>",
        "id": 275749900,
        "sender_full_name": "cuviper",
        "timestamp": 1647566690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/fmt.3A.3AWrite.20for.20File/near/275717797\">said</a>:</p>\n<blockquote>\n<p>Entertaining a completely different direction for a moment: we could also implement <code>io::Write</code> for String.</p>\n</blockquote>\n<p>It feels like implementing <code>io::Write</code> for <code>String</code> breaks the mental abstraction of an <code>io</code> module, since it isn't really an IO device.</p>",
        "id": 275815381,
        "sender_full_name": "lovelymono",
        "timestamp": 1647616152
    },
    {
        "content": "<p>well fmt write outputs str, and io write outputs [u8], which is less restricted than str. So if either File or String are going to implement the \"other\" trait then File should support fmt write because any str can be viewed as [u8]</p>",
        "id": 275819810,
        "sender_full_name": "Lokathor",
        "timestamp": 1647617927
    },
    {
        "content": "<p>But really we should just put a generic adapter for all io write types so that they can be viewed as a fmt writers</p>",
        "id": 275820125,
        "sender_full_name": "Lokathor",
        "timestamp": 1647618086
    },
    {
        "content": "<p>Isn't \"io to memory buffer\" a pretty standard concept? C++ has <code>stringstream</code>, Java has <code>ArrayOutputStream</code> (byte-oriented) / <code>StringWriter</code> (utf-16) and so on</p>",
        "id": 275846832,
        "sender_full_name": "Johannes Dahlström",
        "timestamp": 1647629429
    },
    {
        "content": "<p>(Granted in <code>stringstream</code>'s case it's because C++ couples i/o and formatting which Rust (and Java) doesn't do)</p>",
        "id": 275847379,
        "sender_full_name": "Johannes Dahlström",
        "timestamp": 1647629707
    },
    {
        "content": "<p><code>io::Write</code> does work in memory with <code>Vec&lt;u8&gt;</code>, just not <code>String</code> because that has to be utf-8</p>",
        "id": 275847890,
        "sender_full_name": "cuviper",
        "timestamp": 1647629970
    },
    {
        "content": "<p>Oh, right. So <code>fmt::Write</code> is <em>sort</em> of like Java's <code>Writer</code>, except that in Java it works such that you wrap an <code>OutputStream</code> (byte i/o) in a <code>Writer</code> to get string/formatted i/o… which in turn is similar to the idea in this discussion of a wrapper adapting <code>io::Write</code> to <code>fmt::Write</code>. Which IMHO makes a lot of sense to have in any case.</p>",
        "id": 275852416,
        "sender_full_name": "Johannes Dahlström",
        "timestamp": 1647632133
    },
    {
        "content": "<p>(Just like in Rust, in Java you can't do byte i/o into a String because of the UTF invariant.)</p>",
        "id": 275852697,
        "sender_full_name": "Johannes Dahlström",
        "timestamp": 1647632265
    }
]