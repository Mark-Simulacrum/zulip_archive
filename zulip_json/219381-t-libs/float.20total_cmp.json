[
    {
        "content": "<p>Following up from <a href=\"https://github.com/rust-lang/rust/issues/72599\">https://github.com/rust-lang/rust/issues/72599</a> , once total_cmp is stabilized, would there be any objections to adding a <code>sort_float</code> method on <code>Vec&lt;f32&gt;</code> and <code>Vec&lt;f64&gt;</code>, which just calls <code>sort_by</code>? That would help people doing floating-point operations on Rust to know what they should use.</p>",
        "id": 269486851,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643233327
    },
    {
        "content": "<p>(if we'll add <code>sort_float</code> we should probably add it to <code>[f32]</code> and not <code>Vec&lt;f32&gt;</code>)</p>",
        "id": 269487431,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1643233655
    },
    {
        "content": "<p>It should be on <code>&amp;mut [f]</code>, but that sounds good to me.</p>",
        "id": 269487438,
        "sender_full_name": "cuviper",
        "timestamp": 1643233659
    },
    {
        "content": "<p>sort_unstable_by, presumably?</p>\n<p>It feels rather unfortunate to add a new method -- particularly one that will not get well-sorted in rustdoc or easily discoverable (since the name isn't sort_f32, searching for f32 wouldn't help you...)</p>\n<p>It might make sense to add a rustc_on_unimplemented attribute  on Ord  for floats that suggests total_cmp, and some custom code that gives you the one-line snippet for sort_by with total_cmp as the argument (on <code>[f32].sort()</code> in particular), maybe.</p>",
        "id": 269487523,
        "sender_full_name": "simulacrum",
        "timestamp": 1643233688
    },
    {
        "content": "<p>It could be called <code>sort_f32</code> / <code>sort_f64</code></p>",
        "id": 269487651,
        "sender_full_name": "cuviper",
        "timestamp": 1643233770
    },
    {
        "content": "<p>Using <code>sort_unstable_by</code> also means it can go in <code>core</code></p>",
        "id": 269487850,
        "sender_full_name": "cuviper",
        "timestamp": 1643233864
    },
    {
        "content": "<p>Does <code>total_cmp</code> even provide order for different bit patterns of NaN?</p>",
        "id": 269488100,
        "sender_full_name": "cuviper",
        "timestamp": 1643233996
    },
    {
        "content": "<p>Inner comments say yes, it follows bitwise order.</p>",
        "id": 269488296,
        "sender_full_name": "cuviper",
        "timestamp": 1643234084
    },
    {
        "content": "<p>Also, quote from the documentation:</p>\n<blockquote>\n<p>The values are ordered in following order:</p>\n<ul>\n<li>Negative quiet NaN</li>\n<li>Negative signaling NaN</li>\n<li>Negative infinity</li>\n<li>Negative numbers</li>\n<li>Negative subnormal numbers</li>\n<li>Negative zero</li>\n<li>Positive zero</li>\n<li>Positive subnormal numbers</li>\n<li>Positive numbers</li>\n<li>Positive infinity</li>\n<li>Positive signaling NaN</li>\n<li>Positive quiet NaN</li>\n</ul>\n</blockquote>",
        "id": 269488417,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1643234144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269487651\">said</a>:</p>\n<blockquote>\n<p>It could be called <code>sort_f32</code> / <code>sort_f64</code></p>\n</blockquote>\n<p>It'd be on a type that contains an <code>f32</code> or <code>f64</code>, and there's lots of precedent for having the same methods on different numeric types.</p>",
        "id": 269488589,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643234210
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269487523\">said</a>:</p>\n<blockquote>\n<p>sort_unstable_by, presumably?</p>\n</blockquote>\n<p>Right, yes.</p>",
        "id": 269488686,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643234259
    },
    {
        "content": "<p>I thought that and then didn't end up typing it. :)</p>",
        "id": 269488700,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643234265
    },
    {
        "content": "<p><code>sort_total</code>?</p>",
        "id": 269488782,
        "sender_full_name": "cuviper",
        "timestamp": 1643234287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> That seems less discoverable.</p>",
        "id": 269488839,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643234318
    },
    {
        "content": "<p>Part of the notion here was \"I have a collection that has a sort method, but I can't sort floats...oooh, there's a method named \"sort_float\", that's what I want.\"</p>",
        "id": 269488868,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643234339
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"273349\">@Waffle Lapkin</span> there are more bit patterns of NaN than simply +/- quiet/signaling</p>",
        "id": 269488943,
        "sender_full_name": "cuviper",
        "timestamp": 1643234384
    },
    {
        "content": "<p>That's fine, just offering shed colors</p>",
        "id": 269489078,
        "sender_full_name": "cuviper",
        "timestamp": 1643234421
    },
    {
        "content": "<p>The other thing that would make this easier to use would be to make <code>.sort_by_key(|x| (x.some_float.total_cmp_key(), x.other_thing))</code> work -- that's much less annoying to actually use than <code>sort_by</code>, in basically every case I've hit.  But deciding a return type for that is harder than defining <code>total_cmp</code> was.</p>\n<p>Arguably it could just be called <code>.sort_unstable()</code>, the same way that there's <code>min</code> on <code>f32</code> different from <code>Ord::min</code>.</p>\n<p>I do like simulacrum's suggestion of a diagnostic, though.  It could mention <code>.sort_unstable_by(f32::total_cmp)</code> but also the possibility of <code>.sort_unstable_by(|a, b| PartialCmp::partial_cmp(a, b).unwrap())</code>.</p>",
        "id": 269491605,
        "sender_full_name": "scottmcm",
        "timestamp": 1643235554
    },
    {
        "content": "<p>why not just have <code>f32::total_cmp_key()</code> return <code>i32</code> and <code>f64::total_cmp_key()</code> return <code>i64</code>? that's basically what <code>total_cmp</code> does internally anyway</p>",
        "id": 269494176,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643237067
    },
    {
        "content": "<p>Yeah, there are also a lot of uses for the operation that total_cmp performs internally — that is to say, ideally total_cmp_key would return u64/u32 (depending on the float type), rather than a wrapper.</p>\n<p>EDIT: didn't see Jacobs post. i32/i64 is fine too.</p>",
        "id": 269495567,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643237906
    },
    {
        "content": "<p>is there a function for the equivalent of <code>reinterpret_cast&lt;u64&gt;(x: f64)</code>? <code>x as u64</code> does float conversion so it's not ideal here</p>",
        "id": 269495898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643238030
    },
    {
        "content": "<p><code>to_bits</code>, but it's not equivalent to the total key</p>",
        "id": 269495976,
        "sender_full_name": "cuviper",
        "timestamp": 1643238065
    },
    {
        "content": "<p>I guess <code>total_cmp_key</code> is just a bit more complicated than that because it has to swap positive and negative IIRC</p>",
        "id": 269495997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643238080
    },
    {
        "content": "<p>there's a big explanation of what it does: <a href=\"https://doc.rust-lang.org/src/core/num/f32.rs.html#1053\">https://doc.rust-lang.org/src/core/num/f32.rs.html#1053</a></p>",
        "id": 269496049,
        "sender_full_name": "cuviper",
        "timestamp": 1643238116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269494176\">said</a>:</p>\n<blockquote>\n<p>that's basically what <code>total_cmp</code> does internally anyway</p>\n</blockquote>\n<p>Yeah, but it's not obvious to me that that fact makes sense to expose -- <code>x.total_cmp_key() &gt; 4</code> compiling is non-great.  It could potentially just be <code>-&gt; impl Ord + Copy</code>, for example.  (And if we had TAIT that might be enough.)  But then there's a bunch of other questions about that like whether it should have had <code>Hash</code> and <code>Debug</code> and ...</p>",
        "id": 269497172,
        "sender_full_name": "scottmcm",
        "timestamp": 1643238741
    },
    {
        "content": "<p>I've wanted this when performing non-comparison based sort (for example, radix/bucket sort). It's not too much work to implement manually, but it also is already implemented in the standard library, and it's unclear that the abstraction barrier here is actually very useful.</p>",
        "id": 269497390,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643238852
    },
    {
        "content": "<p>That said a wrapper that can be converted into the integer type with From/Into would be acceptable for this too.</p>",
        "id": 269497898,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643239143
    },
    {
        "content": "<p>This sounds like a really good convenience method to have! (and worth having over the sort_by  desugaring for beginners, readability, and because it is a common thing to do) My 2c on naming is that since total_cmp is specific to floats (i.e., is an inherent method, not a trait one) that sort_float is the right name (rather than sort_total) and _float is better than _f32/_f64 because it is more flexible and readible and consistent with other naming of numeric functions.</p>",
        "id": 269544030,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643275218
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/93397\">https://github.com/rust-lang/rust/pull/93397</a></p>",
        "id": 269657917,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643326607
    },
    {
        "content": "<p>Tracking issue at <a href=\"https://github.com/rust-lang/rust/issues/93396\">https://github.com/rust-lang/rust/issues/93396</a></p>",
        "id": 269657929,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643326615
    },
    {
        "content": "<blockquote>\n<p>This sounds like a really good convenience method to have! (and worth having over the sort_by  desugaring for beginners, readability, and because it is a common thing to do) My 2c on naming is that since total_cmp is specific to floats (i.e., is an inherent method, not a trait one) that sort_float is the right name (rather than sort_total) and _float is better than _f32/_f64 because it is more flexible and readible and consistent with other naming of numeric functions.</p>\n</blockquote>\n<p>I would say that <code>_float</code> in <code>sort_float</code> is superfluous piece of information given that the type is already float. Also, what if there comes up other sensible and convincing ways to order floats in a ways other than by <code>totalOrder</code>?</p>",
        "id": 269665951,
        "sender_full_name": "nagisa",
        "timestamp": 1643331312
    },
    {
        "content": "<p>In that case <code>sort_float</code> would seem like insufficiently precise, to me at least.</p>",
        "id": 269665971,
        "sender_full_name": "nagisa",
        "timestamp": 1643331341
    },
    {
        "content": "<p>there's definitely an argument that people might often prefer <code>.sort_unstable_by_key(|x| (x.is_nan(), x.total_cmp_key())</code> or something.</p>\n<p>Or, going further, it could be something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">sort_float</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">f32</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">f32</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">iter_mut</span><span class=\"p\">().</span><span class=\"n\">partition_in_place</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">is_nan</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"n\">i</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">sort_by</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">PartialOrd</span>::<span class=\"n\">partial_cmp</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">).</span><span class=\"n\">unwrap_unchecked</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>&lt;<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0c4e163e0fb051e1e489b57f5539a7fe\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=0c4e163e0fb051e1e489b57f5539a7fe</a>&gt;</p>",
        "id": 269667947,
        "sender_full_name": "scottmcm",
        "timestamp": 1643332595
    },
    {
        "content": "<p>A large segment of float users generally do not want NaNs to disappear. They may want to cast NaNs to one of 0.0, 1.0, or Infinity, possibly with a sign.</p>",
        "id": 269668766,
        "sender_full_name": "Jubilee",
        "timestamp": 1643333119
    },
    {
        "content": "<p>Note that if you ignore the returned slice then that <code>sort_float</code> sketch I put up <em>does</em> keep them.</p>",
        "id": 269677511,
        "sender_full_name": "scottmcm",
        "timestamp": 1643336235
    },
    {
        "content": "<p>I feel like this would be too... idiosyncratic for the stdlib?</p>",
        "id": 269684015,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643342756
    },
    {
        "content": "<p>Hmm, by the same reasoning, there are other total orderings of the floats which make sense, so I think sort_total or similar are also sub-optimal. Is there a way to describe the ordering which would label it definitively (like is it officially the Hoare-Djikstra-73 ordering, or something)?</p>",
        "id": 269706190,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643360980
    },
    {
        "content": "<p>it's officially the \"<code>totalOrder</code>\" predicate from ieee754 2019 (and probably 2008 — I don't have a copy on this machine and don't feel like looking).</p>\n<p>which doesn't particularly help, i know.</p>",
        "id": 269706529,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643361161
    },
    {
        "content": "<p>call the function <code>sort_ieee754</code>?</p>",
        "id": 269710083,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643363030
    },
    {
        "content": "<p>That's just a confusing mess of letters and numbers to the average user.</p>",
        "id": 269711355,
        "sender_full_name": "Amanieu",
        "timestamp": 1643363702
    },
    {
        "content": "<p>That doesn’t seem like a massive downside? It starts with sort_ which is the important thing and it is very specific</p>",
        "id": 269712024,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643364035
    },
    {
        "content": "<p>Put it another way, we’re describing a sort using an arbitrary ordering, so I’m not sure we can do better for a name than an arbitrary jumble of letters and numbers</p>",
        "id": 269712091,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643364078
    },
    {
        "content": "<p>(And for a lot of users who just want to sort some floats, talking about total orderings, etc is just as confusing a mess of letters)</p>",
        "id": 269712244,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643364155
    },
    {
        "content": "<p>The lowest-commitment form would be to just special-case a diagnostic.</p>\n<p>I wonder if this would work...</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[rustc_on_unimplemented(</span>\n<span class=\"cp\">    on(</span>\n<span class=\"cp\">        all(_Self=</span><span class=\"s\">\"f32\"</span><span class=\"cp\">, from_method=</span><span class=\"s\">\"sort_unstable\"</span><span class=\"cp\">),</span>\n<span class=\"cp\">        note = </span><span class=\"s\">\"consider using `.sort_unstable_by(f32::total_cmp)`\"</span><span class=\"cp\">,</span>\n<span class=\"cp\">    ),</span>\n<span class=\"cp\">    on(</span>\n<span class=\"cp\">        all(_Self=</span><span class=\"s\">\"f32\"</span><span class=\"cp\">, from_method=</span><span class=\"s\">\"sort\"</span><span class=\"cp\">),</span>\n<span class=\"cp\">        note = </span><span class=\"s\">\"consider using `.sort_by(f32::total_cmp)`\"</span><span class=\"cp\">,</span>\n<span class=\"cp\">    ),</span>\n<span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Ord</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269712568,
        "sender_full_name": "scottmcm",
        "timestamp": 1643364349
    },
    {
        "content": "<p>That seems not terrible, but also not great. This seems like the kind of simple operation that it is worth making really ergonomic even if it means papering over some details for the sake of making the beginner/casual user experience smoother</p>",
        "id": 269713020,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643364582
    },
    {
        "content": "<p>Yeah, its primary goodness is that it can go in and start helping immediately without fcp.</p>\n<p><code>f32::min</code> is precedent for just picking one and giving it the same name as the <code>Ord</code> version, FWIW.  To me the \"really ergonomic\" version is just letting <code>.sort_unstable()</code> and <code>.sort()</code> work, by defining a specific inherent method on <code>[f32]</code> and <code>[f64]</code>.  (And if we can't do that today, we could with <a href=\"https://github.com/rust-lang/negative-impls-initiative/issues/1\">https://github.com/rust-lang/negative-impls-initiative/issues/1</a> )</p>",
        "id": 269713748,
        "sender_full_name": "scottmcm",
        "timestamp": 1643364994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269713748\">said</a>:</p>\n<blockquote>\n<p><code>f32::min</code> is precedent for just picking one and giving it the same name as the <code>Ord</code> version, FWIW.  To me the \"really ergonomic\" version is just letting <code>.sort_unstable()</code> and <code>.sort()</code> work, by defining a specific inherent method on <code>[f32]</code> and <code>[f64]</code>.</p>\n</blockquote>\n<p>As long as we're clear that this kind of \"just works\" is only for concrete types, not possible for generic code on <code>[T]</code> -- but that's also true of <code>min</code></p>",
        "id": 269757805,
        "sender_full_name": "cuviper",
        "timestamp": 1643385546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269710083\">said</a>:</p>\n<blockquote>\n<p>call the function <code>sort_ieee754</code>?</p>\n</blockquote>\n<p>IEEE754 also defines other comparisons though — this is actually <em>more</em> vague, IMO.</p>",
        "id": 269764797,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643388460
    },
    {
        "content": "<p>I don't object to just calling it <code>sort</code>, as long as that doesn't require substantial compiler magic.</p>",
        "id": 269786828,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643396928
    },
    {
        "content": "<p>It'll probably require a bit of compiler magic no matter what we call it, because writing <code>impl [f32]</code> even in core needs a lang item.</p>",
        "id": 269787419,
        "sender_full_name": "scottmcm",
        "timestamp": 1643397180
    },
    {
        "content": "<p>I've already added that part. :)</p>",
        "id": 269788674,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643397775
    },
    {
        "content": "<p>I meant, <em>more</em> magic to handle having <code>sort</code> on both <code>[T] where T: Ord</code> and <code>[f32]</code>.</p>",
        "id": 269788709,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643397794
    },
    {
        "content": "<p>Hmm, trying <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a99d3d45844ae80909e8368411f99ea1\">something similar in playground</a> gives</p>\n<div class=\"codehilite\"><pre><span></span><code>note: upstream crates may add a new impl of trait `std::cmp::Ord` for type `f32` in future versions\n</code></pre></div>\n<p>so I think that implies it just needs <code>impl !Ord for f32</code> and already-in-the-works magic <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 269789683,
        "sender_full_name": "scottmcm",
        "timestamp": 1643398253
    },
    {
        "content": "<p>I'm going to go ahead and finish getting the implementation working as <code>sort_floats</code>, but I'd be happy to change that to <code>sort</code> if negative impls are available. I'm also happy to add a blocking item to the tracking issue to say that change needs to be made before stabilization, if negative impls aren't ready yet.</p>",
        "id": 269790687,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643398739
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Trying to use a negative impl resulted in:</p>\n<blockquote>\n<p>error[E0658]: negative trait bounds are not yet fully implemented; use marker types for now</p>\n</blockquote>",
        "id": 269791177,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643398950
    },
    {
        "content": "<p>Not sure what using marker types looks like.</p>",
        "id": 269791189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643398958
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116266\">@Santiago Pastorino</span></p>",
        "id": 269791197,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643398962
    },
    {
        "content": "<p>Odd that it would mention negative <em>bounds</em>, since we already have negative impls in <code>core</code> like &lt;<a href=\"https://doc.rust-lang.org/nightly/std/clone/trait.Clone.html#impl-Clone-126\">https://doc.rust-lang.org/nightly/std/clone/trait.Clone.html#impl-Clone-126</a>&gt;</p>",
        "id": 269791333,
        "sender_full_name": "scottmcm",
        "timestamp": 1643399036
    },
    {
        "content": "<p>But the coherence part of negative impls isn't done yet, afaik, so it might not work until that's done.</p>",
        "id": 269791431,
        "sender_full_name": "scottmcm",
        "timestamp": 1643399076
    },
    {
        "content": "<p>Then I'm going to try to avoid tying the two together, and just note in the tracking issue that we could change that.</p>",
        "id": 269792379,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643399507
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269789683\">said</a>:</p>\n<blockquote>\n<p>Hmm, trying <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a99d3d45844ae80909e8368411f99ea1\">something similar in playground</a> gives</p>\n<div class=\"codehilite\"><pre><span></span><code>note: upstream crates may add a new impl of trait `std::cmp::Ord` for type `f32` in future versions\n</code></pre></div>\n<p>so I think that implies it just needs <code>impl !Ord for f32</code> and already-in-the-works magic <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>that should fare better when done <em>in</em> <code>core</code>, as it is also the source of <code>Ord</code></p>",
        "id": 269796561,
        "sender_full_name": "cuviper",
        "timestamp": 1643401083
    },
    {
        "content": "<p>your example works with a local <code>MyOrd</code></p>",
        "id": 269796579,
        "sender_full_name": "cuviper",
        "timestamp": 1643401092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269791177\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> Trying to use a negative impl resulted in:</p>\n<blockquote>\n<p>error[E0658]: negative trait bounds are not yet fully implemented; use marker types for now</p>\n</blockquote>\n</blockquote>\n<p>I need to read what all this is about but I guess this error shows up because the feature gate is not enabled ?</p>",
        "id": 269797010,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1643401306
    },
    {
        "content": "<p>(don't need the negative bound when <code>Ord</code> is local though)</p>",
        "id": 269797119,
        "sender_full_name": "cuviper",
        "timestamp": 1643401350
    },
    {
        "content": "<p>would need to read the thread :)</p>",
        "id": 269797179,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1643401385
    },
    {
        "content": "<p>just saw the mention, saw the error and if you check the source code is doing <a href=\"https://github.com/rust-lang/rust/blob/427eba2f0bacdeaebc992a78eb2889564de7d7cf/compiler/rustc_ast_passes/src/feature_gate.rs#L434-L442\">https://github.com/rust-lang/rust/blob/427eba2f0bacdeaebc992a78eb2889564de7d7cf/compiler/rustc_ast_passes/src/feature_gate.rs#L434-L442</a></p>",
        "id": 269797335,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1643401452
    },
    {
        "content": "<p>hmm, but if <code>core</code> adds <code>fn sort</code> for floats, maybe that will make <code>alloc</code> fail on its <code>fn sort</code> for <code>T: Ord</code></p>",
        "id": 269798185,
        "sender_full_name": "cuviper",
        "timestamp": 1643401892
    },
    {
        "content": "<p>fwiw I tried that, and it built fine. I'm guessing <code>lang = \"slice_alloc\"</code> sidesteps that coherency</p>",
        "id": 269819762,
        "sender_full_name": "cuviper",
        "timestamp": 1643413797
    },
    {
        "content": "<p>How about adding a trait <code>SortOrd</code> for types that want to implement a sort-order that might be different from a <code>PartialOrd</code> implementation. Give it a default implementation based on <code>Ord</code>, and give <code>sort</code> function a <code>T: SortOrd</code> bound? Then (eventually, once stabilized) every downstream library defining float-like types that have a <code>PartialOrd</code>-but-not-<code>Ord</code> overloading of comparison operators will be able to have it supported by sorting functions, too. It also doesn't require negative implementation, and should be backwards compatible. Unless I'm missing something.</p>",
        "id": 269848655,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1643444264
    },
    {
        "content": "<p>Also, I guess <code>total_cmp</code> could just be a method of that trait then <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 269848747,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1643444382
    },
    {
        "content": "<p>That's not the split I usually want, though.  To me the one I really want is the \"I want to use BTreeMap but there isn't a meaningful order\" -- like I'd be happy for <code>Result</code> to <em>not</em> be <code>PartialOrd</code>, because I never want to write <code>&lt;</code> between results.</p>\n<p>But I think really the first thing we should have is <code>NonNanF32</code> &amp; <code>NonNanF64</code> that just work normally.  Because those can be <code>Ord</code> no problem, and will sort without issue.</p>\n<p>(And it would be relatively easy to compute in <code>f32</code>, then store <code>NonNanF32</code> at the end, or something)</p>",
        "id": 269852165,
        "sender_full_name": "scottmcm",
        "timestamp": 1643448647
    },
    {
        "content": "<p>For “*Map” types (i.e. <code>BTreeMap</code> or <code>HashMap</code>), I’m not sure whether NaN keys are a good idea. Do you want to differentiate different NaNs or not? And equality testing on floats is usually questionable anyways. Perhaps <code>BTreeMap</code> has some more/better use-cases since it also allows operations such as accessing all entries in a given range.</p>\n<p>Sorting, particularly unstable sorting, seems way less problematic than “*Map” types; things that are equal are sorted in an unpredictable order anyways, this generalizes neatly to: things that are <em>roughly</em> equal are sorted in a hard-to-predict order, based on rounding errors.</p>\n<p>I agree with the sentiment that it's a bit unfortunate that <code>Ord</code> implementations for the sake of using <code>BTreeMap</code> (or other ordering-based data structures) are coupled to <code>Ord</code> implementations for the sake of introducing/overloading the <code>&lt;</code>/<code>&gt;</code>/<code>&lt;=</code>/<code>&gt;=</code> operators, but I feel like that ship has sailed, since there’s already a lot of types that implement <code>Ord</code> and support comparison operators even though it’s not really necessary.</p>\n<hr>\n<p>My <em>main</em> point in my post above was anyways that using a trait with a glob implementation based on <code>Ord</code> should remove the need for using negative implementations in order to support re-using the same <code>.sort_unstable</code>/<code>.sort</code> method for slices of floats. Whether or not the trait is made stable / user-implementable any time soon is not even that relevant. If we get “inherent traits implementations” eventually, then <code>total_cmp</code> could even be neatly migrated from inherent methods to trait methods in the future without breakage. Instead of a <code>SortOrd[er]</code> trait, it could even be named more narrowly as something like <code>SliceSort</code>, similar to the <code>SliceIndex</code> trait, with the sole main purpose of being used for slice's <code>.sort*</code> methods.</p>",
        "id": 269859789,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1643457561
    },
    {
        "content": "<p>If you just want to put it in a BTreeMap then isn't basically any ordering fine? Like you could just newtype it to use the bit ordering? It's a pain of course for the newtype to be in there, but it'd work and be consistent and even be NaN friendly.</p>",
        "id": 269874546,
        "sender_full_name": "Lokathor",
        "timestamp": 1643474421
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  Using comparison of bit-patterns for NaN values in a map seems like a terrible idea, in light of issues such as the problems described in <a href=\"https://github.com/rust-lang/rust/issues/73328\">#73328</a>.</p>\n<p>While for sorting alone, as I explained above, this can still be reasonably explained along the lines of “well, the sorting is kind-of unstable around NaNs, so please don't rely on their particular relative order too much”, as soon as you start using NaNs as keys in a map, in my view the negative consequences are severe enough that such an approach should be strongly discouraged. Newtypes that treat all NaNs the same are in my view far better, as e.g. the newtypes provided by the popular <a href=\"https://crates.io/crates/ordered-float\">ordered-float</a> crate, which has one newtype <code>OrderedFloat</code> that classifies all NaNs as <code>Equal</code>, and another newtype <code>NotNan</code> that forbids NaN values entirely. Even then, using these as keys can be questionable, depending on how you’d like to obtain the keys you want to look up… certainly any kind of floating-point operation can lead to rounding-errors giving you unequal keys that “ought-to-be” equal.</p>",
        "id": 269875755,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1643475813
    },
    {
        "content": "<p>On second thought, even sorting is problematic because positive and negative NaNs are <strong><em>not</em></strong> grouped together, as long as the sign of NaNs you get from calculations is unspecified.</p>",
        "id": 269875973,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1643476020
    },
    {
        "content": "<p>hmm, that's a rough one, but now that you mention it I've hit this bug before myself</p>",
        "id": 269876243,
        "sender_full_name": "Lokathor",
        "timestamp": 1643476324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/269874546\">said</a>:</p>\n<blockquote>\n<p>If you just want to put it in a BTreeMap then isn't basically any ordering fine?</p>\n</blockquote>\n<p>It depends if you want to be able to use <code>BTreeMap::range</code> reasonably -- and that API (for things like next after queries) is one of the best reasons to use <code>BTreeMap</code>.</p>\n<p>...which I guess also contradicts my previous statement of just wanting \"something that works\" with it.  I suppose what I want (given a time machine) is something like Partial Ord on Result, so that the results from <code>range</code> would exclude anything incomparable to it (like <code>.range(Ok(3)..)</code> would not include any Errs and <code>.range(Err(3)..)</code> would not include any Oks).  But with some \"arbitrary tie breaker\" to split the categories, or something...</p>",
        "id": 269887923,
        "sender_full_name": "scottmcm",
        "timestamp": 1643489431
    },
    {
        "content": "<p>I updated <a href=\"https://github.com/rust-lang/rust/pull/93397\">https://github.com/rust-lang/rust/pull/93397</a> to call the method <code>sort</code>; let's see if this works without needing a negative impl.</p>",
        "id": 269956246,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643575536
    },
    {
        "content": "<p>...and it turns out that doesn't work without some additional steps, so I reverted back to <code>sort_floats</code>.</p>",
        "id": 269959062,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643578558
    },
    {
        "content": "<p>I don't think adding this is a good idea; doing so could make users be oblivious to NaNs. The total order as defined by IEEE 754 is not always what users want for sorting. Users could want to:</p>\n<ul>\n<li>Sort all NaNs to one side (total order would place negative NaN and positive NaN on different sides)</li>\n<li>Sort floats without NaNs; in this case it might make more sense to panic when NaN exists instead (i.e. <code>partial_cmp(..).unwrap()</code>)</li>\n</ul>",
        "id": 270030687,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643635808
    },
    {
        "content": "<p>Do you propose not having float sorting at all? Or some alternative sorting?</p>\n<p>Because not having a float sorting at all seems unacceptable to me as a user. Let me sort the darn floats.</p>",
        "id": 270043282,
        "sender_full_name": "Lokathor",
        "timestamp": 1643640823
    },
    {
        "content": "<p>Maybe <code>sort_float</code> should accept a setting? Like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">SortFloatStrategyNamesBikeshadable</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">TotalOrder</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// as defined in IEEE 754</span>\n<span class=\"w\">    </span><span class=\"n\">NonNans</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// panic on nan</span>\n<span class=\"w\">    </span><span class=\"n\">SmallNans</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// NaN is the smallest value</span>\n<span class=\"w\">    </span><span class=\"n\">BigNans</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// NaN is the biggest value</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270050230,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1643643316
    },
    {
        "content": "<p>All that flexibility exists in the sort-by methods. IMO <code>sort_float</code> should just stick to a reasonable default, and total order seems like the best option.</p>",
        "id": 270050620,
        "sender_full_name": "cuviper",
        "timestamp": 1643643442
    },
    {
        "content": "<p>I just feel like there isn't a reasonable default and any default will lead to unexpected behaviour for some users.</p>",
        "id": 270051012,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1643643593
    },
    {
        "content": "<p>do we have a way to discover how often the IEEE total ordering is used in practice?</p>",
        "id": 270051262,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1643643664
    },
    {
        "content": "<p>It's not that I think total order is amazing and perfect, just that it's well-defined and standardized. It will do the right thing for all the partially ordered values, while also doing something consistent for NaN. If a user has more opinions about handling NaN, they can write their own comparison.</p>",
        "id": 270058485,
        "sender_full_name": "cuviper",
        "timestamp": 1643645876
    },
    {
        "content": "<p>And it'd actually be nice if there were always NANs at both ends, since that's the places they're most likely to get noticed, I suspect.</p>",
        "id": 270092694,
        "sender_full_name": "scottmcm",
        "timestamp": 1643658242
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270043282\">said</a>:</p>\n<blockquote>\n<p>Because not having a float sorting at all seems unacceptable to me as a user. Let me sort the darn floats.</p>\n</blockquote>\n<p>I don't see why writing <code>.sort_float</code> is better than <code>.sort_by(f32::total_cmp)</code>.</p>",
        "id": 270271382,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643743952
    },
    {
        "content": "<p>The former is easier to find when looking for a sort function.</p>",
        "id": 270271614,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643744044
    },
    {
        "content": "<p>And \"I have a <code>Vec&lt;f32&gt;</code> and just want to sort it\" seems reasonable.</p>",
        "id": 270271643,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643744063
    },
    {
        "content": "<p>And that is exactly what I worry about, because then the users won't understand the quirks about sorting floats.</p>",
        "id": 270271951,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643744195
    },
    {
        "content": "<p>I think \"easier to find\" can be solved with diagnostics and/or diagnostics.</p>\n<p>Hmm, looks like we don't mention anything about floats in the <code>sort</code> documentation.  Seems like an easy no-fcp thing would be to just add a \"if you're trying to sort floats, consider <code>sort_by(f32::total_cmp)</code>\" or whatever.  Or maybe a section in the documentation for floats that we can link from <code>sort</code> and <code>sort_unstable</code>?</p>",
        "id": 270275145,
        "sender_full_name": "scottmcm",
        "timestamp": 1643745389
    },
    {
        "content": "<p>We could totally talk about <code>f32::total_cmp</code> in the diagnostic of <code>error[E0277]: the trait bound f32: Ord is not satisfied</code>. And potentially even figure out if that error comes from <code>required by a bound in slice::&lt;impl [T]&gt;::sort</code> and then mention <code>sort_by</code>.</p>",
        "id": 270278852,
        "sender_full_name": "oli",
        "timestamp": 1643746858
    },
    {
        "content": "<p>We absolutely could add compiler suggestions to steer people.</p>",
        "id": 270279159,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643746978
    },
    {
        "content": "<p>But I feel like if you are writing float-heavy code, you shouldn't <em>have</em> to write out <code>.sort_by(f32::total_cmp)</code>, any more than you have to write <code>x.float_add(y.float_mul(z))</code>.</p>",
        "id": 270279230,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643747010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270271951\">said</a>:</p>\n<blockquote>\n<p>And that is exactly what I worry about, because then the users won't understand the quirks about sorting floats.</p>\n</blockquote>\n<p>1) Those quirks will be in the documentation.<br>\n2) Why do they <em>need</em> to understand those quirks? And to what extent will having to type out a more verbose incantation force them to understand it, rather than just copy-paste it and treat it as a verbose way to spell <code>sort</code>?</p>",
        "id": 270279273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643747028
    },
    {
        "content": "<p>I generally tend to agree with the premise of \"don't hide details that people need to care about\", and I <em>will</em> say that's making me increasingly convinced we shouldn't call this <code>.sort()</code>; <code>.sort_floats()</code> being different gives us the chance for people to ask \"why is it different\" and learn about those quirks.</p>",
        "id": 270279555,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643747133
    },
    {
        "content": "<p><code>total_cmp</code> is in ieee754. But is it widely used? Does it being in the standard make it a better choice than the other way to sort floats? Since there is no one true way to sort them I'm not sure if calling it <code>sort_floats</code> is the best choice since it just chooses one that we happen to have in the standard library because we needed something.</p>",
        "id": 270458653,
        "sender_full_name": "The 8472",
        "timestamp": 1643836483
    },
    {
        "content": "<p>I think any reasonable way to sort floats is going to sort numeric values identically. The only plausible way to differ would be how to handle NaN, I think.</p>",
        "id": 270459243,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643836749
    },
    {
        "content": "<p>And in practice, I think the primary thing people want is sorting numeric values.</p>",
        "id": 270459283,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643836768
    },
    {
        "content": "<p>supposedly, IEEE 754 was designed to tolerate well-meaning ignorance among programmers. no idea how well that extends to its total order predicate. <a href=\"https://en.wikipedia.org/wiki/Floating-point_arithmetic#IEEE_754_design_rationale\">https://en.wikipedia.org/wiki/Floating-point_arithmetic#IEEE_754_design_rationale</a></p>",
        "id": 270459693,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1643836928
    },
    {
        "content": "<p>yeah, but that handling matters. panic, NaN at start, NaN at end... and then what total_cmp does.</p>",
        "id": 270459802,
        "sender_full_name": "The 8472",
        "timestamp": 1643836974
    },
    {
        "content": "<p>Let's compromise and put them at both ends!</p>",
        "id": 270459845,
        "sender_full_name": "The 8472",
        "timestamp": 1643836993
    },
    {
        "content": "<p>If we want to go down the very configurable route, we could add defaulted generic params to the float types that configures their behaviour (basically the OrderedFloat &amp; NotNan newtypes integrated into <code>f32</code> via generic params).</p>",
        "id": 270459882,
        "sender_full_name": "oli",
        "timestamp": 1643837010
    },
    {
        "content": "<p>another silly approach: poison the whole slice with nans if you encounter a single one on sorting</p>",
        "id": 270460345,
        "sender_full_name": "The 8472",
        "timestamp": 1643837195
    },
    {
        "content": "<p>Please tweet this xD</p>",
        "id": 270461359,
        "sender_full_name": "oli",
        "timestamp": 1643837603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270460345\">said</a>:</p>\n<blockquote>\n<p>another silly approach: poison the whole slice with nans if you encounter a single one on sorting</p>\n</blockquote>\n<p>The batman approach?</p>",
        "id": 270462610,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643838152
    },
    {
        "content": "<p>NaNaNaNaNaNaNaNaNaNaNaNaNaNaNaN Batman!</p>",
        "id": 270462632,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643838163
    },
    {
        "content": "<p>I see you're already planning your replies. <a href=\"https://twitter.com/the8472/status/1488992329902051333\">https://twitter.com/the8472/status/1488992329902051333</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/the8472/status/1488992329902051333\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/b06fe73b56f4f203ff80b62d19fcb0c8a901fe62/68747470733a2f2f6162732e7477696d672e636f6d2f737469636b792f64656661756c745f70726f66696c655f696d616765732f64656661756c745f70726f66696c655f6e6f726d616c2e706e67\"></a><p><span aria-label=\"crab\" class=\"emoji emoji-1f980\" role=\"img\" title=\"crab\">:crab:</span> How to deal with NaNs when sorting [f32] since it's not Ord? Panic, sort them to the start or end, or use ieee754 total ordering which puts them at both ends?\n\nThe best way to surface them is to poison the whole slice with NaNs when encountering the first one.</p><span>- the8472 (@the8472)</span></div></div>",
        "id": 270463230,
        "sender_full_name": "The 8472",
        "timestamp": 1643838427
    },
    {
        "content": "<p>:retweet:</p>",
        "id": 270463308,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1643838474
    },
    {
        "content": "<p>Note that even without NANs, <code>sort_by(f32::total_cmp)</code> is different from <code>sort_by(|a, b| a.partial_cmp(b).unwrap())</code>, because it differs in the handling of signed zeros.</p>",
        "id": 270463824,
        "sender_full_name": "scottmcm",
        "timestamp": 1643838703
    },
    {
        "content": "<p>That seems fine. I kind of expect total and partial orderings to be different</p>",
        "id": 270463942,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643838754
    },
    {
        "content": "<p>True, but I think the handling of signed zeroes in total_cmp seems right, and either people won't care or if they care they want the negative-zeroes-then-positive-zeroes behavior.</p>",
        "id": 270463969,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643838770
    },
    {
        "content": "<p>I suspect fewer people care about those than about NaN handling.</p>",
        "id": 270463980,
        "sender_full_name": "The 8472",
        "timestamp": 1643838775
    },
    {
        "content": "<p>Or at least it seems as fine as the rest of the best of footguns which is floating point</p>",
        "id": 270463986,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643838777
    },
    {
        "content": "<p>But sure, that's yet another dimension along which we can skin this cat</p>",
        "id": 270464188,
        "sender_full_name": "The 8472",
        "timestamp": 1643838855
    },
    {
        "content": "<p>Can you skin a foot gun?</p>",
        "id": 270464265,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643838901
    },
    {
        "content": "<p>ow</p>",
        "id": 270464479,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643838980
    },
    {
        "content": "<p>The fur goes onto the gun if it's a fancy one.</p>",
        "id": 270464496,
        "sender_full_name": "The 8472",
        "timestamp": 1643838986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270279230\">said</a>:</p>\n<blockquote>\n<p>But I feel like if you are writing float-heavy code, you shouldn't <em>have</em> to write out <code>.sort_by(f32::total_cmp)</code>, any more than you have to write <code>x.float_add(y.float_mul(z))</code>.</p>\n</blockquote>\n<p>Honestly, if you are writing float-heavy code, you are going to be bringing in a library with custom tooling for this issue, either because you are doing graphics work or because you are doing scientific numerical computation, and both of those libraries have different needs and slightly different answers to this issue.</p>",
        "id": 270466685,
        "sender_full_name": "Jubilee",
        "timestamp": 1643840001
    },
    {
        "content": "<p>I do think that the equivalent of PyTorch or similar will need a library, but I'm hoping the equivalent of numpy won't.</p>",
        "id": 270468406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643840690
    },
    {
        "content": "<p>I'm thinking of this as part of the story for having functionality like numpy.</p>",
        "id": 270468448,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643840718
    },
    {
        "content": "<p>Doesn't ndarray already cover that? (I don't know much about numpy)</p>",
        "id": 270468644,
        "sender_full_name": "The 8472",
        "timestamp": 1643840846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270468448\">said</a>:</p>\n<blockquote>\n<p>I'm thinking of this as part of the story for having functionality like numpy.</p>\n</blockquote>\n<p>Eh? Something like NumPy is far more likely to use a mechanism where the NumArray <code>sort</code> doesn't simply take <code>&amp;mut self</code> and instead accepts an argument and dispatches to something that is likely going to look like <code>sort_by</code> anyways.</p>\n<p>Or if you meant \"NumPy in the std\": That is... a lot. NumPy does a lot.</p>",
        "id": 270474144,
        "sender_full_name": "Jubilee",
        "timestamp": 1643843637
    },
    {
        "content": "<p>I just meant \"good handling of large-scale numeric work\".</p>",
        "id": 270483729,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643849585
    },
    {
        "content": "<p>Consider another solution, how about introduce NotNanF32 and NotNanF64 to our stdlib?</p>\n<p>Currently, we already have NonZero* in std::num, so it’s reasonable to introduce NotNan* for floats.</p>\n<p>There are several advantages:</p>\n<ol>\n<li>They can implement Ord directly, so we don’t need sort_floats anymore.</li>\n<li>NAN is likely a mistake but not expected in sort, and the error can be reported from construction.</li>\n<li>Users has another choose if they can confirm there is no NAN in their slice, just transmute them.</li>\n<li>Option&lt;NotNanF32&gt;/Option&lt;NotNanF64&gt; can be optimized in memory layout inside compiler, so they will only use 4/8 bytes.</li>\n</ol>",
        "id": 270489988,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1643853695
    },
    {
        "content": "<p>As the price, if we really want to sort floats with Nan (unlikely), we may have to iterate the slice twice. sort_floats is meaningful in the case. But for general case, I think NotNan* is a better solution.</p>\n<p>In fact, there are no conflicts between the two APIs, I just propose  a better solution for some cases covered by sort_floats.</p>",
        "id": 270490679,
        "sender_full_name": "TennyZhuang",
        "timestamp": 1643854231
    },
    {
        "content": "<p><code>NonNanF32</code> and friends come up regularly on IRLO.  Here's a recent instance: &lt;<a href=\"https://internals.rust-lang.org/t/suggestion-ffastmath-intrinsics-in-stable/14447/60?u=scottmcm\">https://internals.rust-lang.org/t/suggestion-ffastmath-intrinsics-in-stable/14447/60?u=scottmcm</a>&gt;</p>\n<p>I'd really like to see them.  Though they'll always be somewhat of a pain until we find a better way to do literals.</p>",
        "id": 270492951,
        "sender_full_name": "scottmcm",
        "timestamp": 1643856227
    },
    {
        "content": "<p>Having experimented extensively with wrapping types in Rust, I think the NonZero* types are not a great model.</p>",
        "id": 270494787,
        "sender_full_name": "Jubilee",
        "timestamp": 1643857840
    },
    {
        "content": "<p>Ugh, I think it might be a problem if we partition -NaN and +NaN on different ends of the slice, the way total order requires. LLVM's APFloat currently gets the sign bit of NaNs wrong on many architectures, including common ones like x86_64.</p>\n<p>The concrete outcome of this is that the sign bit of NaNs will switch based on what optimization levels are enabled (and more broadly, what optimizations LLVM happens to apply). Here's a program whose output changes on debug versus release as a result of this: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=3eaa2447c25f89fd2375b152e0aa68af\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2021&amp;gist=3eaa2447c25f89fd2375b152e0aa68af</a></p>\n<p>This generally isn't noticed by anybody, but if we add <code>sort_float</code> using total order, it will expose the problem in a way that makes NaNs go to wildly different positions depending on the build flags you use, which seems like it could cause hard to track-down bugs that only show up in release builds.</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>You'd like am unreasonable amount of writing about this problem, including a made-up FAQ? Say no more.</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>On most arches (all I'm aware of), there's essentially a \"default NaN\" bitpattern that gets produced when a NaN is generated by some operation which does not have NaN in any of the inputs (typically if it has a NaN in the inputs, that one is propagated to the output).</p>\n<p>Unfortunately, <code>llvm::APFloat</code> is not really aware of the target architecture it is compiling to (its only aware of the type of float you're emulating), and fixing this is tricky. As a result, it just produces a positive qNaN everywhere. This is correct on some arches, but also wrong on many. As mentioned, x86_64 is an example of an architecture where a <em>negative</em> qNaN will be emitted instead.</p>\n<p><code>llvm::APFloat</code> is used to implement a few optimizations, such as constant propagation. This means that whether or not this optimization is performed on your code (which is up to the whims of the inliner, optimization level, and luck) may determine what sign bit NaNs happen to have in your program.. </p>\n<p>Historically, we've had this problem for a while, but this hasn't been a significant issue -- even if code does handle NaNs in some way, it typically doesn't care about the signbit value they have. However, using total order here sadly would make it much more visible and seems like a real footgun.</p>\n<p>That is, it might appear to some unsuspecting users that the sort order of NaNs switches between \"NaNs at the end of slices\" to \"NaNs at the start of slices\" based on optimization levels. This seems almost guaranteed to cause only-happens-in-release-build heisenbugs.</p>\n<hr>\n<h2>The made-up FAQ</h2>\n<ol>\n<li>Is this bug in llvm::APFloat?<p>I don't know. I think so, but would have to argue it -- it's not 100% clear at all if LLVM considers it to be one, or if it just considers it unsupported (intentiaonally or otherwise).</p>\n<p>Concretely: even with this bug, APFloat is IEEE-754 compliant, as that spec does not require a specific sign bit to be used in these cases. However, as it is, it means the optimizations applied can change the result of code quite significantly, which seems very unfortunate for something like constant folding, which <em>should</em> otherwise be entirely transparent (in the absense of UB, which this is certainly not).</p>\n<p>That is: I think it's a bug, but that it isn't cut and dry.</p>\n</li>\n</ol>\n<hr>\n<ol start=\"2\">\n<li>Does our port of APFloat have this issue?<p>Yes, it has the same issue. We don't use it in optimization dependent ways, and forbid float arithmetic in const fn, which considerably limits the scope of the bug.</p>\n<p>That is, while this might means <code>f64::NAN</code> may have a different sign bit than NaNs generated at runtime, we could just document that <code>{f64,f32}::NAN</code> is guaranteed to have a positive signbit (or something), if it became an issue.</p>\n<p>Moreover, CTFE and const eval don't have (nor want to have) optimization-dependent behavior, which limits the negative aspects a great deal IMO.</p>\n</li>\n</ol>\n<hr>\n<ol start=\"3\">\n<li>What about WASM?<p>On Wasm the values of NaN bits and sign are specced as being produced non deterministically. This is annoying, and will probably result in some bugs if it's exhibited by sort_float, but it's more likely to be caught in test code, as it's not opt-level dependent (not to be a broken record, or anything...)</p>\n</li>\n</ol>\n</div></div>",
        "id": 270506799,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643870207
    },
    {
        "content": "<blockquote>\n<p>That is, it might appear to some unsuspecting users that the sort order of NaNs switches between \"NaNs at the end of slices\" to \"NaNs at the start of slices\" based on optimization levels. This seems almost guaranteed to cause only-happens-in-release-build heisenbugs.</p>\n</blockquote>\n<p>I think this is the issue that needs to be tackled head-on in documentation. I can definitely see people just trying to sort NaN and other stuff to find out the answer to the question \"do NaNs sort before other stuff or after?\" and the docs need to very loudly and clearly indicate that the question has a false premise and the answer is \"both, nondeterministically\"</p>",
        "id": 270508814,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643872356
    },
    {
        "content": "<p>What are the actual solutions for this in the community?</p>",
        "id": 270512663,
        "sender_full_name": "Jubilee",
        "timestamp": 1643875889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> in most numeric code I have worked with, mostly in Python or R languages, you actively define how you want to deal with NaN values before doing any sorting, so you can drop the rows with NaN values, you replace them with the mean value for that column or use the min or max value. So I'd say that \"cleaning\" the data before sorting is needed and depends on the specific case. The problem is having that ergonomic hit in all cases, even when you can be sure that there are no NaNs or, if you have them, then that's a logic bug.</p>",
        "id": 270515591,
        "sender_full_name": "pachi",
        "timestamp": 1643877832
    },
    {
        "content": "<p>So, I personally would say that total ordering is perfectly fine for my cases, as if I need special casing for NaNs I'd probably have to deal with it before doing any data sorting, grouping, etc</p>",
        "id": 270515705,
        "sender_full_name": "pachi",
        "timestamp": 1643877899
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270512663\">said</a>:</p>\n<blockquote>\n<p>What are the actual solutions for this in the community?</p>\n</blockquote>\n<p><code>noisy_float</code> apparently just YOLOs it: <a href=\"https://docs.rs/noisy_float/0.2.0/src/noisy_float/float_impl.rs.html#108-119\">https://docs.rs/noisy_float/0.2.0/src/noisy_float/float_impl.rs.html#108-119</a></p>\n<p><code>ordered_float</code> would let you do <code>.sort_by_key(|a| NotNan::new(a).ok())</code>, which would put all the NANs at one end: <a href=\"https://docs.rs/ordered-float/latest/ordered_float/struct.NotNan.html#method.new\">https://docs.rs/ordered-float/latest/ordered_float/struct.NotNan.html#method.new</a></p>",
        "id": 270516579,
        "sender_full_name": "scottmcm",
        "timestamp": 1643878430
    },
    {
        "content": "<p>Also yes, I should mention I think float sorting functions should in fact sort sign of zeros even if they are not, strictly speaking, \"ordered\" by such except under <code>total_cmp</code> and its ilk.</p>",
        "id": 270516911,
        "sender_full_name": "Jubilee",
        "timestamp": 1643878574
    },
    {
        "content": "<p>either all your values are gonna be negative or positive anyways or you have reason to care about sign of zero.</p>",
        "id": 270517516,
        "sender_full_name": "Jubilee",
        "timestamp": 1643878887
    },
    {
        "content": "<p>I do think that, for sorting, distinguishing negative zeros is a good thing -- at least since it's inexpensive to do so.</p>\n<p>(Similarly I wish there was an efficient way to have <code>(-0.0).clamp(0.0, 1.0)</code> return <code>+0.0</code>, not the current <code>-0.0</code>.)</p>",
        "id": 270517959,
        "sender_full_name": "scottmcm",
        "timestamp": 1643879130
    },
    {
        "content": "<p>I'm pretty sure <span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> showed me a special comparison ordering you can do which brings even NaN and -0.0 into a range like that.</p>",
        "id": 270562712,
        "sender_full_name": "Lokathor",
        "timestamp": 1643900578
    },
    {
        "content": "<p><code>robust_saturate</code> in <a href=\"https://shift.click/codelet/codelet-saturate\">https://shift.click/codelet/codelet-saturate</a> brings all floats into the range between 0.0 and 1.0 (it maps -0.0 and the NaNs to 0.0 -- which can be controversial). I've never tried to make it that fast other than a batch SIMD impl I did once in some image processing code (converting f32 channels to u8). Not that relevant here tho</p>",
        "id": 270600860,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643915101
    },
    {
        "content": "<p><code>NotNan</code> is a funny name since NaN is already \"not a number\" :)</p>",
        "id": 270601795,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1643915473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270562712\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure <span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> showed me a special comparison ordering you can do which brings even NaN and -0.0 into a range like that.</p>\n</blockquote>\n<p>Once <a href=\"https://llvm.org/docs/LangRef.html#llvm-minimum-intrinsic\">https://llvm.org/docs/LangRef.html#llvm-minimum-intrinsic</a> is fast everywhere then <code>clamp</code> could just use that instead, yes.</p>",
        "id": 270602277,
        "sender_full_name": "scottmcm",
        "timestamp": 1643915670
    },
    {
        "content": "<p>Sure, but also that's not the same as what's described in the blog post Thom linked.</p>",
        "id": 270603368,
        "sender_full_name": "Lokathor",
        "timestamp": 1643916190
    },
    {
        "content": "<p>Mine's not quite that, since I explicitly turns NaNs into 0 (which is desirable in stuff like image processing, but probably not appropriate for the stdlib).</p>\n<p>I remember asking about changing something (maybe <code>clamp</code>?) to use <code>minimum</code> instead of <code>minNum</code>, and was told it was too slow on important targets (e.g. x86_64).</p>\n<p>That said, I didn't check if this was true. In retrospect it seems unlikely, since minps/maxps arent ieee754's minNum/maxNUm anyway, so neither could use the instruction regardless.</p>\n<p>Might be misremembering tho</p>",
        "id": 270603793,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643916372
    },
    {
        "content": "<p>So the fast form of <code>min()</code> on x86_64 is <code>if x &lt; y { x } else { y }</code> which propagates NaNs in <code>y</code> but not <code>x</code>.  So <code>robust_saturate()</code> is just <code>max(min(v, 1.0), 0.0)</code> which should be two instructions</p>",
        "id": 270604384,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1643916613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306504\">Tavian Barnes</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270601795\">said</a>:</p>\n<blockquote>\n<p><code>NotNan</code> is a funny name since NaN is already \"not a number\" :)</p>\n</blockquote>\n<p><code>Real&lt;f32&gt;</code></p>",
        "id": 270604474,
        "sender_full_name": "Jubilee",
        "timestamp": 1643916655
    },
    {
        "content": "<p>You don't like <code>An&lt;f32&gt;</code>? ;)</p>",
        "id": 270604520,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1643916677
    },
    {
        "content": "<p>HA.</p>",
        "id": 270604556,
        "sender_full_name": "Jubilee",
        "timestamp": 1643916697
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270604474\">said</a>:</p>\n<blockquote>\n<p><code>Real&lt;f32&gt;</code></p>\n</blockquote>\n<p>Personally I'd say <code>ExtendedReal</code>, since it includes infinities -- or at least I think it would, since the infinities are useful and don't have issues like the NANs do.</p>",
        "id": 270604718,
        "sender_full_name": "scottmcm",
        "timestamp": 1643916764
    },
    {
        "content": "<p><code>Real++</code></p>",
        "id": 270604778,
        "sender_full_name": "Jubilee",
        "timestamp": 1643916793
    },
    {
        "content": "<p>joke: <code>Hyper&lt;f32&gt;</code> because that sounds faster. <a href=\"https://en.wikipedia.org/wiki/Hyperreal_number\">https://en.wikipedia.org/wiki/Hyperreal_number</a></p>",
        "id": 270605458,
        "sender_full_name": "Jubilee",
        "timestamp": 1643917069
    },
    {
        "content": "<p>Aside: treating <code>+0</code> and <code>-0</code> as positive/negative infinitesimals and <code>+-INF</code> as specific positive/negative infinite hyperreal numbers (note, this is not the same as <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">∞</mi></mrow><annotation encoding=\"application/x-tex\">\\infty</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord\">∞</span></span></span></span>) is actually somewhat more logically coherent than the usual way of reading these as members of the extended reals and +-0 being the same but also not really. <code>NaN</code> is right out though, even the hyperreals want nothing to do with that mess</p>",
        "id": 270622759,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643924735
    },
    {
        "content": "<p>Re: naming, I think we shouldn't miss the opportunity to have <code>NaNaN</code></p>",
        "id": 270623102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1643924885
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270516579\">said</a>:</p>\n<blockquote>\n<p><code>noisy_float</code> apparently just YOLOs it: <a href=\"https://docs.rs/noisy_float/0.2.0/src/noisy_float/float_impl.rs.html#108-119\">https://docs.rs/noisy_float/0.2.0/src/noisy_float/float_impl.rs.html#108-119</a></p>\n</blockquote>\n<p>afaict <code>NoisyFloat</code> is essentially a <code>NotNaN</code> or <code>FiniteOnly</code> (except it only checks in debug builds?? <a href=\"https://docs.rs/noisy_float/0.2.0/src/noisy_float/checkers.rs.html#29-31\">https://docs.rs/noisy_float/0.2.0/src/noisy_float/checkers.rs.html#29-31</a>)</p>",
        "id": 270634143,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1643930458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306504\">Tavian Barnes</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270604384\">said</a>:</p>\n<blockquote>\n<p>So the fast form of <code>min()</code> on x86_64 is <code>if x &lt; y { x } else { y }</code> which propagates NaNs in <code>y</code> but not <code>x</code>.  So <code>robust_saturate()</code> is just <code>max(min(v, 1.0), 0.0)</code> which should be two instructions</p>\n</blockquote>\n<p>i am pretty sure you can't use the max instruction, which has the args the other way? maybe i am wrong. fwiw, llvm doesn't optimize it two just min/max <a href=\"https://godbolt.org/z/cPKv55boP\">https://godbolt.org/z/cPKv55boP</a>, but maybe thats something something something canonicalization gone wrong</p>",
        "id": 270654827,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643938328
    },
    {
        "content": "<p>It's unclear to me what minss does about signed zeros -- <a href=\"https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=minss&amp;ig_expand=4786\">https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=minss&amp;ig_expand=4786</a> says </p>\n<blockquote>\n<p>does not follow the IEEE Standard for Floating-Point Arithmetic (IEEE 754) minimum value when inputs are NaN or signed-zero values.</p>\n</blockquote>\n<p>so <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 270667021,
        "sender_full_name": "scottmcm",
        "timestamp": 1643949403
    },
    {
        "content": "<p>ah right, that too.</p>",
        "id": 270746324,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643995775
    },
    {
        "content": "<blockquote>\n<p>If the values being compared are both 0.0s (of either sign), the value in the second source operand is returned. If a value in the second operand is an SNaN, that SNaN is returned unchanged to the destination (that is, a QNaN version of the SNaN is not returned).</p>\n<p>If only one value is a NaN (SNaN or QNaN) for this instruction, the second source operand, either a NaN or a valid floating-point value, is written to the result. If instead of this behavior, it is required that the NaN in either source operand be returned, the action of MINSD can be emulated using a sequence of instructions, such as, a comparison followed by AND, ANDN and OR.</p>\n</blockquote>\n<p><a href=\"https://www.felixcloutier.com/x86/minss\">https://www.felixcloutier.com/x86/minss</a></p>",
        "id": 270752177,
        "sender_full_name": "Hans Kratz",
        "timestamp": 1643998548
    },
    {
        "content": "<p>Yeah, <code>clamp</code> is written carefully so it compiles to <code>minss+maxss</code> while handling NAN correctly.  But because of the \"of either sign\" it doesn't handle signed zeros perfectly.</p>",
        "id": 270761118,
        "sender_full_name": "scottmcm",
        "timestamp": 1644002664
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/219381-t-libs/topic/float.20total_cmp/near/270654827\">said</a>:</p>\n<blockquote>\n<p>i am pretty sure you can't use the max instruction, which has the args the other way? maybe i am wrong. fwiw, llvm doesn't optimize it two just min/max <a href=\"https://godbolt.org/z/cPKv55boP\">https://godbolt.org/z/cPKv55boP</a>, but maybe thats something something something canonicalization gone wrong</p>\n</blockquote>\n<p>Well I dunno why that didn't work exactly, but this does: <a href=\"https://godbolt.org/z/Wc6eqKEen\">https://godbolt.org/z/Wc6eqKEen</a></p>",
        "id": 270761398,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1644002802
    },
    {
        "content": "<p>Oh actually there is a difference between those implementations</p>",
        "id": 270761653,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1644002937
    },
    {
        "content": "<p>The correct one would be <code>min(max(v, 0.0), 1.0)</code>, which is also compiled optimally.  Your version codegens differently because both tests use <code>v</code>, whereas in mine the  second test is on the clamped value.  I guess yours is harder to canonicalize</p>",
        "id": 270761927,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1644003101
    }
]