[
    {
        "content": "<p>While working on <a href=\"https://github.com/rust-lang/rust/pull/93709\">https://github.com/rust-lang/rust/pull/93709</a> I stumbled upon weird behaviour: </p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --&gt; library/alloc/src/collections/btree/set/tests.rs:383:20\n    |\n383 |     assert_eq!(set.min().unwrap().id(), 1);\n    |                    ^^^- supplied 0 arguments\n    |                    |\n    |                    expected 1 argument\n    |\nnote: associated function defined here\n   --&gt; /home/waffle/projects/repos/rust2/library/core/src/cmp.rs:816:8\n    |\n816 |     fn min(self, other: Self) -&gt; Self\n    |        ^^^\n</code></pre></div>\n<p>Even though I've <a href=\"https://github.com/rust-lang/rust/pull/93709/files#diff-9a2ef4e4c7d97aa881a78d345ec96b7238baa4bd06472c3b2d8a436737be15bfR686\">defined</a> inherent method <code>BTreeSet::min</code> and <code>library/alloc</code> builds just fine while <a href=\"https://github.com/rust-lang/rust/pull/93709/files#diff-9a2ef4e4c7d97aa881a78d345ec96b7238baa4bd06472c3b2d8a436737be15bfR327\">using this method</a>. Is there something special about compiling tests?</p>",
        "id": 270902277,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1644170155
    },
    {
        "content": "<p>It's also weird that Rust Analyzer finds the right method</p>\n<p><a href=\"/user_uploads/4715/7Wep-HMcBnerCMSS89QpeSJb/2022-02-06_21-03.png\">2022-02-06_21-03.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/7Wep-HMcBnerCMSS89QpeSJb/2022-02-06_21-03.png\" title=\"2022-02-06_21-03.png\"><img src=\"/user_uploads/4715/7Wep-HMcBnerCMSS89QpeSJb/2022-02-06_21-03.png\"></a></div>",
        "id": 270902778,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1644170653
    },
    {
        "content": "<p>Huh? This does not compile too:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(PartialEq, PartialOrd, Eq, Ord)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Mine</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Mine</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">min</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Mine</span><span class=\"p\">.</span><span class=\"n\">min</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=61fcaec8b63c0be18367cf2651aafeb2\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=61fcaec8b63c0be18367cf2651aafeb2</a></p>\n<p>Shouldn't inherent methods always take precedence over trait ones?</p>",
        "id": 270903014,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1644170991
    },
    {
        "content": "<p><del>Not if the trait is in scope afaik, and since <code>Ord</code> is in the prelude it takes over here</del></p>",
        "id": 270903234,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1644171249
    },
    {
        "content": "<p><del>(so r-a resolving it to the inherent method is probably a bug)</del></p>",
        "id": 270903263,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1644171306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"300586\">Lukas Wirth</span> <a href=\"#narrow/stream/219381-t-libs/topic/Inherent.20function.20is.20not.20prioritized.20in.20tests.3F/near/270903234\">said</a>:</p>\n<blockquote>\n<p>Not if the trait is in scope afaik, and since <code>Ord</code> is in the prelude it takes over here</p>\n</blockquote>\n<p>Nope, the inherent method should take precedence even if the trait is in scope, I think. For example, this compiles just fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(PartialEq, PartialOrd, Eq, Ord)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Mine</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Mine</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">min</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Mine</span><span class=\"p\">.</span><span class=\"n\">min</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=3b83547065f25a1f015b1659901dbed4\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=3b83547065f25a1f015b1659901dbed4</a></p>",
        "id": 270903433,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1644171504
    },
    {
        "content": "<p>Moreover this is a regression introduced in 1.20.0?</p>\n<p><a href=\"/user_uploads/4715/3dwfuRXIMsw8TWNTpqykJjc9/2022-02-06_21-21.png\">2022-02-06_21-21.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/3dwfuRXIMsw8TWNTpqykJjc9/2022-02-06_21-21.png\" title=\"2022-02-06_21-21.png\"><img src=\"/user_uploads/4715/3dwfuRXIMsw8TWNTpqykJjc9/2022-02-06_21-21.png\"></a></div>",
        "id": 270903551,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1644171709
    },
    {
        "content": "<p>I think it looks at the trait impl first before trying to do add a reference to the receiver and trying to resolve the method for this. So inherent <code>fn min(self)</code> -&gt; trait impl <code>fn min(self)</code> -&gt; inherent <code>fn min(&amp;self)</code> -&gt; trait impl <code>fn min(&amp;self)</code>.</p>",
        "id": 270903699,
        "sender_full_name": "bjorn3",
        "timestamp": 1644171874
    },
    {
        "content": "<p>Yes, but since this compiled fine before 1.20, this seems like a bug in auto-ref/method resolution logic</p>",
        "id": 270903788,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1644171966
    },
    {
        "content": "<p>Ord::min was stabilized in 1.21</p>",
        "id": 270903949,
        "sender_full_name": "The 8472",
        "timestamp": 1644172185
    }
]