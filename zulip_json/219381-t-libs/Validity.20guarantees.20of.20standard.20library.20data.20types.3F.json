[
    {
        "content": "<p>Hi, simple question I’m having about standard library types such as <code>BTreeSet</code>, maybe someone can answer this, link to existing information, or refer me to a better place to ask (in case opening a topic here is not the best place):</p>\n<p>Essentially in the simplest form the question is: Is it possible to create, say, a “broken” <code>BTreeSet&lt;i32&gt;</code> using safe code? Where by “broken” I mean that the elements are not in ascending order (which can lead to surprising behavior when using the data structure). Certainly for custom types such a “broken” state is possible if the <code>Ord</code> implementation of the type is not well-behaved or if the type has interior mutability (e.g. <code>BTreeSet&lt;Cell&lt;i32&gt;&gt;</code>).</p>\n<p>If the answer is “no it’s not possible currently”, then a follow-up question would be whether this is guaranteed (e.g. <code>unsafe</code> code receiving a <code>BTreeSet&lt;i32&gt;</code> could rely on the thing not being in a “broken” state). Alternatively, if creating such a “broken” data structure for types with well-behaved <code>Ord</code> implementation is not deemed unsound, then a <em>safe</em> function could technically (eventually) be provided in the standard library for efficiently building a <code>BTreeMap</code> from a sorted duplicate-free iterator, without additional comparisons of duplicate-checks, right?</p>",
        "id": 271287906,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644417810
    },
    {
        "content": "<p>How does the unsafe code interact with btreesets? If it's <code>unsafe fn foo(set: BtreeSet&lt;i32&gt;)</code> then the set being in a sane state should be part of its contract. Whether that contract is automatically fulfilled because an invalid map cannot be constructed or needs to be explicitly checked is then a separate question.</p>",
        "id": 271288749,
        "sender_full_name": "The 8472",
        "timestamp": 1644418173
    },
    {
        "content": "<p>Ah, no, I’m saying a safe <code>fn foo(set: BTreeSet&lt;i32&gt;) { unsafe { /* code relies on `set` not exhibiting surprising behavior */ } }</code></p>",
        "id": 271288889,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644418230
    },
    {
        "content": "<blockquote>\n<p>then a safe function could technically (eventually) be provided in the standard library for efficiently building a BTreeMap from a sorted duplicate-free iterator, without additional comparisons of duplicate-checks, right?</p>\n</blockquote>\n<p>Safe does not mean bugfree and we still should try to ensure non-buggy behavior. An example that frequently comes up is <code>size_hint</code>. It's safe and can be wrong. Imo it would be reasonable to panic when we see a wrong size-hint.</p>",
        "id": 271288913,
        "sender_full_name": "The 8472",
        "timestamp": 1644418247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"280891\">Frank Steffahn</span> <a href=\"#narrow/stream/219381-t-libs/topic/Validity.20guarantees.20of.20standard.20library.20data.20types.3F/near/271288889\">said</a>:</p>\n<blockquote>\n<p>Ah, no, I’m saying a safe <code>fn foo(set: BTreeSet&lt;i32&gt;) { unsafe { /* code relies on `set` not exhibiting surprising behavior */ } }</code></p>\n</blockquote>\n<p>If <code>foo</code> exists inside the standard library then it's easy. We can check whether such a map can be constructed or not and add guards if it becomes possible in the future.<br>\nIf it is part of a 3rd party crate then it becomes more difficult, basically a policy question around API contracts, stability etc.... I guess that's the one you're asking?</p>",
        "id": 271289235,
        "sender_full_name": "The 8472",
        "timestamp": 1644418373
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Validity.20guarantees.20of.20standard.20library.20data.20types.3F/near/271289235\">said</a>:</p>\n<blockquote>\n<p>If it is part of a 3rd party crate then it becomes more difficult, basically a policy question around API contracts, stability etc.... I guess that's the one you're asking?</p>\n</blockquote>\n<p>Yes, kind-of. I’m mostly interested in whether or not this already is a guarantee; and if it isn’t it might even make sense to document this.</p>\n<p>To give an example, I could imagine someone might write something like this without even questioning whether it could be unsound:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">get_all_indices</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span>: <span class=\"o\">'</span><span class=\"na\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">indices</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">b</span> <span class=\"nc\">BTreeSet</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">slice</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">last</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">indices</span><span class=\"p\">.</span><span class=\"n\">last</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">last</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Safety: BTreeSet entries are sorted and duplicate-free</span>\n<span class=\"w\">    </span><span class=\"n\">indices</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">i</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(untested)</p>\n<p>On the other hand, guaranteeing such code to be sound seems like a minor benefit, and IMO the benefit of allowing <code>unsafe</code>-code-free efficient creation of <code>BTreeSet</code>s from known-to-be-sorted iterators might be more valiable.</p>",
        "id": 271291006,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644419058
    },
    {
        "content": "<p>The basic question here applies similarly e.g. to <code>HashMap</code> or <code>BinaryHeap</code>.</p>",
        "id": 271291151,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644419128
    },
    {
        "content": "<blockquote>\n<p>and IMO the benefit of allowing unsafe-code-free efficient creation of BTreeSets from known-to-be-sorted iterators might be more valiable.</p>\n</blockquote>\n<p>That could be handled by <code>unsafe</code> traits though then we don't even have to ask the question.</p>",
        "id": 271292516,
        "sender_full_name": "The 8472",
        "timestamp": 1644419679
    },
    {
        "content": "<blockquote>\n<p>That could be handled by <code>unsafe</code> traits though then we don't even have to ask the question.</p>\n</blockquote>\n<p>Could you elaborate slightly, what kind of trait you have in mind?</p>",
        "id": 271292681,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644419751
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">OrderedUniqIterator</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">OrderedUniqIterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">btree_set</span>::<span class=\"n\">IntoIter</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>plus adapter impls for <code>Filter</code> and other things that don't change order</p>",
        "id": 271292880,
        "sender_full_name": "The 8472",
        "timestamp": 1644419833
    },
    {
        "content": "<p>We can also orthogonalize into Ordered and Uniq traits. HashSet could be the latter but not the former.</p>",
        "id": 271293284,
        "sender_full_name": "The 8472",
        "timestamp": 1644419988
    },
    {
        "content": "<p>Well, now that kind of impl would effectively imply that <code>BTreeSet</code> <em>does</em> guarantee that it only ever gets into an unordered state when the <code>Ord</code> implementation of the contained type is non-well-behaved (which includes the case of interior mutability). Right?</p>",
        "id": 271293801,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644420189
    },
    {
        "content": "<p>Hrmm... actually, BtreeSet couldn't uphold the requirements of that trait I guess, not in the general case. So we could only implement it for TrustedOrd or some-such types in the first place! It's just kicking the problem down the road.</p>",
        "id": 271294915,
        "sender_full_name": "The 8472",
        "timestamp": 1644420604
    },
    {
        "content": "<p>I think that's a guarantee insofar as it would be a bug if it got into a bad state. Which is kind of true for the <code>Ord</code> problem too, but it's a question of <em>whose</em> bug.</p>",
        "id": 271295022,
        "sender_full_name": "cuviper",
        "timestamp": 1644420659
    },
    {
        "content": "<p>Currently it says:</p>\n<blockquote>\n<p>It is a logic error for an item to be modified in such a way that the item’s ordering relative to any other item, as determined by the Ord trait, changes while it is in the set. This is normally only possible through Cell, RefCell, global state, I/O, or unsafe code. The behavior resulting from such a logic error is not specified (it could include panics, incorrect results, aborts, memory leaks, or non-termination) but will not be undefined behavior.</p>\n</blockquote>\n<p>But I guess that refers to BtreeSet itself not having undefined behavior. It says nothing about other code.</p>",
        "id": 271295277,
        "sender_full_name": "The 8472",
        "timestamp": 1644420759
    },
    {
        "content": "<p>Ok so <code>OrderedUniqIterator</code> could still work. It'd basically say that the iterator is consistent with the type's <code>Ord</code>. Which indeed does defer to the sanity of <code>Ord</code>. But for specific types, such as <code>usize</code> it is known and then <code>get_all_indices</code> would be fine.</p>",
        "id": 271295721,
        "sender_full_name": "The 8472",
        "timestamp": 1644420923
    },
    {
        "content": "<p>I think you really have no choice <em>but</em> to rely on safe code in standard library types being correct, at least in so much as it doesn't involve unknown generic impls.  Because if you go <em>ad absurdum</em>, not having that means that <code>Vec&lt;T&gt;::as_ptr</code> could return basically anything.</p>",
        "id": 271321560,
        "sender_full_name": "scottmcm",
        "timestamp": 1644429765
    },
    {
        "content": "<p>It seems like it should be legal for a downstream crate to \"upgrade\" logic errors in std to UB, because that's not something that a future std could change. I don't think std itself can do this however because it would be a breaking change.</p>",
        "id": 271370574,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644453475
    },
    {
        "content": "<p>Yeah I've wondered about this before and basically come to the conclusion that unsafe code has to be able to rely on std being correctly implemented (at least with regards to its documentation). I mean, at you have stuff like <code>std::ops::Add</code> for <code>usize</code> -- arbitrary safe code is obviously allowed to implement Add in buggy or goofy ways (it's a safe trait after all), but i think if it turned out that there were an issue with libcore's implementation where <code>Add</code> happened to somehow return the wrong result for some of the numbers, it should... be considered more than just a logic error, and probably require a security advisory / patch release / etc.</p>\n<p>(Presumably no such bugs could possibly still exist at this point, and I suppose <code>std::ops::Add for usize</code> is implemented more in the compiler rather than in the stdlib; although I'm not sure that changes my larger point..)</p>",
        "id": 271414894,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644490532
    },
    {
        "content": "<p>Steffahn wasn't necessarily asking about bugs though but future API extensions that allow a type to be brought into a state that is called wrong-but-safe. Today it's not possible to construct such a thing for a specific instantiation of a generic but is the guarantee that this won't ever change?</p>",
        "id": 271427802,
        "sender_full_name": "The 8472",
        "timestamp": 1644498463
    },
    {
        "content": "<p>I don't think there's a general answer to this. In some cases we can see the problem in advance, in others future API changes aren't obvious.</p>",
        "id": 271427910,
        "sender_full_name": "The 8472",
        "timestamp": 1644498508
    },
    {
        "content": "<p>E.g. in iterators we clearly distinguish between std-provided ones and 3rd party adapters for unsafe specializations.</p>",
        "id": 271427953,
        "sender_full_name": "The 8472",
        "timestamp": 1644498538
    },
    {
        "content": "<p>I think the general form might be that for standard library types+traits, unsafe code must be able to assume that that the validity invariants, library invariants, and documented behavior of methods/functions are all upheld (at least upon function entry).</p>\n<p>For example with a BTreeMap: if an Ord impl is hostile and causes elements to be out of order then that's the Ord impl's fault. However, we choose to trust the Ord impl of all standard library types so if you're using a BTreeMap with a standard library type as the key then you should choose to trust that your elements will be in order.</p>\n<p>However, if the key is generic, you just have a trait bound, then in that situation you should <em>not</em> trust in general that keys will be in order.</p>",
        "id": 271443274,
        "sender_full_name": "Lokathor",
        "timestamp": 1644505429
    },
    {
        "content": "<p>But <code>BtreeSet</code> explicitly don't guarantee that the sets are in a sane order due to the possibility of bad Ord impls. So there are two ways to extrapolate from there</p>\n<p>a) Because BtreeSet doesn't guarantee anything anyway we might as well add an API that can construct them in the wrong order for any type, including std-owned ones<br>\nb) someone might reason about the concrete type rather then generically and thus rely on more guarantees than are explicitly promises, therefore we shouldn't provide such an API</p>",
        "id": 271448738,
        "sender_full_name": "The 8472",
        "timestamp": 1644507546
    },
    {
        "content": "<p>or various middle grounds requiring <code>unsafe</code> traits or methods</p>",
        "id": 271449387,
        "sender_full_name": "The 8472",
        "timestamp": 1644507829
    },
    {
        "content": "<p>I think (b). I think we can (and should) guarantee that Btree order is as consistent as the key <code>Ord</code>, and that it is memory safe regardless.</p>",
        "id": 271449494,
        "sender_full_name": "cuviper",
        "timestamp": 1644507861
    },
    {
        "content": "<p>If we want that we should update the documentation imo. Currently it doesn't promise such a thing.</p>",
        "id": 271449840,
        "sender_full_name": "The 8472",
        "timestamp": 1644508005
    },
    {
        "content": "<p>Sure</p>",
        "id": 271449938,
        "sender_full_name": "cuviper",
        "timestamp": 1644508045
    },
    {
        "content": "<p>In the face of a hostile Ord impl, I'm not sure BTree could really guarantee anything</p>",
        "id": 271450372,
        "sender_full_name": "simulacrum",
        "timestamp": 1644508203
    },
    {
        "content": "<p>or at least I wouldn't want us to try and verify as we're e.g. iterating that the Ord impl is still right</p>",
        "id": 271450431,
        "sender_full_name": "simulacrum",
        "timestamp": 1644508223
    },
    {
        "content": "<p>We're not arguing about that scenario. We're arguing how to extrapolate from there to btrees over std-owned types.</p>",
        "id": 271451390,
        "sender_full_name": "The 8472",
        "timestamp": 1644508578
    },
    {
        "content": "<p>For context/comparison, e.g. Haskell <em>does</em> offer API for constructing a <code>Map</code> from an ascending list without additional checks. See <a href=\"https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Lazy.html#g:4\">https://hackage.haskell.org/package/containers-0.6.5.1/docs/Data-Map-Lazy.html#g:4</a></p>\n<p>I personally feel like it’s somewhat unfortunate if this was only possible as an <code>unsafe fn</code> in Rust due to perhaps-overly strong guarantees, especially if you’re constructing a set/map with a key type whose <code>Ord</code> implementation you wrote yourself, or a type with interior mutability like <code>BTreeSet&lt;Cell&lt;i32&gt;&gt;</code>, i.e. you <em>could</em> bring the data structure into a broken state <em>anyways</em>.</p>\n<p>For additional context: I remembered this question I’m asking in this thread – which I had wondered my self already at some time in the past – in the context of discussing the documentation of <code>drain</code> / <code>drain_filter</code> iterators and whether or not one should perhaps say that it’s a “logic error” to leak the iterator. It already documents that the number of removed items is unspecified (<code>drain_filter</code> can even remove additional items it wouldn’t have otherwise). But “logic error” would mean (at least following precedent where incorrect trait implementations are called a “logic error”) that the data structure could – potentially – even be in a broken state w.r.t. invariants such as a BTreeSet being sorted. (This is only about documentation and how much or little documentation for a thing you’re not supposed to do guarantees about the consequences. It’s a different question whether an implementation of <code>Drain</code>/<code>DrainFilter</code> should <strong><em>actually</em></strong> allow invariants to break when leaked.)</p>",
        "id": 271460141,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644512146
    },
    {
        "content": "<p>I suppose we have talked about a \"raw entry\" API on <code>HashMap</code> that was considered whether it should be <code>unsafe</code> or not, so that would be a \"you can't rely on the invariants even for something with only known impls like <code>HashMap&lt;usize, usize&gt;</code>\".</p>",
        "id": 271461803,
        "sender_full_name": "scottmcm",
        "timestamp": 1644512803
    },
    {
        "content": "<p>Oh! Great point, I totally overlooked / forgot about the fact that <code>hashbrown</code> with (the non-<code>unsafe</code> parts of) their raw API already offers API for their <code>HashMap</code> API that <em>can</em> break the map.</p>",
        "id": 271462669,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644513174
    },
    {
        "content": "<p>\"yay\"</p>",
        "id": 271482093,
        "sender_full_name": "Lokathor",
        "timestamp": 1644521353
    },
    {
        "content": "<p>Well, raw_entry is still unstable</p>",
        "id": 271483958,
        "sender_full_name": "The 8472",
        "timestamp": 1644522213
    },
    {
        "content": "<p>My personal view is that the BTreeSet <em>contract</em> allows the addition of such a method and any unsafe code taking in unverified sets without making that a safety requirement is assuming too much.<br>\nBut the libs team tends to be overly careful about these things.<br>\nGiven that, the method could be added with verification and the verification disabled with a TrustedOrd unsafe trait. And that trait could be implemented for primitives and perhaps derived Ord impls where all fields are TrustedOrd.</p>",
        "id": 271484636,
        "sender_full_name": "The 8472",
        "timestamp": 1644522537
    },
    {
        "content": "<p>The raw API is a good point. I think that it would be more consistent with, for example, <code>String</code>, that library types assert their invariants as safety properties, so that a raw entry API would have to be unsafe. I think it is easier to make the case that <code>raw_entry</code> is unsafe than the <code>get_all_indices</code> function</p>",
        "id": 271505003,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644532320
    },
    {
        "content": "<p>If the invariant of BTreeSet has the form \"If K: TrustedOrd then the keys of this set are ordered\", then there is no need for a <code>TrustedOrd</code> bound on <code>from_asc_iter</code>, because you can do the (linear time) check that the iterator is ascending while building the map, and this will result in the right thing if K is TrustedOrd and if it's not then it will produce something, memory safely, but without any ordering properties, which is in keeping with the data structure invariant</p>",
        "id": 271505457,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644532603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/219381-t-libs/topic/Validity.20guarantees.20of.20standard.20library.20data.20types.3F/near/271484636\">said</a>:</p>\n<blockquote>\n<p>Given that, the method could be added with verification and the verification disabled with a TrustedOrd unsafe trait. And that trait could be implemented for primitives and perhaps derived Ord impls where all fields are TrustedOrd.</p>\n</blockquote>\n<p>I think the point of my raw_entry example is that it would involve only <code>TrustedEq</code>+<code>TrustedHash</code> types, but still couldn't be relied on for basic things like \"if it's there when you iterate you can look it up and find it\".</p>",
        "id": 271505497,
        "sender_full_name": "scottmcm",
        "timestamp": 1644532639
    },
    {
        "content": "<p>if you don't want to do <em>any</em> checks in <code>from_asc_iter</code> then that would be <code>from_asc_iter_unchecked</code> and again it's easy to explain to users why it needs to be unsafe</p>",
        "id": 271505511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1644532651
    }
]