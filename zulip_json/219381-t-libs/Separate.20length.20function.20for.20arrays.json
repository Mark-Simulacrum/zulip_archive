[
    {
        "content": "<p>I’ve made a PR that adds a separate length function for arrays that is useful for MIR and (locally without unstable flags) it just works. There is a PR, so is it possible to make it insta-stable and run a crater over it? <a href=\"https://github.com/rust-lang/rust/pull/86404\">https://github.com/rust-lang/rust/pull/86404</a></p>",
        "id": 243058148,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623952770
    },
    {
        "content": "<p>Potentially-terrible idea: Things like <code>+</code> on primitives and <code>[0]</code> on arrays/slices are magically lowered to the MIR operations, rather than to the corresponding trait methods calls.  Could it make sense to treat <code>.len()</code> like that too?</p>\n<p>(Seems like that could be net easier than having the call in MIR, then inlining it sometimes and MIR-opt'ing it away in the other cases...)</p>",
        "id": 243060268,
        "sender_full_name": "scottmcm",
        "timestamp": 1623953588
    },
    {
        "content": "<p>hm, we already have this for Vec::len and Vec::is_empty (even though they're also available through deref to []) and a few others. and i don't think that was ever a problem</p>",
        "id": 243066567,
        "sender_full_name": "Mara",
        "timestamp": 1623956217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"420832\">@Alex Vlasov</span> the PR just says \"solve #..\", but that just links to the tracking issue you opened for the PR. is there an issue that describes the problem this is solving?</p>",
        "id": 243066676,
        "sender_full_name": "Mara",
        "timestamp": 1623956276
    },
    {
        "content": "<p>There is nothing else, but I’ve made a short description that basically separate functions allows MIR to propagate constants there without any extra modifications</p>",
        "id": 243067135,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623956473
    },
    {
        "content": "<p>but it doesn't explain why that doesn't already happen before this change, and why it is a problem that it doesn't happen.</p>\n<p>and i'd expect some discussion about why this isn't better solved on the side of MIR first</p>",
        "id": 243067346,
        "sender_full_name": "Mara",
        "timestamp": 1623956560
    },
    {
        "content": "<p>I’ve solved lowering slice::len in the MIR Len operation in a separate PR, but for this one I either have to do a similar thing (and more complicated actually), or just update the core. The underlying reason is that array length actually calls slice::len that does some pointer magic and looks not transparent enough for the correct constant propagation</p>",
        "id": 243067693,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623956702
    },
    {
        "content": "<p>it just accesses a union though? const eval can handle that</p>",
        "id": 243067934,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1623956797
    },
    {
        "content": "<p>we can't really review this without all the context. do you have links to what you changed in MIR, and to any discussion about why this would have to be solved in the library rather than in mir?</p>",
        "id": 243068008,
        "sender_full_name": "Mara",
        "timestamp": 1623956844
    },
    {
        "content": "<p>Main reason is kind of “why not”? Insta-stable method allows to express it on a library level without modifications into the compiler. Even I’m not sure that I’ve observed all the edge cases for it, but can spam more mir optimization tests</p>",
        "id": 243068447,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623957006
    },
    {
        "content": "<p>express what exactly? what does it solve?</p>",
        "id": 243068679,
        "sender_full_name": "Mara",
        "timestamp": 1623957107
    },
    {
        "content": "<p>I've made a simple MIR optimization test for a code like</p>\n<div class=\"codehilite\"><pre><span></span><code>// EMIT_MIR lower_slice_len.array_bound.SimplifyLocals.diff\npub fn array_bound&lt;const N: usize&gt;(index: usize, slice: &amp;[u8; N]) -&gt; u8 {\n    if index &lt; slice.len() {\n        slice[index]\n    } else {\n        42\n    }\n}\n</code></pre></div>\n<p>(hacking into SimplifyLocals as the last pass for simplicity, so after any constant prop, mir-opt-level = 3)</p>\n<p>here is a MIR</p>\n<div class=\"codehilite\"><pre><span></span><code>- // MIR for `array_bound` before SimplifyLocals\n+ // MIR for `array_bound` after SimplifyLocals\n\n  fn array_bound(_1: usize, _2: &amp;[u8; N]) -&gt; u8 {\n      debug index =&gt; _1;                   // in scope 0 at $DIR/lower_slice_len.rs:14:36: 14:41\n      debug slice =&gt; _2;                   // in scope 0 at $DIR/lower_slice_len.rs:14:50: 14:55\n      let mut _0: u8;                      // return place in scope 0 at $DIR/lower_slice_len.rs:14:70: 14:72\n      let mut _3: bool;                    // in scope 0 at $DIR/lower_slice_len.rs:15:8: 15:27\n      let mut _4: usize;                   // in scope 0 at $DIR/lower_slice_len.rs:15:8: 15:13\n      let mut _5: usize;                   // in scope 0 at $DIR/lower_slice_len.rs:15:16: 15:27\n      let mut _6: &amp;[u8];                   // in scope 0 at $DIR/lower_slice_len.rs:15:16: 15:21\n      let mut _7: &amp;[u8; N];                // in scope 0 at $DIR/lower_slice_len.rs:15:16: 15:21\n      let _8: usize;                       // in scope 0 at $DIR/lower_slice_len.rs:16:15: 16:20\n      let mut _9: usize;                   // in scope 0 at $DIR/lower_slice_len.rs:16:9: 16:21\n      let mut _10: bool;                   // in scope 0 at $DIR/lower_slice_len.rs:16:9: 16:21\n\n      bb0: {\n          StorageLive(_3);                 // scope 0 at $DIR/lower_slice_len.rs:15:8: 15:27\n          StorageLive(_4);                 // scope 0 at $DIR/lower_slice_len.rs:15:8: 15:13\n          _4 = _1;                         // scope 0 at $DIR/lower_slice_len.rs:15:8: 15:13\n          StorageLive(_5);                 // scope 0 at $DIR/lower_slice_len.rs:15:16: 15:27\n          StorageLive(_6);                 // scope 0 at $DIR/lower_slice_len.rs:15:16: 15:21\n          StorageLive(_7);                 // scope 0 at $DIR/lower_slice_len.rs:15:16: 15:21\n          _7 = _2;                         // scope 0 at $DIR/lower_slice_len.rs:15:16: 15:21\n          _6 = move _7 as &amp;[u8] (Pointer(Unsize)); // scope 0 at $DIR/lower_slice_len.rs:15:16: 15:21\n          StorageDead(_7);                 // scope 0 at $DIR/lower_slice_len.rs:15:20: 15:21\n          _5 = Len((*_6));                 // scope 0 at $DIR/lower_slice_len.rs:15:16: 15:27\n          StorageDead(_6);                 // scope 0 at $DIR/lower_slice_len.rs:15:26: 15:27\n          _3 = Lt(move _4, move _5);       // scope 0 at $DIR/lower_slice_len.rs:15:8: 15:27\n          StorageDead(_5);                 // scope 0 at $DIR/lower_slice_len.rs:15:26: 15:27\n          StorageDead(_4);                 // scope 0 at $DIR/lower_slice_len.rs:15:26: 15:27\n          switchInt(move _3) -&gt; [false: bb2, otherwise: bb1]; // scope 0 at $DIR/lower_slice_len.rs:15:5: 19:6\n      }\n\n      bb1: {\n          StorageLive(_8);                 // scope 0 at $DIR/lower_slice_len.rs:16:15: 16:20\n          _8 = _1;                         // scope 0 at $DIR/lower_slice_len.rs:16:15: 16:20\n          _9 = const N;                    // scope 0 at $DIR/lower_slice_len.rs:16:9: 16:21\n          _10 = Lt(_8, _9);                // scope 0 at $DIR/lower_slice_len.rs:16:9: 16:21\n          assert(move _10, &quot;index out of bounds: the length is {} but the index is {}&quot;, move _9, _8) -&gt; bb3; // scope 0 at $DIR/lower_slice_len.rs:16:9: 16:21\n      }\n\n      bb2: {\n          _0 = const 42_u8;                // scope 0 at $DIR/lower_slice_len.rs:18:9: 18:11\n          goto -&gt; bb4;                     // scope 0 at $DIR/lower_slice_len.rs:15:5: 19:6\n      }\n\n      bb3: {\n          _0 = (*_2)[_8];                  // scope 0 at $DIR/lower_slice_len.rs:16:9: 16:21\n          StorageDead(_8);                 // scope 0 at $DIR/lower_slice_len.rs:17:5: 17:6\n          goto -&gt; bb4;                     // scope 0 at $DIR/lower_slice_len.rs:15:5: 19:6\n      }\n\n      bb4: {\n          StorageDead(_3);                 // scope 0 at $DIR/lower_slice_len.rs:19:5: 19:6\n          return;                          // scope 0 at $DIR/lower_slice_len.rs:20:2: 20:2\n      }\n  }\n</code></pre></div>\n<p>If I make a library modification then <code>_5 = Len((*_6));</code> becomes <code>_5 = N;</code></p>",
        "id": 243069759,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623957537
    },
    {
        "content": "<p>In bound checks <code>_9 = const N;</code> is fine as expected, but not in the user code</p>",
        "id": 243070067,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623957671
    },
    {
        "content": "<p>Note that if MIR's <code>Len</code> is called on an array, then instcombine will lower it to the constant: <a href=\"https://github.com/rust-lang/rust/blob/master/src/test/mir-opt/combine_array_len.norm2.InstCombine.64bit.diff#L33\">https://github.com/rust-lang/rust/blob/master/src/test/mir-opt/combine_array_len.norm2.InstCombine.64bit.diff#L33</a></p>\n<p>So in-bounds array indexing already removes the check: <a href=\"https://rust.godbolt.org/z/r7bhaxWG4\">https://rust.godbolt.org/z/r7bhaxWG4</a></p>",
        "id": 243070439,
        "sender_full_name": "scottmcm",
        "timestamp": 1623957835
    },
    {
        "content": "<p>Here <code>Len</code> is not called on the array and instead it's called on <code>move _7 as &amp;[u8] (Pointer(Unsize));</code>. So this coercion will be eliminated</p>",
        "id": 243070945,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623958051
    },
    {
        "content": "<p>Actually <code>Len</code> is not even called there, it's a result of <a href=\"https://github.com/rust-lang/rust/pull/86383\">https://github.com/rust-lang/rust/pull/86383</a> that I already use in my work</p>",
        "id": 243071096,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623958098
    },
    {
        "content": "<p>Before such PR it would call <code>core::slice::&lt;impl [u8]&gt;::len</code> there</p>",
        "id": 243071158,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1623958128
    },
    {
        "content": "<p>I've marked a function as insta-const-stable (well, to the best of my guess how it should be marked), tests pass locally, so it may be interesting to run CI, performance and crater</p>",
        "id": 243302736,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624195150
    },
    {
        "content": "<p>hm, I understand why this has to be insta-stable, but does it have to be insta-const stable? I thought the const stability checker was capable enough to do that</p>",
        "id": 243309140,
        "sender_full_name": "bstrie",
        "timestamp": 1624204935
    },
    {
        "content": "<p>A function like this </p>\n<div class=\"codehilite\"><pre><span></span><code>pub const fn length&lt;const N: usize&gt;(_arr: &amp;[u8; N]) -&gt; usize {\n    N\n}\n</code></pre></div>\n<p>is already accepted by 1.52 stable, so it's ok to have an explicit <code>const</code> marker</p>",
        "id": 243363963,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624271749
    },
    {
        "content": "<p>slice::len is already const</p>",
        "id": 243380715,
        "sender_full_name": "Mara",
        "timestamp": 1624281734
    },
    {
        "content": "<p>Ok, so it actually has to be const then. In any case CI doesn’t show any problems, so can it be considered for merging (modulo my noobie insta-const-stable attempt)?</p>",
        "id": 243388950,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624285179
    },
    {
        "content": "<p>insta-const is fine</p>",
        "id": 243390231,
        "sender_full_name": "oli",
        "timestamp": 1624285698
    },
    {
        "content": "<p>a new function can be immediately stabilized as const with its own stabilization</p>",
        "id": 243390274,
        "sender_full_name": "oli",
        "timestamp": 1624285717
    },
    {
        "content": "<p>i'm not really convinced yet we need this function at all</p>",
        "id": 243390407,
        "sender_full_name": "Mara",
        "timestamp": 1624285768
    },
    {
        "content": "<p>it'd be a bit of a weird function, because it takes &amp;self and doesn't use it at all. the length info is already statically known.</p>",
        "id": 243390555,
        "sender_full_name": "Mara",
        "timestamp": 1624285811
    },
    {
        "content": "<p>I'm just here for the \"const\" part, the other part is not my department <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span></p>",
        "id": 243390558,
        "sender_full_name": "oli",
        "timestamp": 1624285812
    },
    {
        "content": "<p>^^</p>",
        "id": 243390590,
        "sender_full_name": "Mara",
        "timestamp": 1624285825
    },
    {
        "content": "<p>but now that I think on it... I still have opinions. Its only motivation is making MIR opts simpler as far as I can tell. But that only helps arrays. We could instead go the mir opt route and figure out what the minimal opt improvement is that makes it work out. Probably just making const prop handle the runtime array to slice op to create a (runtime, constant array length) pair (for the wide pointer that is used after the unsizing to slice) instead of bailing out \"because runtime\"</p>",
        "id": 243391451,
        "sender_full_name": "oli",
        "timestamp": 1624286135
    },
    {
        "content": "<p>The example of “why it’s needed is above”. Yes, it’s artificial in a sense that it’s only type information related function and doesn’t care about &amp;self, but it’s intuitive for users in a sense of syntax and signature, allows better MIR already, and may be handy when full const genetics and const machinery will hit</p>",
        "id": 243391469,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624286142
    },
    {
        "content": "<p>but this should be handled on the mir side, right? as oli is saying.</p>",
        "id": 243391852,
        "sender_full_name": "Mara",
        "timestamp": 1624286283
    },
    {
        "content": "<p>Even though I’ve built a similar MIR pass for slice length I would want to avoid this pass as then all the structures that potentially coerce into slices may require such pass  </p>\n<p>Separately I’d say slice and array  length should be an intrinsic - then already have a special MIR op called Len, so it would be a easier to maintain if we take such artillery as additional niche optimization pass</p>",
        "id": 243393292,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624286845
    },
    {
        "content": "<p>I’ve started all these to be able to make MIR pass that provably eliminates bound checks without LLVM, but in a worst case I can make few more required niches</p>",
        "id": 243393495,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624286940
    },
    {
        "content": "<p>what I'm trying to say is that this is something we want to do in const prop <em>anyway</em>. If doing it in const prop makes the other methods irrelevant, then it would be my preference to only do it there</p>",
        "id": 243394305,
        "sender_full_name": "oli",
        "timestamp": 1624287255
    },
    {
        "content": "<p>Const prop will do it already if something like _2 = _1 as &amp;[T]; Len(* _2) will be patched to just Len(* _1)</p>",
        "id": 243394842,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624287468
    },
    {
        "content": "<p>Can we then consider an idea of length intrinsic then that it easier to maintain then niche MIR patches?</p>",
        "id": 243397319,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624288376
    },
    {
        "content": "<p>It would still require a separate function though</p>",
        "id": 243397455,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624288439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/219381-t-libs/topic/Separate.20length.20function.20for.20arrays/near/243390555\">said</a>:</p>\n<blockquote>\n<p>it'd be a bit of a weird function, because it takes &amp;self and doesn't use it at all. the length info is already statically known.</p>\n</blockquote>\n<p>If this is a concern, perhaps rationalize it like this: The function doesn't needs <code>&amp;self</code>, however to make it use method syntax then some sort of self argument must be present. From there, to play the most nicely with the borrow/ownership of Rust, we pick <code>&amp;self</code>, because it is the least intrusive to whatever else the programmer is doing before and after they call this method.</p>",
        "id": 243398497,
        "sender_full_name": "Lokathor",
        "timestamp": 1624288888
    },
    {
        "content": "<p>i'm just saying that we already have a slice::len. and in contexts where it matters that it's an array, you already have the length N around. and regardless, this seems like a mir-opt thing instead of a library thing.</p>",
        "id": 243398647,
        "sender_full_name": "Mara",
        "timestamp": 1624288938
    },
    {
        "content": "<p>could be lightly precedented by <code>mem::size_of_val</code>, which takes a <code>&amp;T</code> parameter just to look up metadata about the type. but it would be nice if this could just be a guaranteed optimization, yes</p>",
        "id": 243400121,
        "sender_full_name": "bstrie",
        "timestamp": 1624289534
    },
    {
        "content": "<p>if you wanted to better express that this is a statically-known property of the type you could have <code>impl [T; N] { const LEN: usize = N }</code>, but of course that's not the exact same API</p>",
        "id": 243401015,
        "sender_full_name": "bstrie",
        "timestamp": 1624289887
    },
    {
        "content": "<p>We also already have a Vec::len, that doesn’t go into slice coercion and fast tracks to specific implementation</p>",
        "id": 243401124,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624289910
    },
    {
        "content": "<p>In any case at the end of the day any sane code from may be even users who are a little lazy should become _1 = const N in MIR, this is a fastest option, other ones require more code</p>",
        "id": 243401634,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624290052
    },
    {
        "content": "<p>In case of <code>size_of_val</code> the size may be looked up/calculated from the reference metadata if it is a fat pointer.</p>",
        "id": 243402150,
        "sender_full_name": "bjorn3",
        "timestamp": 1624290297
    },
    {
        "content": "<p>I think I'm with oli and Mara on this one FWIW.  If MIR was SSA it'd be easy to see \"unsize+len\" and fold that down to the length.  So it seems weird to add a library function just because it's hard to write optimizations in MIR.</p>",
        "id": 243409138,
        "sender_full_name": "scottmcm",
        "timestamp": 1624293582
    },
    {
        "content": "<p>It’s not “hard”, but MIR pass is a global performance hit (small, but still), and library function is less invasive</p>",
        "id": 243411600,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624294746
    },
    {
        "content": "<p>I dunno, the library function is so invasive that it requires signoff from an entirely different team</p>",
        "id": 243415652,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1624296638
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420832\">Alex Vlasov</span> <a href=\"#narrow/stream/219381-t-libs/topic/Separate.20length.20function.20for.20arrays/near/243411600\">said</a>:</p>\n<blockquote>\n<p>It’s not “hard”, but MIR pass is a global performance hit (small, but still), and library function is less invasive</p>\n</blockquote>\n<p>we will get this hit anyway when we generalize const prop to handle such unsizing ops</p>",
        "id": 243427387,
        "sender_full_name": "oli",
        "timestamp": 1624301921
    },
    {
        "content": "<p>I also think this should be solved at the MIR level and not by adding a new library function.</p>",
        "id": 243440616,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1624308471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211727\">Jonas Schievink  [he/him]</span> <a href=\"#narrow/stream/219381-t-libs/topic/Separate.20length.20function.20for.20arrays/near/243415652\">said</a>:</p>\n<blockquote>\n<p>I dunno, the library function is so invasive that it requires signoff from an entirely different team</p>\n</blockquote>\n<p>libs-api has to sign off on all new api, regardless of invasiveness level, so them having to sign off on the new api doesn't indicate in any way how invasive or not the new method is.</p>",
        "id": 243449190,
        "sender_full_name": "Lokathor",
        "timestamp": 1624313053
    },
    {
        "content": "<p>I've made a draft of the pass and it's not pretty to be both simple and sound. Further MIR passes will optimize away the leftovers, but it requires creation of the intermediate local,  making live, extra copy, patching <code>Len</code> and making local dead</p>",
        "id": 243450529,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624313951
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/86525\">https://github.com/rust-lang/rust/pull/86525</a></p>",
        "id": 243450543,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624313967
    },
    {
        "content": "<p>Sorry, I have been severly unhelpful, just throwing out statements without explanation. I got a few minutes, so here hopefully goes something coherent: I don't think we should have a new pass. Instead we should teach const prop to handle a) unsizing casts, even from runtime values, as that will give us a partial constant wide pointer, where the pointer part is unknown, but the length part is constant, and b) Len to work on slices, by checking whether the length is constant and completely ignoring the actual pointer part. These two steps can both be done in <a href=\"https://github.com/rust-lang/rust/pull/86525/files#diff-4b547ad83c74d17a147c275e70e658b432d5080cbcdb25aa800989d4affb6a70\">https://github.com/rust-lang/rust/pull/86525/files#diff-4b547ad83c74d17a147c275e70e658b432d5080cbcdb25aa800989d4affb6a70</a>, by adding an arm for the Cast rvalue. The Cast rvalue should specifically check for unsizing casts, while the Len rvalue probably doesn't even need an impl, we can just go the default route which should only touch the length. If not, we'll also need a special handler for the Len rvalue. Since we are now producing a previously unknown thing (namely a \"tuple\" (wide pointer) where part of it is undefined, we also need to adjust <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir/src/transform/const_prop.rs#L928-L931\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_mir/src/transform/const_prop.rs#L928-L931</a> to be able to support ScalarMaybeUninit::Undef.</p>\n<p>Does this make sense? Am I misunderstanding what the MIR at the const prop level is and this isn't possible the way I'm thinking?</p>",
        "id": 243483752,
        "sender_full_name": "oli",
        "timestamp": 1624349202
    },
    {
        "content": "<p>I think it's an option, but can you also explain relation (or desired relation) between such MIR hacks and potentially full CTFE that should be able to make the same conclusions and (later on when slice.len() is const) propagate the constants in a consistent way?</p>",
        "id": 243488043,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624352035
    },
    {
        "content": "<p>Hmm... good point, maybe we don't need to do the steps in the first link at all. It may already all be working correctly due to the CTFE machinery. This needs to be debugged, but potentially you can just do the thing at the second link, allowing partially undef scalar pairs</p>",
        "id": 243489984,
        "sender_full_name": "oli",
        "timestamp": 1624353272
    },
    {
        "content": "<blockquote>\n<p>make the same conclusions and (later on when slice.len() is const) propagate the constants in a consistent way?</p>\n</blockquote>\n<p>I don't understand what you mean by this part</p>",
        "id": 243490036,
        "sender_full_name": "oli",
        "timestamp": 1624353307
    },
    {
        "content": "<p>My impression was that CTFE is separate (CTFE allows to e.g. evaluate <code>slice.len()</code> in it's current form before <a href=\"https://github.com/rust-lang/rust/pull/86383#issuecomment-862749123\">https://github.com/rust-lang/rust/pull/86383#issuecomment-862749123</a> changed it, or any other <code>const</code> function) and MIR transformations are separate - just walk over MIR and reorder how you want</p>",
        "id": 243493647,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624355559
    },
    {
        "content": "<p>yes they are</p>",
        "id": 243499387,
        "sender_full_name": "oli",
        "timestamp": 1624359508
    },
    {
        "content": "<p>but I don't get how CTFE is relevant beyond sharing code with const prop</p>",
        "id": 243499401,
        "sender_full_name": "oli",
        "timestamp": 1624359522
    },
    {
        "content": "<p>const prop is a mir opt, and will run on any non-ctfe mir to ensure simple runtime constants are optimized away when used in operations</p>",
        "id": 243499748,
        "sender_full_name": "oli",
        "timestamp": 1624359732
    },
    {
        "content": "<p>so 1+1 becomes 2 in mir, without involving ctfe at all</p>",
        "id": 243499820,
        "sender_full_name": "oli",
        "timestamp": 1624359763
    },
    {
        "content": "<p>anything not constant is treated as undef in const prop</p>",
        "id": 243499884,
        "sender_full_name": "oli",
        "timestamp": 1624359802
    },
    {
        "content": "<p>so x + 1 is not propped, because the shared const machinery (miri engine) errors out if you add undef with anything</p>",
        "id": 243500036,
        "sender_full_name": "oli",
        "timestamp": 1624359892
    },
    {
        "content": "<p>Well, CTFE is relevant, because we have options:</p>\n<ul>\n<li>lib function, that is <code>const</code>, handled by const propagation without extra changes in MIR, and most likely trivial for CTFE, everything for one lib change</li>\n<li>no lib function, but then it may potentially diverge modulo my knowledge. I don't know how CTFE works and what is it's input (MIR?). If it's MIR then sure, ConstProp patch is a way to go, but otherwise we can get a case when for <code>&amp;[T;N].len()</code> MIR will end up with having a code that effectively uses a const value, but CTFE will follow some other pass and may fail to compute <code>&amp;[T].len()</code> into constant, while it should</li>\n</ul>",
        "id": 243502102,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624361163
    },
    {
        "content": "<p>This possible divergence is true for all optimizations, but only if they are buggy. Optimizations do not affect CTFE, and optimizations that miscompile... should be fixed, that's a soundness bug after all. For this situation, all we're doing is moving an optimizations that LLVM does anyway, and putting it into MIR. So we don't actually change anything to the status quo, except that we get simpler MIR</p>",
        "id": 243503136,
        "sender_full_name": "oli",
        "timestamp": 1624361792
    },
    {
        "content": "<p>CTFE works on different MIR than LLVM uses for codegen. the MIR is cloned for CTFE and stored, before optimizations are run on MIR</p>",
        "id": 243503187,
        "sender_full_name": "oli",
        "timestamp": 1624361838
    },
    {
        "content": "<p>so yes, we could definitely diverge, but any divergence due to mir opts would be a soundness bug I presume. We are very careful with adding new const features, e.g. floating point math can be very different when optimized, const evaluated, or done at runtime. Since we use separate MIR for runtime and CTFE, the slice::len function which already works in CTFE on slices or arrays just fine, would not suddenly fail to compute said length, no matter how much we mangle the MIR in optimizations</p>",
        "id": 243503540,
        "sender_full_name": "oli",
        "timestamp": 1624362050
    },
    {
        "content": "<p>Yeah, that's tricky. Then CTFE has to be patched immediately to be able to see through array -&gt; slice casts in a similar manner</p>",
        "id": 243504394,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624362688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"420832\">Alex Vlasov</span> <a href=\"#narrow/stream/219381-t-libs/topic/Separate.20length.20function.20for.20arrays/near/243504394\">said</a>:</p>\n<blockquote>\n<p>Yeah, that's tricky. Then CTFE has to be patched immediately to be able to see through array -&gt; slice casts in a similar manner</p>\n</blockquote>\n<p>it doesn't have to be patched, it already works in CTFE, and we aren't touching the MIR that CTFE uses</p>",
        "id": 243505864,
        "sender_full_name": "oli",
        "timestamp": 1624363622
    },
    {
        "content": "<p>Example showing how CTFE does this: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=14b078f5732f994e6e76c6db1ef4d575\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=14b078f5732f994e6e76c6db1ef4d575</a>. The MIR of the constant is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">_1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"mi\">42_</span><span class=\"k\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"mi\">43_</span><span class=\"k\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"mi\">44_</span><span class=\"k\">i32</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// scope 0 at src/main.rs:2:13: 2:25</span>\n<span class=\"w\">        </span><span class=\"n\">StorageLive</span><span class=\"p\">(</span><span class=\"n\">_2</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 1 at src/main.rs:3:5: 3:6</span>\n<span class=\"w\">        </span><span class=\"n\">StorageLive</span><span class=\"p\">(</span><span class=\"n\">_3</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 1 at src/main.rs:3:5: 3:6</span>\n<span class=\"w\">        </span><span class=\"n\">_3</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">_1</span><span class=\"p\">;</span><span class=\"w\">                        </span><span class=\"c1\">// scope 1 at src/main.rs:3:5: 3:6</span>\n<span class=\"w\">        </span><span class=\"n\">_2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"n\">_3</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Pointer</span><span class=\"p\">(</span><span class=\"n\">Unsize</span><span class=\"p\">));</span><span class=\"w\"> </span><span class=\"c1\">// scope 1 at src/main.rs:3:5: 3:6</span>\n<span class=\"w\">        </span><span class=\"n\">StorageDead</span><span class=\"p\">(</span><span class=\"n\">_3</span><span class=\"p\">);</span><span class=\"w\">                 </span><span class=\"c1\">// scope 1 at src/main.rs:3:5: 3:6</span>\n<span class=\"w\">        </span><span class=\"n\">_0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">slice</span>::<span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">i32</span><span class=\"p\">]</span><span class=\"o\">&gt;</span>::<span class=\"n\">len</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"n\">_2</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">bb1</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// scope 1 at src/main.rs:3:5: 3:12</span>\n</code></pre></div>\n<p>so all steps work already</p>",
        "id": 243506215,
        "sender_full_name": "oli",
        "timestamp": 1624363834
    },
    {
        "content": "<p>Ok, let me try to get into ConstProp</p>",
        "id": 243507434,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624364633
    },
    {
        "content": "<p>I'll try to find some time for your open PR. It's too complex for a casual review, and I'm still on leave until 5th of July, so I unfortunately can't promise anything until then. the mir diffs are looking nice tho</p>",
        "id": 243514409,
        "sender_full_name": "oli",
        "timestamp": 1624367974
    },
    {
        "content": "<p>From by brief understanding of const-prop I do not thing it can work. Yes, one can get a concrete value of array length like in the example above, but not the type system constant <code>N</code></p>",
        "id": 243559296,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624386528
    },
    {
        "content": "<p>that's true. that is a general limitation of const prop</p>",
        "id": 243611457,
        "sender_full_name": "oli",
        "timestamp": 1624429827
    },
    {
        "content": "<p>Ok, so far the results:</p>\n<ul>\n<li><a href=\"https://github.com/rust-lang/rust/pull/86525\">https://github.com/rust-lang/rust/pull/86525</a> achieves a propagation of _1 = const N at the cost of overhead of the optimization pass that for a heavy use of arrays with unremoved bound checks (my guess) leads to slowdowns (keccak example in performance run)</li>\n<li>this library extension: get all the same for free (neutral in performance)</li>\n</ul>\n<p>May be this function is a good candidate for 2021 edition? At least consistent with array.into_iter()</p>",
        "id": 243634253,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624445518
    },
    {
        "content": "<p>since the original concern over this addition was along the lines of \"please elaborate why this isn't addressed in MIR instead\" , and since that approach appears to require 300x more code and has significant perf implications, that seems to me to be a pretty good argument in favor of the inherent method</p>",
        "id": 243669379,
        "sender_full_name": "bstrie",
        "timestamp": 1624462285
    },
    {
        "content": "<p>In general, my opinion is that MIR optimizations should be transparent to users in that there should be no difference in program behavior or language or library behavior whether they are enabled or disabled. I believe they should also be pretty tightly encapsulated in the rustc_mir library and not affect various other parts of the compiler. </p>\n<p>Having said that, if there was a very compelling reason to break those general principles, then that seems entirely reasonable to me. For example, if we can achieve a 20% throughput improvement in compiler performance but it requires touching lots of parts of the compiler, that seems like a worthwhile engineering trade-off to me.</p>\n<p>In this case, even if we add the library function, which doesn't seem very useful to users in general to me, perf results show no real change in compiler performance. I would be very surprised if there was a change in code quality under the release profile as LLVM should be able to trivially optimize these cases itself. There could be an improvement to code quality in the debug profile but that has historically not been something we've cared a lot about. </p>\n<p>Given that the usual justification for MIR optimizations (perf.rlo shows improvements) doesn't seem to currently apply, I think it would be helpful to elaborate more on what the desired end goal is here. That would help evaluate the tradeoff between more complex MIR opts and adding a library function.</p>",
        "id": 243671622,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1624463222
    },
    {
        "content": "<p>There is a message in the beginning of the thread that all those optimizations for length related MIR, etc are just a prelude for the main work, that is first static analysis to eliminate range checks, and then more generic range analysis. For this I’d prefer to start with MIR that is as homogeneous as possible, so I did 3 things:</p>\n<ul>\n<li>lower slice len call from function call to Len MIR operation (merged)</li>\n<li>introduced this proposal to get lowering of array length into _1 = const N - type system constant. It can alternatively be done by the a little expensive MIR pass</li>\n<li>introduced a pass that eliminated intermediate copies like _2 = _1; _3 = Op(move _2); StorageDead(_2)</li>\n</ul>\n<p>All those 3 are required for a good point to start eliminating bound checks</p>",
        "id": 243681733,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624467779
    },
    {
        "content": "<p>So far the most reasonable objection I have see on the special .len() for arrays is that it doesn’t actually care about &amp;self, but when full const genetics kick in I believe other similar cases may emerge</p>",
        "id": 243682159,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624467947
    },
    {
        "content": "<p>And for sure “neutral performance impact” and no failing tests is better than negative one</p>",
        "id": 243682309,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624467996
    },
    {
        "content": "<p>It’s actually funny that even though there is a MIR pass “instcombine” that should lower Len() on arrays into the constant it can not work in practice if the operand is &amp;[T; N]</p>",
        "id": 243682479,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624468080
    },
    {
        "content": "<p>Another performance neutral would be to patch lowering of special case of call to .len() on arrays to skip unsized cast into slice and directly generate Len in MIR, but this would be the most ugly I believe (well, modulo recent into_iter() changes, may be it’s acceptable)</p>",
        "id": 243682952,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624468297
    },
    {
        "content": "<p>One potential way to look at <code>len</code> on arrays: if it's going to exist, <code>is_empty</code> should probably be added to arrays too.</p>\n<p>(I don't know if that makes it more or less appetizing.  And I guess that <code>Vec</code> has <code>is_empty</code> even though it's never been strictly necessary.  Though passing <code>Vec::is_empty</code> as a function seems more plausible to me than passing <code>&lt;[i32; 7]&gt;::is_empty</code> as a function.)</p>",
        "id": 243684968,
        "sender_full_name": "scottmcm",
        "timestamp": 1624469173
    },
    {
        "content": "<p>WRT to taking &amp;self, I think there's an argument that <code>.len()</code> is the single most pervasive \"implicit interface\" in std (i.e. a consistent idiom that isn't codified by a trait), and that it's reasonable for things to conform to that interface even if they don't need access to self. (Pre-1.0 <a href=\"https://internals.rust-lang.org/t/collection-traits-take-2/1272/15\">there were designs for a <code>Collections</code> trait</a> (later abandoned due to lack of HKT), which likely would have included <code>fn len(&amp;self)</code>, which naturally people would have wanted to implement for arrays.) And since arrays are an important fundamental type, giving them their own implementation of this implicit interface feels like continuing the process of making arrays \"first class\" that was blocked for so long on const generics.</p>",
        "id": 243684970,
        "sender_full_name": "bstrie",
        "timestamp": 1624469177
    },
    {
        "content": "<p>I'm not going to argue too vehemently in favor, since after all we <em>don't</em> have any Collections interface and you'll always have <code>N</code> in scope anyway, so the utility is solely in the domain of \"compiler optimizations which may or may not already exist or may or may not ever exist\". But conceptually I think it would be natural, and impose no additional API surface area over what is currently exposed (and is potentially the smallest code addition in the history of std).</p>",
        "id": 243685665,
        "sender_full_name": "bstrie",
        "timestamp": 1624469502
    },
    {
        "content": "<p>Actually missed “is_empty()”, but agree that for consistency it should be added then</p>",
        "id": 243689102,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624471036
    },
    {
        "content": "<p>Regarding the domain: I would not be surprised if people will write .len() and expect it to be optimized away by “powerful rust compiler” :)</p>",
        "id": 243689251,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624471092
    },
    {
        "content": "<p>I absolutely, positively, expect <code>len</code> to be optimized away, and cheaply.</p>",
        "id": 243694119,
        "sender_full_name": "Lokathor",
        "timestamp": 1624473223
    },
    {
        "content": "<p>At the moment MIR const-prop runs before monomorphization, so it can only propagate concrete constants and not const generic N</p>",
        "id": 243694595,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624473458
    },
    {
        "content": "<p>needs some kind of symbolic const-prop?</p>",
        "id": 243694741,
        "sender_full_name": "cuviper",
        "timestamp": 1624473514
    },
    {
        "content": "<p>I think symbolic cost prop is a close relative of full const-generics and will require a larger work (my \"new in rustc\" point of view), but for purposes of bound checks elimination it should be ok to be able to reason that <code>_1 &lt; const N = true</code> by observing CFG</p>",
        "id": 243698338,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624475256
    },
    {
        "content": "<p>any calls to <code>len()</code> will already be optimized out though?</p>",
        "id": 243701244,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1624476824
    },
    {
        "content": "<p>not by the default MIR opts but by LLVM's inliner</p>",
        "id": 243701268,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1624476838
    },
    {
        "content": "<p>though the MIR inliner should also handle it</p>",
        "id": 243701332,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1624476856
    },
    {
        "content": "<p>LLVM may do it because it runs after monomorphization, but it may be useful to be able to judge before it</p>",
        "id": 243702537,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624477485
    },
    {
        "content": "<p>Thanks for the enlightening experiments and thorough analysis of all alternatives. I do believe that you are right, <em>in the future</em> this function may be the right way to go about it. But as noted, there is no immediate benefit, so we'd end up having very complex analyses that we need to maintain, or we have an additional function, that doesn't have much support for existing. So... do we really need the \"eliminate duplicate bounds checks\" optimization to work on arrays in order to show the benefit of that optimizations? Or are these actually orthogonal concerns? If it improves perf if used on slices, meaning a manual length check and an automatically inserted one (e.g. for an index op) do get deduplicated, then that is sufficient to get the pass merged. Arrays will get more prevalent with const generics, but they aren't as of yet, so focussing on arrays does not give us too much benefit I believe. I'd be happy to be proven otherwise with some perf results, but this is all very hard to actually do since we don't test runtime perf yet. So we're kind of stuck in a corner here, where we don't want to add complex MIR opts without compile-time benefits, but technically do want to extend our set of MIR opts to ones that improve runtime perf. Currently we trust in LLVM to take care of that, but if there are situations where that doesn't cut it, we should start by adding tests for that and then looking into improving them.</p>",
        "id": 243719541,
        "sender_full_name": "oli",
        "timestamp": 1624486185
    },
    {
        "content": "<p>I am fully aware I'm putting the entire burden on you by just stating this, but wg-mir-opt just doesn't have the capacity to do any major projects right now, so if you want to champion something in the direction of VRA, we will be happy to help design and figure out how to do it in a way that we can all be happy with. You won't be on your own, but we also won't just merge random mir opts that slightly improve the MIR without some perf or LLVM-ir tests that show that they improve things.</p>",
        "id": 243719761,
        "sender_full_name": "oli",
        "timestamp": 1624486352
    },
    {
        "content": "<p>I’ve initially wanted to do a VRA and had a simple prototype that would e.g. optimize a cast like “bool as u8”, but it’s most likely over the roof for me because ideally I then have to backpropagate the information to front end part and hint a users that some cases are reachable/unreachable. So then it transformed to an attempt to optimize away the famous bound checks, there are test examples in my PRs that should optimize the bound checks away in LLVM, but since LLVM is a black box and blocks with range checks and the following accesses are looking quite obvious in MIR I decided to go this way. So the current prototype tries to operate on a basis of logical relationships like “if we are in block bbX in CFG then we could only reach it from here, and in this case we have the following logical statements like _1 &lt; N, _2 = _1, so our statement Lt(_2, N) is always true and we can eliminate another terminator and just jump to the block of raw unsafe access by index”. This looks to work ok-ish and complexity is moderate, but for it I need more homogeneous MIR to start with, so slice::len were already patched into Len, now I’d want to preserve array length information for Len (otherwise in checks like “if i &lt; arr.len()” I get unsized cast + slice len, and in unsafe index access the comparison is between index and “const N”). Elimination of copies is useful in general and reduces the cost of trying to do such analysis because number of predicates reduced due to smaller numbers for copies and edges in a graph of relations. If I get all three prerequisites then there is a confidence that bound checks can be eliminated in MIR soundly and there will be less issues with “bound check is not eliminated”</p>",
        "id": 243724713,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624490121
    },
    {
        "content": "<p>Regarding the concrete performance - is there any existing tooling for it? I believe that those MIR passes are strictly producing “better” MIR (more constants, less calls, etc), and if LLVM works worse after this (e.g. it can perform some optimizations after monomorphization when array length is done via unsized case + slice length instead of having it as a constant) then it’s a little separate issue with LLVM that has to be fixed anyway</p>",
        "id": 243724939,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624490295
    },
    {
        "content": "<blockquote>\n<p>it’s a little separate issue with LLVM that has to be fixed anyway</p>\n</blockquote>\n<p>yes, you are right, but we still can't decrease compile-time performance (especially for check and debug builds) and say \"the regression is actually due to a different bug that we don't have a plan for fixing yet\". There are issues like slightly different MIR causing huge perf regressions in LLVM that we have been unable to properly track down. Some are due to random choices with cgu splitting, others are simply causing some LLVM opt to run in circles</p>",
        "id": 243728663,
        "sender_full_name": "oli",
        "timestamp": 1624493065
    },
    {
        "content": "<blockquote>\n<p>I believe that those MIR passes are strictly producing “better” MIR (more constants, less calls, etc)</p>\n</blockquote>\n<p>agreed, but if they cost performance at no measurable benefit, then that is an academic improvement. I do believe we will see actual improvements, just because it makes debug builds faster or rlibs smaller, but we don't have the infrastructure to track the latter. If nothing is improved by the mir opt except cleaner MIR, even with no compile time perf regression, should we add that mir opt? It is unclear to me, and wg-mir-opt has historically declined such new opts. We could change our stance here, but we need to discuss that separately from the specific opts here</p>",
        "id": 243728917,
        "sender_full_name": "oli",
        "timestamp": 1624493334
    },
    {
        "content": "<blockquote>\n<p>Regarding the concrete performance - is there any existing tooling for it?</p>\n</blockquote>\n<p>There is the lolbench project, but I think it has stalled (somewhat?)</p>",
        "id": 243728941,
        "sender_full_name": "oli",
        "timestamp": 1624493363
    },
    {
        "content": "<p>I've sent a short reply to the GitHub PR thread about keccak. Another interesting fact is that keccak is a good demo of how current const prop can eliminate all the bound checks there and reduce them down to <code>assert(true)</code></p>",
        "id": 243746909,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624516941
    },
    {
        "content": "<p>Also keccak (one that is tested, not the round function in all it's varieties) doesn't have const generics, so MIR pass would not affect it anyway, and the library function also would not affect it - there are no .len() calls</p>",
        "id": 243747142,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1624517173
    }
]