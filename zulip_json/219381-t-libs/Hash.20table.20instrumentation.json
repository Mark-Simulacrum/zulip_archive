[
    {
        "content": "<p>I have been doing some instrumentation of hash table use within rustc.</p>\n<p>When compiling <code>std</code>, here are the frequencies of length+capacity combinations when tables are dropped:</p>\n<div class=\"codehilite\"><pre><span></span><code>41644590 counts:\n(  1) 38525290 (92.5%, 92.5%): 0 0\n(  2)  1506303 ( 3.6%, 96.1%): 1 3\n(  3)   564473 ( 1.4%, 97.5%): 2 3\n(  4)   244728 ( 0.6%, 98.1%): 0 3\n(  5)   173150 ( 0.4%, 98.5%): 3 3\n(  6)   108308 ( 0.3%, 98.7%): 4 7\n(  7)    60820 ( 0.1%, 98.9%): 5 7\n(  8)    51134 ( 0.1%, 99.0%): 0 7\n(  9)    46309 ( 0.1%, 99.1%): 6 7\n( 10)    37448 ( 0.1%, 99.2%): 7 7\n( 11)    31143 ( 0.1%, 99.3%): 9 14\n( 12)    28999 ( 0.1%, 99.4%): 8 14\n( 13)    26947 ( 0.1%, 99.4%): 10 14\n( 14)    26793 ( 0.1%, 99.5%): 0 14\n( 15)    24586 ( 0.1%, 99.5%): 11 14\n( 16)    19417 ( 0.0%, 99.6%): 12 14\n( 17)    13869 ( 0.0%, 99.6%): 13 14\n( 18)    11418 ( 0.0%, 99.7%): 14 14\n( 19)     9303 ( 0.0%, 99.7%): 15 28\n( 20)     9259 ( 0.0%, 99.7%): 0 28\n</code></pre></div>",
        "id": 265955341,
        "sender_full_name": "nnethercote",
        "timestamp": 1640295348
    },
    {
        "content": "<p>92.5% of created hash tables never have anything inserted into them! A few years ago I made sure empty hash tables didn't allocate, no wonder that was a win.</p>",
        "id": 265955421,
        "sender_full_name": "nnethercote",
        "timestamp": 1640295394
    },
    {
        "content": "<p>Beyond that, most tables are tiny, which is interesting. I recently tried changing hashbrown so the minimum hash table capacity was bigger (I tried both 7 and 14). It was a small speed win (1-2% on some benchmarks) but increased heap usage by 5-10%. This explains why!</p>",
        "id": 265955589,
        "sender_full_name": "nnethercote",
        "timestamp": 1640295584
    },
    {
        "content": "<p>Also for compiling <code>std</code>, here are frequencies of length+capacity combinations when tables are looked up (I instrumented <code>RawTable::find</code>, which I think every lookup goes through):</p>\n<div class=\"codehilite\"><pre><span></span><code>221109668 counts:\n(  1) 19818913 ( 9.0%,  9.0%): 0 0\n(  2) 19692341 ( 8.9%, 17.9%): 1 3\n(  3)  7409283 ( 3.4%, 21.2%): 36019 57344\n(  4)  5395463 ( 2.4%, 23.7%): 0 3\n(  5)  3582184 ( 1.6%, 25.3%): 2 3\n(  6)  3474142 ( 1.6%, 26.9%): 25916 28672\n(  7)  2189300 ( 1.0%, 27.8%): 60382 114688\n(  8)  1872733 ( 0.8%, 28.7%): 3 3\n(  9)  1795835 ( 0.8%, 29.5%): 4 7\n( 10)  1616795 ( 0.7%, 30.2%): 8991 14336\n( 11)  1533138 ( 0.7%, 30.9%): 8497 14336\n( 12)  1513901 ( 0.7%, 31.6%): 8806 14336\n( 13)  1357577 ( 0.6%, 32.2%): 5 7\n( 14)  1259535 ( 0.6%, 32.8%): 6 7\n( 15)  1211176 ( 0.5%, 33.3%): 4804 7168\n( 16)  1129427 ( 0.5%, 33.9%): 7 7\n( 17)  1050352 ( 0.5%, 34.3%): 8 14\n( 18)  1033771 ( 0.5%, 34.8%): 981 1792\n( 19)   912617 ( 0.4%, 35.2%): 9 14\n( 20)   857619 ( 0.4%, 35.6%): 10 14\n</code></pre></div>",
        "id": 265955677,
        "sender_full_name": "nnethercote",
        "timestamp": 1640295671
    },
    {
        "content": "<p>Bigger tables are better represented, which is unsurprising. What <em>is</em> surprising is that &gt; 10% of all lookups are on empty tables! (With either capacity=0 or capacity=3)</p>",
        "id": 265955757,
        "sender_full_name": "nnethercote",
        "timestamp": 1640295727
    },
    {
        "content": "<p>I wonder what fraction of those are non-inserting lookups, where we could short-circuit things by just saying \"if table is empty, lookup fails\"</p>",
        "id": 265955826,
        "sender_full_name": "nnethercote",
        "timestamp": 1640295809
    },
    {
        "content": "<p>I recently looked at hashbrown and iirc Inserts go through <code>find_insert_slot</code>, not <code>find</code></p>",
        "id": 265956163,
        "sender_full_name": "The 8472",
        "timestamp": 1640296108
    },
    {
        "content": "<p>Wait no, inserts <em>also</em> go through <code>find</code> to check if the value exists, but then call <code>find_insert_slot</code> separately if it doesn't exist.</p>",
        "id": 265956201,
        "sender_full_name": "The 8472",
        "timestamp": 1640296151
    },
    {
        "content": "<p>I should instrument the outer functions in HashMap that don't modify. I think that's <code>get</code>, <code>get_key_value</code>, <code>contains_key</code>, <code>get_mut</code></p>",
        "id": 265956454,
        "sender_full_name": "nnethercote",
        "timestamp": 1640296385
    },
    {
        "content": "<p>They all route through <code>get_inner</code> or <code>get_inner_mut</code></p>",
        "id": 265956721,
        "sender_full_name": "nnethercote",
        "timestamp": 1640296650
    },
    {
        "content": "<p>All the <code>HashSet</code> sets route through <code>HashMap</code></p>",
        "id": 265957035,
        "sender_full_name": "nnethercote",
        "timestamp": 1640296875
    },
    {
        "content": "<p>Here are the stats for compiling <code>std</code>, just instrumenting <code>HashMap::get_inner{,_mut}</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>80448733 counts:\n(  1) 26907948 (33.4%, 33.4%): 0 0\n(  2)  3051386 ( 3.8%, 37.2%): 1 3\n(  3)  2209185 ( 2.7%, 40.0%): 2 3\n(  4)  2158504 ( 2.7%, 42.7%): 60382 114688\n(  5)  1287894 ( 1.6%, 44.3%): 3821 7168\n(  6)  1046516 ( 1.3%, 45.6%): 3 3\n(  7)  1011106 ( 1.3%, 46.8%): 4 7\n(  8)   741962 ( 0.9%, 47.8%): 5 7\n(  9)   728143 ( 0.9%, 48.7%): 6 7\n( 10)   684762 ( 0.9%, 49.5%): 7 7\n</code></pre></div>",
        "id": 265959384,
        "sender_full_name": "nnethercote",
        "timestamp": 1640298685
    },
    {
        "content": "<p>Do you have any stats for approximately how much non-codegen time is spent in hash table code, total?</p>",
        "id": 265959404,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640298716
    },
    {
        "content": "<p>One third of all lookups are on empty tables! And the code currently hashes the input unnecessarily, if I I'm reading the code correctly</p>",
        "id": 265959406,
        "sender_full_name": "nnethercote",
        "timestamp": 1640298717
    },
    {
        "content": "<p>Whoa! That's an awesome find!</p>",
        "id": 265959454,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640298737
    },
    {
        "content": "<p>one sec</p>",
        "id": 265959457,
        "sender_full_name": "nnethercote",
        "timestamp": 1640298739
    },
    {
        "content": "<p>I don't have good numbers, but I think it's at least a few percent</p>",
        "id": 265959555,
        "sender_full_name": "nnethercote",
        "timestamp": 1640298843
    },
    {
        "content": "<p>I'll just try adding a \"if is_empty, fail quickly\" test to those functions, see what happens, perf-wise</p>",
        "id": 265959575,
        "sender_full_name": "nnethercote",
        "timestamp": 1640298865
    },
    {
        "content": "<p>Hashing and hash tables are always one of the bigger things when you look at a bottom-up profile</p>",
        "id": 265959620,
        "sender_full_name": "nnethercote",
        "timestamp": 1640298910
    },
    {
        "content": "<p>There also are some uses that use raw tables/raw entries directly</p>",
        "id": 265959701,
        "sender_full_name": "The 8472",
        "timestamp": 1640298977
    },
    {
        "content": "<p>I'm really surprised that empty check is not already there. We do that in <code>indexmap</code>, but I thought we cribbed that from somewhere.</p>",
        "id": 265959707,
        "sender_full_name": "cuviper",
        "timestamp": 1640298982
    },
    {
        "content": "<p>@cuviper: I see that <a href=\"https://github.com/bluss/indexmap/blob/master/src/map.rs#L443-L453\">here</a>. Yeah, hashbrown doesn't have that check</p>",
        "id": 265960282,
        "sender_full_name": "nnethercote",
        "timestamp": 1640299606
    },
    {
        "content": "<p>Could also try skipping the hash calculation for a 1-element table (just using <code>Eq</code>), as an additional thing after the \"wait it's empty\" experiment.</p>",
        "id": 265960464,
        "sender_full_name": "scottmcm",
        "timestamp": 1640299816
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> What are the two numbers at the end of your stats lines? What is the 60382 114688 at the end of line 4?</p>",
        "id": 265961021,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300433
    },
    {
        "content": "<p>Oh, length/capacity?</p>",
        "id": 265961043,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300454
    },
    {
        "content": "<p>yes</p>",
        "id": 265961053,
        "sender_full_name": "nnethercote",
        "timestamp": 1640300463
    },
    {
        "content": "<p>So, 2.7% of lookups were in a table(s) with len=60382, cap=114688</p>",
        "id": 265961091,
        "sender_full_name": "nnethercote",
        "timestamp": 1640300499
    },
    {
        "content": "<p>So, there are a <em>bunch</em> of hash tables that all use that size? 2.7%?</p>",
        "id": 265961092,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300499
    },
    {
        "content": "<p>Probably a single table that is looked up many times</p>",
        "id": 265961097,
        "sender_full_name": "nnethercote",
        "timestamp": 1640300511
    },
    {
        "content": "<p>Oh, it's all one hash table and 2.7% of <em>lookups</em>.</p>",
        "id": 265961098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300511
    },
    {
        "content": "<p>It could be multiple tables, but for that len/cap combination it's probably not</p>",
        "id": 265961142,
        "sender_full_name": "nnethercote",
        "timestamp": 1640300527
    },
    {
        "content": "<p>Do you have any easy way to check if there are hash table lengths (not capacities) above (say) 1024 that are duplicated?</p>",
        "id": 265961153,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300537
    },
    {
        "content": "<p>I can imagine that there may be more than one hash table in the compiler of the same size, if it's information proportional to the same thing.</p>",
        "id": 265961185,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300569
    },
    {
        "content": "<p>(when compiling the same code)</p>",
        "id": 265961191,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300576
    },
    {
        "content": "<p>I could add a unique table ID to the output line. What question are you trying to answer?</p>",
        "id": 265961203,
        "sender_full_name": "nnethercote",
        "timestamp": 1640300584
    },
    {
        "content": "<p>Rationale: if those tables grow at around the same time in execution, we could keep a 2-3 entry cache of \"specific large sizes that might get repeated\", and if we see a table grow to about that size, we could pick a capacity accordingly and we'd be more likely to nail the ideal capacity.</p>",
        "id": 265961292,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300661
    },
    {
        "content": "<p>\"I'm about to double a table from 8192 to 16384. Turns out recently I saw a table that needed 16400 entries. Why don't I overshoot a bit?\"</p>",
        "id": 265961318,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300687
    },
    {
        "content": "<p>(Which would avoid ending up with a length/capacity of 16400/32768.)</p>",
        "id": 265961365,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640300723
    },
    {
        "content": "<p>Sounds... bespoke <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 265962300,
        "sender_full_name": "nnethercote",
        "timestamp": 1640301735
    },
    {
        "content": "<p>Adding the is_empty check is a small but clear win for rustc, in terms of instruction counts:</p>\n<div class=\"codehilite\"><pre><span></span><code>unused-warnings check   incr-full   -1.36%  6.80x\nexterns check   incr-full   -1.03%  5.14x\nmany-assoc-items check  incr-full   -0.97%  4.84x\ntuple-stress check  full    -0.77%  3.87x\ntuple-stress check  incr-full   -0.74%  3.72x\ninflate check   incr-unchanged  -0.73%  3.64x\ntuple-stress check  incr-patched: new row   -0.70%  3.48x\nkeccak check    incr-unchanged  -0.68%  3.40x\nderive check    incr-full   -0.66%  3.32x\nmatch-stress-exhaustive_patterns check  incr-full   -0.66%  3.30x\nmatch-stress-enum check     incr-unchanged  -0.64%  3.18x\nwf-projection-stress-65510 check    incr-full   -0.56%  2.80x\nfutures check   incr-full   -0.56%  2.78x\ntokio-webpush-simple check  incr-full   -0.53%  2.66x\nclap-rs check   incr-unchanged  -0.53%  2.64x\nstm32f4 check   incr-full   -0.53%  2.63x\nissue-88862 check   incr-full   -0.52%  2.59x\nderive check    incr-unchanged  -0.49%  2.46x\nregex check     incr-full   -0.49%  2.45x\nsyn check   incr-full   -0.49%  2.44x\nunused-warnings check   incr-unchanged  -0.49%  2.43x\nripgrep check   incr-full   -0.48%  2.40x\nencoding check  incr-full   -0.48%  2.38x\nissue-58319 check   incr-full   -0.47%  2.36x\nwebrender-wrench check  incr-full   -0.45%  2.25x\nmatch-stress-exhaustive_patterns check  full    -0.45%  2.25x\nregression-31157 check  incr-full   -0.45%  2.23x\nhyper-2 check   incr-full   -0.44%  2.21x\nexterns check   incr-unchanged  -0.43%  2.17x\nclap-rs check   incr-patched: println   -0.43%  2.13x\nstm32f4 check   incr-unchanged  -0.42%  2.12x\nmatch-stress-exhaustive_patterns check  incr-unchanged  -0.42%  2.12x\nunused-warnings check   incr-patched: dummy fn  -0.42%  2.11x\nwebrender check     incr-full   -0.42%  2.10x\nwf-projection-stress-65510 check    incr-unchanged  -0.42%  2.08x\nissue-46449 check   incr-full   -0.41%  2.04x\nucd check   incr-unchanged  -0.41%  2.03x\nclap-rs check   incr-full   -0.40%  1.98x\nrepro_crate check   incr-full   -0.39%  1.96x\npiston-image check  incr-full   -0.37%  1.87x\nunicode_normalization check     incr-full   -0.37%  1.85x\nrepro_crate check   full    -0.37%  1.85x\nrepro_crate check   incr-unchanged  -0.34%  1.68x\ncoercions check     full    -0.33%  1.67x\nderive check    full    -0.33%  1.65x\nunicode_normalization check     full    -0.33%  1.64x\ncoercions check     incr-full   -0.32%  1.61x\nunicode_normalization check     incr-patched: println   -0.31%  1.56x\nserde check     incr-full   -0.31%  1.56x\n</code></pre></div>",
        "id": 265962393,
        "sender_full_name": "nnethercote",
        "timestamp": 1640301851
    },
    {
        "content": "<p>Shame we don't have a perf suite for a broader set of rust programs.</p>",
        "id": 266003204,
        "sender_full_name": "scottmcm",
        "timestamp": 1640353713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/219381-t-libs/topic/Hash.20table.20instrumentation/near/265961365\">said</a>:</p>\n<blockquote>\n<p>(Which would avoid ending up with a length/capacity of 16400/32768.)</p>\n</blockquote>\n<p>Isn't the capacity of an hashtable always a power of 2? (The actual capacity allocated, not the one shown with <code>.capacity()</code>)</p>",
        "id": 266014916,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1640367245
    },
    {
        "content": "<p>with_capacity constructor allows for non-power-of-two capacities.</p>",
        "id": 266059863,
        "sender_full_name": "nagisa",
        "timestamp": 1640439602
    },
    {
        "content": "<p>(thats true for both the rust view and allocator view of allocation size)</p>",
        "id": 266059902,
        "sender_full_name": "nagisa",
        "timestamp": 1640439663
    },
    {
        "content": "<p>The raw table capacity is forced to be a power of 2 so the hash can be simply bitmasked to get the index. Your requested capacity is rounded up to 7/8 of a power of 2 for the maximum load factor.</p>",
        "id": 266061035,
        "sender_full_name": "cuviper",
        "timestamp": 1640441562
    }
]