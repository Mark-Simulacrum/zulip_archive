[
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/93967\">#93967</a> suggests to use <code>guess_head_span</code> in the implementation of the <code>def_span</code>query. However, I fear that using the source_map may be hazardous for incr. comp. The source text behind a span is not tracked anywhere, only the file name, line &amp; column numbers. As the span may get into the crate metadata, this will also create an ICE in downstream crates.</p>\n<p>There are three possibilities:</p>\n<ol>\n<li>make source_map a (no_hash eval_always) query and hash source tokens as part of the crate hash;</li>\n<li>make source_map a (no_hash eval_always) query and compute crate hash from encoded metadata;</li>\n<li>forbid accessing the source map outside of diagnostic code (using a delay_span_bug for example);</li>\n<li>ignore the problem until someone hits an ICE.</li>\n</ol>\n<p>I think the most future-proof solution is (2), but it may incur a significant runtime cost.<br>\n<span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> <span class=\"user-mention\" data-user-id=\"124287\">@mw</span> I'd like your opinion on this.</p>",
        "id": 272001384,
        "sender_full_name": "cjgillot",
        "timestamp": 1644943364
    },
    {
        "content": "<p>The source map is already included in the crate hash I believe.</p>",
        "id": 272011697,
        "sender_full_name": "bjorn3",
        "timestamp": 1644947307
    },
    {
        "content": "<p>I think 3. makes sense. Accessing the source map pessimizes incremental compilation as every change to the source will cause the respective query to run again.</p>",
        "id": 272011824,
        "sender_full_name": "bjorn3",
        "timestamp": 1644947378
    },
    {
        "content": "<p>The crate hash contains the source file names, but it does not contain the source contents, does it?</p>",
        "id": 272012229,
        "sender_full_name": "cjgillot",
        "timestamp": 1644947545
    },
    {
        "content": "<p>you're right. <a href=\"https://github.com/rust-lang/rust/blob/24b8bb13bff98bb747cd403b86596af43aceee78/compiler/rustc_middle/src/hir/map/mod.rs#L1104\">https://github.com/rust-lang/rust/blob/24b8bb13bff98bb747cd403b86596af43aceee78/compiler/rustc_middle/src/hir/map/mod.rs#L1104</a></p>",
        "id": 272012817,
        "sender_full_name": "bjorn3",
        "timestamp": 1644947815
    },
    {
        "content": "<p>I opened a related issue a while back</p>",
        "id": 272014335,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644948397
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/86480\">https://github.com/rust-lang/rust/issues/86480</a></p>",
        "id": 272014375,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1644948415
    },
    {
        "content": "<p>Is the underlying problem that <code>guess_head_span</code> relies on the string contents of something from the source map (and those string contents are not fingerprinted anywhere)?</p>",
        "id": 272031569,
        "sender_full_name": "mw",
        "timestamp": 1644956015
    },
    {
        "content": "<p>Yes.</p>",
        "id": 272034055,
        "sender_full_name": "cjgillot",
        "timestamp": 1644957262
    },
    {
        "content": "<p>This is true for all span manipulation functions that use the source_map, not just guess_head_span.</p>",
        "id": 272034086,
        "sender_full_name": "cjgillot",
        "timestamp": 1644957288
    },
    {
        "content": "<blockquote>\n<p>compute crate hash from encoded metadata;</p>\n</blockquote>\n<p>Can you elaborate on what you mean by this exactly and how it would solve the problem?</p>",
        "id": 272100610,
        "sender_full_name": "mw",
        "timestamp": 1645009056
    },
    {
        "content": "<p>There are 2 issues.<br>\nInside one crate, we can force re-evaluation of queries that depend on source_map data by making it a no-hash eval-always query.<br>\nAcross crates, the query system relies on a foreign crate's <code>crate_hash</code> to know if data should be loaded. At the moment, crate_hash is computed from HIR. As source text is not in HIR, changes to source text will not change chrate_hash, but may still influence guess_head_span. We could compute it from metadata itself (or a sanitized version of it), which would ensure that we never miss anything in metadata.</p>",
        "id": 272142358,
        "sender_full_name": "cjgillot",
        "timestamp": 1645030118
    },
    {
        "content": "<p>There's an additional issue - guess_head_span for foreign files actually reads from the file on disk, not the crate metadata</p>",
        "id": 272142961,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645030378
    },
    {
        "content": "<p>A hash of each source file is included in the source map as encoded in the crate metadata. That doesn't help with missing or changed source files though as reading the source will fail in that case.</p>",
        "id": 272143244,
        "sender_full_name": "bjorn3",
        "timestamp": 1645030492
    },
    {
        "content": "<blockquote>\n<p>There's an additional issue - guess_head_span for foreign files actually reads from the file on disk, not the crate metadata</p>\n</blockquote>\n<p>If the crate hash somehow captures any changes that might be relevant for guess_head_span, then that would only be a problem, if we re-compiled a crate without first also re-compiling its dependencies, right?</p>",
        "id": 272235295,
        "sender_full_name": "mw",
        "timestamp": 1645091121
    },
    {
        "content": "<blockquote>\n<p>Inside one crate, we can force re-evaluation of queries that depend on source_map data by making it a no-hash eval-always query.<br>\nYes, it sounds to me like making the source map no_hash + eval_always would take care of the problem inside the current crate.</p>\n</blockquote>\n<blockquote>\n<p>Across crates, ...</p>\n</blockquote>\n<p>At some point in the past, we computed fingerprints while generating crate metadata. It required quite a bit of additional infrastructure and we removed it because it was a bit of a maintenance burden without providing that much of a benefit. Removing it also solved a few bugs we had then -- but that doesn't mean a new, clean implementation of the same thing would also have to have these problems. A benefit would be that fingerprints for a given crate only have to be computed once instead of every time something is loaded from that crate. A downside is that you have to compute fingerprints for everything in crate metadata, even if that thing is never used downstream.</p>\n<p>I'm wondering though: is there a big downside to straight-up including  a hash of all source files in the crate hash? We would get some false positives if  there are only insignificant whitespace changes -- but almost all changes that are likely to happen are significant, right? And the main case, where a crate is recompiled without any change, would be unaffected. If we hash source files, we might even get around hashing the HIR altogether. But maybe I'm missing something.</p>",
        "id": 272237005,
        "sender_full_name": "mw",
        "timestamp": 1645092050
    }
]