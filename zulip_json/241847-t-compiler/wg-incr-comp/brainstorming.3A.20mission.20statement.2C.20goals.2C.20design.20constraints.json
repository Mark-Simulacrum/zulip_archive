[
    {
        "content": "<p>this is a brainstorming thread</p>",
        "id": 201984120,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593098796
    },
    {
        "content": "<p>so I don't know if this is going to end up being an area subteam or a project subteam</p>",
        "id": 201984211,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593098841
    },
    {
        "content": "<p>it sort of depends on whether we turn into a group of local experts on everything related to incr-comp</p>",
        "id": 201984240,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593098859
    },
    {
        "content": "<p>or if we just decide on a specific set of tasks that we're going to do, and once they're done, we disband</p>",
        "id": 201984269,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593098876
    },
    {
        "content": "<p>in any case, here are some thoughts that have been bouncing around my head for some number of days</p>",
        "id": 201984428,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593098941
    },
    {
        "content": "<p>some of these are things I've already talked about with <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> but want to record more publicly</p>",
        "id": 201984461,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593098957
    },
    {
        "content": "<p>(I don't have much of an opinion regarding these questions, I'm primarily interested in showing up at a meeting each week (or w/e), being given some tasks to do, and gaining expertise in incr-comp through that - whatever everyone else's goals are, that works for me)</p>",
        "id": 201984474,
        "sender_full_name": "davidtwco",
        "timestamp": 1593098964
    },
    {
        "content": "<p>others are more little musings that I'm still working through</p>",
        "id": 201984489,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593098970
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> that's no problem. I just figure this can be a space for people to write down their thoughts. Or respond to mine. Or maybe it will just be a void that I send messages off into.</p>",
        "id": 201984596,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099006
    },
    {
        "content": "<p>The first thing I want to bring up: I recently mentioned to niko how we might be better served in incremental compilation</p>",
        "id": 201984659,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099040
    },
    {
        "content": "<p>if we used some sort of \"predictive model\" to anticipate which modules/fn's are most likely to be editted in the future</p>",
        "id": 201984691,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099059
    },
    {
        "content": "<p>and keep those in a separate cgu</p>",
        "id": 201984706,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099064
    },
    {
        "content": "<p>from the unchanging code</p>",
        "id": 201984723,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099075
    },
    {
        "content": "<p>obviously we cannot predict the future, but I would guess that the modules in files that have been most recently edited are ones likely to change in the future</p>",
        "id": 201984771,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099106
    },
    {
        "content": "<p>when I mentioned this to <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> , they responded that one of the oldest design crietria for incr-comp is that it is deterministic</p>",
        "id": 201984881,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099143
    },
    {
        "content": "<p>i.e. the edit history should not matter for the final object code files you get out</p>",
        "id": 201984928,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> specifically pointed out that the incr-comp system, at least originally, had testing where they went through the commit history for a set of projects and checked that incr rebuilds after each commit had same object output as building from scratch at that commit</p>",
        "id": 201985090,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099242
    },
    {
        "content": "<p>So all of this is to say: Do we think this is a property we should ensure we preserve? Or should we consider, e.g., having a opt-in flag where a user can say \"go ahead and make cgu partitioning decisions that depend on details such as file timestamps\"?</p>",
        "id": 201985240,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099308
    },
    {
        "content": "<p>That's sort of a big picture question, and I imagine a change to that design criteria would have to be approved by rest of rustc team</p>",
        "id": 201985337,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099356
    },
    {
        "content": "<p>Was the goal for reproducible builds or something else?</p>",
        "id": 201985343,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593099358
    },
    {
        "content": "<p>It sounds a bit like that would make reproducing incr. comp. bugs even harder than it already is</p>",
        "id": 201985356,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1593099362
    },
    {
        "content": "<p>I think it was for reproducible builds, yes, exactly</p>",
        "id": 201985425,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099380
    },
    {
        "content": "<p>and I had a reaction of \"I think that ship has sailed\"</p>",
        "id": 201985462,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099392
    },
    {
        "content": "<p>(which is when <span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> gave the example of the commit history test)</p>",
        "id": 201985485,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099409
    },
    {
        "content": "<p>I don't remember offhand if there were other motivations besides reproducibility of builds, and also bugs (which may or may not be a corollary)</p>",
        "id": 201985546,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099442
    },
    {
        "content": "<p>anyway any work we did here would definitely have to show huge benefits before it could get buy-in, I imagine</p>",
        "id": 201985661,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099478
    },
    {
        "content": "<p>but given how much time of compiling e.g. <code>rustc_middle</code> is spent in LLVM codegen</p>",
        "id": 201985791,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099491
    },
    {
        "content": "<p>its something that I keep thinking about</p>",
        "id": 201985844,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099501
    },
    {
        "content": "<p>It seems like most of the use cases that care about reproducible builds are batch compilation sessions anyway. But yeah, I agree that would probably make repro-ing incr. comp bugs more difficult.</p>",
        "id": 201985861,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593099506
    },
    {
        "content": "<p>While reproducible builds are great, and we should want them, I think it would be reasonable for debug builds where you're just working locally to forgo that.</p>",
        "id": 201985873,
        "sender_full_name": "davidtwco",
        "timestamp": 1593099513
    },
    {
        "content": "<p>having said that, there may be other ways to get similar benefits</p>",
        "id": 201985892,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099522
    },
    {
        "content": "<p>in particular, something <em>else</em> I was thinking about</p>",
        "id": 201985919,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099532
    },
    {
        "content": "<p>(by the way, I may make statements here that are bogus. please do correct me if so)</p>",
        "id": 201985972,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099552
    },
    {
        "content": "<p>the other thing I was thinking about: Right now, if i understand correctly, we have a cgu parititioning system where we have a hard limit on the number of cgu's</p>",
        "id": 201986070,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099598
    },
    {
        "content": "<p>we start with a large set of cgui's and merge them in order to stay under that bound, call it <em>N</em></p>",
        "id": 201986152,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099618
    },
    {
        "content": "<p>and that is set by profiles in cargo</p>",
        "id": 201986364,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099704
    },
    {
        "content": "<p>where the default is 256 for incremental builds and 16 for non-incremental (for parallel codegen purposes)</p>",
        "id": 201986452,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099728
    },
    {
        "content": "<p>so heres my point</p>",
        "id": 201986467,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099732
    },
    {
        "content": "<p>what if, instead of having a fixed number</p>",
        "id": 201986481,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099738
    },
    {
        "content": "<p>we instead had it scale up with crate size</p>",
        "id": 201986500,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099749
    },
    {
        "content": "<p>or, if you prefer, we had a max codegen-unit size</p>",
        "id": 201986516,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099758
    },
    {
        "content": "<p>that is, a max size for each codegen unit</p>",
        "id": 201986528,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099767
    },
    {
        "content": "<p>and so the merging would be about putting the smaller stuff together</p>",
        "id": 201986564,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099783
    },
    {
        "content": "<p>this is all a very long way of saying</p>",
        "id": 201986579,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099792
    },
    {
        "content": "<p>right now, the time spent doing codegen</p>",
        "id": 201986597,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099801
    },
    {
        "content": "<p>is going to be O(C) where C is the size of your crate</p>",
        "id": 201986626,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099814
    },
    {
        "content": "<p>even when you turn on incremetnal, its still O(C)</p>",
        "id": 201986647,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099823
    },
    {
        "content": "<p>(its \"just\" cut by that constant factor)</p>",
        "id": 201986728,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099851
    },
    {
        "content": "<p>but if the policy were instead to have a max codegen-unit size</p>",
        "id": 201986778,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099879
    },
    {
        "content": "<p>then time spent doing codegen should be O(E*S), where E is number of edits and S is that max codegen-unit size</p>",
        "id": 201986840,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099906
    },
    {
        "content": "<p>I think in general that's a good idea but there's a few things I ran into when I played with that idea:</p>\n<ul>\n<li>\n<p>For release cases, you really don't want to split call graphs over multiple CGUs because it kills LLVM's optimization abilities (ThinLTO I think recovers some of those losses but I don't know much about it).</p>\n</li>\n<li>\n<p>For debug cases, right now you sometimes get lucky and the code you're modifying is in a tiny CGU. By making the CGUs more equal in size, you're going to hurt those cases (but hopefully still improve the average case).</p>\n</li>\n</ul>",
        "id": 201986901,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593099929
    },
    {
        "content": "<p>I agree you don't want to split call graphs if you can. That could hopefully be addressed by making the merge algorithm smarter</p>",
        "id": 201987027,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099971
    },
    {
        "content": "<p>the \"get lucky and have thing in tiny CGU\" case ... does that actually happen today?</p>",
        "id": 201987083,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593099999
    },
    {
        "content": "<p>Yeah</p>",
        "id": 201987106,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100009
    },
    {
        "content": "<p>I was under impression that, since the cgu merge system is geared towards load balancing</p>",
        "id": 201987117,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100015
    },
    {
        "content": "<p>that you would tend to have small stuff all collected together</p>",
        "id": 201987144,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100027
    },
    {
        "content": "<p>If your function is not polymorphic, it tends to end up in one of the smaller CGUs</p>",
        "id": 201987149,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100030
    },
    {
        "content": "<p>hmm</p>",
        "id": 201987154,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100034
    },
    {
        "content": "<p>Not always</p>",
        "id": 201987156,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100034
    },
    {
        "content": "<p>but often I'd say</p>",
        "id": 201987171,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100042
    },
    {
        "content": "<p>that's interesting</p>",
        "id": 201987178,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100048
    },
    {
        "content": "<p>if anything, its an argument for the predictive modelling I mentioned up above</p>",
        "id": 201987209,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100064
    },
    {
        "content": "<p>the other thing I was thinking, regarding max codegen size</p>",
        "id": 201987297,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100094
    },
    {
        "content": "<p>Does that fall out from generic and non-generic items being in different codegen units in the initial set and then there just being more generic code in most projects?</p>",
        "id": 201987299,
        "sender_full_name": "davidtwco",
        "timestamp": 1593100095
    },
    {
        "content": "<p>I think so yeah</p>",
        "id": 201987326,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/201987297\">said</a>:</p>\n<blockquote>\n<p>the other thing I was thinking, regarding max codegen size</p>\n</blockquote>\n<p>... instead of having it be a predetermined number, the number could be computed by the contents of the crate. E.g. take the largest fn in the crate, multiply its size by 10 (or some other factor K), and then use that as the target cgu size.</p>",
        "id": 201987469,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100179
    },
    {
        "content": "<p>I'm honestly not sure whether that will hurt or help overall, but it at least seems like it has a chance to being adaptive to peoples coding styles</p>",
        "id": 201987571,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100219
    },
    {
        "content": "<p>Yeah, I think scaling the number of CGUs by the size of the crate (however that's determined) is a good idea</p>",
        "id": 201987583,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100232
    },
    {
        "content": "<p>if nothing else, it has a nice asymptotic growth argument behind it.</p>",
        "id": 201987627,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100258
    },
    {
        "content": "<p>perfect for academic papers</p>",
        "id": 201987649,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100268
    },
    {
        "content": "<p>There's already some code-size heuristic computed in partitioning to determine which codegen units are smallest and should be merged, right?</p>",
        "id": 201987665,
        "sender_full_name": "davidtwco",
        "timestamp": 1593100280
    },
    {
        "content": "<p>I assume that could be used to determine the size of an entire crate.</p>",
        "id": 201987715,
        "sender_full_name": "davidtwco",
        "timestamp": 1593100305
    },
    {
        "content": "<p>One project I've been thinking about doing is refactoring <code>partitioning.rs</code> so that the actual algorithm is hidden behind a trait which would let us swap out different algorithms in a cleaner way. Potentially we could have unstable flags for choosing the algorithm for testing.</p>",
        "id": 201987717,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100305
    },
    {
        "content": "<p>yes. it is only an estimate</p>",
        "id": 201987723,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100306
    },
    {
        "content": "<p>That would also give us a framework for having algorithms for different build configurations.</p>",
        "id": 201987775,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1593100322
    },
    {
        "content": "<p>(and I've seen some issues where people grumble about inaccuracies in the estimate)</p>",
        "id": 201987804,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100327
    },
    {
        "content": "<p>okay. I need to go afk for a bit. thanks for letting me bounce these ideas off of you all.</p>",
        "id": 201987945,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593100398
    },
    {
        "content": "<p>Something I'd like to see as well (I think <span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> was experimenting with this concept) is experimentation with large numbers of CGUs for incremental compilation</p>",
        "id": 202003516,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593108128
    },
    {
        "content": "<p>Like, the numbers that we have today are sort of magic numbers</p>",
        "id": 202003541,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593108146
    },
    {
        "content": "<p>(To pick the numbers and size of CGUs)</p>",
        "id": 202003575,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593108169
    },
    {
        "content": "<p>I would like to see how small can we make the CGUs before we lose incremental compilation performance</p>",
        "id": 202003633,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593108203
    },
    {
        "content": "<p>Because the smaller they are, the more the incremental compilation times should mimic the size of the edit, is that correct?</p>",
        "id": 202003782,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593108280
    },
    {
        "content": "<p>And hopefully, I think, we would like incr. comp time to be related to the size of the edits, i.e. small edits should make recompilation almost trivial</p>",
        "id": 202003898,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593108345
    },
    {
        "content": "<p>Just thought of another drawback of making incr. comp. nondeterministic: It would become impossible to use it to build code for benchmarking.</p>",
        "id": 202085110,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1593175802
    },
    {
        "content": "<p>This is something I do all day at the moment, and having to wait even longer to run benchmarks would be very unfortunate</p>",
        "id": 202085181,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1593175847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211727\">Jonas Schievink</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/202085110\">said</a>:</p>\n<blockquote>\n<p>Just thought of another drawback of making incr. comp. nondeterministic: It would become impossible to use it to build code for benchmarking.</p>\n</blockquote>\n<p>I don't think it would become _impossible_. It would become quite a lot harder though. We'd need a long time to run benchmarks multiple times, and do statistical analysis over the sample. </p>\n<p>And there's an argument to be said that we need to do that already (measuring performance of a deterministic program is already quite hard).</p>",
        "id": 202108918,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593187195
    },
    {
        "content": "<p>But if you change the program and want to estimate the performance impact of that change, non-deterministic incr. comp. wouldn't just mean you have to run it more often, it means you have to turn incr. comp. off completely, since it depends on the changes to the source code. Not even recompiling multiple times would help (since nothing has changed since the last rebuild).</p>",
        "id": 202110028,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1593187711
    },
    {
        "content": "<p>(you raise a good point though – this is another reason why reproducible builds are important)</p>",
        "id": 202110297,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1593187862
    },
    {
        "content": "<blockquote>\n<p>If you change the program and want to estimate the performance impact of that change</p>\n</blockquote>\n<p>Ahh, I get what you mean now. I was thinking of measurements to incr. compilation times (in the context of developing the compiler), but you mean measuring performance of another Rust project that's being compiled. Yas, that's totally right. The performance impact would have to be measured against the from-scratch compiled binary, because the incr. comp. binary would depend on the compilation history, yes yes yes yes.</p>",
        "id": 202112302,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593188849
    },
    {
        "content": "<p>Should \"querify earlier stages of compilation\" be one of the goals?</p>",
        "id": 202294046,
        "sender_full_name": "gizmondo",
        "timestamp": 1593427523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211727\">Jonas Schievink</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/202085110\">said</a>:</p>\n<blockquote>\n<p>Just thought of another drawback of making incr. comp. nondeterministic: It would become impossible to use it to build code for benchmarking.</p>\n</blockquote>\n<p>my latest thinking here is that we could get around this by providing an easy way to recreate a given incremental compilation context. E.g. a <code>-Z</code> flag where you explicitly say \"treat this listed set of files as recently changed, and all others as not recently changed.\" That, combined with some automated messaging from the compiler <em>saying</em> what those sets are on a given compiler run, would let us recreate incremental build contexts that incorporate history without losing determinism.</p>",
        "id": 202346721,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593453666
    },
    {
        "content": "<p>But that's a bit coarse-grained, isn't it? After all, incr-comp changes depending on how much and where each file was changed.</p>",
        "id": 202347619,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593454104
    },
    {
        "content": "<p>Like afaik just introducing a println! call can currently affect the next incr comp step substantially</p>",
        "id": 202347681,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593454148
    },
    {
        "content": "<p>But other changes to the same file are trivial to recompile</p>",
        "id": 202347727,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593454183
    },
    {
        "content": "<p>well, <em>if</em> we can come up with some reasonable way for a human to encode the context, then one can imagine using something more fine-grained than just file timestamps</p>",
        "id": 202348067,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593454346
    },
    {
        "content": "<p>my main point was that we need not give up on reproducibility</p>",
        "id": 202348106,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593454366
    },
    {
        "content": "<p>(however, if it requires a very long string of text to encode the context informing the incremental compile, then this is perhaps not realistic.)</p>",
        "id": 202348208,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593454428
    },
    {
        "content": "<p>(one thought I've just had - might be worth scheduling a meeting/session describing what the incr-comp infrastructure looks like within the compiler today; gets everyone up to speed as the working group starts to do things + you can refer back to it with new folks, or for a refresher)</p>",
        "id": 202348484,
        "sender_full_name": "davidtwco",
        "timestamp": 1593454549
    },
    {
        "content": "<p>Yeah, I'm thinking that perhaps the minimum equivalent representation of the problem for the goal of reproducibility is a diff history, a bit like a git commit chain (caveat: I know that git doesn't actually work as patch-based diff chains, but for this purpose it can be thought of in that way)</p>",
        "id": 202348487,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593454550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"251406\">gizmondo</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/202294046\">said</a>:</p>\n<blockquote>\n<p>Should \"querify earlier stages of compilation\" be one of the goals?</p>\n</blockquote>\n<p>This probably should indeed be one of the goals</p>",
        "id": 202348566,
        "sender_full_name": "pnkfelix",
        "timestamp": 1593454572
    },
    {
        "content": "<p>I'm mainly concerned about users who want to <code>cargo bench</code> their code, and turn on incr. comp. at the same time (which would become the default once <a href=\"https://github.com/rust-lang/rust/issues/57968\">#57968</a> is resolved). For those users, the executable they get would depend on recent changes, which sounds undesirable. If a <code>-Z</code> flag is provided to override this behavior, I'm not sure how people would find out about it.</p>",
        "id": 202348980,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1593454787
    },
    {
        "content": "<p>Yeah, <code>-Z</code> flags should not be where the best option for normal users lie</p>",
        "id": 202349134,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1593454849
    },
    {
        "content": "<p>(some projects enable this kind of setup today because they are trying to find a balance between compile times and runtime performance, rust-analyzer is one example, but this is common for game dev too, I believe)</p>",
        "id": 202349190,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1593454880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116107\">davidtwco</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/202348484\">said</a>:</p>\n<blockquote>\n<p>(one thought I've just had - might be worth scheduling a meeting/session describing what the incr-comp infrastructure looks like within the compiler today; gets everyone up to speed as the working group starts to do things + you can refer back to it with new folks, or for a refresher)</p>\n</blockquote>\n<p>I've never replied to this message but I thought I have done so :P, I was talking with <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> some days ago exactly about this, so huge <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 202839198,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1593813714
    },
    {
        "content": "<p>Making incr. comp. non-deterministic sounds <em>awful</em> to me. It would make all sorts of things harder, such as profiling.</p>",
        "id": 203664773,
        "sender_full_name": "njn",
        "timestamp": 1594594026
    },
    {
        "content": "<p>uhh, what's this about? I wasn't here when the conversation took place</p>",
        "id": 203668558,
        "sender_full_name": "eddyb",
        "timestamp": 1594600559
    },
    {
        "content": "<p>is this specifically just about CGU partitioning?</p>",
        "id": 203668598,
        "sender_full_name": "eddyb",
        "timestamp": 1594600565
    },
    {
        "content": "<p>at least that part I'm less worried about, compared to the query system</p>",
        "id": 203668607,
        "sender_full_name": "eddyb",
        "timestamp": 1594600588
    },
    {
        "content": "<p>Oh, it says above that \"deterministic\" means \"the edit history should not matter for the final object code files you get out\". That's much stronger than what I was thinking of</p>",
        "id": 203670229,
        "sender_full_name": "njn",
        "timestamp": 1594603379
    },
    {
        "content": "<p>hmm, this shouldn't matter for most of the compiler, right? just codegen and beyond?</p>",
        "id": 203673642,
        "sender_full_name": "eddyb",
        "timestamp": 1594609055
    },
    {
        "content": "<p>okay found the start of the non-determinism discussion: <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/201984881\">https://rust-lang.zulipchat.com/#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/201984881</a></p>",
        "id": 203673717,
        "sender_full_name": "eddyb",
        "timestamp": 1594609164
    },
    {
        "content": "<p>okay yeah seems to be able CGUs, since if they're based on the state of the code when you first compiled the crate, and don't change when you recompile, would not be identical for different edit histories</p>",
        "id": 203673789,
        "sender_full_name": "eddyb",
        "timestamp": 1594609245
    },
    {
        "content": "<p>at least it can't (or shouldn't be able to) affect query system behavior in ways in which I care about - even if there are other problems with \"edit history sensitive\" CGUs</p>",
        "id": 203673840,
        "sender_full_name": "eddyb",
        "timestamp": 1594609324
    },
    {
        "content": "<p>Yeah my main focus (when I was talking about using the edit history) was CGUs.</p>",
        "id": 203736391,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594657404
    },
    {
        "content": "<p>now, that may still affect things we care about. When <span class=\"user-mention\" data-user-id=\"120989\">@njn</span> said \"profiling\" above, I don't know if that was in reference to profile-guided optimization (PGO), or if it was \"just\" about manual inspection of performance profiles</p>",
        "id": 203736600,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594657506
    },
    {
        "content": "<p>I suspect messing with the CGUs would probably totally screw up PGO</p>",
        "id": 203736632,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594657530
    },
    {
        "content": "<p>I mean, if we have two identical scenarios (in terms of what gets compiled, changed, recompiled, etc., after starting from a fresh codebase), I want to have identical (or very nearly identical) behaviour. Which is what we currently have. E.g. look at the <code>incr-patched</code> benchmarks.</p>",
        "id": 203780690,
        "sender_full_name": "njn",
        "timestamp": 1594680315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@njn</span> if a \"scenario\" includes the edit history, then my intent was that determinism would be retained. (I was further musing to go a step further, and have some succinct encoding of the historical context that the compiler could emit and read back in, to ease reconstruction of scenarios)</p>",
        "id": 203783434,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594682735
    },
    {
        "content": "<p>that is, the \"non-determinism\" I was referring to was that the edit history could affect the output, and for some people, that implies unpredictability</p>",
        "id": 203783483,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594682774
    },
    {
        "content": "<p>So you're saying that this non determinism would behave like a seeded RNG:</p>\n<ul>\n<li>The seed is the change history of the incr-compiled code.</li>\n<li>The LLVM IR generated by this process can be described by a certain random distribution (could have really small, greater than zero variance, and still count)</li>\n<li>The ONLY thing that determines the IR that gets generated for a certain sample of code, is its change history.<br>\nDid I get you right, <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span>?</li>\n</ul>",
        "id": 203801841,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594707353
    },
    {
        "content": "<p>The third point implies that if you have two identical histories, the IR generated for both of them would be the same.</p>",
        "id": 203801909,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594707457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"212698\">@Félix Fischer</span> I thought the \"change history\" is only relevant because of statefulness, not because it exists as an input</p>",
        "id": 203804111,
        "sender_full_name": "eddyb",
        "timestamp": 1594710184
    },
    {
        "content": "<p>Yeah yeah yeah</p>",
        "id": 203804122,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710201
    },
    {
        "content": "<p>simplest way I can imagine this is some information computed when first compiling incrementally, that is preserved instead of updated</p>",
        "id": 203804129,
        "sender_full_name": "eddyb",
        "timestamp": 1594710204
    },
    {
        "content": "<p>I'm modeling it as an equivalent problem</p>",
        "id": 203804137,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710216
    },
    {
        "content": "<p>so instead of being deterministic on the current source code, it's deterministic on the source code at some point in the past</p>",
        "id": 203804147,
        "sender_full_name": "eddyb",
        "timestamp": 1594710233
    },
    {
        "content": "<p>I don't think you need to get into randomness, it's deterministic just not on the current state</p>",
        "id": 203804208,
        "sender_full_name": "eddyb",
        "timestamp": 1594710273
    },
    {
        "content": "<p>Yes</p>",
        "id": 203804210,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710279
    },
    {
        "content": "<p>It is deterministic</p>",
        "id": 203804214,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710283
    },
    {
        "content": "<p>I'd call it \"stateful\" not even nondeterministic tbh</p>",
        "id": 203804219,
        "sender_full_name": "eddyb",
        "timestamp": 1594710289
    },
    {
        "content": "<p>But it might appear random</p>",
        "id": 203804221,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710290
    },
    {
        "content": "<p>no, I don't think that's fair to say</p>",
        "id": 203804247,
        "sender_full_name": "eddyb",
        "timestamp": 1594710303
    },
    {
        "content": "<p>I think I need a voice message to explain what I mean XD</p>",
        "id": 203804264,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710331
    },
    {
        "content": "<p>because of how different the past codebase could look compared to the current one, I don't think you can even model it probabilistically</p>",
        "id": 203804330,
        "sender_full_name": "eddyb",
        "timestamp": 1594710369
    },
    {
        "content": "<p>I mean that it is like a noise function. You give it a seed and a point in space, and it always computes to the same value</p>",
        "id": 203804332,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710369
    },
    {
        "content": "<p>(Procedural noise)</p>",
        "id": 203804345,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710380
    },
    {
        "content": "<p>that's just a deterministic function</p>",
        "id": 203804360,
        "sender_full_name": "eddyb",
        "timestamp": 1594710392
    },
    {
        "content": "<p>And it is continuous in the point</p>",
        "id": 203804363,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710396
    },
    {
        "content": "<p>Yup</p>",
        "id": 203804366,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710397
    },
    {
        "content": "<p>Deterministic indeed. Well, that's what I'm asking</p>",
        "id": 203804378,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710411
    },
    {
        "content": "<p>I don't see how the \"PRNG\" aspect applies to the rustc situation</p>",
        "id": 203804386,
        "sender_full_name": "eddyb",
        "timestamp": 1594710424
    },
    {
        "content": "<p>it's either deterministic in one or more of the states the source code was when running <code>rustc</code>, or it's not</p>",
        "id": 203804424,
        "sender_full_name": "eddyb",
        "timestamp": 1594710482
    },
    {
        "content": "<p>if it depends on anything but the current state, it's stateful</p>",
        "id": 203804463,
        "sender_full_name": "eddyb",
        "timestamp": 1594710500
    },
    {
        "content": "<p>Why not? (Btw we might be digressing too much here, and I think we are actually saying the same thing but I might not be good enough at writing my idea down to show it, I think?</p>",
        "id": 203804466,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710504
    },
    {
        "content": "<p>Nono, you got me wrong. Procedural noise is always deterministic. It only appears random.</p>",
        "id": 203804512,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710546
    },
    {
        "content": "<p>what rustc does doesn't even appear random, it's just boring algorithms</p>",
        "id": 203804523,
        "sender_full_name": "eddyb",
        "timestamp": 1594710560
    },
    {
        "content": "<p>you can <em>add</em> PRNGs to some of the algorithms but that's specifically an extra step</p>",
        "id": 203804539,
        "sender_full_name": "eddyb",
        "timestamp": 1594710581
    },
    {
        "content": "<p>But prngs are something else eddy!</p>",
        "id": 203804558,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710595
    },
    {
        "content": "<p>Anywho</p>",
        "id": 203804606,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710606
    },
    {
        "content": "<p>the closest thing is probably LLVM optimizations, in terms of unpredictable behavior</p>",
        "id": 203804616,
        "sender_full_name": "eddyb",
        "timestamp": 1594710619
    },
    {
        "content": "<p>what rustc does is <em>very boring</em> compared to anything random-looking, noise etc.</p>",
        "id": 203804627,
        "sender_full_name": "eddyb",
        "timestamp": 1594710634
    },
    {
        "content": "<p>Yes</p>",
        "id": 203804634,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710641
    },
    {
        "content": "<p>and we could (deterministically) randomize some things, and that's a specific choice, which is why I disagree on using that terminology when we <em>don't</em> do that</p>",
        "id": 203804661,
        "sender_full_name": "eddyb",
        "timestamp": 1594710667
    },
    {
        "content": "<p>But my question was about this discussion we were having on making the incr. compilation artifacts be \"non-deterministic\"</p>",
        "id": 203804668,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710680
    },
    {
        "content": "<p>So, things that haven't been implemented yet</p>",
        "id": 203804671,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710690
    },
    {
        "content": "<p>I think even \"non-deterministic\" might've been a misuse of the term</p>",
        "id": 203804685,
        "sender_full_name": "eddyb",
        "timestamp": 1594710710
    },
    {
        "content": "<p>And I wanted to ask Felix (the other Felix XD) if what he meant was actually \"deterministic, but basically dependent on the entire incr. compilation history of the code\"</p>",
        "id": 203804759,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710753
    },
    {
        "content": "<p>statefully deterministic and only apparently non-deterministic (when taking into account only the current state)</p>",
        "id": 203804771,
        "sender_full_name": "eddyb",
        "timestamp": 1594710770
    },
    {
        "content": "<p>Yup</p>",
        "id": 203804783,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710781
    },
    {
        "content": "<p>Exactly</p>",
        "id": 203804788,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710784
    },
    {
        "content": "<p>okay sure but bringing anything like \"randomness\" into it muddles the waters, because <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> may have been talking about actually randomizing (deterministically, or not) some initial state of the incremental caches</p>",
        "id": 203804813,
        "sender_full_name": "eddyb",
        "timestamp": 1594710825
    },
    {
        "content": "<p>I think that \"non-deterministic\" here means that the artifacts produced might depend on history and not just code alone</p>",
        "id": 203804818,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710836
    },
    {
        "content": "<p>sorry, I should go to sleep instead of stumbling over things to be pedantic about</p>",
        "id": 203804860,
        "sender_full_name": "eddyb",
        "timestamp": 1594710847
    },
    {
        "content": "<p>yeah I think that's a slightly misuse like I mentioned above</p>",
        "id": 203804876,
        "sender_full_name": "eddyb",
        "timestamp": 1594710864
    },
    {
        "content": "<p>Yeah yeah</p>",
        "id": 203804883,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710876
    },
    {
        "content": "<p>Don't worry eddy</p>",
        "id": 203804885,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710884
    },
    {
        "content": "<p>Be pedantic alright</p>",
        "id": 203804888,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710890
    },
    {
        "content": "<p>Please do ask me for clarification if something seems off in my writing</p>",
        "id": 203804921,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594710938
    },
    {
        "content": "<p>I sometimes use terms that might be ambiguous because I usually bring different areas of CS to the table, to understand the compiler better myself</p>",
        "id": 203805048,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594711068
    },
    {
        "content": "<p>But those terms in this context might not carry the same meaning</p>",
        "id": 203805107,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594711103
    },
    {
        "content": "<p><span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>️</p>",
        "id": 203805109,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594711109
    },
    {
        "content": "<p>im happy to switch terminology</p>",
        "id": 203848500,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741005
    },
    {
        "content": "<p>all I've been trying to say is that we might want to allow the results to be a function of the history rather than the end state. I said \"non-deterministic\" because, unfortunately, that's how such results can look to some people who assume that history is <em>not</em> an input to the function.</p>",
        "id": 203848653,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741085
    },
    {
        "content": "<p>Oh, okay, I think we got what you meant then :3</p>",
        "id": 203849552,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741489
    },
    {
        "content": "<p>I was worried I had misunderstood</p>",
        "id": 203849587,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741506
    },
    {
        "content": "<p>So then: is this a problem? That the results are history-dependent for the incr-comp case?</p>",
        "id": 203849763,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741587
    },
    {
        "content": "<p>well, as I noted above, its contrary to one of the original design goals for incr-comp</p>",
        "id": 203849825,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741621
    },
    {
        "content": "<p>that is, at one point one of the tests in use was to rebuild a repo at each point in its history, and check that the results are the same as a clean build (i.e. one with no incr-comp results stored)</p>",
        "id": 203849999,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741699
    },
    {
        "content": "<p>Ahhh, I see</p>",
        "id": 203850056,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741723
    },
    {
        "content": "<p>(because I interpret the latter as being the same as \"having no history at all\")</p>",
        "id": 203850066,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741728
    },
    {
        "content": "<p>Right, right</p>",
        "id": 203850096,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741742
    },
    {
        "content": "<p>Can we get rid of that restriction?</p>",
        "id": 203850121,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741759
    },
    {
        "content": "<p>that is indeed the question. :)</p>",
        "id": 203850142,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741768
    },
    {
        "content": "<p>Hahaha</p>",
        "id": 203850160,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741777
    },
    {
        "content": "<p>:)</p>",
        "id": 203850170,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741783
    },
    {
        "content": "<p>its probably something we'd have to raise with the whole compiler team, at least</p>",
        "id": 203850171,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741783
    },
    {
        "content": "<p>if not core as well</p>",
        "id": 203850181,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741788
    },
    {
        "content": "<p>Agreed</p>",
        "id": 203850185,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741792
    },
    {
        "content": "<p>And I don't want to do that until we've got evidence that doing this is a significant win</p>",
        "id": 203850269,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741809
    },
    {
        "content": "<p>Ahh, okay</p>",
        "id": 203850309,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741828
    },
    {
        "content": "<p>Niko pointedly said that they thought there are other tasks we could tackle, like querifying more stuff</p>",
        "id": 203850320,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741834
    },
    {
        "content": "<p>Querifying more stuff?</p>",
        "id": 203850382,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741871
    },
    {
        "content": "<p>Like, in chalk?</p>",
        "id": 203850395,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/203850269\">said</a>:</p>\n<blockquote>\n<p>And I don't want to do that until we've got evidence that doing this is a significant win</p>\n</blockquote>\n<p>at the same time, I don't want to invest the effort of prototyping history-sensitive compilation unless we have some idea that it <em>might</em> be okayed.</p>",
        "id": 203850407,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741887
    },
    {
        "content": "<p>Right, right. I was wondering about that^</p>",
        "id": 203850439,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"212698\">Félix Fischer</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/203850395\">said</a>:</p>\n<blockquote>\n<p>Like, in chalk?</p>\n</blockquote>\n<p>um more like in the query system that the compiler actually uses today?</p>",
        "id": 203850462,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"212698\">Félix Fischer</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/203850382\">said</a>:</p>\n<blockquote>\n<p>Querifying more stuff?</p>\n</blockquote>\n<p><a href=\"https://rustc-dev-guide.rust-lang.org/query.html\">https://rustc-dev-guide.rust-lang.org/query.html</a></p>",
        "id": 203850511,
        "sender_full_name": "davidtwco",
        "timestamp": 1594741927
    },
    {
        "content": "<p>let me see if I can find an issue explaining this</p>",
        "id": 203850517,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741929
    },
    {
        "content": "<p>Ahhhhhhhhhhhhhhhh</p>",
        "id": 203850563,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741958
    },
    {
        "content": "<p>AIUI only the middle and backend parts of the compiler use the query system which is what powers incremental compilation. The parser, name resolution, and other frontend stuff is still pass based and doesn't participate in incremental compilation.</p>",
        "id": 203850600,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594741975
    },
    {
        "content": "<p>see for example: <a href=\"https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-06-end-to-end-query-PRs/\">https://rust-lang.github.io/compiler-team/minutes/design-meeting/2019-12-06-end-to-end-query-PRs/</a></p>",
        "id": 203850604,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594741975
    },
    {
        "content": "<p>Demand driven <em>compilation</em>. I had completely forgotten that that was one of the current overall goals</p>",
        "id": 203850641,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594741996
    },
    {
        "content": "<p>I was only thinking in queries as \"rust-analyzer kind of things\"</p>",
        "id": 203850770,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742048
    },
    {
        "content": "<p>So how do we get from a world where we do incremental pass-based compilation to a world where, at least for debug builds, we do it... query-based?</p>",
        "id": 203850876,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742113
    },
    {
        "content": "<p>We're already query based, just not the first part of the compilation process</p>",
        "id": 203850900,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742136
    },
    {
        "content": "<p>no no, read <span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> 's message again</p>",
        "id": 203850904,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742138
    },
    {
        "content": "<p>So the goal is to make that part query based as well</p>",
        "id": 203850915,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742146
    },
    {
        "content": "<p>the pass-based stuff is inherently non-increental</p>",
        "id": 203850917,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742147
    },
    {
        "content": "<p>but yes, we probably do want to move from pass-based to query-based for more stuff</p>",
        "id": 203851032,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742190
    },
    {
        "content": "<p>that is what the end-to-end query stuff is about. (Making the earlier phases use queries)</p>",
        "id": 203851054,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742204
    },
    {
        "content": "<p>Ah, okay. So we are already in a query-based world. This is cool :D</p>",
        "id": 203851070,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742211
    },
    {
        "content": "<p>Ah, okay, I see. So niko was saying that we could still get some low-hanging fruit by querifying more parts of the compiling process.</p>",
        "id": 203851233,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742283
    },
    {
        "content": "<p>exactly</p>",
        "id": 203851250,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742291
    },
    {
        "content": "<p>I don't know how low-hanging it is</p>",
        "id": 203851256,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742298
    },
    {
        "content": "<p>but it would have a less drastic effect, perhaps, on our customers</p>",
        "id": 203851276,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/203851256\">said</a>:</p>\n<blockquote>\n<p>I don't know how low-hanging it is</p>\n</blockquote>\n<p>I was typing exactly this <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 203851277,
        "sender_full_name": "davidtwco",
        "timestamp": 1594742310
    },
    {
        "content": "<p>There's other possible improvements here as well. Some of our queries are very \"coarse-grained\" so we do more work than strictly necessary or because they cover so much code, they invalidate more of the data then needs to be when something changes. Breaking those kinds of queries up to be smaller would result in less work. </p>\n<p>There's also the reverse where if we have queries that are too small, the overhead of recording their results into the query system dwarfs the improvements we get from running them incrementally.</p>",
        "id": 203851324,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742341
    },
    {
        "content": "<p>Basically just fine-tuning what we already have.</p>",
        "id": 203851342,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742351
    },
    {
        "content": "<p>Right, right, right</p>",
        "id": 203851406,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742377
    },
    {
        "content": "<p>I wonder how we can set up a benchmark for this. Something that feeds compilation histories to the compiler so that we can see how the tuning efforts affect performance</p>",
        "id": 203851638,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742497
    },
    {
        "content": "<p>even a short history might be useful</p>",
        "id": 203851760,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"212698\">Félix Fischer</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/203851638\">said</a>:</p>\n<blockquote>\n<p>I wonder how we can set up a benchmark for this. Something that feeds compilation histories to the compiler so that we can see how the tuning efforts affect performance</p>\n</blockquote>\n<p><a href=\"http://perf.rust-lang.org\">perf.rust-lang.org</a> does that some of that already, which you might not be aware of - there is a baseline run, a full incremental run and a patched incremental run - we may of course want something more or less depending on what the working group ends up focusing on</p>",
        "id": 203851801,
        "sender_full_name": "davidtwco",
        "timestamp": 1594742581
    },
    {
        "content": "<p>like, our current perf.rlo benchmarks only use single patches at most for evaluating incrental, if I remember correctly</p>",
        "id": 203851817,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742586
    },
    {
        "content": "<p>while I would expect we would probably want histories with a stack of at least two patches</p>",
        "id": 203851867,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742615
    },
    {
        "content": "<p>Yup, as I understand it, that is the case</p>",
        "id": 203851884,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742619
    },
    {
        "content": "<p>(since the content of the first patch will likely inform the compilation of the second patch)</p>",
        "id": 203851907,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742634
    },
    {
        "content": "<p>Yas. Two patches would let us explore how two changes interact</p>",
        "id": 203851969,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742649
    },
    {
        "content": "<p>adding a two-patch stack to perf.rlo probably would not be that hard. But I wouldn't want to start adding that overhead to perf until we have <em>something</em> in place that tries to use it</p>",
        "id": 203852066,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742702
    },
    {
        "content": "<p>(Thank u <span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span>, I already sorta know that bench, although I feel like I could know a lot more still ^^)</p>",
        "id": 203852084,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742708
    },
    {
        "content": "<p>We get a lot of PRs that need to run perf before merging so adding tests to that unnecessarily hurts PR throughput. If we need the tests to catch perf regressions or make sure things stay fast, that's fine but we shouldn't add overhead there unnecessarily.</p>",
        "id": 203852220,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742772
    },
    {
        "content": "<p>Agreed</p>",
        "id": 203852251,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742790
    },
    {
        "content": "<p>having said that, we might consider making a branch of perf</p>",
        "id": 203852259,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742801
    },
    {
        "content": "<p>that we use locally to evaluate a prototype</p>",
        "id": 203852266,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742810
    },
    {
        "content": "<p>so that we have a shared understanding of what we are benchmarking.</p>",
        "id": 203852280,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742823
    },
    {
        "content": "<p>You can run perf locally, it's not necessarily the most streamlined experience but it does work fairly well once you have it set up.</p>",
        "id": 203852324,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742842
    },
    {
        "content": "<p>I take from the current discussion that we're primarily interested in the performance implications of incr-comp; things such as making incr-comp bugs easier to reproduce and debug are somewhat secondary to the extent that addressing them isn't necessary for the primary goal of perf?</p>",
        "id": 203852477,
        "sender_full_name": "davidtwco",
        "timestamp": 1594742911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> that's an excellent point</p>",
        "id": 203852502,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742925
    },
    {
        "content": "<p>Re: PR throughput<br>\nI want to work on that infrastructure. I feel like there are some low hanging fruits (wrt throughput and other metrics) in perf.rlo, but I won't have time for that at least until November so don't mind me &gt;.&lt;</p>",
        "id": 203852525,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742941
    },
    {
        "content": "<p>I think making incr-comp bugs easier to reproduce and debug is something we should talk about</p>",
        "id": 203852526,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742942
    },
    {
        "content": "<p>That's the boring stuff so that's probably why it hasn't been talked about <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 203852547,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742956
    },
    {
        "content": "<p>But yeah, that stuff is really important</p>",
        "id": 203852554,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742961
    },
    {
        "content": "<p>We have a pretty large backlog of incr bugs</p>",
        "id": 203852576,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594742975
    },
    {
        "content": "<p>Having not thought too deeply about potential solutions, it seems hard.</p>",
        "id": 203852583,
        "sender_full_name": "davidtwco",
        "timestamp": 1594742979
    },
    {
        "content": "<p>but I suspect any such work (on making incr-comp easier to repro+debug) is only going to be justified if its in service of making incr comp faster.</p>",
        "id": 203852586,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594742980
    },
    {
        "content": "<p>Hmm</p>",
        "id": 203852614,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594742994
    },
    {
        "content": "<p>I would pose it a bit differently</p>",
        "id": 203852745,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743044
    },
    {
        "content": "<p>is the incr cache something that can be moved between host systems? I would expect it isn't, but if it is, or if it can be made portable, then maybe that's a way we could help make the bugs easier to repro</p>",
        "id": 203852757,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743052
    },
    {
        "content": "<p>Something that hadn't clicked for me until just now but most of the bugs I've seen are only reported because they ICE the compiler. People generally aren't complaining because incr-comp doesn't work as well as it should, they're complaining because it completely breaks rustc.</p>",
        "id": 203852794,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743076
    },
    {
        "content": "<p>at least in terms of having the compiler provide an easy way to archive (e.g. in a tar ball) the current incr cache, perhaps in response to an ICE</p>",
        "id": 203852801,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743081
    },
    {
        "content": "<p>Yas!</p>",
        "id": 203852827,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743097
    },
    {
        "content": "<p>That would be really nice</p>",
        "id": 203852851,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743106
    },
    {
        "content": "<p>So fixing the root cause that causes us to use bad incr-comp data would likely resolve a lot of the current complaints and issues and then we can focus on making it faster/better/smarter.</p>",
        "id": 203852863,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743117
    },
    {
        "content": "<p>Yup</p>",
        "id": 203852913,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743129
    },
    {
        "content": "<p>I would pose it that way</p>",
        "id": 203852923,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743139
    },
    {
        "content": "<p>Presumably we'd need some tooling to understand the contents of the incr-comp cache - I can't imagine how I'd determine right now whether the bug in a incr-comp ICE is what the compiler spat out last time, or what it is doing this time with that data.</p>",
        "id": 203852933,
        "sender_full_name": "davidtwco",
        "timestamp": 1594743146
    },
    {
        "content": "<p>Incr-comp needs to be valid always. Then, it can be as fast as possible. Like, speed is the target; not ICE-ing is a restriction of the problem :3</p>",
        "id": 203853018,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743206
    },
    {
        "content": "<p>its true: trying to make the incr-cache portable could be a real rabbit hole</p>",
        "id": 203853023,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743213
    },
    {
        "content": "<p>another potential option would be to actually record the history, as interpreted by the incr-cache, <em>in</em> the incr-cache</p>",
        "id": 203853128,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743252
    },
    {
        "content": "<p>and then when you have a bug, you could serialize <em>just</em> the edit history</p>",
        "id": 203853143,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743262
    },
    {
        "content": "<p>Yas</p>",
        "id": 203853147,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743267
    },
    {
        "content": "<p>and add that to the bug report</p>",
        "id": 203853148,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743267
    },
    {
        "content": "<p>Storing just the edit history should be fairly cheap in space</p>",
        "id": 203853177,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743287
    },
    {
        "content": "<p>(Unless you do a sweeping change I guess)</p>",
        "id": 203853209,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743309
    },
    {
        "content": "<p>I wonder if there's some kind of diagnostic routine we could write that would validate the incr-comp cache and report issues with it. We could invoke that as part of the ICE routine if the backtrace has some of the telltale incr-comp frames in it.</p>",
        "id": 203853224,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743320
    },
    {
        "content": "<p>I think that would be best - then you can run the compiler with logging in the intermediate compiler invocations too. But not everyone will be able to share their source - though that's not specific to incr-comp bugs.</p>",
        "id": 203853245,
        "sender_full_name": "davidtwco",
        "timestamp": 1594743340
    },
    {
        "content": "<p>Or the classic \"tried to get index 12371239589231032 when slice len was 4\"</p>",
        "id": 203853255,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743346
    },
    {
        "content": "<p>Which is 99% of the time an incr-comp issue</p>",
        "id": 203853321,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743366
    },
    {
        "content": "<p>Woah, that bad?</p>",
        "id": 203853350,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743384
    },
    {
        "content": "<p>I mean we don't see that kind of bug very often at all, apart from incr comp issues</p>",
        "id": 203853378,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743404
    },
    {
        "content": "<p>Well, it's just not a bug we normally generate anywhere else in the compiler.</p>",
        "id": 203853384,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743407
    },
    {
        "content": "<p>I see. Wow.</p>",
        "id": 203853421,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743430
    },
    {
        "content": "<p>I wonder if we could change the message associated with that panic</p>",
        "id": 203853430,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743434
    },
    {
        "content": "<p>when it happens in rustc</p>",
        "id": 203853437,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743438
    },
    {
        "content": "<p>to say \"this might be an incr-comp issue\"</p>",
        "id": 203853443,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743443
    },
    {
        "content": "<p>That seems plausibly possible to me</p>",
        "id": 203853459,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743461
    },
    {
        "content": "<p>\"Go &lt;here&gt; to report the problem\"</p>",
        "id": 203853461,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743463
    },
    {
        "content": "<p>because part of the problem there is that the end-user doesn't even necessarily know that's a likely culprit</p>",
        "id": 203853462,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743463
    },
    {
        "content": "<p>Yas</p>",
        "id": 203853486,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743474
    },
    {
        "content": "<p>That should help a lot</p>",
        "id": 203853491,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743480
    },
    {
        "content": "<p>Yeah and by the time someone on the triage team realizes what's going on, they've blown away their cache</p>",
        "id": 203853535,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743484
    },
    {
        "content": "<p>Oh noes</p>",
        "id": 203853558,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743497
    },
    {
        "content": "<p>That's totally true</p>",
        "id": 203853566,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743506
    },
    {
        "content": "<p><span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 203853573,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743510
    },
    {
        "content": "<p>Personally I would like to know if the issue is that the cache is wrong/corrupted or if we're triggering some kind of rare bug within the query system with valid data.</p>",
        "id": 203853686,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743549
    },
    {
        "content": "<p>really maybe every ICE should archive the incr cache</p>",
        "id": 203853708,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743553
    },
    {
        "content": "<p>In fact I think I even had such an issue while doing incremental work on mir-opt. It was so obscure that I ended up blowing up the entire cache and that fixed it</p>",
        "id": 203853745,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743563
    },
    {
        "content": "<p>Like maybe the data on disk is fine but we forget to update some index or something when we load it into the current compilation session and then later it goes off the rails</p>",
        "id": 203853853,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743589
    },
    {
        "content": "<p>(though <em>that</em> may lead to serious space blowup, given how much space the current incr cache uses already ...)</p>",
        "id": 203853859,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743594
    },
    {
        "content": "<p>Maybe it can be compressed!</p>",
        "id": 203853932,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743626
    },
    {
        "content": "<p>Could earlier parts of the compiler not being querified result in different internal state (e.g. one more variant in an <code>AdtDef</code>) so that at the point where we start checking incr-comp data it causes the out-of-range indexing? I don't know enough about how we implement things to whether that could be the case.</p>",
        "id": 203853964,
        "sender_full_name": "davidtwco",
        "timestamp": 1594743650
    },
    {
        "content": "<p>We probably don't need the MIR or llvm bitcode for the results.</p>",
        "id": 203853968,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743653
    },
    {
        "content": "<p>Which, I think are a fairly significant part of the disk cost.</p>",
        "id": 203853988,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743665
    },
    {
        "content": "<p>If it is a cache, it must be in a fairly easy-to-digest form. I bet you can get a 50% reduction in size if not more with a common compression tool</p>",
        "id": 203853991,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116107\">davidtwco</span> <a href=\"#narrow/stream/241847-t-compiler.2Fwg-incr-comp/topic/brainstorming.3A.20mission.20statement.2C.20goals.2C.20design.20constraints/near/203853964\">said</a>:</p>\n<blockquote>\n<p>Could earlier parts of the compiler not being querified result in different internal state (e.g. one more variant in an <code>AdtDef</code>) so that at the point where we start checking incr-comp data it causes the out-of-range indexing? I don't know enough about how we implement things to whether that could be the case.</p>\n</blockquote>\n<p>One would hope that the relevant portions of the incr-cache are invalidated in such scenarios, but that may indeed be part of the bugs in these cases (i..e situations where we are failing to invalidate sufficiently)</p>",
        "id": 203854201,
        "sender_full_name": "pnkfelix",
        "timestamp": 1594743784
    },
    {
        "content": "<p>I recall that there is some care taken to when choosing <code>DepNodeId</code>s (I think that's the right type) so that it doesn't change unnecessarily between compilations because those are the underlying keys into the incr cache (IIRC).</p>\n<p>Edit: This is what I was thinking of <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_middle/dep_graph/dep_node.rs\">https://github.com/rust-lang/rust/blob/master/src/librustc_middle/dep_graph/dep_node.rs</a></p>",
        "id": 203854334,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743856
    },
    {
        "content": "<p>\"Naming and Cache invalidation are the two hardest problems in CS\" xD</p>",
        "id": 203854340,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594743858
    },
    {
        "content": "<p>Leaving that mostly just to try to point people toward the right thing.</p>",
        "id": 203854360,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1594743868
    },
    {
        "content": "<p>(Fuck, Zulip mobile client is hard to use XD)</p>",
        "id": 203855573,
        "sender_full_name": "Félix Fischer",
        "timestamp": 1594744517
    }
]