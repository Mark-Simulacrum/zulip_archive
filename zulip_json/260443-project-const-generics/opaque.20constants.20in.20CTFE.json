[
    {
        "content": "<p><a href=\"https://github.com/rust-lang/project-const-generics/issues/39\">https://github.com/rust-lang/project-const-generics/issues/39</a> talks about opaque constants, but it is unclear to me how we'll prevent leaking one as non-opaque via CTFE.</p>\n<p>You can always create an intermediate constant that (accidentally or not ) returns the value of a size_of call. Should CTFE automatically track this and magically make that return value opaque, too?</p>",
        "id": 276437401,
        "sender_full_name": "oli",
        "timestamp": 1648103955
    },
    {
        "content": "<p>Or even more generally, how do we handle <code>const fn moo&lt;T&gt;() -&gt; usize { size_of::&lt;T&gt;() }</code></p>",
        "id": 276437480,
        "sender_full_name": "oli",
        "timestamp": 1648104050
    },
    {
        "content": "<blockquote>\n<p>Should CTFE automatically track this and magically make that return value opaque, too?</p>\n</blockquote>\n<p>that was my idea yeah, we add  a tag to allocations or even just the current ctfe context, which gets set once it uses something opaque</p>",
        "id": 276437735,
        "sender_full_name": "lcnr",
        "timestamp": 1648104386
    },
    {
        "content": "<p>Oh, that is easier than what I had in mind (taint tracking)</p>",
        "id": 276438386,
        "sender_full_name": "oli",
        "timestamp": 1648105251
    },
    {
        "content": "<p>We would need to adjust our static analyses, too, as otherwise it becomes real easy to introduce breaking changes where a constant or const fn goes from transparent to opaque without the library author realizing</p>",
        "id": 276438459,
        "sender_full_name": "oli",
        "timestamp": 1648105346
    }
]