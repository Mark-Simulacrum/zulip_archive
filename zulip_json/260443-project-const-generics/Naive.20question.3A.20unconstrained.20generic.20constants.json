[
    {
        "content": "<p>Hi, I've been trying to use generic constants, and have been adding bounds like <code>where [(); N + 1]:</code> to get code to compile (say <code>N</code> is <code>usize</code>). As I understand, the issue is that arbitrary expressions may be invalid, e.g. if <code>N + 1</code> overflows, the containing type/function is not well-defined.</p>\n<p>So say I try to define a struct:</p>\n<div class=\"codehilite\"><pre><span></span><code>struct Foo&lt;const N: usize&gt;([u32; N + 1]);\n</code></pre></div>\n<p>Currently, the compiler \"pre-emptively\" requires me to add a bound forcing the evaluation of <code>N + 1</code> to ensure it is valid. So even if I only ever use <code>Foo&lt;0&gt;</code> and <code>Foo&lt;1&gt;</code>, where <code>N + 1</code> is valid, I still need the bound. But why can't the evaluation and validation be delayed to whenever the generic type is used/\"instantiated\"/\"referenced\", e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><code>let foo: Foo&lt;usize::MAX + 1&gt;;\n</code></pre></div>\n<p>i.e. I would get the equivalent compiler error in this previous line of code, as opposed to the definition of <code>Foo</code>.</p>\n<p>I'm sure this has been brought up before - it's similar to how templates work in C++, where generics really are \"templates\" that don't exist until used/instantiated. I've seen the reasoning somewhere that the current approach makes implicit assumptions about the generic constants (e.g. that <code>N + 1</code> doesn't overflow) explicit. However, even writing a small amount of code with generic constants (e.g. a bitmap parameterized by the number of bits), these explicit bounds quickly seem unwieldy. Is this the only reason for requiring explicit bounds? Alternatively, is it just the case that internally the rust compiler fundamentally doesn't treat generics similar to C++'s templates (where this seems possible and valid)?</p>\n<p>Thank you!</p>",
        "id": 258762550,
        "sender_full_name": "Raekye",
        "timestamp": 1634931335
    },
    {
        "content": "<blockquote>\n<p>Is this the only reason for requiring explicit bounds?</p>\n</blockquote>\n<p>no.  A large issue with having these bounds be implicit is that it is quite difficult to infer these bounds recursively, i.e. whether calling <code>fn bar</code> with <code>usize::MAX</code> causes an error if <code>fn bar</code> calls <code>fn foo</code> with this generic arg where <code>foo</code> fails for some inputs.</p>",
        "id": 258887186,
        "sender_full_name": "lcnr",
        "timestamp": 1635094230
    },
    {
        "content": "<p>if instead of propagating these bounds upwards, we wait until we \"actually need\" the constant which fails evaluation, we end up with cases which don't error with <code>cargo check</code> but instead either:</p>",
        "id": 258887224,
        "sender_full_name": "lcnr",
        "timestamp": 1635094292
    },
    {
        "content": "<ul>\n<li>cause a post monomorphization error, i.e. only error when using <code>cargo build</code> and when using the relevant function, so you can end up with potentially very unhelpful errors and it is not obvious that some methods can't be called with generic args</li>\n</ul>",
        "id": 258887467,
        "sender_full_name": "lcnr",
        "timestamp": 1635094566
    },
    {
        "content": "<ul>\n<li>or even worse, don't error at all even though you use something which depends on a const evaluatable bound (currently written <code>where [u8; my_expr]: Whatever</code>, in the future maybe <code>where evaluatable { my_expr }</code> or something like that) for soundness, which I definitely want to allow. An example here is maybe an algorithm which only works if the used generic arg is prime or sth like that</li>\n</ul>",
        "id": 258887573,
        "sender_full_name": "lcnr",
        "timestamp": 1635094703
    },
    {
        "content": "<p>It's also easier to just start with requiring explicit bounds and then later implicitly inferring them or what not once the rest of this feature already works and we have more experience. Increasing the requirements is pretty much always more difficult then dropping them</p>",
        "id": 258887606,
        "sender_full_name": "lcnr",
        "timestamp": 1635094784
    },
    {
        "content": "<p>i should probably just write a document where i can point to when this question comes up cause the reasoning is currently split over a bunch of different documents and discussions <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 258887708,
        "sender_full_name": "lcnr",
        "timestamp": 1635094823
    },
    {
        "content": "<p>We already have post monomorphization errors for associated consts.</p>",
        "id": 258889862,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635097879
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">VAL</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span>::<span class=\"n\">VAL</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"o\">&gt;</span>::<span class=\"n\">VAL</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 258889949,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635098009
    },
    {
        "content": "<p>I'm not sure if this is what Gary was trying to say, but in my code I also had an associated constant defined as a nontrivial expression (which hypothetically could be a problem), which is why I thought it's not completely inconsistent to have that behavior elsewhere (post monomorphization(?) errors). <span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> is that what you were suggesting?</p>",
        "id": 258907510,
        "sender_full_name": "Raekye",
        "timestamp": 1635123454
    },
    {
        "content": "<p>yes</p>",
        "id": 258907558,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123514
    },
    {
        "content": "<p>Although I have to say that even though this is a form of post-monomorphization error it currently does not flow back to the type system because we forbid usage of <code>Foo::&lt;N&gt;::VAL</code> in const contexts if <code>N</code> is a parameter.</p>",
        "id": 258907724,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123713
    },
    {
        "content": "<p>yea</p>",
        "id": 258907786,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1635123734
    },
    {
        "content": "<p>there's also I think not really a path to making assoc consts <em>not</em> have post mono errors</p>",
        "id": 258907804,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1635123787
    },
    {
        "content": "<p>wheras there <em>is</em> a path towards making <code>foo::&lt;{ N + 1 }&gt;</code> not have post mono errors</p>",
        "id": 258907812,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1635123804
    },
    {
        "content": "<p>or,, i guess really it would be <code>foo::&lt;N&gt;()</code> not having post mono errors</p>",
        "id": 258907820,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1635123822
    },
    {
        "content": "<p>or i guess both</p>",
        "id": 258907823,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1635123827
    },
    {
        "content": "<p>Well, I can have a</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>:<span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span>::<span class=\"n\">VAL</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and it would error post mono.</p>",
        "id": 258907870,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123898
    },
    {
        "content": "<p>But it's IMO a good thing, I use it for static asserts.</p>",
        "id": 258907875,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635123909
    },
    {
        "content": "<p>O fun</p>",
        "id": 258907893,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1635123961
    },
    {
        "content": "<p>i guess I assumed that would be a runtime panic</p>",
        "id": 258907930,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1635123966
    },
    {
        "content": "<p>Well, the const needs to be mono-ed.</p>",
        "id": 258908003,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635124095
    },
    {
        "content": "<p>Actually I hope one day I can just write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>:<span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// and also</span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 258908009,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635124116
    },
    {
        "content": "<p>It's actually okay, because inline consts don't flow back into the type system either, unless used in pattern position, nested in another anon const (but that restriction doesn't come from inline const itself).</p>",
        "id": 258908040,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635124201
    }
]