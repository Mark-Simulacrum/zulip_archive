[
    {
        "content": "<p>So in <a href=\"https://github.com/rust-lang/rust/issues/84045\">#84045</a> <a href=\"https://github.com/rust-lang/rust/pull/84045#issuecomment-839850571\">we were discussing</a> the idea of having a pow-wow to talk over structural equality (cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>, <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>, <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>, <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span>), maybe we could use a const generics meeting to push on that? e.g. next week at <time datetime=\"2021-05-18T14:45:00Z\">2021-05-18T10:45:00-04:00</time> ?</p>",
        "id": 238686037,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1620942424
    },
    {
        "content": "<p>I'm not sure who else to cc :)</p>",
        "id": 238686091,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1620942444
    },
    {
        "content": "<p><span class=\"user-group-mention\" data-user-group-id=\"1916\">@WG-const-eval</span></p>",
        "id": 238697342,
        "sender_full_name": "oli",
        "timestamp": 1620949369
    },
    {
        "content": "<p>Would that be a good time to raise <a href=\"https://github.com/rust-lang/rust/issues/84391\">https://github.com/rust-lang/rust/issues/84391</a>, and the more general point (which is a concern of mine) of <code>derive(Eq,PartialEq)</code> being observably different from an equivalent manual implementation?</p>",
        "id": 238759346,
        "sender_full_name": "Connor Horman",
        "timestamp": 1620995726
    },
    {
        "content": "<p>oof. that's unfortunate and a really good datapoint for finding a less magical scheme for allowing types in const generics. We should def make it a discussion point of that meeting</p>",
        "id": 238762649,
        "sender_full_name": "oli",
        "timestamp": 1620997341
    },
    {
        "content": "<p>C++ may have had similar issues raised when debating CNTTP for C++20, as <a href=\"https://wg21.link/p0732\">p0732</a> defines it in terms of types with <em>strong structural equality</em> (which is effectively equivalent to <code>derive(Eq,PartialEq)</code>), but C++20 uses a different <em>structural</em> definition <a href=\"http://eel.is/c++draft/temp.param#7\">http://eel.is/c++draft/temp.param#7</a>, which requires that class types have only public <em>strutural</em> members (and makes no reference to <code>operator&lt;=&gt;</code> at all). This may be an alternative to consider for const generics as well.</p>",
        "id": 238765157,
        "sender_full_name": "Connor Horman",
        "timestamp": 1620998480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> thnks for raising that. I think your point, if i may restate, is that we have never audited the various PartialEq/Eq impls to be sure that we really intended them to be \"structural eq\" -- in other words, structural equality may be a different property that shouldn't be just tied to PartialEq vs Eq?</p>",
        "id": 238772010,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621001143
    },
    {
        "content": "<p>Also, can you elaborate a bit more on why you see it as a problem to have TypeId as a const</p>",
        "id": 238772031,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621001152
    },
    {
        "content": "<p>i feel like you are saying that this makes it imposible to make changes the type-id hashing algorithm</p>",
        "id": 238772163,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621001203
    },
    {
        "content": "<p>(Also, <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> so happy you are working on that! <span aria-label=\"pray\" class=\"emoji emoji-1f64f\" role=\"img\" title=\"pray\">:pray:</span> )</p>",
        "id": 238772178,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621001211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> speaking of that, can I add that to the lang team project board as an active project?</p>",
        "id": 238772209,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621001223
    },
    {
        "content": "<p>Sure. So the issue generally is more of an implementation issue, where the currently (imo, over) use of <code>derive(PartialEq,Eq)</code> in the standard library may have consequences for implementations down the road (especially with const generics). I ran into this while implementing TypeId for <a href=\"https://github.com/LightningCreations/lccc\">lccc</a>'s standard library, which included an implementation suggested by a user of the Rust Community Discord that solved <a href=\"https://github.com/rust-lang/issues/10389\">#10389</a>, but can't use <code>derive(PartialEq)</code> or <code>derive(Eq)</code>.</p>",
        "id": 238772814,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621001452
    },
    {
        "content": "<p>The issue with TypeId is that any sort of structural implementation of TypeId will have a (potentially non-sigificant) chance of running into any collisions (without the mechanisms necessary to apply a perfect hash function, which would likely be impossible with <code>dylib</code>s), thus making TypeId fundamentally unsound, depending on who you ask (and different implementors may make different decisions on what chance makes it statistically significant). It would not specifically lock everything to the current implementation, it would simply reduce the amount of freedom to avoid collisions.</p>",
        "id": 238773442,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621001723
    },
    {
        "content": "<p>I started a doc for the meeting: <a href=\"https://hackmd.io/VxadMjxdRfiObV2FR03vWQ\">https://hackmd.io/VxadMjxdRfiObV2FR03vWQ</a></p>",
        "id": 238773535,
        "sender_full_name": "oli",
        "timestamp": 1621001756
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238772209\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> speaking of that, can I add that to the lang team project board as an active project?</p>\n</blockquote>\n<p>Possibly. I'm currently waiting on discussion T-libs before starting any of the work (since it's mostly in their domain). I brought it up because the issue is relevant to const-generics (See the note that the <code>derive(PartialEq,Eq)</code> can be observed with <code>#![feature(const_generics)]</code>).</p>",
        "id": 238774053,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621001957
    },
    {
        "content": "<p>For floating point values, it is worth noting the <code>total_cmp</code> operation we have introduced on nightly, which is specified as well-defined by IEEE754-2008, and provides a total order on binary floating point.</p>",
        "id": 238811170,
        "sender_full_name": "Jubilee",
        "timestamp": 1621017563
    },
    {
        "content": "<p>while that works very well for matching, const generics will have to generate a symbol name that is 100% equal to any \"equal\" (whatever that means) value. So the same NaN used in a const generic... should be the same symbol? Or should different NaNs be different symbols? Idk, I don't have a good answer here</p>",
        "id": 238811567,
        "sender_full_name": "oli",
        "timestamp": 1621017753
    },
    {
        "content": "<p>It may be a good idea to look into how C++20 handles NaNs in NTTPs, as <code>float</code>s were added.<br>\nAccording to &lt;<a href=\"http://eel.is/c++draft/temp.type#2.2\">http://eel.is/c++draft/temp.type#2.2</a>&gt;, two float values are <em>template-argument-equivalent</em> if they are identical (note: Not equal), but I haven't found a definition for that, nor anything that suggests NaNs are disallowed. It's possible that <code>NaN</code>s consider bitwise equality in floats.</p>",
        "id": 238812624,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621018295
    },
    {
        "content": "<p>Yeah, in actual practice, we don't want to really allow much in terms of meaningful const-time introspection on NaN values due to certain codegen backends having very creative interpretations. ^^;</p>",
        "id": 238812719,
        "sender_full_name": "Jubilee",
        "timestamp": 1621018334
    },
    {
        "content": "<p>It seems like gcc, for C++, mangles the float values bitwise, <a href=\"https://godbolt.org/z/fcT1P3fd3\">https://godbolt.org/z/fcT1P3fd3</a>, so that's a potential route for rust implementations to take (and thus would permit NaNs in cg)</p>",
        "id": 238814356,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621019076
    },
    {
        "content": "<p>I can list the parts of NaN values that can be determined without an oracle.<br>\nAn oracle, for these purposes, is either directly introspecting the bits, or any suitable side channel that provides similar knowledge of how the FPE (Floating Point Environment) happens to work, like having a table to look at for how the compilation target handles generating NaNs, or injecting an op that would make the value decidable without affecting overall program execution.</p>\n<p>The first is whether it is a qNaN or an sNaN. This is actually pretty knowable at all times, as it is fairly deterministic and target-independent, as far as the standard understands it.<br>\nThe second is whether it is a positive or negative NaN. This is harder to know. A NaN always has a positive or negative sign, but there are several conditions where it is valid for the FPE to assign either to the NaN, so you must consult an oracle.</p>\n<p>However, LLVM and WASM both have... interesting attitudes towards the standard. The LLVM and WASM FPE consider it valid to substitute NaNs they encounter with their \"canon NaNs\", which for LLVM are NaNs with the bit value 0x3F800000 and 0x3FF0000000000000, and I think might be the same for WASM.</p>",
        "id": 238816885,
        "sender_full_name": "Jubilee",
        "timestamp": 1621020266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> what's a \"pow-wow\"?^^</p>",
        "id": 238816978,
        "sender_full_name": "RalfJ",
        "timestamp": 1621020320
    },
    {
        "content": "<p>Indeed, and for the purposes of cg, it's entirely possible that there are only two NaNs: one quiet and one signaling. AFAIK there aren't any limitations on the bitpatterns produced by particular floating-point operations yielding NaN.</p>",
        "id": 238817287,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621020492
    },
    {
        "content": "<p>I would prefer not to handle NaN at all, we can easily detect them and just error if you try to put them into a const generic</p>",
        "id": 238817436,
        "sender_full_name": "oli",
        "timestamp": 1621020596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238762649\">said</a>:</p>\n<blockquote>\n<p>oof. that's unfortunate and a really good datapoint for finding a less magical scheme for allowing types in const generics. We should def make it a discussion point of that meeting</p>\n</blockquote>\n<p>also see <a href=\"https://github.com/rust-lang/rust/issues/74446\">https://github.com/rust-lang/rust/issues/74446</a> and the last section of <a href=\"https://hackmd.io/Qvrj_eOFTkCHZrhJ7f1ItA\">https://hackmd.io/Qvrj_eOFTkCHZrhJ7f1ItA</a> -- I think <code>StrucuralEq</code> as a concept makes sense but we need to fundamentally change its definition</p>",
        "id": 238817640,
        "sender_full_name": "RalfJ",
        "timestamp": 1621020686
    },
    {
        "content": "<p>or rather, we need to come up with a proper definition in the first place :D</p>",
        "id": 238817657,
        "sender_full_name": "RalfJ",
        "timestamp": 1621020696
    },
    {
        "content": "<p>If you do certain operations on a NaN value that set its sign value, like <code>abs</code> or <code>copysign</code>, it <em>should</em> acquire that sign value.<br>\nAnd indeed. I figured I'd enumerate the situation with NaNs, but far as I am concerned actually handling NaN during CTFE basically only makes sense by handling NaN as one entity, the abstract set containing all possible NaN values.</p>",
        "id": 238817780,
        "sender_full_name": "Jubilee",
        "timestamp": 1621020752
    },
    {
        "content": "<p>I also think floats are a sufficiently special case that we should figure out the high-level direction first before going into so much detail</p>",
        "id": 238817937,
        "sender_full_name": "RalfJ",
        "timestamp": 1621020821
    },
    {
        "content": "<p>That's Completely Fair.</p>",
        "id": 238817952,
        "sender_full_name": "Jubilee",
        "timestamp": 1621020833
    },
    {
        "content": "<p>Here's a question: what is Structural Equality supposed to <strong>enable</strong>?<br>\nI get that it has a shaky definition, but I figure that it has a clear <strong>aim</strong>. Yet I have tried to read a bunch of these documents but I still don't know. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 238819900,
        "sender_full_name": "Jubilee",
        "timestamp": 1621021697
    },
    {
        "content": "<p>Or perhaps I should say: at first I thought it was just for addressing certain soundness criteria for <code>match</code>, but then I read all this stuff, and now I know I know nothing.</p>",
        "id": 238821044,
        "sender_full_name": "Jubilee",
        "timestamp": 1621022211
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> A “pow wow” is American slang for a meeting. <a href=\"https://en.wikipedia.org/wiki/Pow_wow\">https://en.wikipedia.org/wiki/Pow_wow</a></p>",
        "id": 238868865,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1621054609
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238686037\">said</a>:</p>\n<blockquote>\n<p>So in <a href=\"https://github.com/rust-lang/rust/issues/84045\">#84045</a> <a href=\"https://github.com/rust-lang/rust/pull/84045#issuecomment-839850571\">we were discussing</a> the idea of having a pow-wow to talk over structural equality (cc <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span>, <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span>, <span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span>, <span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span>), maybe we could use a const generics meeting to push on that? e.g. next week at <time datetime=\"2021-05-18T14:45:00Z\">2021-05-18T10:45:00-04:00</time> ?</p>\n</blockquote>\n<p>sure, yeah</p>",
        "id": 238876827,
        "sender_full_name": "lcnr",
        "timestamp": 1621063555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219696\">XAMPPRocky</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238868865\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> A “pow wow” is American slang for a meeting. <a href=\"https://en.wikipedia.org/wiki/Pow_wow\">https://en.wikipedia.org/wiki/Pow_wow</a></p>\n</blockquote>\n<p>TIL, thanks :)</p>",
        "id": 238885218,
        "sender_full_name": "RalfJ",
        "timestamp": 1621072543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238819900\">said</a>:</p>\n<blockquote>\n<p>Here's a question: what is Structural Equality supposed to <strong>enable</strong>?<br>\nI get that it has a shaky definition, but I figure that it has a clear <strong>aim</strong>. Yet I have tried to read a bunch of these documents but I still don't know. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>yes indeed I think this is the question we should start with. :)</p>",
        "id": 238885238,
        "sender_full_name": "RalfJ",
        "timestamp": 1621072563
    },
    {
        "content": "<p>It is tied up with both <code>match</code> and const generics</p>",
        "id": 238885264,
        "sender_full_name": "RalfJ",
        "timestamp": 1621072577
    },
    {
        "content": "<p>My personal thinking (which is some variant of the links I posted <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238817640\">above</a>) is roughly as follows:<br>\nIn general, the value of a constant (<code>const</code>/<code>static</code> body, but also more general any <code>Constant</code> MIR operand, which includes all literals)  inside rustc is just an unstructured blob of bytes (and <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/interpret/struct.Allocation.html\"><code>Allocation</code></a>, in technical terms). This is sufficient for when a <code>const</code> is just used in code. (There's a slight inaccuracy here in that, for efficiency reasons, we do not actually create an <code>Allocation</code> for each integer literal, so we have more efficient representations for some very simple constants. This is not relevant for the <code>StructuralEq</code> discussion.)<br>\nHowever, there are 2 things the compiler does where an \"unstructured blob\" view of a constant is insufficient:</p>\n<ul>\n<li>pattern matching against a <code>const</code>, if we want exhaustiveness checking to properly take the <code>const</code> into account (i.e., \"as-if\" the <code>const</code> would have been written inline as a normal pattern). Note that if we <em>don't</em> do exhaustiveness checking then we can still treat the <code>const</code> as a blob; this is sound if exhaustiveness checking considers such a match arm to not match <em>anything</em>, thus enforcing the addition of a fallback <code>_</code> arm. In this case the <code>match</code> can be implemented by calling <code>PartialEq</code>.</li>\n<li>const generics. In particular here we need a notion of equality on consts that acts more like <code>PartialEq</code> than <code>memcmp</code>, i.e., comparing references by comparing their pointees and skipping padding bytes.</li>\n</ul>\n<p>Not all consts of all types can be treated in this more structured way, so this is where the need of a <code>StructuralEq</code> constraint arises.</p>\n<p>To support these usecases, the compiler will use \"valtrees\",  a high-level, more structural representation of a constant. A valtree is a tree where the leaves carry integer values and both pointer indirection and \"is a field of\" are represented as edges between nodes.<br>\nSo e.g. <code>2</code> would be a valtree with just a single node carrying a 2; <code>(2, 2)</code> would be a valtree where the root points to two leaf nodes that carry a 2. <code>&amp;2</code> would be a valtree where the root points to a leaf node that carries a 2. <code>(2,)</code> would be the same valtree as <code>&amp;2</code>; that's okay -- valtrees are meant to capture everything about a value that matters at a high level; comparing valtrees of different types is not very meaningful.</p>\n<p>Pattern matching exhaustiveness checking can use valtrees to basically convert a constant into a regular pattern and then treat it as-if that pattern had been written literally. Const generics can compare two valtrees (where inner nodes are compared by recursively comparing the children) to determine equality of const values.</p>\n<p>Now, which values are safe to be converted into valtees? I think this is the class of values that we want to say has \"structural equality\", and then we can say that <code>T: StructuralEq</code> if <em>all</em> values of <code>T</code> have \"structural equality\". (Note that e.g. the value <code>None::&lt;T&gt;</code> has structural equality for all <code>T</code>, that's why it makes sense to distinguish value-level and type-level notions here. I am not suggesting we actually do anything like this in rustc, but I think it is good to develop the theory in this style. And if we want to allow non-NAN floats in const generics, we <em>do</em> have to take this approach.)<br>\nThere are some values which we simply cannot turn into valtrees, so they are out, most notably all values of union type (because a union is just a bag of bytes, there's no high-level representation we can turn that into). But we also quickly realize that there is a deep link with equality here: the behavior of pattern matching against a constant should ideally be equivalent to testing equality with <code>PartialEq</code>. And likewise for const generics, when two constants are equal according to <code>PartialEq</code>, we better treat them as \"equal\" from the perspective of the type system. This guides us to the following key constraint that I think must be satisifed to ensure things make sense:</p>\n<p>STRUCT1: <em>Given two values <code>v1</code>, <code>v2</code> of type <code>T: PartialEq</code>, if both can be converted to a valtree then the valtrees are equal if and only if <code>v1 == v2</code>. Moreover, if <code>v1</code> can be converted to a valtree and <code>v2</code> cannot, then <code>!(v1 == v2)</code>.</em></p>\n<p>(Remember that \"can be converted to a valtree\" is equivalent to \"has structural equality\".)</p>\n<p>This is the basic minimum. I feel like we might want to strengthen this to make it easier to reason about; making definitions conditional on whether a type implements a trait is tricky business (if we aren't careful, adding a <code>PartialEq</code> impl can now break this property! We saw with <code>Pin</code> how easily this goes wrong). Also <code>PartialEq</code> allows some \"whacky\" non-reflexive equality relations which don't make these things easier to think about. So I think we want a property more like:</p>\n<p>STRUCT2: <em>When a value <code>v1</code> of type <code>T</code> can be converted to a valtree, then <code>T: Eq</code> and for any <code>v2: T</code>, their valtrees are equal if and only if <code>v1 == v2</code> (in particular if <code>v2</code> cannot be converted into a valtree, then <code>!(v1 == v2)</code>).</em></p>\n<p>As above, a type <code>T</code> is <code>StrucuralEq</code> if all its values can be converted to a valtree. This lends itself toward saying that the trait should be declared as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// SAFETY constraint: all values of this type must be convertible to valtrees such</span>\n<span class=\"sd\">/// that the valtrees are equal if and only if the values compare equal with `Eq::eq`.</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">StructuralEq</span>: <span class=\"nb\">Eq</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238886560,
        "sender_full_name": "RalfJ",
        "timestamp": 1621073891
    },
    {
        "content": "<p>(However, I am not entirely sure if this is fully backwards compatible -- we currently allow constants in pattern matching that are <em>not</em> <code>StructuralEq</code> under this definition, and I don't know if we do exhaustiveness checking for them.)</p>",
        "id": 238887042,
        "sender_full_name": "RalfJ",
        "timestamp": 1621074471
    },
    {
        "content": "<p>back compat strikes again <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>",
        "id": 238887093,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1621074502
    },
    {
        "content": "<p>It always does.^^</p>",
        "id": 238887137,
        "sender_full_name": "RalfJ",
        "timestamp": 1621074549
    },
    {
        "content": "<p>(Editing the text slightly, I realized after looking at <a href=\"https://github.com/rust-lang/rust/issues/74446\">https://github.com/rust-lang/rust/issues/74446</a> that we probably want something slightly stronger. -- Done)</p>",
        "id": 238887155,
        "sender_full_name": "RalfJ",
        "timestamp": 1621074573
    },
    {
        "content": "<p>Note that the requirement of <code>StructuralEq</code> as given above implies that <code>Eq</code> actually is a proper equivalence relation, assuming that the equality on valtrees is (which I am pretty sure we want^^). So that would be another argument for why talking about <code>PartialEq</code> makes little sense.</p>",
        "id": 238887570,
        "sender_full_name": "RalfJ",
        "timestamp": 1621074933
    },
    {
        "content": "<p>That said, for <em>per-value</em> structural equality, <code>1.0f32</code> could have structural equality, just <code>NAN</code> couldn't -- so STRUCT2 could reasonably be weakened to <code>PartialEq</code>.</p>",
        "id": 238887729,
        "sender_full_name": "RalfJ",
        "timestamp": 1621075025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238887093\">said</a>:</p>\n<blockquote>\n<p>back compat strikes again <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>\n</blockquote>\n<p>I think we'll be fine though... assuming floats and (raw and fn) pointers always require a <code>_</code> arm</p>",
        "id": 238887849,
        "sender_full_name": "RalfJ",
        "timestamp": 1621075135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238686037\">said</a>:</p>\n<blockquote>\n<p>So in <a href=\"https://github.com/rust-lang/rust/issues/84045\">#84045</a> <a href=\"https://github.com/rust-lang/rust/pull/84045#issuecomment-839850571\">we were discussing</a> the idea of having a pow-wow to talk over structural equality (cc <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span>, <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span>, <span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span>, <span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span>), maybe we could use a const generics meeting to push on that? e.g. next week at <time datetime=\"2021-05-18T14:45:00Z\">2021-05-18T10:45:00-04:00</time> ?</p>\n</blockquote>\n<p>yes that time works for me</p>",
        "id": 238887894,
        "sender_full_name": "RalfJ",
        "timestamp": 1621075201
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> is there a link for where the meeting will happen?</p>",
        "id": 239258957,
        "sender_full_name": "RalfJ",
        "timestamp": 1621346638
    },
    {
        "content": "<p>I assume here on zulip, but if not, I would also like to know that.</p>",
        "id": 239259258,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621346761
    },
    {
        "content": "<p>oh I thought it'd be a live call (for higher bandwidth)</p>",
        "id": 239259351,
        "sender_full_name": "RalfJ",
        "timestamp": 1621346789
    },
    {
        "content": "<p>so, we have <a href=\"https://github.com/rust-lang/rust/issues/74446\">#74446</a>, especially <a href=\"https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790\">ralfs summary</a></p>",
        "id": 239262214,
        "sender_full_name": "lcnr",
        "timestamp": 1621347915
    },
    {
        "content": "<p>there's <a href=\"https://github.com/rust-lang/rust/issues/84391\">#84391</a> which brings up some concerns with implicitly making stuff structural match. The concern seems to be that going from a derived <code>PartialEq</code> to a manual one is breaking if it there is a way to get a constant of that type.</p>",
        "id": 239263314,
        "sender_full_name": "lcnr",
        "timestamp": 1621348305
    },
    {
        "content": "<p>there's <a href=\"https://github.com/rust-lang/project-const-generics/issues/6\">project-const-generics#6</a>, which is about the same issue but only focussed on allowing types as const param types</p>",
        "id": 239263479,
        "sender_full_name": "lcnr",
        "timestamp": 1621348352
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/project-const-generics/issues/7\">project-const-generics#7</a> is about structural match for function pointers. The issue is that equality for function pointers is non det at runtime. It is however deterministic at compile time. Considering the utility of allowing function pointers as const params I am still of the opinion that warning for fn ptr comparisions outside of statics/constants and allowing them as const params (but not in <code>match</code> expressions)</p>",
        "id": 239264217,
        "sender_full_name": "lcnr",
        "timestamp": 1621348574
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/71415\">#71415</a> is about requirements for generic const param types so it's not too relevant for us rn imo</p>",
        "id": 239264691,
        "sender_full_name": "lcnr",
        "timestamp": 1621348734
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239263314\">said</a>:</p>\n<blockquote>\n<p>there's <a href=\"https://github.com/rust-lang/rust/issues/84391\">#84391</a> which brings up some concerns with implicitly making stuff structural match. The concern seems to be that going from a derived <code>PartialEq</code> to a manual one is breaking if it there is a way to get a constant of that type.</p>\n</blockquote>\n<p>this would be mitigated once users can do <code>unsafe impl StructuralEq for T</code>, i.e. one that trait is stable, right?</p>",
        "id": 239265541,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349019
    },
    {
        "content": "<p>not sure, because the type probably lost the \"structural match property\" during that change</p>",
        "id": 239265719,
        "sender_full_name": "lcnr",
        "timestamp": 1621349072
    },
    {
        "content": "<p>e.g. <code>TypeId</code> won't be structurally match after the desired refactoring, so the \"bug\" is more in that it's currently structural match but shouldn't be</p>",
        "id": 239265900,
        "sender_full_name": "lcnr",
        "timestamp": 1621349140
    },
    {
        "content": "<p>that would be a change in behavior of the <code>PartialEq</code> impl -- so that's like replacing a <code>derive(Clone)</code> with a manual <code>impl Clone</code> that's <em>different</em>. of course that's a breaking change?</p>",
        "id": 239265930,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349153
    },
    {
        "content": "<p>not really, <code>TypeId</code> is fully opaque</p>",
        "id": 239266028,
        "sender_full_name": "lcnr",
        "timestamp": 1621349179
    },
    {
        "content": "<p>oh so the complaint is that <code>derive(PartialEq)</code> is too implicit in how it also promises StructuralEq?</p>",
        "id": 239266085,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349199
    },
    {
        "content": "<p>so as long as the user visible behavior remains the same, i.e. type ids which are equal remain equal</p>",
        "id": 239266086,
        "sender_full_name": "lcnr",
        "timestamp": 1621349199
    },
    {
        "content": "<p>Yeah, also, you can replace <code>derive(PartialEq,Eq)</code> with a structural implementation w/o the implicit StructuralPartialEq,StructuralEq</p>",
        "id": 239266182,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621349232
    },
    {
        "content": "<p>(FWIW TypeId might still be StructuralEq after the change -- after all the entire point of that change is to fix TypeId runtime equality tests)</p>",
        "id": 239266240,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349253
    },
    {
        "content": "<p>well, I guess <span class=\"user-group-mention\" data-user-group-id=\"3805\">@project-const-generics</span> <span class=\"user-group-mention\" data-user-group-id=\"1916\">@WG-const-eval</span> structural match meeting time <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>",
        "id": 239266403,
        "sender_full_name": "lcnr",
        "timestamp": 1621349296
    },
    {
        "content": "<p>(But in this case, yes, the implementation that I seek is not completely structural, as it adds a potential extra strcmp)</p>",
        "id": 239266468,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621349315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239266182\">said</a>:</p>\n<blockquote>\n<p>Yeah, also, you can replace <code>derive(PartialEq,Eq)</code> with a structural implementation w/o the implicit StructuralPartialEq,StructuralEq</p>\n</blockquote>\n<p>sure, but then (assuming a stable trait) you can also manually <code>unsafe impl StructuralEq</code> for it</p>",
        "id": 239266480,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349321
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239266468\">said</a>:</p>\n<blockquote>\n<p>(But in this case, yes, the implementation that I seek is not completely structural, as it adds a potential extra strcmp)</p>\n</blockquote>\n<p><code>&amp;str</code> is (or could be) <code>StructuralEq</code> so I dont see the problem with <code>strcmp</code></p>",
        "id": 239266611,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349375
    },
    {
        "content": "<p>True. I can post the particular implementation I had in mind for <code>TypeId</code>, because that may effect that. However, one could argue that references are special cases for structural equality. Though for something like const-generics, that may or may not have issues.</p>",
        "id": 239266913,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621349490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239266403\">said</a>:</p>\n<blockquote>\n<p>well, I guess <span class=\"user-group-mention\" data-user-group-id=\"3805\">@project-const-generics</span> <span class=\"user-group-mention\" data-user-group-id=\"1916\">@WG-const-eval</span> structural match meeting time <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span></p>\n</blockquote>\n<p>do we have a problem statement for what we're trying to solve in this meeting?<br>\nas you noted I left my thoughts at <a href=\"https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790\">https://github.com/rust-lang/rust/issues/74446#issuecomment-841637790</a>, happy to answer any questions about that</p>",
        "id": 239266914,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349490
    },
    {
        "content": "<p>\"figure out structural match\" :p</p>",
        "id": 239266971,
        "sender_full_name": "lcnr",
        "timestamp": 1621349511
    },
    {
        "content": "<p>i don't think we have a clear goal here <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 239267058,
        "sender_full_name": "lcnr",
        "timestamp": 1621349530
    },
    {
        "content": "<p>I think we may want to step back and figure out the user visible behaviour first. It seems from the discussion that we aren't even clear on how something fundamental like float should behave</p>",
        "id": 239267061,
        "sender_full_name": "oli",
        "timestamp": 1621349531
    },
    {
        "content": "<p>I think figuring out the underlying structure (heh) helps to determine reasonable user-visible behavior</p>",
        "id": 239267186,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349585
    },
    {
        "content": "<p>so that's what I went for in my post :D</p>",
        "id": 239267231,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349606
    },
    {
        "content": "<blockquote>\n<p>STRUCT2: When a value v1 of type T can be converted to a valtree, then T: Eq and for any v2: T, their valtrees are equal if and only if v1 == v2 (in particular if v2 cannot be converted into a valtree, then !(v1 == v2)).</p>\n</blockquote>",
        "id": 239267547,
        "sender_full_name": "lcnr",
        "timestamp": 1621349709
    },
    {
        "content": "<p>Well... the base thing from pattern  matching is that patterns are the reverse of building the value. This opens up questions like \"can you deconstruct something with private fields\"</p>",
        "id": 239267573,
        "sender_full_name": "oli",
        "timestamp": 1621349717
    },
    {
        "content": "<p>Or can we match NaN</p>",
        "id": 239267619,
        "sender_full_name": "oli",
        "timestamp": 1621349731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219696\">XAMPPRocky</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/238868865\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> A “pow wow” is American slang for a meeting. <a href=\"https://en.wikipedia.org/wiki/Pow_wow\">https://en.wikipedia.org/wiki/Pow_wow</a></p>\n</blockquote>\n<p>you know Ralf, until you asked, I never thought about it, but probably I shouldn't use it. It doesn't seem very respectful. Apologies.</p>",
        "id": 239267653,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621349740
    },
    {
        "content": "<p>but I think starting with the problem statement helps, that's kind of user-visible...</p>\n<ul>\n<li>not all constants can be used as const generic arguments. which subset can we support, and which do we want to make work?</li>\n<li>when a constant is used as a pattern, if we want that to interact with exhaustiveness checking (or if we want to match on non-<code>PartialEq</code> constants -- is that a thing?), we again can only support a subset of constants, which subset makes sense?</li>\n</ul>",
        "id": 239267734,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239267619\">said</a>:</p>\n<blockquote>\n<p>Or can we match NaN</p>\n</blockquote>\n<p>Ouch. The NaN thing is a sticking point as it has many bit-level representations. Are all NaNs equal?</p>",
        "id": 239267804,
        "sender_full_name": "Hameer Abbasi",
        "timestamp": 1621349792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239267573\">said</a>:</p>\n<blockquote>\n<p>Well... the base thing from pattern  matching is that patterns are the reverse of building the value. This opens up questions like \"can you deconstruct something with private fields\"</p>\n</blockquote>\n<p>I dont know what you mean by \"decosntruct\" here -- we're talking about patterns without binders, so this is always just an equality test and of course you can equality test things with private fields</p>",
        "id": 239267839,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349807
    },
    {
        "content": "<p>With \"deconstruct\" I mean to build a pattern out of an aggregate const</p>",
        "id": 239267953,
        "sender_full_name": "oli",
        "timestamp": 1621349859
    },
    {
        "content": "<p>that seems like something internal, what's the user-visible part? :D</p>",
        "id": 239267982,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349872
    },
    {
        "content": "<p>We can pattern match things without partialeq impls, just not via constants</p>",
        "id": 239268053,
        "sender_full_name": "oli",
        "timestamp": 1621349890
    },
    {
        "content": "<p>Heh, I forgot that I proposed to use this slot</p>",
        "id": 239268085,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621349903
    },
    {
        "content": "<p>So equality is not really the right thing here?</p>",
        "id": 239268094,
        "sender_full_name": "oli",
        "timestamp": 1621349908
    },
    {
        "content": "<p>I'm still catching up from ralf's monster message :)</p>",
        "id": 239268142,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621349920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239268094\">said</a>:</p>\n<blockquote>\n<p>So equality is not really the right thing here?</p>\n</blockquote>\n<p>do you mean \"is obviously the right thing\"? once we ruled out non-PartialEq then what else would we do?</p>",
        "id": 239268209,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349943
    },
    {
        "content": "<p>(IOW I dont follow your \"so\", I would have concluded the exact opposite)</p>",
        "id": 239268279,
        "sender_full_name": "RalfJ",
        "timestamp": 1621349979
    },
    {
        "content": "<p>I don't understand what you are asking</p>",
        "id": 239268294,
        "sender_full_name": "oli",
        "timestamp": 1621349983
    },
    {
        "content": "<p>If you have a struct without a partialeq impl, you can still pattern match it directly without constants</p>",
        "id": 239268430,
        "sender_full_name": "oli",
        "timestamp": 1621350020
    },
    {
        "content": "<p>I am saying for a constant <code>C</code>, the pattern <code>C</code> always behaves like the pattern <code>_ if &lt;discriminee&gt; == C</code></p>",
        "id": 239268434,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350021
    },
    {
        "content": "<p>So patterns don't really say anything about equality, right?</p>",
        "id": 239268465,
        "sender_full_name": "oli",
        "timestamp": 1621350035
    },
    {
        "content": "<p>As long as one can specialise, I think <code>Eq</code> is absolutely the right thing. I think <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> is speaking about how <code>Eq</code> behaves wrt NaN and how it could become impossible to match NaNs.</p>",
        "id": 239268484,
        "sender_full_name": "Hameer Abbasi",
        "timestamp": 1621350038
    },
    {
        "content": "<p>Let's ignore nan for now</p>",
        "id": 239268539,
        "sender_full_name": "oli",
        "timestamp": 1621350059
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239268465\">said</a>:</p>\n<blockquote>\n<p>So patterns don't really say anything about equality, right?</p>\n</blockquote>\n<p>we agree that patterns (in particular those without binders) are closely related to equality, dont we?</p>",
        "id": 239268586,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350063
    },
    {
        "content": "<p>Not necessarily.</p>",
        "id": 239268635,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621350082
    },
    {
        "content": "<p>they are a kind of equality test, an equivalence relation</p>",
        "id": 239268638,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350083
    },
    {
        "content": "<p>Not really</p>",
        "id": 239268673,
        "sender_full_name": "oli",
        "timestamp": 1621350096
    },
    {
        "content": "<p>whether that's the same as <code>==</code> is a different question</p>",
        "id": 239268688,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350102
    },
    {
        "content": "<p>of course they are?</p>",
        "id": 239268695,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350105
    },
    {
        "content": "<p>I think a good goal for this meeting would be to get a high-level view of the operations required and the desired relationships  between them</p>",
        "id": 239268707,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350109
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">PartialEq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">partial_eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 239268798,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621350133
    },
    {
        "content": "<p>I think what <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> is saying is that we have two kinds of runtime equaliy test</p>\n<ul>\n<li>matching against a constant</li>\n<li>comparing with <code>==</code></li>\n</ul>",
        "id": 239268802,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350135
    },
    {
        "content": "<p>They are about construction and deconstrution to me, often equality means the same thing</p>",
        "id": 239268821,
        "sender_full_name": "oli",
        "timestamp": 1621350139
    },
    {
        "content": "<p>deconstruction is about binding to fields</p>",
        "id": 239268904,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350171
    },
    {
        "content": "<p>but we're talking about binder-free patterns here</p>",
        "id": 239268931,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350176
    },
    {
        "content": "<p>so I dont think deconstruction is relevant</p>",
        "id": 239268966,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> exactly. we have <code>match x { C =&gt; true, _ =&gt; false }</code> and <code>x == C</code>.</p>",
        "id": 239269122,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350219
    },
    {
        "content": "<p>in particular I dont' think anyone is asserting that the two are necessarily equivalent in behavior</p>",
        "id": 239269136,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350225
    },
    {
        "content": "<p>Isn't lack of binders just a special case?</p>",
        "id": 239269137,
        "sender_full_name": "oli",
        "timestamp": 1621350226
    },
    {
        "content": "<p>Deconstruction without binders is still surely deconstruction?</p>",
        "id": 239269153,
        "sender_full_name": "varkor",
        "timestamp": 1621350231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239269137\">said</a>:</p>\n<blockquote>\n<p>Isn't lack of binders just a special case?</p>\n</blockquote>\n<p>for constants used as patterns its the only case, isnt it?</p>",
        "id": 239269222,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350245
    },
    {
        "content": "<p>we allow non-StructuralEq patterns on stable today (kind of by accident, but still). so clearly \"deconstruction\" is not what is going on in general.</p>",
        "id": 239269344,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350280
    },
    {
        "content": "<p>can you give a concrete example thereof?</p>",
        "id": 239269392,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350298
    },
    {
        "content": "<p>I guess floats :)</p>",
        "id": 239269406,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350303
    },
    {
        "content": "<p>(potentially?)</p>",
        "id": 239269418,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350306
    },
    {
        "content": "<p>(I'm trying to think how to organize the conversation here a bit)</p>",
        "id": 239269470,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350318
    },
    {
        "content": "<p>no not floats... oli had ane xample somewhere, let me find it...</p>",
        "id": 239269481,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350321
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=dc3b8eb7eb67cfaa0c0a38c0526a9ed9\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=dc3b8eb7eb67cfaa0c0a38c0526a9ed9</a></p>",
        "id": 239269532,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350335
    },
    {
        "content": "<p>do we have a list of \"requirements\" that pattern matching wants from structural eq and a list of \"requirements\" that const generics wants?</p>",
        "id": 239269545,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1621350339
    },
    {
        "content": "<p>The Foo example I showed above wouldn't be <code>StructuralEq</code></p>",
        "id": 239269549,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621350339
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239269549\">said</a>:</p>\n<blockquote>\n<p>The Foo example I showed above wouldn't be <code>StructuralEq</code></p>\n</blockquote>\n<p>thats matching a constructor though, not a constant. I think we are making a difference between those?</p>",
        "id": 239269685,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350377
    },
    {
        "content": "<p>(they are treated very similarly in the compiler internally, but I feel like for this discussion we probably dont want to lump them together)</p>",
        "id": 239269767,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350406
    },
    {
        "content": "<p>in particular constructors <em>can</em> have binders when used in patterns (yours just doesnt)</p>",
        "id": 239269797,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239269532\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=dc3b8eb7eb67cfaa0c0a38c0526a9ed9\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=dc3b8eb7eb67cfaa0c0a38c0526a9ed9</a></p>\n</blockquote>\n<p>that's a good one</p>",
        "id": 239269951,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239269392\">said</a>:</p>\n<blockquote>\n<p>can you give a concrete example thereof?</p>\n</blockquote>\n<p>so basically the current check stops at references and that's wrong</p>",
        "id": 239269963,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350478
    },
    {
        "content": "<p>ah no it was more complicated</p>",
        "id": 239270065,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350503
    },
    {
        "content": "<p>I forgot the details^^</p>",
        "id": 239270080,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239269545\">said</a>:</p>\n<blockquote>\n<p>do we have a list of \"requirements\" that pattern matching wants from structural eq and a list of \"requirements\" that const generics wants?</p>\n</blockquote>\n<p>that is a good suggestion, I think, of something to work towards</p>",
        "id": 239270096,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350516
    },
    {
        "content": "<p>but anyway we have a \"hole\" in our structural-match story</p>",
        "id": 239270127,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350523
    },
    {
        "content": "<p>agreed. I tried that a bit in my text as well.<br>\nfor pattern matching basically I think we have no requirement at all <em>if</em> we require constants to be <code>PartialEq</code> and ignore them in exhaustiveness checking.</p>",
        "id": 239270222,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350562
    },
    {
        "content": "<p>it seems like there are 3 operations:</p>\n<ul>\n<li>runtime equality <code>a == b</code></li>\n<li>pattern matching against a constant</li>\n<li>const generics and equality</li>\n</ul>\n<p>I think we all basically agree that the first one is not part of this discussion and that it will not necessarily be equivalent to the latter two, but would like there to be some continuum for the latter two?</p>\n<p>This is clearly a potential breaking change (though we could do it over an edition if necessary)</p>",
        "id": 239270232,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350567
    },
    {
        "content": "<p>but we currently don't ignore them in exhaustiveness checking, right?</p>",
        "id": 239270297,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350591
    },
    {
        "content": "<p>or at least, sometimes we don't</p>",
        "id": 239270306,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350594
    },
    {
        "content": "<blockquote>\n<p>I think we all basically agree that the first one is not part of this discussion and that it will not necessarily be equivalent to the latter two, but would like there to be some continuum for the latter two?</p>\n</blockquote>\n<p>disagreed. the original StructuralEq proposal, in my interpretation, was all about ensuring that matching against a constant is equivalent to testing equality.</p>",
        "id": 239270389,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350612
    },
    {
        "content": "<p>and in terms of avoiding surprises, that seems like reasonable behavior.</p>",
        "id": 239270419,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350623
    },
    {
        "content": "<p>indeed when matching against contants that cannot be \"converted to patterns\", that is pretty much the only way we have for compiling a <code>match</code></p>",
        "id": 239270491,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350648
    },
    {
        "content": "<p>OK. I used to feel that way. I've been shifting some.</p>",
        "id": 239270496,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350651
    },
    {
        "content": "<p>so there's literally code in <code>match</code> lowering today that sues PartialEq. thus we definitely have to consider this relationship.</p>",
        "id": 239270532,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350665
    },
    {
        "content": "<p>ah, yes, so this intersects const generics because converting to patterns is not possible unless we do it post-monomorphization</p>",
        "id": 239270573,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350683
    },
    {
        "content": "<p>this also means if we dont have a continuum between PartialEq and match, we get surprising \"non-linear\" behvaior changes when match lowering switches between one or the other.</p>",
        "id": 239270586,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350691
    },
    {
        "content": "<p>right, so MIR currently lowers to <code>PartialEq</code> because we (falsely) believed that we were limited to cases where this was equivalent</p>",
        "id": 239270739,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350740
    },
    {
        "content": "<p>basically I think we should ensure that just adding <code>unsafe impl StructuralEq for T</code> will never change the behavior of existing code that matches against constants of type <code>T</code></p>",
        "id": 239270749,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350744
    },
    {
        "content": "<blockquote>\n<p>ah, yes, so this intersects const generics because converting to patterns is not possible unless we do it post-monomorphization</p>\n</blockquote>\n<p>The idea here was to always use partialeq for const generics used in patterns</p>",
        "id": 239270750,
        "sender_full_name": "oli",
        "timestamp": 1621350745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239270573\">said</a>:</p>\n<blockquote>\n<p>ah, yes, so this intersects const generics because converting to patterns is not possible unless we do it post-monomorphization</p>\n</blockquote>\n<p>I dont follow, what does this have to do with monomorphization?</p>",
        "id": 239270768,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350756
    },
    {
        "content": "<p>Right now we don't allow any generics I think</p>",
        "id": 239270769,
        "sender_full_name": "oli",
        "timestamp": 1621350756
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> if there are no generic types involved, are there constants that cannot be converted to patterns?</p>",
        "id": 239270837,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350782
    },
    {
        "content": "<p><code>union</code>s</p>",
        "id": 239270906,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350808
    },
    {
        "content": "<p>interesting</p>",
        "id": 239270936,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350823
    },
    {
        "content": "<p>possibly NaN? possibly raw ptrs / fn ptrs?</p>",
        "id": 239270953,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350827
    },
    {
        "content": "<p>Well, those error even if directly used as a pattern</p>",
        "id": 239270958,
        "sender_full_name": "oli",
        "timestamp": 1621350828
    },
    {
        "content": "<p>Can you even match <code>union</code> constants?<br>\nIf not, should you be able to?</p>",
        "id": 239270986,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621350840
    },
    {
        "content": "<p>Unions are a hard error</p>",
        "id": 239271063,
        "sender_full_name": "oli",
        "timestamp": 1621350853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239270986\">said</a>:</p>\n<blockquote>\n<p>Can you even match <code>union</code> constants?<br>\nIf not, should you be able to?</p>\n</blockquote>\n<p>well I'd think you can with oli's trick^^<br>\nnot sure if unions are ever <code>StructuralEq</code></p>",
        "id": 239271094,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239270953\">said</a>:</p>\n<blockquote>\n<p>possibly NaN? possibly raw ptrs / fn ptrs?</p>\n</blockquote>\n<p>so, these are kind of \"special cases\" in my view, but they compile (presently) to the <code>PartialEq</code> impl, and hence NaN != NaN</p>",
        "id": 239271165,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350889
    },
    {
        "content": "<p>Oh... right... the partialeq fallback</p>",
        "id": 239271183,
        "sender_full_name": "oli",
        "timestamp": 1621350894
    },
    {
        "content": "<p>special cases in that they are like constant patterns but they are of atomic types that cannot themselves be further subdivided</p>",
        "id": 239271229,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350910
    },
    {
        "content": "<p>unions is an interesting case</p>",
        "id": 239271300,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621350933
    },
    {
        "content": "<blockquote>\n<p>well I'd think you can with oli's trick^^</p>\n</blockquote>\n<p>I wasn't able to <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0ae136bff2d56627abbeed9bd8b7eb6e\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0ae136bff2d56627abbeed9bd8b7eb6e</a></p>",
        "id": 239271301,
        "sender_full_name": "lcnr",
        "timestamp": 1621350933
    },
    {
        "content": "<p>ah, the trick doesnt seem to work for unions?<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=80ea280ebd1d6ae6626fb1c61c5f60fb\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=80ea280ebd1d6ae6626fb1c61c5f60fb</a></p>",
        "id": 239271375,
        "sender_full_name": "RalfJ",
        "timestamp": 1621350962
    },
    {
        "content": "<p>Try wrapping it one level deeper in a non structuraleq wrapper type</p>",
        "id": 239271501,
        "sender_full_name": "oli",
        "timestamp": 1621350996
    },
    {
        "content": "<p>...?</p>",
        "id": 239271533,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351010
    },
    {
        "content": "<p>Maybe it won't see the Union then <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 239271536,
        "sender_full_name": "oli",
        "timestamp": 1621351012
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=62170a5da3cb4e387b6a17f964d44578\">the following example prints \"other\"</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">CFN</span>: <span class=\"kt\">f64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f64</span>::<span class=\"n\">NAN</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">BFN</span>: <span class=\"kt\">f64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f64</span>::<span class=\"n\">NAN</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">CFN</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">CFN</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"CFN\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">BFN</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"BFN\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Other\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 239271602,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239271536\">said</a>:</p>\n<blockquote>\n<p>Maybe it won't see the Union then <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</blockquote>\n<p>it sees even this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">CFN</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Wrap</span><span class=\"o\">&lt;&amp;</span><span class=\"n\">Wrap</span><span class=\"o\">&lt;</span><span class=\"n\">Bar</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">Wrap</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Wrap</span><span class=\"p\">(</span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span>: <span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}));</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 239271866,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351122
    },
    {
        "content": "<p>but anyway I am not sure where this is going?^^</p>",
        "id": 239271878,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351130
    },
    {
        "content": "<p>union in pattern <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a4743ba694ed2f00b55d373e0c2aeb61\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=a4743ba694ed2f00b55d373e0c2aeb61</a></p>",
        "id": 239271896,
        "sender_full_name": "lcnr",
        "timestamp": 1621351137
    },
    {
        "content": "<p>OK, well, <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> the connection to monomorphization in my mind was somethig like this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">B</span>: <span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Obviously we cant' convert <code>B</code> into anything other than <code>PartialEq</code></p>",
        "id": 239271958,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351166
    },
    {
        "content": "<p>(until we know its value more precisely)</p>",
        "id": 239272006,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351182
    },
    {
        "content": "<p>ah, yes, that too</p>",
        "id": 239272033,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351195
    },
    {
        "content": "<blockquote>\n<p>Obviously we cant' </p>\n</blockquote>\n<p>we can't?  think we should do so</p>",
        "id": 239272038,
        "sender_full_name": "lcnr",
        "timestamp": 1621351197
    },
    {
        "content": "<p>let me rephrase that: we can't without more MIR constructs</p>",
        "id": 239272112,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351212
    },
    {
        "content": "<p>what we obviously can't do is determine whether that match is exhaustive</p>",
        "id": 239272180,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351237
    },
    {
        "content": "<p>so starting there, I hope we agree that we need a \"continuum\" between the two ways to compile constants into a pattern (opaque blob with <code>PartialEq</code>, and converting the constant into a proper pattern)</p>",
        "id": 239272189,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351241
    },
    {
        "content": "<p>let's elaborate that a bit-- why can't we use <code>ParialEq</code> everywhere</p>",
        "id": 239272322,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351280
    },
    {
        "content": "<ul>\n<li>backwards compatibility</li>\n</ul>",
        "id": 239272332,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351284
    },
    {
        "content": "<ul>\n<li>not as nice, because no exhaustiveness checking</li>\n</ul>",
        "id": 239272351,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239272332\">said</a>:</p>\n<blockquote>\n<ul>\n<li>backwards compatibility</li>\n</ul>\n</blockquote>\n<p>I think we should be fine here -- doesnt oli's example compile to PartialEq so the \"bad\" cases wouldnt change behavior?</p>",
        "id": 239272510,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351339
    },
    {
        "content": "<p>those two are connected, I think, in that I think the backwards compat concerns are mostly around exhaustiveness checking? or maybe we already do some desugaring of constants and hence there are also cases where the runtime semantics differ?</p>",
        "id": 239272515,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351342
    },
    {
        "content": "<p>I suppose the other question would be: if structural match against constants isn't just PartialEq, what is it? In my mind, w/o references or floats, it's just <code>memcmp_ignore_padding</code>.</p>",
        "id": 239272545,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621351353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239272510\">said</a>:</p>\n<blockquote>\n<p>I think we should be fine here -- doesnt oli's example compile to PartialEq so the \"bad\" cases wouldnt change behavior?</p>\n</blockquote>\n<p>my belief is that today we do <em>sometimes</em> \"unroll\" constants into patterns</p>",
        "id": 239272654,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239272545\">said</a>:</p>\n<blockquote>\n<p>I suppose the other question would be: if structural match against constants isn't just PartialEq, what is it? In my mind, w/o references or floats, it's just <code>memcmp_ignore_padding</code>.</p>\n</blockquote>\n<p>it's \"translate/deconstruct constant value to a pattern, match against that pattern\".<br>\nI think that's equivalent.</p>",
        "id": 239272658,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239272654\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239272510\">said</a>:</p>\n<blockquote>\n<p>I think we should be fine here -- doesnt oli's example compile to PartialEq so the \"bad\" cases wouldnt change behavior?</p>\n</blockquote>\n<p>my belief is that today we do <em>sometimes</em> \"unroll\" constants into patterns</p>\n</blockquote>\n<p>yes we definitely do</p>",
        "id": 239272678,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351409
    },
    {
        "content": "<p>but I guess the check works well enough to ensure we only do that in cases where PartialEq/Eq are derived?</p>",
        "id": 239272731,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351432
    },
    {
        "content": "<p>Also, compiling to a potentially User-defined PartialEq w/ exhaustiveness checking would run into the exact issue that was debated for <a class=\"stream\" data-stream-id=\"281601\" href=\"/#narrow/stream/281601-project-deref-patterns\">#project-deref-patterns</a>, a malicious impl could make assumption of exhaustiveness unsound.</p>",
        "id": 239272805,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621351444
    },
    {
        "content": "<p>(do we not do it through <code>&amp;</code> patterns?)</p>",
        "id": 239272816,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239272731\">said</a>:</p>\n<blockquote>\n<p>but I guess the check works well enough to ensure we only do that in cases where PartialEq/Eq are derived?</p>\n</blockquote>\n<p>I think so... oli's example AFAIK relies on us falling back to the \"opaque blob, use PartialEq\" path too eagerly without properly checking for StructuralEq</p>",
        "id": 239272880,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351481
    },
    {
        "content": "<blockquote>\n<p>(do we not do it through <code>&amp;</code> patterns?)</p>\n</blockquote>\n<p>Yes</p>",
        "id": 239272961,
        "sender_full_name": "oli",
        "timestamp": 1621351515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239272805\">said</a>:</p>\n<blockquote>\n<p>Also, compiling to a potentially User-defined PartialEq w/ exhaustiveness checking would run into the exact issue that was debated for <a class=\"stream\" data-stream-id=\"281601\" href=\"/#narrow/stream/281601-project-deref-patterns\">#project-deref-patterns</a>, a malicious impl could make assumption of exhaustiveness unsound.</p>\n</blockquote>\n<p>it is definitely true that using PartiaEq without ensuring StructuralEq means we have to ignore the constant for exhaustiveness checking</p>",
        "id": 239272980,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351519
    },
    {
        "content": "<p>StructuralEq, in that view, basically puts the exhaustiveness check correctness obligation on the user and their <code>unsafe impl StrucutralEq</code></p>",
        "id": 239273068,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351554
    },
    {
        "content": "<p>(the trait is currently not unsafe, but if we rely on it like this it has to be)</p>",
        "id": 239273099,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351563
    },
    {
        "content": "<p>Well, that sounds like it would be <code>DerefPure</code> all over again.</p>",
        "id": 239273166,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621351581
    },
    {
        "content": "<p>?</p>",
        "id": 239273194,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351590
    },
    {
        "content": "<p>the StructuralEq definition(s) I proposed already take care of this obligation</p>",
        "id": 239273231,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=583e264700a81f30bff5dc742268d2f1\">how does this code compile</a>?</p>",
        "id": 239273278,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351622
    },
    {
        "content": "<p>we must be unrolling there, no?</p>",
        "id": 239273332,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351640
    },
    {
        "content": "<p><code>reffoo</code> has a <code>switchInt((*_1)) -&gt; [false: bb1, otherwise: bb2]</code></p>",
        "id": 239273433,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351679
    },
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> I'm coming up a bit slow beacuse I haven't caght up with your messages, but is the outline something like this:</p>\n<ul>\n<li>there is a way to declare structural equality</li>\n<li>if that is not known to be true, we fall back to partial equality ?</li>\n</ul>",
        "id": 239273500,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351693
    },
    {
        "content": "<blockquote>\n<p>the exhaustiveness check correctness obligation</p>\n</blockquote>\n<p>we still don't use the <code>PartialEq</code> impl for exhaustiveness checking, do we?</p>",
        "id": 239273543,
        "sender_full_name": "lcnr",
        "timestamp": 1621351710
    },
    {
        "content": "<p>Yeah, if <code>StructuralEq</code> just skips <code>PartialEq</code> and becomes always a \"convert into a pattern and match that\", then it would skip the issue of specifying how <code>StructuralEq</code> constrains <code>PartialEq</code></p>",
        "id": 239273573,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621351722
    },
    {
        "content": "<blockquote>\n<p>if that is not known to be true, we fall back to partial equality ?</p>\n</blockquote>\n<p>well, usually we fall back to rejecting the pattern. but sometimes we dont and then we fall back to <code>PartialEq</code>.</p>",
        "id": 239273599,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351732
    },
    {
        "content": "<blockquote>\n<p>we must be unrolling there, no?</p>\n</blockquote>\n<p>Yes, we unroll all constants up to where they are not structeq</p>",
        "id": 239273608,
        "sender_full_name": "oli",
        "timestamp": 1621351737
    },
    {
        "content": "<p>exhaustiveness checking only uses val trees (it should imo?)?</p>",
        "id": 239273626,
        "sender_full_name": "lcnr",
        "timestamp": 1621351745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239273573\">said</a>:</p>\n<blockquote>\n<p>Yeah, if <code>StructuralEq</code> just skips <code>PartialEq</code> and becomes always a \"convert into a pattern and match that\", then it would skip the issue of specifying how <code>StructuralEq</code> constrains <code>PartialEq</code></p>\n</blockquote>\n<p>no it wouldnt, since we want to ensure a continuum of behavior between the two ways of compiling patterns</p>",
        "id": 239273653,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239273626\">said</a>:</p>\n<blockquote>\n<p>exhaustiveness checking only uses val trees (it should imo?)?</p>\n</blockquote>\n<p>not implemented yet, but that's the plan</p>",
        "id": 239273711,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351775
    },
    {
        "content": "<p>Implemented but not merged</p>",
        "id": 239273735,
        "sender_full_name": "oli",
        "timestamp": 1621351788
    },
    {
        "content": "<p>current valtrees dont support \"starts as a tree, then has a blob at some leaf\" though :/</p>",
        "id": 239273741,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351794
    },
    {
        "content": "<p>so this could slightly change exhaustiveness checking behavior compared to \"we unroll all constants up to where they are not structeq\"</p>",
        "id": 239273885,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351829
    },
    {
        "content": "<p>but I hope not really in practice^^</p>",
        "id": 239273920,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351843
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239273599\">said</a>:</p>\n<blockquote>\n<p>well, usually we fall back to rejecting the pattern. but sometimes we dont and then we fall back to <code>PartialEq</code>.</p>\n</blockquote>\n<p>what determines the reasons to fall back?</p>",
        "id": 239273950,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351852
    },
    {
        "content": "<p>I'm afraid I am out of my depths here, I carefully avoided the pattern matching code in most of what I do^^</p>",
        "id": 239274023,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351879
    },
    {
        "content": "<p>so for pattern, we could say: while the current type is <code>structural_eq</code>, unroll to a pattern (i.e. with exhaustiveness checking) and once we encounter one type which is not structural eq we stop and use <code>PartialEq</code>. If <code>PartialEq</code> is not implemented for that inner type, error</p>",
        "id": 239274034,
        "sender_full_name": "lcnr",
        "timestamp": 1621351885
    },
    {
        "content": "<p>This still works with valtree. We create patterns up to the broken thing and then use a mir constant instead of a valtree. All mir constants are compared with partialeq</p>",
        "id": 239274043,
        "sender_full_name": "oli",
        "timestamp": 1621351890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239274023\">said</a>:</p>\n<blockquote>\n<p>I'm afraid I am out of my depths here, I carefully avoided the pattern matching code in most of what I do^^</p>\n</blockquote>\n<p>to some extent, this feels like a \"design choice\" under your proposal, right?</p>",
        "id": 239274108,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351920
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239274034\">said</a>:</p>\n<blockquote>\n<p>so for pattern, we could say: while the current type is <code>structural_eq</code>, unroll to a pattern (i.e. with exhaustiveness checking) and once we encounter one type which is not structural eq we stop and use <code>PartialEq</code>. If <code>PartialEq</code> is not implemented, error</p>\n</blockquote>\n<p>the thing is, StructuralEq should be a structural property, i.e. it a type is StructuralEq then so are all its constituent types. so having a partial unroll and then transitioning to a blob, IMO should never happen.</p>",
        "id": 239274168,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351932
    },
    {
        "content": "<p>i.e., it's kind of a language design question of what is ergonomic and how confusing it is</p>",
        "id": 239274171,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621351933
    },
    {
        "content": "<blockquote>\n<p>i.e. it a type is StructuralEq then so are all its constituent types.</p>\n</blockquote>\n<p>yeah, but that's a property which could imo not be worth it?</p>",
        "id": 239274256,
        "sender_full_name": "lcnr",
        "timestamp": 1621351971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239274043\">said</a>:</p>\n<blockquote>\n<p>This still works with valtree. We create patterns up to the broken thing and then use a mir constant instead of a valtree. All mir constants are compared with partialeq</p>\n</blockquote>\n<p>I thought the plan was to go constant -&gt; valtree -&gt; pattern? valtrees cannot represent \"partially StructuralEq\" data so we cant convert it to patterns either</p>",
        "id": 239274266,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239274256\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>i.e. it a type is StructuralEq then so are all its constituent types.</p>\n</blockquote>\n<p>yeah, but that's a property which could imo not be worth it?</p>\n</blockquote>\n<p>I think its a fundamental property we need to make any sense of this entire thing^^</p>",
        "id": 239274304,
        "sender_full_name": "RalfJ",
        "timestamp": 1621351987
    },
    {
        "content": "<p>maybe we can pivot briefly to review (for poor me) what ralf's properties of structural equality are?</p>",
        "id": 239274387,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352007
    },
    {
        "content": "<p>Structural equality is shallow right now</p>",
        "id": 239274398,
        "sender_full_name": "oli",
        "timestamp": 1621352014
    },
    {
        "content": "<p>I'd like to have the whole set in mind</p>",
        "id": 239274430,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352027
    },
    {
        "content": "<p>yeah and I think tahts bad</p>",
        "id": 239274437,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352031
    },
    {
        "content": "<p>the core of my proposal is</p>\n<blockquote>\n<p>STRUCT1: Given two values v1, v2 of type T: PartialEq, if both can be converted to a valtree then the valtrees are equal if and only if v1 == v2. Moreover, if v1 can be converted to a valtree and v2 cannot, then !(v1 == v2).</p>\n</blockquote>",
        "id": 239274444,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352035
    },
    {
        "content": "<p>(note that the def.n carefully says nothing about valtrees for non-PartialEq types -- so those would be \"vacuously structural_eq\" -- probably we just want to rule them out by fiat)</p>",
        "id": 239274654,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352112
    },
    {
        "content": "<p>and a valtree is a recursively defined aggregate with certain types at the leaves?</p>",
        "id": 239274749,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352147
    },
    {
        "content": "<p>\"certain types\" = integer, basically</p>",
        "id": 239274776,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352158
    },
    {
        "content": "<p>but we could imagine adding others</p>",
        "id": 239274798,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352164
    },
    {
        "content": "<blockquote>\n<p>So e.g. 2 would be a valtree with just a single node carrying a 2; (2, 2) would be a valtree where the root points to two leaf nodes that carry a 2. &amp;2 would be a valtree where the root points to a leaf node that carries a 2. (2,) would be the same valtree as &2; that's okay -- valtrees are meant to capture everything about a value that matters at a high level; comparing valtrees of different types is not very meaningful.</p>\n</blockquote>",
        "id": 239274847,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352175
    },
    {
        "content": "<blockquote>\n<p>valtrees can represent \"partially StructuralEq\" data so we cant convert it to patterns either</p>\n</blockquote>\n<p>I thought the point of valtrees would be that they were entirely <code>StructuralEq</code>, so their values can be encoded for mangling, etc.?</p>",
        "id": 239274916,
        "sender_full_name": "varkor",
        "timestamp": 1621352202
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239274916\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>valtrees can represent \"partially StructuralEq\" data so we cant convert it to patterns either</p>\n</blockquote>\n<p>I thought the point of valtrees would be that they were entirely <code>StructuralEq</code>, so their values can be encoded for mangling, etc.?</p>\n</blockquote>\n<p>sorry I meant can <em>not</em> represent such data</p>",
        "id": 239274950,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352220
    },
    {
        "content": "<p>so Ralf why do you think it's so important that structural equality is deep, not shallow?</p>",
        "id": 239275043,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352259
    },
    {
        "content": "<blockquote>\n<p>I think its a fundamental property we need to make any sense of this entire thing^^</p>\n</blockquote>\n<p>I think I can make sense of  \"For a type to be <code>StructuralEq</code> its <code>partial_eq</code> impl must call <code>partial_eq</code> for all its fields in order\"</p>",
        "id": 239275060,
        "sender_full_name": "lcnr",
        "timestamp": 1621352265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239275043\">said</a>:</p>\n<blockquote>\n<p>so Ralf why do you think it's so important that structural equality is deep, not shallow?</p>\n</blockquote>\n<p>it follows from my def.n</p>",
        "id": 239275082,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352271
    },
    {
        "content": "<p>valtree construction and comparison is deep</p>",
        "id": 239275101,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352280
    },
    {
        "content": "<p>it definitely follows from your definition :) I'm just trying to understand why you structued the def'n that way</p>",
        "id": 239275225,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352317
    },
    {
        "content": "<p>so if we accept by def.n then I can prove that structural equality is deep, not shallow.^^ and I dont know a useful def.n that would be shallow.</p>",
        "id": 239275229,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239275225\">said</a>:</p>\n<blockquote>\n<p>it definitely follows from your definition :) I'm just trying to understand why you structued the def'n that way</p>\n</blockquote>\n<p>fair. one big moivation is the \"continuum\" I keep mentioning.</p>",
        "id": 239275308,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352352
    },
    {
        "content": "<p>the definition is exactly what we need to ensure that compiling patterns either way (when both ways are possible) yields the same behavior.</p>",
        "id": 239275362,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352377
    },
    {
        "content": "<blockquote>\n<p>For a type to be StructuralEq its partial_eq impl must call partial_eq for all its fields in order</p>\n</blockquote>\n<p>I have to admit I really like that def. And I don't see how the continuum is not guaranteed here <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 239275407,
        "sender_full_name": "lcnr",
        "timestamp": 1621352398
    },
    {
        "content": "<p><a href=\"https://hackmd.io/Qvrj_eOFTkCHZrhJ7f1ItA#Patterns\">https://hackmd.io/Qvrj_eOFTkCHZrhJ7f1ItA#Patterns</a> explains this in a bit more detail</p>",
        "id": 239275468,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352410
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239275060\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think its a fundamental property we need to make any sense of this entire thing^^</p>\n</blockquote>\n<p>I think I can make sense of  \"For a type to be <code>StructuralEq</code> its <code>partial_eq</code> impl must call <code>partial_eq</code> for all its fields in order\"</p>\n</blockquote>\n<p>Are you permitting <code>partial_eq</code> to have a custom impl here?</p>",
        "id": 239275518,
        "sender_full_name": "varkor",
        "timestamp": 1621352432
    },
    {
        "content": "<p>the inner ones yeah</p>",
        "id": 239275546,
        "sender_full_name": "lcnr",
        "timestamp": 1621352440
    },
    {
        "content": "<p>I'm trying to remember if I've seen this hackmd :)</p>",
        "id": 239275568,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352450
    },
    {
        "content": "<p>if so, I've not really read it!</p>",
        "id": 239275580,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352454
    },
    {
        "content": "<p>/me reads</p>",
        "id": 239275588,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239275546\">said</a>:</p>\n<blockquote>\n<p>the inner ones yeah</p>\n</blockquote>\n<p>But then you lose transitivity, reflexivity, etc., which I feel are important for structural equality.</p>",
        "id": 239275625,
        "sender_full_name": "varkor",
        "timestamp": 1621352467
    },
    {
        "content": "<p>so for const generics we require all constituent types to also be <code>StructuralEq</code></p>",
        "id": 239275640,
        "sender_full_name": "lcnr",
        "timestamp": 1621352470
    },
    {
        "content": "<p>Ralf's definition is the one that makes most sense to me right now.</p>",
        "id": 239275666,
        "sender_full_name": "varkor",
        "timestamp": 1621352481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239275407\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>For a type to be StructuralEq its partial_eq impl must call partial_eq for all its fields in order</p>\n</blockquote>\n<p>I have to admit I really like that def. And I don't see how the continuum is not guaranteed here <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>if those fields have ill-behaved partial_eq impls you still have all the same problems</p>",
        "id": 239275715,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352504
    },
    {
        "content": "<p>basically <em>every</em> <code>derive(PartialEq)</code> newtype of any existing type would be structural eq under this def.n, so I cant see how this def.n guarantees anything useful</p>",
        "id": 239275788,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352529
    },
    {
        "content": "<p>it defines a back compat pattern behavior that seems fairly easy to understand imo</p>",
        "id": 239275928,
        "sender_full_name": "lcnr",
        "timestamp": 1621352584
    },
    {
        "content": "<p>well I certainly dont understand it then^^</p>",
        "id": 239275992,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239275640\">said</a>:</p>\n<blockquote>\n<p>so for const generics we require all constituent types to also be <code>StructuralEq</code></p>\n</blockquote>\n<p>I think it makes sense for <code>StructuralEq</code> to be a const-generics specific trait, and handle pattern matching separately. We want to be more liberal in what's accepted in pattern matching.</p>",
        "id": 239276040,
        "sender_full_name": "varkor",
        "timestamp": 1621352633
    },
    {
        "content": "<blockquote>\n<p>basically <em>every</em> <code>derive(PartialEq)</code> newtype of any existing type would be structural eq under this def.n, so I cant see how this def.n guarantees anything useful</p>\n</blockquote>\n<p>Which would leave it to status quo, would it not?</p>",
        "id": 239276127,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621352656
    },
    {
        "content": "<p>Otherwise we're special-casing const-generic <code>StructuralEq</code> anyway.</p>",
        "id": 239276136,
        "sender_full_name": "varkor",
        "timestamp": 1621352659
    },
    {
        "content": "<p>also <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>  how do you define \"constituent types\"? what if I write type-erased code like <code>struct I32Ptr(*const ()); // invariant: is a ptr to i32</code>?</p>",
        "id": 239276201,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352692
    },
    {
        "content": "<p>Should raw pointers be compared bytewise, if considered for structuraleq?</p>",
        "id": 239276270,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621352723
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276127\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>basically <em>every</em> <code>derive(PartialEq)</code> newtype of any existing type would be structural eq under this def.n, so I cant see how this def.n guarantees anything useful</p>\n</blockquote>\n<p>Which would leave it to status quo, would it not?</p>\n</blockquote>\n<p>yeah and the status quo is \"it's a mess and we dont have a clear idea for what the guarantees are\", isnt it?</p>",
        "id": 239276280,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121053\">varkor</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276040\">said</a>:</p>\n<blockquote>\n<p>I think it makes sense for <code>StructuralEq</code> to be a const-generics specific trait, and handle pattern matching separately. We want to be more liberal in what's accepted in pattern matching.</p>\n</blockquote>\n<p>hm, I'm afraid of a proliferation of mechanisms here. yes the two require slightly different things in the details, but in broad scopes they are very similar.</p>",
        "id": 239276413,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352772
    },
    {
        "content": "<p>Indeed, and it's comes with a ton of extra promises that people may not realise that they have to keep, or worse, not know whether or not they have to keep them, which is the basis for my issue, <a href=\"https://github.com/rust-lang/rust/issues/84391\">#84391</a>.</p>",
        "id": 239276484,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621352803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276270\">said</a>:</p>\n<blockquote>\n<p>Should raw pointers be compared bytewise, if considered for structuraleq?</p>\n</blockquote>\n<p>they are not considered for SturcutralEq, at least by me -- they dont have a reasonable notion of equality at compile time</p>",
        "id": 239276491,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276201\">said</a>:</p>\n<blockquote>\n<p>also <span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span>  how do you define \"constituent types\"? what if I write type-erased code like <code>struct I32Ptr(*const ()); // invariant: is a ptr to i32</code>?</p>\n</blockquote>\n<p>we use partial eq of <code>*const ()</code></p>",
        "id": 239276492,
        "sender_full_name": "lcnr",
        "timestamp": 1621352808
    },
    {
        "content": "<p>I don't understand yet the envsioned interaction of structural eq and const generics</p>",
        "id": 239276512,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352815
    },
    {
        "content": "<p>but</p>",
        "id": 239276516,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352817
    },
    {
        "content": "<p>I have to go :) I think I get ralf's proposal, I want to podner it a bit, I'll try to catch up on the thread in any case</p>",
        "id": 239276559,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352834
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276512\">said</a>:</p>\n<blockquote>\n<p>I don't understand yet the envsioned interaction of structural eq and const generics</p>\n</blockquote>\n<p>well basically what I imagined was: <code>&lt;const x: T&gt;</code> is only allowed when <code>T: StructuralEq</code></p>",
        "id": 239276606,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352842
    },
    {
        "content": "<p>I thnk <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> and key point is that you permit (a) matching on any constant and (b) anything with an ill-behaved <code>PartialEq</code> would not be able to (soundly) implement <code>StructuralEq</code>, and hence we would always be conservative about it in exhaustiveness checking</p>",
        "id": 239276692,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352881
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276270\">said</a>:</p>\n<blockquote>\n<p>Should raw pointers be compared bytewise, if considered for structuraleq?</p>\n</blockquote>\n<p>they are not considered for SturcutralEq, at least by me -- they dont have a reasonable notion of equality at compile time</p>\n</blockquote>\n<p>For something like const generics, you could use the definition C++ has for non-type template parameters, which constrains  the pointers to being either null pointers, or to objects that have linkage (So, pointers to statics)</p>",
        "id": 239276750,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621352889
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276606\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276512\">said</a>:<br>\nwell basically what I imagined was: <code>&lt;const x: T&gt;</code> is only allowed when <code>T: StructuralEq</code></p>\n</blockquote>\n<p>yes, I figured that was roughly it :)</p>",
        "id": 239276776,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276692\">said</a>:</p>\n<blockquote>\n<p>I thnk <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> and key point is that you permit (a) matching on any constant and (b) anything with an ill-behaved <code>PartialEq</code> would not be able to (soundly) implement <code>StructuralEq</code>, and hence we would always be conservative about it in exhaustiveness checking</p>\n</blockquote>\n<p>basically, yes. (we could still restrict which constants we permit matching on though, if we wanted. but it's not required for this scheme to work.)</p>",
        "id": 239276811,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352918
    },
    {
        "content": "<p>I see a lot of appeal to this scheme; I don't yet understand <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> why we would want the shallow def'n of structural equality</p>",
        "id": 239276877,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352952
    },
    {
        "content": "<p>maybe you can enumerate some examples it would permit that seem good?</p>",
        "id": 239276906,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276750\">said</a>:</p>\n<blockquote>\n<p>For something like const generics, you could use the definition C++ has for non-type template parameters, which constrains  the pointers to being either null pointers, or to objects that have linkage (So, pointers to statics)</p>\n</blockquote>\n<p>yes we could refine things like that. though if the statics have size 0, or if they are <code>extern</code>, they could still have the same address...</p>",
        "id": 239276911,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352967
    },
    {
        "content": "<blockquote>\n<p>how do you define \"constituent types\"</p>\n</blockquote>\n<p>wrongly <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> i would want to recursively check all \"contained\" types, where \"contained\" recursively looking into the types using <code>constituent_types_for_ty</code></p>",
        "id": 239276921,
        "sender_full_name": "lcnr",
        "timestamp": 1621352973
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> this also applies to <code>const X: T</code> in a trait, right?</p>",
        "id": 239276948,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621352979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239276948\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> this also applies to <code>const X: T</code> in a trait, right?</p>\n</blockquote>\n<p>why would it?</p>",
        "id": 239276975,
        "sender_full_name": "RalfJ",
        "timestamp": 1621352989
    },
    {
        "content": "<p>I'm debating :) perhaps it doesn't have to</p>",
        "id": 239277073,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621353020
    },
    {
        "content": "<p>I didnt think it would</p>",
        "id": 239277088,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353027
    },
    {
        "content": "<p>equality on const generics matters a lot in the compiler</p>",
        "id": 239277118,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353034
    },
    {
        "content": "<p>equality on values of associatd consts doesnt, I think?</p>",
        "id": 239277158,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353046
    },
    {
        "content": "<p>well, it depends</p>",
        "id": 239277202,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621353063
    },
    {
        "content": "<p>associated consts can be the value of a const generic so those are the same thing right?</p>",
        "id": 239277216,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1621353069
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239277118\">said</a>:</p>\n<blockquote>\n<p>equality on const generics matters a lot in the compiler</p>\n</blockquote>\n<p>to elaborate: it becomes part of \"equality on types\", and that matters</p>",
        "id": 239277235,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353079
    },
    {
        "content": "<p>I supose it would depend on if cg included bounding on traits with specific associated constant values?</p>",
        "id": 239277272,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> can auto traits have super traits? <code>auto trait DeepStructuralEq: StructuralEq {}</code></p>",
        "id": 239277278,
        "sender_full_name": "lcnr",
        "timestamp": 1621353092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239277216\">said</a>:</p>\n<blockquote>\n<p>associated consts can be the value of a const generic so those are the same thing right?</p>\n</blockquote>\n<p>if const generics are restricted to StructuralEq types then this is sufficient to cover that case, without also restricting types of associated consts</p>",
        "id": 239277336,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353115
    },
    {
        "content": "<p>Right, I'm thinking that every case where it would become impt to the equality of types implies that the associated constant is a (const) generic parameter of some type, so the restriction applies that way.</p>",
        "id": 239277342,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621353117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239277278\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> can auto traits have super traits? <code>auto trait DeepStructuralEq: StructuralEq {}</code></p>\n</blockquote>\n<p>no, not presently, because of reasons :)</p>",
        "id": 239277423,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621353133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239277278\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> can auto traits have super traits? <code>auto trait DeepStructuralEq: StructuralEq {}</code></p>\n</blockquote>\n<p>IIRC, that either is constrained to other auto traits, or has some <em>flaws</em> because rustc.</p>",
        "id": 239277480,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353151
    },
    {
        "content": "<p>implied bounds + coinductive matching is a recipe for unsoundness</p>",
        "id": 239277489,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621353155
    },
    {
        "content": "<p>It could possibly work with <code>unsafe auto trait DeepStructuralEq{}</code> and <code>impl&lt;T: !StructuralEq&gt; !DeepStructuralEq for T{}</code> with negative trait bounds that don't require an explicit <code>impl !StructuralEq for T{}</code></p>",
        "id": 239277778,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353253
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> so what you call \"deep structural eq\" -- your def.n of structural-eq applied to all constituent types -- is that (supposed to) be equivalent to my definition? it's not obvious to me if they are, could be an interesting thing to figure out.</p>",
        "id": 239277846,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353285
    },
    {
        "content": "<p>certainly you have to be a bit careful here because you need to say <em>something</em> about primitive types being structural eq -- like, <code>i32</code> would be vacuously structural-eq according to your def.n <em>even if</em> we made its PartialEq impl something ridicolous</p>",
        "id": 239278077,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353369
    },
    {
        "content": "<p>Wouldn't scalar types by-definition be structural-eq?</p>",
        "id": 239278207,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353400
    },
    {
        "content": "<p>let me write my idea down</p>",
        "id": 239278230,
        "sender_full_name": "lcnr",
        "timestamp": 1621353405
    },
    {
        "content": "<p>well in my def.n they are structural-eq because they satisfy the property</p>",
        "id": 239278303,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353419
    },
    {
        "content": "<p>no need to make them structural-eq by fiat</p>",
        "id": 239278327,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239277846\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> so what you call \"deep structural eq\" -- your def.n of structural-eq applied to all constituent types -- is that (supposed to) be equivalent to my definition? it's not obvious to me if they are, could be an interesting thing to figure out.</p>\n</blockquote>\n<p>it's similar, I am reasoning about types, so all values of your type would have to be able to be constructed as val trees, but my definition isn't completely right</p>",
        "id": 239278474,
        "sender_full_name": "lcnr",
        "timestamp": 1621353456
    },
    {
        "content": "<p>Yeah, and they do so by definition though.<br>\nThe valtree of a value of a scalar type <code>x</code> is simply <code>x</code>, is it not?</p>",
        "id": 239278508,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353462
    },
    {
        "content": "<p>writing it in a hackmd rn</p>",
        "id": 239278510,
        "sender_full_name": "lcnr",
        "timestamp": 1621353463
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> 's def.n requires talking about them explicitly (and I consider that a weakness -- feels to me like this is a very <em>syntactic</em> definition, whereas what I am looking for is something <em>semantic</em>)</p>",
        "id": 239278607,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239278508\">said</a>:</p>\n<blockquote>\n<p>Yeah, and they do so by definition though.<br>\nThe valtree of a value of a scalar type <code>x</code> is simply <code>x</code>, is it not?</p>\n</blockquote>\n<p>well everything that satisifies the poperty satisfies it by def.n (as in, because STRUCT1 has been defined like that), I dont get that distinction^^</p>",
        "id": 239278762,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353528
    },
    {
        "content": "<p>also \"scalar type\" makes me uneasy, raw ptrs and references are \"scalar types\" under some def.ns of that term...</p>",
        "id": 239278882,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353578
    },
    {
        "content": "<p>It satisfies the property by definition though, because it's valtree is itself, thus the valtree is equal iff the value itself is equal by Sub=.</p>",
        "id": 239278899,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353587
    },
    {
        "content": "<p>True. I'd then constrain it to integral types.</p>",
        "id": 239279049,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239278899\">said</a>:</p>\n<blockquote>\n<p>It satisfies the property by definition though, because it's valtree is itself, thus the valtree is equal iff the value itself is equal by Sub=.</p>\n</blockquote>\n<p>I dont know what you mean by \"satisifies the property by definition\". after you defined a property that is literally the only way it can ever be satisfied, no? so that just doesnt seem like a meaningful statement to me, is what I say.</p>",
        "id": 239279079,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353636
    },
    {
        "content": "<p>we could show a theorem like</p>\n<div class=\"codehilite\"><pre><span></span><code>Lemma scalar_structural: forall (T: scalar_integer_type), is_structural_eq T\n</code></pre></div>",
        "id": 239279166,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353660
    },
    {
        "content": "<p>that theorems requires a bit of reasning, but nothing too complicated</p>",
        "id": 239279212,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353675
    },
    {
        "content": "<p>What I'm saying is that the property that <code>(x==y)&lt;=&gt;(valtree(x)==valtree(y))</code> is trivially true, because valtree(x)=x for integer types. Is that not a correct statement?</p>",
        "id": 239279328,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621353721
    },
    {
        "content": "<p>I guess thats corretc if you squint your eyes enough^^</p>",
        "id": 239279415,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353743
    },
    {
        "content": "<p><code>valtree(x)</code> has type \"valtree\" so comparing that with <code>x</code> is an ill-typed statement in my view...</p>",
        "id": 239279457,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353760
    },
    {
        "content": "<p>but I think I get what you mean</p>",
        "id": 239279510,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353779
    },
    {
        "content": "<p>and I agree with that</p>",
        "id": 239279523,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353782
    },
    {
        "content": "<p>I deliberately did not use <code>==</code> on valtrees in my def.n since this is \"meta-level equality\", whereas the <code>==</code> I am talking about is \"Rust-level equality\"</p>",
        "id": 239279659,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353833
    },
    {
        "content": "<p>so your <code>x==y</code> is really <code>rust_code_evaluates_to(quote!{$x == $y}, quote!{true})</code> or so -- there's a lot going on there that's not going on on the valtree side. maybe that's my PL researcher showing through but I think it is important to keep the meta level and the object level clearly separate. ;)</p>",
        "id": 239279777,
        "sender_full_name": "RalfJ",
        "timestamp": 1621353865
    },
    {
        "content": "<p>but if we agree on these statements all being a bit fuzzy, then I think we agree :)</p>",
        "id": 239280186,
        "sender_full_name": "RalfJ",
        "timestamp": 1621354010
    },
    {
        "content": "<p>Yeah I guess they are.</p>",
        "id": 239280745,
        "sender_full_name": "Connor Horman",
        "timestamp": 1621354133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239278474\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239277846\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> so what you call \"deep structural eq\" -- your def.n of structural-eq applied to all constituent types -- is that (supposed to) be equivalent to my definition? it's not obvious to me if they are, could be an interesting thing to figure out.</p>\n</blockquote>\n<p>it's similar, I am reasoning about types, so all values of your type would have to be able to be constructed as val trees, but my definition isn't completely right</p>\n</blockquote>\n<p>ah, but then how's that related to the shallow definition? I thought one would be defined in terms of the other (that could help me understand the shallow definition better). I'll wait for your writeup. :)</p>",
        "id": 239280858,
        "sender_full_name": "RalfJ",
        "timestamp": 1621354179
    },
    {
        "content": "<p>I am also interested in why you think it's worth relaxing the pattern match requirement to something more shallow. you mentioned backcompat I think, but it is really hard to even come up with an example that would be broken by my proposal -- so (unless crater disagrees) I think this is okay breakage. I think a pattern like <code>(0, _blob)</code> is equivalent to <code>_blob</code> in terms of exhaustiveness checking, so weakening from the former to the latter won't break any code... at least I was unable to come up with a counterexample for this.</p>",
        "id": 239281707,
        "sender_full_name": "RalfJ",
        "timestamp": 1621354495
    },
    {
        "content": "<p>that's my idea: <a href=\"https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA\">https://hackmd.io/-IB2BH1hSWWMQVSfbvVViA</a></p>",
        "id": 239290387,
        "sender_full_name": "lcnr",
        "timestamp": 1621357834
    },
    {
        "content": "<p>this does allow a few things to compile which weren't previously possible</p>",
        "id": 239290778,
        "sender_full_name": "lcnr",
        "timestamp": 1621357979
    },
    {
        "content": "<p>soooo <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span> i think i messed up something here, because I am somehow missing why \"just using\" partial eq is bad <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span></p>",
        "id": 239291135,
        "sender_full_name": "lcnr",
        "timestamp": 1621358092
    },
    {
        "content": "<p>let me reread some of the existing threads <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 239291253,
        "sender_full_name": "lcnr",
        "timestamp": 1621358133
    },
    {
        "content": "<p>i guess it might be interesting to try and force patterns to have that recursive check but always require <code>StructuralMatch</code> instead of just <code>PartialEq</code>. But I do fear that it will break too much code</p>",
        "id": 239298921,
        "sender_full_name": "lcnr",
        "timestamp": 1621361114
    },
    {
        "content": "<p>but i also have to say that i quite like my approach.</p>",
        "id": 239299072,
        "sender_full_name": "lcnr",
        "timestamp": 1621361169
    },
    {
        "content": "<p>which pretty much boils down to: use semantic equality but do check for exhaustiveness if <code>StructuralMatch</code> is implemented</p>",
        "id": 239299147,
        "sender_full_name": "lcnr",
        "timestamp": 1621361207
    },
    {
        "content": "<p>For any desire to handle float values as part of structural equality here, I believe that NaN is comparatively non-problematic compared to a float with <code>0.0</code> or <code>-0.0</code> as its value, because:</p>\n<ul>\n<li><code>0.0</code> and <code>-0.0</code> are both well-defined values for floats, in all senses you might care about</li>\n<li>They are not bit-equal</li>\n<li>They are <code>partial_cmp</code> equal</li>\n</ul>\n<p>They violate float total ordering all on their own, unless you use the <code>total_cmp</code> rules<br>\nIt's easy to just say \"who cares?\" about NaN and hack it out of the picture, by comparison, so I don't think fretting over NaN is essential.</p>",
        "id": 239470798,
        "sender_full_name": "Jubilee",
        "timestamp": 1621447688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239299147\">said</a>:</p>\n<blockquote>\n<p>which pretty much boils down to: use semantic equality but do check for exhaustiveness if <code>StructuralMatch</code> is implemented</p>\n</blockquote>\n<p>this is equivalent with (one variant of) my proposal, for my definition of when it is okay to implement <code>StructuralMatch</code>/<code>StrucutralEq</code> for a type. Now I'll read yours to figure out where the difference is. ;)</p>",
        "id": 239862411,
        "sender_full_name": "RalfJ",
        "timestamp": 1621678774
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I dont think \"partial_cmp-equal but not bit equal\" is a problem. we just have to ensure that their valtrees are equal and they name-mangle to the same thing. which we could achieve by having <code>Float</code> (as in, softfloat) valtree leaves and using an appropriate notion of equality on those.</p>",
        "id": 239862492,
        "sender_full_name": "RalfJ",
        "timestamp": 1621678831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> </p>\n<div class=\"codehilite\"><pre><span></span><code>/// If wrongly implemented patterns might disagree with\n/// `PartialEq`, but that&#39;s not unsound.\n</code></pre></div>\n<p>if <code>StructuralMatch</code> enables exhaustiveness checking, then wrong impls <em>would</em> be unsound. so I think something is wrong here in your proposal.</p>",
        "id": 239863678,
        "sender_full_name": "RalfJ",
        "timestamp": 1621680029
    },
    {
        "content": "<blockquote>\n<p>If T: StructuralEq, it is guaranteed that all values of type T can be converted to a val-tree due to the lang item status of StructuralMatch.</p>\n</blockquote>\n<p>what does the lang item status have to do with this? users are free to implement StructuralMatch, aren't they?</p>",
        "id": 239863725,
        "sender_full_name": "RalfJ",
        "timestamp": 1621680120
    },
    {
        "content": "<p>I think other than that this proposal it pretty similar to mine, but it requires 2 notions (StructuralMatch, StructuralEq) where I need only one. the benefit you have from this is exhaustiveness checking for \"partially structural\" constant -- and I dont think this is actually ever useful: if a constant like <code>(0, foo)</code> can be exhaustiveness-checked only on the first component, that is equivalent to not exhaustiveness-checking it at all.</p>",
        "id": 239863807,
        "sender_full_name": "RalfJ",
        "timestamp": 1621680208
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239863678\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> </p>\n<div class=\"codehilite\"><pre><span></span><code>/// If wrongly implemented patterns might disagree with\n/// `PartialEq`, but that&#39;s not unsound.\n</code></pre></div>\n<p>if <code>StructuralMatch</code> enables exhaustiveness checking, then wrong impls <em>would</em> be unsound. so I think something is wrong here in your proposal.</p>\n</blockquote>\n<p><code>StructuralMatch</code> enables exhaustiveness checking by looking at the val tree, not by using partialeq. <code>PartialEq</code> gets completely ignored for exhaustiveness</p>",
        "id": 239871731,
        "sender_full_name": "lcnr",
        "timestamp": 1621688775
    },
    {
        "content": "<blockquote>\n<p>users are free to implement StructuralMatch, aren't they?</p>\n</blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// Not implementable for types which can't be shallowly converted</span>\n<span class=\"sd\">/// back into patterns. So we forbid impls for extern types, float</span>\n<span class=\"sd\">/// and pointers.</span>\n</code></pre></div>\n<p>(this is the responsibility of the compiler, so users are <strong>not</strong> free to implement <code>StructuralMatch</code> for all types</p>",
        "id": 239871762,
        "sender_full_name": "lcnr",
        "timestamp": 1621688828
    },
    {
        "content": "<blockquote>\n<p>the benefit you have from this is exhaustiveness checking for \"partially structural\" constant </p>\n</blockquote>\n<p>and better perf. Afaik we want <code>match</code> to use patterns as much as possible as it is <em>faster</em></p>",
        "id": 239871871,
        "sender_full_name": "lcnr",
        "timestamp": 1621688922
    },
    {
        "content": "<blockquote>\n<p>StructuralMatch enables exhaustiveness checking by looking at the val tree, not by using partialeq. PartialEq gets completely ignored for exhaustiveness</p>\n</blockquote>\n<p>if <code>PartialEq</code> is still used to actually do the check at runtime (\"use semantic equality\" is what you said), that'd still be unsound</p>",
        "id": 239873286,
        "sender_full_name": "RalfJ",
        "timestamp": 1621690486
    },
    {
        "content": "<blockquote>\n<p>so users are not free to implement StructuralMatch for all types</p>\n</blockquote>\n<p>oh. then how do you intent to let users (unsafely) assert to the compiler that their type is sufficiently well-behaved that it can be used in patterns / const generics? I think that's an important feature (and it also ensures that we cannot weasle out of the respinsibility of saying, precisely, what that trait actually guarantees)</p>",
        "id": 239873321,
        "sender_full_name": "RalfJ",
        "timestamp": 1621690527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239871871\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>the benefit you have from this is exhaustiveness checking for \"partially structural\" constant </p>\n</blockquote>\n<p>and better perf. Afaik we want <code>match</code> to use patterns as much as possible as it is <em>faster</em></p>\n</blockquote>\n<p>I'd expect marginal benefits at best</p>",
        "id": 239873336,
        "sender_full_name": "RalfJ",
        "timestamp": 1621690551
    },
    {
        "content": "<p>it is only used for types not using <code>StructuralMatch</code>(or types inside of other types not implementing <code>StructuralMatch</code>) for these types we use structural equality. The idea is to use structural equality as much as possible for types implementing <code>StructuralMatch</code> which is checked for exhaustiveness while using <code>PartialEq</code> as a fallback without checking for exhaustiveness</p>",
        "id": 239890904,
        "sender_full_name": "lcnr",
        "timestamp": 1621707936
    },
    {
        "content": "<blockquote>\n<p>(unsafely) assert to the compiler that their type is sufficiently well-behaved</p>\n</blockquote>\n<p>Extern types, floats and pointers never have well-behaved structural equality, do they?</p>",
        "id": 239890966,
        "sender_full_name": "lcnr",
        "timestamp": 1621707986
    },
    {
        "content": "<blockquote>\n<p>it is only used for types not using StructuralMatch(or types inside of other types not implementing StructuralMatch) for these types we use structural equality.</p>\n</blockquote>\n<p>so you mean, for these types we convert to a pattern and ignore <code>PartialEq</code>?<br>\n(\"it\" is an unclear reference in your message, and I don't know what it means to \"use structural equality\".)</p>",
        "id": 239937701,
        "sender_full_name": "RalfJ",
        "timestamp": 1621762028
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/260443-project-const-generics/topic/structural.20equality/near/239890966\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>(unsafely) assert to the compiler that their type is sufficiently well-behaved</p>\n</blockquote>\n<p>Extern types, floats and pointers never have well-behaved structural equality, do they?</p>\n</blockquote>\n<p>so what? that's not what I was talking about. I am talking about people that have types without any such thing, but implement their own <code>PartialEq</code> for one reason or another.</p>",
        "id": 239937723,
        "sender_full_name": "RalfJ",
        "timestamp": 1621762069
    },
    {
        "content": "<p>Was there a structural equality meeting planned for today (<a href=\"https://github.com/rust-lang/lang-team/issues/94\">https://github.com/rust-lang/lang-team/issues/94</a>)?</p>",
        "id": 247470919,
        "sender_full_name": "varkor",
        "timestamp": 1627484517
    },
    {
        "content": "<p>Oh, I see it's happening in <a href=\"#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting\">https://rust-lang.zulipchat.com/#narrow/stream/213817-t-lang/topic/structural.20equality.20meeting</a>.</p>",
        "id": 247471545,
        "sender_full_name": "varkor",
        "timestamp": 1627484783
    },
    {
        "content": "<p>there was but we canceled it :)</p>",
        "id": 247491957,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1627494264
    }
]