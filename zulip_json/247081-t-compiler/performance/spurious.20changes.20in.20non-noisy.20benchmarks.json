[
    {
        "content": "<p>I've been seeing several cases of spurious perf changes in non-noisy benchmarks. <a href=\"https://github.com/rust-lang/rust/pull/90757\">Here's</a> a good example. The final change is just removing two docs in librustdoc but the perf results show fairly significance changes in three test cases (not even with the \"doc\" profile). This is definitely concerning, and ideally, we wouldn't see this ever.</p>",
        "id": 261521095,
        "sender_full_name": "rylev",
        "timestamp": 1636993398
    },
    {
        "content": "<p>Yeah, it happened again on <a href=\"https://github.com/rust-lang/rust/pull/90684#issuecomment-968619765\">https://github.com/rust-lang/rust/pull/90684#issuecomment-968619765</a></p>",
        "id": 261521573,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636993568
    },
    {
        "content": "<p>Maybe you just need to change \"non-noisy\" to exclude those benchmarks?</p>",
        "id": 261521627,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636993597
    },
    {
        "content": "<p>Since the distinction seems kind of artificial in the first place; the way you determined non noisy was by finding exactly these sorts of spurious changes</p>",
        "id": 261521675,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636993624
    },
    {
        "content": "<p>I have the suspicion that PGO increases noise due to spooky-at-a-distance inlining changes.</p>",
        "id": 261521696,
        "sender_full_name": "The 8472",
        "timestamp": 1636993635
    },
    {
        "content": "<p>html5ever-check got a lot noisier recently:</p>\n<p><a href=\"/user_uploads/4715/hTZL1Y7CQ_mUK5npfLLhfS7I/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/hTZL1Y7CQ_mUK5npfLLhfS7I/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/hTZL1Y7CQ_mUK5npfLLhfS7I/image.png\"></a></div>",
        "id": 261521699,
        "sender_full_name": "simulacrum",
        "timestamp": 1636993636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> but there are <em>no</em> changes at all to the compiler in either of those PRs</p>",
        "id": 261521772,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636993675
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/90596\">https://github.com/rust-lang/rust/pull/90596</a> seems plausibly suspicious here</p>",
        "id": 261521777,
        "sender_full_name": "simulacrum",
        "timestamp": 1636993678
    },
    {
        "content": "<p>So I would be shocked if this is \"small changes are being amplified\"</p>",
        "id": 261521839,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636993694
    },
    {
        "content": "<p>since the paths we're hashing comparing for things will often contain remapped debuginfo, which contains commit hashes</p>",
        "id": 261521870,
        "sender_full_name": "simulacrum",
        "timestamp": 1636993709
    },
    {
        "content": "<p>so we'll have \"random noise\" from how many leading bytes happen to match commit/commit, for example</p>",
        "id": 261521922,
        "sender_full_name": "simulacrum",
        "timestamp": 1636993733
    },
    {
        "content": "<p>maybe not actually what's happening here, but it's not impossible</p>",
        "id": 261521946,
        "sender_full_name": "simulacrum",
        "timestamp": 1636993741
    },
    {
        "content": "<p>you mean the comparison, not the hashing? because hashing always examines the full length of the path.</p>",
        "id": 261522056,
        "sender_full_name": "The 8472",
        "timestamp": 1636993791
    },
    {
        "content": "<p>Have we checked whether the same sort of noise happens if you measure the same commit twice?</p>",
        "id": 261522079,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636993801
    },
    {
        "content": "<p>oh, sure</p>",
        "id": 261522124,
        "sender_full_name": "simulacrum",
        "timestamp": 1636993804
    },
    {
        "content": "<p>but then after hashing there should be few comparisons so variable-length comparisons shouldn't matter...</p>",
        "id": 261522136,
        "sender_full_name": "The 8472",
        "timestamp": 1636993807
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/spurious.20changes.20in.20non-noisy.20benchmarks/near/261521675\">said</a>:</p>\n<blockquote>\n<p>Since the distinction seems kind of artificial in the first place; the way you determined non noisy was by finding exactly these sorts of spurious changes</p>\n</blockquote>\n<p>This is no longer true. We have a statistical basis for what we define as noise. See the <a href=\"https://github.com/rust-lang/rustc-perf/blob/master/docs/glossary.md\">glossary</a>'s definition of noise.</p>",
        "id": 261522149,
        "sender_full_name": "rylev",
        "timestamp": 1636993814
    },
    {
        "content": "<p>what determines the <code>?</code> though?</p>",
        "id": 261522258,
        "sender_full_name": "The 8472",
        "timestamp": 1636993867
    },
    {
        "content": "<p>How large that statistical threshold is</p>",
        "id": 261522281,
        "sender_full_name": "simulacrum",
        "timestamp": 1636993882
    },
    {
        "content": "<p>We do arbitrarily pick the statistical threshold (at 0.2% I believe) but that's applied evenly to every <del>benchmark</del> test case</p>",
        "id": 261522505,
        "sender_full_name": "rylev",
        "timestamp": 1636993978
    },
    {
        "content": "<p>Going back to my theory, it's also worth noting we run benchmarks in randomly-named /tmp/.tmpxxxxx directories</p>",
        "id": 261524531,
        "sender_full_name": "simulacrum",
        "timestamp": 1636994864
    },
    {
        "content": "<p>so optimizations to the path comparison code can cause us to be more sensitive there.</p>",
        "id": 261524618,
        "sender_full_name": "simulacrum",
        "timestamp": 1636994884
    },
    {
        "content": "<p>hrrm, maybe. the one big regression in <a href=\"https://github.com/rust-lang/rust/issues/90596\">#90596</a> (which didn't show up in the initial perf run though...) is tuple-stress debug    incr-unchanged, which has most of its time increase in <code>incr_comp_query_cache_promotion</code>.<br>\n<a href=\"https://github.com/rust-lang/rust/issues/90684\">#90684</a>'s top regression spends a little more time in <code>incr_comp_persist_dep_graph</code></p>\n<p>Maybe path optimizations impacted about incremental comp persistence? I don't know how it would though.</p>",
        "id": 261525478,
        "sender_full_name": "The 8472",
        "timestamp": 1636995264
    },
    {
        "content": "<p>maybe if there's a subtle bug that sometimes causes hash misses... but then i'd expect other things to blow up too</p>",
        "id": 261526844,
        "sender_full_name": "The 8472",
        "timestamp": 1636995844
    },
    {
        "content": "<p>regression in tuple-stress seems genuine based on cachegrind results</p>",
        "id": 261526889,
        "sender_full_name": "simulacrum",
        "timestamp": 1636995866
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>200,187,078  ???:&lt;rustc_data_structures::sip128::SipHasher128&gt;::short_write_process_buffer::&lt;u64&gt;\n104,399,557  ???:&lt;rustc_span::caching_source_map_view::CachingSourceMapView&gt;::span_data_to_lines_and_cols\n</code></pre></div>",
        "id": 261526904,
        "sender_full_name": "simulacrum",
        "timestamp": 1636995876
    },
    {
        "content": "<p>(amongst other regressions in other functions, but less interesting)</p>",
        "id": 261526955,
        "sender_full_name": "simulacrum",
        "timestamp": 1636995903
    },
    {
        "content": "<p>well, actually, I expected some paths to be involved there but they're not at a first glance</p>",
        "id": 261527211,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996006
    },
    {
        "content": "<p>this all seems to be happening while stable-hashing spans for various other data structures (basic blocks, etc)</p>",
        "id": 261527552,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996135
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> so maybe we're seeing that at least in tuple-stress the paths are short enough(?) or something to cause a large overhead from name hashing?</p>",
        "id": 261527759,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996219
    },
    {
        "content": "<p>seems weird though.</p>",
        "id": 261527768,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996222
    },
    {
        "content": "<p>The hashing shouldn't do more work, certainly not process more bytes, microbenchmarks showed it doing less. Maybe inlining changed in a detrimental way?</p>",
        "id": 261527859,
        "sender_full_name": "The 8472",
        "timestamp": 1636996270
    },
    {
        "content": "<p>well, we pre-hash files and store a u128 hash for them and then truncate that to u64 which is fed into future hashes</p>",
        "id": 261527951,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996307
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/eab2d7519a3f1c11ddaff3d19f8b7727354c6362/compiler/rustc_span/src/lib.rs#L1330-L1331\">https://github.com/rust-lang/rust/blob/eab2d7519a3f1c11ddaff3d19f8b7727354c6362/compiler/rustc_span/src/lib.rs#L1330-L1331</a></p>",
        "id": 261527966,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996317
    },
    {
        "content": "<p>Or updates to hash state are somehow less efficient in some edge-cases that weren't covered by the benchmarks. But again, I don't see how. Before it was hashing slices which do a length + the bytes. Now it's just doing the bytes directly which should be strictly less work.</p>",
        "id": 261528025,
        "sender_full_name": "The 8472",
        "timestamp": 1636996327
    },
    {
        "content": "<p>I agree it seems hard to imagine this being bad in some way</p>",
        "id": 261528075,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996351
    },
    {
        "content": "<p>the regression in tuple-stress debug though has definitely persisted</p>",
        "id": 261528330,
        "sender_full_name": "simulacrum",
        "timestamp": 1636996462
    },
    {
        "content": "<p>If I interpret these <code>perf diff</code> results correctly it does mean some inlining changed, note the rows which have no corresponding baseline.</p>\n<div class=\"codehilite\"><pre><span></span><code># Event &#39;instructions:u&#39;\n#\n# Baseline  Delta Abs  Symbol                                                                                                                                                                                                                                                                                               &gt;\n# ........  .........  .....................................................................................................................................................................................................................................................................................................&gt;\n#\n     1.90%     +3.09%  [.] &lt;rustc_data_structures::sip128::SipHasher128&gt;::short_write_process_buffer::&lt;u64&gt;\n     1.28%     +2.25%  [.] &lt;rustc_span::caching_source_map_view::CachingSourceMapView&gt;::span_data_to_lines_and_cols\n    12.02%     -1.43%  [.] 0x0000000000005bf6\n               +1.24%  [.] &lt;rustc_index::vec::IndexVec&lt;rustc_middle::mir::BasicBlock, rustc_middle::mir::BasicBlockData&gt; as rustc_data_structures::stable_hasher::HashStable&lt;rustc_query_system::ich::hcx::StableHashingContext&gt;&gt;::hash_stable\n               +0.91%  [.] &lt;&amp;rustc_middle::ty::list::List&lt;rustc_middle::mir::ProjectionElem&lt;rustc_middle::mir::Local, &amp;rustc_middle::ty::TyS&gt;&gt; as rustc_data_structures::stable_hasher::HashStable&lt;rustc_query_system::ich::hcx::StableHashingContext&gt;&gt;::hash_stable\n               +0.83%  [.] &lt;&amp;rustc_middle::ty::consts::Const as rustc_data_structures::stable_hasher::HashStable&lt;rustc_query_system::ich::hcx::StableHashingContext&gt;&gt;::hash_stable\n     0.21%     +0.79%  [.] &lt;rustc_data_structures::sip128::SipHasher128&gt;::short_write_process_buffer::&lt;u32&gt;\n               +0.71%  [.] _RINvMs1_NtNtCskzSMKXuqLld_18rustc_query_system9dep_graph5graphINtB6_8DepGraphNtNtNtCscEF2Ad04ChB_12rustc_middle9dep_graph8dep_node7DepKindE23try_mark_previous_greenNtNtCsjzL1g3wEYIK_16rustc_query_impl8plumbing9QueryCtxtEB2G_.llvm.2919872465733405639\n</code></pre></div>",
        "id": 261531102,
        "sender_full_name": "The 8472",
        "timestamp": 1636997593
    },
    {
        "content": "<p>I can definitely believe it, but it's also the case that we see dramatically more instructions in total</p>",
        "id": 261532017,
        "sender_full_name": "simulacrum",
        "timestamp": 1636997913
    },
    {
        "content": "<p>Before the PR <code>path::Components::parse_next_component</code> is only called by <code>&lt;rustc_span::FileName as core::hash::Hash&gt;::hash::&lt;rustc_data_structures::stable_hasher::StableHasher&gt;</code> and that shows up as 0.0411% instructions:u (inclusive)</p>\n<p>After the PR <code>&lt;rustc_span::FileName as core::hash::Hash&gt;::hash::&lt;rustc_data_structures::stable_hasher::StableHasher&gt;</code> shows 0.0301%</p>\n<p>On the assumptions a) that there is no other data structure containing path that gets hashed - because I'd expect them to show up as caller of some std::path things, at least in the old profile - and b) the instructions spent on hashing don't get misattributed somewhere else, it then does look like path hashing itself did get faster and something else got affected.</p>\n<p>The strange thing is that it only affects tuple stress incr unchanged negatively. But many other incr unchanged benchmarks did get faster. <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span><br>\nWouldn't that mean it's data-dependent or some hashing only exercised by tuple-stress gets worse?</p>",
        "id": 261539747,
        "sender_full_name": "The 8472",
        "timestamp": 1637001191
    },
    {
        "content": "<p>Which spans we're hashing (and so, which files) is going to be benchmark dependent</p>",
        "id": 261540588,
        "sender_full_name": "simulacrum",
        "timestamp": 1637001611
    },
    {
        "content": "<p>ahhh... I found a big difference.</p>\n<p><code>rustc_query_system::query::plumbing::try_load_from_disk_and_cache_in_memory::&lt;rustc_query_impl::plumbing::QueryCtxt, rustc_span::def_id::DefId, &amp;rustc_middle::mir::Body&gt;</code> is dominated by <code>&lt;rustc_query_impl::on_disk_cache::OnDiskCache&gt;::try_load_query_result::&lt;&amp;rustc_middle::mir::Body&gt;</code> before the PR.</p>\n<p>After the PR its instructions are split between <code>&lt;rustc_query_impl::on_disk_cache::OnDiskCache&gt;::try_load_query_result::&lt;&amp;rustc_middle::mir::Body&gt;</code> and <code>rustc_query_system::query::plumbing::incremental_verify_ich::&lt;rustc_query_impl::plumbing::QueryCtxt, rustc_span::def_id::DefId, &amp;rustc_middle::mir::Body&gt;</code></p>\n<p>That's the new hash-based incremental verification, isn't it? That'd explain it.</p>",
        "id": 261541540,
        "sender_full_name": "The 8472",
        "timestamp": 1637002116
    },
    {
        "content": "<p>hm, yeah, though I wouldn't expect such a large delta...</p>",
        "id": 261542490,
        "sender_full_name": "simulacrum",
        "timestamp": 1637002597
    },
    {
        "content": "<p>unless my probabilistic thing is just wrong somehow (quite possible)</p>",
        "id": 261542573,
        "sender_full_name": "simulacrum",
        "timestamp": 1637002648
    },
    {
        "content": "<p>we shouldn't ~ever go from \"no hashing at all\" to \"lots of hashing\", or at least, it would be somewhat unexpected</p>",
        "id": 261542604,
        "sender_full_name": "simulacrum",
        "timestamp": 1637002666
    },
    {
        "content": "<p>it's incr-unchanged, so I assume it just happened to not hash before and now it does.</p>",
        "id": 261542610,
        "sender_full_name": "The 8472",
        "timestamp": 1637002669
    },
    {
        "content": "<p>yeah, I suppose it's possible. seems pretty surprising but not entirely impossible.</p>",
        "id": 261542701,
        "sender_full_name": "simulacrum",
        "timestamp": 1637002704
    },
    {
        "content": "<p>I mean it might just be hashing one item but it's significant enough because it doesn't have much else to do. Or because it's a stress test and it ends up being big.</p>",
        "id": 261542830,
        "sender_full_name": "The 8472",
        "timestamp": 1637002765
    },
    {
        "content": "<p>sure.</p>",
        "id": 261542842,
        "sender_full_name": "simulacrum",
        "timestamp": 1637002773
    }
]