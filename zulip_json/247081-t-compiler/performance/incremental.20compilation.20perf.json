[
    {
        "content": "<p>Inspired by a recent discussion on the future of incremental compilation, I got wondering if there are performance costs to the end user, having to maintain all the data related to incremental compilation, so I did this quick test, building rust-analyzer with 1.59.0 (which disables inc-comp by default):</p>\n<div class=\"codehilite\"><pre><span></span><code>❯ hyperfine --prepare &#39;cargo clean&#39; &#39;RUSTC_FORCE_INCREMENTAL=1 cargo build -j8&#39; &#39;cargo build -j8&#39;\nBenchmark #1: RUSTC_FORCE_INCREMENTAL=1 cargo build -j8\n  Time (mean ± σ):     334.217 s ± 16.605 s    [User: 235.449 s, System: 39.735 s]\n  Range (min … max):   315.745 s … 359.909 s    10 runs\n\nBenchmark #2: cargo build -j8\n  Time (mean ± σ):     238.375 s ± 32.004 s    [User: 207.741 s, System: 30.542 s]\n  Range (min … max):   215.619 s … 314.545 s    10 runs\n\nSummary\n  &#39;cargo build -j8&#39; ran\n    1.40 ± 0.20 times faster than &#39;RUSTC_FORCE_INCREMENTAL=1 cargo build -j8&#39;\n</code></pre></div>",
        "id": 273497393,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646058795
    },
    {
        "content": "<p>the data is a bit noisy, but I didn't expect to see this much of a slowdown</p>",
        "id": 273497492,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646058839
    },
    {
        "content": "<p>Odd, the difference isn't that big on perf.rlo. (full vs. incremental full). <a href=\"https://perf.rust-lang.org/dashboard.html\">https://perf.rust-lang.org/dashboard.html</a></p>",
        "id": 273497955,
        "sender_full_name": "The 8472",
        "timestamp": 1646059026
    },
    {
        "content": "<p>Maybe it also affects the scheduling of dependencies and perf only measures the main crate build?</p>",
        "id": 273498137,
        "sender_full_name": "The 8472",
        "timestamp": 1646059098
    },
    {
        "content": "<p>One likely difference is that I'm running on a machine with some very slow disks (network filesystem)</p>",
        "id": 273498150,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646059104
    },
    {
        "content": "<p>Ah</p>",
        "id": 273498220,
        "sender_full_name": "The 8472",
        "timestamp": 1646059133
    },
    {
        "content": "<p>NFS? Its close-to-open consistency is pretty bad for keeping things in the page cache as I understand it.</p>",
        "id": 273498473,
        "sender_full_name": "The 8472",
        "timestamp": 1646059223
    },
    {
        "content": "<p>to be more precise, the filesystem has pretty good performance for very large sequential writes, but really bad latency.  yeah, it's NFS</p>",
        "id": 273498565,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646059267
    },
    {
        "content": "<p>There doesn't seem to be much difference on an SSD</p>",
        "id": 273498617,
        "sender_full_name": "Laurențiu",
        "timestamp": 1646059287
    },
    {
        "content": "<p>If you have a strong reason to use NFS, maybe do a second mount with all the consistency stuff disabled for temp dirs and then symlink/bind-mount the build dir to that mount?</p>",
        "id": 273499334,
        "sender_full_name": "The 8472",
        "timestamp": 1646059577
    },
    {
        "content": "<p>The context for me is using rust at work.  We have a very big HPC cluster where I generally do coding work.  I have a small (30GB) shared NFS home directory, and a large (1TB) shared work directory (also NFS, but is high-latency).   rustup/cargo caches are too big to put in my home directory, so I put them in this 1TB work dir</p>",
        "id": 273499935,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646059847
    },
    {
        "content": "<p>(It's actually generally faster to install rust on a local disk whenever I log into an HPC node, instead of using a shared install, but this can be a bit tedious)</p>",
        "id": 273500587,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646060160
    },
    {
        "content": "<p>but all of this is making me wonder:  how carefully should we look at disk IO when doing perf measurements?</p>",
        "id": 273501280,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646060413
    },
    {
        "content": "<p>Rustc does close to random reads of the crate metadata AFAIK. I don't think it is possible to improve this much without giving up on lazy decoding (which should save a lot of time as often only a small part of the metadata is needed)</p>",
        "id": 273506919,
        "sender_full_name": "bjorn3",
        "timestamp": 1646062492
    },
    {
        "content": "<p>You can't even force dynamic linking I believe: <a href=\"https://github.com/rust-lang/rust/blob/55111d656f7ecd511ebfad09d3b4b41e44cbcc23/compiler/rustc_metadata/src/dependency_format.rs#L102-L103\">https://github.com/rust-lang/rust/blob/55111d656f7ecd511ebfad09d3b4b41e44cbcc23/compiler/rustc_metadata/src/dependency_format.rs#L102-L103</a></p>",
        "id": 273509204,
        "sender_full_name": "bjorn3",
        "timestamp": 1646063316
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>Benchmark 1: RUSTC_FORCE_INCREMENTAL=1 cargo build\n  Time (mean ± σ):     35.809 s ±  0.240 s    [User: 178.711 s, System: 18.748 s]\n  Range (min … max):   35.465 s … 36.134 s    10 runs\n\nBenchmark 2: cargo build\n  Time (mean ± σ):     28.656 s ±  0.198 s    [User: 160.300 s, System: 16.592 s]\n  Range (min … max):   28.277 s … 29.010 s    10 runs\n\nSummary\n  &#39;cargo build&#39; ran\n    1.25 ± 0.01 times faster than &#39;RUSTC_FORCE_INCREMENTAL=1 cargo build&#39;\n</code></pre></div>",
        "id": 273509206,
        "sender_full_name": "Laurențiu",
        "timestamp": 1646063317
    },
    {
        "content": "<p>I ran another test, on a personal machine.  still using NFS, but over a 10gbe link to SSDs (so probably the best case for NFS):</p>\n<div class=\"codehilite\"><pre><span></span><code>  &#39;cargo +stable build&#39; ran\n    1.27 ± 0.03 times faster than &#39;RUSTC_FORCE_INCREMENTAL=1 cargo +stable build&#39;\n</code></pre></div>\n<p>So pretty much the same as your system <span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu</span></p>",
        "id": 273510859,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646063915
    },
    {
        "content": "<p><del>Weird, I get the same numbers with and without <code>sccache</code>.</del> Ah, not the same, but pretty close.</p>",
        "id": 273511132,
        "sender_full_name": "Laurențiu",
        "timestamp": 1646064006
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/incremental.20compilation.20perf/near/273506919\">said</a>:</p>\n<blockquote>\n<p>Rustc does close to random reads of the crate metadata AFAIK. I don't think it is possible to improve this much without giving up on lazy decoding (which should save a lot of time as often only a small part of the metadata is needed)</p>\n</blockquote>\n<p>We could prefault the whole file. I tried that, it was bad for max-rss and cycles but might be net-positive in cases like this.</p>",
        "id": 273519428,
        "sender_full_name": "The 8472",
        "timestamp": 1646067241
    },
    {
        "content": "<p>But 200-350s is all-around terrible, incremental or not. Locally it takes 25-35 seconds. NFS is a much bigger issue here.</p>",
        "id": 273525498,
        "sender_full_name": "The 8472",
        "timestamp": 1646069734
    },
    {
        "content": "<p>yeah, it's pretty bad :)    I'm impressed you can get r-a to build in 35 second.  that's more than twice as fast as my fastest computer, even with fast local SSD.</p>",
        "id": 273534618,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646073616
    },
    {
        "content": "<p>but i guess the thing i wanted to highlight in this thread is the 25% to 40% slowdown just by enabling incremental compilation</p>",
        "id": 273534680,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646073655
    },
    {
        "content": "<p>Something something 5950X</p>",
        "id": 273535769,
        "sender_full_name": "Laurențiu",
        "timestamp": 1646074193
    },
    {
        "content": "<p>It doesn't seem to be the parallelism. It only builds 11s slower with 8 threads instead of 48.</p>\n<div class=\"codehilite\"><pre><span></span><code>cargo clean ; RUSTC_WRAPPER=&quot;&quot; CARGO_INCREMENTAL=0 taskset -c 0-7 cargo build -j8\n    Finished dev [unoptimized] target(s) in 36.78s\ncargo clean ; RUSTC_WRAPPER=&quot;&quot; CARGO_INCREMENTAL=0 RUSTFLAGS=&quot;-Clink-arg=-fuse-ld=lld&quot; cargo build -j48\n    Finished dev [unoptimized] target(s) in 25.64s\n</code></pre></div>",
        "id": 273538797,
        "sender_full_name": "The 8472",
        "timestamp": 1646075488
    },
    {
        "content": "<p>this is on nightly</p>",
        "id": 273538805,
        "sender_full_name": "The 8472",
        "timestamp": 1646075501
    },
    {
        "content": "<p>rustc also acquires file locks when doing incremental compilation. I could imagine that that's not particularly fast with NFS (if it works at all)</p>",
        "id": 273825327,
        "sender_full_name": "mw",
        "timestamp": 1646235544
    },
    {
        "content": "<p>locks on directories to get consistency between multiple files or locking individual files to avoid partial overwrites?</p>",
        "id": 273831865,
        "sender_full_name": "The 8472",
        "timestamp": 1646237645
    },
    {
        "content": "<p>either way, maybe cargo should detect network filesystems and warn about them?</p>",
        "id": 273832905,
        "sender_full_name": "The 8472",
        "timestamp": 1646238093
    },
    {
        "content": "<p>I think it's locking a single file to signal to other rustc instances that the corresponding cache directory is currently in use and must not be garbage collected:<br>\n<a href=\"https://github.com/rust-lang/rust/blob/c42d846add941a26bd254911e16f02c4a3f9346f/compiler/rustc_incremental/src/persist/fs.rs#L505-L552\">https://github.com/rust-lang/rust/blob/c42d846add941a26bd254911e16f02c4a3f9346f/compiler/rustc_incremental/src/persist/fs.rs#L505-L552</a></p>",
        "id": 273834791,
        "sender_full_name": "mw",
        "timestamp": 1646238760
    },
    {
        "content": "<p>I'd be surprised if file locking alone was causing a 20% slowdown</p>",
        "id": 273837661,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1646239837
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222286\">Andrew Chin (eminence)</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/incremental.20compilation.20perf/near/273837661\">said</a>:</p>\n<blockquote>\n<p>I'd be surprised if file locking alone was causing a 20% slowdown</p>\n</blockquote>\n<p>Well, that wasn't what I said. However, if file-locking on NFS involved some kind of cross-network synchronization then I could imagine a significant slowdown.</p>",
        "id": 273975362,
        "sender_full_name": "mw",
        "timestamp": 1646315730
    }
]