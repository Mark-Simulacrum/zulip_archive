[
    {
        "content": "<p>Based on <span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> 's suggestions, I have implemented a hacky way of instrumenting <code>stdlib</code> so that we can gather information about various events that might be interesting for optimizing <code>rustc</code> performance.</p>\n<p>As a first experiment, I have tried to count cases where a <code>Vec</code> is deallocated when empty (A) and when it is deallocated when empty and also with capacity zero (B). In theory, if we could find a place where many such <code>Vec</code>s are created, and these vecs would be embedded within size-critical structures, we could optimize them with e.g. <code>ThinVec</code>.</p>\n<p>It's a bit difficult to make sense of the data though, so I thought that I would also share it if anyone was intereseted in it. The data is <a href=\"https://github.com/Kobzol/rustc-instrumentation-data\">here</a>. Here's how to interpret the data:<br>\n1) I sample 1/1000 of all <code>Vec</code> <code>drop</code> calls where the vec was empty (sampling is done otherwise it would be too slow).<br>\n2) I get a backtrace, and store the filename, line and symbol name from the backtrace. I only store the first 5 entries in the backtrace (ignoring the first one, since that is the instrumentation function itself). For each such backtrace entry, I accumulate it in a hashmap.<br>\n3) At the end of the compilation session, I write the entries and their counts into a file and then merge all files together.<br>\n4) The output file then contains the backtrace entries (when did the Vec drop happen), along with a count how often it happened.</p>\n<p>This concrete data was gathered by compiling the (final) <code>cargo</code> crate.</p>\n<p>If you are interested in other similar \"queries\" that could be performed, let me know. I can also share my branch. <span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> also has a <a href=\"#narrow/stream/131828-t-compiler/topic/.60Rc.60.20without.20the.20weak.20count.3F/near/278240450\">guide</a> for doing this with <code>dhat-rs</code> (it works fine, it just wasn't usable in <code>alloc</code>, so I had to hack something new).</p>",
        "id": 278571548,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1649691039
    },
    {
        "content": "<p>Cools stuff! Am I correct in assuming that the second entry can also be discarded since presumably that will be the drop function for Vec?</p>",
        "id": 278573063,
        "sender_full_name": "rylev",
        "timestamp": 1649691654
    },
    {
        "content": "<p>I guess it would be interesting to tell what the top level symbol in a backtrace that's in libcore or libstd. That should give a decent understanding of what the vec is being used for (i.e., is it being used directly or as a part of some higher-level functionality inside of lib{std,core})</p>",
        "id": 278573296,
        "sender_full_name": "rylev",
        "timestamp": 1649691737
    },
    {
        "content": "<p>Yeah the backtrace filtering needs to get better. It's not so simple though, the output from the backtrace crate returns several sub-frames for each frame, since stuff gets inlined a lot, so it's not straightforward to look for the \"right place\", especially on such scale. I'll try to improve it.</p>",
        "id": 278596122,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1649701359
    }
]