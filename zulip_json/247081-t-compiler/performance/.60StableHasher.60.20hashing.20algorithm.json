[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Four years ago you <a href=\"https://github.com/rust-lang/rust/issues/41215#issuecomment-307149200\">suggested</a> testing <code>seahash</code> for <code>StableHasher</code>, which seems like a good suggestion given the <a href=\"https://gitlab.redox-os.org/redox-os/seahash/-/blob/master/src/lib.rs#L41-53\">claims</a> that's it's more than 10x faster than SipHash.</p>",
        "id": 263819958,
        "sender_full_name": "nnethercote",
        "timestamp": 1638779330
    },
    {
        "content": "<p>So I tried it today. For <code>incr-full</code> builds it increased rustc instruction counts by up to 29%!</p>",
        "id": 263820001,
        "sender_full_name": "nnethercote",
        "timestamp": 1638779372
    },
    {
        "content": "<p>This might be explained by the fact that I sped up SipHasher128 (used by StableHasher) quite a bit last year: <a href=\"https://github.com/rust-lang/rust/pull/68914\">https://github.com/rust-lang/rust/pull/68914</a></p>",
        "id": 263820342,
        "sender_full_name": "nnethercote",
        "timestamp": 1638779615
    },
    {
        "content": "<p>Still, disappointing.</p>",
        "id": 263820349,
        "sender_full_name": "nnethercote",
        "timestamp": 1638779620
    },
    {
        "content": "<p>My impression from having looked at a bunch of the hashing implementations is that every one of them claims to be faster and better than all the others, more or less.</p>",
        "id": 263820407,
        "sender_full_name": "nnethercote",
        "timestamp": 1638779652
    },
    {
        "content": "<p>I also tried <code>wyhash</code>, but I got build errors when building <code>std</code>. I had to add a <code>finish128</code> method, I just took the <code>u64</code> result from the <code>finish</code> method and duplicated the value into the high bits. (I did the same thing for <code>seahash</code>, and it worked ok.)</p>",
        "id": 263820490,
        "sender_full_name": "nnethercote",
        "timestamp": 1638779723
    },
    {
        "content": "<p>I'm genuinely surprised. I appreciate you testing the hypothesis, though.</p>",
        "id": 263824681,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638782528
    },
    {
        "content": "<p>Do you think it likely that even an optimized seahash will fail to beat siphash?</p>",
        "id": 263824753,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638782575
    },
    {
        "content": "<p>I'm surprised that their benchmarks would be off by <em>that</em> much.</p>",
        "id": 263824785,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638782596
    },
    {
        "content": "<p>FWIW, I tried highwayhigh and it was also slower (<a href=\"https://github.com/rust-lang/rust/issues/51054#issuecomment-933603794\">https://github.com/rust-lang/rust/issues/51054#issuecomment-933603794</a>).</p>",
        "id": 263855884,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1638800374
    },
    {
        "content": "<p>My takeaway: take all hashing performance claims with a grain, nay, a bucket of salt</p>",
        "id": 263925910,
        "sender_full_name": "nnethercote",
        "timestamp": 1638825469
    },
    {
        "content": "<p>Do you have a diff of these changes somewhere? I'd love to try some hash algos and see how they work on these inputs.</p>",
        "id": 263933973,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1638829620
    },
    {
        "content": "<p>Diff for rustc:</p>\n<div class=\"codehilite\"><pre><span></span><code>diff --git a/compiler/rustc_data_structures/Cargo.toml b/compiler/rustc_data_structures/Cargo.toml\nindex e3395df3590..36eddcc6e63 100644\n--- a/compiler/rustc_data_structures/Cargo.toml\n+++ b/compiler/rustc_data_structures/Cargo.toml\n@@ -27,6 +27,7 @@ measureme = &quot;10.0.0&quot;\n libc = &quot;0.2&quot;\n stacker = &quot;0.1.14&quot;\n tempfile = &quot;3.2&quot;\n+seahash = { path = &quot;/home/njn/dev/seahash&quot; }\n\n [dependencies.parking_lot]\n version = &quot;0.11&quot;\ndiff --git a/compiler/rustc_data_structures/src/stable_hasher.rs b/compiler/rustc_data_structures/sr\nc/stable_hasher.rs\nindex f800ec6a6a1..2eb88448a0f 100644\n--- a/compiler/rustc_data_structures/src/stable_hasher.rs\n+++ b/compiler/rustc_data_structures/src/stable_hasher.rs\n@@ -1,4 +1,4 @@\n-use crate::sip128::SipHasher128;\n+use seahash::SeaHasher;\n use rustc_index::bit_set;\n use rustc_index::vec;\n use smallvec::SmallVec;\n@@ -15,13 +15,16 @@\n /// To that end we always convert integers to little-endian format before\n /// hashing and the architecture dependent `isize` and `usize` types are\n /// extended to 64 bits if needed.\n+//\n+// njn: I think seahash is endian-independent\n pub struct StableHasher {\n-    state: SipHasher128,\n+    state: SeaHasher,\n }\n\n impl ::std::fmt::Debug for StableHasher {\n-    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {\n-        write!(f, &quot;{:?}&quot;, self.state)\n+    fn fmt(&amp;self, _f: &amp;mut std::fmt::Formatter&lt;&#39;_&gt;) -&gt; std::fmt::Result {\n+        //write!(f, &quot;{:?}&quot;, self.state)\n+        panic!(&quot;njn: todo&quot;);\n     }\n }\n\n@@ -32,7 +35,7 @@ pub trait StableHasherResult: Sized {\n impl StableHasher {\n     #[inline]\n     pub fn new() -&gt; Self {\n-        StableHasher { state: SipHasher128::new_with_keys(0, 0) }\n+        StableHasher { state: SeaHasher::new() }\n     }\n\n     #[inline]\n</code></pre></div>",
        "id": 263941054,
        "sender_full_name": "nnethercote",
        "timestamp": 1638834465
    },
    {
        "content": "<p>I had to use a modified version of <code>seahash</code> to add a <code>finish128</code> method. Here's the diff:</p>\n<div class=\"codehilite\"><pre><span></span><code>diff --git a/src/stream.rs b/src/stream.rs\nindex cf35ebc..6b0fa4d 100644\n--- a/src/stream.rs\n+++ b/src/stream.rs\n@@ -220,6 +220,26 @@ impl Hasher for SeaHasher {\n     }\n }\n\n+impl SeaHasher {\n+    /// njn: docs\n+    pub fn finish128(&amp;self) -&gt; (u64, u64) {\n+        /*\n+        let a = if self.ntail &gt; 0 {\n+            let tail = helper::read_int(&amp;self.tail.to_le_bytes()[..self.ntail])\n;\n+            helper::diffuse(self.state.0 ^ tail)\n+        } else {\n+            self.state.0\n+        };\n+        (\n+            helper::diffuse(a ^ self.state.1 ^ self.written),\n+            helper::diffuse(self.state.2 ^ self.state.3 + self.ntail as u64),\n+        )\n+        */\n+        let x = self.finish();\n+        (x, x)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n</code></pre></div>",
        "id": 263941131,
        "sender_full_name": "nnethercote",
        "timestamp": 1638834510
    },
    {
        "content": "<p>The commented out code there was my first attempt to produce a 128 bit value, the compiler failed to build <code>std</code> with that. So then I changed it to the <code>(x, x)</code> thing, which is stupid and not what you would do for real but was enough for benchmarking purposes, and successfully built <code>std</code>.</p>",
        "id": 263941181,
        "sender_full_name": "nnethercote",
        "timestamp": 1638834579
    },
    {
        "content": "<p>I am guessing everyone is running all the benchmarks and picking the ones they like most to advertise their performance on.</p>",
        "id": 264352525,
        "sender_full_name": "Jubilee",
        "timestamp": 1639077529
    },
    {
        "content": "<p>most of the hashing algorithms also aren't optimized for the incremental hash case, and Rust's Hash trait (nor rustc's StableHasher trait afaict) doesn't give us a good way to distinguish — I discussed the issue <a href=\"https://github.com/rust-lang/rust/issues/86161#issuecomment-916577133\">https://github.com/rust-lang/rust/issues/86161#issuecomment-916577133</a> some.</p>",
        "id": 264393263,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1639100516
    },
    {
        "content": "<p>I'd expect this to matter a lot for the discrepancy between c++ hash algo benchmarks and rust ones. Depending on what kind of workload stablehasher uses, it might be worth tweaking the trait for this (a la <code>BuildHasher::hash_one</code>) and seeing if that makes a difference.</p>",
        "id": 264393364,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1639100604
    }
]