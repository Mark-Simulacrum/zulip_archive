[
    {
        "content": "<p>If you want a somewhat 'different' task, it might be a fun project to integrate BOLT into the src/ci/pgo.sh script -- it recently landed in LLVM 14. It'll likely require some work to wire everything up, though.</p>",
        "id": 272881979,
        "sender_full_name": "simulacrum",
        "timestamp": 1645572933
    },
    {
        "content": "<p>I actually tried that a few days ago, but failed rather quickly because I have an AMD processor :( It seemed to me that BOLT requires Intel LBR. well I couldn't get it to work properly with AMD.</p>",
        "id": 272882084,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645572981
    },
    {
        "content": "<p>Huh, interesting</p>",
        "id": 272882105,
        "sender_full_name": "simulacrum",
        "timestamp": 1645572994
    },
    {
        "content": "<p>It looks like they support perf-record mode with LBR, but also instrumenting a binary directly?</p>",
        "id": 272882193,
        "sender_full_name": "simulacrum",
        "timestamp": 1645573065
    },
    {
        "content": "<p>The latter might be something we can use</p>",
        "id": 272882202,
        "sender_full_name": "simulacrum",
        "timestamp": 1645573070
    },
    {
        "content": "<p><a href=\"https://github.com/llvm/llvm-project/commit/4c106cfdf7cf7eec861ad3983a3dd9a9e8f3a8ae#diff-b00163f1bb0908d1d4b83db158ee13e330dd13877b3b292ea9883e10efd59d25R138-R149\">https://github.com/llvm/llvm-project/commit/4c106cfdf7cf7eec861ad3983a3dd9a9e8f3a8ae#diff-b00163f1bb0908d1d4b83db158ee13e330dd13877b3b292ea9883e10efd59d25R138-R149</a></p>",
        "id": 272882232,
        "sender_full_name": "simulacrum",
        "timestamp": 1645573082
    },
    {
        "content": "<p>But disregarding the fact that I can't run BOLT locally with perf, there are some changes that need to be done to rustc to make it work with BOLT, I think that one of them was adding supoprt for relocations, I can try to look at that.</p>",
        "id": 272882295,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645573108
    },
    {
        "content": "<p>You're right, that is an alternative. I think that I tried that and got an error that some linker parameter was not used when building <code>rustc</code>, so I guess that could be the next step on what to investigate.</p>",
        "id": 272882394,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645573177
    },
    {
        "content": "<p>BTW I suppose that we want to \"BOLTify\" the shared libraries, not the main <code>rustc</code> executable, since that just contains some thin driver wrapper?</p>",
        "id": 272882552,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645573275
    },
    {
        "content": "<p>Yeah, probably. I'm not sure the extent to which those are separable or not, but the shared libraries are were the bulk of the work is.</p>",
        "id": 272882620,
        "sender_full_name": "simulacrum",
        "timestamp": 1645573322
    },
    {
        "content": "<p>FWIW, one thing that I have found is sometimes easier is starting with the LLVM part of this -- if we can BOLT just LLVM, that'll already be a good win I suspect</p>",
        "id": 272882673,
        "sender_full_name": "simulacrum",
        "timestamp": 1645573344
    },
    {
        "content": "<p>and since it's C++ code and in the same project, it may be much easier to do that.</p>",
        "id": 272882686,
        "sender_full_name": "simulacrum",
        "timestamp": 1645573355
    },
    {
        "content": "<p>(i.e., just configuring LLVM's build system, for example)</p>",
        "id": 272882710,
        "sender_full_name": "simulacrum",
        "timestamp": 1645573373
    },
    {
        "content": "<p>So currently on CI when a build is performed, LLVM is first instrumented with PGO (while being invoked by rustc), then LLVM is rebuilt with the profiling data and then this optimized LLVM build is used for <code>rustc</code>?</p>",
        "id": 272882890,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645573491
    },
    {
        "content": "<p>(I assume that's how it would work with BOLT, so I want to confirm whether I understand the current situation, I seem to recall that PGO is being used currently for both LLVM and rustc on CI)</p>",
        "id": 272883042,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645573584
    },
    {
        "content": "<p>LLVM and rustc are both built with instrumentation, then we run some benchmarks to collect data, then both are rebuilt</p>",
        "id": 272888316,
        "sender_full_name": "simulacrum",
        "timestamp": 1645577380
    },
    {
        "content": "<p>Ok, I will start with BOLTifying LLVM then and see how far I get. Do I remember correctly that the custom Rust CI machines use Ryzen, therefore we won't be able to use LBR on CI?</p>",
        "id": 272913588,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645601986
    },
    {
        "content": "<p>I seem to recall the perf collector server being a zen2, and for CI: if we're still using the regular hosted GHA runners, dv2 or dsv2, those are intel only IIRC</p>",
        "id": 272915215,
        "sender_full_name": "lqd",
        "timestamp": 1645603422
    },
    {
        "content": "<p>GHA doesn't allow perf I believe.</p>",
        "id": 272915743,
        "sender_full_name": "bjorn3",
        "timestamp": 1645603867
    },
    {
        "content": "<p>So far I have managed to instrument <a href=\"http://libLLVM.so\">libLLVM.so</a> with BOLT and then apply the generated profiling data to create an optimized library. Further progress is probably blocked until LLVM 14 is released (and used in CI scripts), to avoid the hassle of building BOLT separately on CI (it will be in tree with LLVM 14).</p>",
        "id": 273290762,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645826661
    },
    {
        "content": "<p>Although I'm probably mixing up LLVM used for bootstrap in CI and the LLVM built by <code>x.py build/dist</code>, because the LLVM submodule that is inside the <code>rust</code> repo already has the <code>bolt</code> directory.</p>",
        "id": 273290926,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645826765
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"266526\">@Jakub Beránek</span> It might be possible to do a draft PR that points to a different LLVM, and test it (including perf) that way.</p>",
        "id": 273292682,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645827706
    },
    {
        "content": "<p>And also, yeah, you want to be using the LLVM submodule from the Rust repo, I think.</p>",
        "id": 273292740,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645827727
    },
    {
        "content": "<p>Yes, we already use LLVM 14 for rust's own bootstrap</p>",
        "id": 273293208,
        "sender_full_name": "simulacrum",
        "timestamp": 1645828015
    },
    {
        "content": "<p><a href=\"https://perf.rust-lang.org/compare.html?start=5d9d1e88910f2c7f58e8258b87d30b1340b647fa&amp;end=2e6d9eaae77560cdad01ed7836ae6ceb0f0cc988\">https://perf.rust-lang.org/compare.html?start=5d9d1e88910f2c7f58e8258b87d30b1340b647fa&amp;end=2e6d9eaae77560cdad01ed7836ae6ceb0f0cc988</a> First promising results of applying BOLT to an already PGOed LLVM. Instructions counts are largely the same, but cycles reduced by up to 10 %, Max RSS by up to 20 % and bootstrap down by ~24 seconds.</p>",
        "id": 274317337,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1646586837
    },
    {
        "content": "<p>Although, I should check how much of that is caused by BOLT and how much by upgrading bootstrap LLVM <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 274318243,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1646587906
    },
    {
        "content": "<p>Let's check: <a href=\"https://github.com/rust-lang/rust/pull/94677\">https://github.com/rust-lang/rust/pull/94677</a></p>",
        "id": 274319632,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1646589735
    },
    {
        "content": "<p><a href=\"https://research.facebook.com/publications/vespa-static-profiling-for-binary-optimization/\">https://research.facebook.com/publications/vespa-static-profiling-for-binary-optimization/</a> Uhh. Meta keeps producing these papers and optimizers faster than we can integrate them into Rust :D</p>",
        "id": 277288844,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1648736522
    },
    {
        "content": "<p>and there was another PGO-without-actually-profiling paper that looked nice if you want more of those :3</p>",
        "id": 277289589,
        "sender_full_name": "lqd",
        "timestamp": 1648736796
    },
    {
        "content": "<p>I'll be happy if we manage to integrate BOLT first :D</p>",
        "id": 277290165,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1648737025
    },
    {
        "content": "<p>same :)</p>",
        "id": 277290625,
        "sender_full_name": "lqd",
        "timestamp": 1648737235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/BOLT/near/277289589\">said</a>:</p>\n<blockquote>\n<p>and there was another PGO-without-actually-profiling paper that looked nice if you want more of those :3</p>\n</blockquote>\n<p><a href=\"https://arxiv.org/abs/2112.14679\">https://arxiv.org/abs/2112.14679</a> you mean?</p>",
        "id": 277290841,
        "sender_full_name": "bjorn3",
        "timestamp": 1648737307
    },
    {
        "content": "<p>yes, also from FB</p>",
        "id": 277290894,
        "sender_full_name": "lqd",
        "timestamp": 1648737333
    }
]