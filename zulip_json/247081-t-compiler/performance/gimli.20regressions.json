[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> you expressed some interest in my \"loading all structs comment\" -- basically, I'm referring to the fact that even though the public API of libstd didn't change at all as a result of the PR, we are still decoding and utilizing a ton more metadata (e.g., <a href=\"https://perf.rust-lang.org/detailed-query.html?commit=59c859c74c32bb26ba7c0932ec50c6c566eeac76&amp;base_commit=6b269e44322cfca727fd0e793d3a60bd371cbcae&amp;benchmark=helloworld-check&amp;run_name=full\">for helloworld</a>)</p>",
        "id": 205492130,
        "sender_full_name": "simulacrum",
        "timestamp": 1596122333
    },
    {
        "content": "<p>local evaluation seems to conclude the majority of that comes from <code>has_drop</code> checking and such, but I've not had time to look further</p>",
        "id": 205492205,
        "sender_full_name": "simulacrum",
        "timestamp": 1596122385
    },
    {
        "content": "<p>My <em>guess</em> is that when we ask for \"does X implement drop\" that somehow boils down to \"What types implement Drop\" which then proceeds to examine all types -- but this is purely based on a quick glance at the backtrace and such</p>",
        "id": 205492371,
        "sender_full_name": "simulacrum",
        "timestamp": 1596122444
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\"><pre><span></span><code>      &quot;rustc_metadata::rmeta::decoder::cstore_impl::provide_extern::type_of&quot;,\n    &quot;&lt;rustc_query_system::query::caches::DefaultCache&lt;K,V&gt; as rustc_query_system::query::caches::QueryCache&gt;::lookup&quot;,\n    &quot;rustc_middle::ty::query::TyCtxtAt::type_of&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_middle::ty::context::TyCtxt&gt;::type_of&quot;,\n    &quot;rustc_middle::ty::trait_def::trait_impls_of_provider::{{closure}}&quot;,\n    &quot;rustc_middle::ty::trait_def::trait_impls_of_provider&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_query_system::query::config::QueryAccessors&lt;rustc_middle::ty::context::TyCtxt&gt; for rustc_middle::ty::query::queries::trait_impls_of&gt;::compute&quot;,\n    &quot;&lt;rustc_query_system::query::caches::ArenaCache&lt;K,V&gt; as rustc_query_system::query::caches::QueryCache&gt;::lookup&quot;,\n    &quot;rustc_middle::ty::query::TyCtxtAt::trait_impls_of&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_middle::ty::context::TyCtxt&gt;::trait_impls_of&quot;,\n    &quot;rustc_middle::ty::trait_def::&lt;impl rustc_middle::ty::context::TyCtxt&gt;::for_each_relevant_impl&quot;,\n    &quot;rustc_trait_selection::traits::select::candidate_assembly::&lt;impl rustc_trait_selection::traits::select::SelectionContext&gt;::assemble_candidates_from_impls&quot;,\n    &quot;rustc_trait_selection::traits::select::candidate_assembly::&lt;impl rustc_trait_selection::traits::select::SelectionContext&gt;::assemble_candidates&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::candidate_from_obligation_no_cache&quot;,\n    &quot;rustc_trait_selection::traits::select::candidate_assembly::&lt;impl rustc_trait_selection::traits::select::SelectionContext&gt;::candidate_from_obligation::{{closure}}&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::in_task::{{closure}}&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::in_task&quot;,\n    &quot;rustc_trait_selection::traits::select::candidate_assembly::&lt;impl rustc_trait_selection::traits::select::SelectionContext&gt;::candidate_from_obligation&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluate_stack&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluate_trait_predicate_recursively::{{closure}}&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::in_task::{{closure}}&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::in_task&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluate_trait_predicate_recursively&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluate_predicate_recursively&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluate_root_obligation::{{closure}}&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluation_probe::{{closure}}&quot;,\n    &quot;rustc_infer::infer::InferCtxt::probe&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluation_probe&quot;,\n    &quot;rustc_trait_selection::traits::select::SelectionContext::evaluate_root_obligation&quot;,\n    &quot;rustc_traits::evaluate_obligation::evaluate_obligation::{{closure}}&quot;,\n    &quot;rustc_infer::infer::InferCtxtBuilder::enter_with_canonical::{{closure}}&quot;,\n    &quot;rustc_infer::infer::InferCtxtBuilder::enter&quot;,\n    &quot;rustc_infer::infer::InferCtxtBuilder::enter_with_canonical&quot;,\n    &quot;rustc_traits::evaluate_obligation::evaluate_obligation&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_query_system::query::config::QueryAccessors&lt;rustc_middle::ty::context::TyCtxt&gt; for rustc_middle::ty::query::queries::evaluate_obligation&gt;::compute&quot;,\n    &quot;&lt;rustc_query_system::query::caches::DefaultCache&lt;K,V&gt; as rustc_query_system::query::caches::QueryCache&gt;::lookup&quot;,\n    &quot;rustc_middle::ty::query::TyCtxtAt::evaluate_obligation&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_middle::ty::context::TyCtxt&gt;::evaluate_obligation&quot;,\n    &quot;&lt;rustc_infer::infer::InferCtxt as rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt&gt;::evaluate_obligation&quot;,\n    &quot;&lt;rustc_infer::infer::InferCtxt as rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt&gt;::evaluate_obligation_no_overflow&quot;,\n    &quot;&lt;rustc_infer::infer::InferCtxt as rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt&gt;::predicate_must_hold_modulo_regions&quot;,\n    &quot;rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions&quot;,\n    &quot;rustc_ty::common_traits::is_item_raw::{{closure}}&quot;,\n    &quot;rustc_infer::infer::InferCtxtBuilder::enter&quot;,\n    &quot;rustc_ty::common_traits::is_item_raw&quot;,\n    &quot;rustc_ty::common_traits::is_copy_raw&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_query_system::query::config::QueryAccessors&lt;rustc_middle::ty::context::TyCtxt&gt; for rustc_middle::ty::query::queries::is_copy_raw&gt;::compute&quot;,\n    &quot;&lt;rustc_query_system::query::caches::DefaultCache&lt;K,V&gt; as rustc_query_system::query::caches::QueryCache&gt;::lookup&quot;,\n    &quot;rustc_middle::ty::query::TyCtxtAt::is_copy_raw&quot;,\n    &quot;rustc_middle::ty::util::&lt;impl rustc_middle::ty::TyS&gt;::is_copy_modulo_regions&quot;,\n    &quot;&lt;rustc_ty::needs_drop::NeedsDropTypes&lt;F&gt; as core::iter::traits::iterator::Iterator&gt;::next&quot;,\n    &quot;rustc_ty::needs_drop::needs_drop_raw&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_query_system::query::config::QueryAccessors&lt;rustc_middle::ty::context::TyCtxt&gt; for rustc_middle::ty::query::queries::needs_drop_raw&gt;::compute&quot;,\n    &quot;&lt;rustc_query_system::query::caches::DefaultCache&lt;K,V&gt; as rustc_query_system::query::caches::QueryCache&gt;::lookup&quot;,\n    &quot;rustc_middle::ty::query::TyCtxtAt::needs_drop_raw&quot;,\n    &quot;rustc_middle::ty::query::&lt;impl rustc_middle::ty::context::TyCtxt&gt;::needs_drop_raw&quot;,\n    &quot;rustc_middle::ty::util::&lt;impl rustc_middle::ty::TyS&gt;::needs_drop&quot;,\n    &quot;rustc_mir_build::hair::cx::Cx::needs_drop&quot;,\n    &quot;rustc_mir_build::build::scope::&lt;impl rustc_mir_build::build::Builder&gt;::schedule_drop&quot;,\n    &quot;rustc_mir_build::build::expr::as_temp::&lt;impl rustc_mir_build::build::Builder&gt;::expr_as_temp&quot;,\n</code></pre></div>",
        "id": 205492509,
        "sender_full_name": "simulacrum",
        "timestamp": 1596122510
    },
    {
        "content": "<p>that backtrace accounts for 667 calls to type_of, which is 83% of them. gimli increases the amount of calls by 320</p>",
        "id": 205492938,
        "sender_full_name": "simulacrum",
        "timestamp": 1596122726
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> as well</p>",
        "id": 205493110,
        "sender_full_name": "simulacrum",
        "timestamp": 1596122803
    },
    {
        "content": "<p>if you can get a query stack instead of a raw backtrace that would be easier to read I think</p>",
        "id": 205494382,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596123442
    },
    {
        "content": "<p>if you pulled this out of gdb it might be tricky though</p>",
        "id": 205494411,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596123461
    },
    {
        "content": "<p>oh no this is manual <code>Backtrace::force_capture()</code> and then parsing stderr :)</p>",
        "id": 205494801,
        "sender_full_name": "simulacrum",
        "timestamp": 1596123635
    },
    {
        "content": "<p>but pulling queries out of this is pretty easy</p>",
        "id": 205494821,
        "sender_full_name": "simulacrum",
        "timestamp": 1596123648
    },
    {
        "content": "<p>needs_drop_raw -&gt; is_copy_raw -&gt; evaluate_obligation -&gt; trait_impls_of -&gt; type_of</p>",
        "id": 205494967,
        "sender_full_name": "simulacrum",
        "timestamp": 1596123721
    },
    {
        "content": "<p>hmm</p>",
        "id": 205534872,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596144549
    },
    {
        "content": "<p>that's quite interesting, <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>, thanks</p>",
        "id": 205534880,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596144556
    },
    {
        "content": "<p>I'm not sure how much we can sidestep that, but we might be able to, I think that what happens there is that we wind up loading <em>all</em> impls from <em>all</em> crates and hashing them effectively by the self type...</p>",
        "id": 205534918,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596144592
    },
    {
        "content": "<p>Hm perhaps. I think we should at <em>least</em> not be loading a bunch of stuff cross-crate to evaluate things like is_drop</p>",
        "id": 205534993,
        "sender_full_name": "simulacrum",
        "timestamp": 1596144624
    },
    {
        "content": "<p>er, needs_drop</p>",
        "id": 205534999,
        "sender_full_name": "simulacrum",
        "timestamp": 1596144626
    },
    {
        "content": "<p>we should just load a single byte/bit for that, really</p>",
        "id": 205535017,
        "sender_full_name": "simulacrum",
        "timestamp": 1596144638
    },
    {
        "content": "<p>it's \"hard\" to compute and is all but guaranteed to be needed in the crate we're loading anyway</p>",
        "id": 205535041,
        "sender_full_name": "simulacrum",
        "timestamp": 1596144659
    },
    {
        "content": "<p>It's true that we could probably specialize the <code>Drop</code> trait.</p>",
        "id": 205587670,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596200671
    },
    {
        "content": "<p>It has a lot of special properties</p>",
        "id": 205587678,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596200675
    },
    {
        "content": "<p>e.g., it's either implemented <em>for all instances of a given struct</em> or <em>none</em></p>",
        "id": 205587698,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596200690
    },
    {
        "content": "<p><del>really, it's not a trait at all...</del></p>",
        "id": 205587711,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596200702
    },
    {
        "content": "<p>Not sure if this is related, but <code>drop_in_place</code> is usually the function that results in the most LLVM IR production.</p>",
        "id": 205648044,
        "sender_full_name": "njn",
        "timestamp": 1596234441
    },
    {
        "content": "<p>Seems unrelated, but I've noticed the same</p>",
        "id": 205649462,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1596235799
    },
    {
        "content": "<p>I've been meaning to look into the MIR shim code more deeply to maybe improve this</p>",
        "id": 205649519,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1596235818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> oh wow I didn't expect it to actually need to look at crates. we can easily add a cross-crate has_drop (assuming it's a query) that looks only at that crate's metadata</p>",
        "id": 205676876,
        "sender_full_name": "eddyb",
        "timestamp": 1596280398
    },
    {
        "content": "<p>so for Vec it would look in liballoc's entry for Vec</p>",
        "id": 205676883,
        "sender_full_name": "eddyb",
        "timestamp": 1596280434
    },
    {
        "content": "<p>now that still leaves collecting all of the Drop impls</p>",
        "id": 205676927,
        "sender_full_name": "eddyb",
        "timestamp": 1596280449
    },
    {
        "content": "<p>we could do the indexing better than we do now and have the <code>DefId</code>-based cases of the \"simplified type\" indexing mechanism only look up in the crate where that type was defined. ugh actually this sounds like it would mess with a lot of other different trait system situatons</p>",
        "id": 205676954,
        "sender_full_name": "eddyb",
        "timestamp": 1596280547
    },
    {
        "content": "<p>but every single trait has this problem of wanting to collect the universe of impls, it's not just Drop</p>",
        "id": 205676995,
        "sender_full_name": "eddyb",
        "timestamp": 1596280567
    },
    {
        "content": "<p>so at the very least we could store the \"trait impls\" in rmeta indexed by the simplified type, so we don't have to call <code>type_of</code> to find that out</p>",
        "id": 205677005,
        "sender_full_name": "eddyb",
        "timestamp": 1596280616
    },
    {
        "content": "<p>and that's enough to filter non-blanket impls down to one impl in most cases</p>",
        "id": 205677019,
        "sender_full_name": "eddyb",
        "timestamp": 1596280645
    },
    {
        "content": "<p>or at least all the impls being in the same crate etc.</p>",
        "id": 205677026,
        "sender_full_name": "eddyb",
        "timestamp": 1596280660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> so my minimal suggestion would be to make <a href=\"https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/src/librustc_metadata/rmeta/mod.rs#L233-L237\">cross-crate trait impls</a> be stored more like <a href=\"https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/src/librustc_middle/ty/trait_def.rs#L67-L71\">in-memory trait impls</a></p>",
        "id": 205677101,
        "sender_full_name": "eddyb",
        "timestamp": 1596280777
    },
    {
        "content": "<p>especially the grouping by <code>SimplifiedType</code>. at the very least, replacing <code>DefIndex</code> elements by <code>(Option&lt;SimplifiedType&gt;, DefIndex)</code></p>",
        "id": 205677146,
        "sender_full_name": "eddyb",
        "timestamp": 1596280810
    },
    {
        "content": "<p>even if the list of impls isn't loaded any more lazily, at least <a href=\"https://github.com/rust-lang/rust/blob/b5eae9c44d713779a08e6db352088d45cad3e9b6/src/librustc_middle/ty/trait_def.rs#L208-L210\">this loop</a> will be able to insert into <code>impls</code> itself instead of using <code>add_impl</code> which has to use <code>type_of</code></p>",
        "id": 205677167,
        "sender_full_name": "eddyb",
        "timestamp": 1596280891
    },
    {
        "content": "<p>and the only downside should be the size of the <code>.rmeta</code>/<code>.rlib</code> on disk, but hopefully not by much</p>",
        "id": 205677170,
        "sender_full_name": "eddyb",
        "timestamp": 1596280911
    },
    {
        "content": "<p>(please PM me if you want to get a hold of me, I'm behind looking at mentions for now)</p>",
        "id": 205677215,
        "sender_full_name": "eddyb",
        "timestamp": 1596280973
    },
    {
        "content": "<p>actually, argh, this seems simple enough that I want to try doing it now</p>",
        "id": 205677220,
        "sender_full_name": "eddyb",
        "timestamp": 1596280998
    },
    {
        "content": "<p>yeah that was easy, will open the PR in a bit</p>",
        "id": 205678744,
        "sender_full_name": "eddyb",
        "timestamp": 1596283851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> hopefully this helps <a href=\"https://github.com/rust-lang/rust/pull/75008\">https://github.com/rust-lang/rust/pull/75008</a></p>",
        "id": 205681518,
        "sender_full_name": "eddyb",
        "timestamp": 1596288713
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> so just to make sure I understand -- right now, when checking e.g. <code>T: Copy</code> in the compiler, we load <em>all</em> impls for Copy and then try and find if T is in that set?</p>",
        "id": 205681735,
        "sender_full_name": "simulacrum",
        "timestamp": 1596288968
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> yes, but when we load the impls we bin them by the outermost level of the <code>Self</code> type</p>",
        "id": 205681751,
        "sender_full_name": "eddyb",
        "timestamp": 1596289014
    },
    {
        "content": "<p>so that we check if <code>Vec</code> impls <code>Copy</code>, that's <code>O(1)</code></p>",
        "id": 205681764,
        "sender_full_name": "eddyb",
        "timestamp": 1596289038
    },
    {
        "content": "<p>oh, is the loading done once?</p>",
        "id": 205681768,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289047
    },
    {
        "content": "<p>especially since there are no blanket impls of <code>Copy</code> - well, maybe <code>&amp;_</code> impls count as blanket</p>",
        "id": 205681773,
        "sender_full_name": "eddyb",
        "timestamp": 1596289056
    },
    {
        "content": "<p>well everything is cached in rustc, the main distinction is granularity and eager vs lazy</p>",
        "id": 205681823,
        "sender_full_name": "eddyb",
        "timestamp": 1596289083
    },
    {
        "content": "<p>What's the cache key though? Vec? Copy?</p>",
        "id": 205681889,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289213
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> to put it another way, we more or less only read every byte in the <code>.rmeta</code> <em>at most</em> once</p>",
        "id": 205681892,
        "sender_full_name": "eddyb",
        "timestamp": 1596289223
    },
    {
        "content": "<p>there's some stuff that does double-duty and the tables, but that's not relevant here</p>",
        "id": 205681905,
        "sender_full_name": "eddyb",
        "timestamp": 1596289258
    },
    {
        "content": "<p>okay yeah I should explain it better</p>",
        "id": 205681910,
        "sender_full_name": "eddyb",
        "timestamp": 1596289270
    },
    {
        "content": "<p>so when you want to know anything about what implements <code>Copy</code>, <code>traits_impls_of(Copy)</code> is computed</p>",
        "id": 205681915,
        "sender_full_name": "eddyb",
        "timestamp": 1596289293
    },
    {
        "content": "<p>that holds all of the impls of <code>Copy</code> in the crate graph, <em>indexed</em> by the \"simplified <code>Self</code> type\"</p>",
        "id": 205681929,
        "sender_full_name": "eddyb",
        "timestamp": 1596289320
    },
    {
        "content": "<p>the indexing is important for making using <code>traits_impls_of</code>'s result later, much cheaper</p>",
        "id": 205681971,
        "sender_full_name": "eddyb",
        "timestamp": 1596289331
    },
    {
        "content": "<p>it's also why you were seeing all of those <code>type_of</code> calls, because <code>traits_impls_of(Drop)</code> will call <code>type_of</code> for every <code>Drop</code> impl in the crate graph in order to compute the \"simplified <code>Self</code> type\"</p>",
        "id": 205681984,
        "sender_full_name": "eddyb",
        "timestamp": 1596289382
    },
    {
        "content": "<p>Right, yeah</p>",
        "id": 205681992,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289401
    },
    {
        "content": "<p>so my PR should remove that cost, or at least replace it with a smaller deserialization cost</p>",
        "id": 205681996,
        "sender_full_name": "eddyb",
        "timestamp": 1596289419
    },
    {
        "content": "<p>It feels like we shouldn't even be querying \"All traits in the world\" so to speak</p>",
        "id": 205681998,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289432
    },
    {
        "content": "<p>I'm becoming increasingly suspicious of it helping, but maybe our type deserialization is inefficient</p>",
        "id": 205682001,
        "sender_full_name": "eddyb",
        "timestamp": 1596289439
    },
    {
        "content": "<p>there's nothing that's \"all traits\"</p>",
        "id": 205682041,
        "sender_full_name": "eddyb",
        "timestamp": 1596289447
    },
    {
        "content": "<p>er, I meant all impls, sorry</p>",
        "id": 205682044,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289455
    },
    {
        "content": "<p>like \"impls of Copy\" is a really large set</p>",
        "id": 205682048,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289467
    },
    {
        "content": "<p>okay so the problem with that is we don't know what else to do</p>",
        "id": 205682053,
        "sender_full_name": "eddyb",
        "timestamp": 1596289477
    },
    {
        "content": "<p>We can't store what traits a type implements?</p>",
        "id": 205682061,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289492
    },
    {
        "content": "<p>we can better index them, but they're <code>impl</code>s which means they pattern-match</p>",
        "id": 205682063,
        "sender_full_name": "eddyb",
        "timestamp": 1596289497
    },
    {
        "content": "<p>I was telling <span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> this a couple weeks ago, come to think of it</p>",
        "id": 205682075,
        "sender_full_name": "eddyb",
        "timestamp": 1596289517
    },
    {
        "content": "<p>at best we can index common cases (which is what the \"simplified <code>Self</code> type\" thing is for), but we can't efficiently store <em>all</em> possible impls</p>",
        "id": 205682086,
        "sender_full_name": "eddyb",
        "timestamp": 1596289553
    },
    {
        "content": "<p>it seems like at least we should try to avoid deserializing all impls if we can help it</p>",
        "id": 205682135,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289579
    },
    {
        "content": "<p>but maybe that's not the right thinking</p>",
        "id": 205682147,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289597
    },
    {
        "content": "<p>that's the third paragraph in the PR description</p>",
        "id": 205682150,
        "sender_full_name": "eddyb",
        "timestamp": 1596289604
    },
    {
        "content": "<p>making it lazy based on the \"indexing key\"</p>",
        "id": 205682155,
        "sender_full_name": "eddyb",
        "timestamp": 1596289616
    },
    {
        "content": "<p>well I meant not so much with Self type as even just saying \"hey we're checking for Copy on type Bar, which is declared in crate std, so we only need to load impls of Copy in std\"?</p>",
        "id": 205682166,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289648
    },
    {
        "content": "<p>(so only \"blanket impls\", i.e. those without a useful \"shallow simplifiable <code>Self</code> type\" would be eager)</p>",
        "id": 205682167,
        "sender_full_name": "eddyb",
        "timestamp": 1596289650
    },
    {
        "content": "<p>plus blanket impls, sure, I guess -- so impls in the two crates, the one declaring the trait and the one defining the self type</p>",
        "id": 205682221,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289689
    },
    {
        "content": "<p>impls pattern-match. you can't assume stuff like that</p>",
        "id": 205682225,
        "sender_full_name": "eddyb",
        "timestamp": 1596289707
    },
    {
        "content": "<p>maybe I should use examples?</p>",
        "id": 205682232,
        "sender_full_name": "eddyb",
        "timestamp": 1596289714
    },
    {
        "content": "<p><code>impl From&lt;MyType&gt; for ExternalType</code> is a thing IIRC</p>",
        "id": 205682235,
        "sender_full_name": "eddyb",
        "timestamp": 1596289740
    },
    {
        "content": "<p>you can't trivially rely on coherence rules to simplify this</p>",
        "id": 205682245,
        "sender_full_name": "eddyb",
        "timestamp": 1596289758
    },
    {
        "content": "<p>at best you look for \"<code>Bar: Copy</code>\" impls in all crates instead of \"<code>_: Copy</code>\" impls</p>",
        "id": 205682246,
        "sender_full_name": "eddyb",
        "timestamp": 1596289782
    },
    {
        "content": "<p>or you special-case traits without extra generics, maybe there the coherence is simple enough?</p>",
        "id": 205682295,
        "sender_full_name": "eddyb",
        "timestamp": 1596289811
    },
    {
        "content": "<p>I guess</p>",
        "id": 205682300,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289822
    },
    {
        "content": "<p>Yeah, that's a good point</p>",
        "id": 205682304,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289828
    },
    {
        "content": "<p>you still have tuples in <code>Self</code> so you need to make sure all of those are treated as blanket impls</p>",
        "id": 205682306,
        "sender_full_name": "eddyb",
        "timestamp": 1596289833
    },
    {
        "content": "<p>and blanket impls need to be loaded from the entire crate graph. maybe it's the wrong term but it's the one used in the code</p>",
        "id": 205682314,
        "sender_full_name": "eddyb",
        "timestamp": 1596289853
    },
    {
        "content": "<p>\"blanket impl\" here doesn't mean 100% generic, it means \"cannot be easily simplified\"</p>",
        "id": 205682327,
        "sender_full_name": "eddyb",
        "timestamp": 1596289873
    },
    {
        "content": "<p>sure</p>",
        "id": 205682338,
        "sender_full_name": "simulacrum",
        "timestamp": 1596289901
    },
    {
        "content": "<p>it could very well have 0 generic parameters and be in some random crate</p>",
        "id": 205682339,
        "sender_full_name": "eddyb",
        "timestamp": 1596289902
    },
    {
        "content": "<p>so yeah the name is bad :P</p>",
        "id": 205682344,
        "sender_full_name": "eddyb",
        "timestamp": 1596289914
    },
    {
        "content": "<p>I started on writing a query for this l</p>",
        "id": 205682731,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596290469
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> can you take a look at <a href=\"https://github.com/rust-lang/rust/pull/74489\">https://github.com/rust-lang/rust/pull/74489</a> ?</p>",
        "id": 205682744,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596290509
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> can you sort it out with <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ?</p>",
        "id": 205682810,
        "sender_full_name": "eddyb",
        "timestamp": 1596290562
    },
    {
        "content": "<p>Sure</p>",
        "id": 205682822,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596290581
    },
    {
        "content": "<p>I'm not sure my implementation actually does what you want, it still loads every crate to look at the impls</p>",
        "id": 205682834,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596290603
    },
    {
        "content": "<p>the only reason I made my own PR was that it only took me a bit, I really can't get too dragged into much else</p>",
        "id": 205682836,
        "sender_full_name": "eddyb",
        "timestamp": 1596290605
    },
    {
        "content": "<p>it looks like you're \"transposing\" the trait vs implementor indexing, in a way that doesn't seem like the trait system would need/want to use (because we already have one, or a small number of, traits we look at)</p>",
        "id": 205682937,
        "sender_full_name": "eddyb",
        "timestamp": 1596290731
    },
    {
        "content": "<p>suggestions and rustdoc are the places I can think of that ever want anything related to the entire set of traits in the crate graph</p>",
        "id": 205682952,
        "sender_full_name": "eddyb",
        "timestamp": 1596290761
    },
    {
        "content": "<p>not to mention that if you compute this in a crate and store in the crate metadata, it will be wrong as it will not include downstream impls</p>",
        "id": 205683000,
        "sender_full_name": "eddyb",
        "timestamp": 1596290790
    },
    {
        "content": "<p>anyway that's my quick look</p>",
        "id": 205683003,
        "sender_full_name": "eddyb",
        "timestamp": 1596290802
    },
    {
        "content": "<p><em>wow</em>, <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> you should see these perf results for your PR <a href=\"https://perf.rust-lang.org/compare.html?start=dfe1e3b641abbede6230e3931d14f0d43e5b8e54&amp;end=128201b46cdfa059217962ae2f159583e0ae5f93\">https://perf.rust-lang.org/compare.html?start=dfe1e3b641abbede6230e3931d14f0d43e5b8e54&amp;end=128201b46cdfa059217962ae2f159583e0ae5f93</a></p>",
        "id": 205695574,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596311242
    },
    {
        "content": "<p>it's like -20% on hello world and -5% for a good number of others</p>",
        "id": 205695575,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1596311266
    },
    {
        "content": "<p>that's a bit much</p>",
        "id": 205695690,
        "sender_full_name": "eddyb",
        "timestamp": 1596311486
    },
    {
        "content": "<p><em>surely</em> deserializing a few types here and there shouldn't be <em>that</em> more expensive</p>",
        "id": 205695692,
        "sender_full_name": "eddyb",
        "timestamp": 1596311501
    },
    {
        "content": "<p>we must be doing a few things wrong. or suboptimally, rather</p>",
        "id": 205695693,
        "sender_full_name": "eddyb",
        "timestamp": 1596311512
    },
    {
        "content": "<p>ripgrep is I think the \"realistic project\" benchmark with the biggest win, and it's still surprisingly large</p>",
        "id": 205695747,
        "sender_full_name": "eddyb",
        "timestamp": 1596311596
    },
    {
        "content": "<p>anyway this is what happens when you profile :P (<span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> in this case)</p>",
        "id": 205695750,
        "sender_full_name": "eddyb",
        "timestamp": 1596311611
    },
    {
        "content": "<p>why do we decode <code>item_attrs</code>??</p>",
        "id": 205695783,
        "sender_full_name": "eddyb",
        "timestamp": 1596311643
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> oh god is this some cursed thing about <code>ty::AdtDef</code> needing to exist for <code>ty::Adt</code> (as opposed to just having a <code>DefId</code>) therefore kilobytes of doc comments getting loaded?</p>",
        "id": 205695801,
        "sender_full_name": "eddyb",
        "timestamp": 1596311690
    },
    {
        "content": "<p>I'm looking <a href=\"https://perf.rust-lang.org/detailed-query.html?commit=128201b46cdfa059217962ae2f159583e0ae5f93&amp;base_commit=dfe1e3b641abbede6230e3931d14f0d43e5b8e54&amp;benchmark=ripgrep-check&amp;run_name=incr-patched:%20println\">at these query details</a></p>",
        "id": 205695809,
        "sender_full_name": "eddyb",
        "timestamp": 1596311722
    },
    {
        "content": "<p>helloworld <a href=\"https://perf.rust-lang.org/detailed-query.html?commit=128201b46cdfa059217962ae2f159583e0ae5f93&amp;base_commit=dfe1e3b641abbede6230e3931d14f0d43e5b8e54&amp;benchmark=helloworld-check&amp;run_name=incr-full\">tells a similar story</a></p>",
        "id": 205695817,
        "sender_full_name": "eddyb",
        "timestamp": 1596311743
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I removed an item attrs call for non exhaustive recently, that was a small win too.</p>\n<p>I suspect we should work to either make decoding attributes much faster or work to eliminate it entirely, it really shouldn't be necessary I think - we should be able to place already decoded attributes in metadata</p>",
        "id": 205701337,
        "sender_full_name": "simulacrum",
        "timestamp": 1596321993
    },
    {
        "content": "<p>Cc <span class=\"user-mention\" data-user-id=\"120989\">@njn</span> it looks like <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>'s PR may be eliminating all of the gimli regressions (plus some more wins)</p>",
        "id": 205701346,
        "sender_full_name": "simulacrum",
        "timestamp": 1596322047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I've been wanting to experiment with replacing <code>AdtDef</code> with just a <code>DefId</code> in the type variant</p>",
        "id": 205813109,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596470867
    },
    {
        "content": "<p>just to make it more analogous with most things</p>",
        "id": 205813174,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596470888
    },
    {
        "content": "<p>no idea if it would have perf impact though</p>",
        "id": 205813183,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1596470895
    },
    {
        "content": "<p>I'm worried there are things that rely on it being  cheap to access some information</p>",
        "id": 205819067,
        "sender_full_name": "eddyb",
        "timestamp": 1596473905
    },
    {
        "content": "<p>but I would prefer if that was a <code>DefId</code></p>",
        "id": 205819087,
        "sender_full_name": "eddyb",
        "timestamp": 1596473917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> btw you used backtraces but we could theoretically take two <code>-Zself-profile</code> outputs and get a diff <em>flamegraph</em> (or chrome profile), sadly I think we'd need two outputs, one that's \"added\" and one that's \"removed\" (cc <span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span>)</p>",
        "id": 206198615,
        "sender_full_name": "eddyb",
        "timestamp": 1596748927
    },
    {
        "content": "<p>in that we could see the <em>query call traces</em> being added, not just contextless query names and counts</p>",
        "id": 206198686,
        "sender_full_name": "eddyb",
        "timestamp": 1596748969
    },
    {
        "content": "<p>in fact we could have a one-level version of this (to limit the amount of data we need to keep) for the <a href=\"http://perf.rust-lang.org\">perf.rust-lang.org</a> UI</p>",
        "id": 206198732,
        "sender_full_name": "eddyb",
        "timestamp": 1596749005
    },
    {
        "content": "<p>so when we have a delta in the number of executions, we can show <em>what callers</em> they're from</p>",
        "id": 206198758,
        "sender_full_name": "eddyb",
        "timestamp": 1596749026
    },
    {
        "content": "<p>but with a manual run we can go <em>all the way</em> to recording query keys and just having an exact delta</p>",
        "id": 206199059,
        "sender_full_name": "eddyb",
        "timestamp": 1596749198
    },
    {
        "content": "<p>Yeah I'd be fine with that - backtraces are even more fine-grained of course</p>",
        "id": 206199063,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749201
    },
    {
        "content": "<p>To be honest I'm not worried about data storage, I'd be fine with however much data we need to store for perf.rlo</p>",
        "id": 206199098,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749230
    },
    {
        "content": "<p>It's more so cost of collection that's a concern</p>",
        "id": 206199112,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749239
    },
    {
        "content": "<p>But presumably it's not too bad</p>",
        "id": 206199116,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749245
    },
    {
        "content": "<p>oh. could we just keep the profile files? or are they too big</p>",
        "id": 206199131,
        "sender_full_name": "eddyb",
        "timestamp": 1596749259
    },
    {
        "content": "<p>I guess we do need to process them down otherwise rendering incurs the cost of loading them every time</p>",
        "id": 206199153,
        "sender_full_name": "eddyb",
        "timestamp": 1596749275
    },
    {
        "content": "<p>anyway the reason I say this is that all it took for me to make that PR was <code>trait_impls_of -&gt; type_of</code></p>",
        "id": 206199240,
        "sender_full_name": "eddyb",
        "timestamp": 1596749311
    },
    {
        "content": "<p>Are they self contained? I forget if we need the rustc binary around or anything</p>",
        "id": 206199247,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749317
    },
    {
        "content": "<p>and now we basically want to repeat for the next largest such edge</p>",
        "id": 206199264,
        "sender_full_name": "eddyb",
        "timestamp": 1596749325
    },
    {
        "content": "<p>If they're self contained we should probably just start putting them in s3</p>",
        "id": 206199271,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749342
    },
    {
        "content": "<p>no, the entire thing is a string templating machine</p>",
        "id": 206199275,
        "sender_full_name": "eddyb",
        "timestamp": 1596749345
    },
    {
        "content": "<p>like it's extremely self-contained, to a degree that almost starts bothering me but I guess strings are fine with that much of overengineering lol</p>",
        "id": 206199306,
        "sender_full_name": "eddyb",
        "timestamp": 1596749372
    },
    {
        "content": "<p>Okay so we can definitely just stick them in the database or s3</p>",
        "id": 206199332,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749390
    },
    {
        "content": "<p>(probably s3 is better)</p>",
        "id": 206199344,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749395
    },
    {
        "content": "<p>I can look at doing that today or tomorrow</p>",
        "id": 206199404,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749414
    },
    {
        "content": "<p>I don't think they're that big</p>",
        "id": 206199439,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749442
    },
    {
        "content": "<p>I wish I suggested this earlier, I thought the reason we weren't collecting was the size but never asked</p>",
        "id": 206199622,
        "sender_full_name": "eddyb",
        "timestamp": 1596749564
    },
    {
        "content": "<p>I forget - there was I think some concern about size at some point</p>",
        "id": 206199644,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749580
    },
    {
        "content": "<p>But more so because of bandwidth iirc and how long it took than the size itself</p>",
        "id": 206199678,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749598
    },
    {
        "content": "<p>Maybe we can compress? I'll look</p>",
        "id": 206199696,
        "sender_full_name": "simulacrum",
        "timestamp": 1596749610
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> we now save off the raw results into S3 and even have crox and flamegraph links on the self profile pages (e.g., see <a href=\"https://perf.rust-lang.org/detailed-query.html?commit=f3a9de9b08659e20ce7c282ed77bc43ddd149107&amp;benchmark=helloworld-opt&amp;run_name=full\">https://perf.rust-lang.org/detailed-query.html?commit=f3a9de9b08659e20ce7c282ed77bc43ddd149107&amp;benchmark=helloworld-opt&amp;run_name=full</a>)</p>",
        "id": 206328614,
        "sender_full_name": "simulacrum",
        "timestamp": 1596856330
    },
    {
        "content": "<p>not yet sure -- it's pretty slow to generate flamegraphs and crox files on-demand (which is what we currently do), so may need to cache those somehow (e.g., on first hit save them to S3 and serve from there)</p>",
        "id": 206328625,
        "sender_full_name": "simulacrum",
        "timestamp": 1596856370
    },
    {
        "content": "<p>maybe the measureme data format is not best, too, for long-term storage (cc <span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span>)</p>",
        "id": 206328631,
        "sender_full_name": "simulacrum",
        "timestamp": 1596856401
    },
    {
        "content": "<p>wow</p>",
        "id": 206335118,
        "sender_full_name": "eddyb",
        "timestamp": 1596868580
    }
]