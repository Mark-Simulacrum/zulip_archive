[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116113\">@lqd</span> what's your plan for analyzing <a href=\"https://github.com/lqd/rustc-benchmarking-data\">https://github.com/lqd/rustc-benchmarking-data</a>? It looks like it might have some interesting insights, but I'm not sure what the most helpful place for me to begin is.</p>",
        "id": 272252452,
        "sender_full_name": "rylev",
        "timestamp": 1645101389
    },
    {
        "content": "<p>I don’t have a firm plan in mind already, so any help, advice and insight would be appreciated. </p>\n<p>Nick and I have begun doing some analysis, mostly in an ad hoc way; and apart from doing more of that, and investigating the things these early analyses have surfaced, there were no systematic plans yet (if such a thing is actually required, it may be the case that the ad hoc way could be enough).  </p>\n<p>For example, some summaries of the memory consumption swings in the time-passes data (per pass/activity to see if there are huge outliers sometimes, which we expect for some crates with big cfgs or needing big dataflow data, etc) could be interesting,  I didn’t have the time to look at that yet and planned on doing so when Im back next week.</p>",
        "id": 272259554,
        "sender_full_name": "lqd",
        "timestamp": 1645105145
    },
    {
        "content": "<p>would doing the same run on an older rustc make sense to see if there are any regressions that haven't been caught/reported?</p>",
        "id": 272274172,
        "sender_full_name": "The 8472",
        "timestamp": 1645111032
    },
    {
        "content": "<p>There surely are regressions that we missed indeed, just like we missed the projection caching ones, some of the deferred inlining with NewPM, etc. </p>\n<p>It would be interesting to find out. Probably harder to find other than the easy to notice outliers, but even only that could be worthwhile.</p>\n<p>Some of these runs are quick to do, so if you want to see something in particular I can collect the data for you easily.</p>",
        "id": 272281313,
        "sender_full_name": "lqd",
        "timestamp": 1645113827
    },
    {
        "content": "<p>I am partway through analyzing the data, and I am using it as one input for the <a href=\"https://hackmd.io/YJQSj_nLSZWl2sbI84R1qA\">draft roadmap</a>.</p>",
        "id": 272323972,
        "sender_full_name": "nnethercote",
        "timestamp": 1645132780
    },
    {
        "content": "<p>I'm hoping to have a complete draft of the roadmap by the middle or end of next week.</p>",
        "id": 272323995,
        "sender_full_name": "nnethercote",
        "timestamp": 1645132800
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> has added a couple of items, which are good.</p>",
        "id": 272324041,
        "sender_full_name": "nnethercote",
        "timestamp": 1645132808
    },
    {
        "content": "<p>My data analysis is just sitting on my laptop at the moment, I need to decide where to put it. In a file(s) in lqd's repo? In a HackMD document? Somewhere else?</p>",
        "id": 272324098,
        "sender_full_name": "nnethercote",
        "timestamp": 1645132843
    },
    {
        "content": "<p>Once the draft roadmap is complete (or earlier) it would be good for everyone here to look over it, we can get some consensus and hopefully even assign some tasks. lqd and I are both working more or less full-time on compiler perf for the next few months, so we have some people power</p>",
        "id": 272324223,
        "sender_full_name": "nnethercote",
        "timestamp": 1645132914
    },
    {
        "content": "<p>I think a repo might be a good place</p>",
        "id": 272324452,
        "sender_full_name": "pnkfelix",
        "timestamp": 1645133030
    },
    {
        "content": "<p>in particular, that allows for the structure of filing individual issues, which can then be made very easy to cross-reference (especially if we add sugar to zulip for the repo)</p>",
        "id": 272324537,
        "sender_full_name": "pnkfelix",
        "timestamp": 1645133064
    },
    {
        "content": "<p>but this all depends on how much you expect there to be <em>branching</em> investigations that deserve tree structured form and separate cross referencing</p>",
        "id": 272324633,
        "sender_full_name": "pnkfelix",
        "timestamp": 1645133118
    },
    {
        "content": "<p>Feels a bit like overkill, TBH</p>",
        "id": 272329678,
        "sender_full_name": "nnethercote",
        "timestamp": 1645134856
    },
    {
        "content": "<p>Though maybe I'm an optimist</p>",
        "id": 272329697,
        "sender_full_name": "nnethercote",
        "timestamp": 1645134864
    },
    {
        "content": "<blockquote>\n<p>Reduce allocations. Try to optimize the compilation of crates with the hottest allocation points and highest peak memory usage, as identified by DHAT in lqd’s data set.</p>\n</blockquote>\n<p>I don't know if this fits here but it might be worth looking into using a string type with small-string-optimization in more places in the compiler. E.g. <a href=\"https://crates.io/crates/flexible-string\">https://crates.io/crates/flexible-string</a>.</p>",
        "id": 272390125,
        "sender_full_name": "mw",
        "timestamp": 1645183655
    },
    {
        "content": "<p>Also, I have a well-optimized version of <a href=\"https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html\">XXH3</a> lying around that might be a great fit for replacing SipHash for stable hashing. My local results showed it to speed up the compiler by a couple of percent (good but not spectacular). I don't really have time to pursue this further but I'd be happy to hand it off. I think the main problem to solve is working out how licensing works since my implementation is based on the reference C implementation which is under a BSD license (but we can only easily use Apache or MIT).</p>",
        "id": 272390968,
        "sender_full_name": "mw",
        "timestamp": 1645184173
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> I was experimenting with stable hashing recently, I would be interested in trying this and following up with your work if you want. I tried to replace the siphasher with the stock xxhash-rust crate, that resulted in a loss of 5-15 % icount locally.</p>",
        "id": 272444013,
        "sender_full_name": "Jakub Beránek",
        "timestamp": 1645211444
    },
    {
        "content": "<p>I'm not sure we can use xxh as a hasher: <a href=\"https://github.com/rust-lang/rust/pull/85092#issuecomment-1030811014\">https://github.com/rust-lang/rust/pull/85092#issuecomment-1030811014</a></p>",
        "id": 272449323,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214229
    },
    {
        "content": "<p>If collisions aren't as bad as that indicates, wyhash (<a href=\"https://github.com/wangyi-fudan/wyhash\">https://github.com/wangyi-fudan/wyhash</a>) does well with much less code than xx, and is unlicensed, so perhaps its more usable.</p>",
        "id": 272450255,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214422
    },
    {
        "content": "<p>in practice xxhash is tricky to use directly since its streaming api assumes the use case is very heavyweight, and rust's hashing assumes always using the streaming api is okay</p>",
        "id": 272450365,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1645214477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Analyzing.20lqd.2Frustc-benchmarking-data/near/272450255\">said</a>:</p>\n<blockquote>\n<p>If collisions aren't as bad as that indicates, wyhash (<a href=\"https://github.com/wangyi-fudan/wyhash\">https://github.com/wangyi-fudan/wyhash</a>) does well with much less code than xx, and is unlicensed, so perhaps its more usable.</p>\n</blockquote>\n<p>The \"unlicense\" is still something whose license terms need recording. And there are folks (not common, but not rare) who reject the unlicense if not dual-licensed with some other license.</p>",
        "id": 272457549,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645218447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Analyzing.20lqd.2Frustc-benchmarking-data/near/272390125\">said</a>:</p>\n<blockquote>\n<p>I don't know if this fits here but it might be worth looking into using a string type with small-string-optimization in more places in the compiler. E.g. <a href=\"https://crates.io/crates/flexible-string\">https://crates.io/crates/flexible-string</a>.</p>\n</blockquote>\n<p>TBH, in all the memory profiling I've done (which is quite a bit) strings are rarely a problem. <code>Vec</code> to <code>SmallVec</code> conversions are frequently useful, in contrast.</p>",
        "id": 272488899,
        "sender_full_name": "nnethercote",
        "timestamp": 1645241142
    },
    {
        "content": "<p>But I'll keep it in mind <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 272488911,
        "sender_full_name": "nnethercote",
        "timestamp": 1645241158
    },
    {
        "content": "<p>Yeah, of course, let's keep it data driven. It's just something I came across quite a bit when refactoring the debuginfo module where we generate lots of short strings, let LLVM make a copy of them, and then immediately discard them.</p>",
        "id": 272522393,
        "sender_full_name": "mw",
        "timestamp": 1645282083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Analyzing.20lqd.2Frustc-benchmarking-data/near/272449323\">said</a>:</p>\n<blockquote>\n<p>I'm not sure we can use xxh as a hasher: <a href=\"https://github.com/rust-lang/rust/pull/85092#issuecomment-1030811014\">https://github.com/rust-lang/rust/pull/85092#issuecomment-1030811014</a></p>\n</blockquote>\n<p>I don't quite agree with the <span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span>'s assessment in that comment. We use stable hashing for <a href=\"https://en.wikipedia.org/wiki/Fingerprint_(computing)\">fingerprinting</a> which doesn't require cryptographic security. The current algorithm (SipHash) isn't a cryptographic hash function either. I'd say that if XXH3 is problematic then SipHash would be just as problematic and we'd need to switch to something like BLAKE3.</p>",
        "id": 272522717,
        "sender_full_name": "mw",
        "timestamp": 1645282546
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"266526\">Jakub Beránek</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Analyzing.20lqd.2Frustc-benchmarking-data/near/272444013\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> I was experimenting with stable hashing recently, I would be interested in trying this and following up with your work if you want. I tried to replace the siphasher with the stock xxhash-rust crate, that resulted in a loss of 5-15 % icount locally.</p>\n</blockquote>\n<p>I spent a few days on optimizing my implementation specifically for how it is being used in rustc (it was a spare time project during the holidays at the end of last year). In my micro-benchmarks it is around twice as fast as the compiler's SipHash implementation and three times as fast as the twox-hash crate. (Note that these are just micro-benchmarks for raw hashing speed). Anyway, I'll just try to clean up my code and put it into a public GH repo under the original license and then others can take a look if it is useful and how the licensing questions can be resolved. I'll open a new topic here once the code is up.</p>",
        "id": 272523694,
        "sender_full_name": "mw",
        "timestamp": 1645283567
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Analyzing.20lqd.2Frustc-benchmarking-data/near/272522717\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Analyzing.20lqd.2Frustc-benchmarking-data/near/272449323\">said</a>:</p>\n<blockquote>\n<p>I'm not sure we can use xxh as a hasher: <a href=\"https://github.com/rust-lang/rust/pull/85092#issuecomment-1030811014\">https://github.com/rust-lang/rust/pull/85092#issuecomment-1030811014</a></p>\n</blockquote>\n<p>I don't quite agree with the <span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span>'s assessment in that comment. We use stable hashing for <a href=\"https://en.wikipedia.org/wiki/Fingerprint_(computing)\">fingerprinting</a> which doesn't require cryptographic security. The current algorithm (SipHash) isn't a cryptographic hash function either. I'd say that if XXH3 is problematic then SipHash would be just as problematic and we'd need to switch to something like BLAKE3.</p>\n</blockquote>\n<p>According to wikipedia SipHash is designed to be secure for as long as the key is secret. While in case of rustc the key is known, this implies that it is highly unlikely to get a hash collision by chance, unlike for XXH3 which is optimized for speed over security afaik. It is the getting a hash collision by chance that I am mostly worried about, although deliberately forcing a hash collision can be used as obfuscation method. This is somewhat mitigated by the fact that the input to most hashes changes depending on the full rustc version (including commit) which isn't predictable for future releases, thus breaking the code if it relies upon the hash collision.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/SipHash\">https://en.wikipedia.org/wiki/SipHash</a></p>\n<blockquote>\n<p>Although designed for use as a hash function to ensure security, SipHash is fundamentally different from cryptographic hash functions like SHA in that it is only suitable as a message authentication code: a keyed hash function like HMAC. That is, SHA is designed so that it is difficult for an attacker to find two messages X and Y such that SHA(X) = SHA(Y), even though anyone may compute SHA(X). SipHash instead guarantees that, having seen Xi and SipHash(Xi, k), an attacker who does not know the key k cannot find (any information about) k or SipHash(Y, k) for any message Y ∉ {Xi} which they have not seen before.</p>\n</blockquote>",
        "id": 272528546,
        "sender_full_name": "bjorn3",
        "timestamp": 1645289172
    },
    {
        "content": "<p>Preimage attack resistance is easier to obtain than collision resistance. Possibly even more so when the preimage resistance relies on the key being secret. So it being designed to be secure for that use doesn't tell us how secure it is against collisions.</p>",
        "id": 272528768,
        "sender_full_name": "The 8472",
        "timestamp": 1645289496
    },
    {
        "content": "<p>E.g. there still is no practical preimage-attack against MD5 even though its broken wrt. collisions.</p>",
        "id": 272528842,
        "sender_full_name": "The 8472",
        "timestamp": 1645289558
    },
    {
        "content": "<p>Wikipedia says that if you have a set of inputs and their hashes you can't easily find some input which hashes to any (not just a specific) of the other hashes. That is collision resistance, right? SipHash has to have collision resistance to prevent hashdos, right?</p>",
        "id": 272528988,
        "sender_full_name": "bjorn3",
        "timestamp": 1645289757
    },
    {
        "content": "<p>Yeah, makes sense.</p>",
        "id": 272530110,
        "sender_full_name": "The 8472",
        "timestamp": 1645290866
    },
    {
        "content": "<p>I'd also want to avoid the false impression that switching stable hashing to a cryptographically secure hash would somehow magically make the compiler (or incr. comp.) secure in general. As far as I'm aware, the compiler is not hardened against attacks at all (whatever that might look like). A cryptographically secure hash for stable hashing might be part of such hardening but it would probably only be a small part of the puzzle.</p>",
        "id": 272670839,
        "sender_full_name": "mw",
        "timestamp": 1645440192
    },
    {
        "content": "<p>it will be good to understand/document (that's probably already been done) the properties we're looking for, e.g. \"a low probability of collisions is important for correctness in incr comp data, more so than security and resilience against attacks\", what data we're fingerprinting, and compare with the other hashing algorithms. it seems safe to say fxhash is a no go but maybe umash's fingerprints could work, or mw's xxh3 implementation of course</p>",
        "id": 272680100,
        "sender_full_name": "lqd",
        "timestamp": 1645445621
    },
    {
        "content": "<p>umash fingerprints look really interesting! Having a proven collision probability would be of great value for incr. comp. I'd love to see how it performs.</p>",
        "id": 272681196,
        "sender_full_name": "mw",
        "timestamp": 1645446231
    },
    {
        "content": "<p>I don’t know how feasible/easy/generally useful it would be, but I’ve always wanted to make my crates easier to be used by tools like this.</p>\n<p>If there were some way I could see which of <em>my</em> crates were attempted and failed and hints on how to fix them, it’d be great. </p>\n<p>I’ve wanted the same for crater, but I don’t think it exists there.</p>",
        "id": 273223046,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645792467
    },
    {
        "content": "<p>for <code>twox-hash</code> in particular you mean ? I'll eventually add it and the similar ones later, they didn't fail per se: only require manual work to be integrated into the existing collector benchmarks</p>",
        "id": 273223374,
        "sender_full_name": "lqd",
        "timestamp": 1645792709
    },
    {
        "content": "<p>It's kind of multifaceted. I actually don't remember all the names of my crates <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span> </p>\n<p>My ideal workflow (here and crater) would be a link for \"see all results for &lt;username&gt;s crates\" and then a list of \"this is used\" / \"this is not used for this reason\"</p>",
        "id": 273238792,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645800898
    },
    {
        "content": "<p>so I did notice twox-hash missing, but I also wonder what other crates of mine might be problematic</p>",
        "id": 273238839,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645800931
    },
    {
        "content": "<p>But it's certainly not as important as actually making improvements based on the data</p>",
        "id": 273238958,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645800973
    },
    {
        "content": "<p>just trying to make it more self-serve so I (and other crate owners, ideally) can help you help us</p>",
        "id": 273239017,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645801011
    },
    {
        "content": "<p>FYI, you can find my XXH3 port here now: <a href=\"https://github.com/michaelwoerister/xxh3-port\">https://github.com/michaelwoerister/xxh3-port</a>. It seems to be faster than twox-hash for the streaming case, especially when only hashing small amounts of data before throwing the state away again (which is what I tried to optimize it for). I won't be able to spend much time on it but maybe it's useful.</p>",
        "id": 273349818,
        "sender_full_name": "mw",
        "timestamp": 1645892886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> to clarify, you mean twox-hashes xxh3 implementation, right? That was contributed by someone else and I haven’t had time to truly review it for performance concerns, sadly.</p>",
        "id": 273356345,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645901359
    },
    {
        "content": "<p>@lqd: publicizing your data collection is already having benefits: <a href=\"https://github.com/serde-rs/serde/issues/2181\">https://github.com/serde-rs/serde/issues/2181</a></p>",
        "id": 273360203,
        "sender_full_name": "nnethercote",
        "timestamp": 1645905857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Analyzing.20lqd.2Frustc-benchmarking-data/near/273356345\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> to clarify, you mean twox-hashes xxh3 implementation, right? That was contributed by someone else and I haven’t had time to truly review it for performance concerns, sadly.</p>\n</blockquote>\n<p>Yes, that's correct. But please don't interpret this as a dig at the twox-hash crate. I mostly mention it because it was being used in the <a href=\"https://github.com/rust-lang/rust/pull/85092\">benchmarks</a> mentioned above. In fact, I would prefer it if rustc did not have its own implementation of xxh3 (or any other fingerprinting algorithm). If you can make use of my implementation in twox-hash, please feel free to do so. Just be aware that (1) it's a pretty straightforward port of the C version and thus wouldn't exactly win a beauty contest, (2) it's not entirely complete (e.g. 32-bit hashing is not implemented), and (3) being based on the BSD licensed C version, it is also BSD licensed (whereas twox-hash seems to be under MIT license).</p>",
        "id": 273360656,
        "sender_full_name": "mw",
        "timestamp": 1645906453
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116113\">@lqd</span> <span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Do you have your analyses published somewhere? I would be interested in helping with this if I can :)</p>",
        "id": 273493032,
        "sender_full_name": "Michael Wigard",
        "timestamp": 1646057076
    },
    {
        "content": "<p>Great! </p>\n<p>There are some analyses in <a href=\"https://github.com/lqd/rustc-benchmarking-data/tree/main/summaries\">the repo</a> mostly automated summaries. <br>\nA more comprehensive analysis was done by nick <a href=\"https://hackmd.io/mxdn4U58Su-UQXwzOHpHag?view\">here</a>. </p>\n<p>And this all informed a roadmap of sorts, which can be found <a href=\"https://hackmd.io/YJQSj_nLSZWl2sbI84R1qA?view\">here</a> if anything in there is of interest to you, for example.</p>",
        "id": 273495694,
        "sender_full_name": "lqd",
        "timestamp": 1646058092
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481680\">@Michael Wigard</span> I saw you submitted your first PR to rustc-perf recently, that's a good start <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 273547347,
        "sender_full_name": "nnethercote",
        "timestamp": 1646079326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Yeah, I'm still reading and familiarizing myself with the terrain, trying to find out what I can help with, just wanted to fix a small annoyance I encountered along the path <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 273548313,
        "sender_full_name": "Michael Wigard",
        "timestamp": 1646079854
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481680\">@Michael Wigard</span> No problem with starting small <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  Do you have any idea what you might be interested to work on? I can try to make some suggestions if you can give me a rough idea of your experience and background</p>",
        "id": 273568909,
        "sender_full_name": "nnethercote",
        "timestamp": 1646090488
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> I've been learning Rust for a year now but have plenty of experience in other languages. My academic background is in physics, so I have some knowledge in statistics and data analysis - the <a href=\"https://blog.rust-lang.org/inside-rust/2022/02/22/compiler-team-ambitions-2022.html#performance-dashboard\">compiler ambitions blogpost</a> led me here.</p>",
        "id": 273569887,
        "sender_full_name": "Michael Wigard",
        "timestamp": 1646091122
    },
    {
        "content": "<p>Good to know. Are there any items in the analysis or roadmap that @lqd linked to above that catch your eye?</p>",
        "id": 273570798,
        "sender_full_name": "nnethercote",
        "timestamp": 1646091804
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> UX improvements for the perf site seems like reasonably low hanging fruit... Do you have the code for your analysis posted somewhere? I'm assuming you didn't compile those statistics by hand...</p>",
        "id": 273645301,
        "sender_full_name": "Michael Wigard",
        "timestamp": 1646143557
    },
    {
        "content": "<p>I have submitted an <a href=\"https://github.com/rust-lang/rustc-perf/issues/1187\">issue</a> about the performance of the perf site itself: I think enabling gzip on responses should be an easy win, but I'm inclined to dig deeper and see if site performance could be improved further, (e.g. by allowing some responses to be cached) if you think that would be worthwhile</p>",
        "id": 273650878,
        "sender_full_name": "Michael Wigard",
        "timestamp": 1646145906
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481680\">@Michael Wigard</span> perf tests are now using test significance analysis to detect potentially relevant changes, but I think that some <strong>effect size</strong> analysis would be very useful too. Iirc <span class=\"user-mention\" data-user-id=\"224872\">@rylev</span> was looking for something like it. As you have statistical background, I'm sure you can be off great help there.</p>",
        "id": 273659961,
        "sender_full_name": "pachi",
        "timestamp": 1646149360
    },
    {
        "content": "<p>That would help tagging which tests have significant changes with a big enough effect size, and would reduce manual triaging</p>",
        "id": 273660222,
        "sender_full_name": "pachi",
        "timestamp": 1646149457
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"481680\">@Michael Wigard</span> Indeed, after thinking about it for a bit I think your data science experience could be very useful with the rustc-perf site: presentation and analysis of the runs. I don't have much in the way of specifics, but some additional thought and rigor could be very helpful.</p>",
        "id": 273697792,
        "sender_full_name": "nnethercote",
        "timestamp": 1646163236
    },
    {
        "content": "<p>As for the analysis code, it's not public. It was bunch of quick and dirty semi-automated stuff, no scripts you can run, though I generally wrote down rough notes for what I did. Lots of:</p>\n<ul>\n<li>grepping to pull out lines of interest from the many profiles</li>\n<li>then regexp search-and-replaces to move data on each line around and/or remove uninteresting parts of the lines</li>\n<li>then sometimes using <a href=\"https://github.com/nnethercote/counts/\">counts</a> to identify the most important things</li>\n</ul>\n<p>I could dredge up the exact details if there are specific tables you want to know about</p>",
        "id": 273698233,
        "sender_full_name": "nnethercote",
        "timestamp": 1646163437
    }
]