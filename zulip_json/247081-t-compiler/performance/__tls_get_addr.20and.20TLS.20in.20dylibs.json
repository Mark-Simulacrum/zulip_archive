[
    {
        "content": "<p>heh the top 6 functions (and their counts) in the 13GB <code>ltrace -l '*'</code> output are:</p>\n<div class=\"codehilite\"><pre><span></span><code>25041736 __tls_get_addr\n   1259 pthread_once\n   1074 malloc\n    483 pthread_rwlock_wrlock\n    483 pthread_rwlock_unlock\n     11 calloc\n</code></pre></div>",
        "id": 213971232,
        "sender_full_name": "eddyb",
        "timestamp": 1603223643
    },
    {
        "content": "<p>so I think the reason it took so long and produced so much output is it traced <code>__tls_get_addr</code></p>",
        "id": 213971311,
        "sender_full_name": "eddyb",
        "timestamp": 1603223687
    },
    {
        "content": "<p>Hmm, didn't <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> have a post about how <code>thread_local!</code>'s API required it to be slow? I wonder if we could improve that in rustc somehow</p>",
        "id": 213972350,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1603224196
    },
    {
        "content": "<p>the problem is dylibs are bad</p>",
        "id": 213972370,
        "sender_full_name": "eddyb",
        "timestamp": 1603224209
    },
    {
        "content": "<p>Dylibs force a slower implementation of tls</p>",
        "id": 213972486,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224258
    },
    {
        "content": "<p>AFAIK <code>thread_local!</code> just uses <code>#[thread_local]</code> under the hood, which presumably LLVM generates <code>__tls_get_addr</code> calls for</p>",
        "id": 213972498,
        "sender_full_name": "eddyb",
        "timestamp": 1603224265
    },
    {
        "content": "<p>For executables it is possible to directly offset from a pointer stored at %fs, but for dylibs the offset is not known, so you have to call __tls_get_addr.</p>",
        "id": 213972570,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224316
    },
    {
        "content": "<p>we don't need dylibs for <code>rustc</code>, we just need \"shared objects\" for deduplication. but idk if existing toolchains even allow statically linking <code>.so</code>s</p>",
        "id": 213972577,
        "sender_full_name": "eddyb",
        "timestamp": 1603224319
    },
    {
        "content": "<p>How would that work with loading compiler plugins/codegen backends that link against rustc_driver?</p>",
        "id": 213972715,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224381
    },
    {
        "content": "<p>they would be dynamically loaded libraries, but if they accessed some TLS defined in <code>librustc_driver.so</code> they'd be accessing that via a statically computed offset</p>",
        "id": 213972847,
        "sender_full_name": "eddyb",
        "timestamp": 1603224456
    },
    {
        "content": "<p>though I wonder if you can link both libc and such a weird <code>.so</code>. anyway, it's theoretically possible, practically it's probably unlikely</p>",
        "id": 213972957,
        "sender_full_name": "eddyb",
        "timestamp": 1603224512
    },
    {
        "content": "<p>and I suppose you couldn't have two... waaaait a minute</p>",
        "id": 213973021,
        "sender_full_name": "eddyb",
        "timestamp": 1603224555
    },
    {
        "content": "<p>That could only work if you can guarantee that a single such dylib is linked into a process</p>",
        "id": 213973044,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> why isn't this all done with relocations, like GOT &amp; friends?</p>",
        "id": 213973046,
        "sender_full_name": "eddyb",
        "timestamp": 1603224567
    },
    {
        "content": "<p>why does it have to involve a function call</p>",
        "id": 213973072,
        "sender_full_name": "eddyb",
        "timestamp": 1603224577
    },
    {
        "content": "<p>The TLS storage for dylibs is lazily created for each thread when necessary I believe.</p>",
        "id": 213973196,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224618
    },
    {
        "content": "<p>The offset can thus differ between threads in the same process.</p>",
        "id": 213973220,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224641
    },
    {
        "content": "<p>see, that we definitely don't need :(</p>",
        "id": 213973288,
        "sender_full_name": "eddyb",
        "timestamp": 1603224675
    },
    {
        "content": "<p>There isn't much of a choice as threads may already exist and multiple threads may load a new dylib at the same time.</p>",
        "id": 213973395,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224726
    },
    {
        "content": "<p>right, I don't want <code>librustc_driver.so</code> to be dynamically loadable</p>",
        "id": 213973436,
        "sender_full_name": "eddyb",
        "timestamp": 1603224749
    },
    {
        "content": "<p>I wonder if any of these are relevant <a href=\"https://llvm.org/docs/LangRef.html#thread-local-storage-models\">https://llvm.org/docs/LangRef.html#thread-local-storage-models</a></p>",
        "id": 213973519,
        "sender_full_name": "eddyb",
        "timestamp": 1603224804
    },
    {
        "content": "<p>It should technically be possible to roll our own tls implementation specifically for rustc, though the question would then be where to store the tls pointer when %fs is already uses.</p>",
        "id": 213973549,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224828
    },
    {
        "content": "<p>I mean we can just statically allocate the right amount of space in every executable that links to <code>librustc_driver.so</code></p>",
        "id": 213973666,
        "sender_full_name": "eddyb",
        "timestamp": 1603224885
    },
    {
        "content": "<p>and then put the offset in a weak symbol or something</p>",
        "id": 213973678,
        "sender_full_name": "eddyb",
        "timestamp": 1603224895
    },
    {
        "content": "<p>Yes those storage models are relevant. The linker tries to change the tls storage model to the fastest possible way. In fact it required the tls access to have a specific sequence of instructions including padding prefixes to be able to rewrite it for the chosen storage model.</p>",
        "id": 213973726,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224920
    },
    {
        "content": "<p>If we depend on the libc tls implementation then the offset can differ between threads. If we don't, where do we store the thread specific pointer?</p>",
        "id": 213973869,
        "sender_full_name": "bjorn3",
        "timestamp": 1603224986
    },
    {
        "content": "<p>anyway this doesn't matter much, I just need to avoid tracing <code>__tls_get_addr</code> if I use <code>ltrace</code> again</p>",
        "id": 213973900,
        "sender_full_name": "eddyb",
        "timestamp": 1603225002
    },
    {
        "content": "<p>Every query accesses the TLS I think, so improvements to the TLS implementation can have a relatively big effect.</p>",
        "id": 213973998,
        "sender_full_name": "bjorn3",
        "timestamp": 1603225052
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> no, I mean we rely on the executable TLS which has the same offset across all threads</p>",
        "id": 213974001,
        "sender_full_name": "eddyb",
        "timestamp": 1603225053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/hardware.20counter.20(rdpmc).20measurements/near/213973998\">said</a>:</p>\n<blockquote>\n<p>Every query accesses the TLS I think, so improvements to the TLS implementation can have a relatively big effect.</p>\n</blockquote>\n<p>I'll open an issue so we don't forget</p>",
        "id": 213974112,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1603225095
    },
    {
        "content": "<p>and then we inject that into the dylib somehow. could even be something we do at runtime</p>",
        "id": 213974118,
        "sender_full_name": "eddyb",
        "timestamp": 1603225097
    },
    {
        "content": "<p>roll our own <code>ld.so</code>, how hard could it be...</p>",
        "id": 213974171,
        "sender_full_name": "cuviper",
        "timestamp": 1603225137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/hardware.20counter.20(rdpmc).20measurements/near/213974118\">said</a>:</p>\n<blockquote>\n<p>and then we inject that into the dylib somehow. could even be something we do at runtime</p>\n</blockquote>\n<p>That could work. <code>__rustc_get_tls_addr()</code>?</p>",
        "id": 213974226,
        "sender_full_name": "bjorn3",
        "timestamp": 1603225178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> we don't have the go that far I don't think, just add in an unstable hack that relies on the faster \"executable TLS\" support that already is</p>",
        "id": 213974245,
        "sender_full_name": "eddyb",
        "timestamp": 1603225193
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/hardware.20counter.20(rdpmc).20measurements/near/213974171\">said</a>:</p>\n<blockquote>\n<p>roll our own <code>ld.so</code>, how hard could it be...</p>\n</blockquote>\n<p>relibc?</p>",
        "id": 213974250,
        "sender_full_name": "bjorn3",
        "timestamp": 1603225196
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> heh</p>",
        "id": 213974251,
        "sender_full_name": "eddyb",
        "timestamp": 1603225196
    },
    {
        "content": "<p>And a macro for every rustc_driver user to define it.</p>",
        "id": 213974349,
        "sender_full_name": "bjorn3",
        "timestamp": 1603225236
    },
    {
        "content": "<p>anyway this is kind of offtopic, I'm just sad that's what I wasted time on</p>",
        "id": 213974354,
        "sender_full_name": "eddyb",
        "timestamp": 1603225241
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> lol in that case we wouldn't even need to implement it in the compiler itself</p>",
        "id": 213974371,
        "sender_full_name": "eddyb",
        "timestamp": 1603225254
    },
    {
        "content": "<p>Split this into a new topic?</p>",
        "id": 213974412,
        "sender_full_name": "bjorn3",
        "timestamp": 1603225275
    },
    {
        "content": "<p>like we wouldn't need <code>#[more_magical_thread_local]</code></p>",
        "id": 213974417,
        "sender_full_name": "eddyb",
        "timestamp": 1603225279
    },
    {
        "content": "<p>hmm yeah. I guess it's still performance-related, so that's fine. gimme a sec</p>",
        "id": 213974448,
        "sender_full_name": "eddyb",
        "timestamp": 1603225297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> mentioned elsewhere that <code>ld.so</code> might have a more advanced TLS dynamic linking, but everything still uses <code>__tls_get_addr()</code></p>",
        "id": 213974734,
        "sender_full_name": "eddyb",
        "timestamp": 1603225429
    },
    {
        "content": "<p>so maybe we just need to find a few toggles to mess with in order to get faster TLS</p>",
        "id": 213974797,
        "sender_full_name": "eddyb",
        "timestamp": 1603225448
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"120989\">@njn</span> <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span></p>",
        "id": 213974823,
        "sender_full_name": "eddyb",
        "timestamp": 1603225467
    },
    {
        "content": "<p>but yeah worst case we can bodge it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 213974866,
        "sender_full_name": "eddyb",
        "timestamp": 1603225493
    },
    {
        "content": "<p>The initialexec storage model seems to be allowed for dylibs that are loaded at startup. That only requires 2 instructions. Neither of which is a call.</p>",
        "id": 213975451,
        "sender_full_name": "bjorn3",
        "timestamp": 1603225820
    },
    {
        "content": "<p>We have <code>-Z tls-model=initial-exec</code>, so someone is welcome to try it on the compiler crates.</p>",
        "id": 213975984,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1603226113
    },
    {
        "content": "<p>add that somewhere in <code>src/bootstrap</code>, run perf, ???, profit?</p>",
        "id": 213977184,
        "sender_full_name": "eddyb",
        "timestamp": 1603226760
    },
    {
        "content": "<p>I guess so. It should probably only be added for <a href=\"http://librustc_driver.so\">librustc_driver.so</a> though, so it should go in <a href=\"http://build.rs\">build.rs</a>. Not everyone may play well with initialexec as tls storage model.</p>",
        "id": 213977606,
        "sender_full_name": "bjorn3",
        "timestamp": 1603226982
    },
    {
        "content": "<p>ah right. there's also <code>libstd.so</code> but I don't know how bad that one is</p>",
        "id": 213977700,
        "sender_full_name": "eddyb",
        "timestamp": 1603227020
    },
    {
        "content": "<p>That one may be indirectly loaded using dlopen when for example writing a plugin for something and using -Cprefer-dynamic.</p>",
        "id": 213977864,
        "sender_full_name": "bjorn3",
        "timestamp": 1603227106
    },
    {
        "content": "<p>wouldn't it always be loaded at the start? or do you mean a second copy of <code>libstd-*.so</code>?</p>",
        "id": 213977966,
        "sender_full_name": "eddyb",
        "timestamp": 1603227147
    },
    {
        "content": "<p>I mean as plugin for a non-rust program.</p>",
        "id": 213978156,
        "sender_full_name": "bjorn3",
        "timestamp": 1603227261
    },
    {
        "content": "<blockquote>\n<p>AFAIK thread_local! just uses #[thread_local] under the hood, which presumably LLVM generates __tls_get_addr calls for</p>\n</blockquote>\n<p>It also has the RefCell-ish thing for tracking \"is this initialized\", and can prevent compiler from hoisting thread local access out of loops in pathalogical cases. But, given rustc's already verbose TLS API with with, I wouldn't expect that to matter much</p>",
        "id": 213978424,
        "sender_full_name": "matklad",
        "timestamp": 1603227422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> ah because we don't have a private copy of <code>libstd-*.so</code> for <code>rustc</code>, I see</p>",
        "id": 213979632,
        "sender_full_name": "eddyb",
        "timestamp": 1603228090
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> tbh we could just use <code>#[thread_local]</code> directly in the compiler if we wanted to, there's nothing stopping us I don't think</p>",
        "id": 213979705,
        "sender_full_name": "eddyb",
        "timestamp": 1603228148
    },
    {
        "content": "<p>whereas the dylib tax is worse to shave off</p>",
        "id": 213979745,
        "sender_full_name": "eddyb",
        "timestamp": 1603228164
    },
    {
        "content": "<p>On windows, I don't believe a function call is ever necessary to access TLS, and there no restrictions on when a shared library is loaded. This is because memory for TLS slots is allocated eagerly using TlsAlloc whenever a module is loaded. I don't know if such a thing is in practice possible on linux, but in theory it should be...</p>",
        "id": 213985325,
        "sender_full_name": "Diggsey",
        "timestamp": 1603231428
    },
    {
        "content": "<p>It's not just dylibs that incur the cost, it depends how they're loaded (e.g. via dlopen vs not), and whether code outside the module needs to access them. right now rustc always compiles it in the most pessimistic/general possible way.</p>",
        "id": 213995631,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1603239977
    },
    {
        "content": "<p>I would love to see rustc (and Rust code in general) able to use the much simpler \"just use <code>%fs</code>\" approach.</p>",
        "id": 214011246,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603260550
    },
    {
        "content": "<p>I suspect that'd make a <em>massive</em> performance difference, given the number of calls to <code>__tls_get_addr</code>.</p>",
        "id": 214011253,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603260568
    },
    {
        "content": "<p>I remember profiling some rayon code and finding that <code>__tls_get_addr</code> and family was a <em>substantial</em> component of runtime.</p>",
        "id": 214011259,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603260587
    },
    {
        "content": "<p>Also, I would love to avoid the additional level of indirection through a hash table, that the common thread-local libraries in the ecosystem introduce.</p>",
        "id": 214013006,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603262657
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> AFAIK <code>rustc</code> is much worse than the average Rust program just because the entirety of it is in a dylib</p>",
        "id": 214042813,
        "sender_full_name": "eddyb",
        "timestamp": 1603283505
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=598ebc2ff99a54185588bd891e7dc064\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=598ebc2ff99a54185588bd891e7dc064</a></p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code>    <span class=\"nf\">mov</span> <span class=\"no\">rax</span><span class=\"p\">,</span> <span class=\"no\">qword</span> <span class=\"no\">ptr</span> <span class=\"no\">fs</span><span class=\"p\">:[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"nf\">lea</span> <span class=\"no\">rdi</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"no\">rax</span> <span class=\"err\">+</span> <span class=\"no\">playground</span><span class=\"p\">::</span><span class=\"no\">PID</span><span class=\"p\">::</span><span class=\"no\">__getit</span><span class=\"p\">::</span><span class=\"no\">__KEY@TPOFF</span><span class=\"p\">]</span>\n</code></pre></div>",
        "id": 214043402,
        "sender_full_name": "eddyb",
        "timestamp": 1603283888
    },
    {
        "content": "<p>I guess this is pre-linking, hence <code>@TPOFF</code></p>",
        "id": 214043471,
        "sender_full_name": "eddyb",
        "timestamp": 1603283938
    },
    {
        "content": "<p>how did you get such clean disassembly out of the playground?</p>",
        "id": 214052817,
        "sender_full_name": "Diggsey",
        "timestamp": 1603288616
    },
    {
        "content": "<p>oh, nice, there's an option for intel syntax, I had no idea that existed</p>",
        "id": 214053122,
        "sender_full_name": "Diggsey",
        "timestamp": 1603288739
    },
    {
        "content": "<p>why is a dylib a quality problem?</p>",
        "id": 214053185,
        "sender_full_name": "oliver",
        "timestamp": 1603288763
    },
    {
        "content": "<p>There are multiple storage models for TLS. The local exec model, which is the fastest is only possible for executables. The initial exec model is a tiny bit slower. This one also supports dylibs, but only when they are loaded at program startup, not when using <code>dlopen</code>. The general dynamic model is always allowed, but it requires a <code>__tls_get_addr</code> call. Because it is not known if dylibs will be <code>dlopen</code>ed in advance, they use the general dynamic model by default. Executables instead use the local exec model, which is the fastest model.</p>",
        "id": 214054741,
        "sender_full_name": "bjorn3",
        "timestamp": 1603289400
    },
    {
        "content": "<p>See <a href=\"https://akkadia.org/drepper/tls.pdf\">https://akkadia.org/drepper/tls.pdf</a> for all possible models and their resulting codegen.</p>",
        "id": 214054971,
        "sender_full_name": "bjorn3",
        "timestamp": 1603289500
    },
    {
        "content": "<p>so it's not controversial</p>",
        "id": 214055656,
        "sender_full_name": "oliver",
        "timestamp": 1603289825
    },
    {
        "content": "<p>I've wanted to learn more about ELF</p>",
        "id": 214055696,
        "sender_full_name": "oliver",
        "timestamp": 1603289849
    },
    {
        "content": "<p>All thread locals in the same module are combined by the linker into a single contiguous block \"template\", that is instantiated for each thread in the process (resulting in up to <code>num_threads * num_modules</code> blocks).</p>\n<p>Each thread has an index, whose address is stored in <code>fs</code>, such that you can take your module ID look it up in that index, and find the address of the block for that thread/module combination.</p>\n<p>The problem happens when the block has not been allocated yet, and is not present in the index. In that case it must be lazily allocated, and this logic is complex enough that it lives in a function <code>__tls_get_addr</code> - it doesn't make sense to inline it into the caller.</p>\n<p>For module 0 (the executable) and other modules loaded at startup I believe space in the index can be reserved ahead of time, and so when accessing a TLS value, it can be inlined into the caller (and is just a couple of de-references). For dylibs, they cannot rely on space being pre-allocated, and so will always take the slow path.</p>\n<p>If you switch to the <code>inital exec</code> model, then dylibs will assume that they are loaded on startup. However, AIUI this will cause corruption if those dylibs are loaded with <code>dlopen</code>.</p>\n<p>For comparison, on windows, the OS provides hooks for all DLLs loaded by a process to detect when a new thread is started. This allows all TLS space to be reserved eagerly, even if a module is loaded dynamically with <code>LoadLibrary</code>. All code running in anywhere is safe to assume that TLS space has been allocated, and the only overhead to TLS access from a DLL is the usual overhead of relocations.</p>",
        "id": 214056199,
        "sender_full_name": "Diggsey",
        "timestamp": 1603290082
    },
    {
        "content": "<p>why can't they just error from <code>dlopen</code> &gt;:(</p>",
        "id": 214061640,
        "sender_full_name": "eddyb",
        "timestamp": 1603292262
    },
    {
        "content": "<p>(if they weren't built to be <code>dlopen</code>-able)</p>",
        "id": 214061670,
        "sender_full_name": "eddyb",
        "timestamp": 1603292274
    },
    {
        "content": "<p>I guess because they <em>might</em> work if they happened to be allocated already? TBH I don't know - it may be that this mitigation is implemented in some cases, but the first result on google (<a href=\"https://lists.freebsd.org/pipermail/freebsd-arch/2016-February/017699.html\">https://lists.freebsd.org/pipermail/freebsd-arch/2016-February/017699.html</a>) indicated that this was not the case</p>",
        "id": 214062239,
        "sender_full_name": "Diggsey",
        "timestamp": 1603292497
    },
    {
        "content": "<blockquote>\n<p>Beside the program header entry the only other information the dynamic linker<br>\nneeds is the DF STATIC TLS flag in the DT FLAGS entry in the dynamic section. This<br>\nflag allows to reject loading modules dynamically which are created with the static model</p>\n</blockquote>",
        "id": 214071606,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603295848
    },
    {
        "content": "<p>that would be sweet to have for <code>librustc_driver.so</code></p>",
        "id": 214073029,
        "sender_full_name": "eddyb",
        "timestamp": 1603296326
    },
    {
        "content": "<p>Why <em>do</em> we put that in a shared library, anyway? What shares it?</p>",
        "id": 214073752,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603296583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> all the <code>rustc</code> drivers like <code>rustdoc</code>, <code>clippy</code>, <code>miri</code>, etc.</p>",
        "id": 214074181,
        "sender_full_name": "eddyb",
        "timestamp": 1603296724
    },
    {
        "content": "<p>Ah, got it.</p>",
        "id": 214074234,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603296750
    },
    {
        "content": "<p>They aren't using dlopen, right? So in theory we don't need tls_get_addr?</p>",
        "id": 214074399,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1603296825
    },
    {
        "content": "<p>yes, we just have to figure out how to make LLVM/the linker do what we want</p>",
        "id": 214074431,
        "sender_full_name": "eddyb",
        "timestamp": 1603296838
    },
    {
        "content": "<p>maybe it's just the <code>-Z tls-model=initial-exec</code> flag <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> mentioned but I haven't tried it</p>",
        "id": 214074541,
        "sender_full_name": "eddyb",
        "timestamp": 1603296879
    },
    {
        "content": "<p>if someone has the time, feel free to play around with it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 214074556,
        "sender_full_name": "eddyb",
        "timestamp": 1603296888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> How did you manage to reliably ltrace rustc? I got non-deterministic errors like <code>rustc: ../nptl/pthread_mutex_lock.c:81: __pthread_mutex_cond_lock: Assertion `mutex-&gt;__data.__owner == 0' failed.</code> when I tried.</p>",
        "id": 214097795,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603306634
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> what's the full command?</p>",
        "id": 214100396,
        "sender_full_name": "eddyb",
        "timestamp": 1603307714
    },
    {
        "content": "<p>I never got any assertion failures no matter what I did</p>",
        "id": 214100583,
        "sender_full_name": "eddyb",
        "timestamp": 1603307784
    },
    {
        "content": "<p><code>-l '*'</code> is the filter I used to get the gazillion <code>__tls_get_addr</code> calls</p>",
        "id": 214100668,
        "sender_full_name": "eddyb",
        "timestamp": 1603307825
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> oof tried to replicate something and forgot to pipe stderr instead of stdout</p>",
        "id": 214101279,
        "sender_full_name": "eddyb",
        "timestamp": 1603308085
    },
    {
        "content": "<p>oh thank god that <code>less</code> switched to alternate buffer so it didn't pollute my terminal <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 214101322,
        "sender_full_name": "eddyb",
        "timestamp": 1603308105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> this works great if you want to see <code>__tls_get_addr</code> calls: <code>ltrace -e __tls_get_addr -f -w10</code></p>",
        "id": 214101930,
        "sender_full_name": "eddyb",
        "timestamp": 1603308374
    },
    {
        "content": "<p>replacing the <code>-e __tls_get_addr</code> filter with <code>-l '*'</code> also works but will include other calls. <code>-w10</code> gives you 10 frames of stack trace, you can tune that</p>",
        "id": 214102002,
        "sender_full_name": "eddyb",
        "timestamp": 1603308415
    },
    {
        "content": "<p><code>ltrace -f -e __tls_get_addr -o /tmp/ltrace rustc src/main.rs</code></p>",
        "id": 214102046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308434
    },
    {
        "content": "<p>using <code>rustfilt | c++filt</code> on the result seems to clean it up nicely</p>",
        "id": 214102052,
        "sender_full_name": "eddyb",
        "timestamp": 1603308436
    },
    {
        "content": "<p>hmm</p>",
        "id": 214102083,
        "sender_full_name": "eddyb",
        "timestamp": 1603308450
    },
    {
        "content": "<p>Just running that gives me the assertion failure sometimes. And when I added things like <code>-T</code>, I also sometimes got segfaults from ltrace.</p>",
        "id": 214102098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308464
    },
    {
        "content": "<p>(\"sometimes\", one of the most evil words in software development.)</p>",
        "id": 214102132,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308480
    },
    {
        "content": "<p><code>echo 'fn main() {}' | ltrace -e __tls_get_addr -f -w5 ./build/x86_64-unknown-linux-gnu/stage1/bin/rustc - 2&gt;| rustfilt | c++filt | head -n 5000 | tail -n 30</code></p>",
        "id": 214102333,
        "sender_full_name": "eddyb",
        "timestamp": 1603308558
    },
    {
        "content": "<p>so this works fine. pretty slow and it's still inside LLVM that early, hmm</p>",
        "id": 214102382,
        "sender_full_name": "eddyb",
        "timestamp": 1603308577
    },
    {
        "content": "<p>No idea.</p>",
        "id": 214102415,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308590
    },
    {
        "content": "<p>now trying with just <code>rustc</code> so it goes through the <code>rustup</code> wrapper.... and it still works</p>",
        "id": 214102448,
        "sender_full_name": "eddyb",
        "timestamp": 1603308601
    },
    {
        "content": "<p>oh cool the nightly built has a dynamically linked <code>libLLVM.so</code>, so I can filter by that</p>",
        "id": 214102545,
        "sender_full_name": "eddyb",
        "timestamp": 1603308624
    },
    {
        "content": "<p><code>echo 'fn main() {}' | ltrace -e '__tls_get_addr-@*LLVM*' -f -w5 rustc - 2&gt;| rustfilt | c++filt | head -n 1000 | tail</code></p>",
        "id": 214102697,
        "sender_full_name": "eddyb",
        "timestamp": 1603308691
    },
    {
        "content": "<p>this works great, it's showing me some deserialization going to <code>Symbol::intern</code></p>",
        "id": 214102755,
        "sender_full_name": "eddyb",
        "timestamp": 1603308709
    },
    {
        "content": "<p>(I'm using <code>head -n ... | tail</code> to limit the output and not have to wait ages, it's incredibly slow to trace <code>__tls_get_addr</code>)</p>",
        "id": 214102840,
        "sender_full_name": "eddyb",
        "timestamp": 1603308735
    },
    {
        "content": "<p>Hmmm. In <code>src/bootstrap/bin/rustc.rs</code>, how can I distinguish \"crates that won't get shipped in the sysroot\"?</p>",
        "id": 214102869,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308749
    },
    {
        "content": "<p>you probably just want to hardcode based on the name being <code>rustc_driver</code></p>",
        "id": 214102911,
        "sender_full_name": "eddyb",
        "timestamp": 1603308771
    },
    {
        "content": "<p>if I had to guess</p>",
        "id": 214102924,
        "sender_full_name": "eddyb",
        "timestamp": 1603308778
    },
    {
        "content": "<p>I'd like to cover the rest of the <code>rustc_*</code> crates too.</p>",
        "id": 214102945,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308788
    },
    {
        "content": "<p>And anything they depend on.</p>",
        "id": 214102957,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308792
    },
    {
        "content": "<p>but they're <code>rlib</code>s, wouldn't they be \"polymorphic\"?</p>",
        "id": 214102986,
        "sender_full_name": "eddyb",
        "timestamp": 1603308807
    },
    {
        "content": "<p>actually I wonder how that works hmm</p>",
        "id": 214102995,
        "sender_full_name": "eddyb",
        "timestamp": 1603308811
    },
    {
        "content": "<p>I don't <em>think</em> that works.</p>",
        "id": 214103005,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308818
    },
    {
        "content": "<p>I think that gets decided when compiling the crate, unfortunately.</p>",
        "id": 214103026,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308831
    },
    {
        "content": "<p>but surely if you have a <code>thread_local!</code> in a crate and statically link to it, it won't call <code>__tls_get_addr</code>?</p>",
        "id": 214103039,
        "sender_full_name": "eddyb",
        "timestamp": 1603308838
    },
    {
        "content": "<p>It <em>should</em> be determined by the top-level compile.</p>",
        "id": 214103041,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308840
    },
    {
        "content": "<p>I guess we should determine this first</p>",
        "id": 214103103,
        "sender_full_name": "eddyb",
        "timestamp": 1603308859
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 214103113,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308864
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$</span> <span class=\"nb\">echo</span> <span class=\"s1\">'fn main() {}'</span> <span class=\"p\">|</span> ltrace -e <span class=\"s1\">'__tls_get_addr-@*LLVM*'</span> -f rustc - <span class=\"m\">2</span>&gt;<span class=\"p\">|</span> wc -l\n<span class=\"go\">89723</span>\n</code></pre></div>",
        "id": 214103146,
        "sender_full_name": "eddyb",
        "timestamp": 1603308879
    },
    {
        "content": "<p>so that's nowhere near as slow as compiling <code>libcore</code> :P</p>",
        "id": 214103179,
        "sender_full_name": "eddyb",
        "timestamp": 1603308900
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$</span> <span class=\"nb\">echo</span> <span class=\"s1\">''</span> <span class=\"p\">|</span> ltrace -e <span class=\"s1\">'__tls_get_addr-@*LLVM*'</span> -f rustc --crate-type<span class=\"o\">=</span>lib --emit<span class=\"o\">=</span>metadata - <span class=\"m\">2</span>&gt;<span class=\"p\">|</span> wc -l\n<span class=\"go\">48705</span>\n</code></pre></div>",
        "id": 214103242,
        "sender_full_name": "eddyb",
        "timestamp": 1603308934
    },
    {
        "content": "<p>and this only takes a few seconds</p>",
        "id": 214103257,
        "sender_full_name": "eddyb",
        "timestamp": 1603308943
    },
    {
        "content": "<p>Hang on.</p>",
        "id": 214103273,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308951
    },
    {
        "content": "<p>That's the crate type you're compiling <em>to</em>, not the crate type of rustc. :)</p>",
        "id": 214103291,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308961
    },
    {
        "content": "<p>no I'm testing <code>ltrace</code></p>",
        "id": 214103356,
        "sender_full_name": "eddyb",
        "timestamp": 1603308973
    },
    {
        "content": "<p>Ah.</p>",
        "id": 214103362,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308976
    },
    {
        "content": "<p>Interestingly, you're getting a lot more TLS calls than I am.</p>",
        "id": 214103393,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603308996
    },
    {
        "content": "<p>so using this command I can confirm that it finishes successfully: <code>echo '' | ltrace -e '__tls_get_addr-@*LLVM*' -f rustc --crate-type=lib --emit=metadata - 2&gt;| tail -n 1000 | less</code></p>",
        "id": 214103402,
        "sender_full_name": "eddyb",
        "timestamp": 1603309000
    },
    {
        "content": "<p>oops <code>rustc 1.46.0-nightly (8aa18cbdc 2020-07-08)</code></p>",
        "id": 214103433,
        "sender_full_name": "eddyb",
        "timestamp": 1603309019
    },
    {
        "content": "<p>stuck on old nightly</p>",
        "id": 214103436,
        "sender_full_name": "eddyb",
        "timestamp": 1603309022
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ ltrace -f -e __tls_get_addr rustc src/main.rs 2&gt;&amp;1 | wc -l\n62906\n</code></pre></div>",
        "id": 214103492,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309046
    },
    {
        "content": "<p>(where main is the stock hello world that <code>cargo new</code> creates.)</p>",
        "id": 214103510,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309059
    },
    {
        "content": "<p>(I prefer not relying on files because then it's easy to weed out differences)</p>",
        "id": 214103534,
        "sender_full_name": "eddyb",
        "timestamp": 1603309074
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ echo &#39;fn main() {}&#39; | ltrace -f -e __tls_get_addr rustc - 2&gt;&amp;1 | wc -l\n54105\n</code></pre></div>",
        "id": 214103637,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309106
    },
    {
        "content": "<p>It's not even close to a deterministic number of calls, but it does seem to be much lower.</p>",
        "id": 214103688,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309139
    },
    {
        "content": "<p>(And this is the <code>rustc</code> that goes through rustup.)</p>",
        "id": 214103705,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309145
    },
    {
        "content": "<p>it's probably much newer :P</p>",
        "id": 214103721,
        "sender_full_name": "eddyb",
        "timestamp": 1603309157
    },
    {
        "content": "<p>locally (previously I was on the server) I get:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$</span> <span class=\"nb\">echo</span> <span class=\"s1\">''</span> <span class=\"p\">|</span> ltrace -e <span class=\"s1\">'__tls_get_addr-@*LLVM*'</span> -f ~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc --crate-type<span class=\"o\">=</span>lib --emit<span class=\"o\">=</span>metadata - <span class=\"m\">2</span>&gt;<span class=\"p\">|</span> wc -l\n<span class=\"go\">3287</span>\n</code></pre></div>",
        "id": 214103833,
        "sender_full_name": "eddyb",
        "timestamp": 1603309206
    },
    {
        "content": "<p>with <code>rustc 1.49.0-nightly (91a79fb29 2020-10-07)</code></p>",
        "id": 214103887,
        "sender_full_name": "eddyb",
        "timestamp": 1603309234
    },
    {
        "content": "<p>Huh!</p>",
        "id": 214103897,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309239
    },
    {
        "content": "<p>I get much more than that, with a recent nightly.</p>",
        "id": 214103908,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309247
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ echo &#39;fn main() {}&#39; | ltrace -f -e __tls_get_addr ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin/rustc - 2&gt;&amp;1 | wc -l\n54391\n$ echo &#39;fn main() {}&#39; | ltrace -f -e __tls_get_addr ~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc - 2&gt;&amp;1 | wc -l\n51085\n</code></pre></div>",
        "id": 214103927,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309258
    },
    {
        "content": "<p>Oh, you're <em>only</em> tracing LLVM.</p>",
        "id": 214103959,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309276
    },
    {
        "content": "<p>you do need the exact arguments I use</p>",
        "id": 214103963,
        "sender_full_name": "eddyb",
        "timestamp": 1603309277
    },
    {
        "content": "<p>there's a <code>-</code> before the <code>@</code>, I'm excluding LLVM</p>",
        "id": 214103986,
        "sender_full_name": "eddyb",
        "timestamp": 1603309292
    },
    {
        "content": "<p>/me goes back to trying to eliminate the calls, instead. :)</p>",
        "id": 214103991,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309294
    },
    {
        "content": "<p>(Ah.)</p>",
        "id": 214103999,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309300
    },
    {
        "content": "<p><code>echo '' | ltrace -e '__tls_get_addr-@*LLVM*' -f ~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/rustc --crate-type=lib --emit=metadata - 2&gt;&amp;1 | wc -l</code></p>",
        "id": 214104030,
        "sender_full_name": "eddyb",
        "timestamp": 1603309318
    },
    {
        "content": "<p>if you want to get a comparable number (to my <code>3287</code>)</p>",
        "id": 214104078,
        "sender_full_name": "eddyb",
        "timestamp": 1603309325
    },
    {
        "content": "<p>wait, you're not getting the errors anymore?</p>",
        "id": 214104148,
        "sender_full_name": "eddyb",
        "timestamp": 1603309361
    },
    {
        "content": "<p>Doesn't seem so. I think it might be timing-dependent.</p>",
        "id": 214104403,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309463
    },
    {
        "content": "<p>Perhaps the more focused commands aren't taking as long to trace.</p>",
        "id": 214104428,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309476
    },
    {
        "content": "<p>The ideal solution <em>would</em> be if a top-level compile of a <code>cdylib</code> used <code>local-dynamic</code> with an option for <code>initial-exec</code>, a top-level compile of a dynamic <code>bin</code> used <code>initial-exec</code> for libraries and <code>local-exec</code> for the binary's own things, and a top-level compile of a static <code>bin</code> used <code>local-exec</code> for everything.</p>",
        "id": 214105429,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309923
    },
    {
        "content": "<p>Rather than having to decide on a crate-by-crate basis.</p>",
        "id": 214105501,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603309947
    },
    {
        "content": "<p>maybe I should just try the thing I was imagining, should be pretty easy</p>",
        "id": 214105710,
        "sender_full_name": "eddyb",
        "timestamp": 1603310038
    },
    {
        "content": "<p>Which thing?</p>",
        "id": 214105807,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603310063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/__tls_get_addr.20and.20TLS.20in.20dylibs/near/214103039\">said</a>:</p>\n<blockquote>\n<p>but surely if you have a <code>thread_local!</code> in a crate and statically link to it, it won't call <code>__tls_get_addr</code>?</p>\n</blockquote>\n<p>This?</p>",
        "id": 214105856,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603310082
    },
    {
        "content": "<p><code>echo 'thread_local!(pub static X: () = {};);' | rustc --crate-type=dylib --crate-name=dylib -Cprefer-dynamic -o libdylib.so - &amp;&amp; echo 'extern crate dylib; fn main() { dylib::X.with(|_| {}); }' | rustc -o test-dylib -L. - &amp;&amp; ltrace -e __tls_get_addr ./test-dylib</code></p>",
        "id": 214106238,
        "sender_full_name": "eddyb",
        "timestamp": 1603310254
    },
    {
        "content": "<p>so this tests for the dylib case, which clearly needs it</p>",
        "id": 214106253,
        "sender_full_name": "eddyb",
        "timestamp": 1603310263
    },
    {
        "content": "<p>True. That case needs global-dynamic, right?</p>",
        "id": 214106357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603310299
    },
    {
        "content": "<p><code>echo 'thread_local!(pub static X: () = {};);' | rustc --crate-type=lib --crate-name=rlib -o librlib.rlib - &amp;&amp; echo 'extern crate rlib; fn main() { rlib::X.with(|_| {}); }' | rustc -o test-rlib -L. - &amp;&amp; ltrace -e __tls_get_addr ./test-rlib</code></p>",
        "id": 214106386,
        "sender_full_name": "eddyb",
        "timestamp": 1603310311
    },
    {
        "content": "<p>this outputs <em>nothing</em></p>",
        "id": 214106400,
        "sender_full_name": "eddyb",
        "timestamp": 1603310315
    },
    {
        "content": "<p>time to chain them :P</p>",
        "id": 214106439,
        "sender_full_name": "eddyb",
        "timestamp": 1603310338
    },
    {
        "content": "<p>Currently testing this: <a href=\"https://github.com/rust-lang/rust/pull/78201\">https://github.com/rust-lang/rust/pull/78201</a></p>",
        "id": 214106573,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603310393
    },
    {
        "content": "<p><code>echo 'thread_local!(pub static X: () = {};);' | rustc --crate-type=lib --crate-name=rlib -o librlib.rlib - &amp;&amp; echo 'pub extern crate rlib;' | rustc --crate-type=dylib --crate-name=dylib -Cprefer-dynamic -o libdylib.so -L. -  &amp;&amp; echo 'extern crate dylib; fn main() { dylib::rlib::X.with(|_| {}); }' | rustc -o test-both -L. - &amp;&amp; ltrace -e __tls_get_addr ./test-both</code></p>",
        "id": 214106694,
        "sender_full_name": "eddyb",
        "timestamp": 1603310424
    },
    {
        "content": "<p>this does show <code>__tls_get_addr</code> calls, even if I didn't change how the <code>rlib</code> is compiled</p>",
        "id": 214106730,
        "sender_full_name": "eddyb",
        "timestamp": 1603310442
    },
    {
        "content": "<p>so yeah it's based on how it's used</p>",
        "id": 214106749,
        "sender_full_name": "eddyb",
        "timestamp": 1603310448
    },
    {
        "content": "<p>sadly <code>-Z tls-model=initial-exec</code> on the dylib compilation doesn't change anything</p>",
        "id": 214106852,
        "sender_full_name": "eddyb",
        "timestamp": 1603310484
    },
    {
        "content": "<p>fascinating, you need <code>-Z tls-model=initial-exec</code> for the crate that <em>defines</em> the thread-local</p>",
        "id": 214106991,
        "sender_full_name": "eddyb",
        "timestamp": 1603310534
    },
    {
        "content": "<p>even though the static vs dynamic choice doesn't happen until a <code>dylib</code> or executable is linked</p>",
        "id": 214107033,
        "sender_full_name": "eddyb",
        "timestamp": 1603310553
    },
    {
        "content": "<p>so presumably we could have a flag that we only need to pass when compiling <code>rustc_driver</code></p>",
        "id": 214107068,
        "sender_full_name": "eddyb",
        "timestamp": 1603310572
    },
    {
        "content": "<p>I guess this is what you were saying before</p>",
        "id": 214107109,
        "sender_full_name": "eddyb",
        "timestamp": 1603310593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> the PR is a good approximation, maybe we want to check for the path being in <code>compiler/</code>?</p>",
        "id": 214107160,
        "sender_full_name": "eddyb",
        "timestamp": 1603310625
    },
    {
        "content": "<p>there's some crates that start with <code>rustc_</code> which come from <code>crates.io</code> and which may be used elsewhere though I guess thread locals in a <em>dependency</em> of libstd would be highly unusual</p>",
        "id": 214107260,
        "sender_full_name": "eddyb",
        "timestamp": 1603310662
    },
    {
        "content": "<p>guess I should comment on it</p>",
        "id": 214107598,
        "sender_full_name": "eddyb",
        "timestamp": 1603310820
    },
    {
        "content": "<p>(responded)</p>",
        "id": 214107946,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603310978
    },
    {
        "content": "<p>definitely agree, overapproximating here is good because we should see the best-case improvements</p>",
        "id": 214108073,
        "sender_full_name": "eddyb",
        "timestamp": 1603311020
    },
    {
        "content": "<p>wait I have an idea</p>",
        "id": 214108479,
        "sender_full_name": "eddyb",
        "timestamp": 1603311218
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>  <del>extremely</del> convoluted plan if we want perfect tracking of which crates use TLS <a href=\"https://github.com/rust-lang/rust/pull/78201#issuecomment-713850554\">https://github.com/rust-lang/rust/pull/78201#issuecomment-713850554</a></p>",
        "id": 214109426,
        "sender_full_name": "eddyb",
        "timestamp": 1603311659
    },
    {
        "content": "<p>The local-dynamic only has an advantage over global-dynamic when you are accessing two or more dofferent tls variables from the same function. Otherwise it results in an ummecessary extra add and relocation. global-dynamic directly requests the tls var address while local-dynamic requests the address of the tls storage for the current module and then adds the correct offset. This is only faster then multiple __tls_get_addr calls for different tls vars can be merged.</p>",
        "id": 214122038,
        "sender_full_name": "bjorn3",
        "timestamp": 1603318637
    },
    {
        "content": "<p>Looks like the change is <em>definitely</em> worth making. Now we just need to figure out the best version of the change.</p>",
        "id": 214146046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603345834
    },
    {
        "content": "<p>Ideally we would apply this to every crate that isn't part of std or proc macros.</p>",
        "id": 214146081,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1603345917
    },
    {
        "content": "<p>It can't be applied to hotpluggable codegen backends like cg_clif once it can be built as part of rustc.</p>",
        "id": 214162470,
        "sender_full_name": "bjorn3",
        "timestamp": 1603358860
    },
    {
        "content": "<p>Mode::Compiler should work, as I think I suggested on the PR. Happy to help if I didn't explain sufficiently</p>",
        "id": 214185039,
        "sender_full_name": "simulacrum",
        "timestamp": 1603372626
    }
]