[
    {
        "content": "<p>There's a bunch of sampling profilers for Windows, but they are not very suitable for analyzing small differences like the regression in <a href=\"https://github.com/rust-lang/rust/issues/92245\">#92245</a> on helloworld - the relevant code just doesn't get covered by samples.</p>\n<p>I need something working like callgrind - converting everything into IR and interpreting it, thus taking all executed code into account.<br>\nMaybe something based on Qemu or DynamoRIO? (Both work on Windows, more or less.)<br>\nA quick search didn't give any results.</p>",
        "id": 266039045,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1640402904
    },
    {
        "content": "<hr>\n<p>Also, a side question - is there any tool for producing diffs for callgrind outputs?</p>",
        "id": 266039059,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1640402950
    },
    {
        "content": "<blockquote>\n<p>Also, a side question - is there any tool for producing diffs for callgrind outputs?</p>\n</blockquote>\n<p>cg_diff, right?</p>",
        "id": 266050032,
        "sender_full_name": "bjorn3",
        "timestamp": 1640422788
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Callgrind.20replacement.20for.20Windows.3F/near/266050032\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Also, a side question - is there any tool for producing diffs for callgrind outputs?</p>\n</blockquote>\n<p>cg_diff, right?</p>\n</blockquote>\n<p>Doesn't work on callgrind outputs, unfortunately, only on cachegrind.</p>",
        "id": 266050922,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1640424225
    },
    {
        "content": "<p>I found where I've seen it - <a href=\"https://blog.mozilla.org/nnethercote/2010/06/30/cg_diff-a-differential-profiling-tool/\">https://blog.mozilla.org/nnethercote/2010/06/30/cg_diff-a-differential-profiling-tool/</a><br>\nSo you have to use a larger hammer an run with cachegrind instead of callgrind, but it also collects all the relevant information allowing to count instructions, and the output can be used with cg_diff.</p>",
        "id": 266056519,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1640433766
    },
    {
        "content": "<p>If WSL is acceptable, it can run callgrind IIRC; I don’t remember if WSL can run the perf collector though, but if so and if cachegrind is also acceptable to you to get the diff: the collector does support cg_diff as one of the local benchmarking tools with the \"diff_local  cachegrind\" command</p>",
        "id": 266058620,
        "sender_full_name": "lqd",
        "timestamp": 1640437352
    },
    {
        "content": "<p>(Otherwise tracy can also compute diffs between profiles, and could be interesting to look at; marking the zones manually eg with nagisa’s client, to avoid using sampling)</p>",
        "id": 266058766,
        "sender_full_name": "lqd",
        "timestamp": 1640437668
    },
    {
        "content": "<blockquote>\n<p>If WSL is acceptable, it can run callgrind IIRC</p>\n</blockquote>\n<p>Yeah, that's what I ended up doing.</p>",
        "id": 266059707,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1640439324
    },
    {
        "content": "<hr>\n<p>The next problem with the diff is that <a href=\"https://github.com/rust-lang/rust/issues/92245\">#92245</a> changes function signatures which seems to change hashes in symbol names (with legacy mangling), breaking the diff entirely. Sigh, I guess I'll have to enable v0 mangling an lose demangled names if I want the diff.</p>",
        "id": 266059911,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1640439686
    },
    {
        "content": "<p>If you compile valgrind locally from master it should support v0 mangling now, fwiw</p>",
        "id": 266061996,
        "sender_full_name": "simulacrum",
        "timestamp": 1640443271
    },
    {
        "content": "<blockquote>\n<p>I don’t remember if WSL can run the perf collector though</p>\n</blockquote>\n<p>WSL2 on Windows 10 supports only software events for <code>perf</code> but with Windows 11 hardware events support has been added.</p>",
        "id": 266062721,
        "sender_full_name": "mati865",
        "timestamp": 1640444490
    },
    {
        "content": "<p>For sampling / hardware events the native WPA is fine, don't even need WSL.</p>",
        "id": 266063138,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1640445280
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> There's an old attempt at a callgrind_diff at <a href=\"https://bugs.kde.org/show_bug.cgi?id=399355\">https://bugs.kde.org/show_bug.cgi?id=399355</a>, might still work, but no promises.</p>",
        "id": 266741221,
        "sender_full_name": "nnethercote",
        "timestamp": 1641246972
    },
    {
        "content": "<p>From what I remember, it worked for the Callgrind invocation I used, but had some problems with some other invocations. The Callgrind file format is <em>very</em> complicated, alas</p>",
        "id": 266741262,
        "sender_full_name": "nnethercote",
        "timestamp": 1641247010
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Callgrind.20replacement.20for.20Windows.3F/near/266056519\">said</a>:</p>\n<blockquote>\n<p>So you have to use a larger hammer an run with cachegrind instead of callgrind, but it also collects all the relevant information allowing to count instructions, and the output can be used with cg_diff.</p>\n</blockquote>\n<p>I don't understand this comment. Cachegrind is simpler and collects less information than Callgrind, so I would describe <em>Callgrind</em> as the larger hammer. Have I misunderstood?</p>",
        "id": 266741401,
        "sender_full_name": "nnethercote",
        "timestamp": 1641247117
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Callgrind.20replacement.20for.20Windows.3F/near/266741401\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/Callgrind.20replacement.20for.20Windows.3F/near/266056519\">said</a>:</p>\n<blockquote>\n<p>So you have to use a larger hammer an run with cachegrind instead of callgrind, but it also collects all the relevant information allowing to count instructions, and the output can be used with cg_diff.</p>\n</blockquote>\n<p>I don't understand this comment. Cachegrind is simpler and collects less information than Callgrind, so I would describe <em>Callgrind</em> as the larger hammer. Have I misunderstood?</p>\n</blockquote>\n<p>Looks like a wrong analogy from my side.<br>\nI didn't use cachegrind myself and assumed that cache simulation slows down valgrind significantly after recalling enabling cache simulation in other simulators.</p>",
        "id": 266763914,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1641264975
    },
    {
        "content": "<p>perf collector runs cachegrind without cache simulation</p>",
        "id": 266764495,
        "sender_full_name": "The 8472",
        "timestamp": 1641265587
    },
    {
        "content": "<p>And callgrind also has a cache simulator. Callgrind is just cachegrind with a bunch of extra stuff, basically.</p>",
        "id": 266772945,
        "sender_full_name": "nnethercote",
        "timestamp": 1641276364
    },
    {
        "content": "<p>(rustc-perf also runs Callgrind with the cache simulation disabled, too)</p>",
        "id": 266772953,
        "sender_full_name": "nnethercote",
        "timestamp": 1641276383
    }
]