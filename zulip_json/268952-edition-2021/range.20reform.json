[
    {
        "content": "<p>I wrote up a draft of an RFC covering the proposed changes to range syntax desugaring: <a href=\"https://hackmd.io/cM22mZ5JRH2RAdSART8bWQ\">https://hackmd.io/cM22mZ5JRH2RAdSART8bWQ</a></p>",
        "id": 225248870,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1612487689
    },
    {
        "content": "<p>If renaming the 2018 <code>Range</code> to <code>RangeIter</code> is an option I have a strong preference for that. What would be necessary to make that work? Is a <code>prelude::v2</code> required?</p>",
        "id": 225249426,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1612488223
    },
    {
        "content": "<p>It would require some new kind of compiler support to conditionally rename a type based on an edition.</p>",
        "id": 225249482,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1612488255
    },
    {
        "content": "<p>But I think it is more of a \"should we\" question rather than \"can we\"</p>",
        "id": 225249494,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1612488272
    },
    {
        "content": "<p>the UX around rustdoc would also require thought</p>",
        "id": 225249501,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1612488279
    },
    {
        "content": "<p>Great to see this written up!  I tossed in a few minor things that jumped to mind while reading.</p>",
        "id": 225259685,
        "sender_full_name": "scottmcm",
        "timestamp": 1612498502
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> Might be good to mention what this change would mean for the <code>Index</code> trait implementations for slices and other crates in the ecosystem. And whether <code>RangeBounds</code> will be implemented for both <code>Range</code> and <code>Range2</code> (etc.).</p>",
        "id": 225294120,
        "sender_full_name": "Mara",
        "timestamp": 1612529358
    },
    {
        "content": "<p>I added a sentence about that, thanks</p>",
        "id": 225295532,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1612530180
    },
    {
        "content": "<p>oh yeah i'll talk about how the ecosystem should update as well</p>",
        "id": 225295588,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1612530213
    },
    {
        "content": "<p>I updated the draft to match what we discussed last week: <a href=\"https://hackmd.io/cM22mZ5JRH2RAdSART8bWQ?view#Reference-level-explanation\">https://hackmd.io/cM22mZ5JRH2RAdSART8bWQ?view#Reference-level-explanation</a></p>",
        "id": 229586383,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1615339241
    },
    {
        "content": "<p>I still need to write the guide-level explanation section, which will mostly cover how third party libraries should think about implementing things for the new types.</p>",
        "id": 229586445,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1615339276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> I just realized that <a href=\"https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr_range\"><code>slice::as_ptr_range</code></a> gives a <code>Range</code> of pointers. that one would be a bit weird if we have both Copy and Iterator Ranges, because it's returning the Iterator one instead of the Copy one. maybe we can change it without breaking too much, but it's also something to look at. :(</p>",
        "id": 230364778,
        "sender_full_name": "Mara",
        "timestamp": 1615822372
    },
    {
        "content": "<p>Yeah, we may just be stuck with those methods unfortunately</p>",
        "id": 230365505,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1615822610
    },
    {
        "content": "<p>I was saying to <span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> earlier that maybe we should get a new name, like <code>Interval</code>?</p>",
        "id": 230420419,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615843196
    },
    {
        "content": "<p>then we can have <code>as_ptr_interval</code></p>",
        "id": 230420475,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1615843206
    },
    {
        "content": "<p>I'm sorry for taking a while to notice this but</p>",
        "id": 230758332,
        "sender_full_name": "eddyb",
        "timestamp": 1616011835
    },
    {
        "content": "<p>I don't think this solves anything, other than <code>RangeInclusive</code> having that extra field only for iteration purposes</p>",
        "id": 230758387,
        "sender_full_name": "eddyb",
        "timestamp": 1616011859
    },
    {
        "content": "<p>at least not if we keep in mind the reason for why iterators don't implement <code>Copy</code></p>",
        "id": 230758454,
        "sender_full_name": "eddyb",
        "timestamp": 1616011888
    },
    {
        "content": "<p>I wrote this up in <a href=\"https://github.com/rust-lang/rfcs/issues/2848#issuecomment-801401285\">https://github.com/rust-lang/rfcs/issues/2848#issuecomment-801401285</a> but I might be able to discuss it here as well</p>",
        "id": 230758488,
        "sender_full_name": "eddyb",
        "timestamp": 1616011910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230420419\">said</a>:</p>\n<blockquote>\n<p>I was saying to <span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> earlier that maybe we should get a new name, like <code>Interval</code>?</p>\n</blockquote>\n<p>I'm not strongly opposed to <code>Interval</code> but it feels weird, in part because it suggests something \"continuous\", but also it's mostly just a synonym</p>",
        "id": 230758802,
        "sender_full_name": "eddyb",
        "timestamp": 1616012035
    },
    {
        "content": "<p>While it's true that</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>will copy instead of mutate the iterator, and so can be seen as  \"no improvement over status quo\", I would argue that with the new ranges this is no longer unexpected behavior, it's just the same as iterating over any other <code>IntoIterator</code> thing like a vector. It's not even mutable, so it would be weird to expect that it is mutated</p>",
        "id": 230759636,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616012337
    },
    {
        "content": "<p>I don't get this argument</p>",
        "id": 230759669,
        "sender_full_name": "eddyb",
        "timestamp": 1616012354
    },
    {
        "content": "<p>the original argument was about <em>what the code looks like</em></p>",
        "id": 230759692,
        "sender_full_name": "eddyb",
        "timestamp": 1616012365
    },
    {
        "content": "<p>there's no types in it <em>that make it look different</em></p>",
        "id": 230759701,
        "sender_full_name": "eddyb",
        "timestamp": 1616012374
    },
    {
        "content": "<p>when I look at that code I see that you are iterating twice over 0..10, and that's what it does</p>",
        "id": 230759737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616012394
    },
    {
        "content": "<p>there's nothing explicit about the fact that which <code>IntoIterator</code> impl gets called, changed</p>",
        "id": 230759739,
        "sender_full_name": "eddyb",
        "timestamp": 1616012395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> sure but <em>the</em> argument for why we shouldn't let that compile is because that might not be clear to everyone at a glance</p>",
        "id": 230759831,
        "sender_full_name": "eddyb",
        "timestamp": 1616012424
    },
    {
        "content": "<p>if that argument doesn't hold we can go <code>impl</code> <code>Copy</code> on a dozen iterator types <em>yesterday</em></p>",
        "id": 230759898,
        "sender_full_name": "eddyb",
        "timestamp": 1616012454
    },
    {
        "content": "<p>it's not like whether the type implements <code>Iterator</code> changes the semantics or anything like that</p>",
        "id": 230759967,
        "sender_full_name": "eddyb",
        "timestamp": 1616012483
    },
    {
        "content": "<p><code>for</code> <em>always</em> copies/moves</p>",
        "id": 230759981,
        "sender_full_name": "eddyb",
        "timestamp": 1616012491
    },
    {
        "content": "<p>I'm looking at the far future situation where we aren't worried about backward compatibility; in that case I would want that code to compile and do the obvious thing. Making that code not compile would just punch a hole in an otherwise stable pattern</p>",
        "id": 230760023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616012514
    },
    {
        "content": "<p>I don't understand what you mean</p>",
        "id": 230760108,
        "sender_full_name": "eddyb",
        "timestamp": 1616012539
    },
    {
        "content": "<p>since we changed the desugaring of <code>for</code>, there has been constant pushback against having <code>Copy</code> iterators</p>",
        "id": 230760130,
        "sender_full_name": "eddyb",
        "timestamp": 1616012554
    },
    {
        "content": "<p>through <em>this one</em> argument</p>",
        "id": 230760140,
        "sender_full_name": "eddyb",
        "timestamp": 1616012561
    },
    {
        "content": "<p>I'm not happy about things happening that don't seem to account for the history of this issue :/</p>",
        "id": 230760183,
        "sender_full_name": "eddyb",
        "timestamp": 1616012582
    },
    {
        "content": "<p>because whether that argument holds any water at any official level has <em>far broader</em> implications than just <code>Range</code></p>",
        "id": 230760224,
        "sender_full_name": "eddyb",
        "timestamp": 1616012609
    },
    {
        "content": "<p>I don't follow. That argument seems to apply here. <code>0..10</code> is copy but <code>(0..10).into_iter()</code> isn't</p>",
        "id": 230760225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616012611
    },
    {
        "content": "<p>the argument is about the code without any explicit calls in it</p>",
        "id": 230760256,
        "sender_full_name": "eddyb",
        "timestamp": 1616012634
    },
    {
        "content": "<p>it's not about types or traits</p>",
        "id": 230760307,
        "sender_full_name": "eddyb",
        "timestamp": 1616012644
    },
    {
        "content": "<p>it's about <em>what the code looks like</em></p>",
        "id": 230760327,
        "sender_full_name": "eddyb",
        "timestamp": 1616012655
    },
    {
        "content": "<p><code>for x in iterable</code> <em>always</em> compiles like <code>for x in iterable.into_iter()</code> even when <code>typeof(iterable): Iterator</code></p>",
        "id": 230760425,
        "sender_full_name": "eddyb",
        "timestamp": 1616012701
    },
    {
        "content": "<p><code>for</code> takes its argument by value, so I don't expect any mutation to result unless I use <code>&amp;mut</code>. (I think that's not ironclad but it's pretty close to the truth)</p>",
        "id": 230760454,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616012716
    },
    {
        "content": "<p>so there's no observable change in that code between <code>Range: Copy</code> and <code>Interval: Copy + IntoIterator&lt;IntoIter = Range&gt;</code></p>",
        "id": 230760514,
        "sender_full_name": "eddyb",
        "timestamp": 1616012743
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230760454\">said</a>:</p>\n<blockquote>\n<p><code>for</code> takes its argument by value, so I don't expect any mutation to result unless I use <code>&amp;mut</code>. (I think that's not ironclad but it's pretty close to the truth)</p>\n</blockquote>\n<p>but the whole reason we don't have <code>Copy</code> iterators hinges on that not being an obvious fact</p>",
        "id": 230760630,
        "sender_full_name": "eddyb",
        "timestamp": 1616012795
    },
    {
        "content": "<p>and preventing accidental copies</p>",
        "id": 230760643,
        "sender_full_name": "eddyb",
        "timestamp": 1616012809
    },
    {
        "content": "<p>it's basically a lint baked into a fundamental trait not being implemented</p>",
        "id": 230760709,
        "sender_full_name": "eddyb",
        "timestamp": 1616012847
    },
    {
        "content": "<p><code>Interval: Copy + IntoIterator&lt;IntoIter = Range&gt;</code> addresses <em>the letter</em> of that but not <em>the spirit</em></p>",
        "id": 230760753,
        "sender_full_name": "eddyb",
        "timestamp": 1616012874
    },
    {
        "content": "<p>the rule isn't <code>Iterator XOR Copy</code>, it's \"we don't want to make copies get misconstrued as something else\"</p>",
        "id": 230760858,
        "sender_full_name": "eddyb",
        "timestamp": 1616012911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230760225\">said</a>:</p>\n<blockquote>\n<p>I don't follow. That argument seems to apply here. <code>0..10</code> is copy but <code>(0..10).into_iter()</code> isn't</p>\n</blockquote>\n<p>note that this <em>would</em> address the argument <em>if</em> the new type <em>did not</em> implement <code>IntoIterator</code></p>",
        "id": 230761236,
        "sender_full_name": "eddyb",
        "timestamp": 1616013064
    },
    {
        "content": "<p>I am probably too used to the status quo to see what alternative is being confused here. What would you write that looks like a mutating iterator but is a copy instead?</p>",
        "id": 230761279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013085
    },
    {
        "content": "<p>if you were forced to write <code>for i in range.iter()</code> or something, then yes, <code>typeof(range): Copy</code> would be meaningfully different from <code>typeof(range.iter()): Copy</code></p>",
        "id": 230761303,
        "sender_full_name": "eddyb",
        "timestamp": 1616013101
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230761279\">said</a>:</p>\n<blockquote>\n<p>I am probably too used to the status quo to see what alternative is being confused here. What would you write that looks like a mutating iterator but is a copy instead?</p>\n</blockquote>\n<p>but if you believe that you should believe that any iterator that can implement <code>Copy</code> should do so, right?</p>",
        "id": 230761418,
        "sender_full_name": "eddyb",
        "timestamp": 1616013145
    },
    {
        "content": "<p>except in cases where we want to reserve the right to e.g. allocate or w/e</p>",
        "id": 230761443,
        "sender_full_name": "eddyb",
        "timestamp": 1616013155
    },
    {
        "content": "<p>Iterators that implement copy cause some problem but I'm having trouble coming up with the problem case</p>",
        "id": 230761470,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013177
    },
    {
        "content": "<p>my example is the problem!</p>",
        "id": 230761495,
        "sender_full_name": "eddyb",
        "timestamp": 1616013186
    },
    {
        "content": "<p>that's <em>the</em> argument for not having <code>Copy</code> on iterators</p>",
        "id": 230761534,
        "sender_full_name": "eddyb",
        "timestamp": 1616013196
    },
    {
        "content": "<p>it's something neither of us has issue with, but that <em>is</em> it</p>",
        "id": 230761554,
        "sender_full_name": "eddyb",
        "timestamp": 1616013210
    },
    {
        "content": "<p>that's one half of the problem, but it's being confused with some similar looking code that does something else, no?</p>",
        "id": 230761567,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013218
    },
    {
        "content": "<p>nothing comes to mind</p>",
        "id": 230761666,
        "sender_full_name": "eddyb",
        "timestamp": 1616013253
    },
    {
        "content": "<p>I am not aware of another argument for why iterators shouldn't be <code>Copy</code></p>",
        "id": 230761721,
        "sender_full_name": "eddyb",
        "timestamp": 1616013267
    },
    {
        "content": "<p>I thought there was a way to write it so that the <code>0..10</code> gets mutated, but there isn't an obvious way to do it without putting <code>mut</code> everywhere which gives away the game</p>",
        "id": 230761761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013290
    },
    {
        "content": "<p>there's only <code>&amp;mut</code></p>",
        "id": 230761776,
        "sender_full_name": "eddyb",
        "timestamp": 1616013301
    },
    {
        "content": "<p><em>but</em> it used to be that <code>for</code> loops desugared differently for iterators</p>",
        "id": 230761801,
        "sender_full_name": "eddyb",
        "timestamp": 1616013313
    },
    {
        "content": "<p>when we changed that to <em>always</em> call <code>IntoIterator::into_iter</code>, <em>that's when</em> my example became a problem</p>",
        "id": 230761874,
        "sender_full_name": "eddyb",
        "timestamp": 1616013337
    },
    {
        "content": "<p>because that used to compile and mutate the variable (in the old desugaring)</p>",
        "id": 230761896,
        "sender_full_name": "eddyb",
        "timestamp": 1616013347
    },
    {
        "content": "<p>I remember having a run in with this on my own type that implemented copy + iterator, but I think that was in the context of <code>iter.map(..)</code> where autoderef can hide mutation</p>",
        "id": 230761929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013360
    },
    {
        "content": "<p>autoderef can hide copies, not mutation</p>",
        "id": 230761993,
        "sender_full_name": "eddyb",
        "timestamp": 1616013377
    },
    {
        "content": "<p>I mean I wanted <code>(&amp;mut iter).map(..)</code> and got <code>{iter}.map(..)</code> so it wasn't mutated as expected</p>",
        "id": 230762102,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013428
    },
    {
        "content": "<p>yupp</p>",
        "id": 230762125,
        "sender_full_name": "eddyb",
        "timestamp": 1616013438
    },
    {
        "content": "<p>anyway my simplest suggestion to how to deal with this is <code>MustClone</code></p>",
        "id": 230762184,
        "sender_full_name": "eddyb",
        "timestamp": 1616013470
    },
    {
        "content": "<p>I don't think this issue comes up in for loops though, because there is no hidden <code>&amp;mut</code></p>",
        "id": 230762288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013512
    },
    {
        "content": "<p>you just make people call <code>.clone()</code> as today (and the type moves like today), but you're not banned from implementing <code>Copy</code> on types that contain iterator types</p>",
        "id": 230762291,
        "sender_full_name": "eddyb",
        "timestamp": 1616013514
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230762288\">said</a>:</p>\n<blockquote>\n<p>I don't think this issue comes up in for loops though, because there is no hidden <code>&amp;mut</code></p>\n</blockquote>\n<p>there's never a hidden <code>&amp;mut</code></p>",
        "id": 230762320,
        "sender_full_name": "eddyb",
        "timestamp": 1616013529
    },
    {
        "content": "<p>there <em>used to be</em></p>",
        "id": 230762327,
        "sender_full_name": "eddyb",
        "timestamp": 1616013533
    },
    {
        "content": "<p>and ironically the fact that it got removed is how we ended up in this <code>!Copy</code> mess</p>",
        "id": 230762387,
        "sender_full_name": "eddyb",
        "timestamp": 1616013558
    },
    {
        "content": "<p>There is a hidden <code>&amp;mut</code> in method calls (sometimes)</p>",
        "id": 230762390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013560
    },
    {
        "content": "<p>but that exists with <code>!Copy</code> types anyway, the concern is about <em>not</em> mutating when you <em>want to</em></p>",
        "id": 230762483,
        "sender_full_name": "eddyb",
        "timestamp": 1616013599
    },
    {
        "content": "<p>and the confusion is that the user is thinking about the <code>&amp;mut iter</code> call but rust prefers the <code>{iter}</code> call</p>",
        "id": 230762553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013613
    },
    {
        "content": "<p>right, that's the same as my <code>for</code> loops example I guess</p>",
        "id": 230762642,
        "sender_full_name": "eddyb",
        "timestamp": 1616013647
    },
    {
        "content": "<p>just a bit more subtle</p>",
        "id": 230762683,
        "sender_full_name": "eddyb",
        "timestamp": 1616013666
    },
    {
        "content": "<p>keep in mind it looks obvious because it's designed to be understood</p>",
        "id": 230762728,
        "sender_full_name": "eddyb",
        "timestamp": 1616013684
    },
    {
        "content": "<p>the difference in for loops is that it will never take a <code>&amp;mut</code>, so the user normally won't be expecting this unless they are new to rust</p>",
        "id": 230762731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616013685
    },
    {
        "content": "<p>in practice there's usually more code around</p>",
        "id": 230762781,
        "sender_full_name": "eddyb",
        "timestamp": 1616013706
    },
    {
        "content": "<p>so that makes me realize a funny thing about the range reform: which is that now I will have to write <code>(i..j).into_iter().map(|x| ...)</code> - instead of the <code>MustClone</code> approach of only making the plausibly-ambiguous situations require <code>.clone()</code> - so it's likely to have a negative ergonomic impact on the kind of code I tend to use ranges for (while both approaches letting me <code>Copy</code> structs wrapping whatever <code>i..j</code> produces)</p>",
        "id": 230763687,
        "sender_full_name": "eddyb",
        "timestamp": 1616014068
    },
    {
        "content": "<p>though I wonder if that ergonomic tradeoff is really the whole point here</p>",
        "id": 230764023,
        "sender_full_name": "eddyb",
        "timestamp": 1616014186
    },
    {
        "content": "<p>or rather, I'm worried that it may be</p>",
        "id": 230764051,
        "sender_full_name": "eddyb",
        "timestamp": 1616014197
    },
    {
        "content": "<p>I don't think the wrapper struct is the <em>only</em> motivation, I have to clone ranges for intra doc links regularly and it feels really weird</p>",
        "id": 230783479,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1616022024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230783479\">said</a>:</p>\n<blockquote>\n<p>I don't think the wrapper struct is the <em>only</em> motivation, I have to clone ranges for intra doc links regularly and it feels really weird</p>\n</blockquote>\n<p>we're all agreeing we want to be able to <code>Copy</code> ranges :P</p>",
        "id": 230787233,
        "sender_full_name": "eddyb",
        "timestamp": 1616024503
    },
    {
        "content": "<p>it's just not clear to me what adding more types achieves, other than worse ergonomics when using ranges as iterators</p>",
        "id": 230787383,
        "sender_full_name": "eddyb",
        "timestamp": 1616024596
    },
    {
        "content": "<p>if accidental copying isn't a concern, just make all the iterators <code>Copy</code> already<br>\nif it <em>really is</em> a concern, a specialized lint or even my <code>MustClone</code> idea, seem more appropriate</p>",
        "id": 230787478,
        "sender_full_name": "eddyb",
        "timestamp": 1616024658
    },
    {
        "content": "<p>However, having to now type</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mf\">10.</span><span class=\"n\">clone</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Seems equally \"things got worse\"</p>",
        "id": 230789604,
        "sender_full_name": "Lokathor",
        "timestamp": 1616025994
    },
    {
        "content": "<p>I don't think you would ever need to write that, since that's the only use of <code>0..10</code> in the code. You only need to <code>.clone()</code> if you have the range in a variable that is being reused</p>",
        "id": 230792079,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616027692
    },
    {
        "content": "<p>(also the precedence on that is wrong; hopefully clippy will point out that you are cloning <code>10</code> and not <code>0..10</code>)</p>",
        "id": 230792161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616027754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> the <code>MustClone</code> idea wouldn't affect any code that works today</p>",
        "id": 230822179,
        "sender_full_name": "eddyb",
        "timestamp": 1616052109
    },
    {
        "content": "<p>it just allows implementing <code>Copy</code> on e.g. types that wrap <code>Range</code>, or passing a <code>Range</code> to a type expecting some <code>T: Copy</code></p>",
        "id": 230822256,
        "sender_full_name": "eddyb",
        "timestamp": 1616052151
    },
    {
        "content": "<p>the name might not be ideal, but that's what it'd do</p>",
        "id": 230822264,
        "sender_full_name": "eddyb",
        "timestamp": 1616052171
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> note that I put it through crater even, and the only regressions where some crates aggressively denying lints (which, kind of ironic, lol)</p>",
        "id": 230822380,
        "sender_full_name": "eddyb",
        "timestamp": 1616052275
    },
    {
        "content": "<p>so I'm fairly confident it's backwards-compatible to do, without an edition etc.</p>",
        "id": 230822407,
        "sender_full_name": "eddyb",
        "timestamp": 1616052297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> I have to say, I'm wondering if we are rushing a bit here -- I'm worried that changing the <code>..</code> expansion will be more painful than we think, and we won't have time for 2021 to figure that out (e.g., APIs that were using <code>Range</code> would now break across editions, etc -- maybe all those APIs are generic, so it's ok, but still)</p>",
        "id": 230873206,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616077998
    },
    {
        "content": "<p>Also, the <code>#[must_clone]</code> lint feels like a good idea regardless</p>",
        "id": 230873236,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078011
    },
    {
        "content": "<p>It is useful for things like <code>Cell</code></p>",
        "id": 230873252,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078018
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> pointed out the (persuasive to me) argument that </p>\n<div class=\"codehilite\"><pre><span></span><code>let x = 1..3;\nfor elem in x { if elem == 2 { break } }\nfor elem in x { }\n</code></pre></div>\n<p>still works if <code>x</code> only implements <code>IntoIterator</code></p>",
        "id": 230873369,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078053
    },
    {
        "content": "<p>so it comes down to there being an extra field on <code>RangeInclusive</code>?</p>",
        "id": 230873391,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078059
    },
    {
        "content": "<p>this is a bit unfortunate, I admit :/</p>",
        "id": 230873445,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078078
    },
    {
        "content": "<p>I guess I haen't caught up on (e.g.) the RFC, I'm not sure how much it spells out these considerations and the reaosns to go one way or the other?</p>",
        "id": 230873558,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078109
    },
    {
        "content": "<p>I'd like to read the full case</p>",
        "id": 230873566,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078112
    },
    {
        "content": "<p>(ftr the long conversation in this backlog here started from that same snippet)</p>",
        "id": 230873735,
        "sender_full_name": "eddyb",
        "timestamp": 1616078166
    },
    {
        "content": "<p>sadly we can't collapse subthreads to make messages like that more visible :(</p>",
        "id": 230873819,
        "sender_full_name": "eddyb",
        "timestamp": 1616078199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> the RFC does discuss those points, yes</p>",
        "id": 230874549,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616078453
    },
    {
        "content": "<p>let me read it :)</p>",
        "id": 230874619,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078480
    },
    {
        "content": "<p>is it still a draft?</p>",
        "id": 230874642,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078491
    },
    {
        "content": "<p>IMO #[must_clone] is a bad fit for these types because it's saying \"hey, on the off chance that you are using your Range as an iterator, don't implicitly copy it\", but there are tons of cases where you <em>aren't</em> using your Range as an iterator</p>",
        "id": 230874647,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616078494
    },
    {
        "content": "<p>or is there a final PR now</p>",
        "id": 230874650,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078496
    },
    {
        "content": "<p>so---</p>",
        "id": 230874671,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078507
    },
    {
        "content": "<p>still a draft - I just need to fill out the user description section</p>",
        "id": 230874682,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616078512
    },
    {
        "content": "<p>Hmm</p>",
        "id": 230874683,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078513
    },
    {
        "content": "<p>One thought is that</p>",
        "id": 230874690,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078517
    },
    {
        "content": "<p>but the actual concrete proposal should be there</p>",
        "id": 230874694,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616078521
    },
    {
        "content": "<p><code>#[must_clone]</code> may not want to be applied to the <em>types</em> but more the pattern in code</p>",
        "id": 230874742,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078525
    },
    {
        "content": "<p>e.g., we could say that \"any time you do <code>for x in y</code> twice, you probably want to be explicit</p>",
        "id": 230874776,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078536
    },
    {
        "content": "<p>(where <code>y</code> is of <code>Copy</code> type)</p>",
        "id": 230874791,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078541
    },
    {
        "content": "<p>I think we probably want both</p>",
        "id": 230874795,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078546
    },
    {
        "content": "<p>but maybe <code>Range</code> is not a <code>#[must_clone]</code> type, it's just that we get the warning for this usage pattern</p>",
        "id": 230874833,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078564
    },
    {
        "content": "<p>I guess I think we decided some time back to make <code>Copy</code> mean \"POD\" as well as \"doens't move\" -- around 1.0, iirc -- on the premise that we could lint our way away from user errors</p>",
        "id": 230874913,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078595
    },
    {
        "content": "<p>sure, but that still doesn't fix the RangeInclusive API, and I'm a bit suspicious we can make a sufficiently advanced pattern recognizer in the compiler for all the relevant cases</p>",
        "id": 230874925,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616078602
    },
    {
        "content": "<p>I'm a bit worried that we are solving one niche part but not the rest</p>",
        "id": 230874931,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230874925\">said</a>:</p>\n<blockquote>\n<p>sure, but that still doesn't fix the RangeInclusive API, and I'm a bit suspicious we can make a sufficiently advanced pattern recognizer in the compiler for all the relevant cases</p>\n</blockquote>\n<p>this may be true, but then I suspect many of those patterns are of less and less importance over time</p>",
        "id": 230875004,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078634
    },
    {
        "content": "<p>a hybrid might make sense</p>",
        "id": 230875074,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078649
    },
    {
        "content": "<p>fixing <code>RangeInclusive</code> only</p>",
        "id": 230875087,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078655
    },
    {
        "content": "<p>oh, but then we introduce asymmetry</p>",
        "id": 230875110,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078663
    },
    {
        "content": "<p>which I remember also arguing against (and which I still believe)</p>",
        "id": 230875125,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078671
    },
    {
        "content": "<p>anyway, let me skim the RFC :)</p>",
        "id": 230875145,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078681
    },
    {
        "content": "<p>I mean, from a library design perspective, these types should not have implemented Iterator at any point. Some of the side effects of that design error are the Copy issue, and the RangeInclusive API issue, but we should fix the root of the problem</p>",
        "id": 230875190,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616078703
    },
    {
        "content": "<p>I'm thinking about the ergonomics of <code>(0..i).map(|i| ...)</code> I guess. I think I do that a lot.</p>",
        "id": 230875312,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078749
    },
    {
        "content": "<p><code>.into_iter()</code> is also \"ok\", I might even prefer <code>Range::into_iter(1...5).map(|i| ...)</code></p>",
        "id": 230875420,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078777
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> maybe what I'm saying is that I'm not convinced this:</p>\n<blockquote>\n<p>We do not allow iterator types to be Copy, as it can cause confusion when an implicit copy of an iterator is advanced rather than the original.</p>\n</blockquote>\n<p>ought to be a general rule. There might still be a case for range reform without that, though.</p>",
        "id": 230875573,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078847
    },
    {
        "content": "<p>(I guess we could also add <code>map</code> to the <code>IntoIterator</code> trait :)</p>",
        "id": 230875629,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078876
    },
    {
        "content": "<p>er, no, maybe not</p>",
        "id": 230875683,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078884
    },
    {
        "content": "<p>well, yes</p>",
        "id": 230875690,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078887
    },
    {
        "content": "<p>well, no, because all iterators are into-iterator, duh</p>",
        "id": 230875914,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616078983
    },
    {
        "content": "<p>I am quite skeptical of edition specific type aliases</p>",
        "id": 230876398,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079125
    },
    {
        "content": "<p>But maybe I need to get over it</p>",
        "id": 230876412,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079129
    },
    {
        "content": "<p>It feels to me like a recipe for confusion</p>",
        "id": 230876427,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079135
    },
    {
        "content": "<p>e.g., I look in some crate that is using Rust 2018 and it says <code>std::ops::Range</code>, but my crate is Rust 2021... not to mention the complications that could arise around macros and macro expansions</p>",
        "id": 230876488,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079160
    },
    {
        "content": "<p>So that specific bit isn't <em>strictly</em> necessary, but without it we just end up in a world where we have in <code>std::ops</code> <code>pub type Range&lt;T&gt; = self::range::IntoIter&lt;T&gt;;</code> which is confusing in its own right</p>",
        "id": 230876643,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616079220
    },
    {
        "content": "<p>but we can maybe fix that up in another future edition or something</p>",
        "id": 230876668,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616079229
    },
    {
        "content": "<p>well</p>",
        "id": 230876762,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079244
    },
    {
        "content": "<p>Hmm</p>",
        "id": 230876791,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079258
    },
    {
        "content": "<p>I would have said let's introduce fresh names -- and I still think that</p>",
        "id": 230876815,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079267
    },
    {
        "content": "<p>e.g., <code>Interval</code></p>",
        "id": 230876820,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079269
    },
    {
        "content": "<p>I hadn't considered that we might keep <code>Range</code> as an alias to <code>Interval::IntoIter</code></p>",
        "id": 230876863,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079284
    },
    {
        "content": "<p>certainly we could deprecate the <code>std::ops::Range</code>, though that's unfortunate because it's a nice name to use</p>",
        "id": 230876903,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079300
    },
    {
        "content": "<p>but if we picked a new name (e.g., interval) that is not a problem</p>",
        "id": 230876936,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079309
    },
    {
        "content": "<p>do type aliases work everywhere that we would need them to work? (patterns, struct initializers, I guess)</p>",
        "id": 230876979,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616079323
    },
    {
        "content": "<p>it does work in those cases, but there may be some other obscure places that don't handle aliases: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=547916139993268121354dcec98ba785\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=547916139993268121354dcec98ba785</a></p>",
        "id": 230877271,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616079426
    },
    {
        "content": "<p>re: switching to Interval, it is also confusing to go into the rustdoc for std::ops and see the <code>Range</code> type and the <code>Interval</code> type next to each other! :)</p>",
        "id": 230877450,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616079496
    },
    {
        "content": "<p>The RFC currently prioritizes minimizing API weirdness rolling forward when most people are using the 2021 edition, at the price of a bit of weirdness during the transition.</p>",
        "id": 230878191,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616079730
    },
    {
        "content": "<p>I'd like to see it extended to cover that :)</p>",
        "id": 230886955,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616082431
    },
    {
        "content": "<p>(that comparison)</p>",
        "id": 230887010,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1616082440
    },
    {
        "content": "<p>Cool, will do</p>",
        "id": 230894824,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616084492
    },
    {
        "content": "<p>rather than must_clone always, which is indeed poor, why can't we just lint when it's used in <code>for</code> loop position only?</p>",
        "id": 230898952,
        "sender_full_name": "Lokathor",
        "timestamp": 1616086172
    },
    {
        "content": "<p>Like, ignoring the RangeInclusive issue for a moment, that really seems like the simplest fix. If you use a <code>must_clone</code> any time <em>after</em> you used it in a <code>for</code> loop, you get a warning.</p>",
        "id": 230899300,
        "sender_full_name": "Lokathor",
        "timestamp": 1616086298
    },
    {
        "content": "<p>If that's really what this whole concern is about.</p>",
        "id": 230899489,
        "sender_full_name": "Lokathor",
        "timestamp": 1616086361
    },
    {
        "content": "<p>though honestly the fact that i can write</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but <strong>not</strong></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>has always seemed <em>entirely</em> silly.</p>",
        "id": 230899961,
        "sender_full_name": "Lokathor",
        "timestamp": 1616086519
    },
    {
        "content": "<p>is it any more silly than the fact that you can do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"foo\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but not</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>?</p>",
        "id": 230906500,
        "sender_full_name": "bstrie",
        "timestamp": 1616088766
    },
    {
        "content": "<p>yes. the String is about making allocations explicit, not just about making modification (to a copy) explicit</p>",
        "id": 230906737,
        "sender_full_name": "Mara",
        "timestamp": 1616088842
    },
    {
        "content": "<p>Yes, exactly as Mara said. <code>String</code> is a type that will <code>Drop</code> because it manages a memory allocation.</p>\n<p>When a person asks \"why doesn't this work?\" we can explain that there's a deallocation involved and you can't deallocate the same memory twice.</p>\n<p>and then there's this other thing that just has two integers in it. And the beginner says \"Oh, well, that's just two integers, so it doesn't have to Drop, right?\" and we must reply to them \"True, but we still don't trust that you could ever write the code properly on your own, so we still don't let you Copy that value either\".</p>",
        "id": 230909690,
        "sender_full_name": "Lokathor",
        "timestamp": 1616089913
    },
    {
        "content": "<p>IIRC the (theoretical) problem only occurs if the range is mutable -- is there something we could do just for that?</p>",
        "id": 230916162,
        "sender_full_name": "cuviper",
        "timestamp": 1616092324
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/27186#issuecomment-123390413\">https://github.com/rust-lang/rust/pull/27186#issuecomment-123390413</a></p>",
        "id": 230916181,
        "sender_full_name": "cuviper",
        "timestamp": 1616092333
    },
    {
        "content": "<p>maybe a lint for types where copying from <code>mut</code> (or <code>&amp;mut</code>)  might be unintended</p>",
        "id": 230917075,
        "sender_full_name": "cuviper",
        "timestamp": 1616092750
    },
    {
        "content": "<p>although anything that was formerly a move (without further use) might now look like a copy and trigger that</p>",
        "id": 230917225,
        "sender_full_name": "cuviper",
        "timestamp": 1616092806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/268952-edition-2021/topic/range.20reform/near/230875312\">said</a>:</p>\n<blockquote>\n<p>I'm thinking about the ergonomics of <code>(0..i).map(|i| ...)</code> I guess. I think I do that a lot.</p>\n</blockquote>\n<p>What if <code>Range</code> impl'd <code>Deref</code> to <code>RangeIter</code>? I don't think that collides with anything else, and it would probably prevent a lot of breakage of 2018 patterns like this one</p>",
        "id": 231105143,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616197562
    },
    {
        "content": "<p>How would you implement that?</p>",
        "id": 231105278,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616197661
    },
    {
        "content": "<p>oh wait, that doesn't work since you need mutable access to the iterator</p>",
        "id": 231105362,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616197703
    },
    {
        "content": "<p>you also need an instance of the iterator</p>",
        "id": 231105384,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616197733
    },
    {
        "content": "<p>It could <code>DerefMut</code> to an iterator that modifies the original <code>Range</code> but I think that's exactly the problem pattern I was talking about earlier to <span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span></p>",
        "id": 231105413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616197759
    },
    {
        "content": "<p>you can implement it if it's a transparent wrapper struct and you transmute it</p>",
        "id": 231105442,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616197799
    },
    {
        "content": "<p>But then it would not be Copy, and that would be missing a field for RangeInclusive</p>",
        "id": 231105546,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616197839
    },
    {
        "content": "<p>why wouldn't it be copy?</p>",
        "id": 231105578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616197867
    },
    {
        "content": "<p>If it was a transparent wrapper struct around a non-copy type</p>",
        "id": 231105596,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616197884
    },
    {
        "content": "<p>It's a non-copy transparent wrapper struct around a copy type</p>",
        "id": 231105608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616197902
    },
    {
        "content": "<p>if it was the other way around it'd work for Range, but not RangeInclusive</p>",
        "id": 231105612,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1616197906
    },
    {
        "content": "<p>you're right that it doesn't work for <code>a..=b</code> though</p>",
        "id": 231105618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616197913
    },
    {
        "content": "<p>alternatively, duplicate the entire iterator API <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 231105758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616198011
    },
    {
        "content": "<p>or put all that stuff on a trait</p>",
        "id": 231105831,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616198044
    },
    {
        "content": "<p>which I guess would look like the iterator API except it takes everything by <code>&amp;self</code> or maybe <code>self</code> and calls <code>into_iter()</code> first</p>",
        "id": 231105876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1616198083
    }
]