[
    {
        "content": "<p>(logically splitting off of the <code>k#keywords</code> topic)</p>\n<p>I've filed RFC 3101 (<a href=\"https://github.com/rust-lang/rfcs/pull/3101\">https://github.com/rust-lang/rfcs/pull/3101</a>) as the generalized syntactic reservation of the sort that RFC 3098 (<code>k#keywords</code>) is looking to leverage. If accepted this would no longer require RFC 3098 to be an edition change.</p>",
        "id": 232830802,
        "sender_full_name": "bstrie",
        "timestamp": 1617314254
    },
    {
        "content": "<p>I'm very much in favor of that RFC.</p>",
        "id": 232834600,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316513
    },
    {
        "content": "<p>One question:</p>",
        "id": 232834605,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316517
    },
    {
        "content": "<p>Is there any reasonable way we could <em>prevent</em> macros or similar from using such tokens if they don't actually exist in the language?</p>",
        "id": 232834647,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316542
    },
    {
        "content": "<p>I'm concerned that someone will go \"oooh, a reserved space, I can use that for my macro meta-language's tokens\".</p>",
        "id": 232834712,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316564
    },
    {
        "content": "<p>And then write something like <code>k#mykeyword</code> and then match <code>k#mykeyword</code>, or write <code>m#mything</code> and match <code>m#mything</code>.</p>",
        "id": 232834762,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316600
    },
    {
        "content": "<p>I acknowledge that the ability to do that would <em>also</em> be the ability to implement prototypes of language features as proc macros.</p>",
        "id": 232834788,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316632
    },
    {
        "content": "<p>But on the other hand, the ability to do that is also the ability to accidentally or intentionally use something in a way that'll break in the future if the language wants to use the same syntax, which is the point of reserving it.</p>",
        "id": 232834809,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316665
    },
    {
        "content": "<p>C <em>claimed</em> to reserve <code>__</code>, but in practice, many many libraries and operating systems and similar used <code>__</code> in their own \"internal use\" tokens for much the same reason C reserved it.</p>",
        "id": 232834881,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617316701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/232834712\">said</a>:</p>\n<blockquote>\n<p>I'm concerned that someone will go \"oooh, a reserved space, I can use that for my macro meta-language's tokens\".</p>\n</blockquote>\n<p>AIUI, this is partly what the existing notion of \"literal suffixes\" (linked from the RFC) are for. i.e., the lexer provides <code>\"foo\"bar</code> or <code>123qux</code> as a single token, even though that has no meaning in normal Rust code.</p>",
        "id": 232835239,
        "sender_full_name": "bstrie",
        "timestamp": 1617316954
    },
    {
        "content": "<p>Sure. But that doesn't <em>prevent</em> people from using the <code>ident#</code> or <code>ident\"</code> spaces for themselves.</p>",
        "id": 232835319,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617317020
    },
    {
        "content": "<p>Furthermore, with the aid of this RFC, we could literally carve out such a space. The prefix <code>my#</code> (or w/e) could be \"reserved for private use\" in the same way that unicode reserves the private use area: \"we give you permission to use this, and promise we never will\"</p>",
        "id": 232835420,
        "sender_full_name": "bstrie",
        "timestamp": 1617317077
    },
    {
        "content": "<p>We absolutely could, and that's not necessarily a bad idea.</p>",
        "id": 232835428,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617317091
    },
    {
        "content": "<p>At the very least, I would propose adding language like the following to the RFC:</p>\n<p>Future versions of Rust may add new interpretations of <code>&lt;identifier&gt;#&lt;identifier&gt;</code> or <code>&lt;identifier&gt;\"&lt;string contents&gt;\"</code>. The addition of such new interpretations is not considered a breaking change. This space exists for future use by the compiler, and a program using tokens in this space that are not defined by the stable Rust compiler (including via a macro) is not covered by Rust's usual guarantees of stability and forward-compatibility.</p>",
        "id": 232835469,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617317119
    },
    {
        "content": "<p>though I would want to see some motivation from macro authors to know if this would actually be useful, currently I have absolutely no idea what a real-world use case would look like</p>",
        "id": 232835496,
        "sender_full_name": "bstrie",
        "timestamp": 1617317146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/232835496\">said</a>:</p>\n<blockquote>\n<p>though I would want to see some motivation from macro authors to know if this would actually be useful, currently I have absolutely no idea what a real-world use case would look like</p>\n</blockquote>\n<p>Sure. I don't think <em>this</em> RFC should do anything in that area. Reserving the space means we <em>could</em> choose to assign some of it for such a purpose in the future.</p>",
        "id": 232835576,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617317178
    },
    {
        "content": "<p>Any objections to the above language or something similar to it? Right now the RFC doesn't clearly define what it means to \"reserve\" the syntax, other than making it parse as one token.</p>",
        "id": 232835630,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617317220
    },
    {
        "content": "<p>(I stopped using a <code> ``` </code> block for that, because it prevented wrapping and made it a pain to read.)</p>",
        "id": 232835735,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617317304
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> I posted a few suggestions regarding language.</p>",
        "id": 232837027,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617318133
    },
    {
        "content": "<p>Those suggestions aside, I think this looks good, and I'd be thrilled to propose it for merge so that we can have it available for edition planning in a timely fashion.</p>",
        "id": 232837078,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617318173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/232835496\">said</a>:</p>\n<blockquote>\n<p>though I would want to see some motivation from macro authors to know if this would actually be useful, currently I have absolutely no idea what a real-world use case would look like</p>\n</blockquote>\n<p>hey <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 232837711,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1617318508
    },
    {
        "content": "<p><span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I personally can't think of any motivation for such special tokenizations, except for wanting to polyfill the very feature that would break it <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>. To be fair, it would have to be a very <em>specific</em> DSL of sorts to ever need <code>k#&lt;ident&gt;</code> <em>without whitespace in between</em> to work (I agree with the comparison with <code>$(,)?</code> in that regard: this is breakage that in practice shouldn't be observed; and I am very curious about that crater run).</p>\n<p>As an aside, I think that macro authors know (or ought to) that they depend on Rust's lexer to operate, and that this lexer's primary purpose is obviously for the language; I'd hope that for those needing special lexing-related requirements (<em>e.g.</em>, when whitespace is semantically meaningful) they know they have the option to bundle the DSL contents / macro inout within a string literal, (or within an external file if processing it from within a <code>build.rs</code>) or the currently hacky (but which could be blessed not to be) approach of using proc-macro + fs APIs to get the source code fed to the macro (the hacky part there being the impure fs access, so the fix would thus be to offer some kind of <code>Span::source_code(&amp;Span) -&gt; String</code> API). <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 232838993,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617319406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/232834647\">said</a>:</p>\n<blockquote>\n<p>Is there any reasonable way we could <em>prevent</em> macros or similar from using such tokens if they don't actually exist in the language?</p>\n</blockquote>\n<p>Trying to use <code>r#$foo</code> in a macro argument is a tokenization error, so I think we could do that?</p>",
        "id": 232840644,
        "sender_full_name": "scottmcm",
        "timestamp": 1617320585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/232834647\">said</a>:</p>\n<blockquote>\n<p>Is there any reasonable way we could <em>prevent</em> macros or similar from using such tokens if they don't actually exist in the language?</p>\n</blockquote>\n<p>is that something we should prevent? people can already use any keyword we have in their macro for anything, right? plenty of macros match specifically on <code>let</code> and <code>for</code>, why not on <code>k#yeet</code>?</p>",
        "id": 232879197,
        "sender_full_name": "Mara",
        "timestamp": 1617355754
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> That wasn't my concern. I was worried about macros using keywords we <em>don't</em> have, or reserved syntax we don't assign a meaning to yet.</p>",
        "id": 232883653,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617358984
    },
    {
        "content": "<p>in which cases would that matter?</p>\n<p>i suppose one could match on <code>($e:expr k#yeet)</code>, which will start failing to compile if we later decide <code>k#yeet</code> can be part of an <code>expr</code>. but for simple <code>:tt</code>'s it should be fine. and for every other matcher like <code>:expr</code> we could just forbid these type of tokens afterwards, just like we already do for regular identifiers</p>",
        "id": 232883840,
        "sender_full_name": "Mara",
        "timestamp": 1617359133
    },
    {
        "content": "<p>but i don't see a problem with someone matching on <code>(k#yeet $e:expr)</code>, even if we'd at some point accept <code>k#yeet 1</code> as an <code>:expr</code>. doesn't really break anything. it might make their macro inconsistent with our meaning of <code>k#yeet</code>, but they can already to the exact same for any other existing or future keyword.</p>",
        "id": 232884033,
        "sender_full_name": "Mara",
        "timestamp": 1617359277
    },
    {
        "content": "<p>It would matter if some macro started using it and that caused us to hesitate to define a keyword because a macro in the ecosystem uses it, which would defeat the purpose of reserving the space.</p>",
        "id": 232884103,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617359314
    },
    {
        "content": "<p>That said, I've already argued that we <em>should</em> allow this, for the \"prototype via macro\" case.</p>",
        "id": 232884144,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617359356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/232884103\">said</a>:</p>\n<blockquote>\n<p>It would matter if some macro started using it and that caused us to hesitate to define a keyword because a macro in the ecosystem uses it, which would defeat the purpose of reserving the space.</p>\n</blockquote>\n<p>but that's still the case for non-prefixed keywords, right?  if someone makes a macro that makes <code>yeet</code> work that gets very popular, we'd still be hesitant to add a <code>yeet</code> that works differently.</p>",
        "id": 232884467,
        "sender_full_name": "Mara",
        "timestamp": 1617359555
    },
    {
        "content": "<p>Couldn't \"prototype via macro\" use plain <code>yeet</code>? IMO, let the reserved space be truly reserved, not even a valid <code>tt</code>. That's what made <code>r#ident</code> possible.</p>",
        "id": 232904704,
        "sender_full_name": "cuviper",
        "timestamp": 1617373587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> You know, I hadn't even thought of that?</p>",
        "id": 232930161,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617385793
    },
    {
        "content": "<p>That's a great point.</p>",
        "id": 232930173,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617385800
    },
    {
        "content": "<p>That's a very good argument for erroring at lex time on any reserved syntax Rust doesn't specifically support.</p>",
        "id": 232930420,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617385917
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> ^</p>",
        "id": 232930488,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617385937
    },
    {
        "content": "<p>I'm working on changes to the RFC now. We want to make these into lex errors, yes? Because I'm interpreting that as though <code>foo!(r#bar)</code> ought to fail to lex, but <code>r#bar</code> is valid Rust <em>outside</em> of macros today. Should I not just worry about covering that case?</p>",
        "id": 233250275,
        "sender_full_name": "bstrie",
        "timestamp": 1617669266
    },
    {
        "content": "<p>I'd say it's natural to leave that up to future work on revising the raw identifier RFC, if desired</p>",
        "id": 233250678,
        "sender_full_name": "bstrie",
        "timestamp": 1617669639
    },
    {
        "content": "<p>No, <code>r#bar</code> in a macro should be a single <code>:ident</code> token, but <code>z#bar</code> should be a lex error -- at least until we give that some meaning, and then it should do that new thing.</p>",
        "id": 233260710,
        "sender_full_name": "cuviper",
        "timestamp": 1617678581
    },
    {
        "content": "<p>if we make them lexing errors, that means we don't just break (proc) macros that use a # or \"\" prefix in their syntax, but we also make it impossible for them to fix it. a proc macro that accepts <code>(f\"asdf\")</code> right now would just stop working entirely, instead of just passsing <code>f\"asdf\"</code> as one token instead of two (which the proc macro author can still work with).</p>",
        "id": 233313302,
        "sender_full_name": "Mara",
        "timestamp": 1617713836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> that's a good point too. They do have one fix available, to space out their tokens (<code>f \"asdf\"</code>), but I can see how that's distasteful. I guess if we do want to let this be lexed, it needs to be in such a way that it won't break when the language gives that same syntax a real meaning.</p>",
        "id": 233349022,
        "sender_full_name": "cuviper",
        "timestamp": 1617726201
    },
    {
        "content": "<p>so if we make it one token, it needs to be one token forevermore</p>",
        "id": 233349347,
        "sender_full_name": "cuviper",
        "timestamp": 1617726323
    },
    {
        "content": "<p>And reserved tokens should probably only be allowed as a raw <code>:tt</code>, and possibly not allowed in the follow sets of other macro types</p>",
        "id": 233349415,
        "sender_full_name": "cuviper",
        "timestamp": 1617726355
    },
    {
        "content": "<p>(btw the space to make it lex again is still visible in .source_text() and in the span location, so that would break hacky macros like <code>inline-python</code>)</p>",
        "id": 233351741,
        "sender_full_name": "Mara",
        "timestamp": 1617727297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/233313302\">said</a>:</p>\n<blockquote>\n<p>if we make them lexing errors, that means we don't just break (proc) macros that use a # or \"\" prefix in their syntax, but we also make it impossible for them to fix it. a proc macro that accepts <code>(f\"asdf\")</code> right now would just stop working entirely, instead of just passsing <code>f\"asdf\"</code> as one token instead of two (which the proc macro author can still work with).</p>\n</blockquote>\n<p>\"impossible to fix\" seems a bit harsh, given that rustfix seems capable of automatically turning that into <code>f \"asdf\"</code>. I don't find that be particularly distasteful, but note that anyone who doesn't want to employ whitespace would still be capable of using literal <em>suffixes</em> here, which are already more-or-less reserved for use by macros: <a href=\"https://doc.rust-lang.org/reference/tokens.html#suffixes\">https://doc.rust-lang.org/reference/tokens.html#suffixes</a> . So another possible migration would be <code>f\"asdf\"</code> -&gt; <code>\"asdf\"f</code>.</p>",
        "id": 233394875,
        "sender_full_name": "bstrie",
        "timestamp": 1617744977
    },
    {
        "content": "<p>WRT to macros that find hacky ways to observe significant whitespace, I have to assume that the developers understand that's an unsupported use of the macro system. it feels analogous to saying that proc_macro::TokenStream isn't powerful enough so you code directly against the rustc AST; that's deliberately eschewing stable abstractions in favor of unstable ones, so caveat emptor. anyone who wants to losslessly embed another language in macros needs to be using strings; even the <code>asm!</code> macro doesn't get a free pass here.</p>",
        "id": 233395725,
        "sender_full_name": "bstrie",
        "timestamp": 1617745439
    },
    {
        "content": "<p>huh, I had no idea that arbitrary suffixes are already permitted</p>",
        "id": 233396770,
        "sender_full_name": "cuviper",
        "timestamp": 1617746032
    },
    {
        "content": "<p>I didn't until I started writing this RFC, and I'm pretty sure almost nobody else does too; that's why I link it multiple times in my RFC :P</p>",
        "id": 233397626,
        "sender_full_name": "bstrie",
        "timestamp": 1617746431
    },
    {
        "content": "<p>Thanks for working on this, @bstrie.</p>",
        "id": 233397715,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617746474
    },
    {
        "content": "<blockquote>\n<p>\"impossible to fix\" seems a bit harsh, given that rustfix seems capable of automatically turning that into <code>f \"asdf\"</code></p>\n</blockquote>\n<p>I have several proc macros for which that's a breaking change, where <code>f \"asdf\"</code> is not the same as <code>f\"asdf\"</code>. and it's not weird at all to expect macros that would make things like <code>c\"asdf\"</code> or whatever work as a 'polyfill'. for keywords like <code>k#yeet</code> the argument was that macros could just use <code>yeet</code> itself. but for these we're not using the prefix as a temporary placeholder until an edition change. so that argument doesn't hold here.</p>",
        "id": 233436712,
        "sender_full_name": "Mara",
        "timestamp": 1617775881
    },
    {
        "content": "<p>and even for macros that aren't looking at whitespace, there's a ton of macros that implement some DSL, possibly containing things like <code>f\"asdf\"</code> or <code>c\"asdf\"</code> etc. adding spaces there even though that's not the syntax in the language they're implementing/imitating is far from great.</p>",
        "id": 233436814,
        "sender_full_name": "Mara",
        "timestamp": 1617775962
    },
    {
        "content": "<p>Basic question here: why do <code>&lt;prefix&gt;#&lt;ident&gt;</code> and <code>&lt;prefix&gt;\"…\"</code> &amp; <code>&lt;prefix&gt;'…'</code> have to feature the same lexing behavior? To me, the latter (pair) is an extended way to feature \"enhanced literals\", this time using prefixes rather than suffixes. These literals, should they be given meaning, would expand to stand-alone expressions. This means that there is no problem in letting them be tokenized as <code>:tt</code>s  that are also compatible with <code>:expr</code> captures (and no other high-level capture).</p>\n<p>The problem lies in <code>&lt;prefix&gt;#&lt;ident&gt;</code>. If these are given, for instance, raw keyword meaning, they could become valid <code>:expr</code> (or any other capture) prefixes (say, <code>k#trust_me</code>), but they could also become invalid <code>:expr</code> prefixes (say <code>k#typeof</code>). This is what could be breaking in the future, and why it should cause compilation errors when trying to match these against such captures (≠ fallbacking to the following rule!). Since such a behavior may seem complex to express understand, the simplified \"lexing error\" suffices to ensure these properties.</p>\n<p>Thus, there is legitimate motivation to make <code>&lt;prefix&gt;#&lt;ident&gt;</code> be a lexing error while unassigned, but I fail to see such motivation also apply to / extend to prefixed quoted literals, similar to how there is no lexing error when using suffixed (quoted) literals: has anyone an example of some prefixed quoted literal that may end up not having <code>:expr</code> semantics only? (maybe with also <code>:literal</code>)</p>",
        "id": 233479791,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1617799439
    },
    {
        "content": "<p>Sure, I can easily imagine some uses that aren't all the same token type. <code>rust_ident\"with-non-ident-chars\"</code>.</p>",
        "id": 233523793,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617814101
    },
    {
        "content": "<p>(not advocating, just hypothesizing)</p>",
        "id": 233523879,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617814144
    },
    {
        "content": "<p>Quasiquoters. Compile-time <code>format!</code> to produce an ident.</p>",
        "id": 233524284,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617814296
    },
    {
        "content": "<p>Much of the point of reserving these areas of syntax is to let us define them arbitrarily in the future, without worrying about any conflicts with existing code, including macros.</p>",
        "id": 233524453,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617814358
    },
    {
        "content": "<p>So by erroring in tokenization if we see something we don't understand, we prevent a macro from using that area of syntax in a way that will conflict with rust's own future usage.</p>",
        "id": 233524537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617814393
    },
    {
        "content": "<p>One of the things that had me excited for the <code>ident\"string\"</code> form was that I've always thought it odd that <code>a\"xyz\"</code> and <code>b\"xyz\"</code> tokenize differently.  I think I could get behind the idea that we say those tokenize as one token and will always be <code>:literal</code>s -- but that if they actually expand into a use of use a token in rust then they error if not yet given a defined meaning.</p>\n<p>Though that argument only applies to the string-literal format, where I think the precedent of how we'd use it is pretty strong already.  Something like <code>k#yolo</code> I think the tokenization error is probably best.</p>",
        "id": 233534538,
        "sender_full_name": "scottmcm",
        "timestamp": 1617818343
    },
    {
        "content": "<p>I'm happy to revise the RFC to say that <code>foo#bar</code> is a tokenization error whereas <code>foo\"bar\"</code>, <code>foo'x'</code>, and <code>foo#123</code> will produce a single token but otherwise fail to parse, although if people think that they should match something other than <code>:tt</code> (<code>:expr</code>, etc... I've never heard of <code>:literal</code> before) then speak up with an exhaustive list, because I have no opinion there.</p>",
        "id": 233573565,
        "sender_full_name": "bstrie",
        "timestamp": 1617834866
    },
    {
        "content": "<p>I personally still think all four should produce a tokenization error if they're not yet defined in Rust syntax.</p>",
        "id": 233580228,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617838986
    },
    {
        "content": "<p>That said, I'd <em>also</em> be fine with only doing that tokenization-time-error on Rust 2021, if doing so would break 2018 and 2015 and we could otherwise make this change.</p>",
        "id": 233580257,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617839022
    },
    {
        "content": "<p>I'm also fine with it being a tokenization error in this RFC, since we can always loosen things later if we want.</p>",
        "id": 233583323,
        "sender_full_name": "scottmcm",
        "timestamp": 1617841076
    },
    {
        "content": "<p>it seemed simple at first, but the prefixed string literals are pretty tricky. <code>r\"\\\"</code> is a valid token/literal. <code>\"\\\"</code> is not. how about <code>fr\"\\\"</code>? regardless of whether we want that to give an error or not because of the prefix, we still need to know if we should interpret that second <code>\"</code> as the end or as an escaped <code>\"</code> inside the literal. otherwise we can't even continue tokenizing.</p>",
        "id": 233786335,
        "sender_full_name": "Mara",
        "timestamp": 1617957422
    },
    {
        "content": "<p>I've made a PR for a crater run: <a href=\"https://github.com/rust-lang/rust/pull/84037\">https://github.com/rust-lang/rust/pull/84037</a></p>",
        "id": 233842457,
        "sender_full_name": "Julian-Wollersberger",
        "timestamp": 1617981854
    },
    {
        "content": "<p>I took some shortcuts while implementing that, like it errors on all editions and also considers <code>ident#</code> followed by _anything_ illegal. But should be good enough for crater</p>",
        "id": 233842748,
        "sender_full_name": "Julian-Wollersberger",
        "timestamp": 1617981968
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/233573565\">said</a>:</p>\n<blockquote>\n<p>I'm happy to revise the RFC to say that <code>foo#bar</code> is a tokenization error whereas <code>foo\"bar\"</code>, <code>foo'x'</code>, and <code>foo#123</code> will produce a single token but otherwise fail to parse, </p>\n</blockquote>\n<p>If it fails to parse, it should be irrelevant how many tokens it produces. (Aside from error recovery)</p>",
        "id": 233843089,
        "sender_full_name": "Julian-Wollersberger",
        "timestamp": 1617982105
    },
    {
        "content": "<blockquote>\n<p>If it fails to parse, it should be irrelevant how many tokens it produces.</p>\n</blockquote>\n<p>no, this is relevant for macros. you could still do <code>a!(foo\"bar\")</code> even if <code>foo\"abc\"</code> never parses as (part of) an expression/item/anything.</p>",
        "id": 233845789,
        "sender_full_name": "Mara",
        "timestamp": 1617983080
    },
    {
        "content": "<p>(assuming parsing here means the tokens-&gt;ast conversion, not file-&gt;tokens)</p>",
        "id": 233845891,
        "sender_full_name": "Mara",
        "timestamp": 1617983132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/233786335\">said</a>:</p>\n<blockquote>\n<p>it seemed simple at first, but the prefixed string literals are pretty tricky. <code>r\"\\\"</code> is a valid token/literal. <code>\"\\\"</code> is not. how about <code>fr\"\\\"</code>? regardless of whether we want that to give an error or not because of the prefix, we still need to know if we should interpret that second <code>\"</code> as the end or as an escaped <code>\"</code> inside the literal. otherwise we can't even continue tokenizing.</p>\n</blockquote>\n<p>I agree that this is an interesting problem. But we know we'd be giving a hard error either way, so this is more a quality-of-implementation issue regarding our ability to continue on and give more errors, rather than a correctness issue.</p>",
        "id": 233869366,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617992862
    },
    {
        "content": "<p>And there are heuristics we could <em>potentially</em> use if we think the error messages are too awful. \"If prefix identifier has an 'r' in it, and we failed to tokenize, and we have a <code>\\\"</code>...\"</p>",
        "id": 233869523,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617992922
    },
    {
        "content": "<p>But to a first approximation, this is \"how good is the error message for code that shouldn't successfully lex\".</p>",
        "id": 233869576,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1617992946
    },
    {
        "content": "<p>i'm no longer convinced we should reserve all prefixes for string literals, since we can't even tokenize those properly if we don't know what the prefix means for the escaping. i originally wanted to just make <code>f\"..\"</code> parse as one token, such that we could turn it into a format_args!() shortcut later if we want to. that could still tokenize just fine. (maybe it'd also have <code>fr\"..\"</code> just like <code>br\"..\"</code>) but erroring on <code>xyz\"..\"</code> for no specific reason while breaking any proc macros that use that kind of syntax doesn't seem like a good idea.</p>",
        "id": 233884379,
        "sender_full_name": "Mara",
        "timestamp": 1617999454
    },
    {
        "content": "<p>Hmmm. We could reserve [a-z]\"...\", on the assumption that nothing else will tokenize differently other than <code>r</code>.</p>",
        "id": 233889364,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618002057
    },
    {
        "content": "<p>Is that a safe assumption? Suppose we had format literals like <code>f\"2 + 2 = {2 + 2}\"</code>. Would that be one token?</p>",
        "id": 233979513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618082014
    },
    {
        "content": "<p>If a token can contain zero or more (parsed!) expressions, it's really stretching the definition of what a token is</p>",
        "id": 233979589,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618082074
    },
    {
        "content": "<p>and to be clear, the reason why a non-format-string aware tokenization could get confused is because of examples where unescaped strings appear in the expression, like <code>f\"a = {String::new(\"a\")}\"</code></p>",
        "id": 233979780,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618082244
    },
    {
        "content": "<p>Can you elaborate on what the tokenizing problem is? Here's what I have as the grammar for the string literal reservation:</p>\n<blockquote>\n<p>RESERVED_STRING_LITERAL : IDENTIFIER_OR_KEYWORD RAW_BYTE_STRING_LITERAL | IDENTIFIER_OR_KEYWORD BYTE_STRING_LITERAL | IDENTIFIER_OR_KEYWORD&lt;sub&gt;Except <code>b</code>&lt;/sub&gt; RAW_STRING_LITERAL | IDENTIFIER_OR_KEYWORD&lt;sub&gt;Except <code>b</code>, <code>r</code>, <code>br</code>&lt;/sub&gt; STRING_LITERAL</p>\n</blockquote>\n<p>Now my BNF is rusty so let me know if that looks bogus to anyone (I'm lifting the curious \"Except\" clauses from elsewhere in the reference, so at least there's precedence). But it hopefully answers your questions: <code>fr\"\\\"</code> would be reserved as an identifier <code>f</code> prefixing a raw string literal <code>r\"\\\"</code>; <code>x\"\\\"</code> would not  be reserved, at least not until it encounters a closing <code>\"</code>, and if it doesn't ever encounter a closing <code>\"</code> then your macro already doesn't compile today.</p>\n<p>So yes, this RFC implicitly assumes that to make a raw string you will need to <em>end</em> your identifier in <code>r</code>, or else you will have a non-raw string. I think this is acceptable; the precedence of <code>b</code> combining gracefully with <code>r</code> suggest to me that we'd want such reasonable intermixing as ought to be allowed, and furthermore that <code>r</code> <em>should</em> always be the last character in the prefix if you want a raw string, due to the optional <code>#</code>s.</p>",
        "id": 233979879,
        "sender_full_name": "bstrie",
        "timestamp": 1618082339
    },
    {
        "content": "<p>I would expect format strings <code>f\"blah\"</code> to parse as strings, and <code>fr\"blah\"</code> to parse as raw strings</p>",
        "id": 233979986,
        "sender_full_name": "bstrie",
        "timestamp": 1618082442
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/233979780\">said</a>:</p>\n<blockquote>\n<p>and to be clear, the reason why a non-format-string aware tokenization could get confused is because of examples where unescaped strings appear in the expression, like <code>f\"a = {String::new(\"a\")}\"</code></p>\n</blockquote>\n<p>I think that under the current proposal that example wouldn't lex; it would have to be written as <code>f\"a = { String::from(\\\"a\\\") }\"</code> or <code>fr#\"a = { String::from(\"a\") }\"#</code></p>\n<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/233979879\">said</a>:</p>\n<blockquote>\n<p>So yes, this RFC implicitly assumes that to make a raw string you will need to <em>end</em> your identifier in <code>r</code>, or else you will have a non-raw string. I think this is acceptable</p>\n</blockquote>\n<p>I think it is acceptable too, but it should still be noted as a limitation: words that end in <code>r</code> will be confusing to use and will thus have to be avoided: <code>bar\"\\n\"</code></p>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/233979780\">said</a>:</p>\n<blockquote>\n<p>If a token can contain zero or more (parsed!) expressions, it's really stretching the definition of what a token is</p>\n</blockquote>\n<p>If we are talking about the token <em>tree</em> that a macro can see, then there is already precedence for <em>parsed</em> AST nodes such as <code>1 + 1</code> to appear as a single token tree to (nested) macro( invocation)s when the node ends up captured within a higher-level metavariable, such as <code>:expr</code>. That's the magic of invisible delimiters.</p>\n<p>So, yes, things like <code>f\"Hello, {world}!\"</code> could be lexed as a single token (tree) even if such token tree ends up being <code>⌈ ::std::format!(\"Hello, {world}!\", world = world) ⌉</code> where I am using <code>⌈</code> and <code>⌉</code> to denote the invisible delimiters.</p>",
        "id": 234000320,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1618099712
    },
    {
        "content": "<p>I'll add a note about these implicit assumptions in the RFC.</p>",
        "id": 234004891,
        "sender_full_name": "bstrie",
        "timestamp": 1618104716
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> ---</p>",
        "id": 234207933,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252300
    },
    {
        "content": "<p>we were talking about reserved prefixes for idents and literals in the edition 2021 planning meeting today</p>",
        "id": 234207961,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252313
    },
    {
        "content": "<p>it seems like one of the agenda items that is most 'at risk'</p>",
        "id": 234207973,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252321
    },
    {
        "content": "<p>I was thinking it'd be nice to have a summary of the current state and what is being considered</p>",
        "id": 234208051,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252339
    },
    {
        "content": "<p>I'm going to whip up a hackmd</p>",
        "id": 234208080,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252350
    },
    {
        "content": "<p>also cc <span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> of course, sorry</p>",
        "id": 234208104,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252358
    },
    {
        "content": "<p>The RFC only needs one more checkbox: <a href=\"https://github.com/rust-lang/rfcs/pull/3101\">https://github.com/rust-lang/rfcs/pull/3101</a>   But I do have some concerns, see also the comment there and the discussion in the zulip thread here.</p>",
        "id": 234208280,
        "sender_full_name": "Mara",
        "timestamp": 1618252426
    },
    {
        "content": "<p>I <a href=\"https://hackmd.io/gK4dEyh5TgmnVfFyJL6e5Q\">created this hackmd</a></p>",
        "id": 234208664,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252562
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> it has a few questions for you</p>",
        "id": 234208716,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/234208051\">said</a>:</p>\n<blockquote>\n<p>I was thinking it'd be nice to have a summary of the current state and what is being considered</p>\n</blockquote>\n<p>The only option being considered at this time is whether encountering a reserved prefix should result in a pre-tokenization error or a post-tokenization error, i.e. whether macros should be able to consume the prefixed item (but not use it literally).</p>\n<p>There is one thing that I've been meaning to make more explicit in the text: that any string prefix ending in <code>r</code> is tokenized as a raw string would be, whereas any string prefix not ending in <code>r</code> is tokenized as a non-raw string would be. Currently it just implicitly assumes that new string prefixes will want \"compose\" in the same manner as <code>b</code> and <code>r</code> (so a hyptothetical format string might be written <code>f\"\"</code>, with <code>fr\"\"</code> for the raw version), even though it reserves the full space of literals, which could throw a wrench in, for example, <code>november\"foo\"</code> tokenizing differenly from <code>july\"foo\"</code>.</p>",
        "id": 234209434,
        "sender_full_name": "bstrie",
        "timestamp": 1618252878
    },
    {
        "content": "<p>I'd be in favor of that</p>",
        "id": 234209623,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252956
    },
    {
        "content": "<p>I should add that as a variant</p>",
        "id": 234209641,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618252962
    },
    {
        "content": "<p>ah, one catch</p>",
        "id": 234209726,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618253003
    },
    {
        "content": "<p>I think byte strings also have some conditions</p>",
        "id": 234209736,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618253007
    },
    {
        "content": "<p>I would be ok with moving those out from the tokenizer to the parser though, personally</p>",
        "id": 234209754,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618253015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> take a look at <a href=\"https://hackmd.io/gK4dEyh5TgmnVfFyJL6e5Q\">the hackmd</a> and let me know if anything is missing/misleading from your pov</p>",
        "id": 234209923,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618253094
    },
    {
        "content": "<p>Also cc <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> and <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> about <a href=\"https://github.com/rust-lang/rfcs/pull/3101\">https://github.com/rust-lang/rfcs/pull/3101</a></p>",
        "id": 234209984,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618253121
    },
    {
        "content": "<p>Oh, interesting.  I would have thought it was already a parser error, but it does look like it's a tokenization-time error now <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b53f34c2e811e51d0faaf2a1257d9405\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b53f34c2e811e51d0faaf2a1257d9405</a></p>",
        "id": 234215240,
        "sender_full_name": "scottmcm",
        "timestamp": 1618255334
    },
    {
        "content": "<p>I want to raise one other question</p>",
        "id": 234215529,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255465
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> was concerned because he doesn't want us to get in the situation where we have stated that we reserve this syntax, but because it is in use by popular procedural macros we are reluctant to claim it</p>",
        "id": 234215569,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255491
    },
    {
        "content": "<p>I think that's a reasonable concern, and tokenization errors help to prevent it</p>",
        "id": 234215597,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255497
    },
    {
        "content": "<p>however, I think it's also true that so long as macro-rules doesn't really accept the form</p>",
        "id": 234215623,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255510
    },
    {
        "content": "<p>we don't have to worry that much</p>",
        "id": 234215635,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255515
    },
    {
        "content": "<p>e.g., if I am writing a procedural macro, and I am using (say) <code>syn</code> to parse rust code, it will not accept the new forms until I upgrade to a newer syn</p>",
        "id": 234215680,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255533
    },
    {
        "content": "<p>so existing code using said DSL will continue to work even if we've claimed the syntax, i believe</p>",
        "id": 234215709,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255555
    },
    {
        "content": "<p>(the main danger I can see would be that someone <em>attempts</em> to parse the code as an expression, or whatever, and expects that parsing to fail on the new syntax so they can apply their fallback)</p>",
        "id": 234215768,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255572
    },
    {
        "content": "<p>am I missing something?</p>",
        "id": 234215790,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618255581
    },
    {
        "content": "<p>So, in the interests of getting this reservation into the edition...</p>",
        "id": 234894192,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595090
    },
    {
        "content": "<p>Perhaps we should just <em>drop</em> the reservation of string constants, for the time being?</p>",
        "id": 234894254,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595116
    },
    {
        "content": "<p>Let's get an RFC accepted for <code>k#keyword</code>, in a timely fashion, and continue considering strings in parallel.</p>",
        "id": 234894297,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595142
    },
    {
        "content": "<p>I don't want to block the former on resolution of the latter.</p>",
        "id": 234894312,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595149
    },
    {
        "content": "<p>Does that mean it should also drop <code>foo'a'</code>?  And what about <code>foo#123</code>?</p>\n<p>My instinct is to keep the number version but not the character or string version, but I haven't thought that through in depth.</p>",
        "id": 234894709,
        "sender_full_name": "scottmcm",
        "timestamp": 1618595321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> i think it's already resolved? the rfc is just waiting for fcp now.</p>",
        "id": 234894996,
        "sender_full_name": "Mara",
        "timestamp": 1618595443
    },
    {
        "content": "<p>Ah! Re-checking now.</p>",
        "id": 234895251,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595542
    },
    {
        "content": "<p>it now considers <code>bar\"..\"</code> a raw string literal, just like <code>br\"..\"</code>. and like niko said we can move any validation that are specific to byte strings or other types of string (escape sequences like <code>\\x..</code> or <code>\\u..</code> or non-ascii characters) from the lexer to the parser.</p>",
        "id": 234895490,
        "sender_full_name": "Mara",
        "timestamp": 1618595641
    },
    {
        "content": "<p>...that is not how I would have expected that to be resolved.</p>",
        "id": 234895739,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595740
    },
    {
        "content": "<p>I personally would have expected to see it resolved by just saying \"if we see a string prefix we don't recognize, we'll make a best effort to proceed, but the most we can guarantee is an error on that unknown prefix\".</p>",
        "id": 234895895,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595804
    },
    {
        "content": "<p>what about hash-bracketed string literals?  <code>foo####\"...\"####</code></p>",
        "id": 234895978,
        "sender_full_name": "cuviper",
        "timestamp": 1618595844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> <code>keyword#\"</code> should probably be reserved as well. But I really don't want to turn this into a katamari of all possible syntax reservations and prevent it from making progress.</p>",
        "id": 234896207,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618595940
    },
    {
        "content": "<p>understood</p>",
        "id": 234896360,
        "sender_full_name": "cuviper",
        "timestamp": 1618596002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/234895978\">said</a>:</p>\n<blockquote>\n<p>what about hash-bracketed string literals?  <code>foo####\"...\"####</code></p>\n</blockquote>\n<p>that needs an <code>r</code>. (<code>bar\"..\"</code> is just a prefix of <code>ba</code> on a raw string literal.)</p>",
        "id": 234896620,
        "sender_full_name": "Mara",
        "timestamp": 1618596074
    },
    {
        "content": "<blockquote>\n<p>we'll make a best effort to proceed</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> but then (proc) macros can't rely on these things tokenizing, which was the point of the change</p>",
        "id": 234896712,
        "sender_full_name": "Mara",
        "timestamp": 1618596114
    },
    {
        "content": "<p>ah, I didn't realize the <code>r</code> was effectively special at the end of any prefix</p>",
        "id": 234897082,
        "sender_full_name": "cuviper",
        "timestamp": 1618596236
    },
    {
        "content": "<p>yeah we have <code>br\"...\"</code> but not <code>rb\"..\"</code></p>",
        "id": 234897159,
        "sender_full_name": "Mara",
        "timestamp": 1618596255
    },
    {
        "content": "<p>sure, but I thought of <code>br</code> as a unit, not <code>b</code>+<code>r\"...\"</code></p>",
        "id": 234897254,
        "sender_full_name": "cuviper",
        "timestamp": 1618596300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/234896712\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>we'll make a best effort to proceed</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> but then (proc) macros can't rely on these things tokenizing, which was the point of the change</p>\n</blockquote>\n<p>I think I'm confused. I thought the notion was that we were just not going to commit to it being a <em>lexer</em> error, but that it was still going to be an error later in the compiler.</p>",
        "id": 234897333,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596334
    },
    {
        "content": "<p>it will still not parse. <code>bar\"..\"</code> will give an error about an unknown prefix when parsed. but <code>some_macro! { bar\"..\" }</code> can compile fine.</p>",
        "id": 234897483,
        "sender_full_name": "Mara",
        "timestamp": 1618596386
    },
    {
        "content": "<p>(with <code>$_:tt</code>)</p>",
        "id": 234897511,
        "sender_full_name": "Mara",
        "timestamp": 1618596398
    },
    {
        "content": "<p>(or <code>TokenStream</code>)</p>",
        "id": 234897527,
        "sender_full_name": "Mara",
        "timestamp": 1618596406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/234897254\">said</a>:</p>\n<blockquote>\n<p>sure, but I thought of <code>br</code> as a unit, not <code>b</code>+<code>r\"...\"</code></p>\n</blockquote>\n<p>yeah right now both flags are used by the lexer (it rejects <code>b\"å\"</code> or <code>b\"\\u{1234}\"</code> for example). but the checks for such escape codes and non-ascii characters can also happen in the parser, and then the only flag relevant for tokenizing is the final <code>r</code></p>",
        "id": 234897909,
        "sender_full_name": "Mara",
        "timestamp": 1618596572
    },
    {
        "content": "<p>So, a macro can <em>eat</em> it, but can a macro actually <em>parse</em> it?</p>",
        "id": 234898090,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596647
    },
    {
        "content": "<p>proc macros only ever get tokens which they have to parse themselves..</p>",
        "id": 234898124,
        "sender_full_name": "Mara",
        "timestamp": 1618596668
    },
    {
        "content": "<p>and a regular macro can only match it as <code>:tt</code></p>",
        "id": 234898143,
        "sender_full_name": "Mara",
        "timestamp": 1618596677
    },
    {
        "content": "<p>Would a regular macro be able to match it directly? <code>(k#foo a b c) =&gt; { ... handle k#foo }</code> ?</p>",
        "id": 234898200,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596716
    },
    {
        "content": "<p>I can potentially see value in a macro being able to eat-and-throw-away something unknown, if only so that we can have macros like <code>cfg_if!</code> throw away things unparsed (such as if the cfg controls use of a nightly-only feature).</p>",
        "id": 234898342,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618596766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/234898200\">said</a>:</p>\n<blockquote>\n<p>Would a regular macro be able to match it directly? <code>(k#foo a b c) =&gt; { ... handle k#foo }</code> ?</p>\n</blockquote>\n<p>sure. just like any other token, yeah.</p>",
        "id": 234898385,
        "sender_full_name": "Mara",
        "timestamp": 1618596787
    },
    {
        "content": "<p>You raised the objection on the thread; are you primarily concerned with existing macros that parse syntaxes like <code>ident\"string\"</code>?</p>",
        "id": 234898936,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618597003
    },
    {
        "content": "<p>Because if that's the concern, I'd just as soon drop those from the reservation, if that means we can actually <em>reserve</em> <code>k#</code> in a \"not even with a macro\" way.</p>",
        "id": 234899006,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618597038
    },
    {
        "content": "<p>I feel like this has gotten several things added to it, and then the added things turned out to generate conflicts, so we weakened the reservation mechanism to accommodate those added things...</p>",
        "id": 234899079,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618597070
    },
    {
        "content": "<p>yes, mostly concerned about macros implementing some (DS)L with syntax like <code>f\"...\"</code> or <code>c\"...\"</code> or whatever. reserving <code>abc#xyz</code> is also a bit of a problem because of <code>quote !{}</code> using # for placeholders, but adding  a space there (through rustfix)  works.</p>",
        "id": 234899446,
        "sender_full_name": "Mara",
        "timestamp": 1618597216
    },
    {
        "content": "<p>you know...</p>",
        "id": 234975179,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618651693
    },
    {
        "content": "<p>I was wondering about <code>ident#\"foo\"#</code> too</p>",
        "id": 234975193,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618651727
    },
    {
        "content": "<p>I had just sort of assumed we would parse that as a raw string or what have you, but I guess we could opt for lexer error</p>",
        "id": 234975214,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618651751
    },
    {
        "content": "<p>it's not very obvious I suppose.</p>",
        "id": 234975225,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618651774
    },
    {
        "content": "<p>I would expect that it would permit the use of <code>\"</code> inside</p>",
        "id": 234975232,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618651785
    },
    {
        "content": "<p>but I'm not sure if I would expect <code>\\n</code> and friends to stop working</p>",
        "id": 234975236,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1618651798
    },
    {
        "content": "<p>I think it would be strange for any form of raw strings to not resemble <code>r\"</code>. As I've mentioned, my mental model is that string literal prefixes are compositional.</p>",
        "id": 235006110,
        "sender_full_name": "bstrie",
        "timestamp": 1618682188
    },
    {
        "content": "<p>if people would like me to separate out each reservation into different RFCs, then I'm willing to do so. However, I don't quite understand what the theoretical objection is with the current draft RFC.</p>",
        "id": 235006156,
        "sender_full_name": "bstrie",
        "timestamp": 1618682268
    },
    {
        "content": "<p>another option is that if you want <code>ident#foo</code> to be a pre-tokenization error, and <code>ident\"foo</code> to be a post-tokenization error, then that would also be possible. but to reiterate, I don't foresee any potential conflict between allowing <code>foo#bar</code> to <em>lex</em> now and making <code>foo#bar</code> <em>parse</em> later.</p>",
        "id": 235006259,
        "sender_full_name": "bstrie",
        "timestamp": 1618682378
    },
    {
        "content": "<p>I'm in favor of Niko's current proposal: we keep the reservation RFC as it was before, with lexer errors for unknown syntax, but we carve out the bits that existing crates use and allow them to tokenize and pass through to macros, and only error on those at parse time.</p>",
        "id": 235033622,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1618709619
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/233397626\">said</a>:</p>\n<blockquote>\n<p>I didn't until I started writing this RFC, and I'm pretty sure almost nobody else does too; that's why I link it multiple times in my RFC <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>\n</blockquote>\n<p>FWIW, I actually used this feature pretty recently in a macro to accept <code>1D</code>, <code>2D</code>, and <code>3D</code> as parameters. <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 236177704,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1619445327
    },
    {
        "content": "<p>Hi all. I'm interested in implementing this (if nobody has started earlier), but I have some questions. Hope here is the right place to ask.</p>\n<ol>\n<li>\n<p>The RFC says <code>foo# bar</code> is three tokens. But currently <code>r# bar</code> failed with <code>found invalid character</code>. I think it is weird, isn't it? I wonder whether the error is intended or a fix is needed.</p>\n</li>\n<li>\n<p>It seems the RFC does not describe some corner cases clearly. I give my expected results for them below, am I correct?</p>\n</li>\n</ol>\n<ul>\n<li>\n<p><code>foo## bar</code><br>\n    4 tokens <code>foo</code>, <code>#</code>, <code>#</code>, <code>bar</code> (NOTE: However,<code>r## bar</code> cannot compile now.)</p>\n</li>\n<li>\n<p><code>foo#! bar</code><br>\n    4 tokens <code>foo</code>,  <code>#</code>, <code>!</code>, <code>bar</code> (NOTE: However, <code>r#! bar</code> cannot compile now.)</p>\n</li>\n<li>\n<p><code>foo##! bar</code><br>\n    5 tokens <code>foo</code>, <code>#</code>, <code>#</code>, <code>!</code>, <code>bar</code> (NOTE: However, <code>r##! bar</code> cannot compile now.)</p>\n</li>\n<li>\n<p><code>foo##\" bar</code><br>\n    error: reserved prefixes</p>\n</li>\n<li>\n<p><code>foo##bar</code><br>\n    error: reserved prefixes</p>\n</li>\n<li>\n<p><code>r#foo#bar</code><br>\n    error: reserved prefixes</p>\n</li>\n<li>\n<p><code>r\"foo\"#bar</code><br>\n    3 tokens <code>\"foo\"</code>, <code>#</code>, <code>bar</code></p>\n</li>\n</ul>\n<p>Looking forward to and thanks for any feedback.</p>",
        "id": 238470099,
        "sender_full_name": "lrh2000",
        "timestamp": 1620824948
    },
    {
        "content": "<ol>\n<li>that's because <code>r#</code> now either starts a raw identifier or a raw string, so anything else after the <code>#</code> fails. that's fine, because the RFC tuns all unknown prefixes into errors.</li>\n<li>it might be easier and more consistent if everything starting with <code>foo#</code> is an error. <code>r\"foo\"#bar</code> should stay three tokens, since we're only changing prefixes</li>\n</ol>",
        "id": 238471865,
        "sender_full_name": "Mara",
        "timestamp": 1620825618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> You can use <a href=\"https://github.com/rust-lang/rust/issues/84599\">the tracking issue</a> to claim the issue (say <code>@rustbot claim</code>, iirc). and that's also a good place to discuss details like these edge cases.</p>",
        "id": 238472109,
        "sender_full_name": "Mara",
        "timestamp": 1620825716
    },
    {
        "content": "<p>(zulip is fine too for a 'live' discussion, but it's useful to keep track of design and implementation decisions like that in a github issue.)</p>",
        "id": 238472250,
        "sender_full_name": "Mara",
        "timestamp": 1620825760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310399\">Mara</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/238471865\">said</a>:</p>\n<blockquote>\n<ol>\n<li>that's because <code>r#</code> now either starts a raw identifier or a raw string, so anything else after the <code>#</code> fails. that's fine, because the RFC tuns all unknown prefixes into errors.</li>\n<li>it might be easier and more consistent if everything starting with <code>foo#</code> is an error. <code>r\"foo\"#bar</code> should stay three tokens, since we're only changing prefixes</li>\n</ol>\n</blockquote>\n<ol>\n<li>Yeah that's fine for now. But it is at least not necessary. What's more, I think it leads to bad consistency. For example, we may reserve  the prefix<code>xr#</code> and accept <code>xr# bar</code> as three tokens (that's what the RFC specified). However, once we decide to use <code>xr#</code> represents something like a raw string, <code>xr# bar</code> may not compile anymore (<code>found invalid character</code>).</li>\n<li>Actually I think it is okay and easy to implement. However, the RFC specified we should accept <code>foo# bar</code> as three tokens. It actually complicates the problem a bit.</li>\n</ol>",
        "id": 238475531,
        "sender_full_name": "lrh2000",
        "timestamp": 1620826946
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> You can use <a href=\"https://github.com/rust-lang/rust/issues/84599\">the tracking issue</a> to claim the issue (say <code>@rustbot claim</code>, iirc). and that's also a good place to discuss details like these edge cases.</p>\n</blockquote>\n<p>OK, I'll do this later. (I didn't do this at first because I think I can get the feedback a little faster here.)</p>",
        "id": 238475864,
        "sender_full_name": "lrh2000",
        "timestamp": 1620827089
    },
    {
        "content": "<p>it's not uncommon to slightly deviate from the original RFC if during implementation it turns out to make more sense that way. but those things should be discussed on the tracking issue to make sure everyone involved is aware, possibly nominating the issue for a discussion in a team meeeting</p>",
        "id": 238476139,
        "sender_full_name": "Mara",
        "timestamp": 1620827199
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> You can use <a href=\"https://github.com/rust-lang/rust/issues/84599\">the tracking issue</a> to claim the issue (say <code>@rustbot claim</code>, iirc). and that's also a good place to discuss details like these edge cases.</p>\n</blockquote>\n<p>Done at <a href=\"https://github.com/rust-lang/rust/issues/84978\">https://github.com/rust-lang/rust/issues/84978</a>. But it seems there are two tracking issues (why?) and I've found a different one.</p>",
        "id": 238481863,
        "sender_full_name": "lrh2000",
        "timestamp": 1620829383
    },
    {
        "content": "<p>oh! we should probably mark the empty one as a duplicate or something :)</p>",
        "id": 238512413,
        "sender_full_name": "Mara",
        "timestamp": 1620840394
    },
    {
        "content": "<blockquote>\n<p>However, the RFC specified we should accept foo# bar as three tokens.</p>\n</blockquote>\n<p>as the author of the RFC, any \"accept as three tokens\" language should be read as \"for the purposes of this RFC we don't actually care what the behavior is other than that it <em>won't</em> be a reserved prefix and therefore won't parse as one token; do whatever is most natural, most consistent, and least disruptive\". I wasn't aware that <code>r# foo</code> didn't already parse as three tokens, for example; if I had know then I wouldn't have presumptively used the \"three tokens\" language. restrict the scope of the RFC as much as is reasonable.</p>",
        "id": 238522904,
        "sender_full_name": "bstrie",
        "timestamp": 1620844510
    },
    {
        "content": "<p>yeah these are typically the kind of details that only show up when starting the implementation</p>",
        "id": 238523324,
        "sender_full_name": "Mara",
        "timestamp": 1620844661
    },
    {
        "content": "<p>We did talk about the possibility of reserving <code>foo#</code> (if there's no space before the <code>#</code>) as well, even without a token immediately after it. It sounds like doing that might be more consistent with the current behavior of <code>r#</code>.</p>",
        "id": 238528191,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1620846526
    },
    {
        "content": "<p>I'm also surprised that <code>r# foo</code> tokenizes as <code>r#foo</code>, FWIW.</p>",
        "id": 238531443,
        "sender_full_name": "scottmcm",
        "timestamp": 1620848044
    },
    {
        "content": "<p>But if we have precedent from it, it seems fine to say that the migration is to <code>r #foo</code> and not <code>r# foo</code>, and to reserve more...</p>",
        "id": 238531573,
        "sender_full_name": "scottmcm",
        "timestamp": 1620848096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/238531443\">said</a>:</p>\n<blockquote>\n<p>I'm also surprised that <code>r# foo</code> tokenizes as <code>r#foo</code>, FWIW.</p>\n</blockquote>\n<p>It's different, actually.</p>\n<ul>\n<li>The lexer tokenizes <code>r#foo</code> as a raw identifier <code>foo</code>, <em>successfully</em>.</li>\n<li>The lexer <em>tries</em> to tokenize <code>r# foo</code> as a raw string, because it sees <code>r#</code> and the next character <code> </code> cannot be the start of an identifier. It <em>failed</em> with <code>found invalid character</code> because it expects either <code>#</code> and <code>\"</code> for a raw string.</li>\n</ul>",
        "id": 238566034,
        "sender_full_name": "lrh2000",
        "timestamp": 1620867221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/238522904\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>However, the RFC specified we should accept foo# bar as three tokens.</p>\n</blockquote>\n<p>as the author of the RFC, any \"accept as three tokens\" language should be read as \"for the purposes of this RFC we don't actually care what the behavior is other than that it <em>won't</em> be a reserved prefix and therefore won't parse as one token; do whatever is most natural, most consistent, and least disruptive\". I wasn't aware that <code>r# foo</code> didn't already parse as three tokens, for example; if I had know then I wouldn't have presumptively used the \"three tokens\" language. restrict the scope of the RFC as much as is reasonable.</p>\n</blockquote>\n<p>OK I got it. Thanks for the explanation.</p>",
        "id": 238566143,
        "sender_full_name": "lrh2000",
        "timestamp": 1620867310
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\"><pre><span></span><code>error: unknown prefix on identifier: a#\n --&gt; tokens.rs:7:7\n  |\n7 | demo!(a#foo);\n  |       ^^ help: try using whitespace here: `a # foo`\n  |\n  = note: prefixed identifiers are reserved for future use\n</code></pre></div>\n<p>Note that this syntactic reservation is whitespace-sensitive: any whitespace to either side of the intervening <code>#</code> will allow this code to compile. This provides a simple migration path for anyone who would be impacted by this change; they would need only change their macro invocations from <code>foo!(bar#qux)</code> to any of <code>foo!(bar # qux)</code> , <code>foo!(bar# qux)</code> , or <code>foo!(bar #qux)</code> . It is possible to automate this mechanical migration via rustfix.</p>\n</blockquote>\n<p>another part of the RFC that's relevant to this discussion / would have to be changed if <code>bar# qux</code> was disallowed</p>",
        "id": 238592221,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1620892351
    },
    {
        "content": "<p>Did we settle these semantics? I think we didn't quite :)</p>",
        "id": 238737138,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1620982530
    },
    {
        "content": "<p>I thought we could either deny anything beginning with <code>foo#</code>or change the behavior of <code>r#</code>. According to the discussion, it seems that we prefer the former (denying anything beginning with <code>foo#</code>).</p>",
        "id": 238746967,
        "sender_full_name": "lrh2000",
        "timestamp": 1620988598
    },
    {
        "content": "<p>So we have</p>\n<ul>\n<li>\n<p><code>foo## bar</code><br>\n    error: reserved prefixes</p>\n</li>\n<li>\n<p><code>foo#! bar</code><br>\n    error: reserved prefixes</p>\n</li>\n<li>\n<p><code>foo##! bar</code><br>\n     error: reserved prefixes</p>\n</li>\n<li>\n<p><code>foo##\" bar</code><br>\n    error: reserved prefixes</p>\n</li>\n<li>\n<p><code>foo##bar</code><br>\n    error: reserved prefixes</p>\n</li>\n<li>\n<p><code>r\"foo\"#bar</code><br>\n    3 tokens <code>\"foo\"</code>, <code>#</code>, <code>bar</code></p>\n</li>\n</ul>",
        "id": 238746987,
        "sender_full_name": "lrh2000",
        "timestamp": 1620988612
    },
    {
        "content": "<p>But what about <code>r#foo#bar</code>? It looks like both <code>r\"foo\"#bar</code>(3 tokens) and <code>foo#bar</code>(reserved prefixes). Does this one matter?</p>",
        "id": 238747083,
        "sender_full_name": "lrh2000",
        "timestamp": 1620988673
    },
    {
        "content": "<p>This approach would then unify the <code>ident#foo</code> and <code>ident#123</code> cases described in the RFC and also disallow certain instances of attributes on expressions (without an extra space), e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(stmt_expr_attributes)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">return</span><span class=\"cp\">#[allow(unused)]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>right?</p>",
        "id": 238763454,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1620997708
    },
    {
        "content": "<p>Exactly. I never thought of this kind of code before.</p>",
        "id": 238764520,
        "sender_full_name": "lrh2000",
        "timestamp": 1620998173
    },
    {
        "content": "<p>Similarly for <code>if#[attr] expr { expr }</code> and <code>match#[attr] expr { match_arms }</code>. None of these are stable without <code>stmt_expre_attributes</code> as-is, but they can probably be used by macros. At least something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">eat_expression</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$e</span>:<span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">eat_expression</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"cp\">#[attr]</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>works on stable. (Thus I would believe that inside of attribute-macros, you could use attributes on expressions as well. Haven’t tested or otherwise double-checked that.)</p>",
        "id": 238766866,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1620999179
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> that sounds great. More lex errors. We'll let crate guide us a bit.</p>",
        "id": 238771594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621000970
    },
    {
        "content": "<p>And <span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span> I would expect the migration to cover those cases in particular, right?</p>",
        "id": 238771679,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621000996
    },
    {
        "content": "<p>I’m just pointing out more potential breakage. Of course automatic migrations are supposed to make all of this not really a problem at all.</p>\n<p>Also, I personally feel like disallowing all <code>ident#</code> use cases is a significant change from the original RFC. I don’t really care about the choice here: reserving all <code>ident#</code> uses <em>seems fine and reasonable</em>, especially since automatic migrations and probably some nice error messages in the future will make the change non-problematic.</p>\n<p>However, I feel like the <a href=\"https://blog.rust-lang.org/2021/05/11/edition-2021.html\">blog post</a> becomes somewhat out-of-date/inaccurate with this change since it explicitly says, “we've decided to reserve syntax for prefixed identifiers and literals: <code>prefix#identifier</code>, <code>prefix\"string\"</code>, <code>prefix'c'</code>, and <code>prefix#123</code>, where prefix can be any identifier”.</p>\n<p>Over in <a class=\"stream-topic\" data-stream-id=\"268952\" href=\"/#narrow/stream/268952-edition-2021/topic/News.20articles\">#edition 2021 &gt; News articles</a> there’s some other websites some of which also picked up the mention of <code>prefix#identifier</code> and <code>prefix#123</code>. The change to <code>prefix#</code> is then – in my view – a trade-off between communicating this change and what the actual benefits are. I’m not sure that I know of any particular benefit of reserving <code>prefix#</code> instead of just <code>prefix#ident</code> and <code>prefix#123</code> (but maybe I’m missing something?).</p>",
        "id": 238774590,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621002138
    },
    {
        "content": "<blockquote>\n<p>I’m not sure that I know of any particular benefit of reserving <code>prefix#</code> instead of just <code>prefix#ident</code> and <code>prefix#123</code> (but maybe I’m missing something?).</p>\n</blockquote>\n<p>So do you mean that we should change the behavior of <code>r#</code>? Otherwise, how do we deal with <code>fr#</code> (which is nothing more than a reserved prefix now but in future it may behave like <code>r#</code>)?</p>",
        "id": 238776694,
        "sender_full_name": "lrh2000",
        "timestamp": 1621002931
    },
    {
        "content": "<p>(Of course, we can defer the issue and in the future we can always make <code>fr#</code> behave differently from <code>r#</code>, which is a little awkward at least in my opinion.)</p>",
        "id": 238777193,
        "sender_full_name": "lrh2000",
        "timestamp": 1621003130
    },
    {
        "content": "<p>(And we have to talk about corner cases like <code>foo##\"bar\"</code>, <code>foo##!bar</code> again, which complicates the lexer rules and seems to be unnecessary.)</p>",
        "id": 238778011,
        "sender_full_name": "lrh2000",
        "timestamp": 1621003455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/238776694\">said</a>:</p>\n<blockquote>\n<p>So do you mean that we should change the behavior of <code>r#</code>?</p>\n</blockquote>\n<p>Well, yes and no. I’m saying that reserving <code>prefix#</code> is reasonable but needs to be communicated and may have little benefix. I’m also – indeed – of the opinion that <strong>if</strong> we <em>don’t</em> disallow <code>prefix#</code> in general <strong>then</strong>, yes, we should probably allow <code>r#</code>. So in a sense change the behavior of <code>r#</code>. Although the only “change” of course is that code that didn’t tokenize before tokenizes now, and could possibly be used in macros.</p>\n<p>I also have used <code>#</code> in macros before, although IIRC only at the beginning of the macro (so none of the cases discussed here would apply), especially in <code>macro_rules</code> macros to make recursive calls that don’t clash with the intended use case. I liked the symmetric situation of “you can break up <code>foo#bar</code> in any way you want to make it work in the new edition” in the RFC, so I guess I have a very slight preference to not disallowing <code>prefix#</code>. I haven’t thought too hard about all potential corner cases in lexing so if it turns out that allowing <code>prefix#</code> seems to be unnecessarily hard and complicated then that might be a good reason not to take that approach.</p>",
        "id": 238778422,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621003627
    },
    {
        "content": "<p>Roughly I think our views are actually the same.</p>\n<blockquote>\n<p>I haven’t thought too hard about all potential corner cases in lexing so if it turns out that allowing prefix# seems to be unnecessarily hard and complicated then that might be a good reason not to take that approach.</p>\n</blockquote>\n<p>If we allow <code>foo# bar</code>, there is no reasons we don't allow <code>foo## bar</code>, <code>foo##! bar</code> and so on. But we cannot allow <code>foo##\"</code> since we use <code>r##\"</code> to denote a raw string. It means that we may have to look forward at a lot of <code>#</code> before making the final decision. I'm not sure whether it is <em>unnecessarily hard and complicated</em> enough. At least, we can avoid this by disallowing <code>foo#</code>.</p>",
        "id": 238780071,
        "sender_full_name": "lrh2000",
        "timestamp": 1621004325
    },
    {
        "content": "<p>I don't feel that making <code>foo#</code> an error is so very different from <code>foo#bar</code> being reserved</p>",
        "id": 238781139,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621004730
    },
    {
        "content": "<p>Okay, I guess the <code>r##\"string\"##</code> example <em>is</em> a reasonable argument <em>against</em> allowing <code>foo#</code> in <em>every</em> case other than <code>foo#ident</code> and <code>foo#123</code>. I suppose there’s also other options like for example</p>\n<ul>\n<li>disallowing <code>foo#</code> unless it’s directly followed by whitespace (in which case it becomes 2 tokens), or</li>\n<li>disallowing <code>foo#</code> unless it’s directly followed by whitespace or <code>[</code> or <code>!</code>, which would still allow the attributes examples</li>\n</ul>",
        "id": 238798336,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621012048
    },
    {
        "content": "<p>So we do have several options:</p>\n<ul>\n<li>disallowing anything beginning with <code>foo#</code></li>\n<li>disallowing <code>foo#</code> unless it’s directly followed by whitespace, <em>and</em> adjust the behavior of <code>r#</code></li>\n<li>disallowing <code>foo#</code> unless it’s directly followed by whitespace or <code>[</code> or <code>!</code>, <em>and</em> adjust the behavior of <code>r#</code></li>\n</ul>\n<p>I guess none of the above is significantly better than others and none of the above is significantly worse than others, which makes the selection difficult. So maybe we can just pick the simplest one (i.e. the first one).</p>\n<p>I've opened a PR <a href=\"https://github.com/rust-lang/rust/issues/85359\">#85359</a> for this. Of course, we can still adjust its behavior during the review of that PR.</p>",
        "id": 238946298,
        "sender_full_name": "lrh2000",
        "timestamp": 1621136581
    },
    {
        "content": "<p>Just noticed that the RFC and your PR also disallow things like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"s\">\"foo\"</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>As long as that’s something we actually want to forbid, I don’t see any problem in disallowing <code>return</code>/<code>match</code>/<code>if</code>/… followed by attributes without a space either. In case we <em>do</em> want to e.g. still allow existing keywords followed by <code>#</code>, that would solve the problem with attributes as well. The RFC does forbid <code>IDENTIFIER_OR_KEYWORD</code> prefixes but it doesn’t really give any reason why non-keywords wouldn’t be enough. So this could give rise to some more reasonable alternatives</p>\n<ul>\n<li>disallow anything starting with <code>foo#</code>, <code>foo'</code>, or <code>foo\"</code>  unless <code>foo</code> is a keyword</li>\n<li>disallow anything starting with <code>foo#</code>, <code>foo'</code>, or <code>foo\"</code> unless <code>foo</code> is one of the keywords <code>break</code>, <code>if</code>, <code>in</code>, <code>match</code>, <code>return</code>, <code>while</code>, <code>continue</code>. (Further keywords such as <code>box</code>, or <code>yield</code> could be added later without any problems, once they are stabilized.)</li>\n</ul>\n<p>If <code>foo</code> is a keyword / one of the allowed keywords, then <code>foo#……</code> should parse the same as <code>foo #……</code> with a space after the keyword</p>\n<p>AFAICT (correct me if I’m wrong) the keywords listed above should be all the cases where currently an IDENTIFIER_OR_KEYWORD can be followed by a string/char literal or an attribute or a lifetime/label.</p>\n<p>Either of these approaches should have the effect that it doesn’t break (i.e. introduce the need for changes to) any working code that uses string or char literals without preceding spaces or any code that uses procedural attribute macros (which are able to parse/accept attributes on expressions).</p>",
        "id": 238979476,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621172358
    },
    {
        "content": "<p>Actually, your PR also disallows</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"o\">'</span><span class=\"na\">label</span>: <span class=\"nc\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">continue</span><span class=\"nl\">'label</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With either of the proposals above, this would be fixed, too (I’ve added <code>continue</code> to the list of keywords).</p>",
        "id": 238979787,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621172614
    },
    {
        "content": "<p>The impact of the PR on lifetimes is relevant in ordinary macros, too, where you can currently do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">qux</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$i</span>:<span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"cp\">$l</span>:<span class=\"nc\">lifetime</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">qux</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">ident</span><span class=\"o\">'</span><span class=\"na\">lifetime</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So maybe allowing <code>ident'lifetime</code> in general is preferable?</p>",
        "id": 238982155,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621175048
    },
    {
        "content": "<p>Yeah, thanks a lot for your feedback. I think your argument makes sense and I should consider this situations more carefully.</p>",
        "id": 238988685,
        "sender_full_name": "lrh2000",
        "timestamp": 1621181030
    },
    {
        "content": "<blockquote>\n<p>AFAICT (correct me if I’m wrong) the keywords listed above should be all the cases where currently an IDENTIFIER_OR_KEYWORD can be followed by a string/char literal or an attribute or a lifetime/label.</p>\n</blockquote>\n<p>Actually, <code>where</code> can be followed by lifetimes, too.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"o\">'</span><span class=\"na\">a</span>:<span class=\"o\">'</span><span class=\"na\">b</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238994267,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621186576
    },
    {
        "content": "<p>And <code>let</code> can be followed by char and string literals</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"s\">\"\"</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"\"</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238994898,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621187264
    },
    {
        "content": "<p>I wonder if there is a rust minifier around somewhere</p>",
        "id": 238994997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621187382
    },
    {
        "content": "<p>or code golf, I guess</p>",
        "id": 238995049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621187409
    },
    {
        "content": "<p>Going back to attribute macros or <code>$e:expr</code> macro arguments: <code>for</code> can be followed by string or char literal (patterns) as well</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[proc_macro_attribute]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">noop</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"nc\">TokenStream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">TokenStream</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">TokenStream</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span>::<span class=\"n\">default</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[noop]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"s\">\"\"</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">ignore_expression</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$e</span>:<span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">ignore_expression</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">for</span><span class=\"s\">\"\"</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 238995133,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621187517
    },
    {
        "content": "<p>So the list is now <code>break</code>, <code>if</code>, <code>in</code>, <code>match</code>, <code>return</code>, <code>while</code>, <code>continue</code>, <code>where</code>, <code>for</code>.</p>",
        "id": 238995344,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1621187755
    },
    {
        "content": "<p><code>for</code> is notable since it ends in <code>r</code>; apparently <code>for\"\"</code> does not tokenize as a raw string literal</p>",
        "id": 238998356,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621190967
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/238746967\">said</a>:</p>\n<blockquote>\n<p>I thought we could either deny anything beginning with <code>foo#</code>or change the behavior of <code>r#</code>. According to the discussion, it seems that we prefer the former (denying anything beginning with <code>foo#</code>).</p>\n</blockquote>\n<p>We discussed this in the <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span> meeting today, and the consensus was that being consistent with the current behaviour of <code>r#</code> sounds good.</p>\n<p>(Especially since we can always make it allowed later, so this is the easy consensus.)</p>",
        "id": 239291307,
        "sender_full_name": "scottmcm",
        "timestamp": 1621358150
    },
    {
        "content": "<p>Hey folks</p>",
        "id": 240097771,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621883619
    },
    {
        "content": "<p>I'm somewhat convinced by <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span>'s assertion that we should make this change in the Rust parser area</p>",
        "id": 240097798,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621883637
    },
    {
        "content": "<p>I'm curious <span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> how much you've explored this and what it would mean</p>",
        "id": 240097865,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621883654
    },
    {
        "content": "<p>I have to admit I'm getting worried about shipping this change for the edition</p>",
        "id": 240097878,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621883660
    },
    {
        "content": "<p>(This may want to be in #t-lang)</p>",
        "id": 240097882,
        "sender_full_name": "simulacrum",
        "timestamp": 1621883664
    },
    {
        "content": "<p>There is also the option of shipping a scaled back <code>k#foo</code>, but it seemed like we felt that could be done across all editions</p>",
        "id": 240097922,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621883693
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240097882\">said</a>:</p>\n<blockquote>\n<p>(This may want to be in #t-lang)</p>\n</blockquote>\n<p>It may, but this is where we've been conversing</p>",
        "id": 240097940,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621883703
    },
    {
        "content": "<p>so I figured most of the folks involved would see it here</p>",
        "id": 240097959,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621883713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240097865\">said</a>:</p>\n<blockquote>\n<p>I'm curious <span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> how much you've explored this and what it would mean</p>\n</blockquote>\n<p>So I'd like to first ask whether we have confirmed that we want to see <code>match\"foo\"</code> to be compiled successfully. I'm not sure because it seems that nobody expressed strong views on this problem clearly after the original suggestion made by <span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span> .</p>\n<p>If we do, we should make this change in parser. The lexer is not aware of the keyword list.</p>\n<ul>\n<li>\n<p>Whenever <code>rustc_parse</code> sees an ident in <code>parse_ident</code>, it can check whether or not a <code>#</code> or a string literal is followed immediately (without any whitespaces in the middle). If it is, it emits an error because it has found a reserved prefix.</p>\n</li>\n<li>\n<p>If <code>rustc_parse</code> sees a keyword, it shouldn't go through the <code>parse_ident</code> path (which is the normal case, otherwise, if the <code>parse_ident</code> is still called, we'll emit an error <code>expected identifier, found keyword</code>). Since we know we will never use a keyword as a prefix, we can safely accept the code.</p>\n</li>\n</ul>\n<p>But what I am concerned is that we have another parser that lives in <code>rustc_expand</code> that designs for the macro definitions and invocations. If we make this change only in parser, we can successfully convert <code>print#once</code> into a <code>TokenStream</code> with three tokens <code>print</code>, <code>#</code> and <code>once</code>. So consider the following code segment</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">print</span><span class=\"w\"> </span>#<span class=\"w\"> </span><span class=\"n\">once</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">print</span>#<span class=\"n\">once</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Since we can successfully convert <code>print#once</code> into a <code>TokenStream</code>, <code>rustc_expand</code> will get this <code>TokenStream</code> at the macro invocation <code>foo!(print#once)</code>. But it just matches the first macro rule which is also a <code>TokenStream</code> with three tokens <code>print</code>, <code>#</code> and <code>once</code>. The whole matching is not delegated to <code>rustc_parse</code> since there are no meta var decls (see <a href=\"https://github.com/rust-lang/rust/blob/cdbe2888979bb8797b05f0d58a6f6e60753983d2/compiler/rustc_expand/src/mbe/macro_parser.rs#L597-L601\">https://github.com/rust-lang/rust/blob/cdbe2888979bb8797b05f0d58a6f6e60753983d2/compiler/rustc_expand/src/mbe/macro_parser.rs#L597-L601</a>).</p>\n<p>So we have to check reserved prefixes here for every token, in case we accidentally accept the reserved prefix. I don't think it is a good idea. <strong>But if we decide to do so, how about just checking reserved prefixes while we are generating any <code>TokenStream</code>s?  It lives in <code>rustc_parse/src/lexer</code>, a position between the lexer and the parser.</strong> Does it sound good?</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span></p>",
        "id": 240181211,
        "sender_full_name": "lrh2000",
        "timestamp": 1621946817
    },
    {
        "content": "<p><code>rustc_parse/src/lexer</code> is place where lexer-style tokens are converted to parser-style tokens.<br>\nIf you want to do something with all tokens in a centralized way, then it's a good place to do that.</p>",
        "id": 240193022,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1621951830
    },
    {
        "content": "<p>It's a part of the parser logically, it has access to <code>rustc_span</code>, knows about keywords, etc.</p>",
        "id": 240193189,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1621951891
    },
    {
        "content": "<p>I would not expect <code>match\"foo\"</code> to compile</p>",
        "id": 240197129,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621953456
    },
    {
        "content": "<p>I am however increasingly convinced that we should move this logic to the parser</p>",
        "id": 240197248,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621953487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240197248\">said</a>:</p>\n<blockquote>\n<p>I am however increasingly convinced that we should move this logic to the parser</p>\n</blockquote>\n<p>Why? I thought making <code>match\"foo\"</code> to compile is the most significant benefit by moving this logic to the parser. Could you please explain more for this?</p>",
        "id": 240201756,
        "sender_full_name": "lrh2000",
        "timestamp": 1621955233
    },
    {
        "content": "<blockquote>\n<p>If you want to do something with all tokens in a centralized way, then it's a good place to do that.</p>\n</blockquote>\n<p>Yeah, I think it is the case.</p>",
        "id": 240202015,
        "sender_full_name": "lrh2000",
        "timestamp": 1621955321
    },
    {
        "content": "<p>I guess I don't have a strong opinion about whether <code>match\"foo\"</code> compiles</p>",
        "id": 240214327,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621960170
    },
    {
        "content": "<p>but the benefit I see is that the lexer remains edition agnostic</p>",
        "id": 240214335,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621960176
    },
    {
        "content": "<p>when we designed the proc macro API, we tried to design it to give back simple tokens with \"adjacency information\" so that we could add new operators like <code>&lt;&lt;&lt;&lt;</code> in the future without breaking back-compat</p>",
        "id": 240214389,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621960201
    },
    {
        "content": "<p>I see the appeal of using that to parse <code>k#foo</code> differently from <code>foo</code> etc</p>",
        "id": 240214454,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621960213
    },
    {
        "content": "<p>while still tokenizing it as we ever did</p>",
        "id": 240214470,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621960218
    },
    {
        "content": "<p>or, more to the point, <code>f\"foo\"</code></p>",
        "id": 240214503,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1621960238
    },
    {
        "content": "<p>note that there are already things that enforce mandatory surrounding whitespace; <code>let x = .. ..;</code> compiles, but <code>let x = ....;</code> does not.</p>",
        "id": 240215206,
        "sender_full_name": "bstrie",
        "timestamp": 1621960514
    },
    {
        "content": "<p>(aside, but I thought of one more thing that reserved prefixes might be useful for: in macros there's an open question of which scope identifiers ought to be resolved in, and this might be disambiguated by having <code>call#foo</code> or <code>def#foo</code>)</p>",
        "id": 240220164,
        "sender_full_name": "bstrie",
        "timestamp": 1621962750
    },
    {
        "content": "<p>I don't think I'd want to see <code>#</code> used for that. We already have the <code>::</code> operator.</p>",
        "id": 240224083,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621964482
    },
    {
        "content": "<p>If there's some way we want to change name resolution, I think that should be a <code>newthing::some::name</code>, where <code>newthing</code> can be <code>k#newthing</code> if need be.</p>",
        "id": 240224136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621964505
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> If we check reserved prefixes in <code>rustc_parse/src/lexer</code>, does that allow proc macros to parse and give meaning to reserved prefixes, or will that catch reserved prefixes before macros can process them?</p>",
        "id": 240224798,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621964821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240224083\">said</a>:</p>\n<blockquote>\n<p>I don't think I'd want to see <code>#</code> used for that. We already have the <code>::</code> operator.</p>\n</blockquote>\n<p>would that work for defining types that get injected into the caller's scope? I was thinking of <code>struct call#Foo</code></p>",
        "id": 240224967,
        "sender_full_name": "bstrie",
        "timestamp": 1621964895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256342\">@bstrie</span> As in a macro defining types, and wanting to explicitly ignore hygiene?</p>",
        "id": 240225034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621964933
    },
    {
        "content": "<p>yes, this is the open question that rustc internally uses <code>#[rustc_macro_transparency]</code> to work around</p>",
        "id": 240225091,
        "sender_full_name": "bstrie",
        "timestamp": 1621964961
    },
    {
        "content": "<p>That seems like a matter of macro syntax, and I think I'd expect that to look more like <code>caller_scope!(Foo)</code> rather than something involving <code>#</code>.</p>",
        "id": 240225125,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621964974
    },
    {
        "content": "<p>Also, in many cases a macro may want to combine that with some kind of gensym mechanism (\"give me a fresh identifier that can't conflict with anything\").</p>",
        "id": 240225326,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621965039
    },
    {
        "content": "<p>Regarding lexer vs parser, two things I'd like to make sure we address:</p>",
        "id": 240226132,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621965379
    },
    {
        "content": "<p>1) I want to make sure proc macros can't assign meaning to reserved prefixes that would conflict with the language assigning meaning to them in the future. I don't want to end up in a situation where people start using them and we either have to say \"hey, we said this would break in the future and we're breaking it\" but still cause problems for people, or we have to work around such macros anyway and lose the intended benefit of reserved prefixes.</p>",
        "id": 240226133,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621965379
    },
    {
        "content": "<p>2) I'd like to make sure reserved syntax can itself be used in the definitions of macros themselves, and similarly \"early\" things. That may be less of an issue if only proc macros can \"see\" the reserved syntax, but I still want to verify that whatever solution we go with doesn't limit our ability to use reserved syntax in the definition of arbitrary language constructs, including macros.</p>",
        "id": 240226319,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621965481
    },
    {
        "content": "<p>If we can accomplish both of those things while still having an edition-independent lexer, I'm all for it. For clarity, I don't have any preference whether this happens in the lexer or the parser; I just care about both of the above considerations.</p>",
        "id": 240227396,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1621965948
    },
    {
        "content": "<p>There was an idea someone (I forget by whom, sorry) brought up a while ago that seemed like it could help for <code>macro_rules</code> at least: make \"unknown tokens\" (whatever that means) match things like <code>expr</code> and <code>ident</code> etc.</p>\n<p>That way a macro written <code>{ ( k#foo ) =&gt; { ... }, ( $i:ident ) =&gt; { ... } }</code> can still work, but anything written <code>{ ( $i:ident ) =&gt; { ... }, ( k#foo ) =&gt; { ... } }</code> would just never match the second one, as it'd get picked up by the first arm and then give an error that it's not a valid ident.</p>\n<p>That wouldn't help proc macros, but they're always a bit of a wild west...</p>",
        "id": 240233394,
        "sender_full_name": "scottmcm",
        "timestamp": 1621968748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240233394\">said</a>:</p>\n<blockquote>\n<p>There was an idea someone (I forget by whom, sorry) brought up a while ago that seemed like it could help for <code>macro_rules</code> at least: make \"unknown tokens\" (whatever that means) match things like <code>expr</code> and <code>ident</code> etc.</p>\n<p>That way a macro written <code>{ ( k#foo ) =&gt; { ... }, ( $i:ident ) =&gt; { ... } }</code> can still work, but anything written <code>{ ( $i:ident ) =&gt; { ... }, ( k#foo ) =&gt; { ... } }</code> would just never match the second one, as it'd get picked up by the first arm and then give an error that it's not a valid ident.</p>\n<p>That wouldn't help proc macros, but they're always a bit of a wild west...</p>\n</blockquote>\n<p>I believe it was me <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> To further clarify: a <code>k#foo</code> that has not yet been given a parseable meaning in the compiler would thus:</p>\n<ul>\n<li>start by being \"valid components\" of any macro capture kind;</li>\n<li>but then end with a parsing error due to <code>k#foo</code> having no meaning and thus there not being a valid parsing for that capture kind.</li>\n</ul>\n<p>An example of such behavior can currently be observed with ambiguous prefixes:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$_</span>:<span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$_</span>:<span class=\"nc\">lifetime</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">m</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Error, `'a` is not a valid expr.</span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=001d98f6f9fc87dd91a028147424ff37\">Playground</a></li>\n</ul>\n<p>By doing so, indeed, we'd future-proof against <code>macro_rules!</code> captures as much as possible, since the only way one would match against things such as <code>k#foo</code> would then be either literally, or through <code>$($_:tt)*</code> kind of captures.</p>\n<p>In other words, or as a recap, since any potential keyword <em>could</em> become a valid component for whatever capture we are dealing with,</p>\n<ul>\n<li>we cannot reject macro arms based on captures.</li>\n</ul>\n<p>But since they currently have no meaning assigned / they <em>could</em> become an invalid component for those very specific captures,</p>\n<ul>\n<li>we cannot let the capture be fully parsed.</li>\n</ul>",
        "id": 240239815,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1621971847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240224798\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> <span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> If we check reserved prefixes in <code>rustc_parse/src/lexer</code>, does that allow proc macros to parse and give meaning to reserved prefixes, or will that catch reserved prefixes before macros can process them?</p>\n</blockquote>\n<p>It still leads to edition-dependent <code>TokenStream</code>, so the case should be the same as we check reserved prefixes in <code>rustc_lexer</code>. The benefit is just we have available keyword list. But as <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240214335\">said</a> by <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>:</p>\n<blockquote>\n<p>but the benefit I see is that the lexer remains edition agnostic</p>\n</blockquote>\n<p>If  instead, what we really want is an edition-agnostic lexer (I think here the lexer means <code>TokenStream</code>), we have to defer the check again, maybe in a position where we actually extracts tokens from any <code>TokenStream</code> to parse (possibly <code>Parser::bump()</code> or something similar?).</p>",
        "id": 240267390,
        "sender_full_name": "lrh2000",
        "timestamp": 1621989523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240226319\">said</a>:</p>\n<blockquote>\n<p>2) I'd like to make sure reserved syntax can itself be used in the definitions of macros themselves, and similarly \"early\" things. That may be less of an issue if only proc macros can \"see\" the reserved syntax, but I still want to verify that whatever solution we go with doesn't limit our ability to use reserved syntax in the definition of arbitrary language constructs, including macros.</p>\n</blockquote>\n<p>Do you mean that we can safely write the below code segment?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">print</span>#<span class=\"n\">once</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">print</span><span class=\"w\"> </span>#<span class=\"w\"> </span><span class=\"n\">once</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If we can, we have to explicitly distinguish macro invocations from macro definitions, since we'll check reserved prefixes for invocations but not for definitions. It complicates the problem and I don't understand why we should do this, could you please explain a bit more?</p>",
        "id": 240268074,
        "sender_full_name": "lrh2000",
        "timestamp": 1621990359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> That's not what I mean, sorry.</p>",
        "id": 240278179,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622002824
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> I mean that reserved syntax should, itself, be potentially usable as part of the definition of a macro. For instance, we could decide that <code>k#xyz_macro</code> is the new keyword for defining a new kind of macro, and then <code>k#xyz_macro! foo { ... }</code> should work. Or, <code>m#gensym</code> could be part of a new syntax for defining a new identifier inside a macro.</p>",
        "id": 240278260,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622003002
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240278260\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> I mean that reserved syntax should, itself, be potentially usable as part of the definition of a macro. For instance, we could decide that <code>k#xyz_macro</code> is the new keyword for defining a new kind of macro, and then <code>k#xyz_macro! foo { ... }</code> should work. Or, <code>m#gensym</code> could be part of a new syntax for defining a new identifier inside a macro.</p>\n</blockquote>\n<p>It should be straightforward in lexer. We can manage to do this in parser, i.e. we are of course <em>able</em> to glue <code>k</code>, <code>#</code> and <code>xyz_macro</code> together, as suggested <a href=\"https://github.com/rust-lang/rust/issues/84979#issuecomment-843929357\">here</a>, although personally I think it is less elegant.</p>",
        "id": 240300192,
        "sender_full_name": "lrh2000",
        "timestamp": 1622022556
    },
    {
        "content": "<blockquote>\n<p>1) I want to make sure proc macros can't assign meaning to reserved prefixes that would conflict with the language assigning meaning to them in the future. I don't want to end up in a situation where people start using them and we either have to say \"hey, we said this would break in the future and we're breaking it\" but still cause problems for people, or we have to work around such macros anyway and lose the intended benefit of reserved prefixes.</p>\n</blockquote>\n<p>It is also straightforward in lexer. If we manage to do this in parser, we'd better to find a centralized way, <code>Parser::bump()</code> for example, as I've already mentioned before. Personally I think the latter is less elegant, too.</p>",
        "id": 240300672,
        "sender_full_name": "lrh2000",
        "timestamp": 1622022872
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/268952-edition-2021/topic/reserved.20prefixes/near/240226133\">said</a>:</p>\n<blockquote>\n<p>1) I want to make sure proc macros can't assign meaning to reserved prefixes that would conflict with the language assigning meaning to them in the future. I don't want to end up in a situation where people start using them and we either have to say \"hey, we said this would break in the future and we're breaking it\" but still cause problems for people, or we have to work around such macros anyway and lose the intended benefit of reserved prefixes.</p>\n</blockquote>\n<p>I'm not sure what I think about this goal. I think there is a real tension about \"enable exploration\" here. I actually think I might see it as a <em>benefit</em> that people can write procedural macros to test out things which may eventually become part of the standard language.</p>",
        "id": 240471431,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622123979
    },
    {
        "content": "<p>It's probably worth distinguishing <em>decorators</em> from other sorts of procedural macros</p>",
        "id": 240471906,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622124159
    },
    {
        "content": "<p>We're back in a kind of circular point</p>",
        "id": 240471920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622124165
    },
    {
        "content": "<p>I am getting very worried about schedule here; this doesn't seem to be coming together</p>",
        "id": 240471941,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622124174
    },
    {
        "content": "<p>I'm going to try and write up a doc to summaize the paths forward</p>",
        "id": 240471965,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622124184
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> There's a whole world of unreserved syntax for macros to use. To be, it seems like the point of reservation is to clear a space for future use by the language so that we stop having to worry about whether we might happen to break a macro. Then we can systematically use that reserved syntax for just about anything we might add outside of an edition boundary.</p>",
        "id": 240497140,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622133990
    },
    {
        "content": "<p>We also have the ability to unreserve part of that space at any time if it represents syntax we want to enable experimentation with.</p>",
        "id": 240497199,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622134030
    },
    {
        "content": "<p>In this case, I think we're trying to make the language more maintainable.</p>",
        "id": 240497247,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622134056
    },
    {
        "content": "<p>As well as making maintenance scale; a full crater run may not be an option forever.</p>",
        "id": 240497399,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1622134112
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> we would not break macros</p>",
        "id": 240534249,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622150800
    },
    {
        "content": "<p>they would keep working</p>",
        "id": 240534255,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622150804
    },
    {
        "content": "<p>(if we took the approach of manging this stuff in the parser)</p>",
        "id": 240534283,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622150821
    },
    {
        "content": "<p>at least, procedural macros would</p>",
        "id": 240534298,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622150828
    },
    {
        "content": "<p>macro-rules is more problematic, because of the fact that they can invoke the parser</p>",
        "id": 240534310,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622150838
    },
    {
        "content": "<p>(which is where <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>'s proposal comes in)</p>",
        "id": 240534413,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622150886
    },
    {
        "content": "<p>I'm not sure if that works, and I'm grumpy that the future proofing we tried to do on macro fragments didn't work, but oh well :)</p>",
        "id": 240534505,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622150961
    },
    {
        "content": "<p>...though...we could make the <em>parser</em> hard error</p>",
        "id": 240534590,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622151003
    },
    {
        "content": "<p>(i.e., not \"abort parsing\")</p>",
        "id": 240534630,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622151020
    },
    {
        "content": "<p>OK I wrote up some notes on reserved prefies <a href=\"https://hackmd.io/YLe7viGLTu2PfE5sQO4v0w\">https://hackmd.io/YLe7viGLTu2PfE5sQO4v0w</a> -- these are also based on discussions with <span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> in the meeting today.</p>",
        "id": 241080093,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622584024
    },
    {
        "content": "<p>Our conclusion was that we should stay the course with lexer errors</p>",
        "id": 241080105,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622584033
    },
    {
        "content": "<p>(And make <code>match\"foo\"</code> a lexer error too)</p>",
        "id": 241080117,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622584048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> can you update as to the current status of the implementation? I'm feeling a bit lost :)</p>",
        "id": 241080689,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622584443
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"407862\">lrh2000</span> can you update as to the current status of the implementation? I'm feeling a bit lost :)</p>\n</blockquote>\n<p>Since I have originally implemented it as a lexer error, I don't think I get much more things to do now, especially if we also decide to forbid stuffs like <code>match#foo</code>.</p>\n<p>There is a PR <a href=\"https://github.com/rust-lang/rust/issues/85359\">#85359</a>, and now I think what I still need to do is to fix the issue about lifetimes (if we want to allow <code>continue'label</code>). Is there anything else?</p>",
        "id": 241147610,
        "sender_full_name": "lrh2000",
        "timestamp": 1622640223
    },
    {
        "content": "<p>Let me take a look</p>",
        "id": 241148191,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622640470
    },
    {
        "content": "<p>I'm not sure about lifetimes, that wasn't covered in the RFC I guess</p>",
        "id": 241148260,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1622640487
    },
    {
        "content": "<p>Yes.</p>\n<p>Now the simple implementation does not look at characters after <code>continue'</code> when emitting the reserved prefix error, so it disallows <code>continue'label</code>. If we want to allow it, I think we have to examine those characters ahead (but not eat them) in the lexer.</p>",
        "id": 241151830,
        "sender_full_name": "lrh2000",
        "timestamp": 1622642018
    },
    {
        "content": "<p>And just like <code>match\"foo\"</code>, it won't cause any real problems because it can always be fixed by <code>continue 'label</code>.</p>",
        "id": 241152103,
        "sender_full_name": "lrh2000",
        "timestamp": 1622642158
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407862\">@lrh2000</span> I left some review comments -- do you think you'll have time to address the changes? I or <span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> can also push commits to your branch if you're busy</p>",
        "id": 242614198,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1623684296
    },
    {
        "content": "<p>Sorry I am indeed unexpectedly busy in June. (I'll be free by early July, and before that I can spend fairly limited time on this.)</p>",
        "id": 242615701,
        "sender_full_name": "lrh2000",
        "timestamp": 1623684863
    },
    {
        "content": "<p>But I'd like to take a look first.</p>",
        "id": 242615755,
        "sender_full_name": "lrh2000",
        "timestamp": 1623684886
    },
    {
        "content": "<p>np</p>",
        "id": 242615882,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1623684938
    },
    {
        "content": "<p>(And actually at first I planned to finish this in May. But it did cost much time to reach consensus before.)</p>",
        "id": 242616048,
        "sender_full_name": "lrh2000",
        "timestamp": 1623684988
    },
    {
        "content": "<p>Yes</p>",
        "id": 242616062,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1623684994
    },
    {
        "content": "<p>Although I am willing to, I cannot guarantee that I have time to address the changes before early July. So feel free to push commits if necessary.</p>",
        "id": 242620882,
        "sender_full_name": "lrh2000",
        "timestamp": 1623686774
    },
    {
        "content": "<p>Sorry again and hope this won't cause any trouble.</p>",
        "id": 242620900,
        "sender_full_name": "lrh2000",
        "timestamp": 1623686779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <a href=\"https://github.com/rust-lang/rust/issues/85359\">#85359</a> is ready for review</p>",
        "id": 242634848,
        "sender_full_name": "Mara",
        "timestamp": 1623692785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310399\">@Mara</span> <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 242635644,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1623693149
    }
]