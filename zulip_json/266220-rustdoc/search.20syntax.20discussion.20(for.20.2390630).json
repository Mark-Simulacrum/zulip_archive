[
    {
        "content": "<p>Ok, that's good to know, I had no idea that existed!</p>",
        "id": 268072345,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194163
    },
    {
        "content": "<p>trait bounds (generics is a better match in my head ^^')</p>",
        "id": 268072349,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194165
    },
    {
        "content": "<p>You even had a function get them: <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/js/search.js#L297-L310\">https://github.com/rust-lang/rust/blob/master/src/librustdoc/html/static/js/search.js#L297-L310</a></p>",
        "id": 268072396,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194201
    },
    {
        "content": "<p>well, have</p>",
        "id": 268072404,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194207
    },
    {
        "content": "<p>what does <code>string&lt;u8&gt;</code> mean?</p>",
        "id": 268072452,
        "sender_full_name": "jsha",
        "timestamp": 1642194239
    },
    {
        "content": "<p>a type with a name matching <code>string</code> which has a generic (ie trait bound) matching <code>u8</code></p>",
        "id": 268072548,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194273
    },
    {
        "content": "<p>Can you give an example of a function that would come up when you search for <code>string&lt;u8&gt;</code>?</p>",
        "id": 268072621,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194306
    },
    {
        "content": "<p>so if you have <code>struct string&lt;T: Debug&gt;</code>, then the corresponding search is <code>string&lt;debug&gt;</code></p>",
        "id": 268072635,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307537\">@Noah Lev</span> just made the example ^</p>",
        "id": 268072678,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194337
    },
    {
        "content": "<p>So <code>string&lt;u8&gt;</code> would match <code>struct string&lt;T: u8&gt;</code> -- it's nonsensical in this particular case?</p>",
        "id": 268072679,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194337
    },
    {
        "content": "<p>if you have a <code>u8</code> trait, then yes</p>",
        "id": 268072702,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194355
    },
    {
        "content": "<p>Maybe a more realistic example would be <code>Cow&lt;ToOwned&gt;</code> which would return <a href=\"https://doc.rust-lang.org/nightly/std/borrow/enum.Cow.html\">https://doc.rust-lang.org/nightly/std/borrow/enum.Cow.html</a> ?</p>",
        "id": 268072788,
        "sender_full_name": "jsha",
        "timestamp": 1642194390
    },
    {
        "content": "<p>Absolutely yes</p>",
        "id": 268072877,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194442
    },
    {
        "content": "<p>It doesn't seem to come up in the results though... is that just a bug in the current (i.e., nightly) implementation?</p>",
        "id": 268072910,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194465
    },
    {
        "content": "<p>yep</p>",
        "id": 268072970,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194491
    },
    {
        "content": "<p>the current implementation is just a pile of bugs on top of bugs</p>",
        "id": 268072986,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194508
    },
    {
        "content": "<p>is it a bug in the current implementation, or is it not currently implemented?</p>",
        "id": 268072989,
        "sender_full_name": "jsha",
        "timestamp": 1642194508
    },
    {
        "content": "<p>I don't see it in the help text for the current implementation.</p>",
        "id": 268073007,
        "sender_full_name": "jsha",
        "timestamp": 1642194523
    },
    {
        "content": "<p>Btw: I'm keeping a running list of features <a href=\"https://github.com/rust-lang/rust/pull/90630#issuecomment-1013474609\">here</a> as we discuss :)</p>",
        "id": 268073033,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194541
    },
    {
        "content": "<p>it's tested in <code>src/test/rustdoc-js/generics.js</code></p>",
        "id": 268073063,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194562
    },
    {
        "content": "<p>So it's just buggy ^^'</p>",
        "id": 268073080,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194581
    },
    {
        "content": "<p>and it recently got a fix as of June this year: <a href=\"https://github.com/rust-lang/rust/pull/86659\">https://github.com/rust-lang/rust/pull/86659</a></p>",
        "id": 268073198,
        "sender_full_name": "jsha",
        "timestamp": 1642194650
    },
    {
        "content": "<p>Is searching argument types supported currently (i.e., pre-this-PR)?</p>",
        "id": 268073201,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194651
    },
    {
        "content": "<p>(I mean in the search syntax, not in the search tabs)</p>",
        "id": 268073296,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194718
    },
    {
        "content": "<p>it's more general</p>",
        "id": 268073349,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194731
    },
    {
        "content": "<p>we don't have a search for arguments specifically</p>",
        "id": 268073366,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194742
    },
    {
        "content": "<p>for example if your query is <code>string</code>, we will compare <code>string</code> to the item name, its arguments and its returned types</p>",
        "id": 268073407,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194767
    },
    {
        "content": "<p>the only specific one currently is for returned types with the <code>-&gt;</code></p>",
        "id": 268073441,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642194785
    },
    {
        "content": "<p>And here's the original PR adding generics support in search: <a href=\"https://github.com/rust-lang/rust/pull/45673\">https://github.com/rust-lang/rust/pull/45673</a></p>",
        "id": 268073450,
        "sender_full_name": "jsha",
        "timestamp": 1642194791
    },
    {
        "content": "<p>(Btw I just renamed this topic)</p>",
        "id": 268073499,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194816
    },
    {
        "content": "<p>Are those all the features currently supported in search?</p>",
        "id": 268073810,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194986
    },
    {
        "content": "<p>(To the best of your knowledge)</p>",
        "id": 268073820,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642194996
    },
    {
        "content": "<p>I think we didn't forget one</p>",
        "id": 268073849,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195022
    },
    {
        "content": "<p>Ok, now what are the features supported by this PR?</p>",
        "id": 268073912,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195064
    },
    {
        "content": "<p>Are there any removals/changes or are they all additions?</p>",
        "id": 268073928,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195073
    },
    {
        "content": "<p>Ah right, we forgot one! the <code>;</code></p>",
        "id": 268073993,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195088
    },
    {
        "content": "<p>we can have multi-queries currently, I removed it in my rework</p>",
        "id": 268074024,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195103
    },
    {
        "content": "<p>you mean <code>,</code>?</p>",
        "id": 268074035,
        "sender_full_name": "jsha",
        "timestamp": 1642195109
    },
    {
        "content": "<p>let me check</p>",
        "id": 268074057,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195121
    },
    {
        "content": "<p>e.g. <a href=\"https://doc.rust-lang.org/nightly/std/index.html?search=str%2Cu8\">https://doc.rust-lang.org/nightly/std/index.html?search=str%2Cu8</a></p>",
        "id": 268074092,
        "sender_full_name": "jsha",
        "timestamp": 1642195141
    },
    {
        "content": "<p>it's the comma, you're right</p>",
        "id": 268074153,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195179
    },
    {
        "content": "<p>And it behaves as an OR?</p>",
        "id": 268074169,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195192
    },
    {
        "content": "<p>(I saw it in <code>test/rustdoc-js-std/multi-query.js</code>)</p>",
        "id": 268074172,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195193
    },
    {
        "content": "<p>no, it merges the best results from all queries</p>",
        "id": 268074236,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195209
    },
    {
        "content": "<p>What does that mean?</p>",
        "id": 268074246,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195217
    },
    {
        "content": "<p>we print 200 items in each tab, so if you have <code>u8,string</code>, it'll print the best from both <code>u8</code> and <code>string</code> queries until the 200 is reached</p>",
        "id": 268074308,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195252
    },
    {
        "content": "<p>(insert by lev distance)</p>",
        "id": 268074315,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195259
    },
    {
        "content": "<p>But aren't queries always sorted by lev distance?</p>",
        "id": 268074345,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195275
    },
    {
        "content": "<p>I think that means the same thing as an OR :-)</p>",
        "id": 268074348,
        "sender_full_name": "jsha",
        "timestamp": 1642195276
    },
    {
        "content": "<p>hum does it?</p>",
        "id": 268074359,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195285
    },
    {
        "content": "<p>oh well, maybe</p>",
        "id": 268074371,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195292
    },
    {
        "content": "<p>you have both queries results mixed in the end</p>",
        "id": 268074402,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195305
    },
    {
        "content": "<p>not one or the other is what I tried to say</p>",
        "id": 268074418,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195313
    },
    {
        "content": "<p>anyhow, during review on the big PR we decided to remove it, and I think it is now removed in the big PR.</p>",
        "id": 268074429,
        "sender_full_name": "jsha",
        "timestamp": 1642195322
    },
    {
        "content": "<p>yes, in the big PR I always intended to remove it</p>",
        "id": 268074493,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195338
    },
    {
        "content": "<p>Yeah, OR means it searches for both of them</p>",
        "id": 268074583,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195402
    },
    {
        "content": "<p>How exactly did quotes behave <em>before</em> this PR? IIRC they worked in an unintuitive way</p>",
        "id": 268074700,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195466
    },
    {
        "content": "<p>they look for exactly what you provided</p>",
        "id": 268074739,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195487
    },
    {
        "content": "<p>so if you have <code>\"hello toto\"</code>, it will look for items named <code>hello toto</code></p>",
        "id": 268074782,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195512
    },
    {
        "content": "<p>But how do they behave in these cases: <code>\"cow&lt;toowned\"</code>, <code>\"-&gt; String\"</code>, etc.</p>",
        "id": 268074821,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195542
    },
    {
        "content": "<p>it looks for the content between the quotes</p>",
        "id": 268074887,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195567
    },
    {
        "content": "<p>Example: <a href=\"https://doc.rust-lang.org/nightly/std/index.html?search=%22cow%3Czzzzzzz%3E%22\">https://doc.rust-lang.org/nightly/std/index.html?search=%22cow%3Czzzzzzz%3E%22</a></p>\n<p>This seems to ignore what's inside the <code>&lt;&gt;</code> even though it's a quoted string. That's probably a bug.</p>",
        "id": 268074890,
        "sender_full_name": "jsha",
        "timestamp": 1642195570
    },
    {
        "content": "<p>no no, what's inside the <code>\"\"</code> is taken as is</p>",
        "id": 268074903,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195584
    },
    {
        "content": "<p>no internal parsing until the end of the string</p>",
        "id": 268074915,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195592
    },
    {
        "content": "<p>then why does <code>cow&lt;zzzzzz&gt;</code> match <code>Cow</code>?</p>",
        "id": 268074942,
        "sender_full_name": "jsha",
        "timestamp": 1642195605
    },
    {
        "content": "<p>I kept it the same in the big PR too</p>",
        "id": 268074944,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/search.20syntax.20discussion.20.28for.20.2390630.29/near/268074942\">said</a>:</p>\n<blockquote>\n<p>then why does <code>cow&lt;zzzzzz&gt;</code> match <code>Cow</code>?</p>\n</blockquote>\n<p>O.O</p>",
        "id": 268074960,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195617
    },
    {
        "content": "<p>a bug XD</p>",
        "id": 268074967,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195621
    },
    {
        "content": "<p>the joys of using <code>split</code> :3</p>",
        "id": 268075113,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195689
    },
    {
        "content": "<p>It looks like in the new PR, <code>\"cow&lt;toowned&gt;\"</code> shows no results. Is that because it's treating the inside of the quotes as an exact item name?</p>",
        "id": 268075382,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195836
    },
    {
        "content": "<p>it takes everything until it finds the other quote</p>",
        "id": 268075423,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195855
    },
    {
        "content": "<p>so in this case, it'll look for items named <code>cow&lt;toowner&gt;</code></p>",
        "id": 268075447,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642195867
    },
    {
        "content": "<p>Why does <code>add(string)</code> not return <code>string::add</code> in the new PR?</p>",
        "id": 268075622,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642195969
    },
    {
        "content": "<p>if <code>string::add</code> is taking a <code>string</code> argument, then it's a bug</p>",
        "id": 268075708,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642196032
    },
    {
        "content": "<p>It actually takes a <code>str</code>, but it still doesn't come up in the results with <code>add(str)</code></p>",
        "id": 268075815,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642196100
    },
    {
        "content": "<p>This is what I mean about unnecessary complexity; the feature is quite buggy, but we're not even sure it's useful</p>",
        "id": 268075846,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642196118
    },
    {
        "content": "<p>try <code>add(str)</code> then</p>",
        "id": 268075847,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642196118
    },
    {
        "content": "<p>no, it's as expected</p>",
        "id": 268075862,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642196125
    },
    {
        "content": "<p>I did, it doesn't work</p>",
        "id": 268075863,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642196126
    },
    {
        "content": "<p>if we have more than one argument, then we switch to \"exact matches only\"</p>",
        "id": 268075883,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642196141
    },
    {
        "content": "<p>ah?</p>",
        "id": 268075892,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642196148
    },
    {
        "content": "<p>then it's a bug</p>",
        "id": 268075896,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642196156
    },
    {
        "content": "<p>funnily enough, <code>str -&gt; string</code> finds it</p>",
        "id": 268075998,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642196206
    },
    {
        "content": "<p>likewise, <code>from(str)</code> doesn't show <code>String::from</code></p>",
        "id": 268075999,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642196207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Noah Lev</span> <a href=\"#narrow/stream/266220-rustdoc/topic/search.20syntax.20discussion.20.28for.20.2390630.29/near/268075999\">said</a>:</p>\n<blockquote>\n<p>likewise, <code>from(str)</code> doesn't show <code>String::from</code></p>\n</blockquote>\n<p>I wonder if it has something to do with the <code>&amp;</code>...</p>",
        "id": 268078814,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642197724
    },
    {
        "content": "<p>Seems like we're moving forward. Next will be what we want to keep/remove/improve I guess. Thanks to both of you for taking the time to walk through this</p>",
        "id": 268088565,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642203474
    },
    {
        "content": "<p>If rustdoc strips tuples from the search index, then it ought to strip refs, too.</p>",
        "id": 268089646,
        "sender_full_name": "Michael notriddle Howell",
        "timestamp": 1642204343
    },
    {
        "content": "<p>I think it's being discarded completely. To be confirmed</p>",
        "id": 268128169,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642256655
    },
    {
        "content": "<p>I'm back so maybe let's finish this discussion? What syntax do we want exactly for <a href=\"https://github.com/rust-lang/rust/pull/90630\">https://github.com/rust-lang/rust/pull/90630</a> (as a first step)?</p>\n<p>Taking the comment from <span class=\"user-mention\" data-user-id=\"307537\">@Noah Lev</span> :</p>\n<blockquote>\n<ul>\n<li>plain name search: <code>foo</code>, <code>foo::bar</code></li>\n<li>quotes (exact match?): <code>\"foo\"</code>, <code>\"cow&lt;zzz&gt;\"</code></li>\n<li>itemtype filtering: <code>struct:foo</code>, <code>enum:bar</code></li>\n<li>trait bounds: <code>foo&lt;debug&gt;</code> (matches <code>struct Foo&lt;T: Debug&gt;</code>)</li>\n<li>return types: <code>-&gt; String</code> (matches functions returning <code>String</code>)</li>\n<li>argument types: <code>(String)</code></li>\n<li>function names and types: (doesn't seem to work properly currently)</li>\n</ul>\n</blockquote>\n<p>I think we didn't want the argument types in this implementation? So basically, some examples of what would work (I find it a bit simpler to read/go through) than writing the full supported syntax but if you prefer I can instead write the syntax):</p>\n<ul>\n<li><code>a</code></li>\n<li><code>a&lt;c&gt;</code></li>\n<li><code>-&gt; b</code></li>\n<li><code>-&gt; b&lt;c&gt;</code></li>\n<li><code>a&lt;c&gt; -&gt; b</code></li>\n<li><code>struct:b</code></li>\n<li><code>struct: -&gt; b</code></li>\n<li><code>struct: a -&gt; b</code></li>\n<li><code>\"a\"&lt;c&gt; -&gt; b</code></li>\n</ul>\n<p>What is not supported:</p>\n<ul>\n<li><code>a&lt;\"b\"&gt;</code> (quotes in generics/trait bounds)</li>\n<li><code>a&lt;b&lt;c&gt;&gt;</code> (generics in generics)</li>\n<li><code>(a)</code> (argument types)</li>\n</ul>",
        "id": 270980217,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1644241827
    },
    {
        "content": "<p>Orthogonal to the above, but I'd love search to be case sensitive if the input is mixed case</p>",
        "id": 270985593,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644244128
    },
    {
        "content": "<p>We save all data as lowercase currently</p>",
        "id": 270987306,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1644244870
    },
    {
        "content": "<p>Might be worth an update after the parser has been updated</p>",
        "id": 270987335,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1644244887
    },
    {
        "content": "<p>Welcome back! Let's split this into two steps:</p>\n<ul>\n<li>\n<p>To land <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a>, it should be a pure refactoring. It should not add or remove any syntax at all. That's the purpose of the exercise we went through to clarify what the current syntax is.</p>\n</li>\n<li>\n<p>After <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a> is landed, we can pursue changing the search syntax if we want to. We should have a clear idea of goals. For instance, a goal might be \"the current search syntax is confusing and hard to learn,\" or \"the current search syntax is ambiguous,\" or \"the current search syntax does not support features that we think are important to support.\"</p>\n</li>\n</ul>\n<p>I actually have some ideas for <a href=\"https://github.com/rust-lang/rust/issues/2\">#2</a> there but I'd like to settle on <a href=\"https://github.com/rust-lang/rust/issues/1\">#1</a> first.</p>",
        "id": 271035495,
        "sender_full_name": "jsha",
        "timestamp": 1644264710
    },
    {
        "content": "<p>Can I still remove the current support of multi queries? :3</p>",
        "id": 271036837,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1644265396
    },
    {
        "content": "<p>How about you open a separate PR that removes support for multi-queries from the current implementation? Then the refactoring doesn't need to deal with it.</p>",
        "id": 271339866,
        "sender_full_name": "Noah Lev",
        "timestamp": 1644437198
    },
    {
        "content": "<p>Oh. That's a good idea!</p>",
        "id": 271360249,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1644447475
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/90630\">https://github.com/rust-lang/rust/pull/90630</a> is ready but I'll comment on it that I'll remove the multi-query in another PR first.</p>",
        "id": 271360629,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1644447639
    },
    {
        "content": "<p>How many of the still-open discussion threads on <a href=\"https://github.com/rust-lang/rust/pull/90630\">https://github.com/rust-lang/rust/pull/90630</a> are still applicable? Several of them say that a function needs a sentence describing what it does, but there has been a doc comment added sometime between then and now, so it looks like it's been resolved.</p>",
        "id": 274469103,
        "sender_full_name": "Michael (notriddle) Howell",
        "timestamp": 1646692711
    },
    {
        "content": "<p>In the end, there is no change for the syntax as of now. It's just waiting for someone to make the final review.</p>",
        "id": 274513111,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1646730533
    },
    {
        "content": "<p>I'm coming back for review on this. I'm still confused by what the _current_ implementation of \"generics\" search is supposed to be. </p>\n<p>In the conversation above we came to the conclusion that <code>foo&lt;bar&gt;</code> meant \"a type named <code>foo</code>, with <code>bar</code> in its trait bounds.\" But I think that's wrong.</p>\n<p>I looked at the current test cases for generics search:</p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics.js\">https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics.js</a><br>\n<a href=\"https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics.rs\">https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics.rs</a></p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-trait.js\">https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-trait.js</a><br>\n<a href=\"https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-trait.rs\">https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-trait.rs</a></p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-multi-trait.js\">https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-multi-trait.js</a><br>\n<a href=\"https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-multi-trait.rs\">https://github.com/rust-lang/rust/blob/master/src/test/rustdoc-js/generics-multi-trait.rs</a></p>\n<p>It looks like generics are only really supported for \"in args\" and \"in return types\". It makes a lot of sense there! If I want to find something that returns <code>Vec&lt;u8&gt;</code>, I'm not interested in something that returns <code>Vec&lt;String&gt;</code>. And this works as expected in nightly docs (tab over to \"in return types\" and see Vec::from) <a href=\"https://doc.rust-lang.org/nightly/std/string/struct.String.html?search=vec%3Cu8%3E\">https://doc.rust-lang.org/nightly/std/string/struct.String.html?search=vec%3Cu8%3E</a></p>\n<p>So I propose this documentation for how generics should work in search:</p>\n<ul>\n<li>For \"in args\" and \"in return types\" searches, <code>foo&lt;a, b c&gt;</code> will match a parameter that has a concrete type <code>foo</code> instantiated with parameters <code>a</code>, <code>b</code>, and <code>c</code>, ignoring any lifetime parameters.</li>\n<li>For \"in names\" searches, <code>foo&lt;a, b, c&gt;</code> is an error.</li>\n</ul>",
        "id": 275919317,
        "sender_full_name": "jsha",
        "timestamp": 1647709471
    },
    {
        "content": "<p>Also I should clarify what I mean by \"has a concrete type <code>foo</code>\": has a concrete type where the last element of the path is an exact match for <code>foo</code>.</p>",
        "id": 275919378,
        "sender_full_name": "jsha",
        "timestamp": 1647709557
    },
    {
        "content": "<blockquote>\n<p>In the conversation above we came to the conclusion that foo&lt;bar&gt; meant \"a type named foo, with bar in its trait bounds.\" But I think that's wrong.</p>\n</blockquote>\n<p>More importantly, I don't think that would actually work. The search index doesn't actually include generic information except for function calls (<a href=\"https://github.com/notriddle/notriddle-rustdoc-test/blob/4e3c18a4c3f115f73d029ddffdd5e0d9a386c755/trait-test-rs/doc/search-index.js\">proof</a> by showing that a trait, <code>Read</code>, is never mentioned in the search index at all despite being named in the struct's definition), and, even if it did, a lot of libstd types include trait bounds only on impl blocks (which have no representation in the search index at all), not on the actual types.</p>",
        "id": 275924527,
        "sender_full_name": "Michael (notriddle) Howell",
        "timestamp": 1647716657
    },
    {
        "content": "<p>We currently don't have the \"in names\" search with generics normally since there is more than one element</p>",
        "id": 275930445,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647725061
    },
    {
        "content": "<p>to be confirmed though</p>",
        "id": 275930446,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647725066
    },
    {
        "content": "<p>for example if you have \"a&lt;b&gt;\", then it's automatically not a name search anymore (but again to be confirmed!)</p>",
        "id": 275930457,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647725093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"210053\">Michael (notriddle) Howell</span> <a href=\"#narrow/stream/266220-rustdoc/topic/search.20syntax.20discussion.20.28for.20.2390630.29/near/275924527\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>In the conversation above we came to the conclusion that foo&lt;bar&gt; meant \"a type named foo, with bar in its trait bounds.\" But I think that's wrong.</p>\n</blockquote>\n<p>More importantly, I don't think that would actually work. The search index doesn't actually include generic information except for function calls (<a href=\"https://github.com/notriddle/notriddle-rustdoc-test/blob/4e3c18a4c3f115f73d029ddffdd5e0d9a386c755/trait-test-rs/doc/search-index.js\">proof</a> by showing that a trait, <code>Read</code>, is never mentioned in the search index at all despite being named in the struct's definition), and, even if it did, a lot of libstd types include trait bounds only on impl blocks (which have no representation in the search index at all), not on the actual types.</p>\n</blockquote>\n<p>It's because it's constraint, not a bound. I made this distinction a long time ago. We can discuss it into integrating this information though?</p>",
        "id": 275930530,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647725166
    },
    {
        "content": "<p>Thanks to both of you for the review! I'll try to update the PR tomorrow.</p>",
        "id": 275930541,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647725205
    },
    {
        "content": "<p>The problem is, even if we \"fixed\" that, it would not do what you want on the standard library. <code>HashMap&lt;Hash&gt;</code>, for example, can't possibly resolve to the HashMap struct, because HashMap doesn't actually have any constraints at all. Only the impl blocks do, and they have no representation in the search index.</p>",
        "id": 275930953,
        "sender_full_name": "Michael (notriddle) Howell",
        "timestamp": 1647725830
    },
    {
        "content": "<p>true</p>",
        "id": 275936364,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647733607
    },
    {
        "content": "<p>I'm coming to the conclusion that a lot of the complexity in the parser is due to the \"in parameters\" and \"in return types\" functionality.</p>\n<p>For name searches, there isn't really any reason to support arbitrary Rust syntax.</p>\n<p>But to match a function based on its parameter types, the user has to be able to type just about any syntax that can be part of a Rust type (as seen in a parameter type).</p>\n<p>Perhaps our approach here is wrong. search-index.js represents function parameters in an already-parsed way, and then the rustdoc search query parser tries to re-parse function parameters in the same way, and then semantically match the two against each other.</p>\n<p>It seems like it would be simpler for search-index.js to represent function parameters as simple strings, and use simple string matching against them.</p>",
        "id": 275951258,
        "sender_full_name": "jsha",
        "timestamp": 1647757810
    },
    {
        "content": "<p>(which of course we could do after landing <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a>; I'm not proposing to fully rewrite <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a> at this point)</p>",
        "id": 275951742,
        "sender_full_name": "jsha",
        "timestamp": 1647758749
    },
    {
        "content": "<p>Getting more specific: to be correct for \"in parameters\" and \"in return types\" searches, I think the rustdoc query parser would need to be able to parse the <code>Type</code> syntax described at <a href=\"https://doc.rust-lang.org/reference/types.html#type-expressions\">https://doc.rust-lang.org/reference/types.html#type-expressions</a>.</p>\n<p>Also, as a side note that document nailed down a terminology issue that's been slightly bugging me in reading <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a>. The variable names and comments in the parser frequently say \"generics\", but that's ambiguous: is it talking about generic parameters, or generic arguments? I believe every place that we deal with generics in the rustdoc search code, it's related to function parameters or return types. So we always mean \"generic arguments\" and should describe them as such.</p>\n<p>generic arguments: <a href=\"https://doc.rust-lang.org/reference/paths.html#paths-in-expressions\">https://doc.rust-lang.org/reference/paths.html#paths-in-expressions</a><br>\ngeneric type parameters: <a href=\"https://doc.rust-lang.org/reference/types/parameters.html\">https://doc.rust-lang.org/reference/types/parameters.html</a></p>",
        "id": 275952214,
        "sender_full_name": "jsha",
        "timestamp": 1647759552
    },
    {
        "content": "<p>That would greatly increase the complexity to support rust syntax (because the rust syntax is quite big).</p>",
        "id": 275964600,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647779532
    },
    {
        "content": "<blockquote>\n<p>It seems like it would be simpler for search-index.js to represent function parameters as simple strings, and use simple string matching against them.</p>\n</blockquote>\n<p>They are basically. We added what types they were and their generics afterward.</p>\n<blockquote>\n<p>Also, as a side note that document nailed down a terminology issue that's been slightly bugging me in reading <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a>. The variable names and comments in the parser frequently say \"generics\", but that's ambiguous: is it talking about generic parameters, or generic arguments? I believe every place that we deal with generics in the rustdoc search code, it's related to function parameters or return types. So we always mean \"generic arguments\" and should describe them as such.</p>\n</blockquote>\n<p>It's an oversimplification that came from me. But yes, we're always talking about the bounds of the arguments (\"generic arguments\" is a bit misleading in my opinion).</p>",
        "id": 275964855,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647779887
    },
    {
        "content": "<blockquote>\n<p>(which of course we could do after landing <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a>; I'm not proposing to fully rewrite <a href=\"https://github.com/rust-lang/rust/issues/90630\">#90630</a> at this point)</p>\n</blockquote>\n<p>I think once we'll have it, we can formalize a new syntax for the search. Since we'll have a parser, it'll be much simpler. :)</p>",
        "id": 275965263,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647780411
    },
    {
        "content": "<p>Aha! With this update and your recent comments on the PR, I think I properly understand now:</p>\n<p><a href=\"https://github.com/rust-lang/rust/pull/90630#discussion_r830616525\">https://github.com/rust-lang/rust/pull/90630#discussion_r830616525</a><br>\n<a href=\"https://github.com/rust-lang/rust/pull/90630#discussion_r830617102\">https://github.com/rust-lang/rust/pull/90630#discussion_r830617102</a><br>\n<a href=\"https://github.com/rust-lang/rust/pull/90630#discussion_r830617500\">https://github.com/rust-lang/rust/pull/90630#discussion_r830617500</a></p>\n<p>So if I search for <code>Foo&lt;Bar&gt;</code> In Parameters, there are two possibilities:</p>\n<ul>\n<li><code>Bar</code> is a concrete type, and this will match functions like <code>fn zoop(a: Foo&lt;Bar&gt;)</code></li>\n<li><code>Bar</code> is a trait, and this will match functions like <code>fn blub&lt;T: Bar&gt;(a: Foo&lt;T&gt;)</code>. And presumably <code>fn yow&lt;T: Bar + Baz + Qux&gt;(a: Foo&lt;T&gt;)</code>. Will it also match <code>fn sput(a: Foo&lt;impl Bar&gt;)</code>?</li>\n</ul>",
        "id": 275982541,
        "sender_full_name": "jsha",
        "timestamp": 1647802926
    },
    {
        "content": "<p>I think part of why this is confusing is that it looks a lot like Rust syntax but the semantics are different in an important way. In general, if you see <code>Foo&lt;Bar&gt;</code> in Rust code, <code>Bar</code> is always one of:</p>\n<ul>\n<li>A concrete type</li>\n<li>A type parameter (usually named like <code>T</code>, <code>A</code>, etc)</li>\n</ul>\n<p>But I think <code>Bar</code> is never a trait in Rust code, right?</p>",
        "id": 275982740,
        "sender_full_name": "jsha",
        "timestamp": 1647803199
    },
    {
        "content": "<p>Similarly if I search for <code>Bar</code> In Parameters, there are the same two possibilities: <code>Bar</code> could be a concrete type or <code>Bar</code> could be a trait.</p>\n<p>So for instance that would match <code>fn nurt&lt;T: Bar&gt;(a: T)</code>. Is that covered by the \"generics\" code in search.js even though <code>Bar</code> has no angle brackets?</p>",
        "id": 275982897,
        "sender_full_name": "jsha",
        "timestamp": 1647803413
    },
    {
        "content": "<p>Yes, in any case, it matches both traits and types, either they're a bound or a type (so <code>Vec&lt;T&gt;</code> or Vec&lt;u8&gt;<code> or </code>T`.</p>",
        "id": 275983454,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647804214
    },
    {
        "content": "<p>I tried to formalize those rules to understand them better. Are these correct?</p>\n<p>Rule 1: A simple query \"foo\" in an In Parameters search matches a function F if, for any of F's parameters with type X, one of the following is true:</p>\n<ul>\n<li>X is a concrete type, and \"foo\" name-matches[1] X.</li>\n<li>X is a type with generic parameters, and is instantiated such that one of those parameters is a concrete type that name-matches X.</li>\n<li>F has a generic parameter G with trait bounds such that one of the traits that bounds G name-matches \"foo\"; _and_ X is a type with generic parameters; _and_ one of those parameters is assigned to G.</li>\n</ul>\n<p>Rule 2: A query with generics \"foo&lt;bar, baz, ...&gt;\" in an In Parameters search matches a function F if, for any of F's parameters with type X, _all_ of the following are true:</p>\n<ul>\n<li>X is a concrete type, and \"foo\" name-matches X.</li>\n<li>X is a type with generic parameters, and has the same number of generic parameters as there are elements within the brackets after \"foo\" (\"bar\", \"baz\", ...)</li>\n<li>For each of X's generic parameters G, the corresponding element within the brackets of the search matches G according to either rule 1 or rule 2.</li>\n</ul>\n<p>[1]: A string S name-matches a type X if: S == the fully qualified path of X; or S == the last component of the fully-qualified path of X.</p>",
        "id": 276076712,
        "sender_full_name": "jsha",
        "timestamp": 1647879621
    },
    {
        "content": "<p>I'm not exactly sure it is. Let me try to formalize it with my words:</p>\n<p>Rule 1: simple query \"foo\"</p>\n<ul>\n<li>It'll compute levenshtein distance on all items. If the item has generics, it'll try to match generics as well and take the lowest distance.</li>\n<li>If the item is a function, it'll go through its arguments and returned values and run the previous point.</li>\n</ul>\n<p>Rule 2: a bit less simple query \"foo&lt;A&gt;\"</p>\n<p>Mostly the same as before except that it won't use levenshtein distance anymore, only exact matches.</p>\n<p>Rule 3: multiple arguments query \"foo -&gt; ret\"</p>\n<p>Still exact match, but now we compare \"foo\" to the item name and to its arguments and we compare \"ret\" to the returned values.</p>",
        "id": 276102399,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647891061
    },
    {
        "content": "<blockquote>\n<p>If the item has generics, it'll try to match generics as well and take the lowest distance.</p>\n</blockquote>\n<p>This remark is a bit confusing to me. As far as I can tell by looking through the code, the search index only preserves this information for function arguments, not most items.</p>\n<p>For example, I tried searching <code>Vec&lt;u8&gt;</code> with the code in your branch. The \"in parameters\" and \"in return types\" tabs look great, but the \"in names\" section looks like this:</p>\n<p><a href=\"/user_uploads/4715/K-tKwIbXg9hMmycYwgTnamAv/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/K-tKwIbXg9hMmycYwgTnamAv/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/K-tKwIbXg9hMmycYwgTnamAv/image.png\"></a></div>",
        "id": 276106546,
        "sender_full_name": "Michael (notriddle) Howell",
        "timestamp": 1647893208
    },
    {
        "content": "<p>Because generics mismatch are not \"eliminatory\" I think. Should they?</p>",
        "id": 276112791,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647896346
    },
    {
        "content": "<p>Are you saying that generics info for the struct is actually included in the search index? I can't find it, but I'm willing to be proven wrong!</p>",
        "id": 276117079,
        "sender_full_name": "Michael (notriddle) Howell",
        "timestamp": 1647898452
    },
    {
        "content": "<p>I'll check that tomorrow</p>",
        "id": 276126411,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647904894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210316\">@GuillaumeGomez</span> your formalization isn't precise enough for me to understand:</p>\n<blockquote>\n<p>Rule 1: simple query \"foo\"<br>\nIt'll compute levenshtein distance on all items. If the item has generics, it'll try to match generics as well and take the lowest distance.</p>\n</blockquote>\n<p>What does \"all items\" mean? What does \"try to match generics\" mean?</p>\n<p>Maybe I can try restating this:</p>\n<p>Rule 1: A simple query \"foo\" in an In Parameters search and a function F, the _score_ of F is the minimum of the Levenshtein distance between \"foo\" and any of the following:</p>\n<ul>\n<li>The base name of the type of each parameter of F</li>\n<li>The base name of the type assigned to each type parameter of each parameter of F (and so on for those type parameters, recursively)</li>\n<li>Any trait bound on any type variable in the definition of F</li>\n</ul>\n<p>If the _score_ of F is less than MAX_LEV_DISTANCE + 1, \"foo\" matches F and will be included in the search results. Additionally, the search results will be sorted in order of increasing score (lower score means a better match).</p>\n<p>Note: I'm specifically just talking about In Parameters, and not In Return Types or \"both\" (<code>foo -&gt; bar</code>), because it's simpler and once I've figured out how to formalize how it works, it's easy to extend to those other types of searches.</p>",
        "id": 276130502,
        "sender_full_name": "jsha",
        "timestamp": 1647908442
    },
    {
        "content": "<p>\"base name\" in the above means: the final element of an item's path. Does that have a more precise name in Rust?</p>\n<p>Similarly, is there a term for \"the type assigned to a type's type parameters\"? For instance <code>u8</code> in <code>Vec&lt;u8&gt;</code>?</p>",
        "id": 276130546,
        "sender_full_name": "jsha",
        "timestamp": 1647908497
    },
    {
        "content": "<blockquote>\n<p>Similarly, is there a term for \"the type assigned to a type's type parameters\"? For instance u8 in Vec&lt;u8&gt;?</p>\n</blockquote>\n<p>I call them generics for this reason. ^^'</p>",
        "id": 276165246,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647943651
    },
    {
        "content": "<p>I agree with the explanation you have this time.</p>",
        "id": 276165287,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647943674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"210053\">Michael (notriddle) Howell</span> <a href=\"#narrow/stream/266220-rustdoc/topic/search.20syntax.20discussion.20.28for.20.2390630.29/near/276117079\">said</a>:</p>\n<blockquote>\n<p>Are you saying that generics info for the struct is actually included in the search index? I can't find it, but I'm willing to be proven wrong!</p>\n</blockquote>\n<p>Just checked and you are right. The generics are not generated for types (I think they should though but let's keep it for later). So currently, the generics aren't checked on plain types.</p>",
        "id": 276186376,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647954966
    },
    {
        "content": "<blockquote>\n<p>Similarly, is there a term for \"the type assigned to a type's type parameters\"? For instance u8 in Vec&lt;u8&gt;?<br>\nI call them generics for this reason</p>\n</blockquote>\n<p>What do you mean \"this reason\"? Are you saying \"there is no term for the type assigned to a type's type parameters\"?</p>",
        "id": 276225082,
        "sender_full_name": "jsha",
        "timestamp": 1647970020
    },
    {
        "content": "<blockquote>\n<p>I think they should though</p>\n</blockquote>\n<p>I don't think they should be, because I don't think they'd be very useful. There are two reasons why I think so</p>\n<ol>\n<li>\n<p>A lot of generic types don't actually have bounded generics, even if they are unusable without type parameters that implement certain traits. For example, HashMap.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/ndmitchell/hoogle/blob/master/README.md#searching\">Hoogle</a> doesn't seem to support it. They describe things in terms of \"search-by-name\" and \"search-by-type\", and whenever I <a href=\"https://hoogle.haskell.org/?hoogle=%3A%3A+Ord+a+&amp;scope=set%3Astackage\">try to do search-by-type</a>, I only seem to get functions, not typeclasses or data. I'm not a Haskeller, though, so I might be doing it wrong.</p>\n</li>\n</ol>",
        "id": 276226883,
        "sender_full_name": "Michael (notriddle) Howell",
        "timestamp": 1647970751
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/search.20syntax.20discussion.20.28for.20.2390630.29/near/276225082\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Similarly, is there a term for \"the type assigned to a type's type parameters\"? For instance u8 in Vec&lt;u8&gt;?<br>\nI call them generics for this reason</p>\n</blockquote>\n<p>What do you mean \"this reason\"? Are you saying \"there is no term for the type assigned to a type's type parameters\"?</p>\n</blockquote>\n<p>More precisely, by generics I mean the result from the inlining we're doing. For example, when you have <code>fn foo&lt;T: Clone + Bar&gt;(f: Vec&lt;T&gt;)</code>, the end result from the search perspective kinda looks like this: <code>fn foo(f: Vec&lt;Clone, Bar&gt;)</code>. It's not really a trait bound, more like a list of generics like we have in other languages (hence the term I'm using).</p>",
        "id": 276244958,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647978562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"210053\">Michael (notriddle) Howell</span> <a href=\"#narrow/stream/266220-rustdoc/topic/search.20syntax.20discussion.20.28for.20.2390630.29/near/276226883\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I think they should though</p>\n</blockquote>\n<p>I don't think they should be, because I don't think they'd be very useful. There are two reasons why I think so</p>\n<ol>\n<li>\n<p>A lot of generic types don't actually have bounded generics, even if they are unusable without type parameters that implement certain traits. For example, HashMap.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/ndmitchell/hoogle/blob/master/README.md#searching\">Hoogle</a> doesn't seem to support it. They describe things in terms of \"search-by-name\" and \"search-by-type\", and whenever I <a href=\"https://hoogle.haskell.org/?hoogle=%3A%3A+Ord+a+&amp;scope=set%3Astackage\">try to do search-by-type</a>, I only seem to get functions, not typeclasses or data. I'm not a Haskeller, though, so I might be doing it wrong.</p>\n</li>\n</ol>\n</blockquote>\n<p>That's a good point. Well, in any case it's a discussion we can have later on. :)</p>",
        "id": 276244994,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647978585
    }
]