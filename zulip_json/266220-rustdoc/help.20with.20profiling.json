[
    {
        "content": "<p>I've been working on <a href=\"https://github.com/rust-lang/rust/issues/89732\">https://github.com/rust-lang/rust/issues/89732</a> today, and learning the first inklings of profiling in Rust. I've got two flamegraphs, for before and after. They clearly show that render_item got slower, which makes sense since I added some template rendering in there. However, the flamegraphs don't show deeper under that. How can I dig into the details?</p>\n<p>Also, if anyone is available for some live assistance sometime this week, I feel like I could make much faster progress with someone looking over my shoulder. My hours are generally 1600 UTC to 0100 UTC, though I can flex based on people's timezones. Going on a bike ride this afternoon, but tomorrow morning (1600ish UTC / 0900 PT) would be great.</p>\n<p><a href=\"/user_uploads/4715/1fVUoz-X_UnMYDrB21KAnoHi/flamegraph-lesstera-externs-Doc-Full\">flamegraph-lesstera-externs-Doc-Full</a> <a href=\"/user_uploads/4715/ayOnq0QqU2XxGE6xfLsVOJRb/flamegraph-teramore-externs-Doc-Full\">flamegraph-teramore-externs-Doc-Full</a></p>",
        "id": 257109755,
        "sender_full_name": "jsha",
        "timestamp": 1633982205
    },
    {
        "content": "<p>I can try to check with you if you want</p>",
        "id": 257110418,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1633982526
    },
    {
        "content": "<p>It'll be the afternoon for me so it should be fine.</p>",
        "id": 257110489,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1633982570
    },
    {
        "content": "<p>excellent, thanks! are you okay doing a live call, like Google Meet or something?</p>",
        "id": 257110548,
        "sender_full_name": "jsha",
        "timestamp": 1633982599
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> that sounds like you're generating the flamegraphs with <code>-Zself-profile</code> - that's good for getting a vague idea of what's slower, but as you've discovered it's not very detailed. I've used <code>cachegrind</code> in the past for a more detailed view, there are instructions here: <a href=\"https://github.com/rust-lang/rust/pull/87244#issuecomment-920538189\">https://github.com/rust-lang/rust/pull/87244#issuecomment-920538189</a></p>",
        "id": 257115377,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1633985626
    },
    {
        "content": "<p>I am busy most of this week but I could probably make time 9-10 CDT some day (14:00 UTC)</p>",
        "id": 257115583,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1633985754
    },
    {
        "content": "<p>Thanks for the tip! I followed those instructions and ran:</p>\n<div class=\"codehilite\"><pre><span></span><code>cg_diff results/cgout-lesstera-externs-Doc-Full results/cgout-teramore-externs-Doc-Full | sed &#39;s@c1cb97481a633bdfdf3d6b57c6dcebfdfadbcfdf@@&#39; |         sed &#39;s@6928fafe06e4ab29317f75194e1bf67c119dccdc@@&#39; |         rustfilt |         cg_annotate /dev/stdin | less\n</code></pre></div>\n<p>Here's a bit of the output:</p>\n<div class=\"codehilite\"><pre><span></span><code>Ir\n--------------------------------------------------------------------------------\n175,389,412 (100.0%)  PROGRAM TOTALS\n\n--------------------------------------------------------------------------------\nIr                   file:function\n--------------------------------------------------------------------------------\n15,264,218 ( 8.70%)  ./malloc/malloc.c:_int_free\n 9,694,689 ( 5.53%)  ???:&lt;regex::re_trait::Matches&lt;R&gt; as core::iter::traits::iterator::Iterator&gt;::next\n 9,251,931 ( 5.28%)  ???:alloc::collections::btree::map::BTreeMap&lt;K,V&gt;::insert\n 9,026,812 ( 5.15%)  ./string/../sysdeps/x86_64/multiarch/memcmp-avx2-movbe.S:__memcmp_avx2_movbe\n 8,679,939 ( 4.95%)  ./malloc/malloc.c:malloc\n 7,931,216 ( 4.52%)  ???:tera::renderer::processor::Processor::render_node\n 6,247,456 ( 3.56%)  ./malloc/malloc.c:free\n 6,031,251 ( 3.44%)  ./malloc/malloc.c:_int_malloc\n 5,809,794 ( 3.31%)  ???:alloc::collections::btree::node::Handle&lt;alloc::collections::btree::node::NodeRef&lt;alloc::collections::btree::node::marker::Mut,K,V,alloc::collections::btree::node::marker::Leaf&gt;,alloc::collections::btree::node::marker::Edge&gt;::insert_recursing\n 5,701,810 ( 3.25%)  ???:tera::renderer::call_stack::CallStack::lookup\n 4,808,736 ( 2.74%)  ???:tera::utils::escape_html\n 4,516,246 ( 2.57%)  ./string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:__memcpy_avx_unaligned_erms\n 4,387,412 ( 2.50%)  ???:&lt;std::collections::hash::map::DefaultHasher as core::hash::Hasher&gt;::write\n 4,332,914 ( 2.47%)  ???:tera::renderer::stack_frame::StackFrame::find_value\n 4,180,122 ( 2.38%)  ???:tera::renderer::processor::Processor::eval_expression\n 4,096,170 ( 2.34%)  ???:std::io::Write::write_fmt\n 3,814,135 ( 2.17%)  ???:&lt;serde_json::value::ser::SerializeMap as serde::ser::SerializeStruct&gt;::serialize_field\n 3,628,023 ( 2.07%)  ???:hashbrown::map::make_hash\n 3,168,934 ( 1.81%)  /rustc///library/core/src/fmt/mod.rs:core::fmt::write\n 2,958,538 ( 1.69%)  ???:alloc::str::&lt;impl str&gt;::replace\n 2,835,875 ( 1.62%)  ???:alloc::collections::btree::map::entry::VacantEntry&lt;K,V&gt;::insert\n 2,835,875 ( 1.62%)  ???:alloc::collections::btree::navigate::&lt;impl alloc::collections::btree::node::Handle&lt;alloc::collections::btree::node::NodeRef&lt;alloc::collections::btree::node::marker::Dying,K,V,alloc::collections::btree::node::marker::Leaf&gt;,alloc::collections::btree::node::marker::Edge&gt;&gt;::deallocating_next_unchecked\n 2,811,791 ( 1.60%)  ???:&lt;alloc::collections::btree::map::BTreeMap&lt;K,V&gt; as core::ops::drop::Drop&gt;::drop\n 2,715,667 ( 1.55%)  ???:tera::renderer::processor::process_path\n 2,310,660 ( 1.32%)  ???:&lt;std::io::Write::write_fmt::Adapter&lt;T&gt; as core::fmt::Write&gt;::write_str\n 2,262,676 ( 1.29%)  /rustc///library/core/src/fmt/mod.rs:core::fmt::Formatter::pad\n 2,208,368 ( 1.26%)  /rustc///library/core/src/str/pattern.rs:core::str::pattern::StrSearcher::new\n 2,076,350 ( 1.18%)  ???:&lt;core::str::iter::Split&lt;P&gt; as core::iter::traits::iterator::Iterator&gt;::next\n 1,647,249 ( 0.94%)  ???:regex::dfa::Fsm::next_state\n 1,554,453 ( 0.89%)  /rustc///library/core/src/slice/iter/macros.rs:core::fmt::write\n 1,503,501 ( 0.86%)  ???:tera::renderer::processor::Processor::render\n 1,500,211 ( 0.86%)  ???:serde_json::value::Value::pointer\n 1,366,631 ( 0.78%)  /rustc///library/std/src/sys/unix/alloc.rs:__rdl_alloc\n</code></pre></div>\n<p>The BTree stuff in there is because tera puts the mapping of input variable names in a BTree. Interesting to see malloc and free so much. Does that indicate too many objects being allocated? Also, surprising that _int_free (an internal method in malloc, from some brief googling) consumes so many more instructions than plain free.</p>",
        "id": 257156654,
        "sender_full_name": "jsha",
        "timestamp": 1634021063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/help.20with.20profiling/near/257110548\">said</a>:</p>\n<blockquote>\n<p>excellent, thanks! are you okay doing a live call, like Google Meet or something?</p>\n</blockquote>\n<p>as you prefer!</p>",
        "id": 257165801,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1634026742
    },
    {
        "content": "<blockquote>\n<p>Does that indicate too many objects being allocated?</p>\n</blockquote>\n<p>I don't know what you mean by \"too many\"; it's certain more than before. I suspect there's a new intermediate copy into the HashMap, rather than writing directly to the output buffer. I noticed some calls to <code>to_string()</code> in the PR - maybe there's a way to call that on demand with a Display impl?</p>\n<p>It surprises me how expensive the BTree methods are. Are some of the keys very large or something?</p>",
        "id": 257200332,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634044502
    },
    {
        "content": "<p>And the regex methods are surprising too, I guess Tera uses them internally? Is there a way to disable that somehow?</p>",
        "id": 257200450,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634044554
    },
    {
        "content": "<p>What is the new PathComponents type for? Allocating for each segment of each path seems very expensive</p>",
        "id": 257200955,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634044767
    },
    {
        "content": "<blockquote>\n<p>I suspect there's a new intermediate copy into the HashMap, rather than writing directly to the output buffer.</p>\n</blockquote>\n<p>Yes, there's at least one unavoidable intermediate copy / allocation per field. Tera relies on its input objects implementing serde::Serialize as a way to get a list of fields by name. That means each field's value gets turned into a serde_json::Value (<a href=\"https://docs.serde.rs/serde_json/value/enum.Value.html\">https://docs.serde.rs/serde_json/value/enum.Value.html</a>) at some point, which means an allocation of an owned string.</p>\n<blockquote>\n<p>I noticed some calls to to_string() in the PR - maybe there's a way to call that on demand with a Display impl?</p>\n</blockquote>\n<p>There's just one place <a href=\"https://github.com/rust-lang/rust/pull/89695/files\">in the PR </a> that I call to_string explicitly:</p>\n<div class=\"codehilite\"><pre><span></span><code>item_type: &amp;item.type_().to_string(),\n</code></pre></div>\n<blockquote>\n<p>It surprises me how expensive the BTree methods are. Are some of the keys very large or something?</p>\n</blockquote>\n<p>I don't think so. The keys should be the field names.</p>\n<blockquote>\n<p>And the regex methods are surprising too, I guess Tera uses them internally? Is there a way to disable that somehow?</p>\n</blockquote>\n<p>I need to dig into this.</p>\n<blockquote>\n<p>What is the new PathComponents type for? Allocating for each segment of each path seems very expensive</p>\n</blockquote>\n<p>That's for linkifying each element in the breadcrumbs. E.g. std::string::String at the top of the page. It uses \"../\".repeat(...), which I think should allocate just once?</p>",
        "id": 257221615,
        "sender_full_name": "jsha",
        "timestamp": 1634052486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210316\">@GuillaumeGomez</span> if you're available for talk live, I started up a Meet: <a href=\"https://meet.google.com/avt-abmn-zge\">https://meet.google.com/avt-abmn-zge</a></p>",
        "id": 257221791,
        "sender_full_name": "jsha",
        "timestamp": 1634052554
    },
    {
        "content": "<p>had a nice chat, thanks! here are my notes:</p>\n<ul>\n<li>Regex is called in get_json_pointer to split up dotted paths like \"<a href=\"http://foo.bar\">foo.bar</a>\". Can we avoid calling regex? Can we make the regex faster?<br>\n    - get_json_pointer was added in April, and was a bit of a performance regression in some Tera benchmarks</li>\n<li>Can we cache the built BTree and swap out values? -&gt; Yes, we can hang onto a Context and use .extend.</li>\n<li>change write macros to .write()</li>\n</ul>",
        "id": 257230165,
        "sender_full_name": "jsha",
        "timestamp": 1634055593
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>What is the new PathComponents type for? Allocating for each segment of each path seems very expensive</p>\n</blockquote>\n<p>That's for linkifying each element in the breadcrumbs. E.g. std::string::String at the top of the page. It uses \"../\".repeat(...), which I think should allocate just once?</p>\n</blockquote>\n<p>I think what Joshua's saying is that it allocates a <code>String</code> for each segment of <code>std::string::String</code>, which is non-optimal.</p>",
        "id": 257243255,
        "sender_full_name": "Noah Lev",
        "timestamp": 1634060660
    },
    {
        "content": "<p>Why doesn't it store an integer representing how many <code>../</code>s are needed and then wait until later to render the <code>../</code>?</p>",
        "id": 257243405,
        "sender_full_name": "Noah Lev",
        "timestamp": 1634060738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/help.20with.20profiling/near/257230165\">said</a>:</p>\n<blockquote>\n<ul>\n<li>change write macros to .write(quote</li>\n</ul>\n</blockquote>\n<p>I checked this change locally, doesn't seem to improve things much. I think clippy would complain about that too, to be checked.</p>",
        "id": 257247414,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1634062287
    },
    {
        "content": "<p>I don't think it's particularly important whether clippy complains about it or not</p>",
        "id": 257248579,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634062776
    },
    {
        "content": "<blockquote>\n<p>I think what Joshua's saying is that it allocates a String for each segment of std::string::String, which is non-optimal.</p>\n</blockquote>\n<p>Got it. This is a general pattern in Tera: When you need to pass in a list of things (e.g. a list of method names, or a list of parameters within a method), you have to pass them as something that implements Serialize. This winds up getting converted to a Vec&lt;String&gt; inside Tera, so that's always going to cause a decent number of allocations.</p>\n<p>We could think about different ways the Tera API could work - for instance it could be design such that it can receive an Iterator&lt;Item = &amp;str&gt; instead, to avoid excess allocations. I think that would be a pretty significant redesign - but it might be worth bringing up since it sounds like a 2.0 version is on the table.</p>\n<p>By the way, I've noticed that in discussion of Rust performance, number of allocations (like how many Strings you create) often comes up as an important thing to optimize. I haven't noticed that showing up quite so often other (mainly GC'ed) languages. Are allocations particularly expensive in Rust? Or is it that other options are relatively fast, so the cost of allocations shows up more?</p>",
        "id": 257266832,
        "sender_full_name": "jsha",
        "timestamp": 1634070423
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> I suspect that other languages are using the equivalent of <code>Arc&lt;str&gt;</code> everywhere, so clones are cheap</p>",
        "id": 257268440,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634071098
    },
    {
        "content": "<p>not sure that makes sense for us here because these are substrings - although I think you could put &amp;str inside the serialize context instead of a String?</p>",
        "id": 257268507,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1634071126
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/266220-rustdoc/topic/help.20with.20profiling/near/257248579\">said</a>:</p>\n<blockquote>\n<p>I don't think it's particularly important whether clippy complains about it or not</p>\n</blockquote>\n<p>It's more like \"since it doesn't change perf much, we can always come back to it by running clippy\"</p>",
        "id": 257327756,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1634113014
    }
]