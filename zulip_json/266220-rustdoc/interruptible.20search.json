[
    {
        "content": "<p>Right now we have to be somewhat cautious about when we begin a search, because it is moderately expensive (100ms) and all of that time is spent in a JS loop that blocks UI interaction. So we only do a search if typing idles for 500ms. That can feel a little slow - but can also be a little disorienting since the search \"acts like\" an autocomplete in some ways.</p>\n<p>We can improve things by (a) making the JS cooperatively yield execution, and (b) allowing interruption. The idea is something like this:</p>\n<p>When a search is triggered, it produces a <code>RunningSearch</code> object. The main work is done by <code>RunningSearch.run()</code>, which processes ~1000 items from the search index, updates an internal counter, then yields by calling <code>setTimeout(self.run, 0)</code>. That puts a call to itself on the end of the event queue, to be run when any other events (like user interaction) have finishes. When <code>run</code> has collected all items, it renders them to the page.</p>\n<p>The <code>RunningSearch</code> object would also have a <code>.cancel()</code> function that makes subsequent calls to <code>.run()</code> return immediately.</p>\n<p>If this works the way I expect it to, it would have the added benefit of making search work reasonably well even for very large indexes. That is, it would still be somewhat slow, but user interaction with the page would still work while it's running. And we could even update a progress indicator.</p>",
        "id": 265506869,
        "sender_full_name": "jsha",
        "timestamp": 1639957100
    },
    {
        "content": "<p>I don't think you can have JS run without blocking the UI unfortunately (to be confirmed!).</p>",
        "id": 265537540,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1639991562
    },
    {
        "content": "<p>JavaScript <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises\">Promise</a> ?</p>",
        "id": 265537952,
        "sender_full_name": "Urgau",
        "timestamp": 1639991862
    },
    {
        "content": "<p>The code is still blocking the UI with promises when it's being executed.</p>",
        "id": 265546883,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1639997364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210316\">@GuillaumeGomez</span> correct, you can't have a tight loop in JS without blocking the UI. However, you can cooperatively yield control to the UI by making sure you don't spend too long on the event loop: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop</a>.</p>\n<p>Example:</p>\n<div class=\"codehilite\"><pre><span></span><code>var pi = &quot;3.&quot;;\n\nfunction calculatePi(begin, end) {\n  var i = begin;\n  for (; i &lt; min(end, begin + 100); i++) {\n    pi += calculateDigit(i);\n  }\n  if (i &lt; end) {\n    setTimeout(function() {\n      calculatePi(i, end);\n    }, 0)\n  }\n}\n</code></pre></div>\n<p>What's going on here is the code says \"I've done enough work for now, stick me on the end of the event queue and come back to me when you've handled any other events that need handling.\"</p>",
        "id": 265600444,
        "sender_full_name": "jsha",
        "timestamp": 1640025007
    },
    {
        "content": "<p>Note this is very similar to Rust's async model, and indeed JS' async model, which wraps patterns like the above in Promises to make them easier to work with; though Promises can be harder to work with for compute-heavy tasks.</p>",
        "id": 265600600,
        "sender_full_name": "jsha",
        "timestamp": 1640025108
    },
    {
        "content": "<p>There's also a \"true parallelism\" approach: We can pass the work off to a ServiceWorker, and it will be done in a different thread. We'll get an event when it's done. However, I think the above approach is easier as a first step. Even with a ServiceWorker approach we'd have to build in some yield points for cancelability.</p>",
        "id": 265600732,
        "sender_full_name": "jsha",
        "timestamp": 1640025164
    },
    {
        "content": "<p>But then it would slow down the search I guess. It's an added complexity for a potential gain but I'm not sure if it'll be big enough to be worth it.</p>",
        "id": 265601613,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1640025709
    },
    {
        "content": "<p>Because this is cooperative interruption, it should only slow things down by the cost of a few branch instructions (on the order of nanoseconds), not like preemptive (threaded) interruption, which costs about 15ms.</p>",
        "id": 265602652,
        "sender_full_name": "jsha",
        "timestamp": 1640026314
    },
    {
        "content": "<p>And this also makes nicer features possible, like real time search instead of waiting until the user stops typinh</p>",
        "id": 265602764,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640026365
    },
    {
        "content": "<p>Exactly!</p>",
        "id": 265602903,
        "sender_full_name": "jsha",
        "timestamp": 1640026449
    },
    {
        "content": "<p>True. Well, I'm currently updating <a href=\"https://github.com/rust-lang/rust/pull/90630\">https://github.com/rust-lang/rust/pull/90630</a> to implement <span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> comments. With the much smaller loops, it'll be much simpler to implement this</p>",
        "id": 265603769,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1640026941
    }
]