[
    {
        "content": "<p>Hi, I claimed this issue because it seemed like a good first one, and spent a few days looking at <code>collect_intra_doc_links</code> and around, starting from the point that was suggested in there (<code>resolve_link</code>).</p>\n<p>I have one initial problem that is slowing down trying things and in general debugging/figuring out what's what. I figured I could execute these paths by creating a separate tiny cargo project, with one or two lines of docs on top of <code>main</code>, and use my stage 1 rustdoc on it. It's a pretty slow process: change a line in rustdoc, build, run it on another project. I doubt anyone works like that, what am I missing? Debug output is so thick I've had to change some lines to <code>info!</code> and I'm looking at that instead because it's more manageable. I feel there's some basic workflow thing I missed.</p>\n<p>On that line, I also tried to find some unit tests that maybe would place me in that context, so that instead maybe i could just run some specific tests and get quicker feedback, but I'm afraid the unit tests cover rustdoc more generally, not the intra-doc links pass in particular, and the UI tests are probably going to be around the last things I'll be able to test :(</p>\n<p>Finally, for something more concrete: i intend to add this check within <code>resolve_link</code>. In order to know whether <code>[Text](path::to::Text)</code> is equivalent to <code>[Text]</code>, I believe I would need to run the actual resolution (<code>resolve_with_disambiguator_cached</code>) a second time on a \"made up\" <code>MarkdownLink</code> and check if the returned <code>Res</code>'s <code>DefId</code> is equal to the one for the actual link. Does this make sense?</p>\n<p>I have some more smaller questions but I think that's enough to start the topic. Thank you</p>",
        "id": 252001150,
        "sender_full_name": "marian",
        "timestamp": 1630762388
    },
    {
        "content": "<blockquote>\n<p>It's a pretty slow process: change a line in rustdoc, build, run it on another project. I doubt anyone works like that, what am I missing? </p>\n</blockquote>\n<p>Nope, this is pretty much how I work <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> how long are the builds taking you? For me they're around 20 seconds for an incremental change.</p>\n<blockquote>\n<p>Debug output is so thick I've had to change some lines to info! and I'm looking at that instead because it's more manageable.</p>\n</blockquote>\n<p>What log variable are you setting? I usually use <code>RUSTDOC_LOG=rustdoc::passes::collect_intra_doc_links=debug</code>, which filters out both <code>trace!</code> logs and anything from other modules.</p>\n<blockquote>\n<p>On that line, I also tried to find some unit tests that maybe would place me in that context, so that instead maybe i could just run some specific tests and get quicker feedback, but I'm afraid the unit tests cover rustdoc more generally, not the intra-doc links pass in particular, and the UI tests are probably going to be around the last things I'll be able to test :(</p>\n</blockquote>\n<p>I don't think they would speed things up much anyway - you'd still have to build rustdoc to run the tests. Have you found the intra-doc link tests? You can run them with <code>x.py test src/test/rustdoc/intra-doc src/test/rustdoc-ui/intra-doc</code>, and they run reasonably quickly (~7 seconds for me). You can add your own UI test which means you don't have to switch between directories to test your changes.</p>\n<blockquote>\n<p>I believe I would need to run the actual resolution (resolve_with_disambiguator_cached) a second time on a \"made up\" MarkdownLink and check if the returned Res's DefId is equal to the one for the actual link.</p>\n</blockquote>\n<p>Hmm, I think you're right that you don't need all of <code>resolve_link</code>, just <code>resolve_with_disambiguator_cached</code>. You shouldn't need a full <code>MarkdownLink</code> though, just the module, disambiguator, and path_str. You should already have the module as a parameter, and you can get the disambiguator and path_str by calling <code>preprocess_link</code>.</p>",
        "id": 252003111,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630764378
    },
    {
        "content": "<blockquote>\n<p>how long are the builds taking you? For me they're around 20 seconds for an incremental change.</p>\n</blockquote>\n<p>Just checked, it took a little under a minute. It's not terribly bad, I just wanted to make sure there wasn't a better way i wasn't aware of. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<blockquote>\n<p>What log variable are you setting?</p>\n</blockquote>\n<p>Here's my janky debug one-liner: <code>rm -r -Force .\\target\\doc; $env:RUSTDOC_LOG = 'rustdoc::passes::collect_intra_doc_links=info'; $env:RUSTDOC = 'C:\\src\\rust\\build\\x86_64-pc-windows-msvc\\stage1\\bin\\rustdoc.exe'; cargo doc</code> (i started doing this on windows/powershell and now i don't know how to set the variable for the entire session so I'm just setting it before the command). This is not so bad because in any case I can just turn <code>debug</code> into <code>info</code>. My problem with <code>debug</code> is that there is so much more activity besides the processing of my own test docs that it gets lost. Now that i'm writing this down, maybe i just need to pipe the output into a file </p>\n<blockquote>\n<p>Have you found the intra-doc link tests?</p>\n</blockquote>\n<p>I saw them, they run fairly quickly (30s for rustdoc tests, 6s for rustdoc-ui), but since I would've needed to (i think) create the new lint and be able to output the warning in order to make use of those tests, i kind of discarded that option for now.</p>\n<p>I'll spend some more time on this and have some more questions soon. Thanks a lot for the help! it's much appreciated</p>",
        "id": 252005246,
        "sender_full_name": "marian",
        "timestamp": 1630766483
    },
    {
        "content": "<blockquote>\n<p>since I would've needed to (i think) create the new lint and be able to output the warning in order to make use of those tests</p>\n</blockquote>\n<p>Hmm, I think you should be able to add a failing test even before you add the lint.</p>\n<p>Have you been using <code>x.py check src/tools/rustdoc</code> btw? It's a lot faster than a full build.</p>",
        "id": 252005420,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630766652
    },
    {
        "content": "<p>good points, both. I'll see if adding a test is an easier way to get my changes to run than running rustdoc on a separate project</p>",
        "id": 252005548,
        "sender_full_name": "marian",
        "timestamp": 1630766809
    },
    {
        "content": "<p>There's also a hybrid solution that avoids switching directories, which is what I often use: create a single-file crate (<code>foo.rs</code>, say) and then run <code>rustdoc +stage1 foo.rs</code>. I often do this if I want to quickly test something.</p>",
        "id": 252015175,
        "sender_full_name": "Noah Lev",
        "timestamp": 1630777295
    },
    {
        "content": "<p>So that single-file crate could just be this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">//! [Iterator](std::iter::Iterator)</span>\n</code></pre></div>",
        "id": 252015191,
        "sender_full_name": "Noah Lev",
        "timestamp": 1630777321
    },
    {
        "content": "<p>that's assuming you have two terminals open though, right? at some point you need to run x.py build</p>",
        "id": 252015230,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630777331
    },
    {
        "content": "<p>Yes, you do need to run <code>x build</code>.</p>",
        "id": 252015238,
        "sender_full_name": "Noah Lev",
        "timestamp": 1630777343
    },
    {
        "content": "<p>But it avoids having to switch directories</p>",
        "id": 252015246,
        "sender_full_name": "Noah Lev",
        "timestamp": 1630777351
    },
    {
        "content": "<p>Why would you need two terminals open?</p>",
        "id": 252015250,
        "sender_full_name": "Noah Lev",
        "timestamp": 1630777355
    },
    {
        "content": "<p>oh oh, you mean to put the single file in the checkout of rust-lang/rust</p>",
        "id": 252015263,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630777375
    },
    {
        "content": "<p>Yes, that's what I usually do.</p>",
        "id": 252015275,
        "sender_full_name": "Noah Lev",
        "timestamp": 1630777393
    },
    {
        "content": "<p>I don't like doing that because the generated docs end up in <code>doc/</code> which adds untracked files. But I'm realizing now that the docs for rust-lang/rust live in <code>src/doc</code>, not <code>doc/</code>, so it's easy enough to run <code>rm -r doc</code>.</p>",
        "id": 252015286,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630777412
    },
    {
        "content": "<p>Thanks again for the suggestions and the help. I've managed to get a more manageable test case with Noah's suggestion, and got a basic proof of concept.</p>\n<p>Turns out that even <code>resolve_with_disambiguator_cached</code> is too much for this. Since this is just an attempt at resolving a hypothetical link, we don't need the resolution failure to be reported so maybe <code>resolve</code> will be enough. It seems there is useful resolving logic in <code>resolve_with_disambiguator</code>, trying with the given disambiguator first and otherwise trying all namespaces, that should also run when resolving the shortcut link, but unfortunately this method also reports diagnostics. Maybe it could just return <code>Result</code> without side effects, and its callers could handle the diagnostics output.</p>",
        "id": 252109249,
        "sender_full_name": "marian",
        "timestamp": 1630884532
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> seems reasonable to change, just a little tricky</p>",
        "id": 252111861,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630887625
    },
    {
        "content": "<p>wait hold on I misread:</p>\n<blockquote>\n<p>It seems there is useful resolving logic in resolve_with_disambiguator, trying with the given disambiguator first and otherwise trying all namespaces, that should also run when resolving the shortcut link, but unfortunately this method also reports diagnostics. </p>\n</blockquote>\n<p>I don't think we need to retry with a different disambiguator; it seems really weird for anyone to write <code>[type@Iterator](type@std::iter::Iterator)</code>. Just trying the original link text seems fine.</p>",
        "id": 252219095,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630959158
    },
    {
        "content": "<p>in particular, I don't think we should suggest changing <code>[Iterator](type@Iterator)</code> to <code>[type@Iterator]</code>.</p>",
        "id": 252219137,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630959195
    },
    {
        "content": "<p>that makes sense. So it would be reasonable to skip this whole check whenever a disambiguator has been specified</p>",
        "id": 252225996,
        "sender_full_name": "marian",
        "timestamp": 1630964690
    },
    {
        "content": "<p>I think we should skip the check whenever we're doing it for the lint. We should never suggest adding a disambiguator to the link text, even if it would resolve to a valid link.</p>",
        "id": 252226550,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630965223
    },
    {
        "content": "<p>sorry, I meant to say: the entire new lint check (namely, the second resolution) should be skipped whenever a disambiguator has been specified. Even if it's on a link like (i don't know if this is valid) <code>[Iterator](type@std::iter::Iterator)</code> -- in this case we would let that be and will not warn or suggest anything.</p>",
        "id": 252226803,
        "sender_full_name": "marian",
        "timestamp": 1630965462
    },
    {
        "content": "<p>I don't see why your example is relevant - <code>[Iterator]</code> would be fine to suggest.</p>",
        "id": 252227063,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630965661
    },
    {
        "content": "<p>we don't want to suggest a disambiguator in the link <em>text</em>: <code>[type@Iterator]</code>. But whether the current link <em>target</em> uses a disambiguator or not doesn't matter.</p>",
        "id": 252227091,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1630965699
    }
]