[
    {
        "content": "<p>Looking into <a href=\"https://github.com/rust-lang/rust/issues/83718\">#83718</a>, thoughts so far:</p>\n<ul>\n<li>Less desugared looking item comes from cache.implementors, more desugared from cache.impls</li>\n<li>Tracing back to where they came from, <code>CacheBuilder::fold_item</code></li>\n<li>In that method, implementors is extended from the original item. impls is extended from the item <em>after</em> <code>fold_item_recur</code> is called</li>\n</ul>",
        "id": 267776996,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642017167
    },
    {
        "content": "<p>I'm going to see if moving the push to impls before that call is possible/changes anything</p>",
        "id": 267777088,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642017214
    },
    {
        "content": "<p>I see, it seems it's done afterwards specifically because it wants to fold the generics first. The question is if maybe it can skip replacing visibility/default</p>",
        "id": 267777519,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642017393
    },
    {
        "content": "<p>Nevermind, that call isn't what changes it. It appears twice in the original module provided to fold, already different. Need to trace back earlier</p>",
        "id": 267778641,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642017918
    },
    {
        "content": "<p>Okay looks like clean::TraitItem and clean::ImplItem just don't agree on the exact value of the items they're implementing</p>",
        "id": 267779130,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642018143
    },
    {
        "content": "<p>Alright so. As it stands, I have two options<br>\n1) Try to dive into rustc and figure out why the HIR is different for impls vs traits. This may be a simple change, or it may be incredibly painful<br>\n2) Change how json handles the equality check to instead check for equivalence, and/or pick the better impl. This would be time-consuming, but would avoid the problem entirely</p>",
        "id": 267780775,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642018981
    },
    {
        "content": "<blockquote>\n<p>HIR is different for impls vs traits.</p>\n</blockquote>\n<p>Do you mean different for inherent impls vs trait impls?</p>",
        "id": 267780876,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642019039
    },
    {
        "content": "<p>I may actually still be confused. I was talking about between a TraitItem and an ImplItem, but that isn't actually this issue. The issue is that it's different between two instances of an ImplItem</p>",
        "id": 267781436,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642019318
    },
    {
        "content": "<p>I realized I'm still not sure what exactly is going on, as it doesn't matter if the TraitItem and ImplItem disagree, but the ImplItem is inconsistent at two different points in the process.</p>",
        "id": 267781500,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642019355
    },
    {
        "content": "<p>I think I might know a way to fix part of this; it seems like it may be related to <code>FnRetTy</code></p>",
        "id": 267781595,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642019402
    },
    {
        "content": "<p>Or at least Joshua's MCVE is</p>",
        "id": 267781640,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642019409
    },
    {
        "content": "<p>FnRetTy and Visibility are the two things</p>",
        "id": 267781660,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642019420
    },
    {
        "content": "<p>And the self ty</p>",
        "id": 267781694,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642019434
    },
    {
        "content": "<p>I may need to pause for a bit soon, but I'm probably going to go back to the beginning and try again to trace down why I'm getting two slightly different versions of the same ImplItem</p>",
        "id": 267781831,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642019502
    },
    {
        "content": "<p>Sorry if this stream is hard to follow, I'm kind of thought-streaming as I go so I have a record of my thoughts, and in case someone is like 'Hey you just said something blatantly wrong / trivially solvable'</p>",
        "id": 267781838,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642019506
    },
    {
        "content": "<p>thought-streaming is a great technique!</p>",
        "id": 267782725,
        "sender_full_name": "jsha",
        "timestamp": 1642019890
    },
    {
        "content": "<p>Alright, so I get what Noah was saying better now. When the self ty is the generic, the method inside it is the 'unresolved' version. But for each specific impl, those are compiler generated, and it uses actual visibilities and return types instead of 'default' or 'inherited'</p>",
        "id": 267789083,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642023112
    },
    {
        "content": "<p>I feel the real solution would be if it was possible to skip trying to document methods inside generated impls, but I'm not sure how that would be detected, especially given I'm not sure what rules there are about iteration orders</p>",
        "id": 267789163,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642023154
    },
    {
        "content": "<p>Allowing equivalent but not equal types would be possible, but may introduce inconsistencies in user-seen output, where order in the code changes the output or such</p>",
        "id": 267789356,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642023291
    },
    {
        "content": "<p>Third option, make Rust generated impls from blankets exactly match their parents, not resolving visibility or return type. This may be impossible or easy, but either way would involve compiler changes :P</p>",
        "id": 267789499,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642023394
    },
    {
        "content": "<p>Actually, it is already detected whether it's a blanket. ItemId::Blanket vs ItemId::DefId</p>",
        "id": 267790526,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642023950
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319144\">CraftSpider</span> <a href=\"#narrow/stream/266220-rustdoc/topic/json.20ICE.20breaking/near/267789083\">said</a>:</p>\n<blockquote>\n<p>Alright, so I get what Noah was saying better now. When the self ty is the generic, the method inside it is the 'unresolved' version. But for each specific impl, those are compiler generated, and it uses actual visibilities and return types instead of 'default' or 'inherited'</p>\n</blockquote>\n<p>That's not really what I was saying, but it seems you figured it out anyway <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 267804262,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642031187
    },
    {
        "content": "<p>I'm not sure what you mean by \"unresolved\"</p>",
        "id": 267804290,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642031217
    },
    {
        "content": "<p>I think the issue here is that we should be generating <code>Inherited</code> visibility and <code>self</code> argument names for both impls</p>",
        "id": 267804320,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642031245
    },
    {
        "content": "<p>So, the issue as far as I can tell is that the HIR we're given to clean already has <code>Public</code> instead of <code>Inherited</code> visibility. We could... Revert it in the clean pass, maybe? Turning public or empty tuple on a blanket impl back into the correct type. I'm not sure</p>",
        "id": 267814629,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642039368
    },
    {
        "content": "<p>Clean doesn't use HIR for visibility anymore; it only uses <code>ty::Visibility</code> (computed visibility)</p>",
        "id": 267814938,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642039693
    },
    {
        "content": "<p>I fixed the issue in general by avoiding documenting blanket impl children more than once, but I also see where the visibility quirk comes from - ty::Visibility is actually always public, but when cleaning, ImplItems get it set to 'inherited' in certain cases, and the code path for blanket impls is likely slightly different from the one for the actual impl</p>",
        "id": 267907444,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642097016
    },
    {
        "content": "<p>There are a number of notes around the relevant code paths explaining some of what is going on, and implying this kind of thing could happen</p>",
        "id": 267907593,
        "sender_full_name": "CraftSpider",
        "timestamp": 1642097079
    },
    {
        "content": "<p>Yep, rustdoc has too many code paths â€” it's the root of most bugs ;)</p>",
        "id": 267915381,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642100763
    }
]