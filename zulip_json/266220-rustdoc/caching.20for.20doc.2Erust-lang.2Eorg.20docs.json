[
    {
        "content": "<p>For the stdlib docs on <a href=\"http://doc.rust-lang.org\">doc.rust-lang.org</a>, here's the current situation for caching: everything is in S3, so it gets ETags and Last-Modified automatically. The Cache-Control headers are controlled by what's set when uploading to S3, which is currently nothing. That means it's up to browsers to apply a heuristic about how long to cache.</p>\n<p>According to <a href=\"https://paulcalvano.com/2018-03-14-http-heuristic-caching-missing-cache-control-and-expires-headers-explained/\">https://paulcalvano.com/2018-03-14-http-heuristic-caching-missing-cache-control-and-expires-headers-explained/</a>, that heuristic is \"10% of the time since Last-Modified.\" So for anything in the current stable docs, released 29 days ago, the heuristic cache time is 2.9 days. After the next stable is released, the heuristic cache time will be ~0 days, and slowly go up.</p>\n<p>It'd be nice to do better! In particular, for versioned static assets like CSS, JS, and fonts (especially fonts), we'd like to do as <a href=\"http://docs.rs\">docs.rs</a> does and set a long max-age plus \"immutable.\" For nightly, this doesn't really work, since those static assets get overwritten (with the same version number) every night. However, for the stable docs, this could work.</p>\n<p>For HTML in the stable docs: We could set \"Expires\" to the scheduled release of the next stable version. But that would create a problem when there needs to be a patchlevel release in between. During an uneventful 6-week release cycle with no patchlevel releases, the heuristic cache time would get as high as 4.2 days. So we could safely set max-age=4.2 days and have not much worse than the current situation. Or we could round up a bit in the name of more caching and say 7 days. We could also set stale-while-revalidate to some period on the order of months.</p>\n<p>For HTML in the nightly docs: Here we can quite confidently set Expires to the time of the next planned nightly build, since it's unlikely there will be another build in between.</p>",
        "id": 262957610,
        "sender_full_name": "jsha",
        "timestamp": 1638147058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> these seem like good ideas, but rustdoc doesn't control them: you should talk to T-infra</p>",
        "id": 262957686,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638147128
    },
    {
        "content": "<p>Feel free to ping me if you want feedback on the proper cache options though!</p>",
        "id": 262957688,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638147142
    },
    {
        "content": "<p>Also, I don't think it's a big deal to cache the stable docs even after a point release; usually those only modify the compiler, I've never seen one that changes a public API</p>",
        "id": 262957704,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638147227
    },
    {
        "content": "<p>right, rustdoc doesn't control them, but I think T-rustdoc has the best insight into what might break if you have different versions of things cached.</p>",
        "id": 262957706,
        "sender_full_name": "jsha",
        "timestamp": 1638147233
    },
    {
        "content": "<p>I noticed you didn't mention beta - it gets updated pretty often I'd say (I usually see around 7 updates before it's promoted to stable) but those also rarely modify public APIs, so I think a week-long cache or something would be fine</p>",
        "id": 262957767,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638147320
    },
    {
        "content": "<p>also from a tradeoffs perspective - users seeing stale docs vs getting better performance - is that something that T-rustdoc has input on or is it solely T-infra's decision?</p>",
        "id": 262957770,
        "sender_full_name": "jsha",
        "timestamp": 1638147333
    },
    {
        "content": "<p>I don't think there's precedent for this</p>",
        "id": 262957829,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638147430
    },
    {
        "content": "<p>But I would be very surprised if infra just completely ignored us haha</p>",
        "id": 262957834,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638147450
    },
    {
        "content": "<p>What does the \"immutable\" cache header do? The /stable/ urls do change, it's only /1.XX/ that's immutable</p>",
        "id": 262957901,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638147542
    },
    {
        "content": "<p>according to <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control</a> it sounds like:</p>\n<p>for resources that are still fresh, a soft-reload will send an If-Modified-Since/If-None-Match to revalidate them. If those resources were marked immutable, a soft-reload will not revalidate them.</p>",
        "id": 262958006,
        "sender_full_name": "jsha",
        "timestamp": 1638147621
    },
    {
        "content": "<p>It's meant for versioned URLs - so like <a href=\"https://doc.rust-lang.org/main1.56.1.js\">https://doc.rust-lang.org/main1.56.1.js</a></p>",
        "id": 262958045,
        "sender_full_name": "jsha",
        "timestamp": 1638147672
    },
    {
        "content": "<p>or from <a href=\"https://pokeinthe.io/2021/09/13/cache-control-recommendations/\">https://pokeinthe.io/2021/09/13/cache-control-recommendations/</a>:</p>\n<blockquote>\n<p>immutable<br>\nwhen combined with a large max-age, instructs the browser to not check to see if it's still valid, even when user purposefully chooses to refresh their browser</p>\n</blockquote>",
        "id": 262958124,
        "sender_full_name": "jsha",
        "timestamp": 1638147774
    },
    {
        "content": "<p>Here's a blog post about immutable: <a href=\"https://paulcalvano.com/2018-01-07-cache-control-immutable-a-year-later/\">https://paulcalvano.com/2018-01-07-cache-control-immutable-a-year-later/</a></p>",
        "id": 262958192,
        "sender_full_name": "jsha",
        "timestamp": 1638147899
    },
    {
        "content": "<p>Linked from there, it sounds like Chrome nerfed the reload button in 2017: <a href=\"https://blog.chromium.org/2017/01/reload-reloaded-faster-and-leaner-page_26.html\">https://blog.chromium.org/2017/01/reload-reloaded-faster-and-leaner-page_26.html</a>. Now a reload in Chrome only revalidates the main page, rather than trying to revalidate all subresources, regardless of whether immutable was set.</p>",
        "id": 262958275,
        "sender_full_name": "jsha",
        "timestamp": 1638148037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/266220-rustdoc/topic/caching.20for.20doc.2Erust-lang.2Eorg.20docs/near/262957704\">said</a>:</p>\n<blockquote>\n<p>Also, I don't think it's a big deal to cache the stable docs even after a point release; usually those only modify the compiler, I've never seen one that changes a public API</p>\n</blockquote>\n<p>Counterexample: <a href=\"https://blog.rust-lang.org/2017/02/09/Rust-1.15.1.html#whats-in-1151-stable\">https://blog.rust-lang.org/2017/02/09/Rust-1.15.1.html#whats-in-1151-stable</a></p>\n<p>But yeah, almost never an issue.</p>",
        "id": 262958515,
        "sender_full_name": "scottmcm",
        "timestamp": 1638148465
    },
    {
        "content": "<p>I mean yeah, this is the exception that proves the rule <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> this is the only one I've seen in 6 years of stable rust</p>",
        "id": 262958604,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638148670
    }
]