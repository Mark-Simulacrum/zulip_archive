[
    {
        "content": "<p>Hi everyone. I opened <a href=\"https://github.com/rust-lang/rust/pull/90630\">https://github.com/rust-lang/rust/pull/90630</a> yesterday and went completely overboard with it: what was supposed to be the add of a parser ended up with a refactoring of the search itself. Before going any further, we should first check if everyone is ok with those changes and if it needs to go through RFC or any other process. I'll also split the PR into smaller ones to make it simpler to review instead of simply splitting changes into commits.</p>\n<p>So first, explanations on the PR (and the parser more precisely): I added the possibility to differentiate between name, arguments and returned value and to correctly handle generics (recursively) and to tell which item should be looked \"literally\". Currently, we \"kinda\" handle most of them.<br>\nFor example, you can look for <code>vec</code> or <code>\"vec\"</code> (literal search) or <code>vec -&gt; vec</code> or <code>-&gt; vec</code>, and you can also give generics <code>vec&lt;i32&gt;</code>. However,  all of them are very poorly \"parsed\" and the result is - at best - suboptimal.</p>\n<p>The goal of the parser I wrote was to allow each item to have generics (including generics themselves) and to differentiate between item name, item arguments and item returned value. At this point, you can even tell with item should use literal search. So for example: <code>fn(arg&lt;\"i32\") -&gt; ret</code> means \"we want an item with a name close to \"fn\", with at least one argument with name close to \"arg\" but with a generic called \"i32\" and which returns an item with a name close to \"ret\".</p>\n<p>Of course, all parts are optional. The only \"weird\" case is when we have something like <code>vec -&gt; ret</code> because in this case, we don't know if <code>vec</code> is the item name or an argument's name. In this case, I check for both. So the big difference in the syntax is now that we handle parens (<code>()</code>).</p>\n<p>Important to note: the parser is very \"lazy\": if it's not one of the few separators, it considers it part of the name and moves on. So if you write <code>a++a</code>, it's a perfectly valid name for the parser and it'll look for an item named <code>a++a</code> (just like currently). Quite useful for doc aliases I suppose?</p>\n<p>In case the query is just one non-specified item (like <code>vec</code>), the search is almost exactly the same as the current one (minus the fact that it's now much simpler to search since the query is \"parsed\"/\"sorted\").</p>\n<p>So first, do these explanations make sense to you? I know I'm often very bad at explaining things so don't hesitate if anything is not clear!</p>\n<p>Second, do you agree with these changes? Do you think it should go through an RFC to get validated or another process?</p>\n<p>And finally: here is how I plan to split the PRs:</p>\n<ol>\n<li>Parser and the tests for it without changing anything else in the search (except for the fields usage from the type returned by the parser of course).</li>\n<li>The simplification of the parser by taking full advantage of the parser.</li>\n<li>Put back the optimizations I included (sorting the result takes most of the time so I reduce the number of items to be sorted based on the maximum number of items we display, I can provide more explanations if you want?).</li>\n</ol>\n<p>And again: sorry for going overboard. What started as a simple parser ended up in a complete rewrite of the search. I should have asked beforehand if it was ok to go with this as is and if the team was ok with the syntax changes I added.</p>\n<p>What do you think about this <span class=\"user-mention\" data-user-id=\"307537\">@Noah Lev</span> <span class=\"user-mention\" data-user-id=\"132040\">@Manish Goregaokar</span> <span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> <span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span>?</p>",
        "id": 260576637,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1636294898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210316\">@GuillaumeGomez</span> 3 looks independent of the rest, I would make that PR first. Not sure if I understand the difference between 1 and 2.</p>\n<p>Is it possible to land the new parser without making syntax changes? If so I think we should do that first.</p>",
        "id": 260577932,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636296461
    },
    {
        "content": "<p>It would be complicated but possible with some changes I think</p>",
        "id": 260578024,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1636296553
    },
    {
        "content": "<p>And 3 could be completely done independently from the rest indeed</p>",
        "id": 260578037,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1636296574
    },
    {
        "content": "<p>Oh I forgot to tag <span class=\"user-mention\" data-user-id=\"210053\">@Michael Howell</span> (notriddle)</p>",
        "id": 260578102,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1636296613
    },
    {
        "content": "<p>Just to sum it up, the main differences between the two parsers are:</p>\n<ul>\n<li>The exact search (using double quotes) is for the whole query actually whereas the parser made item-specific.</li>\n<li>The generics can have generics in the new parser (we can force to stop at the first level in this case if we want full compatibility or simply ignore lower levels).</li>\n<li>The add of the parens support (<code>()</code>).</li>\n</ul>",
        "id": 260578299,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1636296877
    },
    {
        "content": "<p>Thanks for the detailed writeup!</p>\n<p>Can you elaborate on the \"generics can have generics\" bit? Is this the part that's related to trait bounds?</p>",
        "id": 260610015,
        "sender_full_name": "Noah Lev",
        "timestamp": 1636339514
    },
    {
        "content": "<p>No problem: so here is an example: <code>a&lt;b&lt;c&lt;d, e&gt;, f&gt;</code></p>",
        "id": 260633886,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1636364584
    },
    {
        "content": "<p>Meaning that we will look if an item <code>a</code> has generics <code>b</code>, which has generics <code>c</code>, etc. To be noted that <code>a</code> can be considered as a generic itself if no top-level item name is matching <code>a</code>.</p>",
        "id": 260633989,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1636364644
    }
]