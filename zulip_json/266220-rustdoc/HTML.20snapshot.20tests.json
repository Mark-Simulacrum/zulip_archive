[
    {
        "content": "<h3>Problem</h3>\n<ul>\n<li>rustdoc doesn't have enough test coverage, making it harder to confidently refactor.</li>\n<li>Writing rustdoc HTML tests is a pain since you have to manually write <code>@has</code> checks, and often you run into things you want to test that are really hard to express as <code>@has</code> checks.</li>\n<li>Thus, increasing test coverage is hard.</li>\n</ul>\n<h3>Existing forms of tests</h3>\n<ul>\n<li>We use snapshot testing for error messages (e.g., <code>src/test/ui</code> and <code>src/test/rustdoc-ui</code>), which has the following advantages:<ul>\n<li>Easy to add tests since <code>--bless</code> will create the output for you. You just have to review it.</li>\n<li>Easy to update tests when you change an error message (= change rustdoc's UI) since you can use <code>--bless</code>.</li>\n</ul>\n</li>\n</ul>\n<h3>Idea</h3>\n<p>Add HTML snapshot test support to rustdoc, so in addition to using <code>@has</code>, you can use <code>@snapshot</code> (<span aria-label=\"bike\" class=\"emoji emoji-1f6b2\" role=\"img\" title=\"bike\">:bike:</span> <span aria-label=\"house\" class=\"emoji emoji-1f3e0\" role=\"img\" title=\"house\">:house:</span>) like so:</p>\n<p><strong>my_test.rs</strong></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// @snapshot struct_docs 'foo/struct.Struct.html' '//details[@class=\"rustdoc-toggle top-doc\"]'</span>\n\n<span class=\"sd\">/// My docs here.</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Struct</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p><strong>my_test.struct_docs.html</strong></p>\n<div class=\"codehilite\" data-code-language=\"HTML\"><pre><span></span><code><span class=\"p\">&lt;</span><span class=\"nt\">div</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"docblock\"</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>My docs here.<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">div</span><span class=\"p\">&gt;</span>\n</code></pre></div>\n<h3>Questions</h3>\n<ul>\n<li>Do you (T-rustdoc) agree that having this is worthwhile?</li>\n<li>How do you suggest implementing it? Should it be implemented as part of htmldocck (where the existing <code>@has</code> checks are implemented) or compiletest (where the existing error snapshot tests are implemented).</li>\n</ul>\n<h5>P.S.</h5>\n<p><em>I thought for sure I wrote this down on Zulip or GitHub recently, but I couldn't find it. Either way, this version is a bit more detailed.</em></p>",
        "id": 262651142,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637796485
    },
    {
        "content": "<p>I would like to try implementing this, but I thought it'd be good to ask for feedback first since I don't want to waste effort, and I would like to get feedback on possible implementations.</p>",
        "id": 262651320,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637796659
    },
    {
        "content": "<p>I don't think compiletest has support for XPATH, I think it would be easier to do this in htmldocck</p>",
        "id": 262651404,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637796740
    },
    {
        "content": "<p>I suggested pulling in an HTML parsing library a while ago but html5ever is really painful to use and kuchiki and lol-html both have incompatible licenses because they depend on <code>selectors</code></p>",
        "id": 262651468,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637796831
    },
    {
        "content": "<p>Do you know if htmldocck's HTML libraries have support for pretty-printing selected nodes?</p>",
        "id": 262651561,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637796908
    },
    {
        "content": "<p>No idea, sorry</p>",
        "id": 262651579,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637796930
    },
    {
        "content": "<p>There might be an <code>innerHtml</code> equivalent in xpath</p>",
        "id": 262651587,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637796946
    },
    {
        "content": "<p>I agree we need better test coverage, and I also agree that the best way to do that is to make writing tests easier. And I agree that one of the big things that's painful about writing tests today is figuring out good selectors for @has - some of which are impossible. I recently experienced the same thing trying to write a test for toggling details - I couldn't write a CSS selector that would select just the one item I wanted.</p>\n<p>I'm quite skeptical of the snapshot concept as a solution, though. I've been on other web teams that had \"golden\" tests where the whole HTML content was saved in a file, and if there was ever a diff the tests would fail and you'd have to update the golden file. This is a type of \"brittle test,\" where nearly any change you make will result in a test failure. And more importantly, the test failure won't actually teach you anything about what (if anything) you broke. It just tells you something changed.</p>\n<p>Unittests are particularly valuable for confident refactoring - if you refactor, and the tests still pass, you did it right. But if you refactor, and you have to update the tests so they pass, you have a lot less confidence that you did everything right. You have to also be sure that your updates to the tests were correct, which means the tests have to be meaningful.</p>\n<p>Faced with a breakage of a golden test, an author is likely to just update the test to match the new output, and a reviewer is likely to do the same. That wastes everyone's time - and worse, it risks introducing contempt for the tests.</p>\n<p>It sounds like the snapshot proposal is significantly more narrow than a full-file golden test - you'd target specific nodes and their children. But I think there would be temptation to put very large subtrees of the HTML into a snapshot test. And the larger the subtree gets, the more brittle and less meaningful the test becomes.</p>\n<p>I do like the idea of making tests easier and faster to write, and I'm glad you're thinking about it. For me, one of the big things is the \"tight loop\" concept I mentioned. For instance, is there an easy way to go from \"inspect element\" in Developer Tools to generating an XPath selector? If not, perhaps there is a library we could bring in for dev purposes that would do it? Also, when we find that certain elements are hard to select on, we should be willing to change the HTML generation to add classes and IDs where necessary.</p>",
        "id": 262664695,
        "sender_full_name": "jsha",
        "timestamp": 1637812784
    },
    {
        "content": "<p>Another test-related tool I've really wanted - an easy way to render a whole bunch of pages in a headless browser, and do a before/after visual diff. When writing changes that are definitely intended to have no visual impact, this would be a good way to verify there was none. And for changes that do have a visual impact, it would be a good way to make sure there were no unintended side effects.</p>",
        "id": 262664898,
        "sender_full_name": "jsha",
        "timestamp": 1637812940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/266220-rustdoc/topic/HTML.20snapshot.20tests/near/262651468\">said</a>:</p>\n<blockquote>\n<p>I suggested pulling in an HTML parsing library a while ago but html5ever is really painful to use and kuchiki and lol-html both have incompatible licenses because they depend on <code>selectors</code></p>\n</blockquote>\n<p>To be noted: kuchiki is juste a wrapper of html5ever.</p>",
        "id": 262679215,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1637829939
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"210316\">@GuillaumeGomez</span> yes, but it still depends on selectors, so it still has an incompatible license</p>",
        "id": 262685872,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637834170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> I agree the test isn't helpful if the snapshot gets too big, but I think we can avoid that just by not approving tests that add enormous subtrees? We could even make it a tidy lint on the file size if you want so it's enforced :)</p>\n<p>FWIW <span class=\"user-mention silent\" data-user-id=\"307537\">Noah Lev</span> has already gotten this working so you can see what it looks like in practice: <a href=\"https://github.com/rust-lang/rust/pull/91209/commits/e3bad0827034ad9164e34c546dc0eac2b957ce47\">https://github.com/rust-lang/rust/pull/91209/commits/e3bad0827034ad9164e34c546dc0eac2b957ce47</a></p>",
        "id": 262686234,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637834409
    },
    {
        "content": "<p>And I don't think the snapshots will change as often as you think; Noah added <code>--bless</code> to make it easy for the author just in case, but if they're small enough I think it will mean any change really is a change in behavior</p>",
        "id": 262686347,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637834465
    },
    {
        "content": "<p>I'm not too sure what to think about this feature... On small DOM tree, I guess it makes sense, but that seems a bit limited no?</p>",
        "id": 262690266,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1637836870
    },
    {
        "content": "<p>Is <code>selectors</code> actually incompatible for test-only  content? We have a bunch of stuff under MPL</p>",
        "id": 262722614,
        "sender_full_name": "Manish Goregaokar",
        "timestamp": 1637856342
    },
    {
        "content": "<p>Hmm, I need to look up the email I sent to core</p>",
        "id": 262723268,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637856819
    },
    {
        "content": "<p>Oh, that was about using it in rustdoc, not in the test suite</p>",
        "id": 262723436,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637856920
    },
    {
        "content": "<p>Actaully, we can even have MPL dependencies in rustdoc itself, it just can't be in std, and we really don't want to</p>",
        "id": 262723450,
        "sender_full_name": "Manish Goregaokar",
        "timestamp": 1637856937
    },
    {
        "content": "<p>This would be <em>really</em> nice for moving htmldocck to Rust /unifying it with jsondocck</p>",
        "id": 262723585,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637857030
    },
    {
        "content": "<p>I'll bring it up in the next compiler meeting just in case but that's super cool, thanks for letting me know :)</p>",
        "id": 262723684,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637857088
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"210316\">GuillaumeGomez</span> <a href=\"#narrow/stream/266220-rustdoc/topic/HTML.20snapshot.20tests/near/262690266\">said</a>:</p>\n<blockquote>\n<p>I'm not too sure what to think about this feature... On small DOM tree, I guess it makes sense, but that seems a bit limited no?</p>\n</blockquote>\n<p>The goal with this feature is to use it on small DOM trees where <code>@has</code> doesn't work well. For example, it's hard to test the ordering of <code>where</code> bounds with <code>@has</code> checks, so you could instead use <code>@snapshot</code> on the DOM tree for the <code>where</code> bounds.</p>",
        "id": 262736938,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637869767
    },
    {
        "content": "<blockquote>\n<p>I'm quite skeptical of the snapshot concept as a solution, though. I've been on other web teams that had \"golden\" tests where the whole HTML content was saved in a file, and if there was ever a diff the tests would fail and you'd have to update the golden file. This is a type of \"brittle test,\" where nearly any change you make will result in a test failure. And more importantly, the test failure won't actually teach you anything about what (if anything) you broke. It just tells you something changed.</p>\n</blockquote>\n<p>As you say later, the goal with <code>@snapshot</code> is to capture small parts of the DOM tree.</p>\n<blockquote>\n<p>But I think there would be temptation to put very large subtrees of the HTML into a snapshot test.</p>\n</blockquote>\n<p>I mean, with any feature, there's a temptation to use it too much or in the wrong places—like rustdoc's overuse of traits (<code>Clean</code>, <code>FromWithTcx</code>, impls of <code>FromIterator</code>, ...)—but that doesn't mean the feature itself is bad. Traits are overall a very useful language feature; you just have to be careful to use them appropriately.</p>\n<p>I feel the same is true for <code>@snapshot</code>. The benefit of being able to write more tests, more easily, outweighs the mitigable risk of capturing too large subtrees.</p>",
        "id": 262737205,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637870116
    },
    {
        "content": "<blockquote>\n<p>This is a type of \"brittle test,\" where nearly any change you make will result in a test failure. And more importantly, the test failure won't actually teach you anything about what (if anything) you broke. It just tells you something changed.</p>\n</blockquote>\n<p>I disagree that <code>@snapshot</code> tests would be somehow more brittle than <code>@has</code> checks. I often find myself scratching my head about why a <code>@has</code> check is failing: it could be that a particular node in the tree is no longer there, a class has changed, or the text has changed. Often, I would <em>really</em> love to have a diff I could look at. Now, I know if I update my version of <code>html-tidy</code>, rustdoc will show me diffs; but even then, if I understand correctly, it shows diffs of the whole file. WIth <code>@snapshot</code> tests, you would only see a diff of the one subtree that changed.</p>",
        "id": 262737357,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637870335
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/HTML.20snapshot.20tests/near/262664898\">said</a>:</p>\n<blockquote>\n<p>Another test-related tool I've really wanted - an easy way to render a whole bunch of pages in a headless browser, and do a before/after visual diff. When writing changes that are definitely intended to have no visual impact, this would be a good way to verify there was none. And for changes that do have a visual impact, it would be a good way to make sure there were no unintended side effects.</p>\n</blockquote>\n<p>IIRC, the <a href=\"http://crates.io\">crates.io</a> team uses a tool like that as part of CI? But let's discuss that in another thread.</p>",
        "id": 262752183,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637890013
    },
    {
        "content": "<p>It's tied into the ember framework somehow I think</p>",
        "id": 262752350,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637890297
    },
    {
        "content": "<p>Hmm, really? I <em>think</em> this is it: <a href=\"https://percy.io\">https://percy.io</a></p>\n<p>I didn't see anything on that page about it being Ember-dependent, but maybe I missed it.</p>",
        "id": 262754049,
        "sender_full_name": "Noah Lev",
        "timestamp": 1637893251
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/91209/files\">The PR</a> is nice because it allows us to discuss concrete details:</p>\n<div class=\"codehilite\"><pre><span></span><code>// @count - &#39;//details[@class=&quot;rustdoc-toggle top-doc&quot;]/div[@class=&quot;docblock&quot;]/p&#39; \\\n//     1\n// @has - &#39;//details[@class=&quot;rustdoc-toggle top-doc&quot;]/div[@class=&quot;docblock&quot;]/p[1]&#39; \\\n//     &#39;Hello world! Goodbye! Hello again!&#39;\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>&lt;div class=&quot;docblock&quot;&gt;&lt;p&gt;Hello world!&lt;/p&gt;\n&lt;p&gt;Goodbye!\nHello again!&lt;/p&gt;\n&lt;/div&gt;\n</code></pre></div>\n<p>In this short snapshot, there are a bunch of invisible assertions:</p>\n<ul>\n<li>The <code>&lt;div&gt;</code> must not contain any attributes other than <code>class</code></li>\n<li>The <code>&lt;p&gt;</code> must not contain any attributes or styles</li>\n<li>There must not be any elements between the <code>&lt;div&gt;</code> and the <code>&lt;p&gt;</code>, or between the <code>&lt;/p&gt;</code> and the <code>&lt;/div&gt;</code>, even if those elements are non-textual</li>\n<li>The <code>&lt;div&gt;</code> must have no classes other than <code>docblock</code>.</li>\n</ul>\n<p>Note that the last one is also (unfortunately) the case for our current XPath based tests - they exact-match on the whole class attribute.</p>\n<p>Are these negative assertions useful, intended by the author, and meaningful when they break? I think mostly no.</p>\n<p>For instance, what if (very hypothetically) we added an <code>&lt;a id=foo&gt;</code> tag to every paragraph, so we could link directly to paragraphs? That would break every snapshot test that covered docblocks. The \"meaning\" of the <code>mixing-doc-comments-and-attrs.rs</code> test case is \"when documentation is provided in attributes, those attributes should appear in consecutive<code>&lt;p&gt;</code> elements, wrapped in a <code>&lt;div class=docblock&gt;</code>. But as a snapshot it winds up testing a much broader range of things, which means it breaks under a much broader range of refactorings.</p>\n<p>So, coming back to ideas: what if snapshot tests weren't exact-match but subset match where applicable. For instance, what if the above snapshot asserted:</p>\n<ul>\n<li>The div must have _at least_ the docblock class</li>\n<li>The div may have any attributes (i.e. no assertion here)</li>\n<li>The p may have any attributes and any classes (i.e. no assertion here)</li>\n<li>Any elements may occur between the <code>&lt;div&gt;</code> and the <code>&lt;p&gt;</code>, and between the <code>&lt;/p&gt;</code> and the <code>&lt;/div&gt;</code>, and between the <code>&lt;/p&gt;</code> and the <code>&lt;p&gt;</code>.</li>\n</ul>",
        "id": 262886128,
        "sender_full_name": "jsha",
        "timestamp": 1638036992
    },
    {
        "content": "<p>While I see your point that the snapshot test has \"invisible assertions\", I also feel that the current state of rustdoc's test coverage is untenable; and the current rustdoc test system is not sufficient to increase test coverage fast enough.</p>\n<p>I would rather have tests that are a little bit brittle (though I feel it's unlikely that we'd really be changing the formatting of docblocks—or most other parts of the UI—so significantly) than no tests at all. When I refactor rustdoc, I often resort to an <em>extremely</em> brittle, manual test: documenting the whole standard library before and after my change, and then diffing the resulting HTML. Needless to say, this is tedious and doesn't provide much insight when there <em>are</em> changes.</p>\n<p>I'm also not suggesting we use snapshot tests everywhere, just when an <code>@has</code> check would be too hard or impossible.</p>\n<p>Finally, I think your idea about using subset match is interesting; but I think the implementation would be tricky and the behavior might be confusing to developers. When I see a snapshot file, I expect it to be (nearly) exact match (perhaps modulo file names, etc.). If it were interpreted non-textually and with somewhat subtle matching rules, it might give me less confidence that my test is correct.</p>",
        "id": 262888524,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638040697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> So would you be okay with landing the <code>@snapshot</code> PR? It's purely an internal feature, so we can always change it later, or even remove it if it doesn't work out.</p>",
        "id": 262899535,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638057426
    },
    {
        "content": "<p>Yeah, let's go ahead and try it, with the intention to be really aware of how brittle the tests are (one proxy variable would be how often a diff to a snapshot test is needed as part of a PR), and to make a different plan if they are too brittle. Keep in mind, the costs of brittle tests often fall the most on new contributors, since they aren't as conscious that they just need to re-generate the test.</p>\n<p>Some other somewhat related thoughts:</p>\n<p>We don't have a good way to know our test coverage from the XPath (and now snapshot) tests. If they were more traditional unittests we could use coverage tools, but these are more like integration tests. It would be nice to find a way to improve on that.</p>\n<p>If we were further along with templatizing, we could do more of these tests as normal Rust unittests, making assertions on the inputs to the template system. Unfortunately, the last templating PR introduced a perf regression, and it seems likely to be just \"Tera is kinda slow,\" which puts us at a bit of an impasse.</p>",
        "id": 262907931,
        "sender_full_name": "jsha",
        "timestamp": 1638072183
    },
    {
        "content": "<p>A lot of the tests I'd like to have are about how rustdoc processes the data from rustc; rustdoc's HTML output is just the best way to test that data. So, in my case, templatizing wouldn't help. Also, I don't think templatizing would really allow us to do these as normal Rust unit tests, since most of the inputs to the template system have or require rustc state.</p>",
        "id": 262943630,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638126879
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307537\">@Noah Lev</span> one thing I do to verify my changes is to add assertions in the function I'm modifying to make sure the output is the same before and after</p>",
        "id": 262944273,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638127845
    },
    {
        "content": "<p>And that gives much better (and easier to debug) errors than trying to understand the HTML diff</p>",
        "id": 262944287,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638127871
    },
    {
        "content": "<p>In my case, I'm often modifying most of rustdoc, so I'm not sure if that'd work <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>If I find a situation where I can, though, I'll try it :)</p>",
        "id": 262944730,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638128533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/266220-rustdoc/topic/HTML.20snapshot.20tests/near/262944287\">said</a>:</p>\n<blockquote>\n<p>And that gives much better (and easier to debug) errors than trying to understand the HTML diff</p>\n</blockquote>\n<p>I need to install a newer version of tidy (currently have the macOS built-in 2006 version...), so I actually get no diff right now <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 262944742,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638128579
    },
    {
        "content": "<p>FWIW, tidy breaks somewhat on our output. It doesn't like what we're doing with summary tags so it just deletes them (or something inside them, I forget).</p>",
        "id": 262945391,
        "sender_full_name": "jsha",
        "timestamp": 1638129575
    },
    {
        "content": "<p>yeah but it deletes them in both the old and new output it's comparing so it doesn't affect the diffs much</p>",
        "id": 262946880,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638131720
    },
    {
        "content": "<p>Hmm, that's unfortunate. Though some diffs are still better than none, I think ;)</p>",
        "id": 262959273,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638149675
    }
]