[
    {
        "content": "<p>I've been thinking about notable traits recently. I found the original tracking issue for 'spotlight' (renamed later) and I had some thoughts. Would appreciate some feedback: <a href=\"https://github.com/rust-lang/rust/issues/45040#issuecomment-1066082986\">https://github.com/rust-lang/rust/issues/45040#issuecomment-1066082986</a></p>",
        "id": 275149100,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647171771
    },
    {
        "content": "<p>I like the idea of reinforcing the Notable Traits concept on struct / enum pages. It could help people figure out what a \"Notable Trait\" is. And given those traits are often the most important thing about a type, it makes sense to front-load them.</p>\n<p>I started a thread about some somewhat orthogonal changes to notable traits here: <a href=\"https://internals.rust-lang.org/t/revisiting-spotlight-notable-traits-in-rustdoc/14759\">https://internals.rust-lang.org/t/revisiting-spotlight-notable-traits-in-rustdoc/14759</a>. TL;DR I wanted to replace the <code>(i)</code> with a chip / lozenge that says what the notable trait is: <code>Iterator</code>, <code>Read</code>, <code>Write</code>, etc.</p>\n<p>A similar concept could apply here: Rather than have a heading that says \"Notable Traits\" but doesn't say what they are, why not have a heading (or similar) that just says <code>Iterator</code>, <code>Read</code>, <code>Write</code>, etc? Or: have a chip at the top of the page that says <code>Iterator</code> / <code>Read</code> / <code>Write</code> and links to the relevant implementation within the page. That would be nice because the UI could be similar to what shows up on other pages referencing the type.</p>",
        "id": 275164789,
        "sender_full_name": "jsha",
        "timestamp": 1647191487
    },
    {
        "content": "<p>I have some issues with Notable Traits from the opposite direction. You discuss how it's under-inclusive for Result types, which is a good point. I also think it's over-inclusive in some scenarios.</p>\n<p>For instance, every method that returns a Vec gets an ⓘ annotation because Vec is Write:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub const fn new() -&gt; Vec&lt;T, Global&gt;ⓘ\npub fn with_capacity(capacity: usize) -&gt; Vec&lt;T, Global&gt;ⓘ\n</code></pre></div>\n<p>But that's not really the most notable thing about Vec. I consider it an issue because Vec is so common, it weakens the concept of ⓘ as \"this is something you should pay attention to.\"</p>\n<p>A similar issue shows up for functions that return <code>&amp;[u8]</code> (Read and Write), like several on String:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub fn as_bytes(&amp;self) -&gt; &amp;[u8]ⓘ\n</code></pre></div>\n<p>Notable Traits also shows up for anything that returns Box, because there are passthrough implementations for Iterator, Read, Write, and Future on Box.</p>\n<p><a href=\"/user_uploads/4715/ntiaz6T77Wuwk7tphIO9txdL/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/ntiaz6T77Wuwk7tphIO9txdL/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/ntiaz6T77Wuwk7tphIO9txdL/image.png\"></a></div>",
        "id": 275166492,
        "sender_full_name": "jsha",
        "timestamp": 1647193950
    },
    {
        "content": "<p>In other words, I think <code>Vec</code>, <code>&amp;[u8]</code>, and <code>Box</code> shouldn't get ⓘ annotations. But also, as you say, <code>Result&lt;Foo&gt;</code> should get a ⓘ  annotation if  Foo gets one. We should figure out a way to do those that is consistent and predictable.</p>",
        "id": 275166598,
        "sender_full_name": "jsha",
        "timestamp": 1647194110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275166492\">said</a>:</p>\n<blockquote>\n<p>For instance, every method that returns a Vec gets an ⓘ annotation because Vec is Write:</p>\n</blockquote>\n<p>Yeah, I definitely agree with that, and my previous comment proposed a fix for that and I already have put up a PR. The gist is that specific impls can be notable rather than whole traits</p>",
        "id": 275168134,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647196141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275164789\">said</a>:</p>\n<blockquote>\n<p>TL;DR I wanted to replace the <code>(i)</code> with a chip / lozenge that says what the notable trait is: <code>Iterator</code>, <code>Read</code>, <code>Write</code>, etc.</p>\n<p>A similar concept could apply here: Rather than have a heading that says \"Notable Traits\" but doesn't say what they are, why not have a heading (or similar) that just says <code>Iterator</code>, <code>Read</code>, <code>Write</code>, etc? Or: have a chip at the top of the page that says <code>Iterator</code> / <code>Read</code> / <code>Write</code> and links to the relevant implementation within the page. That would be nice because the UI could be similar to what shows up on other pages referencing the type.</p>\n</blockquote>\n<p>I like it in concept. It's good to have more visibility of the notability I think. I agree with the other comments that it should be regular rust syntax IMO (like everything else in rustdoc).</p>\n<p>How would this scale to multiple notable traits. Does having multiple notable traits even make sense (I think it does, eg TcpStream is notably <code>Read + Write</code>).</p>",
        "id": 275168281,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647196387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275166598\">said</a>:</p>\n<blockquote>\n<p>In other words, I think <code>Vec</code>, <code>&amp;[u8]</code>, and <code>Box</code> shouldn't get ⓘ annotations. But also, as you say, <code>Result&lt;Foo&gt;</code> should get a ⓘ  annotation if  Foo gets one. We should figure out a way to do those that is consistent and predictable.</p>\n</blockquote>\n<p>My suggestion to fix these is as follows:</p>\n<ol>\n<li>Any blanket impls should not qualify for notability. This solves box being an iterator.</li>\n<li>Read/Write are not notable themselves, but specific impls will be (eg TcpStream). This solves vec/[u8] being notable for read/write.</li>\n<li>Result (as a Try&lt;Output = T&gt; type) will inherit the notability of T</li>\n</ol>",
        "id": 275169496,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647198089
    },
    {
        "content": "<p>Thinking about that more, the 'blanket impl' suggestion I had does not work using rustdoc's current interpretation of blanket. Not sure how to formalise that</p>",
        "id": 275172280,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647201714
    },
    {
        "content": "<p>Also, I'd say that (while not relevant in this case) BufReader should qualify as notable Read even though it could be interpreted using my previous logic as a blanket impl</p>",
        "id": 275172421,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647201887
    },
    {
        "content": "<p>I like these ideas!</p>\n<blockquote>\n<p>I agree with the other comments that it should be regular rust syntax IMO (like everything else in rustdoc).</p>\n</blockquote>\n<p>I assume you mean the comments from the internals thread I linked, like <a href=\"https://internals.rust-lang.org/t/revisiting-spotlight-notable-traits-in-rustdoc/14759/8\">https://internals.rust-lang.org/t/revisiting-spotlight-notable-traits-in-rustdoc/14759/8</a> ?</p>\n<p>I agree the best in theory would be for the various function on Iterator (for instance) to return <code>impl Iterator</code> rather than a concrete Iterator type. But later in the thread it's pointed out that <code>-&gt; impl Iterator</code> is not exactly the same as <code>-&gt; Rev&lt;Self&gt;</code>, and so having the docs replace one with the other would be misleading. I think that makes automatically rewriting a non-starter, and the stdlib at least can't make a code change to <code>-&gt; impl Iterator</code> for backwards compat reasons.</p>",
        "id": 275179265,
        "sender_full_name": "jsha",
        "timestamp": 1647211722
    },
    {
        "content": "<p>I dont mean necessarily replacing each use, but the supplementary lozenge will not be a special format, but just the traits <code>(impl Read + Write)</code></p>",
        "id": 275196281,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647236990
    },
    {
        "content": "<p>This <code>Box</code> situation is very hard. Looking at the impl, it's very hard to distinguish it from <code>Map</code>. I think the only difference is that it's a 'Smart Pointer'. So potentially, any Defef type should not qualify for general notability? They could still have impl specific ones which take priority</p>",
        "id": 275204754,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647246128
    },
    {
        "content": "<p>Taking Deref into account makes sense to me. I think the intuition is 'how would I commonly treat the return type' and usually that means treating pointers transparently and using <code>?</code> on Result, etc.</p>",
        "id": 275209396,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647249204
    },
    {
        "content": "<p>I think it is worth spending some time experimenting with UI. I really dislike the current 'i' UI because it is both too obtrusive (making the type signature noisy) and too subtle (unless you know what hides behind it, you don't know to click it. For beginners (or even experienced users who haven't used the feature in rustdoc), 'notable traits' is unclear and could apply to the function as well as the return type)). I'll also note that function signatures serve as titles, not just as information, so the UI should ideally not get in the way of that function.</p>",
        "id": 275209930,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647249515
    },
    {
        "content": "<p>Maybe the information should be in the body of the docs for the function, rather than in the signature?</p>",
        "id": 275210138,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647249616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275209396\">said</a>:</p>\n<blockquote>\n<p>Taking Deref into account makes sense to me. I think the intuition is 'how would I commonly treat the return type' and usually that means treating pointers transparently and using <code>?</code> on Result, etc.</p>\n</blockquote>\n<p>So, <code>Box</code> and <code>Result</code> should not qualify (as <code>Deref&lt;Target = T&gt;</code> or <code>Try&lt;Output = T&gt;</code> impls), but their respective <code>T</code> types can be used to determine whether a function output is notable?</p>\n<p>Eg, <br>\nI have a function that returns a <code>Box&lt;Sleep&gt;</code> it would make sense to display that as notably <code>impl Future</code>.<br>\nI have a function that returns a <code>io::Result&lt;File&gt;</code>, it would make sense to display that as notable <code>impl Read + Write</code>.</p>\n<p>But If I go directly to the page for <code>Box&lt;T&gt;</code>, I should not see on <code>Box::new(T)</code> that the output is notably a <code>Future</code></p>",
        "id": 275212836,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647251257
    },
    {
        "content": "<p>That all sounds right to me. For Box&lt;T&gt;::new, there is no Future bound on T, so I wouldn't expect to see anything about Future</p>",
        "id": 275213348,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647251578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"396593\">Conrad Ludgate</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275169496\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275166598\">said</a>:</p>\n<blockquote>\n<p>In other words, I think <code>Vec</code>, <code>&amp;[u8]</code>, and <code>Box</code> shouldn't get ⓘ annotations. But also, as you say, <code>Result&lt;Foo&gt;</code> should get a ⓘ  annotation if  Foo gets one. We should figure out a way to do those that is consistent and predictable.</p>\n</blockquote>\n<p>My suggestion to fix these is as follows:</p>\n<ol>\n<li>Any blanket impls should not qualify for notability. This solves box being an iterator.</li>\n<li>Read/Write are not notable themselves, but specific impls will be (eg TcpStream). This solves vec/[u8] being notable for read/write.</li>\n<li>Result (as a Try&lt;Output = T&gt; type) will inherit the notability of T</li>\n</ol>\n</blockquote>\n<p>There is another solution (that I propose (in addition to these?)): impls can be marked as opt-out, this solves the <code>Vec</code>/<code>Box</code>/etc problem, without necessarily making <code>Read</code>/<code>Write</code> non-notable or making blanket impl non-notable (the latter will work badly with <code>Iterator</code> adaptors for example)</p>",
        "id": 275218950,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1647254825
    },
    {
        "content": "<p>I've been trying to avoid entertaining the idea of negative notability attributes, but I guess it will eventually be necessary anyway</p>",
        "id": 275219301,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647255036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"396593\">Conrad Ludgate</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275196281\">said</a>:</p>\n<blockquote>\n<p>I dont mean necessarily replacing each use, but the supplementary lozenge will not be a special format, but just the traits <code>(impl Read + Write)</code></p>\n</blockquote>\n<p><code>(impl Trait)</code> is somewhat similar to what IDEs (r-a, idea) sometimes do to typehints for <code>Iterator</code>s and <code>Future</code>s. I generally think it would be nice (and better than the current <code>(i)</code>), but at the same time for a function signature that may be too much noise...</p>",
        "id": 275219492,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1647255138
    },
    {
        "content": "<p>I agree, there needs to be good effort in order to not make it overly cluttered, but also providing enough information at a glance</p>",
        "id": 275221900,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647256543
    },
    {
        "content": "<p>As nrc said, below the fn line could be good, we just need a solid design idea that is clear</p>",
        "id": 275221990,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647256584
    },
    {
        "content": "<p>i would expect notable traits to be an auto-generated header and then bulleted list in the main body of the type docs, at the end after the programmer's notes</p>",
        "id": 275291578,
        "sender_full_name": "Lokathor",
        "timestamp": 1647288499
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>## notable traits\nthe following traits are notable for this type\n* impl From&lt;u64&gt;\n* impl Iterator&lt;Item=u8&gt;\n* ...\n</code></pre></div>",
        "id": 275291706,
        "sender_full_name": "Lokathor",
        "timestamp": 1647288593
    },
    {
        "content": "<p>That's kinda my intention currently, although re-using the existing trait implementations rendering for consistency.</p>\n<p>Notable Traits show above any other traits in their own section (admittedly below any non trait implementations). My reasoning for that is that most notable types don't have many methods of their own so it doesn't matter either way</p>",
        "id": 275294551,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647290173
    },
    {
        "content": "<p>If the traits are not expanded by default, you'll have all the information necessary up front like that</p>",
        "id": 275294599,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647290221
    },
    {
        "content": "<p>Actually, the un-expanded Iterator impl does not show its associated types :/</p>",
        "id": 275294671,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647290277
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"396593\">Conrad Ludgate</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275212836\">said</a>:</p>\n<blockquote>\n<p>So, <code>Box</code> and <code>Result</code> should not qualify (as <code>Deref&lt;Target = T&gt;</code> or <code>Try&lt;Output = T&gt;</code> impls), but their respective <code>T</code> types can be used to determine whether a function output is notable?</p>\n<p>Eg, <br>\nI have a function that returns a <code>Box&lt;Sleep&gt;</code> it would make sense to display that as notably <code>impl Future</code>.<br>\nI have a function that returns a <code>io::Result&lt;File&gt;</code>, it would make sense to display that as notable <code>impl Read + Write</code>.</p>\n<p>But If I go directly to the page for <code>Box&lt;T&gt;</code>, I should not see on <code>Box::new(T)</code> that the output is notably a <code>Future</code></p>\n</blockquote>\n<p>So exploring this idea, what's a good way to determine if a type implements a specific trait? I assume the <code>DefID</code>s of traits are not consistent and should not be relied upon, so I'll need to determine beforehand what DefID <code>Deref</code>/<code>Try</code> have. Also, would there be any difference between <code>::core::ops::Deref</code> and <code>::std::ops::Deref</code>?</p>",
        "id": 275298154,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647291942
    },
    {
        "content": "<p>Ahh, I can use something like this i presume: <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/lang_items/struct.LanguageItems.html#method.deref_trait\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/lang_items/struct.LanguageItems.html#method.deref_trait</a></p>",
        "id": 275298241,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647291975
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"396593\">Conrad Ludgate</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275294551\">said</a>:</p>\n<blockquote>\n<p>That's kinda my intention currently, although re-using the existing trait implementations rendering for consistency.</p>\n<p>Notable Traits show above any other traits in their own section (admittedly below any non trait implementations). My reasoning for that is that most notable types don't have many methods of their own so it doesn't matter either way</p>\n</blockquote>\n<p>I think that a more \"skimable\" cluster of info, not the entire normal presentation, might help.</p>",
        "id": 275318506,
        "sender_full_name": "Lokathor",
        "timestamp": 1647306830
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"396593\">@Conrad Ludgate</span> I recently implemented a suggestion in the compiler that needed to check if the type implements a trait, I think you may reuse something from there: <a href=\"https://github.com/compiler-errors/rust/blob/7624565d0a464ffc0a6f9368d7f789df6d53ab52/compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs#L441-L460\">conflict_errors.rs#L441-L460</a></p>",
        "id": 275493523,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1647427843
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"315412\">@jsha</span> i really like the idea of a chip, and on hover you can get the actual impls.</p>\n<p>I think for _iterator_ we should have the chip on each instance of the iterator, but perhaps for Write we should have it be opt-in on methods?</p>",
        "id": 275555938,
        "sender_full_name": "Manish Goregaokar",
        "timestamp": 1647454738
    },
    {
        "content": "<p>I do think the usage for Write gets very annoying?</p>",
        "id": 275555971,
        "sender_full_name": "Manish Goregaokar",
        "timestamp": 1647454748
    },
    {
        "content": "<p>FYI I've already implemented this Write functionality: <a href=\"https://github.com/rust-lang/rust/pull/94904\">https://github.com/rust-lang/rust/pull/94904</a></p>",
        "id": 275567241,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647459861
    },
    {
        "content": "<p>Not on methods but on impls</p>",
        "id": 275567298,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647459888
    },
    {
        "content": "<p>I'm not sure if I agree that methods choose the notability of their return types</p>",
        "id": 275567836,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647460116
    },
    {
        "content": "<p>Seems like something that will be forgotten a lot</p>",
        "id": 275567871,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647460133
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132040\">Manish Goregaokar</span> <a href=\"#narrow/stream/266220-rustdoc/topic/notable_traits.20improvements/near/275555938\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> i really like the idea of a chip, and on hover you can get the actual impls.</p>\n</blockquote>\n<p>Little thing: needs to be on click for mobile devices. ;) (but yes, doesn't change anything otherwise)</p>",
        "id": 275567952,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1647460180
    },
    {
        "content": "<blockquote>\n<p>I'm not sure if I agree that methods choose the notability of their return types</p>\n</blockquote>\n<p>I think methods should not choose the notability of their return types. Conceptually, notability is a property of a type, not a method.</p>\n<p>Also, it's probably useful to expand on what \"notable traits\" means to all of us. For me, notable traits solves this problem: When learning Iterators, I would see a method signature like:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn take(self, n: usize) -&gt; Take&lt;Self&gt;ⓘ\n</code></pre></div>\n<p>and think \"oh no, what's this <code>Take</code>? A whole new type I have to learn about. Must be complex if it has its own struct.\" But in practice, <code>Take</code> is just an Iterator that happens to have its own name (and today that API might be written <code>fn take(self, n: usize) -&gt; impl Iterator&lt;Item = Self::Item&gt;</code>). The ⓘ helps you notice that and save a click, knowing that <code>struct Take</code> isn't that interesting since the description you need is on <code>fn take</code>.</p>\n<p>Generalizing that, there are certain traits where, if a struct implements them, that implementation is probably the most notable thing about the struct. And conversely there are structs that have very little inherently interesting about them (e.g. no public fields, no inherent impls), such that implementation of one of those notable traits is the most interesting thing about the struct.</p>",
        "id": 275587270,
        "sender_full_name": "jsha",
        "timestamp": 1647471085
    },
    {
        "content": "<p>Same here, at least I'll go a little further. If the type has significant methods of its own (besides just new and other trivial ones), its likely not going to be notable as a trait.</p>\n<p>For instance, BufReader has a bunch of getter/setter methods, which are not very interesting to learn about, but all of its non-trivial functionality comes from its Read/BufRead impls</p>\n<p>Vec is a Write, but it has significant use on its own. It has achieved self-notability and therefore is not notable for being any traits</p>",
        "id": 275612155,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647498940
    },
    {
        "content": "<p>This doesn't help now, but would anything change here if <em>inherent traits</em> were a thing (even if just in nightly)?  Is it possible that the notable ones could just be the inherent ones on the type?</p>",
        "id": 275612789,
        "sender_full_name": "scottmcm",
        "timestamp": 1647499722
    },
    {
        "content": "<p>I'm not familiar with this concept</p>",
        "id": 275614812,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1647501780
    },
    {
        "content": "<p>\"I think methods should not choose the notability of their return types. Conceptually, notability is a property of a type, not a method.\" - I don't think this is quite right, the context in which the type is used is important. Notable traits isn't just traits for a type but is about how we expect the return type to be used. E.g., when calling an iter method we expect the result to be treated only as an iterator. However when you call ConcreteIterator::new, then the user might well be interested in the concrete type. IMO, notable traits is a workaround for not having <code>impl Trait</code> return types at 1.0.</p>",
        "id": 275620481,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647506267
    },
    {
        "content": "<p>Even for the generic iterator case, it's possible to implement Iterator for a type which does more than just iterate, it's just common to have single purpose iterator types. I believe this is why notable traits for Write (etc) feel worse than for Iterator - because types which impl Write are often multi-purpose types and not single-purpose dictated by a trait</p>",
        "id": 275620650,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647506367
    },
    {
        "content": "<blockquote>\n<p>IMO, notable traits is a workaround for not having impl Trait return types at 1.0.</p>\n</blockquote>\n<p>I agree.</p>\n<blockquote>\n<p>I believe this is why notable traits for Write (etc) feel worse than for Iterator - because types which impl Write are often multi-purpose types and not single-purpose dictated by a trait</p>\n</blockquote>\n<p>That makes sense!</p>",
        "id": 275686750,
        "sender_full_name": "jsha",
        "timestamp": 1647534960
    },
    {
        "content": "<p>Even if impl Trait was in 1.0, plenty of iterators would need to be their own type because they have special additional methods. So we'd want a system like this even so</p>",
        "id": 275709200,
        "sender_full_name": "Lokathor",
        "timestamp": 1647543253
    },
    {
        "content": "<p>And it's unclear how all the conditional-traits stuff we do today could be expressed in <code>impl Trait</code> return types -- like <code>Map</code> being exact-sized only if the iterator it wraps is also exact-sized.</p>",
        "id": 275717199,
        "sender_full_name": "scottmcm",
        "timestamp": 1647547124
    },
    {
        "content": "<p>ah, good points!</p>",
        "id": 275744027,
        "sender_full_name": "jsha",
        "timestamp": 1647561181
    },
    {
        "content": "<p>And also without TAIT you can't name those iterator adapters so libraries generally try to avoid <code>impl Trait</code>. (Of course you often can't name them anyway if for example you want a type like <code>Map&lt;X, |T| -&gt; U&gt;</code> containing a closure type)</p>",
        "id": 275752501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647569537
    },
    {
        "content": "<p>True, true! I guess a better phrasing is that notable traits feels like a docs feature which is the moral equivalent of the impl Trait language feature, but that there are constraints on the language cf docs which make them different features</p>",
        "id": 275770907,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647591372
    }
]