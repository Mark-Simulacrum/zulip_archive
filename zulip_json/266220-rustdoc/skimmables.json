[
    {
        "content": "<p>One really important way people use rustdoc is skimming over an API summary to see what methods are available. I was just thinking, though: we provide that in two different ways (or three, for traits):</p>\n<ol>\n<li>The list of methods in the sidebar.</li>\n<li>\"Collapse all docs\", then skimming the document body.</li>\n<li>For traits, expanding the \"Show N methods\" in the item-decl (e.g. <a href=\"https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html\">https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html</a>).</li>\n</ol>\n<p>Some comparisons of them:</p>\n<p>1: Not very much horizontal space. Hard to see long method names. No parameters visible. Large click target. Click target is a hyperlink.<br>\n 2: Plenty of horizontal space. Includes all parameters. Small click target. Click target is a button. Includes source link, stability info, and item-infos (deprecation, features, platform).<br>\n 3: Plenty of horizontal space. Includes all parameters. Large click target. Click target is a hyperlink. Not visible by default.</p>",
        "id": 268970466,
        "sender_full_name": "jsha",
        "timestamp": 1642875488
    },
    {
        "content": "<p>It's been one of the oldest improvement asked for rustdoc. I wasn't able to have any definitive improvements so I'm very happy to hear it's your next target! :D</p>",
        "id": 268970923,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642876127
    },
    {
        "content": "<p>heh, I'm not sure it's quite my next target. Just doing some musing on how we could do it better (and maybe less redundantly).</p>\n<p>What are some of the improvements people have asked for in this area?</p>",
        "id": 268971484,
        "sender_full_name": "jsha",
        "timestamp": 1642876838
    },
    {
        "content": "<p>It's mostly complains about hard it is to efficiently browse documentation.</p>",
        "id": 268972562,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642878381
    },
    {
        "content": "<p>IIRC, ordering of the methods in the sidebar does not (or at one point did not) match with the ordering in the primary pane. One is alphabetical, one is source-specified. There's certainly grouping in the primary pane, based on things like impls by trait bounds</p>",
        "id": 268972576,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642878416
    },
    {
        "content": "<blockquote>\n<p>IIRC, ordering of the methods in the sidebar does not (or at one point did not) match with the ordering in the primary pane. One is alphabetical, one is source-specified.</p>\n</blockquote>\n<p>Yes, that's correct and intentional. The idea is to accommodate a couple of different modes of reading:</p>\n<ol>\n<li>When a reader is looking for a specific method by name, or you think they know the approximate name, they probably want to look through an alphabetical list.</li>\n<li>When a reader wants to read the whole documentation page in order, the documentation author may want to guide them through it in a certain order - which they can achieve by ordering their source code.</li>\n</ol>\n<p>I have a bit of an issue with the second case: it's not very discoverable. As a user I never knew what order things were supposed to appear on the page until I joined the rustdoc team and someone told me. And I've also authored documentation - so that documentation was created without attention to the ordering of methods. When users see a lot of documentation, some of which has a meaningful order and some of which doesn't, it makes it much harder to figure out the pattern.</p>\n<p>Discussing this previously, it seems like one of the most common use cases for intentional source ordering is to group methods into: constructors; consumers (i.e. turn self into something else); mutators and accessors. It might be interesting to explore making that grouping explicit.</p>",
        "id": 268977215,
        "sender_full_name": "jsha",
        "timestamp": 1642883499
    },
    {
        "content": "<p>Back to the overall \"skimmables\" topic, one rough idea I had - what if each type had a separate \"summary\" page? The method names (and trait names) on the summary page would link to the full documentation page.</p>\n<p>Once upon a time this would have been annoying because page loads are slow, but <span class=\"user-mention\" data-user-id=\"210316\">@GuillaumeGomez</span> and I have made them dramatically faster in the last year and a half or so.</p>\n<p>This would be nice because we wouldn't have to try and squeeze the two use cases into one. We could decide what's important on a skimmable summary page, and what's important on a full documentation page, and present those differently.</p>",
        "id": 268977295,
        "sender_full_name": "jsha",
        "timestamp": 1642883610
    },
    {
        "content": "<blockquote>\n<p>Discussing this previously, it seems like one of the most common use cases for intentional source ordering is to group methods into: constructors; consumers (i.e. turn self into something else); mutators and accessors. It might be interesting to explore making that grouping explicit.</p>\n</blockquote>\n<p>This could be an interesting experiment!</p>\n<blockquote>\n<p>Back to the overall \"skimmables\" topic, one rough idea I had - what if each type had a separate \"summary\" page? The method names (and trait names) on the summary page would link to the full documentation page.</p>\n</blockquote>\n<p>I guess that could work? I'm not 100% sold on the idea but I'm curious what others think about it.</p>",
        "id": 268977422,
        "sender_full_name": "GuillaumeGomez",
        "timestamp": 1642883781
    },
    {
        "content": "<p>an attribute to mark particular things as important parts of a usability category would certainly be welcome.</p>\n<p>just the other day someone told me i needed to add a \"new\" method because the From impl wasn't sufficiently obvious, so being able to tell rustdoc \"hey x y and z are all the construction styles, group them and show them as a single section\" would be great.</p>",
        "id": 268980115,
        "sender_full_name": "Lokathor",
        "timestamp": 1642887642
    },
    {
        "content": "<p>As prior art, Elm's documentation system seems to require users to explicitly group docs IIUC. It looks something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Elm\"><pre><span></span><code><span class=\"cm\">{-|</span>\n<span class=\"cm\"># Constructors</span>\n\n<span class=\"cm\">@docs new, fromString</span>\n\n<span class=\"cm\"># Conversion</span>\n\n<span class=\"cm\">@docs toUpper, toLower</span>\n<span class=\"cm\">-}</span>\n</code></pre></div>\n<p>where the users specify any headers they want. At least, that's my understanding of how it works.</p>",
        "id": 268983415,
        "sender_full_name": "Noah Lev",
        "timestamp": 1642892146
    },
    {
        "content": "<p>I think presenting in the declared order is overrated - many authors don't consider it, different authors have different expectations on ordering and since the ordering is implicit the reader can't know which grouping the author used. The only useful aspect is that different impls are separated, c.f., the pure alphabetical ordering (and you can add docs to an impl, iirc). IMO, if we want ordering to be a reading aid then it should be made explicit by letting the author specify a contents page or similar with descriptions of the groups</p>",
        "id": 269105546,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643031369
    },
    {
        "content": "<p>Talking of which, it is irritating to me that methods via Deref are grouped separately in the sidebar, but methods in different inhernet impls are not grouped. IMO deref methods (and methods in trait impls) should all be displayed aphabetically, or there should be an option to choose grouping in the sidebar</p>",
        "id": 269105774,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643031480
    },
    {
        "content": "<p>docs on an impl block are an extremely niche feature, though perhaps that fact is in the \"unfortunately\" category</p>",
        "id": 269140512,
        "sender_full_name": "Lokathor",
        "timestamp": 1643045529
    },
    {
        "content": "<p>I recall also being unsure of whether I should document the <em>impl</em> or the <em>method</em> on the impl, if I do add documentation for something like a <code>From</code>.</p>\n<p>I guess for traits with more than one method it might be more obvious.</p>",
        "id": 269156251,
        "sender_full_name": "scottmcm",
        "timestamp": 1643051944
    },
    {
        "content": "<p>there should be some guidance on the topic! I think it's much more common to document the method; we should document that.</p>",
        "id": 269156825,
        "sender_full_name": "jsha",
        "timestamp": 1643052202
    },
    {
        "content": "<p>I've thought about this a bit. I think there would be a lot of value in a space-efficient, carefully-aligned, meaningfully-grouped method table. I made this prototype once: <a href=\"/user_uploads/4715/ihQL-8wHSouLNFd22CpQBoBi/prototype.png\">prototype.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/ihQL-8wHSouLNFd22CpQBoBi/prototype.png\" title=\"prototype.png\"><img src=\"/user_uploads/4715/ihQL-8wHSouLNFd22CpQBoBi/prototype.png\"></a></div>",
        "id": 269196819,
        "sender_full_name": "Will Crichton",
        "timestamp": 1643074253
    },
    {
        "content": "<p>That mockup is definitely interesting!</p>",
        "id": 269197141,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643074518
    },
    {
        "content": "<p>ooh that's interesting! Why organize it into columns, though? Is that mainly a way to fit more on the screen?</p>\n<p>Also one of the really interesting ideas here is showing methods from trait implementations alongside all the other methods - for instance, showing a bunch of <code>from</code>s with different args is a neat way to convey all the things a Vec could be built from.</p>",
        "id": 269197962,
        "sender_full_name": "jsha",
        "timestamp": 1643075005
    },
    {
        "content": "<p>a possible iteration on that: since each column defines what the <code>self</code> arg is (if any), you can emit it on each item to make the method signature shorter.</p>\n<p>Also it seems like it would be better to hide excess content on overflow rather than wrap it.</p>",
        "id": 269198221,
        "sender_full_name": "jsha",
        "timestamp": 1643075130
    },
    {
        "content": "<p>Yes, the columns are just to fit as much as possible onto the screen. One of my design principles if that scrolling is generally bad, since it takes someone time to reorient themselves on the page. I think people like cheat sheets for this same reason.</p>\n<p>Your ideas are all good. Some other things that need fixing are how to deal (if at all) with trait bounds. Some of these type signatures look the same, e.g. the multiple <code>eq</code> methods, but presumably have different trait bounds. But that's a lot of information to fit into a small display. A good stress test would be a trait-heavy framework like <a href=\"https://docs.rs/warp/latest/warp/trait.Filter.html\">warp</a>:</p>\n<p><a href=\"/user_uploads/4715/-RxcSATniaADD5Wx_M3JbQ1Y/Screen-Shot-2022-01-24-at-5.53.18-PM.png\">Screen-Shot-2022-01-24-at-5.53.18-PM.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/-RxcSATniaADD5Wx_M3JbQ1Y/Screen-Shot-2022-01-24-at-5.53.18-PM.png\" title=\"Screen-Shot-2022-01-24-at-5.53.18-PM.png\"><img src=\"/user_uploads/4715/-RxcSATniaADD5Wx_M3JbQ1Y/Screen-Shot-2022-01-24-at-5.53.18-PM.png\"></a></div>",
        "id": 269198653,
        "sender_full_name": "Will Crichton",
        "timestamp": 1643075622
    },
    {
        "content": "<p>I think it's okay to have a compact interface that doesn't show _all_ necessary details. For instance, that could be compacted as:</p>\n<div class=\"codehilite\"><pre><span></span><code>or_else(F) -&gt; OrElse&lt;Self, F&gt;\n  F, Self: 4 trait bounds\n</code></pre></div>\n<p>Where the <code>4 trait bounds</code> was linkified to the full docs.</p>",
        "id": 269198802,
        "sender_full_name": "jsha",
        "timestamp": 1643075785
    },
    {
        "content": "<p>For the columns, it might be better to have a continuous page with headings, but then make a 1-column, 2-column, 3-column etc layout as the page gets bigger. So the headings wouldn't always be at the top of the page, but you'd be able to take advantage of wide screens while still gracefully degrading on narrow ones.</p>\n<p>Also, since static methods are often constructors, IMO it makes sense for them to come first.</p>",
        "id": 269198887,
        "sender_full_name": "jsha",
        "timestamp": 1643075883
    },
    {
        "content": "<p>Here's an idea, based on this mockup: One issue with rustdoc IMO is that <code>from</code> and <code>new</code> are from the user's point of view almost the same, yet rustdoc shows them in totally different parts of the page, and you have to scroll way down to get to the <code>from</code>s. What if we put trait impls together with inherent impls, or at least put <code>From</code>/<code>Into</code>/<code>TryFrom</code>/... impls with inherent impls?</p>",
        "id": 269199084,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643076050
    },
    {
        "content": "<p>huh, that's an interesting idea! I think I prefer limiting it to <code>From</code> / <code>Into</code> / <code>TryFrom</code>.</p>\n<p>If we made a new section called \"Constructors\" it could contain (a) all associated methods that yield <code>Self</code> or a type parameterized by <code>Self</code>, and (b) <code>From</code> / <code>Into</code> / <code>TryFrom</code>.</p>",
        "id": 269199476,
        "sender_full_name": "jsha",
        "timestamp": 1643076157
    },
    {
        "content": "<p>That's a very interesting idea!</p>",
        "id": 269199770,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643076447
    },
    {
        "content": "<p>The one hiccup is what would we do with impl doc-comments?</p>",
        "id": 269199786,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643076463
    },
    {
        "content": "<blockquote>\n<p>or a type parameterized by Self,</p>\n</blockquote>\n<p>That could cause false positives though... <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 269199842,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643076492
    },
    {
        "content": "<p>We might have to limit it to just <code>Option</code> and <code>Result</code>...</p>",
        "id": 269199851,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643076509
    },
    {
        "content": "<p>Another thing I'd been thinking about for a summary page: hoist some of the common traits up and categorize them. E.g.:</p>\n<div class=\"codehilite\"><pre><span></span><code>struct String\n\nAuto traits: Send, Sync, Unpin, UnwindSafe, RefUnwindSafe\nDerived traits: Clone, Debug, Default\nComparison: Ord, PartialOrd, Eq, PartialEq\nFrom: &amp;&#39;_ String, &amp;&#39;_ mut str, &amp;&#39;_ str, &amp;&#39;a String, Box&lt;str, Global&gt;, Cow&lt;&#39;a, str&gt;, String, char\nAsRef: str, [u8], OsStr, Path\n(etc)\n</code></pre></div>",
        "id": 269199979,
        "sender_full_name": "jsha",
        "timestamp": 1643076659
    },
    {
        "content": "<p>Seems reasonable</p>",
        "id": 269200502,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643077165
    },
    {
        "content": "<p>Traits like <code>From</code>, <code>AsRef</code>, <code>Eq</code>, <code>Ord</code>, <code>Add</code>, <code>Clone</code>, and <code>Copy</code> (and others) are so commonly used that they're practically part of the language. (In fact, several of them actually are, e.g. <code>Add</code> and <code>Copy</code>.) In those cases, I think it's very reasonable to display them differently.</p>",
        "id": 269200616,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643077270
    },
    {
        "content": "<p>one note on columns vs scrolling: I'd say about a third of the random docs lookups i do are on my phone when i think of something on the bus or whatever. Any design should keep in mind that a lot of people use a tall and scrolly screen often or even all the time (i know of one rust dev that programs exclusively on their android phone).</p>",
        "id": 269201317,
        "sender_full_name": "Lokathor",
        "timestamp": 1643077849
    },
    {
        "content": "<p>That's wild. I don't think I've ever used Rustdoc on my phone.</p>",
        "id": 269201423,
        "sender_full_name": "Will Crichton",
        "timestamp": 1643077928
    },
    {
        "content": "<p>I use rustdoc on my phone occasionally, mainly when something pops into my head that I'm curious about, like <span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> said.</p>",
        "id": 269202619,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643079036
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"315412\">jsha</span> <a href=\"#narrow/stream/266220-rustdoc/topic/skimmables/near/269199476\">said</a>:</p>\n<blockquote>\n<p>If we made a new section called \"Constructors\" it could contain (a) all associated methods that yield <code>Self</code> or a type parameterized by <code>Self</code>, and (b) <code>From</code> / <code>Into</code> / <code>TryFrom</code>.</p>\n</blockquote>\n<p>Details might be complicated, but I really like the general idea of splitting things up into categories like this.  It would be particularly hard for Iterators to generate them, but the whole things of \"this takes <code>&amp;mut</code> so it does something and you can keep using it\" or \"this consumes self so it's a 'terminal' in a chain\" etc are particularly useful.</p>\n<p><a href=\"https://danielkeep.github.io/itercheat_baked.html\">https://danielkeep.github.io/itercheat_baked.html</a> has some categories.</p>",
        "id": 269207306,
        "sender_full_name": "scottmcm",
        "timestamp": 1643083373
    },
    {
        "content": "<p>One thing I like about OCaml and Haskell documentation is that the user can specify categories that organize the documentation. For instance, the Haskell Data.Array type: <a href=\"https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html\">https://hackage.haskell.org/package/array-0.5.4.0/docs/Data-Array.html</a></p>\n<p>Note that it has a table of contents on the left, and also a pop-out synopsis on the right.</p>",
        "id": 269208728,
        "sender_full_name": "Will Crichton",
        "timestamp": 1643085076
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/266220-rustdoc/topic/skimmables/near/269105546\">said</a>:</p>\n<blockquote>\n<p>I think presenting in the declared order is overrated - many authors don't consider it, different authors have different expectations on ordering and since the ordering is implicit the reader can't know which grouping the author used. The only useful aspect is that different impls are separated, c.f., the pure alphabetical ordering (and you can add docs to an impl, iirc). IMO, if we want ordering to be a reading aid then it should be made explicit by letting the author specify a contents page or similar with descriptions of the groups</p>\n</blockquote>\n<p>This discussion really hit a nerve with me, because this is one of the things that has always really bothered me as a user that I've never been able to articulate. The sidebar is effectively a table of contents. Tables of contents are always in the same order as the contents themselves, and its natural to assume The result is that, every single time I read the <code>TyCtxt</code> docs, I get lost and waste time. I pretty regularly want to navigate to the <code>map</code> method, which is at the top of the file, but when I look at the top of the sidebar to jump there, it's not where it is in the file. It's deeply frustrating. Even though I've experienced it plenty of times, the mapping between the two is bewildering that I still get confused.</p>\n<p>Personally, I prefer declaration order. I think the sensible thing to do is just to make it configurable though. That way, authors and people using carefully sorted libraries can use declaration order, and users who just want things alphabetically can do it that way. Although I'm sure y'all don't want to add too much UI, I'm under the impression sort order is one of the most common things to expose, and I think for good reason.</p>",
        "id": 269213877,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1643091244
    },
    {
        "content": "<p>Though I see y'all are talking about more complicated arraignments.  While I would prefer configurability between the options so I could select the one that I need in the moment, any arraignment where the sidebar lines up the text would be a big improvement for me.</p>",
        "id": 269214022,
        "sender_full_name": "inquisitivecrystal",
        "timestamp": 1643091400
    },
    {
        "content": "<p>I ignore bothering with declaration ordering specifically because i know the left bar will sort it for me anyway, and that's the only way to quickly check what methods are available to begin with.</p>\n<p>So my \"lookup\" process is generally:</p>\n<ul>\n<li>search bar, type a Type name, click</li>\n<li>browse the tiny left panel to see what's there</li>\n<li>possibly click a method to jump the main page body to read more info</li>\n</ul>",
        "id": 269216069,
        "sender_full_name": "Lokathor",
        "timestamp": 1643093717
    },
    {
        "content": "<p>\"The sidebar is effectively a table of contents. Tables of contents are always in the same order as the contents themselves\" - interesting! I think of the sidebar as an index rather than a table of contents</p>",
        "id": 269235054,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643105633
    }
]