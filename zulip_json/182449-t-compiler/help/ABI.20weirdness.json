[
    {
        "content": "<p>Hello! I am having some odd behavior with calling conventions in a custom codegen i am working on. <br>\nCUDA C seems to pass a pointer and a <code>vec2&lt;usize&gt;</code> as a 16 byte array in the ptx file:</p>\n<div class=\"codehilite\"><pre><span></span><code>.visible .entry _Z3fooP4vec34vec2(\n    .param .u64 _Z3fooP4vec34vec2_param_0,\n    .param .align 8 .b8 _Z3fooP4vec34vec2_param_1[16]\n)\n</code></pre></div>\n<p>which works fine, however, when i attempt to replicate this function with my codegen, using a vek <code>Vec3</code> struct (a repr C struct of x, y, and z), rustc seems to want to pass the second parameter as two distinct parameters:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[kernel]\npub unsafe fn render(fb: *mut Vec3&lt;f32&gt;, bounds: Vec2&lt;usize&gt;) {\n    let idx = thread::index_2d();\n    if idx.x &gt;= bounds.x || idx.y &gt;= bounds.y {\n        return;\n    }\n    *fb.offset(idx.product() as isize) =\n        (idx.numcast().unwrap() - bounds.numcast().unwrap()).with_z(0.2);\n}\n</code></pre></div>\n<p>nvvm ir snippet generated by my codegen (ABI code taken from cg_llvm):</p>\n<div class=\"codehilite\"><pre><span></span><code>define void @render(%&quot;cuda_std::vek::Vec3&lt;f32&gt;&quot;* nocapture, i64, i64) unnamed_addr {\n</code></pre></div>\n<p>ptx:</p>\n<div class=\"codehilite\"><pre><span></span><code>.visible .entry render(\n    .param .u64 render_param_0,\n    .param .u64 render_param_1,\n    .param .u64 render_param_2\n)\n</code></pre></div>\n<p>This causes a big issue, because when you launch the cuda kernel, cuda expects an extra param instead of a single parameter, which causes a segfault. </p>\n<p>For some reason i cannot get rustc (with my backend) to generate code akin to the CUDA C version, telling rustc to use <code>ptx-kernel</code> or <code>C</code> just makes it pass both things as pointers, which is not what i want (pretty sure it would segfault too). I doubt its my codegen's fault because libnvvm says that it ignores any calling convention markers on functions, rustc seems to decide this before the codegen step.</p>",
        "id": 253163997,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631568734
    },
    {
        "content": "<p>Is <code>Vec2</code> <code>#[repr(C)]</code>?</p>",
        "id": 253164806,
        "sender_full_name": "bjorn3",
        "timestamp": 1631569136
    },
    {
        "content": "<p>Yep</p>",
        "id": 253164813,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569142
    },
    {
        "content": "<p>What does attaching <code>#[rustc_layout(debug)]</code> to the type definition show? You need <code>#![feature(rustc_attrs)]</code> for it to work too.</p>",
        "id": 253165034,
        "sender_full_name": "bjorn3",
        "timestamp": 1631569235
    },
    {
        "content": "<p>Hmm the type def is in the vek crate, lemme try replicating the type and see</p>",
        "id": 253165094,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569263
    },
    {
        "content": "<p>Attaching it to a type alias for <code>Vec2</code> may work too. (<code>#[...] type MyVec2 = Vec2&lt;f32&gt;</code>)</p>",
        "id": 253165254,
        "sender_full_name": "bjorn3",
        "timestamp": 1631569334
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[rustc_layout(debug)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Vec2ButBetter</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">y</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>error: layout_of(Vec2ButBetter) = Layout {\n    fields: Arbitrary {\n        offsets: [\n            Size {\n                raw: 0,\n            },\n            Size {\n                raw: 8,\n            },\n        ],\n        memory_index: [\n            0,\n            1,\n        ],\n    },\n    variants: Single {\n        index: 0,\n    },\n    abi: ScalarPair(\n        Scalar {\n            value: Int(\n                I64,\n                false,\n            ),\n            valid_range: 0..=18446744073709551615,\n        },\n        Scalar {\n            value: Int(\n                I64,\n                false,\n            ),\n            valid_range: 0..=18446744073709551615,\n        },\n    ),\n    largest_niche: None,\n    align: AbiAndPrefAlign {\n        abi: Align {\n            pow2: 3,\n        },\n        pref: Align {\n            pow2: 3,\n        },\n    },\n    size: Size {\n        raw: 16,\n    },\n}\n</code></pre></div>",
        "id": 253165272,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569341
    },
    {
        "content": "<p>yeah it seems the abi wants to pass it as a scalar pair</p>",
        "id": 253165328,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569368
    },
    {
        "content": "<p><code>#[repr(C)]</code> should force ByRef afaik.</p>",
        "id": 253165377,
        "sender_full_name": "bjorn3",
        "timestamp": 1631569402
    },
    {
        "content": "<p>if i mark the function as extern C it forces it to be passed as a pointer</p>",
        "id": 253165409,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569423
    },
    {
        "content": "<p>but i don't think thats the wanted outcome, it should be passed as a byte array</p>",
        "id": 253165429,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569440
    },
    {
        "content": "<p>this is the calling convention that libnvvm wants btw: <a href=\"https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html#rules-and-restrictions\">https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html#rules-and-restrictions</a></p>",
        "id": 253165503,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569461
    },
    {
        "content": "<p>unfortunately i cannot check the llvm ir that nvcc generates for the cuda c version because its closed source but i expect it just passes it by value</p>",
        "id": 253165550,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569494
    },
    {
        "content": "<p>I think you will have to write your own abi calculation code like in rustc_target/src/abi/call You will have to make the functions <code>extern \"C\"</code> too as otherwise the rust abi is used, details of which various parts of the backend depend on. <a href=\"https://github.com/rust-lang/rust/pull/88575\">https://github.com/rust-lang/rust/pull/88575</a> will make it possible to override the abi calculation code from a codegen backend if it lands.</p>",
        "id": 253166093,
        "sender_full_name": "bjorn3",
        "timestamp": 1631569758
    },
    {
        "content": "<p>I was correct, using</p>\n<div class=\"codehilite\"><pre><span></span><code>%&quot;cuda_std::vek::Vec3&lt;f32&gt;&quot; = type { [0 x i32], float, [0 x i32], float, [0 x i32], float, [0 x i32] }\n\ndefine void @foo(%&quot;cuda_std::vek::Vec3&lt;f32&gt;&quot;* nocapture, { i64, i64 }) unnamed_addr #1 {\nstart:\n  ret void\n}\n</code></pre></div>\n<p>makes libnvvm generate the code as </p>\n<div class=\"codehilite\"><pre><span></span><code>.visible .entry foo(\n    .param .u64 foo_param_0,\n    .param .align 8 .b8 foo_param_1[16]\n)\n</code></pre></div>",
        "id": 253166220,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569811
    },
    {
        "content": "<p>hmm, interesting</p>",
        "id": 253166350,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569895
    },
    {
        "content": "<p>What would the abi calculation code entail? just passing everything by value?</p>",
        "id": 253166558,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631569974
    },
    {
        "content": "<p>it sounds kind of cursed but can't i modify the function types/params that i give back to cg_ssa?</p>",
        "id": 253166754,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631570069
    },
    {
        "content": "<p>in <code>FnAbiLlvmExt::llvm_type</code> i treat <code>PassMode::Pair</code> as <code>PassMode::Direct</code>, and keep track of these mappings in cgcx, then in the get_param functions i keep track of that mapping and do the remapping myself</p>",
        "id": 253167182,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631570296
    },
    {
        "content": "<p>because extern functions arent really a thing in libnvvm, this should be safe because the code is only interacting with code generated by the same backend</p>",
        "id": 253167399,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631570405
    },
    {
        "content": "<p><code>extern \"C\"</code> is not about “extern” its about the \"C\" (or other values) primarily.</p>",
        "id": 253181065,
        "sender_full_name": "nagisa",
        "timestamp": 1631579249
    },
    {
        "content": "<p>i.e. its a mechanism to specify the calling convention.</p>",
        "id": 253181076,
        "sender_full_name": "nagisa",
        "timestamp": 1631579257
    },
    {
        "content": "<blockquote>\n<p>cuda expects an extra param instead of a single parameter, which causes a segfault. </p>\n</blockquote>\n<p>This sounds like a need for a well specified calling convention, which <code>\"Rust\"</code> (the default in absence of a different specification) is not.</p>",
        "id": 253181183,
        "sender_full_name": "nagisa",
        "timestamp": 1631579333
    },
    {
        "content": "<p>So you must do what <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> said, pretty much.</p>",
        "id": 253181230,
        "sender_full_name": "nagisa",
        "timestamp": 1631579394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> im pretty sure ptx-kernel is supposed to be the calling convention that cuda uses, but that makes rustc try to pass it as a pointer, not by value, which is very confusing</p>",
        "id": 253184560,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631582393
    },
    {
        "content": "<p>this is the nvvm documentation for the calling convention <a href=\"https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html#argument-passing-and-return\">https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html#argument-passing-and-return</a></p>",
        "id": 253184613,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631582412
    },
    {
        "content": "<p>it doesn't actually tell you how to pass arguments, it just tells you what they will be translated to in the ptx</p>",
        "id": 253184641,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631582443
    },
    {
        "content": "<p>so i personally think its a backend problem not a calling convention problem, but this is confusing overall</p>",
        "id": 253184672,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631582491
    },
    {
        "content": "<p>although the ptx interop guide also says all aggregates and unions are supported using byte arrays <a href=\"https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#aggregates-unions\">https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/index.html#aggregates-unions</a></p>",
        "id": 253184945,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631582745
    },
    {
        "content": "<p>so is rustc generating the wrong pass mode for the ptx-kernel calling convention?</p>",
        "id": 253184995,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631582766
    },
    {
        "content": "<p>I am not sure that's necessarily the case. It may be that llvm's ptx backend actually expects pointers and knows how to deal with them (e.g. by making them byval implicitly)</p>",
        "id": 253221411,
        "sender_full_name": "nagisa",
        "timestamp": 1631611311
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> this is not llvm’s ptx backend, this is my custom codegen backend which uses libnvvm, libnvvm uses a subset of llvm 7 IR and generates PTX from it, along with doing some proprietary opts on it, it well defines how params are passed in one of those docs</p>",
        "id": 253281340,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637316
    },
    {
        "content": "<p>My abi handling code is taken mostly from rustc, and double checking, its generating the correct function types if it receives scalarpair, so the issue is that rustc is asking for scalarpair when it should just be passing everything by value per the ptx-kernel call conv</p>",
        "id": 253281537,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637395
    },
    {
        "content": "<p>Since the ptx abi outlines that all aggregates and unions are supported natively using byte arrays, shouldnt rustc be passing them always by value instead of transforming them to indirect or scalarpair?</p>",
        "id": 253281920,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637528
    },
    {
        "content": "<blockquote>\n<p>I think you will have to write your own abi calculation code like in rustc_target/src/abi/call You will have to make the functions extern \"C\" too as otherwise the rust abi is used, details of which various parts of the backend depend on. <a href=\"https://github.com/rust-lang/rust/pull/88575\">https://github.com/rust-lang/rust/pull/88575</a> will make it possible to override the abi calculation code from a codegen backend if it lands.</p>\n</blockquote>\n<p>this</p>",
        "id": 253282139,
        "sender_full_name": "bjorn3",
        "timestamp": 1631637611
    },
    {
        "content": "<p>Right im just wondering why rustc isnt doing this for ptx-kernel in the first place <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 253282221,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637652
    },
    {
        "content": "<p>The llvm ptx backend doesnt really work on windows but i would expect this would also generate the same wrong code which would segfault, so is this not an issue in rustc too?</p>",
        "id": 253282327,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637716
    },
    {
        "content": "<p>would the fix be making <a href=\"https://github.com/rust-lang/rust/blob/ec9a1bdc4586eec99acbe34df3717b3fd1277b06/compiler/rustc_target/src/abi/call/nvptx64.rs#L16\">https://github.com/rust-lang/rust/blob/ec9a1bdc4586eec99acbe34df3717b3fd1277b06/compiler/rustc_target/src/abi/call/nvptx64.rs#L16</a> make_indirect_by_val?</p>",
        "id": 253282476,
        "sender_full_name": "bjorn3",
        "timestamp": 1631637785
    },
    {
        "content": "<p>I believe so, it should be passing everything by value in ptx</p>",
        "id": 253282567,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637833
    },
    {
        "content": "<p>I will try to see if that fixes it later</p>",
        "id": 253282766,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637913
    },
    {
        "content": "<p>Although id rather not require users to rely on the abi_ptx feature, so ill prob go the route of modifying the extern c handling code once that pr lands</p>",
        "id": 253282936,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631637975
    },
    {
        "content": "<p>although, im still curious as to why implicitly treating everything as Direct in the backend <em>wouldnt</em> work, because to cg_ssa, its basically opaque, and there is technically no concept of a calling convention in ptx, everything uses the ptx calling convention</p>",
        "id": 253283256,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631638091
    },
    {
        "content": "<p>For example fat pointers must be scalar pair. Anything else will cause miscompilations or tripping assertions.</p>",
        "id": 253291759,
        "sender_full_name": "bjorn3",
        "timestamp": 1631641183
    },
    {
        "content": "<p><code>Direct</code> is only meant for primitive types, not composite types.</p>",
        "id": 253291851,
        "sender_full_name": "bjorn3",
        "timestamp": 1631641205
    },
    {
        "content": "<p>I see, <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> how would that PR allow overriding? would i override the query or something?</p>",
        "id": 253295317,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631642581
    },
    {
        "content": "<p>besides, why does rustc extend ints less than 64 bits to 64 bits? according to the <a href=\"https://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability/#parameter-passing\">ref</a> params should be extended to 32 bits if they are below 32 bits, not 64 </p>\n<blockquote>\n<p>Values shorter than 32-bits are sign extended or zero extended, depending on whether they are signed or unsigned types.</p>\n</blockquote>",
        "id": 253302284,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631645179
    },
    {
        "content": "<p>should i submit a bug report for this? it seems rustc is doing some <del>sus</del> odd things for ptx-kernel</p>",
        "id": 253302417,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631645244
    },
    {
        "content": "<p>It is extending to 32 bits for nvptx, but this should not change across nvptx/nvptx64, its always 32 bit extension</p>",
        "id": 253302612,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631645316
    },
    {
        "content": "<blockquote>\n<p>would i override the query or something?</p>\n</blockquote>\n<p>yes</p>\n<blockquote>\n<p>besides, why does rustc extend ints less than 64 bits to 64 bits? according to the ref params should be extended to 32 bits if they are below 32 bits, not 64 </p>\n</blockquote>\n<p>I have no idea.</p>\n<blockquote>\n<p>should i submit a bug report for this? it seems rustc is doing some sus odd things for ptx-kernel</p>\n</blockquote>\n<p>I think so.</p>",
        "id": 253305978,
        "sender_full_name": "bjorn3",
        "timestamp": 1631646529
    },
    {
        "content": "<p>do you happen to know how? i thought queries were made and set in place when tyctxt is made?</p>",
        "id": 253306052,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631646560
    },
    {
        "content": "<p>The <code>CodegenBackend</code> trait has a <code>provide</code> method which allows you to override any query just before the <code>TyCtxt</code> is created.</p>",
        "id": 253307418,
        "sender_full_name": "bjorn3",
        "timestamp": 1631647085
    },
    {
        "content": "<p>oh thats what that method is for! <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> i thought it was only for attrs</p>",
        "id": 253307483,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631647112
    },
    {
        "content": "<p>thank you so much for your continued help <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 253307519,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631647129
    },
    {
        "content": "<p>have a picture i made with the codegen as thanks <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span> <a href=\"/user_uploads/4715/Vncdaxs0NLxNSNwlyWsaO_lM/out.png\">out.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/Vncdaxs0NLxNSNwlyWsaO_lM/out.png\" title=\"out.png\"><img src=\"/user_uploads/4715/Vncdaxs0NLxNSNwlyWsaO_lM/out.png\"></a></div>",
        "id": 253307955,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631647307
    },
    {
        "content": "<p>it aint much but it was made 100% in rust, rust wrapper for the cuda driver API, rust gpu kernel, rust everything <span aria-label=\"crab\" class=\"emoji emoji-1f980\" role=\"img\" title=\"crab\">:crab:</span></p>",
        "id": 253308575,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1631647524
    }
]