[
    {
        "content": "<p>I've noticed that when matching over slices, rustc generates a decision tree. But when matching over <code>&amp;str</code> patterns, rustc generates a call to <code>PartialEq::eq</code> for each string pattern. This means that an expression like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s\">\"abc\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s\">\"abd\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s\">\"def\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"s\">\"deg\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>generates LLVM IR equivalent to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\">      </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"abc\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"abd\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"def\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n<span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"s\">\"deg\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>but if you append 'b' to the start of each pattern:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">as_bytes</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"s\">b\"abc\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"s\">b\"abd\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"s\">b\"def\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"s\">b\"deg\"</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>rustc generates LLVM IR equivalent to:</p>\n<div class=\"codehilite\"><pre><span></span><code>let bytes = s.as_bytes();\nmatch bytes.get(0) {\n    Some(b&#39;a&#39;) =&gt; match bytes.get(1) {\n        Some(b&#39;b&#39;) =&gt; match bytes.get(2) {\n            Some(b&#39;c&#39;) if bytes.get(3) == None =&gt; ...,\n            Some(b&#39;d&#39;) if bytes.get(3) == None =&gt; ...,\n            _ =&gt; None,\n        }\n        _ =&gt; None,\n    }\n    Some(b&#39;d)&#39; =&gt; match bytes.get(1) {\n        Some(b&#39;e&#39;) =&gt; match bytes.get(2) {\n             Some(b&#39;f&#39;) if bytes.get(3) == None =&gt; ...,\n             Some(b&#39;g&#39;) if bytes.get(3) == None =&gt; ...,\n             _ =&gt; None,\n        }\n        _ =&gt; None,\n    }\n    _ =&gt; None,\n}\n</code></pre></div>\n<p>The second style is much faster, since it is constant in the number of patterns, whilst the first is linear in the number of patterns.</p>\n<p>Is there a good reason rustc doesn't compile <code>&amp;str</code> patterns like this, or is it an oversight?</p>",
        "id": 269088854,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643022134
    },
    {
        "content": "<p>I think the only reason is that the <code>b\"foo\"</code> is an array, and thus it hits the array pattern code, which works very differently from strings.</p>\n<p>I don't know that there's a great reason, though ideally I'd expect that LLVM would just do the tree form for the sequence-of-<code>memcmp</code>s if it's helpful.  (Though I guess it doesn't today?)</p>",
        "id": 269091865,
        "sender_full_name": "scottmcm",
        "timestamp": 1643023776
    },
    {
        "content": "<p>nope, llvm doesn't transform chains of <code>memcp</code> into decision-trees. I imagine someone must have investigated that previously to bother generating decision trees from rustc</p>",
        "id": 269092521,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643024148
    },
    {
        "content": "<p>I think it's less \"bother generating\" and more \"well that was the right way to handle slice patterns\".  When you have to support arms like <code>[0, 1, x, y, 10] =&gt; ...</code> you can't do it with just <code>PartialEq::eq</code>.</p>",
        "id": 269092814,
        "sender_full_name": "scottmcm",
        "timestamp": 1643024313
    },
    {
        "content": "<p>(And then the constant version just falls out from it)</p>",
        "id": 269092901,
        "sender_full_name": "scottmcm",
        "timestamp": 1643024390
    },
    {
        "content": "<p>good point</p>",
        "id": 269093368,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643024650
    },
    {
        "content": "<p><a href=\"https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html\">https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html</a></p>\n<p>Someone posted about exactly the same thing last year, but it doesn't seem to have gone anywhere</p>",
        "id": 269093993,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643025041
    },
    {
        "content": "<p>It shouldn't be difficult to switch string to use  slice logic IMO</p>",
        "id": 269096567,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643026554
    },
    {
        "content": "<p>But I wonder if the performance will be worse for small number of match arms.</p>",
        "id": 269096664,
        "sender_full_name": "Gary Guo",
        "timestamp": 1643026609
    },
    {
        "content": "<p>i'll try to make rustc use slice matching logic first. if benchmarks show the perf is worse for small number of patterns, then we can have a heuristic to use <code>memcp</code> instead</p>",
        "id": 269096935,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643026772
    },
    {
        "content": "<p>The thing that would scare me is really long literals, actually.  Because the tree is a good way to do distinct prefixes, but the <code>memcmp</code> is probably better for the \"and does the rest match\" part, so <em>just</em> going to the array logic might not be optimal.</p>\n<p>IIRC the <code>==</code> is also pretty good for strings of different lengths, because it ends up matching on the lengths first, then just doing the <code>memcmp</code> for the one possibility of that length.</p>\n<p>I do wonder if it might be better to make this an LLVM optimization -- it could easily notice a chain of <code>memcmp</code>s against constants -- rather than trying to pick the best approach in <code>match</code> desugaring.</p>",
        "id": 269098963,
        "sender_full_name": "scottmcm",
        "timestamp": 1643028013
    },
    {
        "content": "<p>ok, so i can convert the <code>&amp;str</code> patterns to <code>&amp;[u8]</code> patterns, but the MIR optimiser/verifier complains that the scrutinee cannot be indexed into because it is still a <code>&amp;str</code>. Can I replace the scrutinee with <code>s.as_bytes()</code> ?</p>",
        "id": 269100735,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643028976
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60/near/269098963\">said</a>:</p>\n<blockquote>\n<p>The thing that would scare me is really long literals, actually.  Because the tree is a good way to do distinct prefixes, but the <code>memcmp</code> is probably better for the \"and does the rest match\" part, so <em>just</em> going to the array logic might not be optimal.</p>\n<p>IIRC the <code>==</code> is also pretty good for strings of different lengths, because it ends up matching on the lengths first, then just doing the <code>memcmp</code> for the one possibility of that length.</p>\n<p>I do wonder if it might be better to make this an LLVM optimization -- it could easily notice a chain of <code>memcmp</code>s against constants -- rather than trying to pick the best approach in <code>match</code> desugaring.</p>\n</blockquote>\n<p>I'm not sure how easy it would be to detect this kind of thing from LLVM. My instinct is that it would be easier to implement this in rustc, since rustc has access to the structure of the match block, while all LLVM sees is an unstructured sea of <code>memcmp</code>s and <code>phi</code>s.</p>\n<p>Matching prefixes/suffixes with <code>memcmp</code> is an orthogonal issue, because it would benefit matching over any slice that can be compared with <code>memcmp</code>, not just <code>&amp;str</code>. At the moment, decision trees are always generated for slice patterns, even if only one pattern is being matched against</p>",
        "id": 269102566,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643029838
    },
    {
        "content": "<p>another discussion of the same subject: <a href=\"https://github.com/rust-lang/rust/issues/39525\">https://github.com/rust-lang/rust/issues/39525</a></p>",
        "id": 269103150,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643030149
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60/near/269098963\">said</a>:</p>\n<blockquote>\n<p>IIRC the <code>==</code> is also pretty good for strings of different lengths, because it ends up matching on the lengths first, then just doing the <code>memcmp</code> for the one possibility of that length.</p>\n</blockquote>\n<p>Can't this also be applied to slice matching?</p>",
        "id": 269256856,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1643117703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"454562\">Karl Meakin</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/perf.20of.20matching.20on.20.60.26str.60.20vs.20matching.20on.20.60.26.5Bu8.5D.60/near/269093993\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html\">https://zulip-archive.rust-lang.org/stream/189540-t-compiler/wg-mir-opt/topic/better.20string.20pattern.20matching.html</a></p>\n<p>Someone posted about exactly the same thing last year, but it doesn't seem to have gone anywhere</p>\n</blockquote>\n<p>FWIW, I tried switching string matching to use slice lowering, but it ended up being difficult just because of the way the code was written</p>",
        "id": 269308150,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643138010
    },
    {
        "content": "<blockquote>\n<p>but it ended up being difficult just because of the way the code was written</p>\n</blockquote>\n<p>yep, im discovering that myself :/</p>",
        "id": 269403559,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643200707
    },
    {
        "content": "<p>are there any experts on the rustc pattern matching logic i could ping for some help?</p>",
        "id": 269403672,
        "sender_full_name": "Karl Meakin",
        "timestamp": 1643200771
    }
]