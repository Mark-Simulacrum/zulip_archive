[
    {
        "content": "<p>Hello, </p>\n<p>I have a question about how the mutability of variables is handled by the compiler.</p>\n<p>Let's say I have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">500</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">something_complicated</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">other_complicated_function</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In the last line, is the value in the first x copied to the second x, or is the mutability of the first x just removed?</p>",
        "id": 268329039,
        "sender_full_name": "Patrick Poitras",
        "timestamp": 1642466226
    },
    {
        "content": "<p>I like this pattern because you can have variables that are only mutable for the period where the mutability is needed, and then removed to make it unmutable. I was wondering if the compiler also does this in the background.</p>",
        "id": 268329141,
        "sender_full_name": "Patrick Poitras",
        "timestamp": 1642466339
    },
    {
        "content": "<p>It usually won't copy, as the copy gets optimized away.</p>\n<p>Internally it introduces a new binding that does not have <code>mut</code>.  The lower-level optimizations are responsible for figuring out what needs to be copied or moved around or kept in place.</p>\n<p>If you're curious, you could start looking at the MIR output to see what the mid-level intermediate representation looks like in the compiler.  On a nightly, run <code>rustc</code> with <code>-Zunpretty=mir</code>.  </p>\n<p>If you're even more curious, you could look up SSA (single static assignment). At the lower levels, the code is transformed into a form where variables are only assigned once.</p>",
        "id": 268334400,
        "sender_full_name": "Eric Huss",
        "timestamp": 1642471386
    },
    {
        "content": "<p>You can print out the address of variables. </p>\n<div class=\"codehilite\"><pre><span></span><code>    fn something_complicated() -&gt; bool{\n        true\n    }\n\n    fn other_complicated_function() -&gt; i32 {\n        1\n    }\n\n    let mut x = 500;\n\n    if something_complicated() {\n        x += other_complicated_function();\n    }\n    println!(&quot;x1: 0x{:X}&quot;, (&amp;x as * const i32) as usize);\n\n    let mut x = x;\n\n    if something_complicated() {\n        x += other_complicated_function();\n    }\n    println!(&quot;x2: 0x{:X}&quot;, (&amp;x as * const i32) as usize);\n\n    let x = x;\n    println!(&quot;x3: 0x{:X}&quot;, (&amp;x as * const i32) as usize);\n</code></pre></div>\n<p>Output on my machine:<br>\nx1: 0xD47FF0F2DC<br>\nx2: 0xD47FF0F2D8<br>\nx3: 0xD47FF0F2CC</p>",
        "id": 268335688,
        "sender_full_name": "hyabean",
        "timestamp": 1642472747
    },
    {
        "content": "<p>Printing the addresses of the different variables forces the compiler to keep them separate. If you remove the <code>println!</code>s and the compiler will likely use a single stack slot for the different <code>x</code> variables</p>",
        "id": 268339590,
        "sender_full_name": "nnethercote",
        "timestamp": 1642477251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"451171\">Patrick Poitras</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Question.20about.20mutability/near/268329141\">said</a>:</p>\n<blockquote>\n<p>I like this pattern because you can have variables that are only mutable for the period where the mutability is needed, and then removed to make it unmutable. I was wondering if the compiler also does this in the background.</p>\n</blockquote>\n<p>Btw, to get that pattern in an even more ligthweight fashion, the <code>.tap_mut()</code>-like patterns (<a href=\"https://docs.rs/ext-trait/1.0.0/ext_trait/index.html#also\">an example called <code>also</code></a>), allow writing:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">HashMap</span>::<span class=\"n\">with_capacity</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">).</span><span class=\"n\">also</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">m</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s\">\"foo\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s\">\"bar\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">27</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"c1\">// immutable `map`</span>\n</code></pre></div>\n<p>This, in your case, would give:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mf\">500.</span><span class=\"n\">also</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">something_complicated</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"n\">other_complicated_function</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 268394276,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642514448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> I checked the assembly code in debug mode, the address of x is different. I know the code may be different in release mode. But I can't understand the assembly code in release mode. Can you explain at what stage did this optimization occur? How can I observe the address without modifying the generated code in release mode?</p>",
        "id": 268398128,
        "sender_full_name": "hyabean",
        "timestamp": 1642516133
    },
    {
        "content": "<p>Run the program under a debugger and inspect the variables?</p>",
        "id": 268441523,
        "sender_full_name": "nnethercote",
        "timestamp": 1642533336
    }
]