[
    {
        "content": "<p>For some experimenting, I would like to test if I can create a <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_builtin_macros\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_builtin_macros</a> which is able to look up the declaration of a function passed to it. I'm not talking about having any kind of type analysis, the replacement should be completely done on a \"string\"-level. Say we have </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mf\">2.0</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">mod</span> <span class=\"nn\">bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"n\">magic</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">super</span>::<span class=\"n\">foo</span>::<span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"c1\">// expands to</span>\n<span class=\"c1\">// magic!(\"f(x: f64) -&gt; f64\")</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Macro expansion is done before type analysis, so I guess I can't just add a querry for it. But some builtin macros already have the capability to expand their inner macros. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1618816971f9324fe2cbedb6024324a3\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1618816971f9324fe2cbedb6024324a3</a><br>\nIs there any specific blocker, or can I just go and try to understand / adjust <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_builtin_macros/concat.rs.html#8-65\">https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_builtin_macros/concat.rs.html#8-65</a>?<br>\nAlso, I'm not saying in any way that we should really give users this feature, it's just an interesting question for me and a way to learn about how rustc works.</p>",
        "id": 266642316,
        "sender_full_name": "Manuel Drehwald",
        "timestamp": 1641171237
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"348574\">@Manuel Drehwald</span> </p>\n<p>Disclaimer: I'm a novice rustc contributor.</p>\n<blockquote>\n<p>I'm not talking about having any kind of type analysis, the replacement should be completely done on a \"string\"-level</p>\n</blockquote>\n<p>I don't see how this is possible without querying the type system. At macro expansion time, all you have is the AST tokens and no information about the function signature of <code>f</code>.</p>\n<p>The documentation on rustc_builtin_macros says that they inject code before lowering to HIR. And type information doesn't really exist until you get to the HIR.</p>\n<p>To my knowledge, the closest existing thing to what you want to do is the <code>core::intrinsics::type_name</code> intrinsic (perhaps more commonly known by <code>std::any::type_name</code>): <a href=\"https://doc.rust-lang.org/std/any/fn.type_name.html\">https://doc.rust-lang.org/std/any/fn.type_name.html</a></p>",
        "id": 266655104,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1641191303
    }
]