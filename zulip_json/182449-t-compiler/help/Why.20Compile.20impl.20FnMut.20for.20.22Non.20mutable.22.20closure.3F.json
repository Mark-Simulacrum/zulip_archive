[
    {
        "content": "<p>In following example, because s1 is not mutable, So closure can't mutate it's captured variable s1.  how ever, trait bound <code>where F: FnMut()</code> satisfied. No error triggered.  But obviously closure can't really mutate anything. why compiler have to impl FnMut in this case. <br>\nI also checked source code of libcore/ops/function.rs. the relationship of FnOnce, FnMut and Fn are:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Fn</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span>: <span class=\"nb\">FnMut</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span>: <span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>In another word, FnOnce is a supertrait of  FnMut, and FnMut is a supertrait of Fn. So in order to implement Fn, we have to implement FnMut. <br>\nBut seems it doesn't make sense. if I try to s1.push_str(\" Rust\"); compiler will throw an error,  that basically means compiler is smart enough to know if the closure will make any change. if not, why have to implement FnMut.  why can't make Fn is supertrait of FnMut. <br>\nI must missed something, but couldn't dig out, hope I can get some help here. Thanks! </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">call</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">func</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">()</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">func</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">&quot;Hello&quot;</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// This will trigger &quot;cannot borrow as mutable&quot;</span>\n<span class=\"w\">        </span><span class=\"c1\">// s1.push_str(&quot; Rust&quot;);</span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{} Rust&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"n\">closure</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 186957515,
        "sender_full_name": "Derek",
        "timestamp": 1580364170
    },
    {
        "content": "<p>FnMut does not mean that the closure mutates state, it means that it <em>might</em> mutate state. That, in turn, means that you have to have a mutable receiver in order to call an FnMut. Fn trait means that the it does not mutate state, so if we make Fn a supertrait of FnMut, it would mean that in order to mutate state, it would also need to not mutate state, which does not make sense.</p>",
        "id": 186978730,
        "sender_full_name": "Areredify",
        "timestamp": 1580386075
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> Thanks for you reply,  I really appreciate. If that's the only reason, In my option, <br>\n\"so if we make Fn a supertrait of FnMut, it would mean that in order to mutate state, it would also need to not mutate state, which does not make sense.\"<br>\nThis can be interpreted this way,  Fn is read only.  FnMut goes futher, it can mutate. as mutate will need read first. this kind like any permission management, readonly &lt; read/write. So following rule  would be more clear:</p>\n<ol>\n<li>with move key word, compiler implement FnOnce by default.</li>\n<li>without mutate ability. compiler go further implement FnOnce and Fn.</li>\n<li>with mutate ability, compiler go further implement FnMut. <br>\nthanks</li>\n</ol>",
        "id": 186999236,
        "sender_full_name": "Derek",
        "timestamp": 1580399188
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/reference/types/closure.html#call-traits-and-coercions\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/reference/types/closure.html#call-traits-and-coercions\">https://doc.rust-lang.org/nightly/reference/types/closure.html#call-traits-and-coercions</a></p>",
        "id": 187081995,
        "sender_full_name": "Charles Lew",
        "timestamp": 1580476540
    },
    {
        "content": "<p><code>move</code> is about disabling smart inference, it has nothing to do with call traits.</p>",
        "id": 187082083,
        "sender_full_name": "Charles Lew",
        "timestamp": 1580476581
    }
]