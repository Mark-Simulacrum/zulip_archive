[
    {
        "content": "<p>I'm in the process of hooking rustc up to an llvm backend containing an experimental target for an (old) 8 bit cpu. Things are going well, but I'm running into a problem trying to compile libcore.<br>\n<code>LLVM ERROR: unable to translate instruction: call (in function: _ZN4core3fmt3num12GenericRadix7fmt_int17h0225deeec0744d34E)</code></p>\n<p>I did some poking around with the llvm intermediary output by passing save-temps to rustc, and ran llvm-dis on the problematic bc file to get some llvm-asm out of it to analyze.</p>\n<p>I believe the root of my problem is the fact that the calling convention for a return value for this LLVM target looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>def RetCC_Z80_C : CallingConv&lt;[\n  CCIfType&lt;[ i16 ], CCAssignToReg&lt;[ HL, DE, BC, IY ]&gt;&gt;,\n  CCIfType&lt;[ i8 ], CCAssignToReg&lt;[ A, L, H, E, D, C, B, IYL, IYH ]&gt;&gt;\n]&gt;;\n</code></pre></div>\n<p>Only accepting an 8 or 16 bit value, and several of the call instructions from the llvm disassembler look like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>%55 = call i128 @&quot;_ZN54_$LT$u128$u20$as$u20$core..num..FromStrRadixHelper$GT$8from_u3217he575bc60f15078e9E&quot;(i32 0)\n</code></pre></div>\n<p>and this:</p>\n<div class=\"codehilite\"><pre><span></span><code> %164 = call { i8, i32 } @&quot;_ZN4core4char7methods22_$LT$impl$u20$char$GT$8to_digit17h6ccd7676ad861346E&quot;(i32 %162, i32 %163)\n</code></pre></div>\n<p>So I'm blowing up because I can't translate that call instruction with a 128 bit return value.</p>\n<p>I went ahead and wrote a <code>compute_abi_info</code> routine for my new target triple in <code>compiler/rustc_target/src/abi/call/</code> to take those large return values and <code>make_indirect()</code> them to a pointer to satisfy my llvm calling conventions.</p>\n<p>However, this compute_abi_info function is never getting run, because when compiling libcore (even with a --target specified), it seems that core always compiles with the <code>Rust</code> or <code>RustIntrinsic</code> ABI specified, and so we hit a rule in <code>fn_abi_adjust_for_abi()</code> in <code>compiler/rustc_middle/src/ty/layout.rs</code> that performs some simple blanket abi adjustments and skips any custom adjustments for my target triple.</p>\n<p>I'm assuming that I need to try to get libcore compiled with my custom ABI in mind, but I can't figure out a good way to do that.</p>\n<p>Is this Rust ABI target truly the issue I'm running into? Or is there a deeper problem I'm not understanding?</p>",
        "id": 265468276,
        "sender_full_name": "Dominic DeMarco",
        "timestamp": 1639901887
    },
    {
        "content": "<blockquote>\n<p>Is this Rust ABI target truly the issue I'm running into?</p>\n</blockquote>\n<p>Probably</p>\n<blockquote>\n<p>I'm assuming that I need to try to get libcore compiled with my custom ABI in mind, but I can't figure out a good way to do that.</p>\n</blockquote>\n<p>There are several requirements an abi has to satisfy to be usable as rust abi. This includes but I think is not limited to that all zst (zero sized type) arguments are skipped (for casting closures to function pointers), all arguments with the <code>ScalarPair</code> abi in the layout are passed as two separate values and all pointer arguments as a single value (for dynamic dispatch).</p>",
        "id": 265479657,
        "sender_full_name": "bjorn3",
        "timestamp": 1639919612
    },
    {
        "content": "<p>Backend impl in LLVM should know how to translate these kinds of signatures by itself.</p>",
        "id": 265480576,
        "sender_full_name": "nagisa",
        "timestamp": 1639920949
    },
    {
        "content": "<p>Thanks for the replies all.<br>\n<span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> , is there documentation somewhere of rusts hard abi requirements? Or will I have to do some digging in <code>layout.rs</code> to figure it out?<br>\n<span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> , I imagine they normally do, but this is an experimental target for an old 8 bit cpu, (we're talking 9 usable registers). If the logic to reduce these llvm-asm call arguments is target based, they likely weren't implemented by the original author for some reason or another.<br>\nEvidently in my scenario, something isn't reducing correctly. Offhand, do you know where this logic lives? I haven't worked directly with LLVM before this project.</p>\n<p>As an aside... if anyone knows how to get llvm to spit out some more information on that <code>unable to translate instruction call</code> without me having to write some debug output and recompile, that would be most helpful</p>",
        "id": 265526306,
        "sender_full_name": "Dominic DeMarco",
        "timestamp": 1639982959
    },
    {
        "content": "<p>I don't think there is any documentation. They are assumptions backed into the codegen backend code.</p>",
        "id": 265534491,
        "sender_full_name": "bjorn3",
        "timestamp": 1639989586
    },
    {
        "content": "<p>So here's how you'd debug LLVM side of things: build llvm-project with <code>-DLLVM_ENABLE_ASSERTIONS=1</code> enabled.  Then you can feed LLVM IR to <code>llc -debug</code> to get more info out of it as to what it was doing and where.</p>",
        "id": 265553323,
        "sender_full_name": "nagisa",
        "timestamp": 1640001588
    }
]