[
    {
        "content": "<p>I ran into a not-so-minor issue in my CUDA codegen which im not so sure how to solve. <br>\nAs a background, my codegen guarantees how structs, slices, arrays, etc are passed through GPU kernels by overriding the ABI calculation for anything not rustcall. This is because CUDA expects stuff like <code>foo: Foo</code> to be always passed by value (CUDA supports this, it uses byte arrays), and rustc wouldn't do that, it'd pass it indirectly which yielded a nice segfault. So i overrode the ABI calculation just to guarantee certain things are passed that way.</p>\n<p>This works perfectly, but i just realized that rustc will not emit very important function attributes like noalias for extern \"C\" functions. This is a big problem because <code>noalias</code> is vital for fast GPU code, because it allows cuda to load things like <code>&amp;[u8]</code> into readonly cache, which can have tremendous performance benefits.</p>\n<p>Im not quite sure how i could solve this issue, i basically need to tell rustc to treat extern c functions as normal rust functions, to add any attributes it would normally add if it was a rust function. I have tried making a \"shell\" rust function called by the top level gpu kernel, but that does not work, looking at the LLVM IR and the generated PTX, there is no <code>ld.global.nc</code> (non-coherent read-only cache read) being generated.</p>",
        "id": 262010728,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1637280558
    },
    {
        "content": "<p>Is there any way to retrieve the attributes it would have put but is not putting because it is extern \"C\"? so i can then apply them to the functions that need them</p>",
        "id": 262010876,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1637280677
    },
    {
        "content": "<p>oh i think the problem is actually that i am not giving any scalar attrs when making a new arg abi</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ArgAbi</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"p\">.</span><span class=\"n\">layout</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">ArgAttributes</span>::<span class=\"n\">new</span><span class=\"p\">());</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 262018326,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1637286889
    },
    {
        "content": "<p>it seems that fixed it for <code>&amp;Struct</code> but slices are still the same, it emits <code>[0 x float]* nocapture readonly %a.0</code> without noalias, which is weird</p>",
        "id": 262018871,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1637287410
    }
]