[
    {
        "content": "<p>What is the best way to look past a <code>TyAlias</code> when calling something like <code>def_path_str(def_id)</code>? Trying to figure out the smartest way to go from def_id of the TyAlias to the def_id of item it is aliasing.</p>",
        "id": 269437702,
        "sender_full_name": "hgm4",
        "timestamp": 1643213834
    },
    {
        "content": "<p>Do you mean <code>hir::ItemKind::TyAlias</code>? If so the fields of it already define the type it aliases. By the way not every type has a <code>DefId</code>. For example all primitive types don't.</p>",
        "id": 269439710,
        "sender_full_name": "bjorn3",
        "timestamp": 1643214576
    },
    {
        "content": "<p>That is good to know, thanks @bjorn3. Right now, I am emitting a string using tcx.def_path_str(def_id) but would like to special case TyAlias to emit the original type. I can wrangle the given def_id I have an get back a <code>hir::ItemKind::TyAlias</code>. Maybe there is something equivalent / better than def_path_str?</p>",
        "id": 269440222,
        "sender_full_name": "hgm4",
        "timestamp": 1643214742
    },
    {
        "content": "<p>Why do you exactly want to emit a string?</p>",
        "id": 269443558,
        "sender_full_name": "bjorn3",
        "timestamp": 1643215931
    },
    {
        "content": "<p>Lowering to an alternate IR (for research purposes) from HIR and am emitting call targets as strings. Would like to have calls resolve to the same target without having to worry about type aliases.</p>",
        "id": 269444552,
        "sender_full_name": "hgm4",
        "timestamp": 1643216297
    },
    {
        "content": "<p>Are you sure you want to lower HIR and not MIR? HIR doesn't directly contain type information or any of the type dependent adjustments. HIR becomes immutable after being lowered from the AST and before typechecking. All typechecking information is stored in side tables.</p>",
        "id": 269446089,
        "sender_full_name": "bjorn3",
        "timestamp": 1643216867
    },
    {
        "content": "<p>I think so. In some cases the MIR is too low (I need to be capture certain things, such as patterns, that no longer exist in MIR). I am able to type check everything in the HIR and have the necessary types/adjustments. I'm using <code>tcx.typeck_body(body_id)</code>, where <code>body_id</code> is obtained from <code>tcx.hir().maybe_body_owned_by(tcx.hir().local_def_id_to_hir_id(e.hir_id.owner))</code>, to do so. Getting the resulting type from <code>expr_ty</code> and any adjustments via <code>expr_adjustments</code>.</p>",
        "id": 269447483,
        "sender_full_name": "hgm4",
        "timestamp": 1643217437
    },
    {
        "content": "<p>Would the THIR layer work? It is roughly HIR except with types and adjustments already applied. It isn't public though at the moment: <a href=\"https://github.com/rust-lang/rust/tree/master/compiler/rustc_mir_build/src/thir\">https://github.com/rust-lang/rust/tree/master/compiler/rustc_mir_build/src/thir</a></p>",
        "id": 269447801,
        "sender_full_name": "bjorn3",
        "timestamp": 1643217566
    },
    {
        "content": "<p>I'll take a look. Thank you.</p>",
        "id": 269448520,
        "sender_full_name": "hgm4",
        "timestamp": 1643217838
    },
    {
        "content": "<p>The THIR is public, I use it for my verification tool in combination with MIR, itâ€™s a good IR for many translations/analyses</p>",
        "id": 269494239,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1643237117
    },
    {
        "content": "<p>One gotcha is that typechecking failure is represented by an empty thir</p>",
        "id": 269494362,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1643237189
    }
]