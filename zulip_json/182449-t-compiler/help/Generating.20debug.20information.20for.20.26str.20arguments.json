[
    {
        "content": "<p>Hi everyone,<br>\nRecently, when I tried to debug a Rust binary with WinDbg, I realized that the visualization for objects of type &amp;str that are passed as function arguments are incorrect. For instance, with this program:<br>\n&nbsp;</p>\n<div class=\"codehilite\"><pre><span></span><code>#[inline(never)]\npub fn nam_foo_function(first_var: &amp;str) -&gt; usize {\n    first_var.len()\n}\n\nfn main() {\n    let s = &quot;hello&quot;;\n    let input = &amp;s[1..3];\n    nam_foo_function(input);\n}\n</code></pre></div>\n<p>I got this debug information <a href=\"/user_uploads/4715/xXXZEHLP79vdozNSnBAkNTRA/image.png\">(length should be 5 and the address that data_ptr points to contains no ASCII character) </a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/xXXZEHLP79vdozNSnBAkNTRA/image.png\" title=\"(length should be 5 and the address that data_ptr points to contains no ASCII character) \"><img src=\"/user_uploads/4715/xXXZEHLP79vdozNSnBAkNTRA/image.png\"></a></div><p>I would like to do something to address this problem. A little investigation showed me that Rust breaks down every &amp;str or slice argument into two arguments, a pointer and an int. However, in the LLVM IR, there is only debug information for the original &amp;str or slice argument. Here is a segment of the LLVM IR for the program I posted above:<br>\n&nbsp;</p>\n<div class=\"codehilite\"><pre><span></span><code>; main::nam_foo_function\n; Function Attrs: noinline uwtable\ndefine internal i64 @_ZN4main16nam_foo_function17h6e11569add74fc3fE([0 x i8]* noalias nonnull readonly align 1 %first_var.0, i64 %first_var.1) unnamed_addr #0 !dbg !408 {\nstart:\n  %first_var.dbg.spill = alloca { [0 x i8]*, i64 }, align 8\n  %0 = getelementptr inbounds { [0 x i8]*, i64 }, { [0 x i8]*, i64 }* %first_var.dbg.spill, i32 0, i32 0\n  store [0 x i8]* %first_var.0, [0 x i8]** %0, align 8\n  %1 = getelementptr inbounds { [0 x i8]*, i64 }, { [0 x i8]*, i64 }* %first_var.dbg.spill, i32 0, i32 1\n  store i64 %first_var.1, i64* %1, align 8\n  call void @llvm.dbg.declare(metadata { [0 x i8]*, i64 }* %first_var.dbg.spill, metadata !412, metadata !DIExpression()), !dbg !413\n; call core::str::&lt;impl str&gt;::len\n  %2 = call i64 @&quot;_ZN4core3str21_$LT$impl$u20$str$GT$3len17ha405126c3a923becE&quot;([0 x i8]* noalias nonnull readonly align 1 %first_var.0, i64 %first_var.1), !dbg !414\n  br label %bb1, !dbg !414\n</code></pre></div>\n<p>&nbsp;<br>\nI plan to generate the debug information for <code>first_var.0</code> and <code>first_var.1</code> to see if that would fix the issue.  I had a look at the function <code>debug_introduce_local</code> at <code>compiler\\rustc_codegen_ssa\\src\\mir\\debuginfo.rs</code> and realized that these two arguments are not treated as locals, and it seems that Rust compiler does not generate debug information for values that are not local refs. I wonder if my understanding of how debug information for &amp;str and slice arguments is generated is correct. If so, is there any way to force Rust to emit debug information for components of &amp;str and slice arguments, even though they are not locals?</p>",
        "id": 224916094,
        "sender_full_name": "Nam Nguyen",
        "timestamp": 1612291129
    }
]