[
    {
        "content": "<p>I've looked at the code for <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_middle/src/ty/list.rs#L21-L36\"><code>List&lt;Ty&gt;</code></a> lots of times, but never understood it. Can anyone explain?</p>",
        "id": 263547755,
        "sender_full_name": "nnethercote",
        "timestamp": 1638519857
    },
    {
        "content": "<p>It feels to me like it has insufficient comments given how magical it is</p>",
        "id": 263547767,
        "sender_full_name": "nnethercote",
        "timestamp": 1638519874
    },
    {
        "content": "<p>i understand that code fairly well, so i should helpfully be able to help here. Feel free to ping me on any question you have here or if you just want a general overview of what should happen here</p>",
        "id": 263552625,
        "sender_full_name": "lcnr",
        "timestamp": 1638523037
    },
    {
        "content": "<p>Just a general overview would be great. A starting point is how the zero-length slice works. A follow-up is what the  <code>OpaqueListContents</code> does. Once I know those I think reading the code will be easier</p>",
        "id": 263554412,
        "sender_full_name": "nnethercote",
        "timestamp": 1638524106
    },
    {
        "content": "<p>Thanks <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 263554426,
        "sender_full_name": "nnethercote",
        "timestamp": 1638524116
    },
    {
        "content": "<p>wrt zero length: we compare lists using pointer comparision, so there must only be one empty <code>List&lt;T&gt;</code> for each <code>T</code> ( we actually only use one empty <code>List&lt;T&gt;</code> for all <code>T</code>)</p>",
        "id": 263591180,
        "sender_full_name": "lcnr",
        "timestamp": 1638543572
    },
    {
        "content": "<p>the empty list has to be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">len</span>: <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>tbh I am not completely sure why <code>EmptySlice</code> is a <code>[u8; 64]</code> instead of a single <code>usize</code>. But that doesn'T really matter as only the first <code>mem::size_of::&lt;usize&gt;()</code> bytes of <code>EmptySlice</code> are used.</p>",
        "id": 263591807,
        "sender_full_name": "lcnr",
        "timestamp": 1638543775
    },
    {
        "content": "<p>about <code>OpaqueListContents</code>: <code>&amp;List&lt;T&gt;</code> is pretty much an ordinary interned <code>&amp;[T]</code> with two differences:</p>\n<ul>\n<li>the size of the list is stored as part of the list, this means that<br>\n    - <code>&amp;List&lt;T&gt;</code> is only a single <code>usize</code><br>\n    - you cannot get <code>List</code> which is a subslice of another list, as the length is at the start of each list</li>\n<li>lists are interned and have to be unique, meanign that<ul>\n<li>you can eq and hash its ptr instead of the whole list</li>\n<li>you must not get a subslice of a list as a <code>List</code>, as otherwise you could get a list for <code>[a, b]</code> and <code>[b]</code> and then use <code>[a, b][1..]</code> (if that were to return another list) to get two lists with different pointers to the same elements</li>\n</ul>\n</li>\n</ul>",
        "id": 263592745,
        "sender_full_name": "lcnr",
        "timestamp": 1638544198
    },
    {
        "content": "<p>the <code>data: [T; 0],  opaque: OpaqueListContents</code> is currently the best way to represent a variable sized array of unknown length. Using <code>data: [T]</code> without <code>OpaqueListContents</code> would mean that the len is stored both at the start of the list and as part of its pointer which is not what we want here</p>",
        "id": 263592997,
        "sender_full_name": "lcnr",
        "timestamp": 1638544303
    },
    {
        "content": "<p>i feel like I am mostly repeating the existing comments here '^^ this already feels quite intuitive to me so I am currently missing what you're struggling with <span aria-label=\"bow\" class=\"emoji emoji-1f647\" role=\"img\" title=\"bow\">:bow:</span></p>",
        "id": 263593152,
        "sender_full_name": "lcnr",
        "timestamp": 1638544374
    },
    {
        "content": "<p>The u8 array is probably to make sure we have no padding before it so that lists of less than usize-aligned elements are still ok, Id guess, but this is without looking closely.</p>",
        "id": 263593764,
        "sender_full_name": "simulacrum",
        "timestamp": 1638544625
    },
    {
        "content": "<p>Regarding the <code>[u8; 64]</code>, imagine a <code>T</code> where <code>mem::size_of::&lt;usize&gt;() &lt; mem::align_of::&lt;T&gt;() &lt;= 64</code> then a <code>List&lt;T&gt;</code> is an <code>align_of::&lt;T&gt;()</code>-aligned structure that starts with <code>mem::size_of::&lt;usize&gt;()</code> bytes for the <code>.len</code>, and then <code>mem::align_of::&lt;T&gt;() - mem::size_of::&lt;usize&gt;()</code> padding bytes.</p>\n<p>Tbf, I'd find it clearer if it had done:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[inline(always)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">empty</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">mem</span>::<span class=\"n\">align_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#[repr(align(64)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">MaxAlign</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">InOrder</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">EMPTY_SLICE</span>: <span class=\"nc\">InOrder</span><span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MaxAlign</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">InOrder</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">MaxAlign</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">EMPTY_SLICE</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263667112,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638574361
    },
    {
        "content": "<p>Thanks everyone for the explanations! That does clear it up a bit. Very much like the old trick in C of writing a struct that ends with a zero-length array to allow variable lengths.</p>",
        "id": 263943209,
        "sender_full_name": "nnethercote",
        "timestamp": 1638836050
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/List.3CTy.3E/near/263591807\">said</a>:</p>\n<blockquote>\n<p>the empty list has to be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">List</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">len</span>: <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>One question: does the <code>..</code> here mean \"anything\"? Including emptiness?</p>\n</blockquote>",
        "id": 263946620,
        "sender_full_name": "nnethercote",
        "timestamp": 1638838938
    },
    {
        "content": "<p>Oh, this is important: it's meant to be an interned type, and various operations (e.g. <code>PartialEq</code>) rely on this, but it doesn't provide the interning itself, that comes from outside!</p>",
        "id": 263946990,
        "sender_full_name": "nnethercote",
        "timestamp": 1638839280
    },
    {
        "content": "<p>This is the only place <code>List</code>s are constructed: <a href=\"https://github.com/rust-lang/rust/blob/e5038e20999eef35260b070189883edc2a8a34b2/compiler/rustc_middle/src/ty/context.rs#L2094-L2104\">https://github.com/rust-lang/rust/blob/e5038e20999eef35260b070189883edc2a8a34b2/compiler/rustc_middle/src/ty/context.rs#L2094-L2104</a></p>",
        "id": 263947058,
        "sender_full_name": "nnethercote",
        "timestamp": 1638839322
    },
    {
        "content": "<p>There's nothing to stop someone from unintentionally calling <code>List::from_arena</code> and then getting themselves into trouble</p>",
        "id": 263947092,
        "sender_full_name": "nnethercote",
        "timestamp": 1638839353
    },
    {
        "content": "<p>/me starts writing a PR with better comments</p>",
        "id": 263947337,
        "sender_full_name": "nnethercote",
        "timestamp": 1638839549
    },
    {
        "content": "<p>Hmm, <code>List&lt;T&gt;</code> is an interned (unique) type, so to hash it we can just hash the pointer. We have lots of other interned types (<code>Ty</code>, <code>Substs</code>) that are also always interned(?) but which we hash normally, via the contents.</p>",
        "id": 263950627,
        "sender_full_name": "nnethercote",
        "timestamp": 1638842899
    },
    {
        "content": "<p>So now I'm wondering if we could hash them by address instead</p>",
        "id": 263950659,
        "sender_full_name": "nnethercote",
        "timestamp": 1638842945
    },
    {
        "content": "<p>I guess not if they are <code>Copy</code> types...</p>",
        "id": 263950674,
        "sender_full_name": "nnethercote",
        "timestamp": 1638842961
    },
    {
        "content": "<p>Wait, <code>context.rs</code> has this code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// An entry in an interner.</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Interned</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">tcx</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// N.B., an `Interned&lt;Ty&gt;` compares and hashes as a `TyKind`.</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">PartialEq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Interned</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">TyS</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Interned</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">TyS</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">kind</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">kind</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Hash</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Interned</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">TyS</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">hash</span><span class=\"o\">&lt;</span><span class=\"n\">H</span>: <span class=\"nc\">Hasher</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">kind</span><span class=\"p\">().</span><span class=\"n\">hash</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// N.B., an `Interned&lt;List&lt;T&gt;&gt;` compares and hashes as its elements.</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nb\">PartialEq</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">PartialEq</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Interned</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Interned</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">other</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">Hash</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Hash</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Interned</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">hash</span><span class=\"o\">&lt;</span><span class=\"n\">H</span>: <span class=\"nc\">Hasher</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">H</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">].</span><span class=\"n\">hash</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263952321,
        "sender_full_name": "nnethercote",
        "timestamp": 1638845024
    },
    {
        "content": "<p>!!</p>",
        "id": 263952325,
        "sender_full_name": "nnethercote",
        "timestamp": 1638845028
    },
    {
        "content": "<p>A <code>List&lt;T&gt;</code> uses its address for <code>Eq</code> and <code>Hash</code>, but <code>Interned&lt;List&lt;T&gt;&gt;</code> uses the contents!</p>",
        "id": 263952394,
        "sender_full_name": "nnethercote",
        "timestamp": 1638845089
    },
    {
        "content": "<p>This seems entirely backwards. <code>List&lt;T&gt;</code> has this silent uniqueness requirement that's not even documented. But <code>Interned&lt;List&lt;T&gt;&gt;</code>, whose uniqueness is implied by its name, doesn't take advantage of the uniqueness provided by interning?</p>",
        "id": 263952437,
        "sender_full_name": "nnethercote",
        "timestamp": 1638845159
    },
    {
        "content": "<p>Seems like <code>List&lt;T&gt;</code> could be changed to not have the uniqueness requirement, and then use <code>Interned&lt;List&lt;T&gt;&gt;</code> in the places where we do have uniqueness</p>",
        "id": 263952536,
        "sender_full_name": "nnethercote",
        "timestamp": 1638845267
    },
    {
        "content": "<p>Ok, <a href=\"https://github.com/rust-lang/rust/pull/91617\">https://github.com/rust-lang/rust/pull/91617</a> is my PR for comments and readability. <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> , I used your <code>empty()</code> formulation (with minor modifications), I hope you don't mind</p>",
        "id": 263953086,
        "sender_full_name": "nnethercote",
        "timestamp": 1638845932
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/List.3CTy.3E/near/263952437\">said</a>:</p>\n<blockquote>\n<p>This seems entirely backwards. <code>List&lt;T&gt;</code> has this silent uniqueness requirement that's not even documented. But <code>Interned&lt;List&lt;T&gt;&gt;</code>, whose uniqueness is implied by its name, doesn't take advantage of the uniqueness provided by interning?</p>\n</blockquote>\n<p>Oh... <code>Interned</code> is used within <code>InternedSet</code>. When you're looking to see if a slice has already been interned, the <code>Interned&lt;List&lt;T&gt;&gt;</code> is in the interner, and for that lookup we do need to look at the contents.</p>",
        "id": 263954418,
        "sender_full_name": "nnethercote",
        "timestamp": 1638847580
    },
    {
        "content": "<p>I find that naming non-intuitive, I assumed <code>Interned&lt;T&gt;</code> basically meant <code>Unique&lt;T&gt;</code>, i.e. it was an interned value for use by the outside world</p>",
        "id": 263954453,
        "sender_full_name": "nnethercote",
        "timestamp": 1638847644
    },
    {
        "content": "<p><code>Interned&lt;T&gt;</code> is more like <code>InterningKey&lt;T&gt;</code>, the interned value as used when doing interning lookups</p>",
        "id": 263954465,
        "sender_full_name": "nnethercote",
        "timestamp": 1638847673
    },
    {
        "content": "<p>As opposed to the result you get from an <code>intern()</code> call, which is what I expected</p>",
        "id": 263957683,
        "sender_full_name": "nnethercote",
        "timestamp": 1638851903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> nice PR, I like the clarifications very much. Thanks for doing this!</p>",
        "id": 263993165,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638879946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/List.3CTy.3E/near/263946620\">said</a>:</p>\n<blockquote>\n<p>One question: does the <code>..</code> here mean \"anything\"? Including emptiness?</p>\n</blockquote>\n<p><code>...</code> was meant to represent that we don't care about the rest, so yes, anything including emptiness</p>",
        "id": 263993965,
        "sender_full_name": "lcnr",
        "timestamp": 1638880452
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/List.3CTy.3E/near/263954465\">said</a>:</p>\n<blockquote>\n<p><code>Interned&lt;T&gt;</code> is more like <code>InterningKey&lt;T&gt;</code>, the interned value as used when doing interning lookups</p>\n</blockquote>\n<p>yeah, think i am in favor of renaming that</p>",
        "id": 263994053,
        "sender_full_name": "lcnr",
        "timestamp": 1638880515
    },
    {
        "content": "<p>Thanks for the info!</p>",
        "id": 264063785,
        "sender_full_name": "nnethercote",
        "timestamp": 1638907523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/List.3CTy.3E/near/263994053\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/List.3CTy.3E/near/263954465\">said</a>:</p>\n<blockquote>\n<p><code>Interned&lt;T&gt;</code> is more like <code>InterningKey&lt;T&gt;</code>, the interned value as used when doing interning lookups</p>\n</blockquote>\n<p>yeah, think i am in favor of renaming that</p>\n</blockquote>\n<p><code>ForInterning&lt;T&gt;</code> might be a better name</p>",
        "id": 264063924,
        "sender_full_name": "nnethercote",
        "timestamp": 1638907585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/List.3CTy.3E/near/263950659\">said</a>:</p>\n<blockquote>\n<p>So now I'm wondering if we could hash them by address instead</p>\n</blockquote>\n<p>Note that <code>Ty</code> is already hashed by address. This works because <code>TyS</code> doesn't implement <code>Copy</code> and <code>type Ty&lt;'tcx&gt; = &amp;'tcx TyS&lt;'tcx&gt;</code>.</p>\n<p>I had an attempt to do the same for <code>ty::Const</code>: <a href=\"https://github.com/rust-lang/rust/issues/90951\">#90951</a></p>\n<p>I think the best thing is to have a <code>rustc_middle::ty::P&lt;'tcx, T&gt;</code> smart pointer that can only be constructed with an interned reference. That way we could eliminate <code>&amp;'tcx List&lt;T&gt;</code> and migrate to <code>P&lt;'tcx, [T]&gt;</code>.</p>",
        "id": 264188220,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638983888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"361356\">@fee1-dead</span> <code>&amp;'tcx List&lt;T&gt;</code> has the additional property that it's a single word, because the length is stored within the list. In contrast, <code>P&lt;'tcx, [T]&gt;</code> would be a fat pointer, no?</p>",
        "id": 268792237,
        "sender_full_name": "nnethercote",
        "timestamp": 1642736570
    },
    {
        "content": "<p>That's true. So we can't just do <code>P&lt;'tcx, [T]&gt;</code>, but I'd like to see all other interned objects to use <code>P&lt;'tcx, T&gt;</code> though.</p>",
        "id": 268793372,
        "sender_full_name": "fee1-dead",
        "timestamp": 1642737771
    },
    {
        "content": "<p>Check out <a href=\"https://github.com/rust-lang/rust/issues/93148\">#93148</a>, it's a start on this idea</p>",
        "id": 268799296,
        "sender_full_name": "nnethercote",
        "timestamp": 1642744224
    },
    {
        "content": "<p>Also, <a href=\"https://github.com/rust-lang/rust/issues/93147\">#93147</a> has some comments and other readability improvements that I think are worthwhile</p>",
        "id": 268799316,
        "sender_full_name": "nnethercote",
        "timestamp": 1642744257
    }
]