[
    {
        "content": "<p>Hi, I'm hacking on some of the rust-for-linux project. I'm trying to fix an issue where kbuild (kernel build system) tries to generate metadata (BTF) from DWARF. However, it only works for C -- not rust. I'm going to teach the build system to skip BTF generation for rust modules. </p>\n<p>Is it possible to detect if an object file is built from rust code? Alternatively I could add some magic symbol into the symbol table.</p>",
        "id": 251650759,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630543702
    },
    {
        "content": "<p>One way would be check if it contains symbols mangled in Rust mangling scheme.</p>",
        "id": 251651205,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630544071
    },
    {
        "content": "<p>rust-for-linux uses v0 mangling scheme so basically just check if any symbol starts with <code>_R</code></p>",
        "id": 251651252,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630544135
    },
    {
        "content": "<p>Hmm, could work, but nothing stops a module from having a function called <code>_RemoveFoo</code> or something</p>",
        "id": 251653380,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630546049
    },
    {
        "content": "<p>Well, technically that's not allowed since underscore followed by a capital letter is a reserved identifier in C.</p>",
        "id": 251653761,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630546417
    },
    {
        "content": "<p>But if you want to guard against that you can try to demangle it with Rust mangling scheme, and only count as Rust symbol if it demangles.</p>",
        "id": 251653815,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630546447
    },
    {
        "content": "<p>A 3rd alternative is add a 1 byte note (eg <code>ELFNOTE</code>) . This is pretty easy to do in the <code>module!</code> macro and has the advantage of being easily checked in non-rust parts of the codebase</p>",
        "id": 251654075,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630546710
    },
    {
        "content": "<p>Good point about the reserved identifier, though</p>",
        "id": 251654117,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630546768
    },
    {
        "content": "<p>(Although I'm guessing that restriction does not exist for assembly)</p>",
        "id": 251654183,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630546810
    },
    {
        "content": "<p>I think it'll be sufficient in practice to check the third character for a symbol starting with <code>_R</code>. In v0 mangling scheme it'll be decimal number of a capital letter.</p>",
        "id": 251654383,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630547031
    },
    {
        "content": "<p>Ok, I'll give that a try</p>",
        "id": 251657656,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630550151
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"316820\">Daniel Xu</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Detecting.20that.20an.20object.20file.20is.20rust/near/251650759\">said</a>:</p>\n<blockquote>\n<p>Hi, I'm hacking on some of the rust-for-linux project. I'm trying to fix an issue where kbuild (kernel build system) tries to generate metadata (BTF) from DWARF. However, it only works for C -- not rust. I'm going to teach the build system to skip BTF generation for rust modules. </p>\n<p>Is it possible to detect if an object file is built from rust code? Alternatively I could add some magic symbol into the symbol table.</p>\n</blockquote>\n<p>I'm curious, why does BTF generation fail?</p>",
        "id": 251665445,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630557957
    },
    {
        "content": "<p>Because ideally that's something that should be possible to do.</p>",
        "id": 251665488,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630557967
    },
    {
        "content": "<p>BTF seems to not support enums with data (tagged unions).</p>",
        "id": 251672095,
        "sender_full_name": "bjorn3",
        "timestamp": 1630564544
    },
    {
        "content": "<p>In any case I think it makes sense to skip rust object files as rust emits debuginfo for various internal datastructures like vtables and trait objects where not just the field offsets, but also the complete format is unstable. By not emitting BTF for them it becomes harder for BPF programs to depend on these implementation details. Another hard thing would be niche filling. I don't think a BPF program can switch between the tagged and niche filling layout of an enum at load time.</p>",
        "id": 251672329,
        "sender_full_name": "bjorn3",
        "timestamp": 1630564745
    },
    {
        "content": "<p>Doesn't rust always generate <code>rust_begin_unwind</code> as a symbol? can't you check for that? Although i am not certain if it always makes it and if its going to be in every object file, my intuition says it wont make it for every object file</p>",
        "id": 251682414,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1630571558
    },
    {
        "content": "<p>That symbol is only defined in a single object file and declared in other object files only when a panicking function exists.</p>",
        "id": 251692638,
        "sender_full_name": "bjorn3",
        "timestamp": 1630577233
    },
    {
        "content": "<p>Right, BTF only understands C constructs. To actually support rust, we would most likely need to change BTF spec and teach rest of the ecosystem about rust. Not impossible but unlikely to be well received at the moment.</p>",
        "id": 251739462,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630598587
    },
    {
        "content": "<p>(I pitched a similar idea for C++)</p>",
        "id": 251739684,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630598651
    },
    {
        "content": "<p>Would it make sense to generate BTF for <code>#[repr(C)]</code> structs and ignore <code>#[repr(Rust)]</code> ones?</p>",
        "id": 251747460,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630601649
    },
    {
        "content": "<p>Assuming there's enough info in DWARF to know which structs are <code>#[repr(C)]</code>, maybe, maybe not. I'm not sure how the verifier would like only knowing about _some_ types. </p>\n<p>If it's something that would be useful to do, we can bring it up in bpf list and see what people think.</p>",
        "id": 251762262,
        "sender_full_name": "Daniel Xu",
        "timestamp": 1630607011
    },
    {
        "content": "<p>What about the .note.rustc section?</p>",
        "id": 252003839,
        "sender_full_name": "nagisa",
        "timestamp": 1630765041
    },
    {
        "content": "<p>The <code>.rustc</code> section only exists in dylibs, not object files.</p>",
        "id": 252007882,
        "sender_full_name": "bjorn3",
        "timestamp": 1630769195
    }
]