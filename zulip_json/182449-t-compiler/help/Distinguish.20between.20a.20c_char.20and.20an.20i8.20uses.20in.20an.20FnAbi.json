[
    {
        "content": "<p>I'm currently working on a couple different type metadata identifier encodings for <a href=\"https://github.com/rust-lang/rust/issues/89653\">https://github.com/rust-lang/rust/issues/89653</a>, and one of these encodings need to be able to distinguish between c_char and i8 uses at the time types are encoded. The types are encoded from a rustc_target::abi::call::FnAbi. Is there a way to identify when a ty:Ty in an FnAbi was used as a c_char type alias instead of directly as an i8?</p>",
        "id": 276742204,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648323696
    },
    {
        "content": "<p>If all you have is a <code>Ty</code> I'd be very surprised if that was visible, since there's a number of cases where that kind of distinction is fundamentally lost in inference because it's just a type alias.</p>\n<p>Do you have the FnDef or anything for it?</p>",
        "id": 276742415,
        "sender_full_name": "scottmcm",
        "timestamp": 1648323965
    },
    {
        "content": "<p>c_char is defined as alias for i8 or u8 depending on the target. There is exactly zero difference between them after typechecking.</p>",
        "id": 276742494,
        "sender_full_name": "bjorn3",
        "timestamp": 1648324086
    },
    {
        "content": "<p>The ty::FnDef may be available at the call sites to the function that does the encoding--I need to check all of them.</p>",
        "id": 276742583,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648324231
    },
    {
        "content": "<p>I was able to identify c_void because it's an enum (and thus a ty::Adt that has a name and a crate name). Is there a way to do something similar for c_char? Or maybe add an attribute or mark it somehow?</p>",
        "id": 276742709,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648324374
    },
    {
        "content": "<p>No.  Because it's a <em>type alias</em> (as <span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> said), it's fundamentally not a different thing from <code>i8</code> (or <code>u8</code>, depending on platform).</p>",
        "id": 276742778,
        "sender_full_name": "scottmcm",
        "timestamp": 1648324462
    },
    {
        "content": "<p>If it were instead a <em>newtype</em> (like <code>struct c_char(i8);</code>) then it would be possible, but that would also break everything using <code>c_char</code> today.</p>",
        "id": 276742791,
        "sender_full_name": "scottmcm",
        "timestamp": 1648324497
    },
    {
        "content": "<p>Is there a path from either the ty::FnAbi or ty::FnDef (instead of the ty::Ty) to a higher abstraction level where I can identify it?</p>",
        "id": 276742943,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648324723
    },
    {
        "content": "<p>No, if the function is defined in another crate there is absolutely no information left to distinguish them. Only the <code>ty::Ty</code> is encoded in the crate metadata.</p>",
        "id": 276742968,
        "sender_full_name": "bjorn3",
        "timestamp": 1648324801
    },
    {
        "content": "<p>I'm just thinking about the options: would a transitional new type (i.e., struct c_char(i8)) for use when CFI is enabled and interoperating with foreign code written in C be a viable option? (The reason I'm exploring this encoding is because it'll provide a much more comprehensive protection than the alternative encoding.)</p>",
        "id": 276743574,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648325549
    }
]