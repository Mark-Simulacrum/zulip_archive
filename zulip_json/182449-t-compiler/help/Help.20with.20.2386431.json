[
    {
        "content": "<p>I have some questions about tackling <a href=\"https://github.com/rust-lang/rust/issues/86431\">#86431</a>, and am seeking feedback for my approach to caching the string segments.</p>\n<ul>\n<li>\n<p>What is meant by the term \"type renderings\"? Does this refer to matching <code>TyKind</code> to it's string literal value e.g. <code>ty::Bool =&gt; output.push_str(\"bool\")</code> ? or does it refer to pushing the type's identifier onto the output string? Just want to be sure.</p>\n</li>\n<li>\n<p>As for how to approach caching repeat string segments, my current idea is to use a wrapper to a hash map that uses a <code>TyKind</code> as a key to a string literal e.g. <code>&lt;TyKind, &amp;str&gt;</code>. This wrapper will also implement the   <code>push_debuginfo_type_name()</code>and <code>compute_debuginfo_type()</code> functions. The caching will occur in <code>push</code> when we have matched to a given type. Just check if the type is in the cache and if not, load it. Then use it's key to push the string literal onto the output string.</p>\n</li>\n<li>\n<p>Part of this issue means analyzing redundant work that the compiler is currently doing. I am wondering if there is a \"best approach\" to this. As so far my only idea is to profile the compiler before I make changes, and after I make changes, and observe any differences. I don't think this will yield an accurate assessment however, and am curious if anyone would suggest something different.</p>\n</li>\n</ul>",
        "id": 252212565,
        "sender_full_name": "Timothy Maloney",
        "timestamp": 1630955025
    }
]