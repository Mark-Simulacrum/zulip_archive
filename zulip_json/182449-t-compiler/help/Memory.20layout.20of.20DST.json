[
    {
        "content": "<p>I'm trying to figure out how to emit DST for a rust verification backend I'm working on.  In particular, what is the memory layout of the a <code>[u8]</code> without the reference (i.e. the <code>Inner.inner</code> field? What is the layout of the <code>Inner</code> class here, what is the layout of <code>&amp;Inner</code> (I assume a fat pointer)? </p>\n<div class=\"codehilite\"><pre><span></span><code>// From rust/library/std/src/sys_common/os_str_bytes.rs\n//      rust/library/std/src/ffi/os_str.rs\n\nuse std::mem;\n\nstruct Inner {\n    pub inner: [u8],\n}\n\nimpl Inner {\n    fn from_u8_slice(s: &amp;[u8]) -&gt; &amp;Inner {\n        unsafe { mem::transmute(s) }\n    }\n}\n\n fn test2() {\n     let inner = Inner::from_u8_slice(b&quot;hi&quot;);\n     assert!(inner.inner[0] == &#39;h&#39; as u8);\n     assert!(inner.inner[1] == &#39;i&#39; as u8);\n }\n\nfn main() {\n    test1();\n    test2();\n}\n\nfn test1() {\n    let inner = Inner::from_u8_slice(b&quot;hi&quot;);\n    let b = &amp;inner.inner;\n    assert!(b[0] == &#39;h&#39; as u8);\n    assert!(b[1] == &#39;h&#39; as u8);\n}\n</code></pre></div>",
        "id": 230362689,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615821605
    },
    {
        "content": "<p>[u8] would be just a list of bytes where the value is placed.</p>",
        "id": 230362961,
        "sender_full_name": "nagisa",
        "timestamp": 1615821709
    },
    {
        "content": "<p>&amp;Inner is a fat pointer, yes.</p>",
        "id": 230363091,
        "sender_full_name": "nagisa",
        "timestamp": 1615821738
    },
    {
        "content": "<p>So in C terms, </p>\n<div class=\"codehilite\"><pre><span></span><code>struct Inner {\n  uint8_t* inner;\n};\n</code></pre></div>",
        "id": 230363241,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615821789
    },
    {
        "content": "<p>And to abuse C syntax:</p>\n<div class=\"codehilite\"><pre><span></span><code>struct &amp;Inner {\n    struct Inner inner,\n   size_t size\n};\n</code></pre></div>",
        "id": 230363333,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615821831
    },
    {
        "content": "<p>Is that correct?</p>",
        "id": 230363346,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615821839
    },
    {
        "content": "<p>not really, its a </p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Inner</span> <span class=\"p\">{</span>\n    <span class=\"kt\">uint8_t</span> <span class=\"n\">inner</span><span class=\"p\">[</span><span class=\"n\">UNKNOWN</span><span class=\"p\">];</span> <span class=\"c1\">// if I remember my C right</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>and <code>&amp;Inner</code> is a </p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"o\">&amp;</span><span class=\"n\">Inner</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"nc\">Inner</span><span class=\"o\">*</span> <span class=\"n\">buffer</span><span class=\"p\">;</span>\n    <span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 230363627,
        "sender_full_name": "nagisa",
        "timestamp": 1615821941
    },
    {
        "content": "<p>Ahh ...</p>",
        "id": 230363766,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615821985
    },
    {
        "content": "<p>And if I had more than one field? </p>\n<div class=\"codehilite\"><pre><span></span><code>struct Inner {\n    pub foo: i16,\n    pub inner: [u8],\n}\n</code></pre></div>",
        "id": 230363980,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615822082
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Inner</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int64_t</span> <span class=\"n\">foo</span><span class=\"p\">;</span>\n    <span class=\"kt\">uint8_t</span> <span class=\"n\">inner</span><span class=\"p\">[</span><span class=\"n\">UNKNOWN</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 230364220,
        "sender_full_name": "bjorn3",
        "timestamp": 1615822168
    },
    {
        "content": "<p>And the size field in the fat pointer would be the size of the known fields of <code>Inner</code> + the size of the slice at the end?</p>",
        "id": 230364347,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615822207
    },
    {
        "content": "<p>No, the size field in the fat pointer only counts the amount of elements in <code>[u8]</code>.</p>",
        "id": 230364407,
        "sender_full_name": "bjorn3",
        "timestamp": 1615822230
    },
    {
        "content": "<p>Then the allocator does the addition when doing an allocation?</p>",
        "id": 230364521,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615822271
    },
    {
        "content": "<p>No, <code>std::mem::size_of_val</code> does this addition.</p>",
        "id": 230364733,
        "sender_full_name": "bjorn3",
        "timestamp": 1615822349
    },
    {
        "content": "<p>ahh, ok</p>",
        "id": 230364791,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615822377
    },
    {
        "content": "<p>I'm going to go implement this, I may have further questions this afternoon. Thanks for the help!</p>",
        "id": 230364877,
        "sender_full_name": "Daniel Schwartz-Narbonne",
        "timestamp": 1615822398
    },
    {
        "content": "<p>actually C can have arrays without explicit size inside structs</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Inner</span> <span class=\"p\">{</span>\n  <span class=\"kt\">uint8_t</span> <span class=\"n\">inner</span><span class=\"p\">[];</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>and it is actually safer to do that, because these arrays must reside at the end of struct</p>",
        "id": 230417251,
        "sender_full_name": "Soveu",
        "timestamp": 1615841926
    },
    {
        "content": "<p>yeah, I wasn't sure if C represents that as a pointer or as a value, so went for the safe option to demonstrate my point.</p>",
        "id": 230420626,
        "sender_full_name": "nagisa",
        "timestamp": 1615843269
    },
    {
        "content": "<p>Its been ages since I last wrote any serious C ^^</p>",
        "id": 230420659,
        "sender_full_name": "nagisa",
        "timestamp": 1615843286
    },
    {
        "content": "<p>Yeah, C likes to cast arrays to pointers</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">void</span> <span class=\"nf\">takes_pointer_in_reality</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">arr</span><span class=\"p\">[])</span> <span class=\"p\">{}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">takes_pointer_in_reality2</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">])</span> <span class=\"p\">{}</span>\n</code></pre></div>",
        "id": 230534820,
        "sender_full_name": "Soveu",
        "timestamp": 1615909108
    },
    {
        "content": "<p>but</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Array</span> <span class=\"p\">{</span>\n  <span class=\"kt\">int</span> <span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">];</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">takes_array</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"nc\">Array</span> <span class=\"n\">arr</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n</code></pre></div>",
        "id": 230535150,
        "sender_full_name": "Soveu",
        "timestamp": 1615909221
    },
    {
        "content": "<p>I have a follow up question about this. I'm looking at the following example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">NonEmptySlice</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">first</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">others</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">NonEmptySlice</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">bytes</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"This requires at least one element\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">vector</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"k\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">slice</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">NonEmptySlice</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"p\">.</span><span class=\"n\">as_mut_slice</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Values are correct.</span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">first</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">others</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Not sure why these are the correct values.</span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">mem</span>::<span class=\"n\">size_of_val</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"p\">.</span><span class=\"n\">others</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It is not clear to my why the <code>size_of_val</code> for my object is <code>3</code> neither why the length of <code>others</code> is 2.</p>\n<p>Thanks!</p>",
        "id": 277774168,
        "sender_full_name": "Celina V.",
        "timestamp": 1649096622
    },
    {
        "content": "<p>BTW, the structure I'm creating is clearly corrupt and trying to iterate over <code>others</code> on valgrind triggers an invalid read error.</p>",
        "id": 277774323,
        "sender_full_name": "Celina V.",
        "timestamp": 1649096693
    },
    {
        "content": "<p>The <code>bytes</code> argument is basically <code>(*mut u8, usize)</code> with values <code>(some_ptr, 3)</code>. When you transmute, that doesn't change. So the new slice thinks its unsized part is still 3 elements long. You need to use <a href=\"https://doc.rust-lang.org/std/slice/fn.from_raw_parts_mut.html\">https://doc.rust-lang.org/std/slice/fn.from_raw_parts_mut.html</a> with a manually adjusted length</p>",
        "id": 277775949,
        "sender_full_name": "oli",
        "timestamp": 1649097503
    },
    {
        "content": "<p>So your function body should be something like <code>let len = bytes.len(); unsafe { std::slice::from_raw_parts_mut(bytes as *mut [u8] as *mut _, len - 1) }</code></p>",
        "id": 277776198,
        "sender_full_name": "oli",
        "timestamp": 1649097616
    },
    {
        "content": "<p>I guess I'm transmuting the reference not the object itself. :(</p>",
        "id": 277778346,
        "sender_full_name": "Celina V.",
        "timestamp": 1649098667
    },
    {
        "content": "<p>The following seems to work well. Thanks!</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">bytes</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">bytes</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"This requires at least one element\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">unsized_len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bytes_ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">unsized_len</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">bytes_ptr</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277779565,
        "sender_full_name": "Celina V.",
        "timestamp": 1649099278
    },
    {
        "content": "<p>Hmm... I wonder if we can somehow eliminate that transmute, but I can't think of any way right now</p>",
        "id": 277784000,
        "sender_full_name": "oli",
        "timestamp": 1649101626
    },
    {
        "content": "<p>Please let me know if you do. :)</p>",
        "id": 277784205,
        "sender_full_name": "Celina V.",
        "timestamp": 1649101753
    },
    {
        "content": "<p>One might expect</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bytes</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to do the right thing, but it doesn't</p>",
        "id": 277790871,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649105051
    },
    {
        "content": "<p>On nightly, I think you'd use <code>ptr::from_raw_parts_mut</code> with the base pointer and the tail slice's metadata, then <code>&amp;*</code> for a reference.</p>",
        "id": 277790902,
        "sender_full_name": "cuviper",
        "timestamp": 1649105066
    },
    {
        "content": "<p>I'm not sure the associated <code>Metadata</code> type will be considered equal though.</p>",
        "id": 277791048,
        "sender_full_name": "cuviper",
        "timestamp": 1649105140
    },
    {
        "content": "<p>This works to avoid the <code>transmute</code> at least: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=44db79eeb76599da1b344e69fb8a3d5a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=44db79eeb76599da1b344e69fb8a3d5a</a></p>",
        "id": 277791325,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649105275
    },
    {
        "content": "<p>That's amazing. You don't even need the assert anymore.</p>",
        "id": 277793068,
        "sender_full_name": "oli",
        "timestamp": 1649106114
    },
    {
        "content": "<p>This could now even be made generic over an array length so that the prefix is an array</p>",
        "id": 277793150,
        "sender_full_name": "oli",
        "timestamp": 1649106142
    },
    {
        "content": "<p>True</p>",
        "id": 277794134,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649106623
    },
    {
        "content": "<p>There's a potential provenance issue with <code>&amp;mut bytes[..len-1]</code> though</p>",
        "id": 277794426,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649106768
    },
    {
        "content": "<p>This avoids that: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=54b6f7a1235e86fdd6f907531897eb3a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=54b6f7a1235e86fdd6f907531897eb3a</a></p>",
        "id": 277794669,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1649106896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Memory.20layout.20of.20DST/near/277790902\">said</a>:</p>\n<blockquote>\n<p>On nightly, I think you'd use <code>ptr::from_raw_parts_mut</code></p>\n</blockquote>\n<p>This is, AFAIK, the only officially-sound way.  The transmute between reference-to-DSTs is officially UB.</p>",
        "id": 277799601,
        "sender_full_name": "scottmcm",
        "timestamp": 1649109535
    },
    {
        "content": "<p>It would be especially UB given that the struct is <code>#[repr(Rust)]</code>.</p>",
        "id": 277801275,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1649110532
    }
]