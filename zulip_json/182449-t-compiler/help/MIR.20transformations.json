[
    {
        "content": "<p>Hi all,</p>\n<p>I'm doing research on static analysis and optimization in Rust for my Master's thesis and I'm interested in how MIR optimization / transformation works.</p>\n<p>In particular for my project I want to perform static analysis across the entire crate, then perform some transformations.  I've read some of the existing transform passes and compiler queries but I don't see an example of this. I've written my own transform passes as well, but I'm stuck on how to get some sort of entire-crate analysis result.</p>\n<p>I've read most of sections 2 and 3 of the Rustc dev book but haven't figured out how to solve my problem.</p>\n<p>I was wondering if someone has time to answer some questions -- it would be great to discuss this at a high level.</p>\n<p>Thanks!</p>",
        "id": 198432955,
        "sender_full_name": "Claire Nord",
        "timestamp": 1590148681
    },
    {
        "content": "<blockquote>\n<p>but I'm stuck on how to get some sort of entire-crate analysis result.</p>\n</blockquote>\n<p>That is a hard problem to solve using the current architecture. I can see several problems:</p>\n<ol>\n<li>How do you collect all functions? Some functions like shims only pop into existence during the collector, which requests already optimized MIR. While other functions are never used at all.</li>\n<li>How do you handle incremental compilation? If you analyse all functions and then make the optimized MIR depend on that analysis any change to any function would likely cause all codegened object files to be codegened again.</li>\n<li>There is currently only one optimization that supports non-local transformations: inlining. Unfortunately it has several problems. One of which is that it doesn't handle recursive functions very well. It works by requesting the already optimized mir for the callee. Doing so would cause cycles, so there is a hack to prevent inlining back edges by only inlining functions that come before the current function in the source code.</li>\n</ol>\n<p>If you solve the first problem you may be able to add a new query to request the analysis and make that query depend on <code>tcx.mir_validated</code>. Just make sure to depend on the query for all <code>tcx.optimized_mir</code> calls, as any <code>tcx.optimized_mir</code> call before the query has analysed anything will make <code>tcx.mir_validated</code> for that specific function impossible.</p>\n<p>Also may I ask what kind of analysis you want to perform?</p>",
        "id": 198434493,
        "sender_full_name": "bjorn3",
        "timestamp": 1590149802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"304165\">@Claire Nord</span> ^</p>",
        "id": 198434518,
        "sender_full_name": "bjorn3",
        "timestamp": 1590149829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Thank you for your response!</p>\n<blockquote>\n<ol>\n<li>How do you collect all functions?</li>\n</ol>\n</blockquote>\n<p>What is an example of a shim? This might not be a problem for our initial MVP. We only care about developer-defined functions in source code.</p>\n<blockquote>\n<ol start=\"2\">\n<li>How do you handle incremental compilation?</li>\n</ol>\n</blockquote>\n<p>We're not really concerned about compile time, so I think it's okay to just re-compile with any change to any function.</p>\n<blockquote>\n<ol start=\"3\">\n<li>inlining</li>\n</ol>\n</blockquote>\n<p>Yeah, it was helpful to read through the inlining code.</p>\n<blockquote>\n<p>Just make sure to depend on the query for all tcx.optimized_mir calls, as any tcx.optimized_mir call before the query has analysed anything will make tcx.mir_validated for that specific function impossible.</p>\n</blockquote>\n<p>When you say \"depend on the query for all <code>tcx.optimized_mir</code> calls, do you mean that <code>fn optimized_mir\\(...\\)</code> source code should contain a call to my query, or that I should call my query before each time <code>tcx.optimized_mir</code> is called in the compiler code? Right now I'm running into a cycle by depending on <code>tcx.mir_validated</code> for every <code>def_id</code> in <code>tcx.mir_keys(LOCAL_CRATE)</code>.</p>\n<p>For more context, my project involves def-use analysis for every object of a certain type in a crate. I want to check every time an object of that type is allocated and used across functions, closures, etc. Once I have that global def-use information, I use that for an optimization step.</p>\n<p>Thank you for your responses so far. Can you further explain what you had in mind for query dependencies? I'd love to get your perspective on this either in chat or voice call, if that's easier.</p>",
        "id": 199382360,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591025066
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"304165\">@Claire Nord</span> </p>\n<blockquote>\n<p>What is an example of a shim? This might not be a problem for our initial MVP. We only care about developer-defined functions in source code.</p>\n</blockquote>\n<p>A shim is a function generated by rustc to implement certain things. For example the <code>CloneShim</code> is used for the compiler implementation of <code>Clone</code> for <code>[T; n]</code>.</p>\n<p>See <a href=\"https://github.com/rust-lang/rust/blob/d3cba254e464303a6495942f3a831c2bbd7f1768/src/librustc_mir/shim.rs#L33-L112\">https://github.com/rust-lang/rust/blob/d3cba254e464303a6495942f3a831c2bbd7f1768/src/librustc_mir/shim.rs#L33-L112</a> for the full list of shims.</p>\n<blockquote>\n<p>When you say \"depend on the query for all tcx.optimized_mir calls, do you mean that fn optimized_mir\\(...\\) source code should contain a call to my query, or that I should call my query before each time tcx.optimized_mir is called in the compiler code? Right now I'm running into a cycle by depending on tcx.mir_validated for every def_id in tcx.mir_keys(LOCAL_CRATE).</p>\n</blockquote>\n<p>You have to run it from <code>fn optimized_mir(...)</code> before calling <code>body.steal()</code>: <a href=\"https://github.com/rust-lang/rust/blob/d3cba254e464303a6495942f3a831c2bbd7f1768/src/librustc_mir/transform/mod.rs#L401\">https://github.com/rust-lang/rust/blob/d3cba254e464303a6495942f3a831c2bbd7f1768/src/librustc_mir/transform/mod.rs#L401</a></p>",
        "id": 199386677,
        "sender_full_name": "bjorn3",
        "timestamp": 1591027166
    },
    {
        "content": "<blockquote>\n<p>You have to run it from <code>fn optimized_mir(...)</code> before calling <code>body.steal()</code></p>\n</blockquote>\n<p>Ah yes, I’m doing that. I’m running into a query cycle, though. <span aria-label=\"slight frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"slight frown\">:slight_frown:</span> </p>\n<p>My query basically does <code>for def_id in tcx.mir_keys(crate_num) { tcx.subquery(def_id); }</code>, where <code>subquery</code> calls <code>tcx.mir_validated</code> and performs def-use analysis.</p>\n<p>The compiler detects a cycle where my first query calls itself. I’m working on getting a more verbose trace of the cycle now, but do you have an idea of why this would happen? <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span></p>",
        "id": 199390317,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591028836
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"304165\">@Claire Nord</span> What is the query stack during the cycle error? (Run rustc with <code>RUST_BACKTRACE=1</code> to show it)</p>",
        "id": 199390637,
        "sender_full_name": "bjorn3",
        "timestamp": 1591028979
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error[E0391]: cycle detected when [ performing my query ]\n     |\nnote: ...which requires processing `unix::linux_like::linux::CPU_EQUAL`...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/macros.rs:192:17\n     |\n192  | /                 pub unsafe extern fn $i($($arg: $argty),*\n193  | |                 ) -&gt; $ret {\n194  | |                     $($body);*\n195  | |                 }\n     | |_________________^\n     |\n    ::: /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:2307:1\n     |\n2307 | / f! {\n2308 | |     pub fn NLA_ALIGN(len: ::c_int) -&gt; ::c_int {\n2309 | |         return ((len) + NLA_ALIGNTO - 1) &amp; !(NLA_ALIGNTO - 1)\n2310 | |     }\n...    |\n2406 | |     }\n2407 | | }\n     | |_- in this macro invocation\nnote: ...which requires getting validated MIR...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/macros.rs:192:17\n     |\n192  | /                 pub unsafe extern fn $i($($arg: $argty),*\n193  | |                 ) -&gt; $ret {\n194  | |                     $($body);*\n195  | |                 }\n     | |_________________^\n     |\n    ::: /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:2307:1\n     |\n2307 | / f! {\n2308 | |     pub fn NLA_ALIGN(len: ::c_int) -&gt; ::c_int {\n2309 | |         return ((len) + NLA_ALIGNTO - 1) &amp; !(NLA_ALIGNTO - 1)\n2310 | |     }\n...    |\n2406 | |     }\n2407 | | }\n     | |_- in this macro invocation\nnote: ...which requires getting pre-const evaluation MIR...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/macros.rs:192:17\n     |\n192  | /                 pub unsafe extern fn $i($($arg: $argty),*\n193  | |                 ) -&gt; $ret {\n194  | |                     $($body);*\n195  | |                 }\n     | |_________________^\n     |\n    ::: /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:2307:1\n     |\n2307 | / f! {\n2308 | |     pub fn NLA_ALIGN(len: ::c_int) -&gt; ::c_int {\n2309 | |         return ((len) + NLA_ALIGNTO - 1) &amp; !(NLA_ALIGNTO - 1)\n2310 | |     }\n...    |\n2406 | |     }\n2407 | | }\n     | |_- in this macro invocation\nnote: ...which requires processing `unix::linux_like::linux::CPU_EQUAL`...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/macros.rs:192:17\n     |\n192  | /                 pub unsafe extern fn $i($($arg: $argty),*\n193  | |                 ) -&gt; $ret {\n194  | |                     $($body);*\n195  | |                 }\n     | |_________________^\n     |\n    ::: /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:2307:1\n     |\n2307 | / f! {\n2308 | |     pub fn NLA_ALIGN(len: ::c_int) -&gt; ::c_int {\n2309 | |         return ((len) + NLA_ALIGNTO - 1) &amp; !(NLA_ALIGNTO - 1)\n2310 | |     }\n...    |\n2406 | |     }\n2407 | | }\n     | |_- in this macro invocation\nnote: ...which requires processing `unix::linux_like::linux::CPU_EQUAL`...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/macros.rs:192:17\n     |\n192  | /                 pub unsafe extern fn $i($($arg: $argty),*\n193  | |                 ) -&gt; $ret {\n194  | |                     $($body);*\n195  | |                 }\n     | |_________________^\n     |\n    ::: /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:2307:1\n     |\n2307 | / f! {\n2308 | |     pub fn NLA_ALIGN(len: ::c_int) -&gt; ::c_int {\n2309 | |         return ((len) + NLA_ALIGNTO - 1) &amp; !(NLA_ALIGNTO - 1)\n2310 | |     }\n...    |\n2406 | |     }\n2407 | | }\n     | |_- in this macro invocation\nnote: ...which requires processing `unix::linux_like::linux::CPU_EQUAL`...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/macros.rs:192:17\n     |\n192  | /                 pub unsafe extern fn $i($($arg: $argty),*\n193  | |                 ) -&gt; $ret {\n194  | |                     $($body);*\n195  | |                 }\n     | |_________________^\n     |\n    ::: /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:2307:1\n     |\n2307 | / f! {\n2308 | |     pub fn NLA_ALIGN(len: ::c_int) -&gt; ::c_int {\n2309 | |         return ((len) + NLA_ALIGNTO - 1) &amp; !(NLA_ALIGNTO - 1)\n2310 | |     }\n...    |\n2406 | |     }\n2407 | | }\n     | |_- in this macro invocation\nnote: ...which requires const-evaluating + checking `unix::linux_like::linux::cpu_set_t::bits::{{constant}}#0`...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:148:21\n     |\n148  |         bits: [u64; 16],\n     |                     ^^\nnote: ...which requires const-evaluating + checking `unix::linux_like::linux::cpu_set_t::bits::{{constant}}#0`...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:148:21\n     |\n148  |         bits: [u64; 16],\n     |                     ^^\nnote: ...which requires const-evaluating `unix::linux_like::linux::cpu_set_t::bits::{{constant}}#0`...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:148:21\n     |\n148  |         bits: [u64; 16],\n     |                     ^^\nnote: ...which requires getting optimized MIR...\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/linux/mod.rs:148:21\n     |\n148  |         bits: [u64; 16],\n     |                     ^^\n     = note: ...which again requires [ performing my query ], completing the cycle\nnote: cycle used when getting optimized MIR\n    --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/libc-0.2.66/src/unix/linux_like/mod.rs:35:33\n     |\n35   |         pub sa_data: [::c_char; 14],\n     |                                 ^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0391`.\nerror: could not compile `libc`.\n</code></pre></div>\n\n\n<p>@bjorn3 my query is <code>[ performing my query ]</code>, and the other descriptions should be intuitive (I modified them because I couldn't figure out how to set <code>tcx.sess.opts.debugging_opts.verbose</code> -- it's not <code>cargo -vv</code>, is it?).</p>",
        "id": 199521604,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591116954
    },
    {
        "content": "<p>The query names are printed when using <code>RUST_BACKTRACE=1</code> afaik</p>",
        "id": 199521745,
        "sender_full_name": "lcnr",
        "timestamp": 1591117012
    },
    {
        "content": "<p>@lcnr hm, the command I ran was <code>RUSTC_LOG=rustc_mir::transform=debug RUST_BACKTRACE=1 cargo +stage1 build -vv |&amp; tee out.log</code></p>",
        "id": 199522090,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591117184
    },
    {
        "content": "<p>What is the result of <code>RUSTC_LOG=rustc_mir::transform=debug RUST_BACKTRACE=1 cargo +stage1 build -vv --rustc-args -Ztreat-err-as-bug  |&amp; tee out.log</code></p>",
        "id": 199522375,
        "sender_full_name": "lcnr",
        "timestamp": 1591117286
    },
    {
        "content": "<p>I think the problem here is that const evaluated code is also optimized. This however can run during typechecking, which is required to generate MIR for other functions, thus causing a cycle.</p>",
        "id": 199522498,
        "sender_full_name": "bjorn3",
        "timestamp": 1591117332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span></p>\n<div class=\"codehilite\"><pre><span></span><code>$ RUSTC_LOG=rustc_mir::transform=debug RUST_BACKTRACE=1 cargo +stage1 build -vv --rustc-args -Ztreat-err-as-bug  |&amp; tee out.log\nerror: Found argument &#39;--rustc-args&#39; which wasn&#39;t expected, or isn&#39;t valid in this context\n\nUSAGE:\n    cargo build --verbose\n\nFor more information try --help\n</code></pre></div>",
        "id": 199522650,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591117419
    },
    {
        "content": "<p><code>RUSTC_LOG=rustc_mir::transform=debug RUST_BACKTRACE=1 cargo +stage1 rustc -- -Ztreat-err-as-bug |&amp; tee out.log</code></p>",
        "id": 199523082,
        "sender_full_name": "lcnr",
        "timestamp": 1591117609
    },
    {
        "content": "<p>mixed up cargo and <code>x.py</code> arguments</p>",
        "id": 199523111,
        "sender_full_name": "lcnr",
        "timestamp": 1591117623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> </p>\n<div class=\"codehilite\"><pre><span></span><code>$ RUSTC_LOG=rustc_mir::transform=debug RUST_BACKTRACE=1 cargo +stage1 rustc -- -Ztreat-err-as-bug --bin txcell |&amp; tee out.log\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n$ RUSTC_LOG=rustc_mir::transform=debug RUST_BACKTRACE=1 cargo +stage1 rustc --lib libc -- -Ztreat-err-as-bug |&amp; tee out.log\n... same output as before, e.g.\nnote: ...which requires processing `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128`...\n</code></pre></div>\n\n\n<p>As of 2 days ago this should be okay because of <a href=\"https://github.com/rust-lang/rust/commit/8894bd220b82de486f2a8aecec6753c1b416b1f2\">8894bd220b82de486f2a8aecec6753c1b416b1f2</a>, though? I'm on an older version of rustc.</p>",
        "id": 199524995,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591118575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/MIR.20transformations/near/199522498\">said</a>:</p>\n<blockquote>\n<p>I think the problem here is that const evaluated code is also optimized. This however can run during typechecking, which is required to generate MIR for other functions, thus causing a cycle.</p>\n</blockquote>\n<p>Ah, I see; thank you so much for pointing this out. Do you have advice on how to prevent this cycle?</p>",
        "id": 199525237,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591118689
    },
    {
        "content": "<p>Not really, maybe <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>?</p>",
        "id": 199525422,
        "sender_full_name": "bjorn3",
        "timestamp": 1591118764
    },
    {
        "content": "<p>I don't think there's any way you can reasonably call a complex query on all items from another query without running into cycles</p>",
        "id": 199525752,
        "sender_full_name": "oli",
        "timestamp": 1591118933
    },
    {
        "content": "<p>why do you need to run it on all items? Can't you just call it on the item at hand and thus get it cached?</p>",
        "id": 199525978,
        "sender_full_name": "oli",
        "timestamp": 1591119034
    },
    {
        "content": "<p>and call it on all items from somwhere else?</p>",
        "id": 199525999,
        "sender_full_name": "oli",
        "timestamp": 1591119045
    },
    {
        "content": "<p>sorry I haven't read the entire thread here, doing that now</p>",
        "id": 199526030,
        "sender_full_name": "oli",
        "timestamp": 1591119062
    },
    {
        "content": "<p>ah</p>",
        "id": 199526165,
        "sender_full_name": "oli",
        "timestamp": 1591119122
    },
    {
        "content": "<p>you want to use the result of a whole program analysis to optimize specific functions</p>",
        "id": 199526221,
        "sender_full_name": "oli",
        "timestamp": 1591119134
    },
    {
        "content": "<p>uuuuh XD</p>",
        "id": 199526228,
        "sender_full_name": "oli",
        "timestamp": 1591119137
    },
    {
        "content": "<p>I don't think the query system is up for that</p>",
        "id": 199526248,
        "sender_full_name": "oli",
        "timestamp": 1591119152
    },
    {
        "content": "<p>think about it this way: you created a dependency for the optimization of a single function on all other functions in the crate</p>",
        "id": 199526314,
        "sender_full_name": "oli",
        "timestamp": 1591119192
    },
    {
        "content": "<p>but the query system expects only functions to have a dependency on other functions if they (transitively) use it</p>",
        "id": 199526382,
        "sender_full_name": "oli",
        "timestamp": 1591119227
    },
    {
        "content": "<p>so one of these other functions gets type checked. As already noted above, type checking involves array lengths and thus constants</p>",
        "id": 199526459,
        "sender_full_name": "oli",
        "timestamp": 1591119250
    },
    {
        "content": "<p>constants can do a lot of stuff, including: function calls</p>",
        "id": 199526486,
        "sender_full_name": "oli",
        "timestamp": 1591119263
    },
    {
        "content": "<p>so if that constant wants to call your function... kaboom</p>",
        "id": 199526514,
        "sender_full_name": "oli",
        "timestamp": 1591119280
    },
    {
        "content": "<p>Darn, I see. Yeah, that makes sense...</p>",
        "id": 199526542,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591119296
    },
    {
        "content": "<p>now... let's go back to the drawing board and figure out whether you can have your cake and eat it, too</p>",
        "id": 199526585,
        "sender_full_name": "oli",
        "timestamp": 1591119315
    },
    {
        "content": "<p>the query system expects there to be no dependency edge between functions that have nothing to do with each other. so a query processing <code>fn foo() {}</code> and cannot by definition ever call a query that processes <code>fn bar() {}</code>. One super notable exception is <code>type Foo = impl Trait; fn foo() -&gt; Foo {...} fn bar() -&gt; foo {...}</code>.</p>",
        "id": 199526850,
        "sender_full_name": "oli",
        "timestamp": 1591119426
    },
    {
        "content": "<p>I don't remember the exact algorithm there, but it was taken a lot of care that we never create a dependency edge that would get us into trouble</p>",
        "id": 199526912,
        "sender_full_name": "oli",
        "timestamp": 1591119456
    },
    {
        "content": "<p>now... for the actual thing you want to analyze, will <code>fn foo() {}</code>'s MIR ever influence the optimization of <code>fn bar() {}</code>?</p>",
        "id": 199526961,
        "sender_full_name": "oli",
        "timestamp": 1591119478
    },
    {
        "content": "<p>or can you judge whether you need a dependency edge by looking at e.g. the signature of <code>fn foo()</code> while optimizing <code>fn bar()</code>?</p>",
        "id": 199527101,
        "sender_full_name": "oli",
        "timestamp": 1591119537
    },
    {
        "content": "<p>note: I'm on and off rn, no promises I'll respond until tomorrow</p>",
        "id": 199527177,
        "sender_full_name": "oli",
        "timestamp": 1591119583
    },
    {
        "content": "<p>Yes, <code>fn foo() {}</code>'s MIR can influence the optimization of <code>fn bar() {}</code>.</p>",
        "id": 199528867,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591120411
    },
    {
        "content": "<p>Oh wait, let me think about whether the signature is sufficient with some assumptions...</p>",
        "id": 199529006,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591120480
    },
    {
        "content": "<p>if it is, you can make the decision to fetch the more advanced data of the function by first fetching the signature</p>",
        "id": 199585562,
        "sender_full_name": "oli",
        "timestamp": 1591167944
    },
    {
        "content": "<p>if everything fails, you could also do all this work post-\"mir-optimized\" by adding another query \"mir-codegen\" which processes the optimized MIR for codegen and thus has no query edges from earlier steps to it</p>",
        "id": 199585657,
        "sender_full_name": "oli",
        "timestamp": 1591168011
    },
    {
        "content": "<p>Oh wow, the latter seems promising. I'd still be able to transform the MIR or LLVM IR in this query, right? Can you point me to any existing post-<code>tcx.optimized_mir</code> transformations?</p>\n<p>How does this break the cycle? Is it that everything has already been generated, so my query cannot create additional work that requires my query?</p>",
        "id": 199635497,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591198540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/MIR.20transformations/near/199585562\">said</a>:</p>\n<blockquote>\n<p>if it is, you can make the decision to fetch the more advanced data of the function by first fetching the signature</p>\n</blockquote>\n<p>I thought about it more and concluded that the function signature alone is not sufficient.</p>",
        "id": 199636495,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591199018
    },
    {
        "content": "<p>There aren't any post-<code>optimized_mir</code> transformations. You'd have to create all relevant changes for this and in a way that it won't impact the regular compiler negatively if you want to upstream those changes. You could create a query that returns a <code>Cow&lt;'tcx, mir::Body&lt;'tcx&gt;&gt;</code> and ensure that all sites that use it in <code>codegen</code> call that query instead of <code>optimized_mir</code>. Then, when you build your own compiler driver, you can override that query with one that clones all the MIRs that you want to modify, modifies them and returns the modified MIR. The regular compiler would just return a <code>Cow::Borrowed</code> so the additional query would be very cheap (especially since only codegen uses it). If you want to do such a change, I suggest you write an <code>MCP</code> (major change proposal) for the compiler team.</p>",
        "id": 199643032,
        "sender_full_name": "oli",
        "timestamp": 1591201935
    },
    {
        "content": "<p>There may be other/better ways, but I can't think of any off the top of my head</p>",
        "id": 199643095,
        "sender_full_name": "oli",
        "timestamp": 1591201959
    },
    {
        "content": "<p>Only somewhat related, but how big are the perf costs of not using <code>Steal</code> for <code>mir_built</code>?</p>",
        "id": 199643359,
        "sender_full_name": "lcnr",
        "timestamp": 1591202070
    },
    {
        "content": "<p>probably very high</p>",
        "id": 199643431,
        "sender_full_name": "oli",
        "timestamp": 1591202105
    },
    {
        "content": "<p>ok</p>",
        "id": 199643436,
        "sender_full_name": "oli",
        "timestamp": 1591202108
    },
    {
        "content": "<p>hehe</p>",
        "id": 199643439,
        "sender_full_name": "oli",
        "timestamp": 1591202110
    },
    {
        "content": "<p>that's an idea</p>",
        "id": 199643443,
        "sender_full_name": "oli",
        "timestamp": 1591202112
    },
    {
        "content": "<p>you can not modify anything</p>",
        "id": 199643451,
        "sender_full_name": "oli",
        "timestamp": 1591202115
    },
    {
        "content": "<p>but make your driver replace <code>optimized_mir</code> and make it clone <code>mir_validated</code> instead of stealing it</p>",
        "id": 199643491,
        "sender_full_name": "oli",
        "timestamp": 1591202135
    },
    {
        "content": "<p>(and then invoke the original <code>optimized_mir</code>)</p>",
        "id": 199643513,
        "sender_full_name": "oli",
        "timestamp": 1591202148
    },
    {
        "content": "<p>You also have to take into account that that would increase max-rss due to more <code>mir::Body</code> instances being stored.</p>",
        "id": 199643518,
        "sender_full_name": "bjorn3",
        "timestamp": 1591202152
    },
    {
        "content": "<p>I'm assuming all of this is just for research, the compiler will never be able to support such a scheme as far as I can tell</p>",
        "id": 199643667,
        "sender_full_name": "oli",
        "timestamp": 1591202210
    },
    {
        "content": "<p>hmm... at which point, you may just want to change your custom driver to run all <code>optimized_mir</code> queries, <em>then</em> replace the <code>optimized_mir</code> query with your own, which injects your optimization, and only then run codegen</p>",
        "id": 199643894,
        "sender_full_name": "oli",
        "timestamp": 1591202317
    },
    {
        "content": "<p>Then the queries won't run again. They are cached.</p>",
        "id": 199643962,
        "sender_full_name": "bjorn3",
        "timestamp": 1591202353
    },
    {
        "content": "<p>oh right</p>",
        "id": 199643979,
        "sender_full_name": "oli",
        "timestamp": 1591202361
    },
    {
        "content": "<p>yea idk, this optimization goes so much against the query system...</p>",
        "id": 199644009,
        "sender_full_name": "oli",
        "timestamp": 1591202379
    },
    {
        "content": "<p>Also I don't think there is any public api to change the <code>Providers</code> struct after construction of <code>TyCtxt</code>.</p>",
        "id": 199644015,
        "sender_full_name": "bjorn3",
        "timestamp": 1591202382
    },
    {
        "content": "<blockquote>\n<p>create all relevant changes for this and in a way that it won't impact the regular compiler negatively if you want to upstream those changes</p>\n<p>If you want to do such a change, I suggest you write an MCP (major change proposal) for the compiler team.</p>\n<p>the compiler will never be able to support such a scheme as far as I can tell</p>\n</blockquote>\n<p>Yeah, this is just for research, so I'm not planning on upstreaming.</p>",
        "id": 199688734,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591226089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/MIR.20transformations/near/199643491\">said</a>:</p>\n<blockquote>\n<p>but make your driver replace <code>optimized_mir</code> and make it clone <code>mir_validated</code> instead of stealing it</p>\n</blockquote>\n<p>I'd like to do whatever's easiest to get working, so this approach seems most promising <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>To clarify, do you mean removing <code>Steal</code> entirely from <code>mir_built</code>, <code>mir_const</code>, and <code>mir_validated</code> and using <code>clone()</code> instead? Would the return value for each of these queries then be <code>&amp;'tcx mir::Body&lt;'tcx&gt;</code> rather than <code>&amp;'tcx Steal&lt;mir::Body&lt;'tcx&gt;&gt;</code>?</p>",
        "id": 199776159,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591289418
    },
    {
        "content": "<p>no, just keep the steal there</p>",
        "id": 199776696,
        "sender_full_name": "oli",
        "timestamp": 1591289636
    },
    {
        "content": "<p>modify as little as possible</p>",
        "id": 199776701,
        "sender_full_name": "oli",
        "timestamp": 1591289641
    },
    {
        "content": "<p>just remove the <code>.steal()</code> call in <code>optimized_mir</code></p>",
        "id": 199776761,
        "sender_full_name": "oli",
        "timestamp": 1591289652
    },
    {
        "content": "<p>and replace it with <code>.clone()</code> (may need some derefs)</p>",
        "id": 199776789,
        "sender_full_name": "oli",
        "timestamp": 1591289667
    },
    {
        "content": "<p>Hm, but <code>mir_validated</code> returns <code>&amp;'tcx Steal&lt;mir::Body&lt;'tcx&gt;&gt;</code>, so wouldn't the <code>.clone()</code>d value still be wrapped in the <code>Steal</code>? <code>run_optimization_passes</code> requires <code>&amp;mut Body</code> without the <code>Steal</code>.</p>",
        "id": 199777450,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591289955
    },
    {
        "content": "<p><code>(**mir).clone()</code>?</p>",
        "id": 199777544,
        "sender_full_name": "bjorn3",
        "timestamp": 1591289996
    },
    {
        "content": "<p>The specific line is <a href=\"https://github.com/rust-lang/rust/blob/e5335592e78354e33d798d20c04bcd677c1df62d/src/librustc_mir/transform/mod.rs#L401\">here</a>.</p>\n<p>Hm, <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> it says \"type <code>rustc::ty::steal::Steal&lt;rustc::mir::Body&lt;'_&gt;&gt;</code> cannot be dereferenced\".</p>",
        "id": 199777992,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591290162
    },
    {
        "content": "<p><code>(*mir.borrow()).clone()</code></p>\n<p>edit: one <code>*</code> too much</p>",
        "id": 199778118,
        "sender_full_name": "bjorn3",
        "timestamp": 1591290218
    },
    {
        "content": "<p>Trying this out now. <code>(**body.borrow()).clone();</code> says \"type <code>rustc::mir::Body&lt;'_&gt;</code> cannot be dereferenced\", so I'm trying <code>(*body.borrow()).clone();</code>, which I think works.</p>\n<p>Just to clarify, how does this resolve the cycle?</p>",
        "id": 199778604,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591290433
    },
    {
        "content": "<p>Ahaha, yes.</p>",
        "id": 199778627,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591290447
    },
    {
        "content": "<p>Just rebuilt the compiler and still ran into the cycle error -- cloning alone won't solve this, right?</p>",
        "id": 199780721,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591291384
    },
    {
        "content": "<p>Was there a separate recommendation that I missed?</p>",
        "id": 199780735,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591291392
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> could you clarify how you meant cloning instead of stealing would prevent the cycle?</p>",
        "id": 199827590,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591319752
    },
    {
        "content": "<p>You can now access <code>mir_validated</code> from anywhere, without worrying that it's result will disappear. So every single <code>mir_optimized</code> call cann now invoke all other <code>mir_validated</code>. This by itself will not break the cycle you are seeing, but since the only cycle you are seeing is through constants, you can now do an eager check before calling <code>mir_validated</code> on all items, and only do that if the current <code>optimized_mir</code> query's <code>DefId</code> is not a constant</p>",
        "id": 199839665,
        "sender_full_name": "oli",
        "timestamp": 1591338392
    },
    {
        "content": "<p>hmm... this may still invoke <code>const fn</code> cyclically, because the constants can call <code>const fn</code> and we may currently be in a const fn. So I guess you need to exclude <code>const fn</code>, from your optimizations, too</p>",
        "id": 199839748,
        "sender_full_name": "oli",
        "timestamp": 1591338501
    },
    {
        "content": "<p>Ah I see -- using <code>tcx.is_const_fn</code> to check that now</p>",
        "id": 200247426,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591716987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/MIR.20transformations/near/199839748\">said</a>:</p>\n<blockquote>\n<p>hmm... this may still invoke <code>const fn</code> cyclically, because the constants can call <code>const fn</code> and we may currently be in a const fn. So I guess you need to exclude <code>const fn</code>, from your optimizations, too</p>\n</blockquote>\n<p>Hm, I see. Is this what's going on in the following cycle? Now I only call <code>tcx.mir_validated(def_id)</code> if <code>!tcx.is_const_fn(def_id)</code>, but still encounter this cycle.</p>\n<p>Thank you so much for all your help so far! It's really helpful to talk to someone who understands the existing query graph.</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0391]: cycle detected when [ performing my query ]\n    |\nnote: ...which requires processing `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128`...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:5\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...which requires getting validated MIR...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:5\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...which requires getting pre-const evaluation MIR...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:5\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...which requires processing `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128`...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:5\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...which requires processing `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128`...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:5\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...which requires processing `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128`...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:5\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: ...which requires const-evaluating + checking `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128::{{constant}}#0`...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:40\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |                                        ^\nnote: ...which requires const-evaluating + checking `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128::{{constant}}#0`...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:40\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |                                        ^\nnote: ...which requires const-evaluating `x86_64::&lt;impl at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:188:1: 195:2&gt;::new128::{{constant}}#0`...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:40\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |                                        ^\nnote: ...which requires getting optimized MIR...\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:189:40\n    |\n189 |     pub fn new128(xs: [vec128_storage; 4]) -&gt; Self {\n    |                                        ^\n    = note: ...which again requires [ performing my query ], completing the cycle\nnote: cycle used when getting optimized MIR\n   --&gt; /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.6/src/x86_64/mod.rs:111:18\n    |\n111 |     u32x4: [u32; 4],\n    |                  ^\n</code></pre></div>",
        "id": 200253461,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591719203
    },
    {
        "content": "<p>Also is <a href=\"https://doc.rust-lang.org/nightly/unstable-book/language-features/const-fn.html\">this</a> what you mean by <code>const fn</code>? I think it's fine to exclude them from my analysis, then.</p>",
        "id": 200255935,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591720160
    },
    {
        "content": "<p>Oh wait, if <code>tcx.is_const_fn</code> checks for <code>const fn</code>, how do you check if a <code>DefId</code> is a constant otherwise? I think I misunderstood your first message.</p>",
        "id": 200257580,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591720862
    },
    {
        "content": "<p>I've seen <code>Operand::Constant</code> and <code>ty::Const</code>, but not sure what you mean by a <code>DefId</code> being a constant.</p>",
        "id": 200258035,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591721068
    },
    {
        "content": "<p>Oh, I see now that the cycle starts with <code>DefId(0:1545 ~ ppv_lite86[f354]::x86_64[0]::vec128_storage[0]::u32x4[0]::{{constant}}[0])</code>, which has <code>{{constant}}</code> in it...</p>",
        "id": 200260265,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591722128
    },
    {
        "content": "<p>And I see that the <code>{{constant}}</code> comes from <code>AnonConst</code> in <code>DefPathData</code></p>",
        "id": 200260491,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591722252
    },
    {
        "content": "<p>You could match on <code>tcx.def_kind(def_id)</code> and then check for <code>DefKind::Const | DefKind::AssocConst</code>, like here:</p>\n<p><a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_mir/const_eval/eval_queries.rs.html#337\">https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_mir/const_eval/eval_queries.rs.html#337</a></p>",
        "id": 200260832,
        "sender_full_name": "bjorn3",
        "timestamp": 1591722430
    },
    {
        "content": "<p>Ah great, thank you :)</p>",
        "id": 200261855,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591722928
    },
    {
        "content": "<p>Oh, <code>tcx.def_kind</code> of <code>DefId(0:1545 ~ ppv_lite86[f354]::x86_64[0]::vec128_storage[0]::u32x4[0]::{{constant}}[0])</code> is actually <code>None</code>.</p>",
        "id": 200265548,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591724665
    },
    {
        "content": "<p>I'll play around with eager checks using <code>tcx.def_kind</code> to decide when to actually run my query.</p>",
        "id": 200265644,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591724709
    },
    {
        "content": "<p>Eager checking with <code>tcx.def_kind</code> prevents the cycle <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 200272917,
        "sender_full_name": "Claire Nord",
        "timestamp": 1591728268
    },
    {
        "content": "<p>My research project is working now <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span> thank you so much @.oli @.bjorn3 @.lcnr for working with me so patiently!</p>",
        "id": 201170468,
        "sender_full_name": "Claire Nord",
        "timestamp": 1592413366
    }
]