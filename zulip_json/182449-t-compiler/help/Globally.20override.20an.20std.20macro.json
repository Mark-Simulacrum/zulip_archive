[
    {
        "content": "<p>Hi all. We're working on a verification backend for the rust compiler, and we were looking for a way to globally override some of the standard library macros. For instance, if we add a definition for the <code>assert</code> macro in a <code>macro_overrides</code> crate as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[macro_export]</span><span class=\"w\"></span>\n<span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">assert</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$cond</span>:<span class=\"nc\">expr</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Some debug information\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">std</span>::<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"cp\">$cond</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and specify <code>--extern macro_overrides</code> when compiling each crate, is there a way to make every call to <code>assert!</code> in a package use the <code>macro_overrides</code> version of the <code>assert</code> without explicitly adding a <code>use macro_overrides::assert;</code> in every crate?</p>",
        "id": 268790329,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1642734325
    },
    {
        "content": "<p>I can't infer your use case from this, do you want any user to be able to override a macro, or do you just want to change it for all uses of your compiler backend? What is stopping you from shipping your own standard library?</p>",
        "id": 268795552,
        "sender_full_name": "fee1-dead",
        "timestamp": 1642740355
    },
    {
        "content": "<blockquote>\n<p>do you want any user to be able to override a macro, or do you just want to change it for all uses of your compiler backend?</p>\n</blockquote>\n<p>The latter: we want to change it for all uses of our compiler backend without requiring the user to make any modifications to their code.</p>\n<blockquote>\n<p>What is stopping you from shipping your own standard library?</p>\n</blockquote>\n<p>This is an interesting idea. As far as I could see though, the <code>assert</code> macro is not fully defined in the standard library:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"cp\">#[rustc_builtin_macro]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[macro_export]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[rustc_diagnostic_item = </span><span class=\"s\">\"assert_macro\"</span><span class=\"cp\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[allow_internal_unstable(core_panic, edition_panic)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">assert</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"cp\">$cond</span>:<span class=\"nc\">expr</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{{</span><span class=\"w\"> </span><span class=\"cm\">/* compiler built-in */</span><span class=\"w\"> </span><span class=\"p\">}};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"cp\">$cond</span>:<span class=\"nc\">expr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"cp\">$($arg</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{{</span><span class=\"w\"> </span><span class=\"cm\">/* compiler built-in */</span><span class=\"w\"> </span><span class=\"p\">}};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"https://github.com/rust-lang/rust/blob/777bb86bcdbc568be7cff6eeeaaf81a89b4aa50b/library/core/src/macros/mod.rs#L1395\">Source</a><br>\nso it seems that there is some compiler magic done when expanding the macro. I'm not sure what would happen if I modify its definition. I can give that a try.</p>",
        "id": 268800135,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1642745107
    },
    {
        "content": "<p>The <code>#[rustc_builtin_macro]</code> attribute causes code built into rustc to be used for expanding it. If you want to replace the definition of this macro you will have to remove the attribute.</p>",
        "id": 268805131,
        "sender_full_name": "bjorn3",
        "timestamp": 1642750888
    },
    {
        "content": "<p>That is, do:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"gd\">-   #[rustc_builtin_macro]</span>\n    #[macro_export]\n    #[rustc_diagnostic_item = \"assert_macro\"]\n    #[allow_internal_unstable(core_panic, edition_panic)]\n    macro_rules! assert {\n<span class=\"gd\">-       ($cond:expr $(,)?) =&gt; {{ /* compiler built-in */ }};</span>\n<span class=\"gd\">-       ($cond:expr, $($arg:tt)+) =&gt; {{ /* compiler built-in */ }};</span>\n<span class=\"gi\">+       ( $($input:tt)* ) =&gt; ( ::macro_overrides::assert! { $($input)* } );</span>\n    }\n</code></pre></div>",
        "id": 268827845,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642763804
    },
    {
        "content": "<p>(and obviously this requires that your own <code>assert!</code> macro not call back into the stdlib's one!)</p>",
        "id": 268827918,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642763847
    },
    {
        "content": "<p>Got it, thanks!</p>",
        "id": 268871554,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1642784607
    },
    {
        "content": "<p>Another option would be to add a command line option that lets you inject a <code>use</code>, which would be useful for various purposes.</p>",
        "id": 268872760,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642785242
    },
    {
        "content": "<p>I think you can use <code>--extern noprelude:std=/path/to/std-wrapper.rlib</code>. Where std-wrapper re-exports all of libstd except shadowing assert! with your own implementation. Didn't try it, but -Zbuild-std roughly does this I believe.</p>",
        "id": 268873354,
        "sender_full_name": "bjorn3",
        "timestamp": 1642785523
    },
    {
        "content": "<blockquote>\n<p>a command line option that lets you inject a use</p>\n</blockquote>\n<p>Can you clarify how a <code>use</code> can be injected? As far as I understand, by the time compilation gets to the backend, it's too late to add any <code>use</code>.</p>",
        "id": 268894140,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1642794655
    },
    {
        "content": "<blockquote>\n<p>I think you can use --extern noprelude:std=/path/to/std-wrapper.rlib</p>\n</blockquote>\n<p>This sounds like a great solution! Any pointers on how to re-export libstd symbols?</p>",
        "id": 268895430,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1642795007
    },
    {
        "content": "<p><code>pub use std::*;</code> I guess.</p>",
        "id": 268903815,
        "sender_full_name": "bjorn3",
        "timestamp": 1642799488
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429403\">Zyad Hassan</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Globally.20override.20an.20std.20macro/near/268894140\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>a command line option that lets you inject a use</p>\n</blockquote>\n<p>Can you clarify how a <code>use</code> can be injected? As far as I understand, by the time compilation gets to the backend, it's too late to add any <code>use</code>.</p>\n</blockquote>\n<p>You'd need an option in the rustc frontend.</p>",
        "id": 268907163,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642801403
    },
    {
        "content": "<p><code>-C inject-use='mystd as std'</code></p>",
        "id": 268907187,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642801421
    },
    {
        "content": "<p>Or something like that.</p>",
        "id": 268907210,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642801436
    },
    {
        "content": "<p>I'd love to have something like that, for things like:<br>\n<code>-C inject-use='std::arch::asm'</code></p>",
        "id": 268907274,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642801458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Globally.20override.20an.20std.20macro/near/268907163\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"429403\">Zyad Hassan</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Globally.20override.20an.20std.20macro/near/268894140\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>a command line option that lets you inject a use</p>\n</blockquote>\n<p>Can you clarify how a <code>use</code> can be injected? As far as I understand, by the time compilation gets to the backend, it's too late to add any <code>use</code>.</p>\n</blockquote>\n<p>You'd need an option in the rustc frontend.</p>\n</blockquote>\n<p>Ah, I see. Having such an option would be great. We're currently using the <code>rustc_driver</code> crate as is though, so we can't add such an option.</p>",
        "id": 268915242,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1642806166
    },
    {
        "content": "<p>I'm suggesting that such an option would be useful upstream, in rustc itself.</p>",
        "id": 268925104,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642813396
    },
    {
        "content": "<p>You could propose the addition of such an option.</p>",
        "id": 268925109,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642813403
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429403\">@Zyad Hassan</span> Ultimately it'd be a compiler team decision, but libs at least was interested in such an option existing.</p>",
        "id": 268925126,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642813427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429403\">@Zyad Hassan</span> If you proposed something like that, I'd be happy to support it.</p>",
        "id": 268925169,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642813443
    },
    {
        "content": "<p>Cool, yes, I can write a proposal. Is the <a href=\"https://internals.rust-lang.org/\">internals forum</a> the right place to submit a proposal to the compiler team?</p>",
        "id": 268932391,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1642820770
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"429403\">@Zyad Hassan</span> No, you'd want to submit a compiler MCP (\"Major Change Proposal\"). Despite the name, it's also appropriate for smaller changes like this.</p>",
        "id": 268969770,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642874617
    },
    {
        "content": "<p>Also, you may want to make reference to <code>-Z crate-attr</code>.</p>",
        "id": 268969822,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642874663
    },
    {
        "content": "<p>This should be something like <code>-Z inject-use=val</code>, \"inject a <code>use val</code> declaration at the top of every module\".</p>",
        "id": 268969859,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642874743
    },
    {
        "content": "<p>Note that globally injecting a <code>use</code> does not seem like such a good idea in practice:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">assert</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would become:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">your_crate</span>::<span class=\"n\">assert</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- injected</span>\n<span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">assert</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"kc\">true</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and if this were made so the injected <code>use</code> had priority, it would still be problematic <em>w.r.t.</em> eponymous but unrelated macros</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">trait_impls_assertions</span>::<span class=\"n\">assert</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// override this with injection?</span>\n<span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span>: <span class=\"nb\">Copy</span> <span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- problematic for this to become a macro with `core::assert!`'s API</span>\n</code></pre></div>",
        "id": 268978553,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642885435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>  I think if you wanted to override core, you would inject a use <code>as core</code>.</p>",
        "id": 268981260,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642889257
    },
    {
        "content": "<p><code>--extern noprelude:core=...</code> is used by <code>cargo -Zbuild-std</code> to override the host libcore.</p>",
        "id": 269016942,
        "sender_full_name": "bjorn3",
        "timestamp": 1642943504
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/cargo/blob/03e24bcf67696ba35d3aa2b0dd01f97bcfdf91a7/src/cargo/core/compiler/mod.rs#L1171\">https://github.com/rust-lang/cargo/blob/03e24bcf67696ba35d3aa2b0dd01f97bcfdf91a7/src/cargo/core/compiler/mod.rs#L1171</a></p>",
        "id": 269016946,
        "sender_full_name": "bjorn3",
        "timestamp": 1642943516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Globally.20override.20an.20std.20macro/near/268873354\">said</a>:</p>\n<blockquote>\n<p>I think you can use <code>--extern noprelude:std=/path/to/std-wrapper.rlib</code>. Where std-wrapper re-exports all of libstd except shadowing assert! with your own implementation. Didn't try it, but -Zbuild-std roughly does this I believe.</p>\n</blockquote>\n<p>Thanks <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span>! This worked like a charm! For the record, I used:</p>\n<div class=\"codehilite\"><pre><span></span><code>RUSTFLAGS=--crate-type=rlib cargo +nightly build --target x86_64-unknown-linux-gnu\n</code></pre></div>\n<p>for building the std wrapper, and:</p>\n<div class=\"codehilite\"><pre><span></span><code>RUSTFLAGS=&quot;-Z unstable-options --extern noprelude:std=../std-wrapper/target/x86_64-unknown-linux-gnu/debug/deps/libstd_wrapper-4f9d7610b279bf9b.rlib&quot; cargo +nightly run --target x86_64-unknown-linux-gnu\n</code></pre></div>\n<p>for building/running the package. My implementation of the <code>assert!</code> was invoked.</p>",
        "id": 269156183,
        "sender_full_name": "Zyad Hassan",
        "timestamp": 1643051908
    }
]