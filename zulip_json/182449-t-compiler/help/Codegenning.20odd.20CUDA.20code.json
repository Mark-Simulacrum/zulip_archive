[
    {
        "content": "<p>On my journey of compiling rust to cuda kernels, i have stumbled upon some really weird things CUDA/NVCC does. One of these is dynamic shared memory. Basically, you declare an... extern shared variable and then in the kernel invocation you tell it the amount of bytes of shared memory you want. CUDA C++ code:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code><span class=\"n\">__global__</span><span class=\"w\"> </span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"n\">dynamicReverse</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"n\">__shared__</span><span class=\"w\"> </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">[];</span><span class=\"w\">   </span><span class=\"c1\">// this right here</span>\n<span class=\"w\">  </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">threadIdx</span><span class=\"p\">.</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"n\">tr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">__syncthreads</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">d</span><span class=\"p\">[</span><span class=\"n\">t</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">tr</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which then, when put through nvcc, makes an extern decl in the ptx:</p>\n<div class=\"codehilite\"><pre><span></span><code>    // .globl   _Z14dynamicReversePii\n.extern .shared .align 16 .b8 s[];\n</code></pre></div>\n<p>But i am a bit clueless on how i could implement this in a rustc codegen. I don't know if id have to do some manual mir codegen for this or something, because i would need to declare a global every time a certain struct or attribute is created. Maybe i could make a proc macro which the codegen then \"grabs\" invocations to and does its thing? Im honestly not sure how to approach this, so id love to hear any ideas <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 251765120,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1630608050
    },
    {
        "content": "<p>I need to do this for texture objects too, so its not an isolated problem :/</p>",
        "id": 251765239,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1630608104
    },
    {
        "content": "<p>Oh perhaps i could declare a special intrinsic like <code>__nvvm_get_shared_mem_global</code>. Then if the codegen stumbles upon a call to it, instead of generating a call to it, it creates a global then returns a pointer to that global. It seems like a bit of a hack but it should work</p>",
        "id": 251766351,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1630608560
    },
    {
        "content": "<p>i really dislike how cuda does this, because its 100% UB if the caller of the kernel does not match the expected amount of bytes</p>",
        "id": 251766888,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1630608727
    },
    {
        "content": "<p>Another detail is that CUDA does not allow multiple dynamic shared mem declarations, if two shared vars are declared, they will point to the same memory, which will be odd to enforce...</p>",
        "id": 251784149,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1630615765
    },
    {
        "content": "<p>Hello everyone, I have finished learning the rust language, and now I am interested in the rust compiler. I want to join the rust compiler and contribute to rust. How do I learn? Thanks!</p>",
        "id": 254970596,
        "sender_full_name": "kang Lei",
        "timestamp": 1632698302
    }
]