[
    {
        "content": "<p>Currently I'm working on an experiment to add <code>panic::catch_unwind</code> to libcore. To make it compatible with the existing panic runtimes (specifically <code>panic_unwind</code>), I've need to add a new <code>lang_item</code> that gives the runtime a chance to cleanup any state allocated when the panic exception is thrown (one can consider it like an empty catch).</p>\n<p>It was easy enough to add this <code>lang_item</code> and then expose it via a new intrinsic - but my issue is how to make it \"pay for play\", that is the <code>lang_item</code> is only required <em>if</em> <code>panic::catch_unwind</code> is called. Currently I have it \"working\" by relying on <code>catch_unwind</code> being a generic, so the intrinsic is only actually used if <code>catch_unwind</code> is instantiated - but this seems fragile...</p>\n<p>Is there a better way to do this? Or does Rust make any guarantees about uninstantiated code?</p>",
        "id": 259031052,
        "sender_full_name": "Daniel Paoliello",
        "timestamp": 1635202240
    },
    {
        "content": "<p>I don't think catch_unwind belongs to the libcore.</p>",
        "id": 259038778,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635209018
    },
    {
        "content": "<p>It needs to return a boxed error.</p>",
        "id": 259038841,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635209046
    },
    {
        "content": "<p>It might be possible to put it in alloc</p>",
        "id": 259039451,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635209719
    },
    {
        "content": "<p>It's still not useful though; any crate using <code>catch_unwind</code> will need to link to the std anyway.</p>",
        "id": 259043522,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635213979
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Calling.20an.20optional.20lang_item.20without.20requiring.20it/near/259043522\">said</a>:</p>\n<blockquote>\n<p>It's still not useful though; any crate using <code>catch_unwind</code> will need to link to the std anyway.</p>\n</blockquote>\n<p>Why do you say that? The <code>panic_unwind</code> runtime depends on libcore and liballoc: so it is entirely reasonable for someone to want <code>catch_unwind</code> in a <code>no_std</code> environment.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Calling.20an.20optional.20lang_item.20without.20requiring.20it/near/259038841\">said</a>:</p>\n<blockquote>\n<p>It needs to return a boxed error.</p>\n</blockquote>\n<p>If we are keeping the same API shape, then yes. If we wanted to break the dependency on liballoc, then it could return an empty error.</p>",
        "id": 259129079,
        "sender_full_name": "Daniel Paoliello",
        "timestamp": 1635268196
    },
    {
        "content": "<blockquote>\n<p>Why do you say that?</p>\n</blockquote>\n<p>The only way to include the panic runtime is through libstd. The panic runtime is an implementation detail of libstd and may just as well be merged into libstd.</p>",
        "id": 259131859,
        "sender_full_name": "bjorn3",
        "timestamp": 1635269285
    },
    {
        "content": "<blockquote>\n<p>so it is entirely reasonable for someone to want catch_unwind in a no_std environment.</p>\n</blockquote>\n<p>Catching panics requires throwing them in the first place. no_std doesn't allow throwing panics, it requires an aborting panic handler.</p>",
        "id": 259132012,
        "sender_full_name": "bjorn3",
        "timestamp": 1635269355
    },
    {
        "content": "<p>The one case I could think of would be a core + alloc library that needs to be compatible with panics, but doesn't want to add a separate <code>no-std</code> feature and <code>#[cfg]</code>s</p>",
        "id": 259138722,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1635272207
    },
    {
        "content": "<p>such a library could unconditionally call <code>catch_unwind</code>, even though it might be effectively a no-op if the final build artifact is also <code>no_std</code></p>",
        "id": 259138829,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1635272257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Calling.20an.20optional.20lang_item.20without.20requiring.20it/near/259132012\">said</a>:</p>\n<blockquote>\n<p>Catching panics requires throwing them in the first place. no_std doesn't allow throwing panics, it requires an aborting panic handler.</p>\n</blockquote>\n<p>What prevents a throwing panic in no_std (other than the lack of a prebuilt no_std panic runtime)? Could someone build their own throwing panic for whatever no_std environment they are working in?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Calling.20an.20optional.20lang_item.20without.20requiring.20it/near/259131859\">said</a>:</p>\n<blockquote>\n<p>The only way to include the panic runtime is through libstd.</p>\n</blockquote>\n<p>Currently, yes, but if there is nothing that fundamentally prevents a throwing panic in no_std then one could imagine completely splitting the panic runtimes out of libstd and allowing them in a libcore+liballoc environment (just as one can pull in liballoc without all of libstd).</p>",
        "id": 259142310,
        "sender_full_name": "Daniel Paoliello",
        "timestamp": 1635273751
    },
    {
        "content": "<p>We don't guarantee any particular unwinding mechanism, so no you can't write your own throwing panic on stable.</p>",
        "id": 259156241,
        "sender_full_name": "bjorn3",
        "timestamp": 1635280009
    },
    {
        "content": "<p>The only <code>catch_unwind</code> implementation that makes sense in <code>#![no_std]</code> is one that unconditionally drops the error; even that would require delegating the cleanup work to the panic runtime.</p>",
        "id": 259163571,
        "sender_full_name": "Gary Guo",
        "timestamp": 1635283422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> I agree that this may not be possible on stable, but if you are using no_std you quickly end up needing unstable features anyway. Also, just to prove out that panic unwind (and, therefore, <code>catch_unwind</code>) are usable in a libcore+liballoc environment, here is a prototype that demonstrates it: <a href=\"https://github.com/dpaoliello/catch_unwind_in_no_std\">https://github.com/dpaoliello/catch_unwind_in_no_std</a></p>",
        "id": 259424276,
        "sender_full_name": "Daniel Paoliello",
        "timestamp": 1635442271
    },
    {
        "content": "<p>Makes me wonder if there should be a <code>core::panic::catch_unwind</code> in the <code>panic_unwind</code> crate (since it has access to <code>Box</code>, thus the function signature can be the same)</p>",
        "id": 259424376,
        "sender_full_name": "Daniel Paoliello",
        "timestamp": 1635442322
    }
]