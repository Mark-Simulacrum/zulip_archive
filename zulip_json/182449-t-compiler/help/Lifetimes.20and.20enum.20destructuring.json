[
    {
        "content": "<p>hi everyone! I'm a little bit surprised about the behavior of the compiler in the following code snippet. I'd like to understand a little bit better why I'm seeing this. the following code snippet:</p>\n<div class=\"codehilite\"><pre><span></span><code>struct DataStructure {\n    inner: u16,\n    flag: bool,\n}\n\nimpl DataStructure {\n    fn new(inner: u16) -&gt; Self {\n        DataStructure {\n            inner,\n            flag: false,\n        }\n    }\n\n    fn res(&amp;mut self, error: bool) -&gt; Result&lt;&amp;mut u16, String&gt; {\n        fn res_inner(s: &amp;mut DataStructure, error: bool) -&gt; Result&lt;&amp;mut u16, String&gt; {\n            if error {\n                Err(&quot;Returned error&quot;.to_string())\n            } else {\n                Ok(&amp;mut s.inner)\n            }\n        }\n\n        match res_inner(self, error) {\n            Ok(r) =&gt; Ok(r),\n            Err(e) =&gt; {\n                self.flag = true;\n                Err(e)\n            }\n        }\n    }\n}\n</code></pre></div>\n<p>fails with the error:</p>\n<div class=\"codehilite\"><pre><span></span><code>   Compiling playground v0.0.1 (/playground)\nerror[E0506]: cannot assign to `self.flag` because it is borrowed\n  --&gt; src/lib.rs:26:17\n   |\n14 |     fn res(&amp;mut self, error: bool) -&gt; Result&lt;&amp;mut u16, String&gt; {\n   |            - let&#39;s call the lifetime of this reference `&#39;1`\n...\n23 |         match res_inner(self, error) {\n   |                         ---- borrow of `self.flag` occurs here\n24 |             Ok(r) =&gt; Ok(r),\n   |                      ----- returning this value requires that `*self` is borrowed for `&#39;1`\n25 |             Err(e) =&gt; {\n26 |                 self.flag = true;\n   |                 ^^^^^^^^^^^^^^^^ assignment to borrowed `self.flag` occurs here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0506`.\nerror: could not compile `playground`\n\nTo learn more, run the command again with --verbose.\n</code></pre></div>\n<p>the reason that this is surprising to me is that the lifetime is only specified in the <code>Ok</code> variant, not the <code>Err</code> variant. Rust does not seem to be able to determine that the borrow is no longer active by matching on the <code>Err</code> variant most likely due to the wrapped method.</p>\n<p>this example is definitely contrived but it is the same pattern that I need to apply for some autogenerated code that is failing to compile when the return type is a reference borrowed from <code>self</code>. is there a way around this? I've even tried destructuring the <code>Err</code> type and returning early on the <code>Ok</code> variant to try to make the compiler understand that this borrow is not active in the <code>Err</code> code path, but even that doesn't seem to work.</p>",
        "id": 244281588,
        "sender_full_name": "John Baublitz",
        "timestamp": 1624973881
    },
    {
        "content": "<p>I believe polonius will fix this when/if it lands.</p>",
        "id": 244295018,
        "sender_full_name": "bjorn3",
        "timestamp": 1624978695
    },
    {
        "content": "<p>I thought that had already landed. was there a separate restructuring of the borrow checker that has already made it in?</p>",
        "id": 244298175,
        "sender_full_name": "John Baublitz",
        "timestamp": 1624979711
    },
    {
        "content": "<p>(I'm referring to this blog post: <a href=\"https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html\">https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html</a>)</p>",
        "id": 244298475,
        "sender_full_name": "John Baublitz",
        "timestamp": 1624979823
    },
    {
        "content": "<p>There is the old ast borrowck, the current mir borrowck (this is what that post is about) and polonius, which is a reformulation of the borrow checking logic in datalog: <a href=\"https://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/\">https://smallcultfollowing.com/babysteps/blog/2018/04/27/an-alias-based-formulation-of-the-borrow-checker/</a></p>",
        "id": 244298786,
        "sender_full_name": "bjorn3",
        "timestamp": 1624979954
    },
    {
        "content": "<p>Note that the nll borrowchecker at one point was location sensitive as necessary to accept this code, but it was made location insensitive due to performance issues. Polonius can elegantly represent both options using only like <del>50</del> 200 extra lines of code.</p>",
        "id": 244299257,
        "sender_full_name": "bjorn3",
        "timestamp": 1624980117
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/polonius/blob/master/polonius-engine/src/output/location_insensitive.rs\">https://github.com/rust-lang/polonius/blob/master/polonius-engine/src/output/location_insensitive.rs</a> and <a href=\"https://github.com/rust-lang/polonius/blob/master/polonius-engine/src/output/datafrog_opt.rs\">https://github.com/rust-lang/polonius/blob/master/polonius-engine/src/output/datafrog_opt.rs</a></p>",
        "id": 244299521,
        "sender_full_name": "bjorn3",
        "timestamp": 1624980198
    },
    {
        "content": "<p>okay! I didn't realize that that blog post was about mir instead of polonius. I saw a talk on polonius so I was under the impression that they were the same.</p>",
        "id": 244300987,
        "sender_full_name": "John Baublitz",
        "timestamp": 1624980757
    }
]