[
    {
        "content": "<p>compiler/rustc_driver is built as a dylib: <a href=\"https://github.com/rust-lang/rust/blob/181e91567c9f347e055b33b1d7e9894f769aafe3/compiler/rustc_driver/Cargo.toml#L7\">https://github.com/rust-lang/rust/blob/181e91567c9f347e055b33b1d7e9894f769aafe3/compiler/rustc_driver/Cargo.toml#L7</a></p>\n<p>is there any option to build and link it statically? if not, how difficult would a patch be to make it static? I'm not sure how deep the assumption that it's a dylib is (e.g. do any other crates 'dlopen' it)</p>\n<p>side question: how many crates use rustc_driver? what I've found so far: rustc (obviously), clippy, librustdoc. plus lots of tests</p>",
        "id": 268736296,
        "sender_full_name": "Collin Baker",
        "timestamp": 1642703254
    },
    {
        "content": "<blockquote>\n<p>is there any option to build and link it statically?</p>\n</blockquote>\n<p>no</p>\n<blockquote>\n<p>if not, how difficult would a patch be to make it static?</p>\n</blockquote>\n<p>Just remove that line.</p>\n<blockquote>\n<p>e.g. do any other crates 'dlopen' it</p>\n</blockquote>\n<p>It is compiled with the initial-exec tls model which doesn't allow <code>dlopen</code>. (it may work, but this is not guaranteed and shouldn't be relied upon)</p>\n<blockquote>\n<p>I'm not sure how deep the assumption that it's a dylib is</p>\n</blockquote>\n<p>Rustc plugins require it, but they are deprecated and have been gutted almost completely. Only adding a lint from a rustc plugin is still possible as servo depends on this. Custom codegen backends also need rustc_driver to be a dylib. Currently only the llvm backend, which is linked into rustc_driver, is stable, but in the future other codegen backends may be dlopen'ed at runtime in which case they need rustc_driver. There are currently four such codegen backends that I am aware of: cg_clif (created by me, focus on low compile time), cg_gcc (by antoyo, focus on portability across architectures using gcc), cg_spirv (part of rust-gpu, by embark studios, compiles rust code to run on gpu's as shader using vulkan), cg_nvvm (by <br>\nRDambrosio016, compiles rust code to run on nvidia gpu's using cuda) Of these the first two (cg_clif and cg_gcc) can be built as part of rustc by changing <code>config.toml</code>.</p>",
        "id": 268738348,
        "sender_full_name": "bjorn3",
        "timestamp": 1642704068
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465034\">@Collin Baker</span> Why do you exactly want to statically link it by the way?</p>",
        "id": 268738587,
        "sender_full_name": "bjorn3",
        "timestamp": 1642704169
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/link.20compiler.2Frustc_driver.20statically/near/268738587\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465034\">Collin Baker</span> Why do you exactly want to statically link it by the way?</p>\n</blockquote>\n<p>I'm trying to add rust to my project's existing clang/llvm toolchain. we already statically link everything into our clang tools, and prefer sticking to that for rust too</p>",
        "id": 268743370,
        "sender_full_name": "Collin Baker",
        "timestamp": 1642706274
    },
    {
        "content": "<p>we also build llvm without PIC, so we'd need to modify how we build llvm to support the normal rust build</p>",
        "id": 268743446,
        "sender_full_name": "Collin Baker",
        "timestamp": 1642706296
    },
    {
        "content": "<p>I suppose there's a bit of an XY problem here but I'm exploring both options: tweaking our llvm build, or tweaking our future rust build</p>",
        "id": 268743505,
        "sender_full_name": "Collin Baker",
        "timestamp": 1642706329
    }
]