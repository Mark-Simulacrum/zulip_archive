[
    {
        "content": "<p>If a proc macro attaches an input span to the tokens it produces, should that span still be in the root context?</p>",
        "id": 248648961,
        "sender_full_name": "tmandry",
        "timestamp": 1628274131
    },
    {
        "content": "<p>let's assume there are no nested invocations</p>",
        "id": 248648993,
        "sender_full_name": "tmandry",
        "timestamp": 1628274140
    },
    {
        "content": "<p>If the macro copies the span from some input token, then yes, it will have the root context.</p>",
        "id": 248667634,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1628283491
    },
    {
        "content": "<p>I guess there's not an easy way to check if the span has \"gone through\" a proc macro then?</p>",
        "id": 248676763,
        "sender_full_name": "tmandry",
        "timestamp": 1628289607
    },
    {
        "content": "<p>we check for root context-ness when producing some diagnostic suggestions at the module item level, which leads to <a href=\"https://github.com/rust-lang/rust/issues/87613\">#87613</a></p>",
        "id": 248676840,
        "sender_full_name": "tmandry",
        "timestamp": 1628289679
    },
    {
        "content": "<p>hmm, but the whole <em>item</em> span is in the root context, how does that work?</p>",
        "id": 248677639,
        "sender_full_name": "tmandry",
        "timestamp": 1628290381
    },
    {
        "content": "<p>(the item is the <code>fn main()</code> in this case)</p>",
        "id": 248677776,
        "sender_full_name": "tmandry",
        "timestamp": 1628290520
    },
    {
        "content": "<p>the fully expanded function definitely contains code that is generated by the proc macro, but for diagnostics purposes we usually want to consider the function to be defined in the root context</p>",
        "id": 248677865,
        "sender_full_name": "tmandry",
        "timestamp": 1628290583
    },
    {
        "content": "<p>There are two posibilities:<br>\n1) Tokio modifies the <code>SyntaxContext</code> (via <code>Span::located_at</code>) of the code it generates, so that all of the emitted code has the root context.<br>\n2) The emitted token stream has a mixture of spans - when rust tries to join the spans during parsing, it ends up throwing away the non-root <code>SyntaxContext</code>, using the root syntax context for the overall span</p>",
        "id": 248677875,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1628290594
    },
    {
        "content": "<p>I suspect that it's the second one</p>",
        "id": 248677895,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1628290608
    },
    {
        "content": "<p>Proc-macros are powerfull enough that any diagnostic / suggestion that we right can be 'broken' in some way by a proc macro</p>",
        "id": 248678128,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1628290774
    },
    {
        "content": "<p>To get nice error messages, a proc macro needs to 'cooperate' in some way (at a minimum, not give crazy root-context spans to everything)</p>",
        "id": 248678181,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1628290804
    }
]