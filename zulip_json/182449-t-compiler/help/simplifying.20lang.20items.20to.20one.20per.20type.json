[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> Continuing from the thread on <a class=\"stream\" data-stream-id=\"213817\" href=\"/#narrow/stream/213817-t-lang\">#t-lang</a>: if someone wanted to work on that idea of having just one lang item per type rather than one per impl block, what might they be likely to run into in trying to do that? (Ignoring the coherence issue of the std/alloc/core split for the moment.)</p>",
        "id": 272043905,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962205
    },
    {
        "content": "<p>Lang items are name -&gt; Option&lt;DefId&gt; at the moment, so you can't have duplicate definitions.</p>",
        "id": 272044126,
        "sender_full_name": "bjorn3",
        "timestamp": 1644962315
    },
    {
        "content": "<p>I think I'm more generally talking about a rework where \"types are special, impl blocks are not\".</p>",
        "id": 272044168,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962350
    },
    {
        "content": "<p>It could get attached to a different attribute temporarily, if needed.</p>",
        "id": 272044179,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962361
    },
    {
        "content": "<p>Not sure.</p>",
        "id": 272044225,
        "sender_full_name": "bjorn3",
        "timestamp": 1644962396
    },
    {
        "content": "<p>For instance:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[lang = </span><span class=\"s\">\"u32\"</span><span class=\"cp\">]</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">more</span><span class=\"w\"> </span><span class=\"n\">functions</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272044296,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962408
    },
    {
        "content": "<p>If u32 is considered as defined in that crate it may just work.</p>",
        "id": 272044440,
        "sender_full_name": "bjorn3",
        "timestamp": 1644962469
    },
    {
        "content": "<p>Might be worth a try, at least for things that <em>don't</em> have the coherence problem across core/alloc/std. Thanks, that helps!</p>",
        "id": 272044666,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644962575
    },
    {
        "content": "<p>I suspect the lack of a <code>= ...</code> on the type definition is going to be a bit awkward -- it may be easier to define with <code>struct u32;</code> or similar, though even that may cause some lints etc trouble if they're not reading the lang item appropriately</p>",
        "id": 272068592,
        "sender_full_name": "simulacrum",
        "timestamp": 1644980773
    },
    {
        "content": "<p>it seems a little tricky and I'm not sure how much value it buys, necessarily</p>",
        "id": 272068596,
        "sender_full_name": "simulacrum",
        "timestamp": 1644980793
    },
    {
        "content": "<p>I might rather suggest special casing core/std/alloc with <code>#![iamcore]</code> or something and letting those crates define inherent impls without lang items, perhaps.</p>",
        "id": 272068614,
        "sender_full_name": "simulacrum",
        "timestamp": 1644980823
    },
    {
        "content": "<p>I think long-term there's a general desire to merge the crates into one. But short-term that seems plausible.</p>",
        "id": 272069131,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1644981452
    },
    {
        "content": "<p>I think there might be a place for a separation for reusability, actually.  It might turn out, for example, that re-using <code>std</code> across implementations is completely reasonable but re-using <code>core</code> isn't.  But of course it's likely that \"exactly three crates\" isn't the perfect split either.</p>",
        "id": 272071700,
        "sender_full_name": "scottmcm",
        "timestamp": 1644984765
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/simplifying.20lang.20items.20to.20one.20per.20type/near/272068592\">said</a>:</p>\n<blockquote>\n<p>I suspect the lack of a <code>= ...</code> on the type definition is going to be a bit awkward -- it may be easier to define with <code>struct u32;</code> or similar, though even that may cause some lints etc trouble if they're not reading the lang item appropriately</p>\n</blockquote>\n<p>The exact syntax of the definition doesn't seem important, only that it has something marking it as a lang item and has the type name.</p>",
        "id": 272072092,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644985329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/simplifying.20lang.20items.20to.20one.20per.20type/near/272068614\">said</a>:</p>\n<blockquote>\n<p>I might rather suggest special casing core/std/alloc with <code>#![iamcore]</code> or something and letting those crates define inherent impls without lang items, perhaps.</p>\n</blockquote>\n<p>adding inherent impls doesn't cause coherence issues and unsoundness, so i've been considering that solution for quite a while myself. Never got around to implementing it though <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> this seems like the prefered solution for me here</p>",
        "id": 272085363,
        "sender_full_name": "lcnr",
        "timestamp": 1644999822
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/simplifying.20lang.20items.20to.20one.20per.20type/near/272068592\">said</a>:</p>\n<blockquote>\n<p>I suspect the lack of a <code>= ...</code> on the type definition is going to be a bit awkward -- it may be easier to define with <code>struct u32;</code> or similar, though even that may cause some lints etc trouble if they're not reading the lang item appropriately</p>\n</blockquote>\n<p>It could also be <code>extern type u32;</code>, since this actually is an extern type in some sense</p>",
        "id": 272085769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645000097
    },
    {
        "content": "<p><code>extern \"C\" { type u32; }</code> would result in an unsized type.</p>",
        "id": 272093522,
        "sender_full_name": "bjorn3",
        "timestamp": 1645004985
    },
    {
        "content": "<p>Only if compiler magic didn't intercede. The idea is that the <code>#[lang]</code> attribute will make it act like a rust builtin type instead of an extern C type. Plus that could also be <code>extern \"Rust\"</code> or something else with specific semantics</p>",
        "id": 272095716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645006173
    },
    {
        "content": "<p>\"extern\" here is to be read as \"not defined in rust code\", not \"unknown to the rust compiler\"</p>",
        "id": 272095822,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645006220
    },
    {
        "content": "<p>the main pragmatic advantage is that it works with the existing rust grammar, and it is a little closer to the truth than a magic attribute on <code>struct u32;</code></p>",
        "id": 272096095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645006360
    },
    {
        "content": "<p>Considering that we implement <code>Add</code> for integers via the <code>+</code> operation on said integers, we could also do <code>struct u32(u32);</code>. Same recursion, but avoided because the language gives it special meaning</p>",
        "id": 272100559,
        "sender_full_name": "oli",
        "timestamp": 1645009019
    },
    {
        "content": "<p>Actually the <code>Add</code> impls are not recursive. If you write <code>Add::add(a, b)</code> or <code>+</code> in a generic context it will call the <code>add</code> method. If you write <code>+</code> in a non-generic context it will lower to an <code>Add</code> MIR operation. So if you were to implement <code>Add</code> as <code>-</code> on an integer, doing <code>a + b</code> in a non-generic context will do addition, but <code>Add::add(a, b)</code> will do substraction.</p>",
        "id": 272101029,
        "sender_full_name": "bjorn3",
        "timestamp": 1645009289
    }
]