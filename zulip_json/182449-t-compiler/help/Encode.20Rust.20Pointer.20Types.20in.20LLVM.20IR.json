[
    {
        "content": "<p>In some cases there isn't even a rust type in the first place. For example for vtable pointers. Function pointers also sometimes need to be pointer casted. What exactly do you need the rust type for?</p>",
        "id": 266688810,
        "sender_full_name": "bjorn3",
        "timestamp": 1641218541
    },
    {
        "content": "<p>I'm experimenting with an LLVM pass for memory-safety. I want to implement a mechanism to elide safety-checks for pointers whose validity is already handled by Rust</p>",
        "id": 266689428,
        "sender_full_name": "Oliver Braunsdorf",
        "timestamp": 1641218916
    },
    {
        "content": "<p>Hey Rustaceans,<br>\nI'm still seeking help here. Does anybody have some advice on which location in rustc's codegen I should implement emitting LLVM metadata nodes for instructions with pointer operands?</p>\n<p>To me it seems like the calls to the <code>BuilderMethods</code> Trait are scattered over a lot of code parts (<a href=\"http://place.rs\">place.rs</a>, <a href=\"http://rvalue.rs\">rvalue.rs</a>, <a href=\"http://operand.rs\">operand.rs</a> within rustc_codgen_ssa/mir) and I have trouble finding the right location for getting startet.<br>\nCould someone please give me a hint?</p>",
        "id": 267801133,
        "sender_full_name": "Oliver Braunsdorf",
        "timestamp": 1642029455
    },
    {
        "content": "<p>I think you may want the <code>impl BuilderMethods</code> in <code>compiler/rustc_codegen_llvm/src/builder.rs</code></p>",
        "id": 267808237,
        "sender_full_name": "cuviper",
        "timestamp": 1642033631
    },
    {
        "content": "<p>or is that already too deep for the type info you want?</p>",
        "id": 267808337,
        "sender_full_name": "cuviper",
        "timestamp": 1642033694
    },
    {
        "content": "<p>yes, unfortunately that is too deep because most of the functions there take \"Self::Value\" (=reference to an LLVM value) as an argument. I think that it's not possible to get the type info at this point.</p>",
        "id": 267808886,
        "sender_full_name": "Oliver Braunsdorf",
        "timestamp": 1642034097
    },
    {
        "content": "<p>And one level above: it seems like the BuilderMethods' functions like <code>load()</code>or <code>store()</code> are getting called from multiple locations in <code>rustc_codegen_ssa</code>....which makes it hard to get full coverage of all call sites</p>",
        "id": 267809295,
        "sender_full_name": "Oliver Braunsdorf",
        "timestamp": 1642034413
    },
    {
        "content": "<p>can you do it where the LLVM types are constructed? like <code>LayoutTypeMethods</code>, where <code>TyAndLayout</code> has the inner <code>Ty</code></p>",
        "id": 267810279,
        "sender_full_name": "cuviper",
        "timestamp": 1642035325
    },
    {
        "content": "<p>mhh..it seems like this location isn't suited either.<br>\nI think what I am looking for is a location where have an <code>rustc::codegen_llvm::Value</code> and access to the type of the MIR value it is representing. Do you know if there is some kind of map, that i could draw this information from?<br>\nSome mapping between <code>Value</code>s and  <code>PlaceRef</code>s or <code>OperandRef</code>s ?</p>",
        "id": 267812345,
        "sender_full_name": "Oliver Braunsdorf",
        "timestamp": 1642037126
    }
]