[
    {
        "content": "<p>We could add horrible hacks that allow implicit conversion from and to a special <code>struct c_char(i8);</code> and warn the user whenever they aren't using the newtype.</p>",
        "id": 276745385,
        "sender_full_name": "oli",
        "timestamp": 1648328258
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"295814\">Ramon de C Valle</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi/near/276743574\">said</a>:</p>\n<blockquote>\n<p>The reason I'm exploring this encoding is because it'll provide a much more comprehensive protection than the alternative encoding.</p>\n</blockquote>\n<p>Could you elaborate on why CFI cares about the difference?  I skimmed a couple links in that tracking issue, but I didn't see anything that made it obvious.</p>\n<p>Similarly, do you need to distinguish between <code>c_long</code> and <code>c_long_long</code> when those both happen to be <code>i64</code>?</p>",
        "id": 276745607,
        "sender_full_name": "scottmcm",
        "timestamp": 1648328496
    },
    {
        "content": "<p>It's related to the unresolved question at <a href=\"https://github.com/rust-lang/rust/issues/89653\">https://github.com/rust-lang/rust/issues/89653</a>. I'll try to summarize it here, but I'll have it described in detail in the design doc:</p>\n<p>I'm exploring two options, option (A) and (C). For option (A),  I'm using the Itanium C++ ABI with vendor extended type qualifiers and types for Rust types that are not used at the FFI boundary. For option (B), I'm working with clang/CFI team on a new encoding for cross-language CFI, but because of the requirements of this new encoding (i.e., be language agnostic and ideally compatible with any other language), it provides a less comprehensive protection than option (A) [e.g., neither distinguishes between certain types (e.g., c_char/char, bool, enum, and integers) nor discriminates between pointed element types (the latter mainly because of C’s void * abuse)].</p>\n<p>Ideally, I want option (A) to be the main encoding both for Rust-compiled only code and when interoperating with foreign code written in C, and option (C) to be an alternative for interoperating with foreign code written in languages other than C (in the future).</p>",
        "id": 276745963,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648329001
    },
    {
        "content": "<p>I believe it is not uncommon to use u8/i8 directly on the rust side when the C side uses char. For example when using <code>#[start]</code> to directly define the <code>main</code> function called by libc rustc mandates <code>*const *const i8</code> as argv type and not <code>*const *const c_char</code>.</p>",
        "id": 276747133,
        "sender_full_name": "bjorn3",
        "timestamp": 1648330567
    },
    {
        "content": "<p>For c_long and c_long_long, they’re aliased to their respective ty::Ty and encoded correctly to their respective type encoding in the Itanium C++ ABI. For c_char/char it has its own type encoding in the Itanium C++ ABI other than signed and unsigned char that needs to be discriminated (i.e., ‘c’ vs ‘a’ and ‘h’).</p>",
        "id": 276747140,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648330585
    },
    {
        "content": "<p>So for CFI purposes, when using option (A), char, signed char, and unsigned char, discriminates between valid destinations/functions on clang side, and the same would need to be done on Rust side.</p>",
        "id": 276747509,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648331162
    },
    {
        "content": "<p>Hmm, actually, if all you have is an <code>Abi</code> you might not be able to tell even with a newtype -- I think it'd have to be <code>#[repr(transparent)] struct c_short(i16);</code> to be ABI-compatible in <code>extern \"C\"</code>, and thus down at the ABI level the difference might also not exist, even though it does in the function's type.</p>",
        "id": 276747803,
        "sender_full_name": "scottmcm",
        "timestamp": 1648331580
    },
    {
        "content": "<p>I was able to identify c_void by its name and crate name. Since struct c_char(i8) would be an ty::Adt, couldn’t I do the same?</p>",
        "id": 276747985,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648331816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Distinguish.20between.20c_char.20and.20an.20i8.20uses.20in.20an.20FnAbi/near/276745385\">said</a>:</p>\n<blockquote>\n<p>We could add horrible hacks that allow implicit conversion from and to a special <code>struct c_char(i8);</code> and warn the user whenever they aren't using the newtype.</p>\n</blockquote>\n<p>How would it work? Do you have an example? I'm trying to be as unobtrusive as possible, but if this can be done only for when CFI is enabled, I think it's a good cost vs benefit.</p>",
        "id": 276754075,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648340331
    },
    {
        "content": "<p>Is CFI just a backend thing or more like a target/platform? If it's a target or platform, in theory we could cfg the type alias into a newtype. Adding the inference infrastructure is a bit of weirdness in the compiler, but with the libs team on board I think it would be a reasonable amount of work and very well contained</p>",
        "id": 276778284,
        "sender_full_name": "oli",
        "timestamp": 1648373165
    },
    {
        "content": "<p>It's a combination of codegen, metadata, and a LLVM pass: <a href=\"https://github.com/rust-lang/rust/pull/89652\">https://github.com/rust-lang/rust/pull/89652</a>. I'll msg you to get more details about it and see if it's something I can do.</p>",
        "id": 276915113,
        "sender_full_name": "Ramon de C Valle",
        "timestamp": 1648492938
    }
]