[
    {
        "content": "<p>Hi All, I've been trying my best to understand this <a href=\"https://github.com/rust-lang/rust/issues/89275\">issue</a> for a couple of days now and I think I'm getting to the point where I believe that the compiler is doing its job correctly but seems to be trying to run through all the trait impl in scope to figure out what type Foo.downcast() is. </p>\n<p>Am I on the right track or is the compiler doing something else I'm not aware of (I'm mostly using logs/source code however it seems to be doing this inferral via the cannonical trait system which I am struggling to follow)?</p>",
        "id": 255771083,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633105748
    },
    {
        "content": "<p>It doesn't look like this is a method resolution issue, the following has the same bug:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">num_traits</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Ratio</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">pow</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Pow</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Ratio</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">Pow</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">pow</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">unimplemented!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">downcast</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">W</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">W</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">todo!</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Other</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Other</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">downcast</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'll try to work out when the compiler is actually doing the check that overflows</p>",
        "id": 255775786,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1633107743
    },
    {
        "content": "<p>Cool thanks, I don't think it's method resolution myself but it seems to be recursing through every trait trying to fulfil some kind of obligation for the &amp;_ type then it hits the &lt;num_traits::Pow::pow&gt;  trait and seems try to compare &amp;_ against &lt;_as num_traits::Pow:pow&gt; which ends up resolving into a Ratio&lt;T&gt; as num_traits::Pow:pow &amp; recursing from there</p>",
        "id": 255781562,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633110213
    },
    {
        "content": "<p>It only happens when you have an implementation of Pow on Ratio&lt;T&gt; so I expect it's a circular implementation when it's ambiguous what type you want and that check seems to happen before the mutability check so it errors on the trait</p>",
        "id": 255781761,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633110311
    },
    {
        "content": "<p>It's error reporting that's trying to check every method in scope though.</p>",
        "id": 255782303,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1633110559
    },
    {
        "content": "<p>Ahh right I hadn't got that from my poking around, how were you able to see that error reporting was causing it?</p>",
        "id": 255782890,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633110812
    },
    {
        "content": "<p>You can look for callers of <code>prove_op</code> with <code>None</code> as the <code>method_name</code> and follow that back to <code>suggest_deref_ref_or_into</code>.</p>",
        "id": 255783402,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1633111014
    },
    {
        "content": "<p>I assume you're doing that through some kind of tracing of the compiler too?</p>",
        "id": 255784072,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633111275
    },
    {
        "content": "<p>To find call sites I'm looking at the code (using Rust Analyzer to search for usages). To know that <code>probe_op</code> is the function I should be looking at is from previous experience with this part of the compiler, the tracing output would show this too though.</p>",
        "id": 255784618,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1633111494
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/86506\">#86506</a> might be worth looking at here.</p>",
        "id": 255784652,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1633111510
    },
    {
        "content": "<p>although it's not intended for the same issue.</p>",
        "id": 255784725,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1633111546
    },
    {
        "content": "<p>Cool okay I'll do a bit more looking around then thanks for the pointers!</p>",
        "id": 255788631,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633113236
    }
]