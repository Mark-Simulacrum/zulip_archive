[
    {
        "content": "<p>I'm implementing my own programming language as a toy project using LLVM to get familiar with it. I can produce object files <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span>!<br>\nBut now I'd like to produce executable binaries, and I realised LLVM does not know anything about \"entry points\" (which makes sense to me). My first \"hack\" (not really?) was to write a small \"runtime\" in assembly that I link with my object files, and it works! However I don't think that's how real-world compilers/linkers like <code>rustc</code> do things.</p>\n<p>Where and how does <code>rustc</code> add the entry point of the program being compiled (e.g. <code>_start</code> on Linux) before calling the linker?</p>",
        "id": 272835037,
        "sender_full_name": "nasso",
        "timestamp": 1645549865
    },
    {
        "content": "<p>that's <code>cc</code>'s job AFAIK, and <code>rustc</code> will emit a C-typical unmangled <code>main</code> that leads to <code>std::rt</code> startup code</p>",
        "id": 272835352,
        "sender_full_name": "cuviper",
        "timestamp": 1645549992
    },
    {
        "content": "<p>ah so <code>rustc</code> actually calls <code>cc</code> and not just <code>ld</code>?</p>",
        "id": 272835635,
        "sender_full_name": "nasso",
        "timestamp": 1645550101
    },
    {
        "content": "<p>normally, yes. you can also use <code>lld</code> directly, and maybe others, but then I think <code>rustc</code> adds normal <code>crt*.o</code> objects itself to get <code>_start</code> etc.</p>",
        "id": 272835870,
        "sender_full_name": "cuviper",
        "timestamp": 1645550178
    },
    {
        "content": "<p>am i correct in assuming the resulting binary then depends on <code>libc</code> (or anything extra <code>cc</code> might specify to the linker)?</p>",
        "id": 272836516,
        "sender_full_name": "nasso",
        "timestamp": 1645550413
    },
    {
        "content": "<p>yes. often <code>libgcc_s</code> too</p>",
        "id": 272836815,
        "sender_full_name": "cuviper",
        "timestamp": 1645550541
    },
    {
        "content": "<p>unless you use a target like <code>linux-musl</code> that links those statically</p>",
        "id": 272836838,
        "sender_full_name": "cuviper",
        "timestamp": 1645550554
    },
    {
        "content": "<p>that explains so much! i suppose this is why we have both msvc and gnu \"runtimes\" on windows?</p>",
        "id": 272836931,
        "sender_full_name": "nasso",
        "timestamp": 1645550587
    },
    {
        "content": "<p>depending on whether we're linking with <code>cl.exe</code> or <code>gcc.exe</code></p>",
        "id": 272837038,
        "sender_full_name": "nasso",
        "timestamp": 1645550629
    },
    {
        "content": "<p>yeah, and it's not just startup code, but also a lot of support code uses system C APIs too, for threading and such</p>",
        "id": 272837151,
        "sender_full_name": "cuviper",
        "timestamp": 1645550664
    },
    {
        "content": "<p>does that mean i have to have a C compiler available when i call <code>rustc</code>?</p>",
        "id": 272837232,
        "sender_full_name": "nasso",
        "timestamp": 1645550703
    },
    {
        "content": "<p>well, at least enough to link C code, but that's not usually separable</p>",
        "id": 272837326,
        "sender_full_name": "cuviper",
        "timestamp": 1645550752
    },
    {
        "content": "<p>thank you so much, everything's clear now :)<br>\nill try to do the same thing!<br>\nhave a nice rest of your day!</p>",
        "id": 272837494,
        "sender_full_name": "nasso",
        "timestamp": 1645550814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"478591\">nasso</span> has marked this topic as resolved.</p>",
        "id": 272837511,
        "sender_full_name": "Notification Bot",
        "timestamp": 1645550820
    }
]