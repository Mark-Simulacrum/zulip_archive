[
    {
        "content": "<p>Hi All, as per <a href=\"https://github.com/rust-lang/rust/issues/89566\">issue 89566</a> the current compiler parser takes all inner attributes at the top of a crate and applies them as crate attributes - I would like to be able to generate an error message if any incorrect attributes (for example #![derive]) are at the top of a crate so we don't end up with a confusing error message further down the line.</p>\n<p>Is there a list of attributes that can be applied to a crate as an inner attribute?</p>",
        "id": 256716494,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633687564
    },
    {
        "content": "<p>Everything with a <code>CrateLevel</code> <a href=\"https://github.com/rust-lang/rust/blob/e0aaffd8a45cd0e9f331ec7734713e9de11aa6c8/compiler/rustc_feature/src/builtin_attrs.rs#L168\">here</a> is a crate-level only attribute.  rustc already checks for these, but some attributes are special, like <code>derive</code>, <code>test</code>, <code>bench</code>, etc. These attributes run during expansion, before most of the validation is done.  I'm not sure the best way to approach this, <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> might have an idea.  I'm guessing something in resolution, since that is where it is getting stuck.</p>\n<p>Something seems off though.  Putting any unknown attribute at the crate level seems to cause a cascade of \"resolution is stuck\" errors further down the line.  I don't think that should be happening.</p>",
        "id": 256756897,
        "sender_full_name": "Eric Huss",
        "timestamp": 1633706788
    },
    {
        "content": "<p>From what I can tell during std injection it's placing these unknown attributes in between the <code>#![feature(prelude_import)]</code> and the actual std prelude injection inside the <code>standard_library_injection::inject()</code> function because when it parses the initial crate for the ast it assumes that any internal attribute (specified with # ! | ATTRIBUTE) at the top of the crate is a crate attribute. </p>\n<p>The output of macro expansion is: </p>\n<div class=\"codehilite\"><pre><span></span><code>#![feature(prelude_import)]\n#![derive(Debug)]\n#[prelude_import]\nuse std::prelude::rust_2018::*;\n#[macro_use]\nextern crate std;\nstruct Test {\n    s: String,\n}\n\nfn main() { }\n</code></pre></div>\n<p>The only reason I can see why it is doing this is because it appends the injection onto the start of the crate items which come after the crate attributes in the crate representation of the ast </p>\n<div class=\"codehilite\"><pre><span></span><code>pub struct Crate {\n    pub attrs: Vec&lt;Attribute&gt;,\n    pub items: Vec&lt;P&lt;Item&gt;&gt;,\n    pub span: Span,\n}\n</code></pre></div>",
        "id": 256760507,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633708316
    },
    {
        "content": "<p>The location it injects the std prelude is here in <code>Compiler::rustc_builtin_macros::src::standard_library_imports::inject</code></p>",
        "id": 256760744,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633708424
    },
    {
        "content": "<p>So I think the issue is likely that we're just incorrectly parsing attributes at the top of the crate as all being crate level attributes when in fact only a few of the inner attributes actually are</p>",
        "id": 256761019,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633708550
    },
    {
        "content": "<p>And just for completeness despite the wall of text - this is the parser function for the initial <code>Crate</code> ast token: </p>\n<div class=\"codehilite\"><pre><span></span><code>pub fn parse_mod(\n        &amp;mut self,\n        term: &amp;TokenKind,\n    ) -&gt; PResult&lt;&#39;a, (Vec&lt;Attribute&gt;, Vec&lt;P&lt;Item&gt;&gt;, Span)&gt; {\n        let lo = self.token.span;\n        let attrs = self.parse_inner_attributes()?;\n\n        let mut items = vec![];\n        while let Some(item) = self.parse_item(ForceCollect::No)? {\n            items.push(item);\n            self.maybe_consume_incorrect_semicolon(&amp;items);\n        }\n\n        if !self.eat(term) {\n            let token_str = super::token_descr(&amp;self.token);\n            if !self.maybe_consume_incorrect_semicolon(&amp;items) {\n                let msg = &amp;format!(&quot;expected item, found {}&quot;, token_str);\n                let mut err = self.struct_span_err(self.token.span, msg);\n                err.span_label(self.token.span, &quot;expected item&quot;);\n                return Err(err);\n            }\n        }\n\n        Ok((attrs, items, lo.to(self.prev_token.span)))\n    }\n</code></pre></div>\n<p>You can see it's just parsing all inner attributes at the top of the crate and then assigning them to the crate attributes</p>",
        "id": 256767105,
        "sender_full_name": "Tom Farmer",
        "timestamp": 1633710888
    }
]