[
    {
        "content": "<p>I'm trying to understand what's going on in <a href=\"https://github.com/rust-lang/rust/issues/70263\">https://github.com/rust-lang/rust/issues/70263</a></p>\n<p>My understanding from reading <a href=\"https://github.com/rust-lang/rfcs/pull/3216\">this</a> is the core of the issue is the types <code>for&lt;'a&gt; FnOnce(&amp;'a i32) -&gt; &amp;'a i32</code> and <code>for a concrete 'a FnOnce(&amp;'a i32) -&gt; &amp;'a i32</code> are different (first is higher-ranked, second is not), and the compiler tries to infer which one the user wants. How does this inference work?</p>\n<p>I've been looking at here <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/closure.rs\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/closure.rs</a> . Comparing traces I can see the \"good\" snippet goes through <code>deduce_sig_from_projection</code>, <code>sig_of_closure_with_expectation</code>, and the \"bad\" one goes through <code>sig_of_closure_no_expectation</code></p>",
        "id": 272431071,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645205427
    },
    {
        "content": "<p>Is this the right place to look?</p>\n<p>The trace from here <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/closure.rs#L162\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/closure.rs#L162</a> says:</p>\n<p>good:</p>\n<div class=\"codehilite\"><pre><span></span><code>│ │ │ │ │ │ │ │ ├─1ms DEBUG rustc_typeck::check::closure sig=Binder(([(&amp;i32,)]; c_variadic: false)-&gt;&amp;i32, [Region(BrAnon(0))]), opt_kind=Some(FnOnce)\n│ │ │ │ │ │ │ │ ├─1ms DEBUG rustc_typeck::check::closure expr.hir_id=HirId { owner: DefId(0:11 ~ lol[6f2f]::main), local_id: 17 }, closure_type=[closure@lol.rs]\n</code></pre></div>\n<p>bad: </p>\n<div class=\"codehilite\"><pre><span></span><code>│ │ │ │ │ │ │ │ ├─1ms DEBUG rustc_typeck::check::closure sig=Binder(([(&amp;i32,)]; c_variadic: false)-&gt;&amp;i32, [Region(BrAnon(0))]), opt_kind=None\n│ │ │ │ │ │ │ │ ├─1ms DEBUG rustc_typeck::check::closure expr.hir_id=HirId { owner: DefId(0:11 ~ lol[6f2f]::main), local_id: 17 }, closure_type=[closure@lol.rs]\n</code></pre></div>\n<p>sigs are the same. Should I see the differenceif I inspect the <code>closure_type</code>? Or am I looking at the wrong place?</p>",
        "id": 272431401,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645205578
    },
    {
        "content": "<p>Yes, you're looking in the right place</p>",
        "id": 272457412,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645218369
    },
    {
        "content": "<p>what snippet are you compiling when you're getting that debug output?</p>",
        "id": 272457502,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645218420
    },
    {
        "content": "<p>the one from <a href=\"https://github.com/rust-lang/rust/issues/70263\">#70263</a> OP</p>\n<p>bad:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyFn</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyFn</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">i32</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">MyFn</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">     </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>good:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">i32</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">     </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272457688,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645218508
    },
    {
        "content": "<p>that's odd - let me see if I can figure out what's happening</p>",
        "id": 272460610,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220120
    },
    {
        "content": "<p>I think it's coming from <code>check_supplied_sig_against_expectation</code></p>",
        "id": 272460996,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220337
    },
    {
        "content": "<p>in the 'good' case, you get an expected signature deduced from the <code>FnOnce</code> bound, which has the proper higher-ranked lifetimes</p>",
        "id": 272461208,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220463
    },
    {
        "content": "<p>in the 'bad' case, it doesn't deduce a signature from the obligation, so its ends up calling <code>sig_of_closure_no_expectation</code></p>",
        "id": 272461246,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220489
    },
    {
        "content": "<p>You can also pass <code>-Z verbose</code> to the compiler to see distinct signatures</p>",
        "id": 272461376,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220563
    },
    {
        "content": "<p>In the 'bad' case, you'll get:</p>\n<div class=\"codehilite\"><pre><span></span><code>│ ├─0ms DEBUG rustc_typeck::check::closure sig=Binder(([(&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrAnon(0) }) i32,)]; c_variadic: false)-&gt;&amp;&#39;_#0r i32, [Region(BrAnon(0))]), opt_kind=None\n</code></pre></div>\n<p>and in the 'good' case:</p>\n<div class=\"codehilite\"><pre><span></span><code>│ ├─0ms DEBUG rustc_typeck::check::closure sig=Binder(([(&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrAnon(0) }) i32,)]; c_variadic: false)-&gt;&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrAnon(0) }) i32, [Region(BrAnon(0))]), opt_kind=Some(FnOnce)\n</code></pre></div>",
        "id": 272461423,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220604
    },
    {
        "content": "<p>Note how the 'good' case has the same region in the argument and region type, while the 'bad' case has a different region in the return type</p>",
        "id": 272461473,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220639
    },
    {
        "content": "<p>ooh, I see! makes sense</p>",
        "id": 272461879,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645220834
    },
    {
        "content": "<p>It's strange that without verbose the two sigs look the same but aren't, that was confusing me</p>",
        "id": 272461995,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645220895
    },
    {
        "content": "<p>Yeah, I think we might want to change the non-verbose printing of that. It threw me off as well</p>",
        "id": 272462020,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645220915
    },
    {
        "content": "<p>how could the inference be improved?</p>",
        "id": 272462041,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645220934
    },
    {
        "content": "<p>for exampe, if the closure is self-contained (doesn't capture anything) it seems to me there's no reason to not make it always higher-ranked</p>",
        "id": 272462077,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645220956
    },
    {
        "content": "<p>I think that would probably be a good idea</p>",
        "id": 272462226,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221021
    },
    {
        "content": "<p>Unfortunately, I think it will be pretty difficult to fix the specific issue with that reproducer</p>",
        "id": 272462247,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221037
    },
    {
        "content": "<p>We're not 'seeing' the <code>FnOnce</code> bound when we try to deduce the closure signature, because it's behind the <code>where</code> clause of the impl</p>",
        "id": 272462268,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221058
    },
    {
        "content": "<p>At this stage in typechecking, we haven't actually created the closure type yet (we still have an inference variable)</p>",
        "id": 272462299,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221077
    },
    {
        "content": "<p>yeah, that sounds super complicated. there could be other impls as well</p>",
        "id": 272462320,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645221086
    },
    {
        "content": "<p>and the trait selection system doesn't really work with an inference variable as the self type, IIRC</p>",
        "id": 272462332,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221097
    },
    {
        "content": "<p>We would need to recursively process that obligation in some kind of special mode</p>",
        "id": 272462352,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221107
    },
    {
        "content": "<p>but \"make it higher-ranked if there's no captures\" would fix it, wouldn't it?</p>",
        "id": 272462354,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645221108
    },
    {
        "content": "<p>so that we could discover the <code>FnOnce</code> bound</p>",
        "id": 272462367,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221115
    },
    {
        "content": "<p>I think it should, yes</p>",
        "id": 272462371,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221117
    },
    {
        "content": "<p>The only possible issue would be breaking cases where people are relying on <em>not</em> being higher-ranked</p>",
        "id": 272462429,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221136
    },
    {
        "content": "<p>let me see if I can think of a case where that would happen without captures</p>",
        "id": 272462450,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221146
    },
    {
        "content": "<p>but that won't be that useful for real-world code though, usually you do have captures. the original issue that led me down this rabbit hole does have captures...</p>",
        "id": 272462527,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645221199
    },
    {
        "content": "<p>and if there's no captures you can always rewrite it as a standalone fn</p>",
        "id": 272462572,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645221223
    },
    {
        "content": "<p>Yeah, I think it should be fine in practice. In the worst case, we'll do a Crater run and discover some weird code that can make for good test cases :)</p>",
        "id": 272462736,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221288
    },
    {
        "content": "<p>If you're interested in working on this, I can give you some pointers</p>",
        "id": 272462753,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221298
    },
    {
        "content": "<p>If not, I can work on implementing this myself</p>",
        "id": 272462764,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221302
    },
    {
        "content": "<p>please do! I have never contributed but would really like to get started</p>",
        "id": 272462819,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645221334
    },
    {
        "content": "<p>hmm - it looks like we run the closure capture anaylsis late in typechecking</p>",
        "id": 272463098,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221467
    },
    {
        "content": "<p>I think we could run a very basic version (that just checks if there are any upvars at all) when we're computing the closure signature</p>",
        "id": 272463672,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221670
    },
    {
        "content": "<p>what about cases like these?<br>\n<code>|a: &amp;u8, b: &amp;u8| a</code> --&gt; <code>for&lt;'a,'b&gt; FnOnce(&amp;'a u8, &amp;'b u8) -&gt; &amp;'a u8</code><br>\n<code>|a: &amp;u8, b: &amp;u8| if cond {a} else {b}</code>  --&gt; <code>for&lt;'a&gt; FnOnce(&amp;'a u8, &amp;'a u8) -&gt; &amp;'a u8</code></p>",
        "id": 272464099,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645221906
    },
    {
        "content": "<p>In general, I think it's going to be very tricky to get that working (partially due to the fact that the closure signature is determined before NLL runs, and partially due to the complexity of higher-ranked regions)</p>",
        "id": 272464233,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645221972
    },
    {
        "content": "<p>how would it match input lifetimes to output lifetimes?</p>",
        "id": 272464240,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645221978
    },
    {
        "content": "<p>yeah.. :S</p>",
        "id": 272464272,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645222001
    },
    {
        "content": "<p>For tricky cases, explicitly specifiying the signature via <a href=\"https://github.com/rust-lang/rfcs/pull/3216\">https://github.com/rust-lang/rfcs/pull/3216</a> will probably be the way to go</p>",
        "id": 272464291,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645222021
    },
    {
        "content": "<p>However, we can hopefully make unambiguous improvements to inference for common cases</p>",
        "id": 272464317,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645222037
    },
    {
        "content": "<p>my original issue was trying to do async closures <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=bc5d8bb1f708bf94fc346653b413b0a3\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=bc5d8bb1f708bf94fc346653b413b0a3</a></p>",
        "id": 272464802,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645222289
    },
    {
        "content": "<p>which is annoying because it's impossible to write the bounds for the closure with a <code>for&lt;'a&gt; F: FnOnce(..)</code></p>",
        "id": 272464975,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645222389
    },
    {
        "content": "<p>but seeing this is so tricky perhaps it's better to invest efforts towards <a href=\"https://rust-lang.github.io/async-fundamentals-initiative/roadmap/async_closures.html\">async closures</a>?</p>",
        "id": 272465191,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645222535
    },
    {
        "content": "<p>because these could do the same \"peek at the expectation to deduce everything\" trick...</p>",
        "id": 272465617,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645222623
    },
    {
        "content": "<p>I think many of the underlying inference issues will be the same, unfortunately</p>",
        "id": 272465827,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645222742
    },
    {
        "content": "<p>After looking at this in more detail, I think the simplest approach would be to attempt to apply the normal function signature lifetime elision rules</p>",
        "id": 272467064,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223405
    },
    {
        "content": "<p>If there's exactly one elided input lifetime, then it will get applied to the output lifetimes (<a href=\"https://doc.rust-lang.org/nomicon/lifetime-elision.html\">https://doc.rust-lang.org/nomicon/lifetime-elision.html</a>)</p>",
        "id": 272467104,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223430
    },
    {
        "content": "<p>e.g. <code>fn foo(arg: &amp;u8, other: bool) -&gt; &amp;u8 {}</code> compiles</p>",
        "id": 272467131,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223446
    },
    {
        "content": "<p>We can apply the same logic to explicit closure signatures (so <code>|arg: &amp;i32| -&gt; &amp;i32</code> will behave like <code>fn foo(arg: &amp;i32) -&gt; &amp;i32</code>)</p>",
        "id": 272467227,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223505
    },
    {
        "content": "<p>of course, closures support things like <code>|first: &amp;i32, second: &amp;i32| -&gt; &amp;i32 { ... }</code>, which have no corresponding function equivalent (for good reason :P)</p>",
        "id": 272467327,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223539
    },
    {
        "content": "<p>However, we can just fall back to existing closure behavior in those kinds of tricky cases</p>",
        "id": 272467367,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223563
    },
    {
        "content": "<p>still only if there's no upvars, right?</p>",
        "id": 272467368,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645223564
    },
    {
        "content": "<p>I think this could apply regardless of upvars - it would just work based on the signature</p>",
        "id": 272467429,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223602
    },
    {
        "content": "<p>An upvar-based inference rule could be added separately. However, I'm concerned that it might lead to somewhat brittle code - you could have a working closure, but adding a single upvar usage causes a confusing signature error</p>",
        "id": 272467546,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223658
    },
    {
        "content": "<p>even if your upvar isn't related to the input or output at all</p>",
        "id": 272467568,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"348152\">@Dario Nieuwenhuis</span> If you're interested, I can help walk you through the changes needed to implement the elision change</p>",
        "id": 272467759,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223792
    },
    {
        "content": "<p>hmm, I think that might break existing code that has upvars, because an input/output lifetime could  be related to one that's \"exfiltrated\" through an upvar</p>",
        "id": 272467792,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645223816
    },
    {
        "content": "<p>or even if there's no upvars:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">STATIK</span>: <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">u8</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&amp;</span><span class=\"n\">STATIK</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">123</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"kt\">u8</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272467830,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645223850
    },
    {
        "content": "<p>that currently infers <code>for&lt;'a&gt; Fn(&amp;'a u8) -&gt; &amp;'static u8</code><br>\nwith the change it would infer <code>for&lt;'a&gt; Fn(&amp;'a u8) -&gt; &amp;'a u8</code> and break</p>",
        "id": 272467917,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645223886
    },
    {
        "content": "<p>That's a good point. However,  it would allow code like this to compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">arg</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span><span class=\"o\">|</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">arg</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272467986,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223941
    },
    {
        "content": "<p>while your example could be fixed by adding an explicit <code>'static</code> lifetime, the code I posted currently <em>can't</em> compile with an explicit signature</p>",
        "id": 272468039,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645223982
    },
    {
        "content": "<p>oh wow why does that not compile</p>",
        "id": 272468116,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645224014
    },
    {
        "content": "<p>However, we'd probably want to do a Crater run to evaluate the inference breakage in practice</p>",
        "id": 272468127,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224021
    },
    {
        "content": "<p>Yeah, I discovered that <em>lovely</em> example while working on my closure RFC</p>",
        "id": 272468142,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224032
    },
    {
        "content": "<blockquote>\n<p>returning this value requires that <code>'1</code> must outlive <code>'2</code></p>\n</blockquote>\n<p>but it seems like it should just infer that <code>'1 : '2</code> and carry on, wtf :D</p>",
        "id": 272468201,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645224077
    },
    {
        "content": "<p>A lot of the closure issues stem from the fact that most of the 'intelligence' around regions occurs after types are inferred (the AST-based region logic, and MIR borrowcheck)</p>",
        "id": 272468270,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224118
    },
    {
        "content": "<p>Unfortunately, the closure signature gets inferred <em>during</em> type inference (so that we can create the <code>ty::Closure</code>)</p>",
        "id": 272468343,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224144
    },
    {
        "content": "<p>Everything dealing with closure regions tends to get complicated fairly quickly :)</p>",
        "id": 272468467,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224232
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/closure.20type.20inference.20questions/near/272467759\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"348152\">Dario Nieuwenhuis</span> If you're interested, I can help walk you through the changes needed to implement the elision change</p>\n</blockquote>\n<p>of course, I'd love that!</p>",
        "id": 272468610,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645224323
    },
    {
        "content": "<p>I'm somewhat scared this will be \"too breaking\" though</p>",
        "id": 272468621,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645224333
    },
    {
        "content": "<p>I made an initial attempt locally, and there was only one break in the test suite (which was easily fixed)</p>",
        "id": 272468707,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224374
    },
    {
        "content": "<p>We can do a Crater run on your PR to evaluate the breakage, and discuss with the rest of the compiler team</p>",
        "id": 272468734,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224396
    },
    {
        "content": "<p>To start with, I'd recommend taking a look at compiler/rustc_resolve/src/late/lifetimes.rs</p>",
        "id": 272468759,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224410
    },
    {
        "content": "<p>Here's where we skip running the elision logic for closures: <a href=\"https://github.com/rust-lang/rust/blob/b17226fcc11587fed612631be372a5b4cb89988a/compiler/rustc_resolve/src/late/lifetimes.rs#L2768-L2769\">https://github.com/rust-lang/rust/blob/b17226fcc11587fed612631be372a5b4cb89988a/compiler/rustc_resolve/src/late/lifetimes.rs#L2768-L2769</a></p>",
        "id": 272468898,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224489
    },
    {
        "content": "<p>To start with, I'd reccomend adding a new <code>match</code> arm that checks for a closure</p>",
        "id": 272468937,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224519
    },
    {
        "content": "<p>Have you looked at <code>hir::Expr</code> before?</p>",
        "id": 272468955,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224529
    },
    {
        "content": "<p>not much, no</p>",
        "id": 272468973,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645224543
    },
    {
        "content": "<p>If you haven't seen it already, the compiler docs site is very helpful: <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Expr.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/struct.Expr.html</a></p>",
        "id": 272469014,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224572
    },
    {
        "content": "<p>You're going to want to check for an <code>ExprKind::Closure</code></p>",
        "id": 272469041,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224596
    },
    {
        "content": "<p>To check that, you'll want to match against <code>Node::Expr</code> in that existing match block</p>",
        "id": 272469139,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224653
    },
    {
        "content": "<p>you can just have that arm produce <code>None</code> (the <code>body</code> field is just used for diagnostics)</p>",
        "id": 272469464,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224854
    },
    {
        "content": "<p>Let me know if you run into any issues doing that</p>",
        "id": 272469479,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645224867
    },
    {
        "content": "<p>Will try, thanks!</p>",
        "id": 272469686,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225015
    },
    {
        "content": "<p>Additionally, you'll want to modify the error case: <a href=\"https://github.com/rust-lang/rust/blob/b17226fcc11587fed612631be372a5b4cb89988a/compiler/rustc_resolve/src/late/lifetimes.rs#L2888\">https://github.com/rust-lang/rust/blob/b17226fcc11587fed612631be372a5b4cb89988a/compiler/rustc_resolve/src/late/lifetimes.rs#L2888</a></p>",
        "id": 272469943,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225184
    },
    {
        "content": "<p>For closures, we don't want to emit an error if the elision logic fails, since we want to continue to accept code like <code>|first: &amp;i32, second: &amp;i32| -&gt; &amp;i32 { ... }</code> (which is <em>not</em> allowed in function signatures)</p>",
        "id": 272470103,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225224
    },
    {
        "content": "<p>Inside that <code>else</code> branch, you'll want to check if you're in a closure</p>",
        "id": 272470141,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225240
    },
    {
        "content": "<p>If you are, then you'll want to fall back to the code that we currently run unconditionally:</p>",
        "id": 272470180,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225265
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/b17226fcc11587fed612631be372a5b4cb89988a/compiler/rustc_resolve/src/late/lifetimes.rs#L2771-L2772\">https://github.com/rust-lang/rust/blob/b17226fcc11587fed612631be372a5b4cb89988a/compiler/rustc_resolve/src/late/lifetimes.rs#L2771-L2772</a></p>",
        "id": 272470188,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225273
    },
    {
        "content": "<p>Feel free to ping me for any help that you need</p>",
        "id": 272470237,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225304
    },
    {
        "content": "<p>what about the <code>&amp;'static</code> case then?</p>",
        "id": 272470433,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225421
    },
    {
        "content": "<p>The example that you gave?</p>",
        "id": 272470452,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225435
    },
    {
        "content": "<p>That kind of code will need to be modified to be <code>let closure = |x: &amp;u8| -&gt; &amp;'static u8 { ... }</code></p>",
        "id": 272470539,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225485
    },
    {
        "content": "<p>yeah, or you can construct similar ones with captures, I suspect these will be more common</p>",
        "id": 272470578,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225508
    },
    {
        "content": "<p>moving references from an input to a capture, or from a capture to the return value</p>",
        "id": 272470613,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225535
    },
    {
        "content": "<p>The compiler is allowed to make 'small' inference breakages in the course of improvements to the language. We'll need to see how large of an issue that code is in practice, using a Crater run</p>",
        "id": 272470617,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225537
    },
    {
        "content": "<p>Also, that code only starts erroring if you have an explicit type on both the input <em>and</em> output</p>",
        "id": 272470864,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225676
    },
    {
        "content": "<p><code>|x| -&gt; &amp;u8 { ... }</code> and <code>|x: &amp;u8| { ... }</code>are both unaffected by this elision change</p>",
        "id": 272470956,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225709
    },
    {
        "content": "<p>In my experience, explicitly specifying both the closure input and output is pretty rare</p>",
        "id": 272470994,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225730
    },
    {
        "content": "<p>right</p>",
        "id": 272470995,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225730
    },
    {
        "content": "<p>which should hopefully reduce the impact of this change</p>",
        "id": 272471012,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225738
    },
    {
        "content": "<p>maybe it's a bit overlapping with your RFC?</p>",
        "id": 272471176,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225809
    },
    {
        "content": "<p>you've specified if you use <code>for&lt;..&gt;</code> then all lifetimes must be specified</p>",
        "id": 272471202,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225823
    },
    {
        "content": "<p>an extension of that would be \"apply lifetime elision rules to elided lifetimes\"</p>",
        "id": 272471265,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225862
    },
    {
        "content": "<p>that's a good point - there's definitely some overlap there</p>",
        "id": 272471293,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225884
    },
    {
        "content": "<p>or even an empty <code>for&lt;&gt;</code></p>",
        "id": 272471327,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225904
    },
    {
        "content": "<p>so <code>for&lt;&gt; |arg: &amp;i32| -&gt; &amp;i32 { arg }</code> means <code>for&lt;'a&gt; |arg: &amp;'a i32| -&gt; &amp;'a i32 { arg }</code></p>",
        "id": 272471394,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225924
    },
    {
        "content": "<p>looks a bit weird, but feels more consistent</p>",
        "id": 272471446,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225951
    },
    {
        "content": "<p>Personally, I think it would be a good idea to apply this elision change in all cases, if we can 'get away' with it</p>",
        "id": 272471472,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225966
    },
    {
        "content": "<p>It would be really nice for <code>|val: &amp;i32| -&gt; &amp;i32 { val }</code> to compile, especially for people new to the language</p>",
        "id": 272471510,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645225989
    },
    {
        "content": "<p>no <code>for&lt;&gt;</code> -&gt; lifetimes are inferred within the context of parent function<br>\n<code>for&lt;&gt;</code> -&gt; lifetimes are always higher-ranked, elision rules are applied</p>",
        "id": 272471527,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645225997
    },
    {
        "content": "<p>However, if the breakage turns out to be too high in practice, then I think it would be a great idea to put it behind <code>for&lt;&gt;</code> as you suggested</p>",
        "id": 272471542,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645226007
    },
    {
        "content": "<p>also you could argue <code>&amp;u32</code> means different things \"inside\" and \"outside\" a fn body</p>",
        "id": 272471636,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226048
    },
    {
        "content": "<p>outside -&gt; apply elision rules, or it's invalid if you can't<br>\ninside -&gt; infer lifetimes within the whole fn context</p>",
        "id": 272471664,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226070
    },
    {
        "content": "<p>while with this change, <code>&amp;u32</code> would \"mean\" a different thing in <code>let x: &amp;u32</code> vs in <code>|x: &amp;u32| -&gt; &amp;u32</code></p>",
        "id": 272471714,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226105
    },
    {
        "content": "<p>dunno, it's a bit handwavey. Maybe I'm too used to how it works now</p>",
        "id": 272471845,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226167
    },
    {
        "content": "<p>it's certainly super whacky that this fails to compile <code>|val: &amp;i32| -&gt; &amp;i32 { val }</code></p>",
        "id": 272471871,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226185
    },
    {
        "content": "<p>I think you raise some good points. I've always thought of the closure signature as more like a function signature that 'happens' to be written inside another function, but I can see the argument for consistency with <code>let x: &amp;u32</code></p>",
        "id": 272471953,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645226231
    },
    {
        "content": "<p>yeah... closure signatures are a weird \"in-between\" thing</p>",
        "id": 272471994,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226260
    },
    {
        "content": "<p>I like the idea of <code>for&lt;&gt;</code> to \"activate function signature-like mode\" a bit better</p>",
        "id": 272472137,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226346
    },
    {
        "content": "<p>Are you still interested in trying out the 'unconditional' elision change, or would you prefer to wait for my RFC to (hopefully) land?</p>",
        "id": 272472710,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645226716
    },
    {
        "content": "<p>I'm not sure <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 272472835,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645226786
    },
    {
        "content": "<p>At the very least, I think it would be interesting to do a Crater run to gather data on how people are using closure signatures in practice</p>",
        "id": 272472874,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645226824
    },
    {
        "content": "<p>and how many cases would need to use <code>for&lt;&gt;</code> syntax if we gate the elision change behind it</p>",
        "id": 272472886,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1645226838
    },
    {
        "content": "<p>indeed! I'll give it a try next week.</p>",
        "id": 272473411,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645227191
    },
    {
        "content": "<p>I have to run now. Thanks a lot for the pointers and the interesting conversation!</p>",
        "id": 272473441,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645227208
    },
    {
        "content": "<p>I wonder if we could do something tricky like delay such checking all the way to mir borrowck. Basically allow typeck to assume that those lifetimes are equal and leave it to mir borrowck to actually check them. At that point we do have all the information and can make more complicated decisions</p>",
        "id": 272506172,
        "sender_full_name": "oli",
        "timestamp": 1645262758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/closure.20type.20inference.20questions/near/272468039\">said</a>:</p>\n<blockquote>\n<p>while your example could be fixed by adding an explicit <code>'static</code> lifetime, the code I posted currently <em>can't</em> compile with an explicit signature</p>\n</blockquote>\n<p>This particular example has a namable lifetime, but closure can return something with an unnamable lifetime and with elision it'll break.</p>",
        "id": 272604415,
        "sender_full_name": "Gary Guo",
        "timestamp": 1645377038
    },
    {
        "content": "<p>I've shifted goal a bit</p>\n<p>Currently higher-ranked inference works with these obligations</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I want to try getting it working with these obligations as well:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span>: <span class=\"nc\">Debug</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because I believe it'll make async closures just work in more cases (most?)</p>",
        "id": 272629727,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645406184
    },
    {
        "content": "<p>but I'm not getting all obligations <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/closure.rs#L199\">here</a>, the log <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs#L689\">here</a> is printing:</p>\n<p>good:</p>\n<div class=\"codehilite\"><pre><span></span><code>│ │ │ │ │ │ │ │ │ ├─0ms TRACE rustc_typeck::check::fn_ctxt::_impl pending_obligations = [\n│ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::marker::Sized&gt;, polarity:Positive), []), cause=ObligationCause { span: snippets/good.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:9 ~ good[6163]::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ good[6163]::foo), snippets/good.rs:4:8: 4:9 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::ops::FnOnce&lt;(&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed(DefId(0:8 ~ good[6163]::foo::&#39;a), &#39;a) }) i32,)&gt;&gt;, polarity:Positive), [Region(BrNamed(DefId(0:8 ~ good[6163]::foo::&#39;a), &#39;a))]), cause=ObligationCause { span: snippets/good.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:9 ~ good[6163]::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ good[6163]::foo), snippets/good.rs:6:8: 6:38 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(ProjectionPredicate(ProjectionTy { substs: [_#0t, (&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed(DefId(0:8 ~ good[6163]::foo::&#39;a), &#39;a) }) i32,)], item_def_id: DefId(2:3277 ~ core[ce39]::ops::function::FnOnce::Output) }, Ty(i32)), [Region(BrNamed(DefId(0:8 ~ good[6163]::foo::&#39;a), &#39;a))]), cause=ObligationCause { span: snippets/good.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:9 ~ good[6163]::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ good[6163]::foo), snippets/good.rs:6:35: 6:38 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(WellFormed(_#0t), []), cause=ObligationCause { span: snippets/good.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:9 ~ good[6163]::main), local_id: 13 }, code: None }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ ]\n</code></pre></div>\n<p>bad</p>\n<div class=\"codehilite\"><pre><span></span><code>│ │ │ │ │ │ │ │ │ ├─0ms TRACE rustc_typeck::check::fn_ctxt::_impl pending_obligations = [\n│ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::marker::Sized&gt;, polarity:Positive), []), cause=ObligationCause { span: snippets/good.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:10 ~ good[4f88]::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ good[4f88]::foo), snippets/good.rs:4:8: 4:9 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::ops::FnOnce&lt;(&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed(DefId(0:8 ~ good[4f88]::foo::&#39;a), &#39;a) }) u32,)&gt;&gt;, polarity:Positive), [Region(BrNamed(DefId(0:8 ~ good[4f88]::foo::&#39;a), &#39;a))]), cause=ObligationCause { span: snippets/good.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:10 ~ good[4f88]::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ good[4f88]::foo), snippets/good.rs:6:16: 6:34 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(WellFormed(_#0t), []), cause=ObligationCause { span: snippets/good.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:10 ~ good[4f88]::main), local_id: 13 }, code: None }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ ]\n</code></pre></div>",
        "id": 272629970,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645406505
    },
    {
        "content": "<p><a href=\"http://good.rs\">good.rs</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(unboxed_closures)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//a</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"http://bad.rs\">bad.rs</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(unboxed_closures)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span>: <span class=\"nc\">Debug</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272630034,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645406563
    },
    {
        "content": "<p>where do these obligations come from? How can I get the <code>: Debug</code> one?</p>",
        "id": 272630059,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645406624
    },
    {
        "content": "<p>I can see it in the logs in unrelated stuff... I suspect it's something to do with it having a different self type? but the log there is before filtering by self type</p>\n<div class=\"codehilite\"><pre><span></span><code>Binder(TraitPredicate(&lt;&lt;F as std::ops::FnOnce&lt;(&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed(DefId(0:9 ~ good[4f88]::foo::&#39;a#1), &#39;a) }) u32,)&gt;&gt;::Output as std::fmt::Debug&gt;, polarity:Positive), [Region(BrNamed(DefId(0:9 ~ good[4f88]::foo::&#39;a#1), &#39;a))])\n</code></pre></div>",
        "id": 272630294,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645406921
    },
    {
        "content": "<p>wait, that's erroring <em>before</em> doing any closure typechecking.. how's that possible?</p>",
        "id": 272632994,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645410109
    },
    {
        "content": "<p>why does this fail? it makes no sense (<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=612ff388ada95547a912d6f4883ed5ea\">playground</a>)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(unboxed_closures)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span>: <span class=\"nc\">Debug</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272633729,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645410908
    },
    {
        "content": "<p>the fulfillment ctx is immediately exploding when adding these obligations instead of leaving it pending, why is that?</p>",
        "id": 272633807,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645410986
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/94207\">https://github.com/rust-lang/rust/issues/94207</a></p>",
        "id": 272637211,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645414334
    },
    {
        "content": "<p>Those <code>: Debug</code> bounds are lowered as opaque types. In the current system that means there'll be an inference type there that you need to query for its obligations</p>",
        "id": 272647535,
        "sender_full_name": "oli",
        "timestamp": 1645425851
    },
    {
        "content": "<p>You may have it easier if you wait for <a href=\"https://github.com/rust-lang/rust/pull/94081\">https://github.com/rust-lang/rust/pull/94081</a> to get merged, as then you see the opaque types and can get the bounds from it directly</p>",
        "id": 272647602,
        "sender_full_name": "oli",
        "timestamp": 1645425940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> is it possible they're lowered to opaque types only if the bounds are not higher-ranked?</p>\n<p>With this</p>\n<div class=\"codehilite\"><pre><span></span><code>    F: FnOnce&lt;(u32,)&gt;,\n    &lt;F as FnOnce&lt;(u32,)&gt;&gt;::Output: Debug,\n</code></pre></div>\n<p>I get </p>\n<div class=\"codehilite\"><pre><span></span><code>│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(ProjectionPredicate(ProjectionTy { substs: [_#0t, (u32,)], item_def_id: DefId(2:3291 ~ core[ac93]::ops::function::FnOnce::Output) }, Ty(_#1t)), []), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:8 ~ FILE::main), local_id: 12 }, code: None }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=1),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::marker::Sized&gt;, polarity:Positive), []), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:8 ~ FILE::main), local_id: 12 }, code: Some(BindingObligation(DefId(0:6 ~ FILE::foo), snippets/FILE.rs:4:8: 4:9 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::ops::FnOnce&lt;(u32,)&gt;&gt;, polarity:Positive), []), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:8 ~ FILE::main), local_id: 12 }, code: Some(BindingObligation(DefId(0:6 ~ FILE::foo), snippets/FILE.rs:6:8: 6:22 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#1t as std::fmt::Debug&gt;, polarity:Positive), []), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:8 ~ FILE::main), local_id: 12 }, code: Some(BindingObligation(DefId(0:6 ~ FILE::foo), snippets/FILE.rs:7:36: 7:41 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(WellFormed(_#0t), []), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:8 ~ FILE::main), local_id: 12 }, code: None }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(WellFormed(_#0t), []), cause=ObligationCause { span: snippets/FILE.rs:12:9: 12:14 (#0), body_id: HirId { owner: DefId(0:8 ~ FILE::main), local_id: 12 }, code: None }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n</code></pre></div>\n<p>the new <code>_#1t </code> variable is what you're talking about, I guess</p>",
        "id": 272710126,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645461125
    },
    {
        "content": "<p>but with this</p>\n<div class=\"codehilite\"><pre><span></span><code>    for&lt;&#39;a&gt; F: FnOnce&lt;(&amp;&#39;a u32,)&gt;,\n    for&lt;&#39;a&gt; &lt;F as FnOnce&lt;(&amp;&#39;a u32,)&gt;&gt;::Output: Debug,\n</code></pre></div>\n<p>I get</p>\n<div class=\"codehilite\"><pre><span></span><code>│ │ │ │ │ │ │ │ │ │ │ ├─0ms TRACE rustc_typeck::check::fn_ctxt::_impl pending_obligations = [\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::marker::Sized&gt;, polarity:Positive), []), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:10 ~ FILE::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ FILE::foo), snippets/FILE.rs:4:8: 4:9 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;_#0t as std::ops::FnOnce&lt;(&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed(DefId(0:8 ~ FILE::foo::&#39;a), &#39;a) }) u32,)&gt;&gt;, polarity:Positive), [Region(BrNamed(DefId(0:8 ~ FILE::foo::&#39;a), &#39;a))]), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:10 ~ FILE::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ FILE::foo), snippets/FILE.rs:6:16: 6:34 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(TraitPredicate(&lt;&lt;_#0t as std::ops::FnOnce&lt;(&amp;ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed(DefId(0:9 ~ FILE::foo::&#39;a#1), &#39;a) }) u32,)&gt;&gt;::Output as std::fmt::Debug&gt;, polarity:Positive), [Region(BrNamed(DefId(0:9 ~ FILE::foo::&#39;a#1), &#39;a))]), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:10 ~ FILE::main), local_id: 13 }, code: Some(BindingObligation(DefId(0:6 ~ FILE::foo), snippets/FILE.rs:7:48: 7:53 (#0))) }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(WellFormed(_#0t), []), cause=ObligationCause { span: snippets/FILE.rs:12:5: 12:8 (#0), body_id: HirId { owner: DefId(0:10 ~ FILE::main), local_id: 13 }, code: None }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │     Obligation(predicate=Binder(WellFormed(_#0t), []), cause=ObligationCause { span: snippets/FILE.rs:12:9: 12:15 (#0), body_id: HirId { owner: DefId(0:10 ~ FILE::main), local_id: 13 }, code: None }, param_env=ParamEnv { caller_bounds: [], reveal: UserFacing, constness: NotConst }, depth=0),\n│ │ │ │ │ │ │ │ │ │ │ │ ]\n</code></pre></div>",
        "id": 272710183,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645461159
    },
    {
        "content": "<p>so I was thinking of updating the closure typeck to also match obligations like <code>Binder(TraitPredicate(&lt;&lt;_#0t as std::ops::FnOnce&lt;....&gt;&gt;::Output as std::fmt::Debug&gt;, ..</code></p>",
        "id": 272710614,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645461372
    },
    {
        "content": "<p>(I tried both master and <a href=\"https://github.com/rust-lang/rust/issues/94081\">#94081</a> , the behavior is the same)</p>",
        "id": 272710716,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645461430
    },
    {
        "content": "<p>well, we explicitly stop going into higher ranked things, because of some reason that I didn't dig into yet, so those obligation changes make sense, but there's still an opaque type behind the <code>::Output</code> projection. You'll see it once the projection gets resolved</p>",
        "id": 272711536,
        "sender_full_name": "oli",
        "timestamp": 1645461821
    },
    {
        "content": "<p>okay, but at the time of typechecking the closure I get just these obligations</p>",
        "id": 272711946,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645462034
    },
    {
        "content": "<p>so does it make sense to make closure typechecking to match these to infer the closure signature?</p>",
        "id": 272712004,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645462066
    },
    {
        "content": "<p>currently it matches only <code>ProjectionPredicate</code>s, so it can't infer the closure signature with HRTBs</p>",
        "id": 272712271,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645462202
    },
    {
        "content": "<p>full example</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(unboxed_closures)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,)</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Output</span>: <span class=\"nc\">Debug</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272712303,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1645462211
    }
]