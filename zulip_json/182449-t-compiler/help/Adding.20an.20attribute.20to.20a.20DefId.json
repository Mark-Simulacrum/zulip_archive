[
    {
        "content": "<p>Is there anyway to <strong>add</strong> an attribute to a <code>DefId</code> during compilation? I've been searching the docs but it seems like you can only <strong>read</strong> attributes, I haven't found a way to extend them.</p>",
        "id": 250565059,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629849071
    },
    {
        "content": "<p>Honestly, any mechanism to store metadata during compilation so I can read it from another crate would be perfect</p>",
        "id": 250579389,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629866375
    },
    {
        "content": "<p>I'd like to avoid having to handle it myself so I can easily benefit from fingerprints / integrate with cargo clean etc..</p>",
        "id": 250579395,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629866398
    },
    {
        "content": "<p>No, the HIR is immutable. That is necessary for the query system and incremental compilation to work correctly.</p>",
        "id": 250587576,
        "sender_full_name": "bjorn3",
        "timestamp": 1629876505
    },
    {
        "content": "<p>You can change the AST before lowering to HIR though, but the lowering to HIR happens before the TyCtxt is created. (HIR is one of the inputs of the TyCtxt constructor)</p>",
        "id": 250587640,
        "sender_full_name": "bjorn3",
        "timestamp": 1629876575
    },
    {
        "content": "<p>If you want to store extra things in the crate metadata you will have to change rustc_metadata to add an extra field for it.</p>",
        "id": 250587733,
        "sender_full_name": "bjorn3",
        "timestamp": 1629876634
    },
    {
        "content": "<p>I imagine that will require an MCP</p>",
        "id": 250646444,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629910133
    },
    {
        "content": "<p>I wonder what the best api would be? Allow user key value pairs in the metadata?</p>",
        "id": 250646765,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629910276
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> <br>\nCould you tell in more detail what you want to achieve in the end?<br>\nAlso, is it something in rustc or in a third-party rustc driver or plugin?</p>",
        "id": 250675533,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1629922195
    },
    {
        "content": "<p>(I'm asking because for questions from the \"how to do something weird in the implementation\" category the answer is often \"you don't need to do that, you need to do something else entirely to achieve the observable end goal\".)</p>",
        "id": 250676639,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1629922730
    },
    {
        "content": "<p>This is for a rustc driver. </p>\n<p>I'm building a formal verification tool, and I'm trying to get it to work in a multi-crate project (ie with dependencies). The idea is that when It processes a crate it will save metadata about items, so that dependent crates can load them.</p>",
        "id": 250676653,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629922739
    },
    {
        "content": "<p>yea I figure that is could be an XY-problem situation</p>",
        "id": 250676694,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629922763
    },
    {
        "content": "<p>The end goal is I'd like to have additional build outputs (in a driver), whose storage is ideally managed by rustc infrastructure</p>",
        "id": 250676758,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629922798
    },
    {
        "content": "<p>What kind of <code>DefId</code>s do you want to attach extra data to?<br>\nDoes \"items\" mean items in Rust sense?</p>",
        "id": 250679232,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1629923985
    },
    {
        "content": "<p>Is it possible to use regular attributes (<code>#[attr(arbitrary token stream)]</code>) for this?<br>\nThey are already attached to <code>DefId</code>s, encoded into metadata, and can contain pretty arbitrary data.</p>",
        "id": 250679380,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1629924042
    },
    {
        "content": "<p>No it's not possible to use normal attributes because I need to add them after typechecking, in fact I need to add them after MIR is generated. I'm using 'item' here in the rustc sense, I need to attach to functions, trait method declarations, potentially even type declarations.</p>",
        "id": 250688659,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629928671
    },
    {
        "content": "<p>Basically, I'm compiling rust functions to logical expressions and I want to save those expressions, just like rustc saves the mir for inlineable functions.</p>",
        "id": 250688757,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629928722
    },
    {
        "content": "<p>You can use <code>-Zalways-encode-mir</code> to always encode mir in the crate metadata for all functions, not just inlineable and generic functions. Maybe you could then do the compilation to logic expressions in the binary crate instead of in every library?</p>",
        "id": 250734526,
        "sender_full_name": "bjorn3",
        "timestamp": 1629963104
    },
    {
        "content": "<p>Another option would be to make it a custom \"codegen\" backend and have the logic expressions be the \"object files\".</p>",
        "id": 250734632,
        "sender_full_name": "bjorn3",
        "timestamp": 1629963159
    },
    {
        "content": "<p>For fairly complex reasons that wouldn’t work</p>",
        "id": 250786072,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629989960
    },
    {
        "content": "<p>I actually generate functions that don’t have valid mir and read them out as THIR</p>",
        "id": 250786214,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629990005
    },
    {
        "content": "<p>So always encore mir wouldn’t be of any use and similarity for a custom codegen backend</p>",
        "id": 250786442,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629990072
    },
    {
        "content": "<p>For the moment I’m just using <code>output_filenames</code> to recover the storage location for a crate</p>",
        "id": 250786554,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629990118
    },
    {
        "content": "<p>And I can read it back by loading it from the crate source in a dependent crate</p>",
        "id": 250786705,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629990146
    },
    {
        "content": "<p>I think I’m pushing the limits of how rustc was meant to be used</p>",
        "id": 250787479,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1629990448
    }
]