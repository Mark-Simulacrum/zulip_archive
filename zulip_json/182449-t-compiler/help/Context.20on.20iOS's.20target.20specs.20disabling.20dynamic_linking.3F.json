[
    {
        "content": "<p>There's <a href=\"https://github.com/rust-lang/rust/blob/69f11fff33f68701d222639a1a5ae991605ec3ab/compiler/rustc_target/src/spec/mod.rs#L1183-L1185\">a comment from 8y ago</a> saying that iOS only supports static libraries and not executables. iOS specs get their base <code>TargetOptions</code> from <code>apple_sdk_base::opts()</code> though <a href=\"https://github.com/rust-lang/rust/blob/41c3017c82bbc16842cc3bc1afa904e6910e293c/compiler/rustc_target/src/spec/apple_sdk_base.rs#L54\">which sets <code>executables</code> to true</a>. This is a contradiction, right?</p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/41c3017c82bbc16842cc3bc1afa904e6910e293c/compiler/rustc_target/src/spec/apple_sdk_base.rs#L53\"><code>apple_sdk_base::opts()</code> also sets <code>dynamic_linking</code> to false</a>. That's consistent with the \"static libraries\" comment at least, but is it actually true? I don't know whether there's iOS SDK magic that needs to happen or what but iOS apps can definitely organize code into dylibs; I work on a few apps that do.</p>\n<p>I ran into this because it apparently means you can't compile <code>proc-macro</code> crates for iOS targets. When I tried I got a warning:</p>\n<blockquote>\n<p>warning: dropping unsupported crate type <code>proc-macro</code> for target <code>x86_64-apple-ios</code></p>\n</blockquote>\n<p>and an error about using <code>#[proc_macro_attribute]</code> in the wrong crate type. I'd like to turn on <code>dynamic_linking</code> to solve it, but I am wondering if there's anyone who knows why it is this way in the first place.</p>",
        "id": 275127503,
        "sender_full_name": "Matt H",
        "timestamp": 1647136871
    },
    {
        "content": "<p><a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Help.20with.20arm64.20apple-iOS.20support.20on.20a.20Linux.20host\">Here's an old Zulip thread that touches on this issue</a>. The OP suggests it is incorrect for <code>dynamic_linking</code> to be turned off but there's not really any actionable information in it. That's all I was able to find.</p>",
        "id": 275127572,
        "sender_full_name": "Matt H",
        "timestamp": 1647136999
    },
    {
        "content": "<p>I suspect dylib support was added after iOS support was initially added (perhaps in iOS 8?).  There's also probably a difference between whether the os technically supports it, and whether Apple would allow it in the App Store (which at the time they were probably more restrictive, as they didn't like dynamically loaded code).</p>\n<p>I'm not sure I understand the comment about proc-macro, though.  proc-macros should only be needed if you are running rustc on iOS, which I'm pretty sure rustc doesn't support.  proc-macros should only be needed for the host.</p>",
        "id": 275128407,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647138396
    },
    {
        "content": "<p>I should maybe back up and ask: what's the deal with <code>proc-macro</code> generating a dylib? That doesn't fit my mental model of what they are. Is there something I should read before digging in here?</p>\n<p>Are you saying that support for the <code>proc-macro</code> crate type should branch on host capabilities rather than target capabilities <a href=\"https://github.com/rust-lang/rust/blob/a41a6925badac7508d7a72cc1fc20f43dc6ad75e/compiler/rustc_session/src/output.rs#L186\">like it currently does</a>? Or are you saying that when building <code>proc-macro</code> crates you should target the host even if the rest of your program targets another platform?</p>\n<p>Concretely, I'm using the Buck build system to build a project targeting iOS that depends on <a href=\"https://docs.rs/const_fn/latest/const_fn/\">const_fn</a>. Buck is telling rustc to target <code>x86_64-apple-ios</code> when building const_fn and I'm getting that error. I figured the fix would be to update the target spec, but it sounds like that might not be accurate?</p>",
        "id": 275140214,
        "sender_full_name": "Matt H",
        "timestamp": 1647158185
    },
    {
        "content": "<p>Proc macros are dynamic libraries loaded by the compiler itself. Cargo compiles them for the host, not the target. If buck compiles them for the target that is a bug in buck. Const fn is completely unrelated to const fn. There is nothing in a target spec that can prevent const fn from running. Const fn's are interpreted by miri unlike proc macros which get compiled to native code.</p>",
        "id": 275143136,
        "sender_full_name": "bjorn3",
        "timestamp": 1647162605
    },
    {
        "content": "<p>The \"const fn\" language feature works across the board, but the <code>const_fn</code> crate this project depends on is a <code>proc-macro</code> and that's what I stumbled over.</p>\n<p>I found an undocumented buck config option for making plugins/proc-macros build for the host. Thanks for your help, Eric + bjorn3!</p>\n<p>If anyone gets here later via search, <a href=\"https://github.com/rust-lang/cargo/blob/5aad9b302adc2f4cf1f184315f497fb3e3256b78/src/cargo/core/manifest.rs#L788-L791\">here's a relevant Cargo code pointer</a>.</p>",
        "id": 275180375,
        "sender_full_name": "Matt H",
        "timestamp": 1647213194
    }
]