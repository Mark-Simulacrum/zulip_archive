[
    {
        "content": "<p>Can anyone point me to the code that turns <code>{integer}</code> into a concrete type? For unsuffixed values if it matters.</p>",
        "id": 276811581,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648420456
    },
    {
        "content": "<p>I'd like to play around with the possibility of nonzero integer literals.</p>",
        "id": 276811587,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648420485
    },
    {
        "content": "<p>at what point? There's code that defaults uninferred <code>{integer}</code>s to i32, and then there's regular inference which simply equates a type variable to some concrete type the same way as every other uninferred type variable is.</p>",
        "id": 276811608,
        "sender_full_name": "nagisa",
        "timestamp": 1648420540
    },
    {
        "content": "<p>The latter, I think. I certainly don't intend on changing the fallback type <em>but</em> would like to be able to choose which type if multiple are possible. That's not a strict requirement for now, at least.</p>",
        "id": 276811675,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648420658
    },
    {
        "content": "<p>I don't know the infer code super well, but AFAIK there isn't a specific part of the code you can change here, since it just goes through the regular full blown InferCx code.</p>",
        "id": 276811783,
        "sender_full_name": "nagisa",
        "timestamp": 1648420811
    },
    {
        "content": "<p>First: I would love to have better literal functionality.</p>\n<p>Here's the (officially minor) breaking change that I expect you'll run into, though:</p>\n<p>This compiles today, as <code>{integer}</code> can only be <code>u32</code>: &lt;<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=a475948b9de717c62c31dda8f941ab33\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=a475948b9de717c62c31dda8f941ab33</a>&gt;</p>\n<p>But I suspect it would break if <code>{integer}</code> could also be <code>NonZeroU32</code>, the same way this similar example breaks when <code>{integer}</code> could be <code>u32</code> or <code>u64</code>: &lt;<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=f8803efdfbf0d1adc0999593f01e0a75\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=f8803efdfbf0d1adc0999593f01e0a75</a>&gt;</p>",
        "id": 276811790,
        "sender_full_name": "scottmcm",
        "timestamp": 1648420830
    },
    {
        "content": "<p>I absolutely expect to run into that case, which is why I mention a potential fallback (being to the zero-able integer). I know fallback is a touchy subject that's been long-considered.</p>",
        "id": 276811808,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648420914
    },
    {
        "content": "<p>I guess one way to approach this would be to tell the compiler that <code>NonZeroX</code> is an <code>{integer}</code>?</p>",
        "id": 276811855,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648420941
    },
    {
        "content": "<p>The keyword you're looking for is <code>IntVar</code> and <code>fn is_integral</code>, if you want to do that.</p>",
        "id": 276811943,
        "sender_full_name": "nagisa",
        "timestamp": 1648421117
    },
    {
        "content": "<p>Also <code>fn unify_integral_variable</code> I guess.</p>",
        "id": 276811991,
        "sender_full_name": "nagisa",
        "timestamp": 1648421166
    },
    {
        "content": "<p>Thanks. Gives me a starting point <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 276812000,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648421181
    },
    {
        "content": "<p>I think we should not allow implicit fallback to more types. Instead we could add ranges to IntVar and allow what would currently be a type mismatch error between <code>{integer}</code> and <code>NonZero</code> if the range does not contain zero. It's a bit iffy if you'd have generic nonzero types, but for the explicit ones this seems like it would not cause problems and allow literals for the nonzero types</p>",
        "id": 276845767,
        "sender_full_name": "oli",
        "timestamp": 1648458800
    },
    {
        "content": "<p>Honestly the first problem for me is figuring out how to permit nonzero literals <em>at all</em>. Fallback is a secondary thing imo.</p>",
        "id": 276915044,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648492919
    },
    {
        "content": "<p>Well, I think the place to look is <code>TypeRelation</code>. You can look at the <code>sub</code> module. Basically afaict you want to make <code>NonZeroU8</code> to be a subtype of <code>{integer}</code> if that inference var excludes zero</p>",
        "id": 276919537,
        "sender_full_name": "oli",
        "timestamp": 1648495325
    },
    {
        "content": "<p>But there may be other designs</p>",
        "id": 276919557,
        "sender_full_name": "oli",
        "timestamp": 1648495336
    },
    {
        "content": "<p>It could be done as a coercion I guess</p>",
        "id": 276919581,
        "sender_full_name": "oli",
        "timestamp": 1648495346
    },
    {
        "content": "<p>After digging around more than I care to admit, it seems like a coercion would be the simplest to implement.<br>\nAny solution will necessitate making the nonzero types becoming lang items, correct? Does this need a bootstrap before it can be used?</p>",
        "id": 277094241,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648615634
    },
    {
        "content": "<p>Any place where libstd depends on nightly changes to the compiler requires cfg(bootstrap), yes</p>",
        "id": 277094316,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648615759
    },
    {
        "content": "<p>A test does not, though, correct?</p>",
        "id": 277094675,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648616255
    },
    {
        "content": "<p>Trying to determine if I should preemptively ask for these to be lang items.</p>",
        "id": 277094681,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648616273
    },
    {
        "content": "<p>Nah, just use ui tests, then you can make them lang items whenever you need</p>",
        "id": 277096752,
        "sender_full_name": "oli",
        "timestamp": 1648618931
    },
    {
        "content": "<p>Yeah I meant UI tests, not \"regular\" tests. Thanks for the info <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 277096784,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648618967
    },
    {
        "content": "<p>Little update: it's possible! While I have not extensively tested this, a naïve implementation <strong>does</strong> work. I have managed to get this test to pass.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// compile-flags: --crate-type=lib</span>\n\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">num</span>::<span class=\"p\">{</span><span class=\"n\">NonZeroI8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NonZeroU8</span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Alpha</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"nc\">NonZeroU8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Beta</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"nc\">NonZeroI8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"nc\">NonZeroU8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"nc\">NonZeroI8</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">NonZeroU8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">NonZeroI8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Alpha</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Alpha</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Beta</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Beta</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">NonZeroU8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR expected non-zero value</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">NonZeroI8</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR expected non-zero value</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR expected non-zero value</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR expected non-zero value</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Alpha</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Alpha</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR expected non-zero value</span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Beta</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Beta</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR expected non-zero value</span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277237639,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648707528
    },
    {
        "content": "<p>Cool!</p>",
        "id": 277237983,
        "sender_full_name": "oli",
        "timestamp": 1648707826
    },
    {
        "content": "<p>Obviously needs an RFC and far more thorough testing, but it's neat to see that a coercion to <code>unsafe { NonZeroX::new_unchecked(val as _) }</code> is possible.</p>",
        "id": 277238055,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648707875
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> When you have a PR you're comfortable with, let me know and I can try a crater run.</p>",
        "id": 277344890,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648763598
    },
    {
        "content": "<p>I'm impressed that it's this feasible.</p>",
        "id": 277344911,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648763612
    },
    {
        "content": "<p>I'm just completely baffled that we never thought to try coercions for custom literals... in hindsight after Jacob said how he did it it's so obvious</p>",
        "id": 277347524,
        "sender_full_name": "oli",
        "timestamp": 1648765086
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> — it's a ways off but good to know.</p>",
        "id": 277360486,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648776189
    },
    {
        "content": "<p>FWIW right now I added <strong>24</strong> new lang items (12 for the nonzero types and 12 for their constructors). What I want to do is to introduce <code>#[rustc_custom_literal]</code> attribute (name?) that would register a type with the compiler. That should largely avoid the need for new lang items.</p>",
        "id": 277360594,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648776359
    },
    {
        "content": "<p>I would love one day to have a <code>FromIntegerLiteral</code> trait or something one day, using CTFE to turn an <code>{integer}</code> literal into instance -- fallibly, so it can show an error message.  But for now a <code>rustc_*</code> attribute seems plausible (to me from the peanut gallery).</p>\n<p><em>Also, day 472 of wishing we just had one generic integer type.</em></p>",
        "id": 277366866,
        "sender_full_name": "scottmcm",
        "timestamp": 1648783812
    },
    {
        "content": "<p>One of these days, I do intend on writing an RFC for ranged integers. The benefits would be wonderful.</p>",
        "id": 277366997,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648784026
    },
    {
        "content": "<p>Problem is I have other things to do as well. Including starting a new job <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 277367062,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648784085
    },
    {
        "content": "<p>Congrats on the job!!</p>",
        "id": 277367580,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648784652
    },
    {
        "content": "<p>Instead of the new lang items, you could create a single attribute for all of them and just check if it's there. Constructing the coercion can probably be done off the destination type's info without looking up lang items (I hope)</p>",
        "id": 277383419,
        "sender_full_name": "oli",
        "timestamp": 1648801145
    },
    {
        "content": "<p>But... if you already got it working this way, I am tempted to stay with it and refactor later</p>",
        "id": 277383446,
        "sender_full_name": "oli",
        "timestamp": 1648801173
    },
    {
        "content": "<p>I think a lang item <code>FromIntegerLiteral</code> trait as <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> suggested would be the best.</p>",
        "id": 277391623,
        "sender_full_name": "bjorn3",
        "timestamp": 1648805845
    },
    {
        "content": "<p>wow, wait <span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> , would this allow a rustc driver to define a custom integer literal type??</p>",
        "id": 277394592,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648807487
    },
    {
        "content": "<p>like one for unbounded integers?</p>",
        "id": 277394605,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648807495
    },
    {
        "content": "<p>ah, I see, you haven't yet implemented <code>rustc_custom_literal</code>, if you do I would be so so happy. sorry about the ping!</p>",
        "id": 277394852,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648807631
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> not quite — unbounded integers would still have to be accepted elsewhere. Right now everything is parsed into a <code>u128</code> internally.</p>",
        "id": 277493692,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648858935
    },
    {
        "content": "<p>For those suggesting a trait, one concern I have is const compatibility. It would effectively prohibit us from stabilizing nonzero literals until <code>impl_const_trait</code> becomes stable, unless we're willing to explicitly permit the unstable expansion.</p>",
        "id": 277493856,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648859098
    },
    {
        "content": "<p>Personally I'd like to guarantee that the expansion can always be used in a const context, regardless of type.</p>",
        "id": 277493929,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648859168
    },
    {
        "content": "<p>That limitation is fine for me, I have it already with my current hacks solution</p>",
        "id": 277508646,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1648878427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"245610\">Jacob Pratt</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/.7Binteger.7D.20inference.20location/near/277493856\">said</a>:</p>\n<blockquote>\n<p>For those suggesting a trait, one concern I have is const compatibility. It would effectively prohibit us from stabilizing nonzero literals until <code>impl_const_trait</code> becomes stable, unless we're willing to explicitly permit the unstable expansion.</p>\n</blockquote>\n<p>well... more motivation for finding a way to stabilize that <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 277508975,
        "sender_full_name": "oli",
        "timestamp": 1648878887
    },
    {
        "content": "<p>Agreed, but I think it's important to note. I'd love to see <code>impl_const_trait</code> for wholly unrelated reasons.</p>",
        "id": 277509064,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648879016
    },
    {
        "content": "<p>I'm still likely to move ahead with attempting that. Namely if the types don't match <em>and</em> the target type implements the trait, expand to the fully-qualified trait method call. I am fairly certain it's possible to query if a type implements a (lang item) trait?</p>",
        "id": 277509134,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648879119
    },
    {
        "content": "<p>Yeah, look at how the <code>is_copy_raw</code> and <code>is_sized_raw</code> and such queries work.  IIRC they wrap a \"does that type implement this particular DefId\" query, and you just pass the one from the lang item.</p>",
        "id": 277510299,
        "sender_full_name": "scottmcm",
        "timestamp": 1648880752
    },
    {
        "content": "<p>neat, I wonder how much breakage would be caused by allow them in <code>#[repr(NonZeroU8)] enum</code>, etc, given macros hard coding the list of types they expect in repr.  I've got a proc macro which hacks around this ability to set NZ reprs which would be obviated by such a thing...</p>",
        "id": 277548750,
        "sender_full_name": "matt rice",
        "timestamp": 1648929741
    },
    {
        "content": "<p>I guess it probably doesn't matter, just that those macros wouldn't work with enums that currently don't exist or so...</p>",
        "id": 277548863,
        "sender_full_name": "matt rice",
        "timestamp": 1648929951
    },
    {
        "content": "<p>That wouldn't be covered by this, fyi</p>",
        "id": 277548918,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648929996
    },
    {
        "content": "<p>Indeed, just mentioning it because it would be a nice extension to it</p>",
        "id": 277548944,
        "sender_full_name": "matt rice",
        "timestamp": 1648930035
    },
    {
        "content": "<p>Note that on an <em>enum</em> you don't need <code>repr(NonZeroU8)</code>.  <code>repr(u8)</code> is fine, and it'll look at the discriminants to find the niche.</p>\n<p>(Which is the trick I'm using in <a href=\"https://github.com/rust-lang/rust/pull/95361/files#diff-48ffeec3fb2dca955c1866b0c2caa8e6e784b12efba56f9e782655f484df107dR173\">https://github.com/rust-lang/rust/pull/95361/files#diff-48ffeec3fb2dca955c1866b0c2caa8e6e784b12efba56f9e782655f484df107dR173</a>)</p>",
        "id": 277550975,
        "sender_full_name": "scottmcm",
        "timestamp": 1648932758
    },
    {
        "content": "<p>Where i've been using it, it isn't really about niche's, or compilation, but just a logical precondition that (In my case some iterator) relies on their not being a zero repr'd variant, in that regard the derive macro I wrote <code>#[derive(NonZeroRepr)</code> has actually caught bugs, and works but requires jumping through a trait to convert from <code>u8</code> to <code>NonZeroU8</code> or whatever primitive type.</p>",
        "id": 277552800,
        "sender_full_name": "matt rice",
        "timestamp": 1648935063
    },
    {
        "content": "<p>fwiw, the entirety of the proc macro <a href=\"https://github.com/ratmice/enum_extra/blob/main/derive/src/lib.rs\">https://github.com/ratmice/enum_extra/blob/main/derive/src/lib.rs</a></p>",
        "id": 277553156,
        "sender_full_name": "matt rice",
        "timestamp": 1648935553
    },
    {
        "content": "<p>The actual NonZeroRepr associated type isn't very useful, because you need to rely on trait bounds, but there aren't nonzero num traits, so I basically don't use it beyond a compile time check.</p>",
        "id": 277553331,
        "sender_full_name": "matt rice",
        "timestamp": 1648935741
    },
    {
        "content": "<p>Implementation question! I need to construct <code>&lt;NonZeroX as FromIntegerLiteral&gt;::from_integer_literal</code> to call. I have access to both <code>NonZeroX</code> and <code>FromIntegerLiteral</code> (from which I get the method). This expands to <code>&lt;Self as FromIntegerLiteral&gt;::from_integer_literal</code>, which isn't what I want — it's actually an ICE because it doesn't know what <code>Self</code> is. How can I construct <code>&lt;NonZeroX as FromIntegerLiteral&gt;::from_integer_literal</code>?</p>\n<p>What I currently have:</p>\n<ul>\n<li><code>DefId</code> for <code>FromIntegerLiteral</code> trait</li>\n<li><code>DefId</code> for <code>FromIntegerLiteral::from_integer_literal</code></li>\n<li><code>DefId</code> for <code>NonZeroX</code> (this is the target type of the coercion/adjustment</li>\n<li><code>DefId</code> for <code>X</code> (I don't think this is needed here)</li>\n</ul>",
        "id": 277588322,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648970141
    },
    {
        "content": "<p>Unrelated question that is likely for <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>. The trait returns <code>Result&lt;Self, &amp;'static str&gt;</code>. The error value is intended to be used for diagnostics. Is it possible to have const eval evaluate the expression and get the <code>Result</code> back? The trait definition I have is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FromIntegerLiteral</span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Input</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// this is what the compiler will pass</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from_integer_literal</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Input</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Am I approaching this the correct way in general?</p>",
        "id": 277588677,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648970345
    },
    {
        "content": "<p>I think you need to substitute the call with substs containing only the NonZeroX type</p>",
        "id": 277589562,
        "sender_full_name": "oli",
        "timestamp": 1648970798
    },
    {
        "content": "<p>Is this parsing always happening at compile time? In that case, maybe make the trait generic over a <code>const LITERAL: u128</code> for now and use an associated const instead of a method</p>",
        "id": 277589753,
        "sender_full_name": "oli",
        "timestamp": 1648970901
    },
    {
        "content": "<p>Call as in this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fn_call</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">method_callee</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">hir_expr</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">span</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">((</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">from_integer_literal_method_did</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">ty</span>::<span class=\"n\">List</span>::<span class=\"n\">identity_for_item</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">tcx</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">adjustment</span><span class=\"p\">.</span><span class=\"n\">target</span><span class=\"p\">.</span><span class=\"n\">ty_adt_def</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">did</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That's what I had originally and it's still ICE'ing. My suspicion is that it's doing <code>&lt;Self as FromIntegerLiteral&gt;::from_integer_literal::&lt;NonZeroX&gt;</code>, which isn't what I want.</p>",
        "id": 277589983,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971056
    },
    {
        "content": "<p>And yes, my intent is for it to <em>always</em> be done at compile-time. That way the type validation can be done in the relevant library as opposed to the compiler.</p>",
        "id": 277590021,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971091
    },
    {
        "content": "<p>The library code would just have a choice of which integer type the compiler would pass as a parameter.</p>",
        "id": 277590111,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971125
    },
    {
        "content": "<p>Right</p>",
        "id": 277590130,
        "sender_full_name": "oli",
        "timestamp": 1648971139
    },
    {
        "content": "<p>Hmm</p>",
        "id": 277590150,
        "sender_full_name": "oli",
        "timestamp": 1648971151
    },
    {
        "content": "<p>We don't have a good infrastructure for this yet</p>",
        "id": 277590171,
        "sender_full_name": "oli",
        "timestamp": 1648971164
    },
    {
        "content": "<p>Intuitively it feels like the same problem as having proc macros in the same crate (in terms of diagnostics)</p>",
        "id": 277590216,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971194
    },
    {
        "content": "<p>The best I can come up with right now would be to add a new const eval intrinsic that unwraps a result and specially prints the string</p>",
        "id": 277590242,
        "sender_full_name": "oli",
        "timestamp": 1648971215
    },
    {
        "content": "<p>Well for now you can just do a const panic and live with weird diagnostics</p>",
        "id": 277590272,
        "sender_full_name": "oli",
        "timestamp": 1648971238
    },
    {
        "content": "<p>We can figure out the diagnostics later</p>",
        "id": 277590334,
        "sender_full_name": "oli",
        "timestamp": 1648971257
    },
    {
        "content": "<p>I thought of const panic, but that doesn't seem ideal. Intrinsic is an interesting possibility.</p>",
        "id": 277590335,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971258
    },
    {
        "content": "<p>We can use this as the proving ground for improving const panic diagnostics</p>",
        "id": 277590417,
        "sender_full_name": "oli",
        "timestamp": 1648971314
    },
    {
        "content": "<p>On your ICE problem I'll have to have a look at your current code</p>",
        "id": 277590552,
        "sender_full_name": "oli",
        "timestamp": 1648971385
    },
    {
        "content": "<p>True. And diagnostics later is a valid point. So I'll change that, which should be quite quick. It's constructing the trait call that's the primary issue.</p>",
        "id": 277590564,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971395
    },
    {
        "content": "<p>Can you push your changes to a draft PR</p>",
        "id": 277590596,
        "sender_full_name": "oli",
        "timestamp": 1648971420
    },
    {
        "content": "<p>I was heading to bed soon, but I'll push what I have now up tomorrow/today.</p>",
        "id": 277590610,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971429
    },
    {
        "content": "<p>Gives me a chance to make the minor signature change.</p>",
        "id": 277590645,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1648971451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"245610\">@Jacob Pratt</span> One simple way might just be to make a separate perma-unstable function be the lang item that you call.</p>\n<p>That worked great for my <code>yeet</code> experiment, at least: <a href=\"https://github.com/scottmcm/rust/commit/do-yeet#diff-55ca2bad04d574c9b9d2b0ea41dc8e3825970da85fd2fd853446e01715f1c024R342\">https://github.com/scottmcm/rust/commit/do-yeet#diff-55ca2bad04d574c9b9d2b0ea41dc8e3825970da85fd2fd853446e01715f1c024R342</a></p>",
        "id": 277656462,
        "sender_full_name": "scottmcm",
        "timestamp": 1649013916
    },
    {
        "content": "<p>I just pushed up my attempt so far: <a href=\"https://github.com/jhpratt/rust/tree/nonzero-literals2\">https://github.com/jhpratt/rust/tree/nonzero-literals2</a></p>",
        "id": 277667858,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649029351
    },
    {
        "content": "<p>Making a separate helper function resulted in the same error. It's a matter of how to provide the generic type, I think.</p>",
        "id": 277667889,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649029421
    },
    {
        "content": "<p>I think what should work is to not provide the type at all and instead use an inference var</p>",
        "id": 277695637,
        "sender_full_name": "oli",
        "timestamp": 1649059776
    },
    {
        "content": "<p>You wouldn't even have to check if the target type implements the trait</p>",
        "id": 277695678,
        "sender_full_name": "oli",
        "timestamp": 1649059799
    },
    {
        "content": "<p>Just always lower to the function call if it's not a primitive type</p>",
        "id": 277695743,
        "sender_full_name": "oli",
        "timestamp": 1649059820
    },
    {
        "content": "<p>How would that work? The adjustment has to return <code>ExprKind</code>, which is in thir.</p>",
        "id": 277822457,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649127982
    },
    {
        "content": "<p>Oooh, that's where you're doing this. I thought this was still in typeck's coercion code.</p>\n<p>Yea, you need to fetch the real type, but that should be available due to being the expression's type. What type are you using and what is the exact ICE you're getting?</p>",
        "id": 277829939,
        "sender_full_name": "oli",
        "timestamp": 1649137387
    },
    {
        "content": "<p>I'm on mobile now, but the ICE has something to do with it being generic. I could double back into the coercion code if it makes more sense there? I'd have to check the types to see what's possible.</p>",
        "id": 277830798,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649138030
    },
    {
        "content": "<p>The code I currently have (which is what's pushed up) is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fn_call</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">method_callee</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">hir_expr</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">span</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">((</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">from_integer_literal_method_did</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">ty</span>::<span class=\"n\">List</span>::<span class=\"n\">identity_for_item</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">tcx</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">adjustment</span><span class=\"p\">.</span><span class=\"n\">target</span><span class=\"p\">.</span><span class=\"n\">ty_adt_def</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">().</span><span class=\"n\">did</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">fn_call</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fn_call</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">thir</span><span class=\"p\">.</span><span class=\"n\">exprs</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">fn_call</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With the result of that being logged:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>[compiler/rustc_mir_build/src/thir/cx/expr.rs:160] &amp;fn_call = Expr {\n    ty: {\"message\":\"compiler/rustc_middle/src/ty/subst.rs:634:17: type parameter `T/#0` (T/0) out of range when substituting, substs=[]\",\"code\":null,\"level\":\"error: internal compiler error\",\"spans\":[{\"file_name\":\"/home/jhpratt/code/rust/src/test/ui/inference/nonzero-literal-runtime.rs\",\"byte_start\":0,\"byte_end\":0,\"line_start\":1,\"line_end\":1,\"column_start\":1,\"column_end\":1,\"is_primary\":true,\"text\":[],\"label\":null,\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"error: internal compiler error: compiler/rustc_middle/src/ty/subst.rs:634:17: type parameter `T/#0` (T/0) out of range when substituting, substs=[]\\n\\n\"}\nthread 'rustc' panicked at 'Box&lt;dyn Any&gt;', /home/jhpratt/code/rust/compiler/rustc_errors/src/lib.rs:1223:9\nstack backtrace:\n   0:     0x7f995873a2c3 - &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt::h2f808f62c293eacc\n   1:     0x7f99587c3f8e - core::fmt::write::h1a03e421df9a5c87\n(rest appears to be the backtrace for write, which is irrelevant)\n</code></pre></div>\n<p>I tried your suggestion of building it in the coercion part, but I don't see how to get the <em>value</em> of the type. Nor do I see how I could lower the HIR code I manually built to the necessary MIR (in this part of code, which is what's necessary).</p>",
        "id": 277973797,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649218526
    },
    {
        "content": "<p>The JSON formatted:</p>\n<div class=\"codehilite\" data-code-language=\"JSON\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">\"message\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"compiler/rustc_middle/src/ty/subst.rs:634:17: type parameter `T/#0` (T/0) out of range when substituting, substs=[]\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">\"code\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">\"level\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"error: internal compiler error\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">\"spans\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"file_name\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"/home/jhpratt/code/rust/src/test/ui/inference/nonzero-literal-runtime.rs\"</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"byte_start\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"byte_end\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"line_start\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"line_end\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"column_start\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"column_end\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"is_primary\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"text\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[],</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"label\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"suggested_replacement\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"suggestion_applicability\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nt\">\"expansion\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">\"children\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nt\">\"rendered\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"error: internal compiler error: compiler/rustc_middle/src/ty/subst.rs:634:17: type parameter `T/#0` (T/0) out of range when substituting, substs=[]\\n\\n\"</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277973845,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649218574
    },
    {
        "content": "<p>The identity for item builds generics for the type, not the method. I think you just want a single element list that contains <code>adjustment.target</code>?</p>",
        "id": 277977148,
        "sender_full_name": "oli",
        "timestamp": 1649222938
    },
    {
        "content": "<p>How do I create that? That's the problem I was running into that led me to what I have now. The method signature is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">method_callee</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">expr</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Expr</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">span</span>: <span class=\"nc\">Span</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">overloaded_callee</span>: <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"n\">DefId</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">SubstsRef</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Expr</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277977484,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649223377
    },
    {
        "content": "<p>Hmm... if I read this right you should just use <code>None</code></p>",
        "id": 277978240,
        "sender_full_name": "oli",
        "timestamp": 1649224438
    },
    {
        "content": "<p>The only place using Some is Deref: <a href=\"https://github.com/rust-lang/rust/blob/a40c595695bff3bfb373a8a3355ae4bd4ea64608/compiler/rustc_mir_build/src/thir/cx/expr.rs#L127\">https://github.com/rust-lang/rust/blob/a40c595695bff3bfb373a8a3355ae4bd4ea64608/compiler/rustc_mir_build/src/thir/cx/expr.rs#L127</a></p>",
        "id": 277978312,
        "sender_full_name": "oli",
        "timestamp": 1649224500
    },
    {
        "content": "<p>Trying that now. I'd have sworn I tried it previously.</p>",
        "id": 277978325,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649224526
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error: internal compiler error: compiler/rustc_mir_build/src/thir/cx/expr.rs:865:25: no type-dependent def for method callee\n  --&gt; /home/jhpratt/code/rust/src/test/ui/inference/nonzero-literal-runtime.rs:15:22\n   |\nLL | const _: NonZeroU8 = 1;\n   |                      ^\n\nthread 'rustc' panicked at 'Box&lt;dyn Any&gt;', /home/jhpratt/code/rust/compiler/rustc_errors/src/lib.rs:1223:9\n</code></pre></div>",
        "id": 277978443,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649224665
    },
    {
        "content": "<p>Wait I think it's because I'm using <code>hir_expr</code> as a parameter to <code>method_callee</code></p>",
        "id": 277978644,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649224818
    },
    {
        "content": "<p>Should be the lang item method I think</p>",
        "id": 277978685,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649224839
    },
    {
        "content": "<p>Anyways headed to bed right now. I'll look at it tomorrow</p>",
        "id": 277978827,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1649224960
    }
]