[
    {
        "content": "<p>With the help of <code>-Z time-passes</code>, my colleagues and I discovered that a significant portion of rustc time is spent in <code>macro_expand</code> when re-compiling crates in our codebase.</p>\n<p>We'd like some advice for how to diagnose what's slow with our macro expansion. We already checked that we are compiling proc_macro crates with -O3 (both our own crates and third-party dependencies). We tried running Linux <code>perf</code> on rustc and generating a flamegraph, but a large portion of the captured stacks were in <code>[unknown]</code> functions. We also tried <code>-Z self-profile</code>, but that did not provide nearly enough granularity.</p>",
        "id": 273366907,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1645914789
    },
    {
        "content": "<p>We weren't terribly shocked by all the <code>[unknown]</code> symbols in the flamegraph, because we know that there's <em>something</em> weird about how proc_macros are invoked by rustc. I would really love to learn more about how that works, I couldn't find any resources online about how rustc actually invokes proc_macros after a quick search.</p>",
        "id": 273366983,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1645914895
    },
    {
        "content": "<p>Did you enable debuginfo for the proc macro?</p>",
        "id": 273368390,
        "sender_full_name": "bjorn3",
        "timestamp": 1645916665
    },
    {
        "content": "<p>Proc macros are loaded by rustc using a regular dlopen call.</p>",
        "id": 273368399,
        "sender_full_name": "bjorn3",
        "timestamp": 1645916680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435059\">Ben Reeves</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Profiling.20proc_macros/near/273366983\">said</a>:</p>\n<blockquote>\n<p>I would really love to learn more about how that works, I couldn't find any resources online about how rustc actually invokes proc_macros after a quick search.</p>\n</blockquote>\n<p>Unfortunately I don't think there is much written about it.  As bjorn3 mentioned, it is just a dylib that gets loaded with dlopen. There is a C ABI that is used for serializing/deserializing the tokens as they are transferred to the proc-macro.  There are some comments scattered in the <a href=\"https://github.com/rust-lang/rust/blob/master/library/proc_macro/src/bridge/mod.rs\"><code>bridge</code></a> module that somewhat explain how things work, and the client/server architecture.</p>",
        "id": 273369233,
        "sender_full_name": "Eric Huss",
        "timestamp": 1645917966
    }
]