[
    {
        "content": "<p>I'm trying to fortify the detection of recursive calls for MIR inlining. The current implementation works well for shallow call chains, but ICEs for longer call chains: normalization failure or failure to resolve trait bounds.  Consider <a href=\"https://godbolt.org/z/bnjGdq15q\">https://godbolt.org/z/bnjGdq15q</a>, extracted from <code>rustc_query_system</code>.  The ICE happens when trying find recursive calls in <code>get_query</code>. My understanding is:</p>\n<ul>\n<li><code>get_query&lt;Q, T&gt;</code> has a param_env which proves the call to <code>try_execute_query&lt;&lt;Q as Query&gt;::C&gt;</code> is well-formed;</li>\n<li>the call to <code>mk_cycle</code> is resolved as <code>mk_cycle&lt;&lt;&lt;Q as Query&gt;::C as Cache&gt;::V</code> and normalized to <code>mk_cycle&lt;&lt;Q as Query&gt;::V&gt;</code>;</li>\n<li>when attempting to resolve the call to <code>store_nocache</code>, trait selection attempts to verify <code>&lt;&lt;Q as Query&gt;::V as Debug&gt;</code> and fails.</li>\n</ul>\n<p>One solution would be to keep track of <code>try_execute_query</code> and <code>mk_cycle</code>'s param envs when recursing.  This would introduce the required bound in the param-env for the resolution of <code>store_nocache</code>.  However, this creates duplicated bounds and I'm not confident how to clean-up everything.<br>\nIs there a better solution?</p>",
        "id": 264625596,
        "sender_full_name": "cjgillot",
        "timestamp": 1639318541
    },
    {
        "content": "<p>(And duplicate bounds creates another ICE in instance resolution because it's ambiguous.)</p>",
        "id": 264625728,
        "sender_full_name": "cjgillot",
        "timestamp": 1639318766
    },
    {
        "content": "<p>On a related note: what is the role of the <code>delay_span_bug</code> in <code>drain_fulfillment_cx_or_panic</code>?</p>",
        "id": 264649722,
        "sender_full_name": "cjgillot",
        "timestamp": 1639351590
    }
]