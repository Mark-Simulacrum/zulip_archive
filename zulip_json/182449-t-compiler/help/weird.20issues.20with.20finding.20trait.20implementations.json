[
    {
        "content": "<p>Summarizing the major points from <a href=\"https://discordapp.com/channels/442252698964721669/459149231702278154/734115963082899517\">https://discordapp.com/channels/442252698964721669/459149231702278154/734115963082899517</a>:</p>\n<ul>\n<li><code>all_impls</code> isn't returning all the impls (in particular, it's certainly missing <code>impl Into&lt;String&gt; for String</code>)</li>\n<li><code>inherent_impls</code> is returning an impl not found by <code>all_impls</code>: <code>DefId(5:3595 ~ alloc[b674]::string[0]::{{impl}}[0])</code></li>\n<li>I can't give you a better name for that impl because trying to do so panics: <code>error: internal compiler error: src/librustc_middle/ty/mod.rs:2925:21: item_name: no name for DefPath { data: [DisambiguatedDefPathData { data: TypeNs(\"string\"), disambiguator: 0 }, DisambiguatedDefPathData { data: Impl, disambiguator: 0 }], krate: crate5 }</code></li>\n</ul>\n<p>Any ideas?</p>",
        "id": 204313086,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595098330
    },
    {
        "content": "<p>for context, we're trying to fix a bug where <code>String::from</code> doesn't resolve in intra-doc links</p>",
        "id": 204313095,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595098348
    },
    {
        "content": "<p>oh hold on I think I need to call <code>trait_id_of_impl</code> to print the name</p>",
        "id": 204313166,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595098492
    },
    {
        "content": "<p>I figured this out, see vaguely <a href=\"https://discordapp.com/channels/442252698964721669/459149231702278154/734122117095882783\">https://discordapp.com/channels/442252698964721669/459149231702278154/734122117095882783</a></p>",
        "id": 204317061,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595105260
    },
    {
        "content": "<p>ok it turns out the issue is that <code>all_impls</code> takes a _trait_, not a _type_</p>",
        "id": 204319788,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595109644
    },
    {
        "content": "<p>is there a cheap way to get all traits that a _type_ implements?</p>",
        "id": 204319793,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595109654
    },
    {
        "content": "<p>the best I've found is going through every trait from every crate one at a time which doesn't seem right</p>",
        "id": 204319806,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595109676
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> in case you're still wondering: it is right. although I already linked this on Discord: <a href=\"https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src/librustc_trait_selection/traits/error_reporting/mod.rs#L1395-L1414\">https://github.com/rust-lang/rust/blob/d7f94516345a36ddfcd68cbdf1df835d356795c3/src/librustc_trait_selection/traits/error_reporting/mod.rs#L1395-L1414</a></p>",
        "id": 204381571,
        "sender_full_name": "eddyb",
        "timestamp": 1595212523
    },
    {
        "content": "<p>I was actually just starting to work on this again haha</p>",
        "id": 204381578,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212545
    },
    {
        "content": "<p>this seems kind of slow?</p>",
        "id": 204381580,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212560
    },
    {
        "content": "<p>the situation with inherent impls is the wrong one, actually. when you say \"type\" you presumably mean a <code>struct</code>/<code>enum</code>/<code>union</code>, right?</p>",
        "id": 204381618,
        "sender_full_name": "eddyb",
        "timestamp": 1595212575
    },
    {
        "content": "<p>right</p>",
        "id": 204381620,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212589
    },
    {
        "content": "<p>(I think)</p>",
        "id": 204381623,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212596
    },
    {
        "content": "<p>anything that <code>Type::item</code> is valid for</p>",
        "id": 204381625,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212607
    },
    {
        "content": "<p>that's not what \"implements\" a trait, and so asking for impls \"of it\" is not something fundamental(ly meaningful)</p>",
        "id": 204381626,
        "sender_full_name": "eddyb",
        "timestamp": 1595212609
    },
    {
        "content": "<p>wait, what? don't types implement traits?</p>",
        "id": 204381631,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212636
    },
    {
        "content": "<p>semantic types implement traits, and your path example is misleading because it desugars  to <code>&lt;Type&lt;..&gt;&gt;::item</code></p>",
        "id": 204381639,
        "sender_full_name": "eddyb",
        "timestamp": 1595212650
    },
    {
        "content": "<p>What's a semantic type?</p>",
        "id": 204381643,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212674
    },
    {
        "content": "<p>typesystem types. where e.g. type aliases don't matter. <code>ty::Ty</code></p>",
        "id": 204381683,
        "sender_full_name": "eddyb",
        "timestamp": 1595212691
    },
    {
        "content": "<p>the only thing that's sort of pre-typesystem about (trait) impls is the trait. that's why you can find impls by trait</p>",
        "id": 204381687,
        "sender_full_name": "eddyb",
        "timestamp": 1595212727
    },
    {
        "content": "<p>ok, so if I run <code>tcx.type_of(def_id)</code>, can I get the traits that semantic type implements?</p>",
        "id": 204381697,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212762
    },
    {
        "content": "<p>not without going through all the traits in the world, taking every single one of their impls, and comparing them against that type</p>",
        "id": 204381715,
        "sender_full_name": "eddyb",
        "timestamp": 1595212802
    },
    {
        "content": "<p>well, time to make the CPU cache very unhappy</p>",
        "id": 204381753,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212835
    },
    {
        "content": "<p>there's not really any other way the trait system <em>can</em> work, because the type can <em>any type</em></p>",
        "id": 204381757,
        "sender_full_name": "eddyb",
        "timestamp": 1595212846
    },
    {
        "content": "<p>inherent impls we've managed to keep lying for because we restrict what they can go on</p>",
        "id": 204381763,
        "sender_full_name": "eddyb",
        "timestamp": 1595212871
    },
    {
        "content": "<p>also ugh I feel like I'm explaining this very poorly</p>",
        "id": 204381767,
        "sender_full_name": "eddyb",
        "timestamp": 1595212878
    },
    {
        "content": "<p>I think I understand what you're saying</p>",
        "id": 204381784,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212902
    },
    {
        "content": "<p>if all you could write is <code>impl Trait for AStructOrEnumOrUnion</code> then yes there would make sense to be a mapping</p>",
        "id": 204381786,
        "sender_full_name": "eddyb",
        "timestamp": 1595212910
    },
    {
        "content": "<p>I'm just not understanding the design decisions that make adding this hard</p>",
        "id": 204381787,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212915
    },
    {
        "content": "<p>but you can implement a trait for <code>(&amp;i32, Vec&lt;Foo&gt;)</code></p>",
        "id": 204381826,
        "sender_full_name": "eddyb",
        "timestamp": 1595212925
    },
    {
        "content": "<p>and that doesn't have a <code>DefId</code>, it can only be represented by a<code>Ty</code></p>",
        "id": 204381828,
        "sender_full_name": "eddyb",
        "timestamp": 1595212933
    },
    {
        "content": "<p>hmm</p>",
        "id": 204381831,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212951
    },
    {
        "content": "<p>and when generics are involved, you end up with <em>patterns</em></p>",
        "id": 204381834,
        "sender_full_name": "eddyb",
        "timestamp": 1595212970
    },
    {
        "content": "<p>not in the sense of <code>Pat</code> syntax in Rust, but more abstractly</p>",
        "id": 204381848,
        "sender_full_name": "eddyb",
        "timestamp": 1595212987
    },
    {
        "content": "<p>I think I see, the query I'm imagining that goes from types to traits only works if you have a DefId</p>",
        "id": 204381849,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595212988
    },
    {
        "content": "<p>this is a shame because rustdoc will never have to deal with <code>(&amp;i32, Vec&lt;Foo&gt;)</code> :/</p>",
        "id": 204381854,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213022
    },
    {
        "content": "<p>at least not for intra links</p>",
        "id": 204381866,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213032
    },
    {
        "content": "<p>anyway, the <code>for_each_relevant_impl</code> query does a compromise: for each trait we cache the list of impls partitioned by a \"simplified type\"</p>",
        "id": 204381907,
        "sender_full_name": "eddyb",
        "timestamp": 1595213056
    },
    {
        "content": "<p>(and if one is impossible to derive from the semantic type, it's treated as \"blanket\". so every time you look for a specific <code>struct</code>'s impl, you'll get all the e.g. <code>impl&lt;T&gt; From&lt;Foo&gt; for T</code> impls)</p>",
        "id": 204381922,
        "sender_full_name": "eddyb",
        "timestamp": 1595213118
    },
    {
        "content": "<p>(because there's no way to tell you <em>don't</em> want those impls)</p>",
        "id": 204381924,
        "sender_full_name": "eddyb",
        "timestamp": 1595213131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> okay waking up enough to formulate the other constraints: the crate graph can form \"diamonds\"</p>",
        "id": 204381937,
        "sender_full_name": "eddyb",
        "timestamp": 1595213160
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>    a\n  /   \\\n b     c\n  \\   /\n    d\n</code></pre></div>",
        "id": 204381983,
        "sender_full_name": "eddyb",
        "timestamp": 1595213182
    },
    {
        "content": "<p>this sort of shape of dependencies</p>",
        "id": 204381984,
        "sender_full_name": "eddyb",
        "timestamp": 1595213189
    },
    {
        "content": "<p>sure</p>",
        "id": 204381988,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213206
    },
    {
        "content": "<p>so you can't do arbitrary indexing <em>even with</em> the \"simplified types\" trick</p>",
        "id": 204382001,
        "sender_full_name": "eddyb",
        "timestamp": 1595213234
    },
    {
        "content": "<p>without putting a lot of work on every crate to combine together all the traits' impls into one big indexed map</p>",
        "id": 204382024,
        "sender_full_name": "eddyb",
        "timestamp": 1595213281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> furthermore, this is <em>never</em> needed (outside of diagnostics), as you either have to name the trait or have it in scope, in order to use it, normally</p>",
        "id": 204382069,
        "sender_full_name": "eddyb",
        "timestamp": 1595213311
    },
    {
        "content": "<p>because a downstream crate can implement a local trait for a foreign type, right</p>",
        "id": 204382070,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213317
    },
    {
        "content": "<p>ok it's starting to make sense why this can't be done cheaply</p>",
        "id": 204382076,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213329
    },
    {
        "content": "<p>ideally we'd have a very fancy pattern-indexed thing. and maybe Chalk can do some of that (not sure), but it would likely still be partitioned by traits just because of how much less effort that makes things</p>",
        "id": 204382092,
        "sender_full_name": "eddyb",
        "timestamp": 1595213374
    },
    {
        "content": "<p>sorry for starting at the (arguably) wrong tail-end of this</p>",
        "id": 204382093,
        "sender_full_name": "eddyb",
        "timestamp": 1595213382
    },
    {
        "content": "<p>you're good, I was doing some code munging in the meantime</p>",
        "id": 204382098,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213396
    },
    {
        "content": "<p>adding back inherent impls since apparently it was very incorrect to remove those lookups lol</p>",
        "id": 204382171,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213463
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> oh btw it's not an ambiguity to have both inherent and trait available. the inherent will always take precedence</p>",
        "id": 204382177,
        "sender_full_name": "eddyb",
        "timestamp": 1595213495
    },
    {
        "content": "<p>(and you specify the trait one by <code>Trait::method</code> or <code>&lt;T as Trait&gt;::method</code> etc.)</p>",
        "id": 204382181,
        "sender_full_name": "eddyb",
        "timestamp": 1595213510
    },
    {
        "content": "<p>the issue is that rustdoc doesn't currently support <code>&lt;T as Trait&gt;</code></p>",
        "id": 204382193,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213521
    },
    {
        "content": "<p>so you probably want to use that same logic</p>",
        "id": 204382229,
        "sender_full_name": "eddyb",
        "timestamp": 1595213523
    },
    {
        "content": "<p>so even though it's not ambiguous in the language it's ambiguous in the context of intra-doc links</p>",
        "id": 204382242,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213532
    },
    {
        "content": "<p>well, no, the trait one should just not be reachable :P</p>",
        "id": 204382245,
        "sender_full_name": "eddyb",
        "timestamp": 1595213553
    },
    {
        "content": "<p>well yeah but that's not ideal either lol</p>",
        "id": 204382252,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213569
    },
    {
        "content": "<p>unless you have examples where this is a problem?</p>",
        "id": 204382254,
        "sender_full_name": "eddyb",
        "timestamp": 1595213571
    },
    {
        "content": "<p>it just seems unfortunate to have an item that's unreachable</p>",
        "id": 204382265,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595213593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> so I see two ways this is currently done: in <code>rustc_trait_selection::error_reporting</code> it calls <code>all_traits</code>, then <code>for_each_relevant_impl</code> on each trait. But in <code>rustdoc::collect_trait_impls</code> it calls <code>all_trait_implementations</code> instead: <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustdoc/passes/collect_trait_impls.rs#L30\">https://github.com/rust-lang/rust/blob/master/src/librustdoc/passes/collect_trait_impls.rs#L30</a>. Which should I use?</p>",
        "id": 204382572,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214121
    },
    {
        "content": "<p>I'll go with <code>for_each_relevant_impl</code> since you said it was indexed by the type</p>",
        "id": 204382638,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214234
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> <code>all_trait_implementations</code> doesn't give you <em>any</em> indexing so yeah</p>",
        "id": 204382640,
        "sender_full_name": "eddyb",
        "timestamp": 1595214240
    },
    {
        "content": "<p>actually I can filter this even more by skipping traits that don't have this associated item</p>",
        "id": 204382721,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214359
    },
    {
        "content": "<p>so then I don't need to look at each impl unless it's relevant</p>",
        "id": 204382760,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214369
    },
    {
        "content": "<p>I kinda doubt <code>all_trait_implementations</code> is that useful now that I think about it hmm, since it shouldn't be slower to iterate the traits (since the total work is still linear in the number of total impls)</p>",
        "id": 204382766,
        "sender_full_name": "eddyb",
        "timestamp": 1595214396
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> ah yeah! I remember suggesting that on Discord :P</p>",
        "id": 204382776,
        "sender_full_name": "eddyb",
        "timestamp": 1595214406
    },
    {
        "content": "<p>the error reporting code filters by confusable trait path but in your case, the associated item is relevant</p>",
        "id": 204382784,
        "sender_full_name": "eddyb",
        "timestamp": 1595214429
    },
    {
        "content": "<p>great minds think alike :P</p>",
        "id": 204382785,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214431
    },
    {
        "content": "<p>I'd use <code>associated_items()</code> for that?</p>",
        "id": 204382789,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214468
    },
    {
        "content": "<p>I think so? make sure it has an API to query by name</p>",
        "id": 204382830,
        "sender_full_name": "eddyb",
        "timestamp": 1595214494
    },
    {
        "content": "<p>so that you don't have to iterate all the associated items before getting to look at their names</p>",
        "id": 204382838,
        "sender_full_name": "eddyb",
        "timestamp": 1595214513
    },
    {
        "content": "<p>yup: <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.AssociatedItems.html#method.filter_by_name\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.AssociatedItems.html#method.filter_by_name</a></p>",
        "id": 204382843,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214527
    },
    {
        "content": "<p>uh oh</p>\n<blockquote>\n<p>Multiple items may have the same name if they are in different Namespaces. For example, an associated type can have the same name as a method. Use one of the find_by_name_and_* methods below if you know which item you are looking for.</p>\n</blockquote>",
        "id": 204382860,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214584
    },
    {
        "content": "<p>you should use <code>.filter_by_name_unhygienic(name).next().is_some()</code></p>",
        "id": 204382905,
        "sender_full_name": "eddyb",
        "timestamp": 1595214604
    },
    {
        "content": "<p>actually I already have a namespace argument so this works out</p>",
        "id": 204382907,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214607
    },
    {
        "content": "<p>oh you do? hmm</p>",
        "id": 204382909,
        "sender_full_name": "eddyb",
        "timestamp": 1595214614
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I need the AssocKind of the item, not just that it exists</p>",
        "id": 204382911,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214622
    },
    {
        "content": "<p>I still think you need to use the the unhygienic variant</p>",
        "id": 204382916,
        "sender_full_name": "eddyb",
        "timestamp": 1595214637
    },
    {
        "content": "<p>but you could try to pass the <code>DefId</code> of the item being documented as <code>parent_def_id</code> if you can?</p>",
        "id": 204382923,
        "sender_full_name": "eddyb",
        "timestamp": 1595214657
    },
    {
        "content": "<p>what's the difference between hygenic and unhygenic here?</p>",
        "id": 204382926,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214663
    },
    {
        "content": "<p>macro hygiene</p>",
        "id": 204382929,
        "sender_full_name": "eddyb",
        "timestamp": 1595214669
    },
    {
        "content": "<p>specifically for the case here of associated items, macros 2.0 (<code>macro foo {...}</code> or <code>macro foo(...) {...}</code>), not <code>macro_rules!</code></p>",
        "id": 204382938,
        "sender_full_name": "eddyb",
        "timestamp": 1595214704
    },
    {
        "content": "<p>shouldn't parent_def_id be that of the trait?</p>",
        "id": 204382980,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214726
    },
    {
        "content": "<p>I doubt it's the parent of the associated item, since the associated item knows that itself</p>",
        "id": 204382987,
        "sender_full_name": "eddyb",
        "timestamp": 1595214750
    },
    {
        "content": "<p>ugh I might be wrong</p>",
        "id": 204382998,
        "sender_full_name": "eddyb",
        "timestamp": 1595214779
    },
    {
        "content": "<p>the docs for this are non-existent lol</p>",
        "id": 204383003,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214793
    },
    {
        "content": "<p>you have to guess from the types</p>",
        "id": 204383004,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595214797
    },
    {
        "content": "<p>yeah calls pass the trait <code>DefId</code>. I don't understand why though</p>",
        "id": 204383008,
        "sender_full_name": "eddyb",
        "timestamp": 1595214810
    },
    {
        "content": "<p>like <code>AssociatedItems</code> could just contain that <code>DefId</code> if looking it up seems too expensive</p>",
        "id": 204383085,
        "sender_full_name": "eddyb",
        "timestamp": 1595214907
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> lol they're not more efficient <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/mod.rs#L277-L316\">https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/mod.rs#L277-L316</a></p>",
        "id": 204383091,
        "sender_full_name": "eddyb",
        "timestamp": 1595214956
    },
    {
        "content": "<p>so you should be fine with doing this unhygienically and filtering by namespace or w/e</p>",
        "id": 204383138,
        "sender_full_name": "eddyb",
        "timestamp": 1595214997
    },
    {
        "content": "<p><span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 204383141,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215007
    },
    {
        "content": "<p>it looks like <code>find_by_name_and_namespace</code> is what I want</p>",
        "id": 204383144,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215018
    },
    {
        "content": "<p>oh that returns a single one. okay fine :P</p>",
        "id": 204383162,
        "sender_full_name": "eddyb",
        "timestamp": 1595215065
    },
    {
        "content": "<p>this is what typeck does:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">tcx</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">associated_items</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">find_by_name_and_namespace</span><span class=\"p\">(</span><span class=\"n\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">item_name</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ns</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">def_id</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">copied</span><span class=\"p\">()</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204383206,
        "sender_full_name": "eddyb",
        "timestamp": 1595215101
    },
    {
        "content": "<p>as usual, grepping is far more useful than docs :P</p>",
        "id": 204383210,
        "sender_full_name": "eddyb",
        "timestamp": 1595215115
    },
    {
        "content": "<p>oh but you're filtering traits. so it's not like you need the <code>ty::AssocItem</code></p>",
        "id": 204383225,
        "sender_full_name": "eddyb",
        "timestamp": 1595215173
    },
    {
        "content": "<p>how do I get info about the impl once I have it?</p>",
        "id": 204383226,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215177
    },
    {
        "content": "<p>I want to know what type it's for</p>",
        "id": 204383229,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215184
    },
    {
        "content": "<p>once you have it from <code>for_each_relevant_impl</code>?</p>",
        "id": 204383230,
        "sender_full_name": "eddyb",
        "timestamp": 1595215189
    },
    {
        "content": "<p><code>impl_trait_ref</code> ideally but <code>impl_self_ty</code> also works IIRC</p>",
        "id": 204383272,
        "sender_full_name": "eddyb",
        "timestamp": 1595215206
    },
    {
        "content": "<p>I don't see an impl_self_ty</p>",
        "id": 204383305,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215285
    },
    {
        "content": "<p>oh right it wasn't made its own query lol</p>",
        "id": 204383350,
        "sender_full_name": "eddyb",
        "timestamp": 1595215323
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> just use <code>impl_trait_ref</code> then</p>",
        "id": 204383353,
        "sender_full_name": "eddyb",
        "timestamp": 1595215327
    },
    {
        "content": "<p>it's less confusing</p>",
        "id": 204383355,
        "sender_full_name": "eddyb",
        "timestamp": 1595215334
    },
    {
        "content": "<p>wait, why does that return an Option??</p>",
        "id": 204383356,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215335
    },
    {
        "content": "<p><code>None</code> for inherent impls</p>",
        "id": 204383366,
        "sender_full_name": "eddyb",
        "timestamp": 1595215344
    },
    {
        "content": "<p>(you can unwrap it if you found it from a trait)</p>",
        "id": 204383371,
        "sender_full_name": "eddyb",
        "timestamp": 1595215367
    },
    {
        "content": "<p>well it compiles at least</p>",
        "id": 204383577,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215703
    },
    {
        "content": "<p>let me see if it actually works</p>",
        "id": 204383578,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215707
    },
    {
        "content": "<p>it's just as complicated as I thought btw: <a href=\"https://hastebin.com/zeviyuxuco.js\">https://hastebin.com/zeviyuxuco.js</a></p>",
        "id": 204383590,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215773
    },
    {
        "content": "<p><code>if trait_ref.self_ty() == ty {</code> will not work heh</p>",
        "id": 204383635,
        "sender_full_name": "eddyb",
        "timestamp": 1595215824
    },
    {
        "content": "<p>oh no :(</p>",
        "id": 204383637,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215839
    },
    {
        "content": "<p>in general, don't <code>==</code> on <code>Ty</code> unless it's a fast-path</p>",
        "id": 204383638,
        "sender_full_name": "eddyb",
        "timestamp": 1595215842
    },
    {
        "content": "<p>is there a deep_equals() or something?</p>",
        "id": 204383642,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215862
    },
    {
        "content": "<p>think what happens if generics are involved and the trait impl used different names for the parameters than the definition</p>",
        "id": 204383647,
        "sender_full_name": "eddyb",
        "timestamp": 1595215865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> <code>relate</code> but doubtful you need it. where'd you get the <code>ty</code></p>",
        "id": 204383650,
        "sender_full_name": "eddyb",
        "timestamp": 1595215887
    },
    {
        "content": "<p><code>tcx.type_of(def_id)</code></p>",
        "id": 204383651,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215895
    },
    {
        "content": "<p>(or worse than parameter names: the <code>impl</code> is for specific types replacing some of the parameters)</p>",
        "id": 204383656,
        "sender_full_name": "eddyb",
        "timestamp": 1595215906
    },
    {
        "content": "<p>okay so it's not an arbitrary type so you wouldn't need to do anything deep</p>",
        "id": 204383695,
        "sender_full_name": "eddyb",
        "timestamp": 1595215925
    },
    {
        "content": "<p>just check for <code>ty::Adt(def, _)</code> and compare <code>def.did</code></p>",
        "id": 204383698,
        "sender_full_name": "eddyb",
        "timestamp": 1595215945
    },
    {
        "content": "<p>this will effectively ignore blanket impls (which idk if you can do more efficiently otherwise)</p>",
        "id": 204383702,
        "sender_full_name": "eddyb",
        "timestamp": 1595215959
    },
    {
        "content": "<p>lol it failed even earlier</p>\n<div class=\"codehilite\"><pre><span></span><code>$ rustdoc +stage1 str_from.rs\nthread &#39;rustc&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `crate1`,\n right: `crate0`&#39;, src/librustc_typeck/check/method/suggest.rs:1305:9\n</code></pre></div>",
        "id": 204383704,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595215965
    },
    {
        "content": "<p>looks like <code>non_blanket_impls</code> is not exposed so there's not much you can do</p>",
        "id": 204383723,
        "sender_full_name": "eddyb",
        "timestamp": 1595216027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/weird.20issues.20with.20finding.20trait.20implementations/near/204383698\">said</a>:</p>\n<blockquote>\n<p>just check for <code>ty::Adt(def, _)</code> and compare <code>def.did</code></p>\n</blockquote>\n<p>should i also check for <code>Foreign(def)</code>?</p>",
        "id": 204383724,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216034
    },
    {
        "content": "<p>oh maybe. I keep forgetting</p>",
        "id": 204383767,
        "sender_full_name": "eddyb",
        "timestamp": 1595216044
    },
    {
        "content": "<p>also do you want to support e.g. <code>i32::method</code>?</p>",
        "id": 204383772,
        "sender_full_name": "eddyb",
        "timestamp": 1595216058
    },
    {
        "content": "<p>oh ugh I probably should</p>",
        "id": 204383793,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216089
    },
    {
        "content": "<p>even though primitives are all sorts of broken right now</p>",
        "id": 204383797,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216096
    },
    {
        "content": "<p>also you should ban this feature on type aliases</p>",
        "id": 204383798,
        "sender_full_name": "eddyb",
        "timestamp": 1595216097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> at least for the named primitives <code>==</code> will do what you need (since they have no parameters)</p>",
        "id": 204383812,
        "sender_full_name": "eddyb",
        "timestamp": 1595216126
    },
    {
        "content": "<p>(the problem with type aliases is they can be arbitrarily complicated so checking if <code>TypeAlias::method</code> would resolve in typeck requires asking the trait system nicely, which is more effort)</p>",
        "id": 204383866,
        "sender_full_name": "eddyb",
        "timestamp": 1595216174
    },
    {
        "content": "<p>yeah I just want an MVP for now lol</p>",
        "id": 204383876,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216203
    },
    {
        "content": "<p>since before it was so broken it depended where in the crate you put the link lol</p>",
        "id": 204383882,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216218
    },
    {
        "content": "<p>so you can do <code>==</code> and fallback to comparing <code>ty::Adt</code>s</p>",
        "id": 204383884,
        "sender_full_name": "eddyb",
        "timestamp": 1595216221
    },
    {
        "content": "<p>how's this?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"w\">                    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">trait_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">impl_trait_ref</span><span class=\"p\">(</span><span class=\"n\">impl_</span><span class=\"p\">).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">&quot;this is not an inherent impl&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"c1\">// Check if these are the same type.</span>\n<span class=\"w\">                    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">impl_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">trait_ref</span><span class=\"p\">.</span><span class=\"n\">self_ty</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"c1\">// Fast path: if this is a primitive simple `==` will work</span>\n<span class=\"w\">                    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">same_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">impl_type</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">impl_type</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"c1\">// Check if these are the same def_id</span>\n<span class=\"w\">                        </span><span class=\"n\">TyKind</span>::<span class=\"n\">Adt</span><span class=\"p\">(</span><span class=\"n\">def</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">def</span><span class=\"p\">.</span><span class=\"n\">did</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">TyKind</span>::<span class=\"n\">Foreign</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">def_id</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204384006,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216425
    },
    {
        "content": "<p>does that not warn about unnecessary parens? :P</p>",
        "id": 204384011,
        "sender_full_name": "eddyb",
        "timestamp": 1595216444
    },
    {
        "content": "<p>I don't want to remember whether == or || has higher precedence lol</p>",
        "id": 204384018,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216461
    },
    {
        "content": "<p><code>||</code> and <code>&amp;&amp;</code>  can't mess with comparisons</p>",
        "id": 204384025,
        "sender_full_name": "eddyb",
        "timestamp": 1595216475
    },
    {
        "content": "<p>ok same panic as before</p>",
        "id": 204384027,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216476
    },
    {
        "content": "<p>(unsurprisingly)</p>",
        "id": 204384030,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216484
    },
    {
        "content": "<p>since <code>if</code> conditions are <code>||</code> of <code>&amp;&amp;</code> of comparisons, without parens, lol</p>",
        "id": 204384031,
        "sender_full_name": "eddyb",
        "timestamp": 1595216485
    },
    {
        "content": "<p>like that's what they're \"optimized\" for :P</p>",
        "id": 204384037,
        "sender_full_name": "eddyb",
        "timestamp": 1595216501
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>thread &#39;rustc&#39; panicked at &#39;assertion failed: `(left == right)`\n  left: `crate1`,\n right: `crate0`&#39;, src/librustc_typeck/check/method/suggest.rs:1305:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\nquery stack during panic:\n#0 [all_traits] fetching all foreign and local traits\nend of query stack\n</code></pre></div>",
        "id": 204384084,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> wait how are you calling that? the suggestions code uses <code>all_traits(LOCAL_CRATE)</code></p>",
        "id": 204384097,
        "sender_full_name": "eddyb",
        "timestamp": 1595216576
    },
    {
        "content": "<p>... please don't tell me this only works for the local crate</p>",
        "id": 204384100,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216586
    },
    {
        "content": "<p>it's a nulary query</p>",
        "id": 204384105,
        "sender_full_name": "eddyb",
        "timestamp": 1595216601
    },
    {
        "content": "<p>oh wait we only care about traits available for the current crate</p>",
        "id": 204384106,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216604
    },
    {
        "content": "<p>we should just make it <code>tcx.all_traits()</code> but nobody has done it yet</p>",
        "id": 204384108,
        "sender_full_name": "eddyb",
        "timestamp": 1595216619
    },
    {
        "content": "<p>... why would it take a parameter if it's just going to ignore it lol</p>",
        "id": 204384109,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216620
    },
    {
        "content": "<p>ok yeah</p>",
        "id": 204384110,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216627
    },
    {
        "content": "<p>because queries started out as a macro making memoization cleaner :P</p>",
        "id": 204384111,
        "sender_full_name": "eddyb",
        "timestamp": 1595216638
    },
    {
        "content": "<p>and it has to figure out which crate to compute the query \"relative to\"</p>",
        "id": 204384153,
        "sender_full_name": "eddyb",
        "timestamp": 1595216651
    },
    {
        "content": "<blockquote>\n<p>warning: <code>[std::collections::BTreeMap::into_iter]</code> cannot be resolved, ignoring it.</p>\n</blockquote>\n<p>great</p>",
        "id": 204384246,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595216847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/weird.20issues.20with.20finding.20trait.20implementations/near/204383812\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> at least for the named primitives <code>==</code> will do what you need (since they have no parameters)</p>\n</blockquote>\n<p>hold on, primitives don't have a def_id</p>",
        "id": 204384349,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217020
    },
    {
        "content": "<p>so since I got the type from a def id it will never be a primitive</p>",
        "id": 204384353,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217028
    },
    {
        "content": "<p>so you're just not supporting them, right :P</p>",
        "id": 204384359,
        "sender_full_name": "eddyb",
        "timestamp": 1595217064
    },
    {
        "content": "<p>works for me</p>",
        "id": 204384365,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217071
    },
    {
        "content": "<p>if you start with a <code>Res</code>, you should be able to support them</p>",
        "id": 204384370,
        "sender_full_name": "eddyb",
        "timestamp": 1595217087
    },
    {
        "content": "<p>(by handling cases other than <code>Res::Def</code>)</p>",
        "id": 204384374,
        "sender_full_name": "eddyb",
        "timestamp": 1595217098
    },
    {
        "content": "<p>ah yup you're right</p>",
        "id": 204384380,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217117
    },
    {
        "content": "<p>I'll fix it up later</p>",
        "id": 204384381,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217120
    },
    {
        "content": "<p>ooh I just realized, even though into_iter doesn't work the explicit impl did :) <code>impl MyTrait for MyType</code></p>",
        "id": 204384449,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217213
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// See [S::method]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">T1</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// [S::method] on method</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204384454,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217241
    },
    {
        "content": "<p>add a type parameter, curious if that works</p>",
        "id": 204384492,
        "sender_full_name": "eddyb",
        "timestamp": 1595217260
    },
    {
        "content": "<p>and/or a trait from a different crate</p>",
        "id": 204384493,
        "sender_full_name": "eddyb",
        "timestamp": 1595217267
    },
    {
        "content": "<p>different crate definitely doesn't work</p>\n<blockquote>\n<p>warning: <code>[std::collections::BTreeMap::into_iter]</code> cannot be resolved, ignoring it.</p>\n</blockquote>",
        "id": 204384497,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217281
    },
    {
        "content": "<p>not like that, in your test</p>",
        "id": 204384498,
        "sender_full_name": "eddyb",
        "timestamp": 1595217300
    },
    {
        "content": "<p>assume that the most general case is hopelessly broken in 3 different ways</p>",
        "id": 204384502,
        "sender_full_name": "eddyb",
        "timestamp": 1595217309
    },
    {
        "content": "<p>so test things one at a time</p>",
        "id": 204384503,
        "sender_full_name": "eddyb",
        "timestamp": 1595217314
    },
    {
        "content": "<p>I see</p>",
        "id": 204384505,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217327
    },
    {
        "content": "<p>like, modify one variable at a time. that <code>BTreeMap</code> example has alloc type, core trait, and the type is generic,</p>",
        "id": 204384508,
        "sender_full_name": "eddyb",
        "timestamp": 1595217349
    },
    {
        "content": "<p>this also fails:</p>\n<div class=\"codehilite\"><pre><span></span><code>/// Link to [S], [S::clone]\npub struct S;\n\nimpl Clone for S {\n    fn clone(&amp;self) -&gt; Self {\n        S\n    }\n}\n</code></pre></div>",
        "id": 204384579,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217454
    },
    {
        "content": "<p>this is worrying</p>",
        "id": 204384582,
        "sender_full_name": "eddyb",
        "timestamp": 1595217461
    },
    {
        "content": "<blockquote>\n<p>warning: <code>[S::clone]</code> cannot be resolved, ignoring it.</p>\n</blockquote>",
        "id": 204384583,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217462
    },
    {
        "content": "<p>well it's looking at the items so it's probably a bug in my code</p>\n<div class=\"codehilite\"><pre><span></span><code>[DEBUG rustdoc::passes::collect_intra_doc_links] considering explicit impl for trait DefId(2:1636 ~ core[92f6]::clone[0]::Clone[0])\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering item (DefId(2:1637 ~ core[92f6]::clone[0]::Clone[0]::clone[0]), Fn)\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type &amp;T\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type &amp;mut T\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type S\n</code></pre></div>",
        "id": 204384632,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217515
    },
    {
        "content": "<p>ugh <code>all_traits</code> is implemented by diagnostic logic, this is worrying</p>",
        "id": 204384636,
        "sender_full_name": "eddyb",
        "timestamp": 1595217540
    },
    {
        "content": "<p>maybe I need to check more type kinds?</p>",
        "id": 204384643,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217546
    },
    {
        "content": "<p>but it does handle cross-crate</p>",
        "id": 204384644,
        "sender_full_name": "eddyb",
        "timestamp": 1595217554
    },
    {
        "content": "<p><code>struct</code> is <code>ty::Adt</code> though</p>",
        "id": 204384648,
        "sender_full_name": "eddyb",
        "timestamp": 1595217561
    },
    {
        "content": "<p>let me use debug printing for the types</p>",
        "id": 204384649,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217562
    },
    {
        "content": "<p>that does nothing</p>",
        "id": 204384657,
        "sender_full_name": "eddyb",
        "timestamp": 1595217589
    },
    {
        "content": "<p>you can at most name your struct something that's not confusable. but assuming it's <code>S</code> it should work</p>",
        "id": 204384704,
        "sender_full_name": "eddyb",
        "timestamp": 1595217608
    },
    {
        "content": "<p>also, <code>s/TyKind::/ty::</code>, idk why you don't get an internal warning for that</p>",
        "id": 204384733,
        "sender_full_name": "eddyb",
        "timestamp": 1595217675
    },
    {
        "content": "<p>you are correct that debug printing does nothing</p>",
        "id": 204384737,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217683
    },
    {
        "content": "<p>I changed the name to <code>MyStruct</code> but basically the same as before</p>\n<div class=\"codehilite\"><pre><span></span><code>[DEBUG rustdoc::passes::collect_intra_doc_links] considering explicit impl for trait\nDefId(2:1636 ~ core[92f6]::clone[0]::Clone[0])\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering item (DefId(2:1637 ~ cor\ne[92f6]::clone[0]::Clone[0]::clone[0]), Fn)\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type &amp;T\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type &amp;mut T\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type MyStruct\n</code></pre></div>",
        "id": 204384742,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217707
    },
    {
        "content": "<p>okay I think I know what the problem is</p>",
        "id": 204384746,
        "sender_full_name": "eddyb",
        "timestamp": 1595217719
    },
    {
        "content": "<p>make it <code>struct MyStruct { foo: () }</code></p>",
        "id": 204384787,
        "sender_full_name": "eddyb",
        "timestamp": 1595217730
    },
    {
        "content": "<p>that might just work</p>",
        "id": 204384789,
        "sender_full_name": "eddyb",
        "timestamp": 1595217734
    },
    {
        "content": "<p>still breaks :(</p>",
        "id": 204384810,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217802
    },
    {
        "content": "<p>although if it wasn't the right <code>DefId</code>- oh right, <code>type_of(ctor_def_id)</code> for an unit constructor still gives you the original type</p>",
        "id": 204384816,
        "sender_full_name": "eddyb",
        "timestamp": 1595217817
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>[DEBUG rustdoc::passes::collect_intra_doc_links] considering explicit impl for trait\nDefId(2:1636 ~ core[92f6]::clone[0]::Clone[0])\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering item (DefId(2:1637 ~ cor\ne[92f6]::clone[0]::Clone[0]::clone[0]), Fn)\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type &amp;T with kind Ref(ReEarlyBound(0, &#39;_), T, Not)\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type &amp;mut T with kind Ref(ReEarlyBound(0, &#39;_), T, Mut)\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering type MyStruct with kind Adt(MyStruct, [])\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code><span class=\"sd\">/// Link to [MyStruct], [MyStruct::clone]</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">MyStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyStruct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">MyStruct</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204384819,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217834
    },
    {
        "content": "<p>okay print the <code>Res</code> / <code>DefId</code> you're starting from</p>",
        "id": 204384820,
        "sender_full_name": "eddyb",
        "timestamp": 1595217835
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> there really isn't anything else the type can be. the <code>DefId</code> you have however might be not the <code>struct</code> one</p>",
        "id": 204384873,
        "sender_full_name": "eddyb",
        "timestamp": 1595217879
    },
    {
        "content": "<p>but rather <code>S</code>'s unit constructor</p>",
        "id": 204384878,
        "sender_full_name": "eddyb",
        "timestamp": 1595217891
    },
    {
        "content": "<p>however, why would local trait work</p>",
        "id": 204384886,
        "sender_full_name": "eddyb",
        "timestamp": 1595217902
    },
    {
        "content": "<p>ohh</p>",
        "id": 204384894,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217921
    },
    {
        "content": "<p>wait yeah that's confusing</p>",
        "id": 204384899,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217938
    },
    {
        "content": "<p>just print it, we'll know when we see it</p>",
        "id": 204384904,
        "sender_full_name": "eddyb",
        "timestamp": 1595217950
    },
    {
        "content": "<p>(it might only affect the <code>struct MyStruct;</code> case)</p>",
        "id": 204384946,
        "sender_full_name": "eddyb",
        "timestamp": 1595217965
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>[DEBUG rustdoc::passes::collect_intra_doc_links] comparing type MyStruct with kind Adt(MyStruct, []) against def_id DefId(0:3 ~ str_from[8787]::MyStruct[0])\n</code></pre></div>",
        "id": 204384953,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217979
    },
    {
        "content": "<p>looks right to me?</p>",
        "id": 204384959,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595217997
    },
    {
        "content": "<p>okay just print the <code>DefId</code> in the <code>ty::Adt</code>, and also the comparison result</p>",
        "id": 204384965,
        "sender_full_name": "eddyb",
        "timestamp": 1595218010
    },
    {
        "content": "<p>this is for <code>pub struct MyStruct { foo: () }</code></p>",
        "id": 204384967,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218012
    },
    {
        "content": "<p>how sure are you that the comparison <em>doesn't</em> succeed?</p>",
        "id": 204384971,
        "sender_full_name": "eddyb",
        "timestamp": 1595218028
    },
    {
        "content": "<p>heck it's not generic, the <code>==</code> will likely work :P</p>",
        "id": 204384975,
        "sender_full_name": "eddyb",
        "timestamp": 1595218034
    },
    {
        "content": "<p>yeah even if constructors were involved, <code>impl_self_ty == ty</code> would return <code>true</code>, sorry for the derail</p>",
        "id": 204384983,
        "sender_full_name": "eddyb",
        "timestamp": 1595218072
    },
    {
        "content": "<p>so it must be something else that's breaking it</p>",
        "id": 204384997,
        "sender_full_name": "eddyb",
        "timestamp": 1595218082
    },
    {
        "content": "<p>watch me accidentally forget to add it to the candidates or something lol</p>",
        "id": 204385029,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218104
    },
    {
        "content": "<p>here's the code so I have more eyes on it:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">trait_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">impl_trait_ref</span><span class=\"p\">(</span><span class=\"n\">impl_</span><span class=\"p\">).</span><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"s\">&quot;this is not an inherent impl&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"c1\">// Check if these are the same type.</span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">impl_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">trait_ref</span><span class=\"p\">.</span><span class=\"n\">self_ty</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">debug</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;comparing type {} with kind {:?} against def_id {:?}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">impl_type</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">impl_type</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"c1\">// Fast path: if this is a primitive simple `==` will work</span>\n<span class=\"w\">                </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">same_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">impl_type</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">ty</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">impl_type</span><span class=\"p\">.</span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"c1\">// Check if these are the same def_id</span>\n<span class=\"w\">                    </span><span class=\"n\">TyKind</span>::<span class=\"n\">Adt</span><span class=\"p\">(</span><span class=\"n\">def</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">debug</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;adt did: {:?}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">def</span><span class=\"p\">.</span><span class=\"n\">did</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"n\">def</span><span class=\"p\">.</span><span class=\"n\">did</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">TyKind</span>::<span class=\"n\">Foreign</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">def_id</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">did</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">same_type</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"c1\">// We found it!</span>\n<span class=\"w\">                    </span><span class=\"n\">debug</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;found a match!&quot;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">candidates</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">assoc_item</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204385037,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218131
    },
    {
        "content": "<p>and then at the end</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"w\">    </span><span class=\"c1\">// Cleanup and go home</span>\n<span class=\"w\">    </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">candidates</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204385046,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218150
    },
    {
        "content": "<p>oh god damn it</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">rustdoc</span>::<span class=\"n\">passes</span>::<span class=\"n\">collect_intra_doc_links</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">comparing</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">MyStruct</span><span class=\"w\"> </span><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"n\">kind</span><span class=\"w\"> </span><span class=\"n\">Ad</span><span class=\"w\"></span>\n<span class=\"n\">t</span><span class=\"p\">(</span><span class=\"n\">MyStruct</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[])</span><span class=\"w\"> </span><span class=\"n\">against</span><span class=\"w\"> </span><span class=\"n\">def_id</span><span class=\"w\"> </span><span class=\"n\">DefId</span><span class=\"p\">(</span><span class=\"mi\">0</span>:<span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">~</span><span class=\"w\"> </span><span class=\"n\">str_from</span><span class=\"p\">[</span><span class=\"mi\">8787</span><span class=\"p\">]</span>::<span class=\"n\">MyStruct</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"p\">[</span><span class=\"n\">DEBUG</span><span class=\"w\"> </span><span class=\"n\">rustdoc</span>::<span class=\"n\">passes</span>::<span class=\"n\">collect_intra_doc_links</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">found</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"o\">!</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204385051,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218180
    },
    {
        "content": "<p>so it's a bug somewhere else lol</p>",
        "id": 204385054,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218190
    },
    {
        "content": "<p>there we go</p>",
        "id": 204385107,
        "sender_full_name": "eddyb",
        "timestamp": 1595218251
    },
    {
        "content": "<p>wait wtf</p>",
        "id": 204385169,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218344
    },
    {
        "content": "<p>my debugging isn't showing up outside this function</p>",
        "id": 204385170,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218350
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>                    // Check if item_name belogns to `impl SomeTrait for SomeItem`\n                    // This gives precedence to `impl SomeItem`:\n                    // Although having both would be ambiguous, use impl version for compat. sake.\n                    // To handle that properly resolve() would have to support\n                    // something like [`ambi_fn`](&lt;SomeStruct as SomeTrait&gt;::ambi_fn)\n                    if kind.is_none() {\n                        kind = resolve_associated_trait_item(did, item_name, ns, &amp;self.cx)?;\n                    }\n                    debug!(&quot;got associated item kind {:?}&quot;, kind);\n</code></pre></div>",
        "id": 204385172,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218361
    },
    {
        "content": "<p>'got associated item kind' just isn't in the log at all</p>",
        "id": 204385173,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218369
    },
    {
        "content": "<p>and I only call this function from here so it's definitely running</p>",
        "id": 204385187,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218437
    },
    {
        "content": "<p>oh hold on I have a sinking suspicion that it's reporting the wrong error for multiple matches</p>",
        "id": 204385243,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218511
    },
    {
        "content": "<p>god damn it people</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">hir_id</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">as_local_hir_id</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">.</span><span class=\"n\">def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">hir_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">hir_id</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// If non-local, no need to check anything.</span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204385300,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218601
    },
    {
        "content": "<p>this is in the error reporting for an ambiguous link</p>",
        "id": 204385303,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218618
    },
    {
        "content": "<p>presumably <code>struct_span_lint_hir</code> has a counterpart that takes DefIds?</p>",
        "id": 204385346,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218702
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> highly suspecting <code>item.def_id</code> is not what you want to emit the lint on</p>",
        "id": 204385349,
        "sender_full_name": "eddyb",
        "timestamp": 1595218737
    },
    {
        "content": "<p>it can't possibly not be local</p>",
        "id": 204385358,
        "sender_full_name": "eddyb",
        "timestamp": 1595218752
    },
    {
        "content": "<p>this is a good point</p>",
        "id": 204385359,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218764
    },
    {
        "content": "<p>the <code>HirId</code> lints take is the thing in the local crate you want to warn about</p>",
        "id": 204385377,
        "sender_full_name": "eddyb",
        "timestamp": 1595218767
    },
    {
        "content": "<p>unless it's a re-export, whic it's not</p>",
        "id": 204385381,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218769
    },
    {
        "content": "<p>then you need to pass the reexport <code>HirId</code>, or silence it</p>",
        "id": 204385385,
        "sender_full_name": "eddyb",
        "timestamp": 1595218786
    },
    {
        "content": "<p>pick your poison :P</p>",
        "id": 204385386,
        "sender_full_name": "eddyb",
        "timestamp": 1595218797
    },
    {
        "content": "<p>I'll worry about re-exports later</p>",
        "id": 204385427,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218817
    },
    {
        "content": "<p>how did that trigger here though?</p>",
        "id": 204385429,
        "sender_full_name": "eddyb",
        "timestamp": 1595218828
    },
    {
        "content": "<p>with just a local struct</p>",
        "id": 204385431,
        "sender_full_name": "eddyb",
        "timestamp": 1595218834
    },
    {
        "content": "<p>uhh apparently it didn't</p>",
        "id": 204385440,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218863
    },
    {
        "content": "<p>I'm <em>so</em> confused</p>",
        "id": 204385442,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218868
    },
    {
        "content": "<p>let me try <code>    assert!(candidates.len() &gt;= 2);</code></p>",
        "id": 204385453,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218921
    },
    {
        "content": "<p>I think it won't behave properly if there are no candidates</p>",
        "id": 204385491,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595218936
    },
    {
        "content": "<p>nope, no assertion failure</p>",
        "id": 204385510,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219023
    },
    {
        "content": "<p>ugh I hate rustdoc</p>",
        "id": 204385514,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219030
    },
    {
        "content": "<p>oh ffs</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"w\"> </span><span class=\"n\">value_ns</span>: <span class=\"nc\">match</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">resolve</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"n\">path_str</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"n\">disambiguator</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"n\">ValueNS</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"o\">&amp;</span><span class=\"n\">current_item</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"n\">base_node</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"o\">&amp;</span><span class=\"n\">extra_fragment</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">ErrorKind</span>::<span class=\"n\">AnchorFailure</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                                    </span><span class=\"n\">anchor_failure</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">item</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">ori_link</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">dox</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">link_range</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                                    </span><span class=\"k\">continue</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">ok</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                            </span><span class=\"p\">.</span><span class=\"n\">and_then</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fragment</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"c1\">// Constructors are picked up in the type namespace.</span>\n<span class=\"w\">                                </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                                    </span><span class=\"n\">Res</span>::<span class=\"n\">Def</span><span class=\"p\">(</span><span class=\"n\">DefKind</span>::<span class=\"n\">Ctor</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Res</span>::<span class=\"n\">SelfCtor</span><span class=\"p\">(</span><span class=\"o\">..</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                                    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">fragment</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">extra_fragment</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                                        </span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">fragment</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                                            </span><span class=\"c1\">// Shouldn&#39;t happen but who knows?</span>\n<span class=\"w\">                                            </span><span class=\"nb\">Some</span><span class=\"p\">((</span><span class=\"n\">res</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">fragment</span><span class=\"p\">)))</span><span class=\"w\"></span>\n<span class=\"w\">                                        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                                        </span><span class=\"p\">(</span><span class=\"n\">fragment</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fragment</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                                            </span><span class=\"nb\">Some</span><span class=\"p\">((</span><span class=\"n\">res</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fragment</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">                                        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                                    </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">                                </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 204385555,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219075
    },
    {
        "content": "<p>it completely ignores the error</p>",
        "id": 204385559,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219080
    },
    {
        "content": "<p>it assumes it was a resolution failure <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 204385564,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219088
    },
    {
        "content": "<p>let's just copy/paste 50 lines of code, that seems like a reasonable thing to do</p>",
        "id": 204385632,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219230
    },
    {
        "content": "<p>lmao there we go</p>\n<div class=\"codehilite\"><pre><span></span><code>warning: `MyStruct::clone` is an associated function, an associated function, an associated function, an associated function, and an associated function\n</code></pre></div>",
        "id": 204385690,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219312
    },
    {
        "content": "<p>well at least it's something</p>",
        "id": 204385694,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219319
    },
    {
        "content": "<p>it looks like it's considering the same trait multiple times?</p>",
        "id": 204385714,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219378
    },
    {
        "content": "<p>yeah <code>[DEBUG rustdoc::passes::collect_intra_doc_links] considering explicit impl for trait DefId(2:1636 ~ core[92f6]::clone[0]::Clone[0])</code> shows up 5 times</p>",
        "id": 204385760,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219413
    },
    {
        "content": "<p>this is coming from <code>all_traits</code></p>",
        "id": 204385762,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219426
    },
    {
        "content": "<p>I'm out of time for tonight, I'll pick this back up later</p>",
        "id": 204385775,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219483
    },
    {
        "content": "<p>WIP at <a href=\"https://github.com/rust-lang/rust/pull/74489/\">https://github.com/rust-lang/rust/pull/74489/</a> in case you're interested</p>",
        "id": 204385779,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219495
    },
    {
        "content": "<p>oh and when you get a chance do you know where to find the source for <code>all_traits</code>? All I found was the one in <code>suggest.rs</code> which itself is calling the query, so that's not it.</p>",
        "id": 204385992,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219850
    },
    {
        "content": "<p>oh it's right next to it lol, compute_all_traits</p>",
        "id": 204386039,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219903
    },
    {
        "content": "<p>but yeah I think something's buggy there</p>",
        "id": 204386049,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595219987
    },
    {
        "content": "<p>so <span class=\"user-mention\" data-user-id=\"132040\">@Manish Goregaokar</span> suggested that I give up on ambiguity errors for now until there's a way to disambiguate (<a href=\"https://github.com/rust-lang/rust/issues/74563\">https://github.com/rust-lang/rust/issues/74563</a>)</p>",
        "id": 204490799,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595283584
    },
    {
        "content": "<p>I'm currently trying to resolve associated types</p>",
        "id": 204490811,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595283595
    },
    {
        "content": "<p>but something is fishy with <code>for_each_relevant_impl</code></p>",
        "id": 204490858,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595283608
    },
    {
        "content": "<p>it definitely calls it here: <a href=\"https://github.com/rust-lang/rust/pull/74489/files#diff-2bcad7b16b56ef2ebb92f8e60ae33773R474\">https://github.com/rust-lang/rust/pull/74489/files#diff-2bcad7b16b56ef2ebb92f8e60ae33773R474</a><br>\nbecause I'm getting the debug output</p>\n<div class=\"codehilite\"><pre><span></span><code>[DEBUG rustdoc::passes::collect_intra_doc_links] looking for associated item named In\nput for item DefId(0:3 ~ str_from[8787]::MyStruct[0])\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering explicit impl for trait\nDefId(0:9 ~ str_from[8787]::T[0])\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering item (DefId(0:10 ~ str_from[8787]::T[0]::Input[0]), Type)\n[DEBUG rustdoc::passes::collect_intra_doc_links] considering explicit impl for trait DefId(0:12 ~ str_from[8787]::T1[0])\n</code></pre></div>",
        "id": 204490934,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595283697
    },
    {
        "content": "<p>but the closure is never called, it skips straight over it as if there are no trait impls!</p>",
        "id": 204490947,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595283710
    },
    {
        "content": "<p>... I'm being dumb, my test case was wrong lol</p>",
        "id": 204491062,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1595283782
    }
]