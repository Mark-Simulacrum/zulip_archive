[
    {
        "content": "<p>A big difficulty when working with async rust is not knowing up-front the cost of a migration to async (who knows if my dependencies use blocking syscalls). The second biggest difficulty is not being sure if my program will get stuck in production because I used task::spawn instead of task::spawn_blocking somewhere.</p>\n<p>Maybe this is a naive suggestion, but seems like a solveable problem. What if all io-blocking functions take <code>&amp;mut ThreadToken</code> as input while all non-blocking functions take <code>&amp;ThreadToken</code>? Here <code>ThreadToken</code> is an empty enum that doesn't implement <code>Copy</code> or <code>Clone</code> and would be unsafely be constructed only by <code>std::thread::spawn</code>.</p>\n<p>This effectively ensures at compile time that all blocking calls reserve their own thread.</p>\n<p>I would be down to build a rough demo for this. But before I dig in, I'm curious if there's existing work or a well-known reason that this is a bad idea. Or maybe an irrelevant RFC that obviates this?</p>",
        "id": 269184384,
        "sender_full_name": "Bojan Serafimov",
        "timestamp": 1643064772
    },
    {
        "content": "<p>Side note: For now let's ignore CPU-blocking functions. If we really want them in the type system, that can be done with a non-mandatory <code>&amp;mut ThreadToken</code> input argument.</p>",
        "id": 269184984,
        "sender_full_name": "Bojan Serafimov",
        "timestamp": 1643065160
    },
    {
        "content": "<p>I think this discussion might be a better fit for the standard library team in <a class=\"stream\" data-stream-id=\"219381\" href=\"/#narrow/stream/219381-t-libs\">#t-libs</a>?</p>",
        "id": 269203029,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643079448
    },
    {
        "content": "<p>Also, by \"empty enum\", I assume you mean \"empty struct\"? An empty enum has no possible values, so you'd never be able to call a function taking it as a parameter.</p>",
        "id": 269203054,
        "sender_full_name": "Noah Lev",
        "timestamp": 1643079480
    },
    {
        "content": "<p>Yes that's the point, that safe code can't instantiate an empty enum :) Only the spawn function can create the token, using some unsafe code. Playground example: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1b45843c812ae18483b75615f2f8cb5d\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1b45843c812ae18483b75615f2f8cb5d</a></p>",
        "id": 269217159,
        "sender_full_name": "Bojan Serafimov",
        "timestamp": 1643094824
    },
    {
        "content": "<p>unsafe code also cannot create a value of <code>enum Void {}</code> that is UB</p>",
        "id": 269243505,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1643110294
    },
    {
        "content": "<p>I don't see all libraries changing their APIs to take additional arguments to label effects of their functions. So I'm not sure how this would help in practice.</p>",
        "id": 269244512,
        "sender_full_name": "The 8472",
        "timestamp": 1643111003
    },
    {
        "content": "<p>It seems more like something that could be done with a linting system. Label entire crates/modules/functions as #[asynclinter::blocking] or #[asynclinter::nonblocking] (anything unlabeled can emit hint that additional annotations are needed or something) and then warn if non-blocking code calls blocking code without spawn_blocking.</p>",
        "id": 269244672,
        "sender_full_name": "The 8472",
        "timestamp": 1643111142
    }
]