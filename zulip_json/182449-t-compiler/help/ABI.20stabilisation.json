[
    {
        "content": "<p>Hi. I'm aware that this is a potentially huge topic, so I'm not expecting a definitive or exhaustive answer. The question is, what would it take for the rust ABI to be stabilised? For context, I was reading this blog series about developing a system that can integrate Rust plugins: <a href=\"https://nullderef.com/blog/plugin-start/\">https://nullderef.com/blog/plugin-start/</a> and there it mentions that even though the entire stack is Rust, because the ABI interface is unstable even between compiler runs, they had to resort to the \"C\" ABI which massively added the amount of  <code>unsafe</code> code. I have some interest in systems like these, but I do also think that being able to create system that can handle plugins with minimal <code>unsafe</code> code would be a boon for the ecosystem (along with other benefits of course). </p>\n<p>I know this is probably RFC worthy so I just wanted to ask around what people thought before diving into that. This is not even something I'm remotely skilled enough to work on myself, but I did just want to start a conversation about it. Is it even remotely realistic to expect? Would people see the benefit? What kind of work would need to happen?</p>",
        "id": 258316806,
        "sender_full_name": "Sam Vente",
        "timestamp": 1634709802
    },
    {
        "content": "<p>Rust ABI is intentionally unstable</p>",
        "id": 258319998,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634712485
    },
    {
        "content": "<p>I wouldnt say its realistic to expect any time soon, same with a spec. Honestly, if ever, not even C++ has a stable ABI (cross-os/compiler). Stabilizing the ABI would be a huge amount of work and be potentially catastrophic if all of the sudden we want to change it for performance, memory use, safety, whatever. So i am personally opposed to ever stabilizing it, but having a definite list of \"this is ub, this isnt\" is certainly very helpful, but we won't see this any time soon because specs are difficult and rust is still under heavy development</p>",
        "id": 258322328,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634713918
    },
    {
        "content": "<p>besides, using the rust ABI for plugins is not a good thing anyways, because the C abi can be used by... basically all languages used by more than 20 people. While the rust ABI would not be implemented by others because theres no point, the C abi is supported by everything</p>",
        "id": 258322494,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634714016
    },
    {
        "content": "<p>Part of the issue, as well, is that a Rust ABI isn't just about \"how to pass arguments\", or even the semantics of things like lifetimes and references; the Rust ABI includes generics, and any generic function can't just be supplied as a single function pointer.</p>",
        "id": 258326132,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634716105
    },
    {
        "content": "<p>When a Rust crate exposes a function with generics in it, that function isn't just supplied as a linkable library to the crates consuming it.</p>",
        "id": 258326169,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634716136
    },
    {
        "content": "<p>It's supplied in a form that can be compiled with different types substituted in, and the crate linking in the function will compile a copy for any given set of generic types it uses.</p>",
        "id": 258326218,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634716174
    },
    {
        "content": "<p>There are ways around that; it'd be possible, for instance, to expose an ABI based on <code>dyn Trait</code> and runtime dispatch. That's what Swift did to provide an ABI that supports generics.</p>",
        "id": 258326298,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634716210
    },
    {
        "content": "<p>But such an ABI doesn't exist yet, and we can't stabilize something that hasn't even been written yet.</p>",
        "id": 258326332,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634716232
    },
    {
        "content": "<p>I don't think we'll ever stabilize <code>extern \"Rust\"</code>, but I personally would be in favor of stabilizing an <code>extern \"safe\"</code> or similar, which provides a superset of C, along with types like <code>Vec</code>, <code>String</code>, <code>&amp;str</code>, <code>&amp;[slices]</code>, <code>dyn Trait</code>, and a handful of other things.</p>",
        "id": 258326443,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634716307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/ABI.20stabilisation/near/258326298\">said</a>:</p>\n<blockquote>\n<p>There are ways around that; it'd be possible, for instance, to expose an ABI based on <code>dyn Trait</code> and runtime dispatch. That's what Swift did to provide an ABI that supports generics.</p>\n</blockquote>\n<p>wouldnt that be fundamentally impossible for a lot of cases? do you mean like being able to mark a generic function as <code>extern \"traitobj\"</code> or something like that, and having rustc error if the type cannot be made into a trait object?</p>",
        "id": 258401585,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634748404
    },
    {
        "content": "<p>I think I wouldn't want it to be automatically converted. I would want the ABI to act like extern \"C\" and complain if you use it with unsupported types.</p>",
        "id": 258442711,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634763327
    },
    {
        "content": "<p>This was a helpful read, thanks everyone :D</p>",
        "id": 258683195,
        "sender_full_name": "Sam Vente",
        "timestamp": 1634893519
    }
]