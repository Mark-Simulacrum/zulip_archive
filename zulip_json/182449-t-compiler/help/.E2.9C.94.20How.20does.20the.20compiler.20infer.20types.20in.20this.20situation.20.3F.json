[
    {
        "content": "<p>In general each variable’s type starts out as a fresh unknown variable</p>",
        "id": 271544331,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568288
    },
    {
        "content": "<p>As the type checker scans the code it will apply a rule specific to each bit of syntax which will constrain those unknown types</p>",
        "id": 271544409,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568324
    },
    {
        "content": "<p>In the case of languages like Rust, those constraints may also involve trait resolution, which is another layer of rules</p>",
        "id": 271544455,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568362
    },
    {
        "content": "<p>In your example <code>à</code> starts out as an unknown, say <code>?t</code></p>",
        "id": 271544501,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568417
    },
    {
        "content": "<p>Then on the following line we see a call to <code>St::f</code>, whose type is something like <code>fn f&lt;Tr&lt;a,b&gt;&gt;(a) -&gt; b</code></p>",
        "id": 271544753,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568607
    },
    {
        "content": "<p>So we generate fresh unknowns for a and b in the type call them <code>?b</code> and <code>?c</code></p>",
        "id": 271544828,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568662
    },
    {
        "content": "<p>Then we apply the rule for calls which will unify the arguments with their expected type</p>",
        "id": 271544951,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568714
    },
    {
        "content": "<p>So we get a constraint saying that <code>?a = ?b</code></p>",
        "id": 271544972,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568734
    },
    {
        "content": "<p>We can continue this process to see that <code>?c = u16</code></p>",
        "id": 271545024,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568776
    },
    {
        "content": "<p>And finally we can discharge the constraint <code>Tr&lt;?b,?c&gt;</code> which I forgot to mention was generated by the call</p>",
        "id": 271545157,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568861
    },
    {
        "content": "<p>Doing so we see that <code>?b</code> must be <code>u8</code></p>",
        "id": 271545189,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568895
    },
    {
        "content": "<p>The specific algorithm rust uses is more complex and different ofc</p>",
        "id": 271545220,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568918
    },
    {
        "content": "<p>Ok so when we look at the call we store a constraint and when we see something that's part of the constraint we \"reprocess\" the constraint ?</p>",
        "id": 271545313,
        "sender_full_name": "Teln0",
        "timestamp": 1644568960
    },
    {
        "content": "<p>Xavier is correct, but while they were giving their explanation, I had already mostly written this out...... so this is my take (added some places in code if you want to dig):</p>\n<ol>\n<li>\n<p>First, we need to determine what trait that method call corresponds to. Not exactly sure what the rules are, but inherent methods are preferred, and if a two traits apply to a type, we just give up and say it's ambiguous. <br>\n believe that is handled in <code>rustc_typeck::check::method::probe</code>.</p>\n</li>\n<li>\n<p>Once we have determined that <code>St::f</code> means <code>&lt;St as Tr&lt;_, _&gt;&gt;::f</code>, then we take the function signature according to the trait, give it fresh inference variables, and use the types we gave to the method call to infer those type variables. <br>\nI believe this is handled somewhere in <code>rustc_typeck::check::callee</code> (<code>confirm_overloaded_call</code>?)<br>\nIn this case, it doesn't really give us much information, since the only relevant type is a number, but we don't know what _kind_ of number.</p>\n</li>\n<li>\n<p>We continue typechecking, and eventually end up learning that the return type is constrained by the let statement. Substituting that, we have <code>St</code> must implement <code>Tr&lt;_, u16&gt;</code>. </p>\n</li>\n</ol>\n<p>To prove that, we do trait selection.</p>\n<ol start=\"4\">\n<li>\n<p>During trait selection, we gather all of the relevant impls that might apply to our type. We process through this list of impls, removing ones that we can prove will never apply (because types are not compatible). <br>\nThis all lives in <code>rustc_trait_selection::traits::select</code>. <br>\nSpecifically in <code>rustc_trait_selection::traits::select::candidate_assembly</code>.<br>\nIf there's only one obvious <code>impl</code> left, we \"confirm\" it by adding any extra where clauses it might then imply to our required list of things to solve.<br>\nThis lives in <code>rustc_trait_selection::traits::select::confirm</code>.</p>\n</li>\n<li>\n<p>We iterate trait selection (\"fulfillment\") until we're done solving the program. In this case, the impl has no extra where clauses, so we're done.</p>\n</li>\n</ol>\n<p>In reality, there's a bit more complication. Trait selection and type inference interleave in practice. We have to normalize things like projection types too, and then things like closures, dyn unsizing, etc all add extra layers.</p>",
        "id": 271545327,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1644568971
    },
    {
        "content": "<p>But if you want to learn the basics of this kind of stuff, you should look for “Hindley-Milner type systems” and algorithm W</p>",
        "id": 271545336,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644568977
    },
    {
        "content": "<p>Seconded ^, understanding H-M type systems at least gives you a good foundation to understanding what's going on in the <code>rustc_typeck</code> crate.</p>",
        "id": 271545531,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1644569144
    },
    {
        "content": "<p>Thanks for the detailed answer <span class=\"user-mention\" data-user-id=\"426609\">@Michael Goulet (compiler-errors)</span>, much more precise on Rust's implementation than I could ever be.</p>",
        "id": 271545532,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644569145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312985\">Teln0</span> <a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/How.20does.20the.20compiler.20infer.20types.20in.20this.20situation.20.3F/near/271545313\">said</a>:</p>\n<blockquote>\n<p>Ok so when we look at the call we store a constraint and when we see something that's part of the constraint we \"reprocess\" the constraint ?</p>\n</blockquote>\n<p>Typically we perform inference / checking and <em>then</em> discharge all constraints</p>",
        "id": 271545600,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644569180
    },
    {
        "content": "<p>and we go back and replace all the inferred types with their answers</p>",
        "id": 271545633,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1644569205
    },
    {
        "content": "<p>Ok, I think I understand now</p>",
        "id": 271545643,
        "sender_full_name": "Teln0",
        "timestamp": 1644569215
    },
    {
        "content": "<p>Thank you very much to everyone who replied !</p>",
        "id": 271545657,
        "sender_full_name": "Teln0",
        "timestamp": 1644569225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312985\">Teln0</span> has marked this topic as resolved.</p>",
        "id": 271545916,
        "sender_full_name": "Notification Bot",
        "timestamp": 1644569435
    }
]