[
    {
        "content": "<p>I was wondering if it was possible to externalize the runtime checks added by Rust's compiler in the form of a JSON or YAML listing.Obviously it would be extremely verbose but there would be always a way to filter it to a certain compilation unit, file or group of lines.   This would be very useful for code reviews. In particular, it would have helped find this filesystem bug in the Linux kernel patched last week.</p>",
        "id": 269069082,
        "sender_full_name": "Fred",
        "timestamp": 1643010719
    },
    {
        "content": "<p>There is a long discussion on StackOverflow: <a href=\"https://stackoverflow.com/questions/70829952/what-static-code-analyzer-technique-would-have-revealed-this-unsigned-underflow\">https://stackoverflow.com/questions/70829952/what-static-code-analyzer-technique-would-have-revealed-this-unsigned-underflow</a></p>",
        "id": 269069456,
        "sender_full_name": "Fred",
        "timestamp": 1643011030
    },
    {
        "content": "<p>My end goal is to alert the peer-reviewer where there are potential problems, basically guiding the reviewer through all new potential breaks.  The reviewer could even run the listing before and after the patch and then diff them to find all new potential breaks.</p>",
        "id": 269070014,
        "sender_full_name": "Fred",
        "timestamp": 1643011415
    },
    {
        "content": "<p>This would have to mark every single use of every single arithmetic operation, so I don't know that it would be worth having at the rust level.  The reviewer can see those operations at source level.</p>\n<p>I think to be usable it'd need to be integrated into some sort of theorem proving framework where it'd only report on ones where it doesn't have static knowledge that it'll be in-bounds.  (Which would probably need a bunch of extra annotations and smart inter-procedural behaviour.)</p>",
        "id": 269071241,
        "sender_full_name": "scottmcm",
        "timestamp": 1643012263
    },
    {
        "content": "<p>But it's very true that you need to be careful with all math.  <a href=\"https://blog.rust-lang.org/2018/09/21/Security-advisory-for-std.html\">https://blog.rust-lang.org/2018/09/21/Security-advisory-for-std.html</a> was also an overflow issue -- fixed to explicitly panic for overflow instead of wrapping.</p>\n<p>Of course, it's also worth considering just enabling <code>-C overflow-checks=yes</code> even in release builds in certain kinds of code.</p>",
        "id": 269071488,
        "sender_full_name": "scottmcm",
        "timestamp": 1643012434
    },
    {
        "content": "<p>No, not every arithmetic operation, just the ones with potential for unsigned underflow. The Rust realtime checks already cover it, check the Godbolt link: <a href=\"https://godbolt.org/z/sov58TE6n\">https://godbolt.org/z/sov58TE6n</a>.  I just need a listing that is machine readable to be able to automate the peer review.</p>",
        "id": 269071645,
        "sender_full_name": "Fred",
        "timestamp": 1643012539
    },
    {
        "content": "<p>So just to stress - I'm not after overflows but underflows and other dangerous situations. Again, the Rust runtime checks already cover this, I'm not asking to add anything, just externalize.</p>",
        "id": 269071749,
        "sender_full_name": "Fred",
        "timestamp": 1643012626
    },
    {
        "content": "<p>The ask is to create a listing of the runtime checks that already exist.</p>",
        "id": 269071990,
        "sender_full_name": "Fred",
        "timestamp": 1643012764
    },
    {
        "content": "<p>I don't follow.  To rustc's middle-end, <em>every</em> unsigned subtraction has the potential for underflow -- it never does any range analysis, leaving that to LLVM.  And I don't understand how unsigned underflow is more dangerous than other kinds of overflow.</p>",
        "id": 269072009,
        "sender_full_name": "scottmcm",
        "timestamp": 1643012788
    },
    {
        "content": "<p>That said, one version of this that might work would be to use one of the ways to dump mir, and grep for <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.Rvalue.html#variant.CheckedBinaryOp\"><code>CheckedBinaryOp</code></a>.</p>",
        "id": 269072431,
        "sender_full_name": "scottmcm",
        "timestamp": 1643013078
    },
    {
        "content": "<p>So at what stage the runtime checks are added?</p>",
        "id": 269072770,
        "sender_full_name": "Fred",
        "timestamp": 1643013346
    },
    {
        "content": "<p>My goal is to create a highlighted version of the patch for review.  It would take a reviewer 5 minutes to go over 50 potential checks. It's worth it. <br>\nIf you look at when the original code was introduced in 2019, it was signed off by a senior dev at Redhat and a kernel developer. If they had such a tool, they would certainly not have missed it.</p>",
        "id": 269073251,
        "sender_full_name": "Fred",
        "timestamp": 1643013615
    },
    {
        "content": "<p><a href=\"https://github.com/torvalds/linux/commit/3e1aeb00e6d132efc151dacc062b38269bc9eccc\">https://github.com/torvalds/linux/commit/3e1aeb00e6d132efc151dacc062b38269bc9eccc</a></p>",
        "id": 269073287,
        "sender_full_name": "Fred",
        "timestamp": 1643013635
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"473848\">Fred</span> <a href=\"#narrow/stream/122652-new-members/topic/feature.20request.3A.20produce.20JSON.20listing.20of.20all.20runtime.20checks/near/269072770\">said</a>:</p>\n<blockquote>\n<p>So at what stage the runtime checks are added?</p>\n</blockquote>\n<p>Every <code>+</code> in the AST (well, HIR/HAIR, but that's not important) is lowered to <code>CheckedAdd</code> in MIR (assuming overflow checks are on), and <code>-</code> to <code>CheckedSub</code> and such.  Demo with your godbolt: &lt;<a href=\"https://godbolt.org/z/MMasb1919\">https://godbolt.org/z/MMasb1919</a>&gt;</p>\n<p>If overflow checks aren't on, then they're all lowered to the wrapping versions, and there are no checks.</p>\n<p>So maybe that'll help elaborate a bit why you're getting confusion in responses here.  There's nothing like the sanitizers going on here to add the checks -- it's just that that's what the operators do, in a one-to-one correspondence.</p>\n<p>(Sometimes LLVM can remove the checks, but that's up to it.)</p>",
        "id": 269074046,
        "sender_full_name": "scottmcm",
        "timestamp": 1643014095
    },
    {
        "content": "<p>That's very useful Scott. I mean, I'm almost going into there and coding this myself. I just need to get familiar with the Rust codebase. It's just a matter of passing an option to rustc and printing it out (to a file) every time any check is generated. It can't be that hard, right?</p>",
        "id": 269074281,
        "sender_full_name": "Fred",
        "timestamp": 1643014246
    },
    {
        "content": "<p>And here's a demonstration that the <code>CheckedAdd</code> is generated in both MIR and LLVM even when it absolutely cannot overflow: &lt;<a href=\"https://godbolt.org/z/4x6b6bjW9\">https://godbolt.org/z/4x6b6bjW9</a>&gt;</p>",
        "id": 269074527,
        "sender_full_name": "scottmcm",
        "timestamp": 1643014376
    },
    {
        "content": "<p>Which is why I'm skeptical of the value here, since it would literally just be a list of \"here's all the math operators\".</p>\n<p>So to me you could get 99.9% of the value for 0.01% of the work by having a checklist item that says \"think about over/underflow for every math operator used\".</p>",
        "id": 269074725,
        "sender_full_name": "scottmcm",
        "timestamp": 1643014503
    },
    {
        "content": "<p>Here's a code link for you, though: <a href=\"https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_mir_build/src/build/expr/as_rvalue.rs#L386\">https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_mir_build/src/build/expr/as_rvalue.rs#L386</a></p>",
        "id": 269075186,
        "sender_full_name": "scottmcm",
        "timestamp": 1643014762
    },
    {
        "content": "<p>I think there is a distinction to be made here: if pure unsigned adds overflow, you have a range problem, this is pure stupidity. In the case of an unsigned sub underflow, this is almost always a nasty overlook. In fact, unsigned subtraction should be avoided at all costs. So with such a listing I can choose to activate which checks to highlight, pretty much as we do with <code>clang-tidy -checks=-*,+modernize-*</code></p>",
        "id": 269075839,
        "sender_full_name": "Fred",
        "timestamp": 1643015078
    },
    {
        "content": "<p>So is the Rust compiler written in Rust??? WTF love it.</p>",
        "id": 269076107,
        "sender_full_name": "Fred",
        "timestamp": 1643015234
    },
    {
        "content": "<p>Alright I'm diving into this bro, thanks for the link. My next project.</p>",
        "id": 269076260,
        "sender_full_name": "Fred",
        "timestamp": 1643015303
    },
    {
        "content": "<p>If what you want is \"In fact, unsigned subtraction should be avoided at all costs\", then what you want is instead a lint for it that you can just <code>deny</code> so people never do it: &lt;<a href=\"https://rustc-dev-guide.rust-lang.org/diagnostics.html#lints\">https://rustc-dev-guide.rust-lang.org/diagnostics.html#lints</a>&gt;</p>\n<p>(And which can be <code>#[allow]</code>ed in a scope if someone <em>does</em> want to do one for some reason.)</p>",
        "id": 269076289,
        "sender_full_name": "scottmcm",
        "timestamp": 1643015319
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"473848\">Fred</span> <a href=\"#narrow/stream/122652-new-members/topic/feature.20request.3A.20produce.20JSON.20listing.20of.20all.20runtime.20checks/near/269076107\">said</a>:</p>\n<blockquote>\n<p>So is the Rust compiler written in Rust??? WTF love it.</p>\n</blockquote>\n<p>Yes.  Originally bootstrapped from an OCaml one.  (Though there's another bootstrap path via C++ that people with toolchain concerns have used to repro a bit-identical compiler.)</p>",
        "id": 269076390,
        "sender_full_name": "scottmcm",
        "timestamp": 1643015375
    },
    {
        "content": "<p>So are both paths actively maintained? The one I'm using right now on Ubuntu, what is it?</p>",
        "id": 269076600,
        "sender_full_name": "Fred",
        "timestamp": 1643015511
    },
    {
        "content": "<p>The official one is the one written in rust.  If you don't know which you're using, you're using that one.</p>\n<p>(The other one doesn't implement many of rust's checks, nor the latest version of rust, so is mostly only useful as a bootstrapping path)</p>",
        "id": 269076728,
        "sender_full_name": "scottmcm",
        "timestamp": 1643015576
    },
    {
        "content": "<p>Hey this thing is lit! Way easier than creating a clang-tidy check. I need to get into this asap. I have done a lot of lints on clang-tidy to avoid common pitfalls in trading but it's always a pita. This looks much easier.</p>",
        "id": 269076890,
        "sender_full_name": "Fred",
        "timestamp": 1643015654
    },
    {
        "content": "<p>There's also clippy, which has a whole bunch more lints: &lt;<a href=\"https://rust-lang.github.io/rust-clippy/master/index.html\">https://rust-lang.github.io/rust-clippy/master/index.html</a>&gt;</p>",
        "id": 269076959,
        "sender_full_name": "scottmcm",
        "timestamp": 1643015694
    },
    {
        "content": "<p>I used clippy but it does not bring up any of these issues, it passes clean. But you mean, perpaps it's easier to implement on a separate project than in the official rust compiler right?</p>",
        "id": 269077179,
        "sender_full_name": "Fred",
        "timestamp": 1643015797
    },
    {
        "content": "<p>The bar to get a lint into rustc tends to be higher.  I don't know which is easier.</p>",
        "id": 269077266,
        "sender_full_name": "scottmcm",
        "timestamp": 1643015843
    },
    {
        "content": "<p>No I dont expect anyone to get my amateur patch into the rust compiler, I mean it's easier to keep patching a smaller crate like clippy than the actual compiler - on my side</p>",
        "id": 269077682,
        "sender_full_name": "Fred",
        "timestamp": 1643016065
    },
    {
        "content": "<p>I was really hoping that there was a single point in the Rust compiler where all the checks were generated or reviewed so I could hook and patch with a print. But it seems that these runtime checks are all over the place?</p>",
        "id": 269078535,
        "sender_full_name": "Fred",
        "timestamp": 1643016464
    },
    {
        "content": "<p>I think you're thinking of this with a different mindset than Rust uses.</p>\n<p>It's not the C+sanitizers mental model of \"it's unsafe, but then there's this extra pass that can add checks\".  The rust model is just \"the operation is safe, so when we codegen the operation it includes the safety checks\".  And thus of course they're in multiple places, the same way that any other bits of codegen for different features will be in different places.</p>\n<p>(And then there are extra functions/intrinsics for the unchecked versions, but they're a separate thing.)</p>",
        "id": 269087084,
        "sender_full_name": "scottmcm",
        "timestamp": 1643021246
    },
    {
        "content": "<p>So I have to disagree with you there. Rust does not protect against these underflows. It is \"safe\" in the sense it does not segfault but it still generates unsafe/wrong values - as the runtime checks show.</p>",
        "id": 269087286,
        "sender_full_name": "Fred",
        "timestamp": 1643021376
    },
    {
        "content": "<p>Rust would be safe if every add and sub would be a checked one - but then it would be slow. So it's removed from release builds and it becomes unsafe.</p>",
        "id": 269087441,
        "sender_full_name": "Fred",
        "timestamp": 1643021474
    },
    {
        "content": "<p>The problem is that any arithmetic operation can overflow / underflow. The compiler doesn't really know that much more about it. So having a list of all range checks, as mentioned previously, is really just a list of every arithmetic operation in the program, which isn't very useful. (this is why these checks have to be dynamic in the first place, and why C++ sanitizers are also dynamic rather than static)</p>",
        "id": 269088139,
        "sender_full_name": "Josh Simmons",
        "timestamp": 1643021797
    },
    {
        "content": "<p>Unsigned adds are fine. But unsigned <em>subtractions</em> are always a problem. Case in hand, the patch to the Linux kernel was to remove the subtraction and write an equivalent comparison that only used additions. I'd say unsigned subtractions should be flagged always.</p>",
        "id": 269089814,
        "sender_full_name": "Fred",
        "timestamp": 1643022598
    },
    {
        "content": "<p>But we are missing the forest for the trees here. My ask is how hard it is to create a listing of all runtime checks added so the user can grep for the ones they consider dangerous. If I have a change in a file between the lines 400 and 500, I can produce this report and filter all the checks done between these lines.  A code reviewer can then look into the potential issues and decide which ones are likely to be triggered in production.</p>",
        "id": 269090215,
        "sender_full_name": "Fred",
        "timestamp": 1643022828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"473848\">Fred</span> <a href=\"#narrow/stream/122652-new-members/topic/feature.20request.3A.20produce.20JSON.20listing.20of.20all.20runtime.20checks/near/269087441\">said</a>:</p>\n<blockquote>\n<p>So it's removed from release builds and it becomes unsafe.</p>\n</blockquote>\n<p>Critical terminology nit: \"unsafe\" has a very particular meaning in rust, and wrapping math is not <em><code>unsafe</code></em>.  Prefer \"error-prone\" or similar, for what you're expressing here.</p>\n<p>And that may be how it was fixed <em>in C</em>, but that's not necessarily the best way to fix it in Rust.  In Rust it would be equally good to switch it to using <code>checked_sub</code> instead.  That might even be <em>better</em> since it would protect against overflow too.</p>",
        "id": 269091554,
        "sender_full_name": "scottmcm",
        "timestamp": 1643023565
    },
    {
        "content": "<p>You could compile with <code>-Cdebug-assertions=yes --emit mir</code> and then look for all <code>CheckedSub</code> in the produced MIR. On the same line there should be a comment with the source location to which the statement corresponds. Note that the exact format of MIR is unstable, so you may need to change your tool once in a while if you write a tool to automatically do this for you. You can also write a clippy lint which looks for CheckedSub, which wouldn't be too hard either I think.</p>",
        "id": 269091702,
        "sender_full_name": "bjorn3",
        "timestamp": 1643023662
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> is there by any chance a list of <em>all</em> runtime checks? Unsigned underflow is just one of them. Ideally I'd have all the runtime checks done by Rust in clippy but with a <code>--potential-errors</code> or something like that.</p>",
        "id": 269091959,
        "sender_full_name": "Fred",
        "timestamp": 1643023814
    },
    {
        "content": "<p>You can look for all <code>panic</code> references in code compiled with <code>-Cdebug-assertions=yes</code>.</p>",
        "id": 269092082,
        "sender_full_name": "bjorn3",
        "timestamp": 1643023900
    },
    {
        "content": "<p>This will catch all compiler inserted panics as well as all panics that are part of the source code.</p>",
        "id": 269092162,
        "sender_full_name": "bjorn3",
        "timestamp": 1643023943
    },
    {
        "content": "<p>If you also enable optimizations you won't see the ones LLVM has been able to prove as unreachable.</p>",
        "id": 269092242,
        "sender_full_name": "bjorn3",
        "timestamp": 1643023995
    },
    {
        "content": "<p>Thats useful, thank you</p>",
        "id": 269092794,
        "sender_full_name": "Fred",
        "timestamp": 1643024298
    }
]