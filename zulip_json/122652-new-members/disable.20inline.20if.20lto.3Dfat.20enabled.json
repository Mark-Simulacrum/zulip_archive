[
    {
        "content": "<p>Hi all, nice to meet you~ <br>\nAfter some search, I got the idea that \"if I enable lto=fat, then I can disable inline from rustc side\". Any catch?</p>",
        "id": 275379230,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647354150
    },
    {
        "content": "<p>The reason why I do this is, I found some case that even for functions with large body, as long as they are marked #[inline] then it will be instantiated in client crate, which actually makes the final output bloated.</p>",
        "id": 275379414,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647354241
    },
    {
        "content": "<p>There are functions in the standard library marked as inline that must only be codegened when actually used. For example the simd functions on wasm. Codegenning those when not used would force the wasm runtime to support simd even if no simd is used at all.</p>",
        "id": 275381580,
        "sender_full_name": "bjorn3",
        "timestamp": 1647355215
    },
    {
        "content": "<p>Also how would it handle mixing a libstd not compiled with -Clto=fat with a user crate compiled with -Clto=fat?</p>",
        "id": 275381697,
        "sender_full_name": "bjorn3",
        "timestamp": 1647355261
    },
    {
        "content": "<p>lto happened at link time, and the libstd actually more like a static lib/object files, so whether libstd compiled with or without lto=fat actually doesn't matter?</p>",
        "id": 275382302,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647355492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275381580\">said</a>:</p>\n<blockquote>\n<p>There are functions in the standard library marked as inline that must only be codegened when actually used. For example the simd functions on wasm. Codegenning those when not used would force the wasm runtime to support simd even if no simd is used at all.</p>\n</blockquote>\n<p>So they are marked as inline(always)?</p>",
        "id": 275382835,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647355684
    },
    {
        "content": "<p>Libstd is compiled once with both object files and with bitcode. The object files are used when lto is disabled and the bitcode when lto is enabled. The same llvm ir is used for both.</p>",
        "id": 275390597,
        "sender_full_name": "bjorn3",
        "timestamp": 1647358943
    },
    {
        "content": "<p>I don't think those functions are marked as inline(always). I think they are simply marked as inline. This is enough for current rustc as only used inline functions are actually codegened right now.</p>",
        "id": 275390726,
        "sender_full_name": "bjorn3",
        "timestamp": 1647359000
    },
    {
        "content": "<p>reading this dialogue, I'm wondering if we should have an attribute to actually say \"only codegen this if it is actually used.\" I don't think <code>inline</code> <em>or</em> <code>inline(always)</code> really convey that at all.</p>",
        "id": 275391172,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647359170
    },
    {
        "content": "<p>that would either still depend on the mono item collector implementation or force all callers to behave as if they have the attribute too.</p>",
        "id": 275395959,
        "sender_full_name": "bjorn3",
        "timestamp": 1647361017
    },
    {
        "content": "<p>I was thinking of an MIR pass which disables inline if opt-level is \"MinSize\" and lto=fat. But now it seems being blocked by the simd like functions. Despite simd like functions, any other catches? e.g: In performance wise</p>",
        "id": 275402114,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647363400
    },
    {
        "content": "<p>How about remove the #[inline] from Clone and Default deriving macro if opt-level is \"MinSize\", is it a good idea?</p>",
        "id": 275403579,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647363900
    },
    {
        "content": "<p>I think the inline attribute also adds a generic LLVM inline hint. Personally, I _really_ want this gone because <code>#[inline]</code> does two things and the codegen delay is far more influential and the fact that it does two things makes the attribute hard to explain. I would be very happy if we separated the codegen ordering property into a new attribute.</p>",
        "id": 275404826,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647364350
    },
    {
        "content": "<p>So my concern with only doing what you're suggesting is that it will cause less inlining, because the hint will be missing.</p>",
        "id": 275404908,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1647364387
    },
    {
        "content": "<p>yea, inline hint is missing, but lto=fat kinda equals tell llvm to set inline for all functions(not sure about this, pls correct me if wrong). So the final binary should be kinda similar.</p>",
        "id": 275405497,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647364649
    },
    {
        "content": "<p>Also if enable size min opt level, llvm will kick in a function outline optimize pass, which may revert what inline just did?</p>",
        "id": 275405883,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647364790
    },
    {
        "content": "<p>btw, time is late in my timezone, will come back later~ thanks for your help~</p>",
        "id": 275406473,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647365042
    },
    {
        "content": "<p>No, lto makes it possible for every function to be inlined. The inlinehint attribute tells llvm to be a bit more eager to inline functions even if it otherwise thinks doing so would not be profitable.</p>",
        "id": 275408638,
        "sender_full_name": "bjorn3",
        "timestamp": 1647366097
    },
    {
        "content": "<p>There is also the alwaysinline attribute which makes llvm disregard inlining cost completely afaik.</p>",
        "id": 275408744,
        "sender_full_name": "bjorn3",
        "timestamp": 1647366128
    },
    {
        "content": "<p>I think that is expected when optimize for size.<br>\nSo I think there are two possible follow ups:</p>\n<ol>\n<li>Add a new attribute for \"gen_at_call_site\"</li>\n<li>Remove inline attribute where applicable if opt level is SizeMin</li>\n</ol>\n<p>Is it right? I can fire a pr for 2. <br>\nFor 1, though I'd like to, but  I don't have enough knowledge to do it.</p>\n<p>EDIT: format</p>",
        "id": 275451066,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647387755
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275408638\">said</a>:</p>\n<blockquote>\n<p>No, lto makes it possible for every function to be inlined. The inlinehint attribute tells llvm to be a bit more eager to inline functions even if it otherwise thinks doing so would not be profitable.</p>\n</blockquote>\n<p>Is it possible to disable inline in rustc side, and still keep the llvm inline hint? I think it is doable, but is it a good idea?</p>",
        "id": 275458890,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647395467
    },
    {
        "content": "<p>We could definitely add an experimental -Z flag that disables just the delayed codegen but otherwise does not affect inline attributes, but wouldn't that still break the SIMD case?</p>",
        "id": 275784496,
        "sender_full_name": "oli",
        "timestamp": 1647599545
    },
    {
        "content": "<p>Maybe mark simd cases as inline(always) first?</p>",
        "id": 275784620,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647599625
    },
    {
        "content": "<p>I don't see anything wrong with that, but better ask the SIMD people first. cc <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span></p>",
        "id": 275784791,
        "sender_full_name": "oli",
        "timestamp": 1647599710
    },
    {
        "content": "<p>No, this would brutally pessimize cases where it would actually need correctly outlining.</p>",
        "id": 275893672,
        "sender_full_name": "Jubilee",
        "timestamp": 1647671859
    },
    {
        "content": "<p>The way inlining hints to LLVM work, if a function <strong>usually</strong> benefits from being inlined, and it is not <strong>obvious</strong> it should be inlined, <code>#[inline]</code> is the correct annotation, but <code>#[inline(always)]</code> never is, because in spite of being a \"hint\" that LLVM can technically ignore, it usually hits the threshold numbers in such a way that it overrides good sense and cases where LLVM would otherwise back out. And SIMD is actually not a case where it benefits from overriding inlining logic always, it just needs to be more aggressive than the default inlining heuristic LLVM uses.</p>",
        "id": 275893806,
        "sender_full_name": "Jubilee",
        "timestamp": 1647672029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"484782\">Shuo Li</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275451066\">said</a>:</p>\n<blockquote>\n<ol>\n<li>Add a new attribute for \"gen_at_call_site\"</li>\n<li>Remove inline attribute where applicable if opt level is SizeMin</li>\n</ol>\n</blockquote>\n<p>You are missing a 3rd option:<br>\nIncrease the <strong>default</strong> LLVM inlining hints generated by rustc so we can back out adding <code>#[inline]</code> everywhere.</p>",
        "id": 275894073,
        "sender_full_name": "Jubilee",
        "timestamp": 1647672429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275893672\">said</a>:</p>\n<blockquote>\n<p>No, this would brutally pessimize cases where it would actually need correctly outlining.</p>\n</blockquote>\n<p>The current case essentially means every SIMD function has a prologue and epilogue about the size of a moderately complex SIMD function itself... load from memory once per operand into SIMD registers, and then store SIMD register to mem once per return value, and then zero the tops of the registers. In the case of a simple <code>add2vecs</code> function, that's adding about four instructions, and storing/loading to the top of the stack is not an overwhelming penalty, but neither is it completely free.</p>\n<p>However, creating a massively over-heavy function via <code>#{inline(always)]</code> can result in much more punitive codegen consequences than hitting the prologue/epilogue, and <code>#[inline(always)]</code> has consistently proven to be the Wrong Choice Most Of The Time.</p>",
        "id": 275894499,
        "sender_full_name": "Jubilee",
        "timestamp": 1647673124
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275381580\">said</a>:</p>\n<blockquote>\n<p>There are functions in the standard library marked as inline that must only be codegened when actually used. For example the simd functions on wasm. Codegenning those when not used would force the wasm runtime to support simd even if no simd is used at all.</p>\n</blockquote>\n<p>From <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> 's comment, I thought inline for simd is not an optimization but a requirement. That's why I think <code>inline(always)</code> or create a new <code>codegen_at_callsite</code> is a good idea. Correct me if i'm wrong.</p>",
        "id": 275900806,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647682836
    },
    {
        "content": "<p>The inlining itself is not a requirement. The delayed codegen that is currently associated with <code>#[inline]</code> is required.</p>",
        "id": 275900904,
        "sender_full_name": "bjorn3",
        "timestamp": 1647682983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275900904\">said</a>:</p>\n<blockquote>\n<p>The inlining itself is not a requirement. The delayed codegen that is currently associated with <code>#[inline]</code> is required.</p>\n</blockquote>\n<p>Yes, that's what I mean. <br>\nHere is my understanding:</p>\n<ol>\n<li>For simd, we should create a new attribute for delayed codegen, which doesn't interfere with inline behavior. </li>\n<li>For MinSize opt level, we should omit <code>#[inline]</code> and pass through <code>#[inline(always)]</code> to reduce duplicate code in final output.</li>\n<li>If we increase LLVM inline threshold, maybe we can skip MIR inline pass and let llvm to do all inline business, so we don't need to do late codegen for <code>#[inline]</code>, still inline hint is passed to llvm.</li>\n</ol>",
        "id": 275901404,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647683647
    },
    {
        "content": "<p>If you use <code>-Copt-level=z</code> you probably want to use LTO too which allows LLVM to deduplicate functions across the whole program so <code>#[inline]</code> probably won't have any effect on the output size.</p>",
        "id": 275901656,
        "sender_full_name": "bjorn3",
        "timestamp": 1647684004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275901656\">said</a>:</p>\n<blockquote>\n<p>If you use <code>-Copt-level=z</code> you probably want to use LTO too which allows LLVM to deduplicate functions across the whole program so <code>#[inline]</code> probably won't have any effect on the output size.</p>\n</blockquote>\n<p>I tried, it didn't. Actually that is the reason why I opened the issue(<a href=\"https://github.com/rust-lang/rust/issues/94795\">https://github.com/rust-lang/rust/issues/94795</a>).</p>",
        "id": 275901772,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647684105
    },
    {
        "content": "<p>I guess maybe some MIR pass modified the body so they are not same in LLVM eyes.</p>",
        "id": 275901829,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647684162
    },
    {
        "content": "<p>I just read code in <a href=\"http://mono.rs\">mono.rs</a>, there is a function called instantiation_mode, which seems decides whether to create a local copy or use the global copy, is it a good idea we just modify this function, add a small branch that \"In MinSize mode, prefer global copy, but if the codegen required, then do LocalCopy?\"</p>",
        "id": 275913411,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647700619
    },
    {
        "content": "<p>FYI related info: <a href=\"https://users.rust-lang.org/t/enable-cross-crate-inlining-without-suggesting-inlining/55004/9\">https://users.rust-lang.org/t/enable-cross-crate-inlining-without-suggesting-inlining/55004/9</a>.</p>",
        "id": 275915100,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647703083
    },
    {
        "content": "<p><a href=\"#narrow/stream/182449-t-compiler.2Fhelp/topic/Adjusting.20inline.20logic.20to.20minimize.20code.20size\">https://rust-lang.zulipchat.com/#narrow/stream/182449-t-compiler.2Fhelp/topic/Adjusting.20inline.20logic.20to.20minimize.20code.20size</a></p>",
        "id": 275919026,
        "sender_full_name": "Jubilee",
        "timestamp": 1647709120
    },
    {
        "content": "<p>I did an experiment:</p>\n<ol>\n<li>modify <a href=\"http://mono.rs\">mono.rs</a> as</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">instantiation_mode</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tcx</span>: <span class=\"nc\">TyCtxt</span><span class=\"o\">&lt;'</span><span class=\"na\">tcx</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">InstantiationMode</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">generate_cgu_internal_copies</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">sess</span><span class=\"p\">.</span><span class=\"n\">opts</span><span class=\"p\">.</span><span class=\"n\">debugging_opts</span><span class=\"p\">.</span><span class=\"n\">inline_in_all_cgus</span><span class=\"p\">.</span><span class=\"n\">unwrap_or_else</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">sess</span><span class=\"p\">.</span><span class=\"n\">opts</span><span class=\"p\">.</span><span class=\"n\">optimize</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">OptLevel</span>::<span class=\"n\">No</span><span class=\"w\"></span>\n<span class=\"w\">                   </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">sess</span><span class=\"p\">.</span><span class=\"n\">opts</span><span class=\"p\">.</span><span class=\"n\">optimize</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"n\">OptLevel</span>::<span class=\"n\">SizeMin</span><span class=\"w\">  </span><span class=\"c1\">// also prevent local codegen for size min</span>\n<span class=\"w\">            </span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">sess</span><span class=\"p\">.</span><span class=\"n\">link_dead_code</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And build the toolchain, then link it as <code>dev</code>.</p>\n<ol start=\"2\">\n<li>then build the whole project with SizeMin optlevel with <code>nightly</code> and <code>dev</code>. <br>\nThe result looks promising, with <code>lto=thin</code>, the nightly build is smaller, with <code>lto=fat</code>, the <code>dev</code> is smaller.<br>\nAnother observation is compile time, <code>dev</code> compile time is around 2800s, and <code>nightly</code> around 3200s. <br>\nIt is not a proper benchmark, the building process is time consuming, so I just try once per build profile.</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>lib_dev_lto_thin.dylib            <span class=\"m\">75298888</span>\nlib_dev_lto_fat.dylib               <span class=\"m\">64617632</span>\nlib_nightly_lto_thin.dylib     <span class=\"m\">73419952</span>\nlib_nightly_lto_fat.dylib        <span class=\"m\">66606364</span>\n</code></pre></div>\n<p>EDIT: The compile time is from my blur memory, could be wrong.</p>",
        "id": 275943913,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647745565
    },
    {
        "content": "<p>That seems interesting. <span class=\"user-mention\" data-user-id=\"484782\">@Shuo Li</span> If you have a patch that you would like to try, feel free to open a PR. An important check will be a perf run as whatever happens can't degrade the compiler speed on normal execution significantly, and anything size-changing can do that.</p>",
        "id": 275985205,
        "sender_full_name": "Jubilee",
        "timestamp": 1647806782
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/122652-new-members/topic/disable.20inline.20if.20lto.3Dfat.20enabled/near/275985205\">said</a>:</p>\n<blockquote>\n<p>That seems interesting. <span class=\"user-mention silent\" data-user-id=\"484782\">Shuo Li</span> If you have a patch that you would like to try, feel free to open a PR. An important check will be a perf run as whatever happens can't degrade the compiler speed on normal execution significantly, and anything size-changing can do that.</p>\n</blockquote>\n<p>sure, I plan to do more test today, create a small &amp; fast demo project to see whether this is consistent. Will fire a pr later.</p>",
        "id": 276000280,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647829791
    },
    {
        "content": "<p>I can not reproduce the result for smaller projects, and I do think the whole <code>inline</code> + optimization is so COMPLEX that I not able to reason it.. In cases opt-level <code>s</code> is the smallest, even smaller than <code>z</code>.<br>\nI am trying to attack this in another angle, create a test suite that easily build existing open source project with different profile.</p>",
        "id": 276154885,
        "sender_full_name": "Shuo Li",
        "timestamp": 1647937083
    }
]