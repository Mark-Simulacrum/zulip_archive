[
    {
        "content": "<p>This seems like a lot of magic for something that's already possible :/ especially since <code>move o::method</code> already has an existing and conflicting meaning</p>",
        "id": 259362340,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635413630
    },
    {
        "content": "<p><del>Note that <code>apply(o::method)</code> already works as long as the type signatures match up, it only breaks when the closure is doing autorefs</del> nevermind, misread</p>",
        "id": 259362516,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635413717
    },
    {
        "content": "<p>Also note that <code>o</code> could already be in scope as a type, so changing it to resolve to a variable in scope instead would be a breaking change</p>",
        "id": 259362683,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635413806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/122652-new-members/topic/auto.20closure.20wrappers/near/259362683\">said</a>:</p>\n<blockquote>\n<p>Also note that <code>o</code> could already be in scope as a type, so changing it to resolve to a variable in scope instead would be a breaking change</p>\n</blockquote>\n<p>Right! It seems the only non-breaking unambiguous use of this sugar might be to resolve to <code>self</code>.</p>\n<div class=\"codehilite\"><pre><span></span><code>struct FooBarBaz{\n    fn foo(&amp;self, x:u8){}\n    fn bar&lt;F: Fn(u8)&gt;(&amp;self, f:F){ f(0u8); }\n    fn baz(&amp;self){\n        self.bar(self::foo);\n    }\n}\n</code></pre></div>",
        "id": 259364007,
        "sender_full_name": "Davydov Daniil",
        "timestamp": 1635414647
    },
    {
        "content": "<p>No, <code>self</code> already has a meaning in a type context, it's the current module</p>",
        "id": 259364378,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635414866
    },
    {
        "content": "<p>I see. Can we just add more magic to '.' operator to auto generate closure? So the first example becomes <code>x.apply(o.method)</code>? <br>\n+: <del>Its still coerces with the type with the same name in scope though.</del> '.' operator not applicable to modules\\types</p>",
        "id": 259365625,
        "sender_full_name": "Davydov Daniil",
        "timestamp": 1635415664
    },
    {
        "content": "<p>That's ambiguous if there's a <code>method</code> field on the struct.</p>\n<p>Also, I'm not sure how useful this change is, the closure isn't <em>that</em> noisy. I haven't seen people using point free notation a lot, I don't think it's something we need to encourage</p>",
        "id": 259365980,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635415831
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"453750\">@Davydov Daniil</span> I don't understand your edit, <code>o.method</code> and <code>o::method</code> resolve different items for <code>o</code></p>",
        "id": 259366081,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635415902
    },
    {
        "content": "<p>I guess we could make it behave differently depending on whether a <code>method</code> field exists or not, but that seems confusing / inconsistent</p>",
        "id": 259366675,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635416236
    },
    {
        "content": "<p>I'm missing this sugar when writing functional-style code, where less characters usually leads to better 'meaning density'(sorry, can't phrase it better) per character. <br>\nAlso, it's seems intuitive that <code>obj.method</code> should resolve to something.</p>",
        "id": 259370697,
        "sender_full_name": "Davydov Daniil",
        "timestamp": 1635418678
    },
    {
        "content": "<p>Specifically about \"are there any related discussions\": yes. There's been a lot of discussion on currying and auto-closures over the years on IRLO and elsewhere, even <a href=\"https://github.com/rust-lang/rfcs/pull/191\">going back to pre-1.0</a>. Most recently I recall a little bit of discussion <a href=\"https://twitter.com/fasterthanlime/status/1447307106202312708\">on twitter</a> with the exact syntax you're into. General impression I have is that:</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/fasterthanlime/status/1447307106202312708\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/bade379ef25ea9325a0b92fe1f438f895b6b914a/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3933363332343335383634393430353434302f6b52524f56336b665f6e6f726d616c2e6a7067\"></a><p>idk I'm kinda tired of writing\n\n`takes_closure(|arg| s.stuff(arg))`\n\ncan we make\n\n`takes_closure(s.stuff)`\n\nwork in more cases? surely that won't terribly break anything else right?</p><span>- fasterthanlime ðŸŒŒ (@fasterthanlime)</span></div></div><ul>\n<li>this is something that is vaguely but consistently wanted, but:</li>\n<li>there's lots of opinions but not a lot of consensus</li>\n<li>the technical feasibility is in the air (probably requires HKT in some form)</li>\n<li>this is not something that is sorely needed, it's a possible quality-of-life improvement that can already be reasonably approximated with not a lot more syntax (ie even though it could be another <code>?</code> moment, it's not going to be prioritised unless it's demonstrably significantly better)</li>\n</ul>",
        "id": 259370866,
        "sender_full_name": "FÃ©lix Saparelli",
        "timestamp": 1635418767
    }
]