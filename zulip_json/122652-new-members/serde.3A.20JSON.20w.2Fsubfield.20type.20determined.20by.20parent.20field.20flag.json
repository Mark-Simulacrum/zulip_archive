[
    {
        "content": "<p>Trying to deserialize the \"details\" subfield of the Item API at <a href=\"https://wiki.guildwars2.com/wiki/API:2/items\">https://wiki.guildwars2.com/wiki/API:2/items</a> - the type of the detail field varies based on the type field of the Item. I specifically only want the details if the parent type is \"Consumable\" (this is being reserialized to cache it, and I don't want code and data bloat).</p>\n<p>I don't believe a custom deserialize_with for the details field can check the flag on the parent, and I'm leery of trying to write an entire custom deserializer. I've tried a wrapper enum with a generic Item&lt;T&gt; specified by Type - I got stuck when trying to convert <code>&amp;Item&lt;ConsumableDetails&gt;</code> to <code>&amp;Item&lt;Ignore&gt;</code>. Using (Item) and (Item, ConsumableDetails) in the Enum wasn't picked up on by serde.</p>\n<p>Serde appears to switch enum types on <code>type</code> in the JSON - but I only need the child details field to change types, in practice.</p>\n<p>The below code works, though it ignores the details field. How would you add it?</p>\n<div class=\"codehilite\"><pre><span></span><code>#[derive(Debug, Serialize, Deserialize)]\npub struct Item {\n    pub id: u32,\n    pub name: String,\n    #[serde(rename = &quot;type&quot;)]\n    item_type: ItemType,\n    rarity: ItemRarity,\n    level: i32,\n    vendor_value: i32,\n    flags: Vec&lt;ItemFlag&gt;,\n    restrictions: Vec&lt;String&gt;,\n    upgrades_into: Option&lt;Vec&lt;ItemUpgrade&gt;&gt;,\n    upgrades_from: Option&lt;Vec&lt;ItemUpgrade&gt;&gt;,\n}\n</code></pre></div>\n<ul>\n<li>The entire code can be found at <a href=\"https://github.com/t-mw/gw2-arbitrage/blob/master/src/api.rs#L66\">https://github.com/t-mw/gw2-arbitrage/blob/master/src/api.rs#L66</a></li>\n</ul>",
        "id": 264263535,
        "sender_full_name": "Michael Clark",
        "timestamp": 1639033257
    },
    {
        "content": "<p>I would write a deserialize_with for the <em>Item</em> instead. With a little code duplication (though might be dedupeable, not sure), you can write a <code>#[derive(Deserialize)] struct ItemDeser { /* all fields except details */ }</code> and use that within the deserializer (so you don't have to write the whole thing), then convert it into an proper <code>Item</code>.</p>",
        "id": 264268391,
        "sender_full_name": "Félix Saparelli",
        "timestamp": 1639037922
    },
    {
        "content": "<p>Like this: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=eed35aa937bf9c5dc50bb0eba0322819\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=eed35aa937bf9c5dc50bb0eba0322819</a></p>",
        "id": 264271228,
        "sender_full_name": "Félix Saparelli",
        "timestamp": 1639039842
    },
    {
        "content": "<p>Thank you.</p>\n<p>The concept seems to work, but  won't deserialize from the bincode cache now, probably due to relying on serde_json::Value and the related warnings. As I'm a bit shaky on how the deserializer works already, I'm not sure how to fix it (and I suspect it'll be harder too).</p>\n<p>I'll keep reading the Rust book and serde docs to see if I can understand this system well enough.</p>",
        "id": 264743470,
        "sender_full_name": "Michael Clark",
        "timestamp": 1639417485
    },
    {
        "content": "<p>Is there a way to have different deserialize code run based on different input formats? The default deserializer does work fine for the bincode.</p>",
        "id": 264749935,
        "sender_full_name": "Michael Clark",
        "timestamp": 1639420130
    },
    {
        "content": "<p>I'll open this as a new question.</p>",
        "id": 264765508,
        "sender_full_name": "Michael Clark",
        "timestamp": 1639427298
    }
]