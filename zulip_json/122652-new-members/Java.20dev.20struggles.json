[
    {
        "content": "<p>Hi there! I'm a Java dev trying to learn Rust and I need some help.</p>\n<p>Obviously I'm trying to apply my Java/Spring/Dependency Injection patterns to Rust which causes me some problems.<br>\nI wrote a tiny <a href=\"https://github.com/Brutus5000/contractmanager\">command line app</a>. <br>\nApart from the main method I basically have 2 relevant services (in Java terms):<br>\nContractManager manages a Vec of contracts (struct with no impl) and the next index. You can create, remove and list items. <br>\nEventRouter manages a Vec of events (just an enum) and reads/writes events from/to disk and processes them by matching the event type and delegating them to the ContractManager (looks stupid but I plan on more events and more services)</p>\n<p>If the app starts it tries to load all historic events and replay them.<br>\nThis is where my problem started. After I load all historic events from disc I try to reprocess them (<a href=\"https://github.com/Brutus5000/contractmanager/blob/master/src/events/router.rs#L82\">code</a>.</p>\n<p>In my first iteration the contract manager required for create and remove a mutable reference to self (as it was changing the contract vec). This caused the calling method in EventRouter to also have a mutable reference to self.</p>\n<p>But when processing an event required a mutable self reference, it did not work together with iter as it required a mutable borrow, where it already borrowed.</p>\n<p>The solution was to put everything in ContractManager into RefCells so that the methods create and remove didn't need a mutable self reference. But for me this feels massively wrong. Just because an external caller has double borrow issues, I needed to modify the ContractManager.</p>\n<p>So obviously I am  not doing it \"the Rust way\". Because if I continued working like that basically everything would end up in RefCell which can't be right. But iterating a vec and doing something mutable with it is like the most simple pattern that I can think of in Java. What is the alternative here? Where is my conceptual burden from Java causing issues?</p>",
        "id": 258806593,
        "sender_full_name": "Brutus5000",
        "timestamp": 1634970089
    },
    {
        "content": "<p>There are more ways to go about this, but one would be to think about:</p>\n<ul>\n<li>does it make sense for multiple <code>EventRouter</code>s to write into the same <code>ContractStore</code>?</li>\n<li>should you be able to access the contracts while an <code>EventRouter</code> is replaying the log or doing work?</li>\n</ul>",
        "id": 258807467,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634971643
    },
    {
        "content": "<p>I think it makes sense for the <code>EventRouter</code> to own the <code>ContractStore</code>. It can provide a getter for anyone who wants to read it, but reading shouldn't happen while the store is being modified.</p>",
        "id": 258807820,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634972240
    },
    {
        "content": "<p>This doesn't fix directly the <code>replay</code>/<code>process</code> interaction, but a common approach is to:</p>\n<ul>\n<li>remove the <code>self</code> parameter from <code>process</code> (instead it take a reference to what it needs to modify, <code>ContactStore</code>)</li>\n<li>you'll still run into a capture error on <code>self</code> in the closure; there's another way around it, but the simplest solution is to change the project to the <code>2021</code> edition (just replace that in <code>Cargo.toml</code>)</li>\n</ul>",
        "id": 258807896,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634972400
    },
    {
        "content": "<p>This (<code>fn process(contract_store: &amp;mut ContractStore, event: &amp;Event)</code>) is the first solution from <a href=\"https://stackoverflow.com/a/38944523\">https://stackoverflow.com/a/38944523</a></p>",
        "id": 258808007,
        "sender_full_name": "Laurențiu",
        "timestamp": 1634972515
    },
    {
        "content": "<blockquote>\n<p>does it make sense for multiple EventRouters to write into the same ContractStore</p>\n</blockquote>\n<p>No I would say both EventRouter and ContractStore would be singletons.</p>\n<blockquote>\n<p>should you be able to access the contracts while an EventRouter is replaying the log or doing work?</p>\n</blockquote>\n<p>There is no requirement for any concurrent access.</p>",
        "id": 258820566,
        "sender_full_name": "Brutus5000",
        "timestamp": 1634991922
    }
]