[
    {
        "content": "<p>Hello everyone,</p>\n<p>I'm a master's student and I'm quite new to Rust, especially as far as the compiler itself is concerned. Currently, I'm writing my thesis on testing with Rust and I'd like to instrument Rust programs and insert additional function calls in certain branches (e.g., after if's) that trace the execution of a branch along with additional information. For this, I need the condition expressions to be atomic, which is why MIR seems to me to be most suitable.</p>\n<p>From this <a href=\"https://zulip-archive.rust-lang.org/stream/182449-t-compiler/help/topic/Modifying.20the.20MIR.20of.20a.20function.20from.20rustc_driver.html\">archive post</a>, I learned that I can modify MIR and pass the modified version back to the compiler. So what I do is run the compiler and register my own function where I modify the MIR of a function body:</p>\n<div class=\"codehilite\"><pre><span></span><code>const CUSTOM_OPT_MIR: for&lt;&#39;tcx&gt; fn(_: TyCtxt&lt;&#39;tcx&gt;, _: DefId) -&gt; &amp;&#39;tcx Body&lt;&#39;tcx&gt; = |tcx, def| {\n    let opt_mir = rustc_interface::DEFAULT_QUERY_PROVIDERS\n        .borrow()\n        .optimized_mir;\n    let mut body = opt_mir(tcx, def).clone();\n\n    let mut mir_visitor = MirVisitor { tcx };\n\n    mir_visitor.visit_body(&amp;mut body);\n    tcx.arena.alloc(body)\n};\n\nstruct CompilerCallbacks;\n\nimpl rustc_driver::Callbacks for CompilerCallbacks {\n    fn config(&amp;mut self, _config: &amp;mut Config) {\n        _config.override_queries = Some(|session, local, external| {\n            local.optimized_mir = CUSTOM_OPT_MIR;\n        });\n    }\n}\n\nfn main() {\n    // define args and stuff\n\n    let mut callbacks = CompilerCallbacks {};\n    rustc_driver::RunCompiler::new(&amp;args, &amp;mut callbacks)\n        .run()\n        .unwrap();\n}\n</code></pre></div>\n<p>Now, this seems to work. In my MirVisitor, I want to insert a function call at some point. Let's assume I have the following program I try to instrument and a dummy tracing function:</p>\n<div class=\"codehilite\"><pre><span></span><code>use\nmod monitor {\n    pub fn trace() {\n        // do something\n    }\n}\n\nfn main() {\n    let inputs: Vec&lt;u64&gt; = std::env::args()\n        .map(|a| a.parse::&lt;u64&gt;().unwrap())\n        .take(2)\n        .collect();\n    let x = *inputs.get(0).unwrap();\n    let y = *inputs.get(1).unwrap();\n\n    if x &lt; y {\n        println!(&quot;x &lt; y&quot;);\n    } else {\n        println!(&quot;x &gt;= y&quot;);\n    }\n}\n</code></pre></div>\n<p>The relevant basic block in the MIR of the main function looks like this: </p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>bb10: {\n        _12 = (*_13);\n        _19 = _6;\n        _20 = _12;\n        _18 = Lt(move _19, move _20);\n        switchInt(move _18) -&gt; [false: bb13, otherwise: bb11];\n    }\n</code></pre></div>\n<p>Now I want to call the monitor::trace function directly after that, on both control paths. A function call is a terminator, so I could insert a whole new basic block for each branch and let it point to the original descendent blocks, i.e.,</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>bb10: {\n        _12 = (*_13);\n        _19 = _6;\n        _20 = _12;\n        _18 = Lt(move _19, move _20);\n        switchInt(move _18) -&gt; [false: bb14, otherwise: bb15];\n    }\n\n\nbb14: {\n        _22 = monitor::trace() -&gt; [return: bb13, unwind: ...];\n    }\n\n\nbb15: {\n        _23 = monitor::trace() -&gt; [return: bb11, unwind: ...];\n    }\n</code></pre></div>\n<p>I understand that I will also need to add the locals, however, I don't even know how to create such an artificial function call programmatically in the first place. A part of the <a href=\"https://doc.rust-lang.org/stable/nightly-rustc/rustc_middle/mir/terminator/struct.Terminator.html\">Terminator</a> struct is a reference (ConstantKind::Ty). Hence, the basic block I initialize does not live long enough to be passed back to the compiler :( </p>\n<p>Is there a way to implement this idea anyway? Maybe in a different way? Note that I don't just want to trace coverage, but also make computations based on the runtime values used in condition expressions and so on.</p>",
        "id": 259428124,
        "sender_full_name": "Vsevolod Tymofyeyev",
        "timestamp": 1635443948
    },
    {
        "content": "<p>Consider asking in #t-compiler/wg-mir-opt, this is kind of a specialized question haha</p>",
        "id": 259432201,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1635445822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> thanks, gonna do this :)</p>",
        "id": 259432862,
        "sender_full_name": "Vsevolod Tymofyeyev",
        "timestamp": 1635446112
    }
]