[
    {
        "content": "<p>Hello everyone<br>\nAfter reading the following <a href=\"https://nullderef.com/blog/plugin-start/#_abi_unstability_its_much_worse_than_it_seems\">article</a>, I was very surprised, that apparently, rustc could change the memory layout with each recompilation and not just when using different versions of rustc. Can anybody explain, how layout stability  is upheld when linking stdlib dynamically?</p>",
        "id": 254424362,
        "sender_full_name": "Markus Ineichen",
        "timestamp": 1632338944
    },
    {
        "content": "<p>I think there's a few different aspects to this:</p>\n<ul>\n<li>The article points out that Rust doesn't <em>guarantee</em> memory layout will be compatible across different compilations. <em>In practice</em>, they will be which is where the commonly cited advice mentioned in the article comes from. </li>\n<li>The flag doesn't literally randomize layout on every recompilation. That would completely break incremental builds. Instead the random seed is deterministically generated from the crate source. Thus <em>in practice</em>, you will get the same randomized layout across two different builds of the same source. </li>\n<li>stdlib is special and can take advantage of unspecified behavior because it's part of the distribution and is intertwined with the compiler. For example, the stdlib uses specialization internally for performance even though the compiler you use is (probably) a stable compiler. For example, some parts of the stdlib are just compiler intrinsics. </li>\n<li>The flag supports cross-crate scenarios <a href=\"https://github.com/rust-lang/rust/blob/8c4e116fe1e95eed34768000eafd3fc62d9bf789/compiler/rustc_middle/src/ty/mod.rs#L1541-L1543\">https://github.com/rust-lang/rust/blob/8c4e116fe1e95eed34768000eafd3fc62d9bf789/compiler/rustc_middle/src/ty/mod.rs#L1541-L1543</a></li>\n</ul>",
        "id": 254427392,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1632340091
    },
    {
        "content": "<p>Thank you for your answer. In my project, I have an executable which loads a dylib with libloading. Both projects reference a common external library. If the executable passes a struct from that library to the dylib, everything works like charm right now, even if executable and dylib use different features of the common library. But I'm worried that it could fall back on me in the future when the codebase grows.</p>",
        "id": 254429041,
        "sender_full_name": "Markus Ineichen",
        "timestamp": 1632340729
    },
    {
        "content": "<p>Can you make that struct <code>#[repr(C)]</code>?</p>",
        "id": 254434773,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1632342887
    },
    {
        "content": "<p>No, it is an external library I have no control over. I guess it  wouldn't help if I wrap the external struct like <code>MyWrapper(ExternalNoReprC)</code>in a fourth project, right? What about passing trait objects like <code>Box&lt;dyn MyTrait&gt;</code>? Do you see any way to reliably accomplish something like that? It's quite difficult to find information about this topic.</p>",
        "id": 254441839,
        "sender_full_name": "Markus Ineichen",
        "timestamp": 1632345858
    }
]