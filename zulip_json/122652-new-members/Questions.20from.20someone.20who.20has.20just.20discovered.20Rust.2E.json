[
    {
        "content": "<p>Hi, I'm Giuseppe Palmeri, an Italian programmer. During this time I took a look at the RUST language (among the many that use LLVM) and I discovered some key features in the philosophy of the language that I really liked.</p>\n<p>I liked them a lot for 2 reasons:<br>\nThe first is that these characteristics solve practical problems and the second is that once these practical problems and the doubts that arise about them are removed, you can see beyond with a wider range of action and you can see solutions for problems that before were more laboriously practicable (Eureka!).</p>\n<p>These features are:</p>\n<ol>\n<li>Allocation and Release of memory implicitly and at the expense of the compiler;</li>\n<li>The ability to prevent concurrency on the writing of the same portion of memory by different threads (it is simply decided that this scenario cannot be possible);</li>\n<li>The concept that interfaces (in an Object Oriented context) do not necessarily have to be abstractions of the language, but also exist concretely to represent an abstraction at the application level.</li>\n</ol>\n<p>I have not gone into specific detail yet on other issues of the language, I have never used it again, but already from these 3 characteristics (without necessarily going into the merits of how they have been implemented) it seems that particularly interesting scenarios open up (in my opinion obviously ).</p>\n<p>One of these is the possibility of basing an entire Operating System on at least these 3 basic concepts of RUST. In practice, having an operating system entirely modeled on the same principles.</p>\n<p>Personally, I believe that every operating system can benefit greatly if developed in close relation to the language with which it was created.</p>\n<p>Just as I believe that the character of the operating system can only be expressed through the adoption of its own compilation language.</p>\n<p>Each framework (and an operating system can be seen as a framework referring to the kernel), at any level, can correspond to a programming language that models its decisions and the possibilities of use.</p>\n<p>Wanting to design a new operating system, one of the things that come to my mind and that I might need is the adoption of a proprietary format of executable code.</p>\n<p>A proprietary, or simply alternative, way of formatting executable code.</p>\n<p>I am not referring to an alternative file format for identifying an executable as an ELF, but rather what it might contain within it.</p>\n<p>Generally the format of the executable code is defined by standards, as well as the way in which it is loaded and executed in memory.</p>\n<p>This depends both on the architecture on which the operating system is running, on how the operating system itself was designed and on how compatible it is to be with other operating systems.</p>\n<p>At this point I can think of some questions to ask that I think it is right to ask and that concern the evolution of RUST and of LLVM more generally.</p>\n<p>The questions are:</p>\n<ol>\n<li>Does RUST provide a modeling system for the code it generates?<br>\n    Does it allow to define a proprietary ABI for library code?<br>\n    Or are these tasks exclusive to LLVM?<br>\n    To achieve this, is it possible that both LLVM and RUST need to be changed?</li>\n</ol>\n<p>An example that implies an intervention on this aspect could be that of giving the possibility or not to the code to be able to be executed as an instance of a class that implements a remote interface (which also exists on another computer in the same network).<br>\nThink of a parallel computing distributed over a network.</p>\n<p>This does not mean that new ABI standards or different DLL or Shared Objects (.so) formats could be born.</p>\n<ol start=\"2\">\n<li>Does RUST foresee a system for the development of compilable dialects of its own language in order to be able to deal with more specific and dedicated problems?</li>\n</ol>\n<p>For example, there could be a compiler dialect that derives from RUST which deals with the modeling of peripheral drivers only.</p>\n<p>In addition to these questions, I would like to know if an Italian translation of his book is planned for RUST: <a href=\"https://doc.rust-lang.org/stable/book/\">https://doc.rust-lang.org/stable/book/</a>.</p>\n<p>Also, I would like to know if there is a list of desirable libraries for RUST that have not already been implemented.<br>\nThere are libraries to handle XML, JSON, FTP or HTTP.<br>\nWhat other libraries do we feel the need for?</p>\n<p>Thanks to those who want to answer my questions.<br>\nI also apologize for my English if it doesn't sound perfect to you.</p>",
        "id": 227131018,
        "sender_full_name": "Giuseppe Palmeri",
        "timestamp": 1613868882
    },
    {
        "content": "<p>Hello! I'm not really the one to answer this, but Rust doesn't have a stable ABI (yet?). It has its own ABI, but it's not stable across different compiler versions, so that the developers have the option to improve it over time. This is requested quite often, in various contexts, but it's pretty hard to say \"we stop here and never touch it again\".</p>",
        "id": 227151690,
        "sender_full_name": "Laurențiu",
        "timestamp": 1613894791
    },
    {
        "content": "<p>Of course, there are a couple of operating systems written in Rust, one of the most popular -- and relatively usable as a desktop OS -- being <a href=\"https://www.redox-os.org/\">https://www.redox-os.org/</a>, but I haven't looked into them or whether they do something fundamentally different from other operating systems. My gut feeling is that the help you get from the compiler is really nice, but there's plenty of difficult problems to solve outside the language.</p>",
        "id": 227151772,
        "sender_full_name": "Laurențiu",
        "timestamp": 1613894894
    },
    {
        "content": "<p>I think there's also some interest in writing different front-ends for the Rust, and in stabilizing the internal representation so that static analysis tools can understand it better, e.g. <a href=\"https://github.com/rust-lang/lang-team/files/5997688/lang-team-proposal-trust-levels-1613584473422.pdf\">https://github.com/rust-lang/lang-team/files/5997688/lang-team-proposal-trust-levels-1613584473422.pdf</a> and probably other work in the Sealed Rust initiative.</p>",
        "id": 227151910,
        "sender_full_name": "Laurențiu",
        "timestamp": 1613895085
    },
    {
        "content": "<p>As for missing crates, there's a list at <a href=\"https://github.com/not-yet-awesome-rust/not-yet-awesome-rust\">https://github.com/not-yet-awesome-rust/not-yet-awesome-rust</a>, another at <a href=\"https://github.com/dtolnay/request-for-implementation\">https://github.com/dtolnay/request-for-implementation</a>, and maybe others too. GUIs, Web frameworks and ML get mentioned pretty often.</p>",
        "id": 227152040,
        "sender_full_name": "Laurențiu",
        "timestamp": 1613895237
    },
    {
        "content": "<p>Hi Nicola, thanks for answering me! <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span> <span aria-label=\"smiling face\" class=\"emoji emoji-263a\" role=\"img\" title=\"smiling face\">:smiling_face:</span><br>\nI understand the difficulties and certainly before we can establish every aspect of the compiler there must be a certain maturity.<br>\nThanks for everything.<br>\nI also took a look at Redox OS.<br>\nIt is very interesting and compatible as much as possible with linux.<br>\nAlthough in my opinion (personal opinion), it should strongly ignore the standards <br>\n(use them as a guideline anyway) and come up with proprietary solutions that conform to the language. <br>\nThese are the standards that must be rewritten, <br>\nimproved or forked at this point if they do not fit the new approach.<br>\nI took a look at the missing creates and saw that DDS is missing. I saw the description of RustDDS of who is working on it (<a href=\"https://crates.io/crates/rustdds\">https://crates.io/crates/rustdds</a>).<br>\nIn this case it seems difficult to strictly follow the specifications.</p>\n<p>But at this point a re-design of the dds specifications could also follow. <br>\nEven the creation of an alternative proprietary design to DDS could be at least as useful <br>\nas being compatible with the existing as much as possible since it is impossible to be.</p>\n<p>Redox OS (or similar os) could natively implement DDS-like middleware functionality natively and the RUST compiler should have DDS-like functionality in its toolchain and language.</p>\n<p>A language like Rust should have its own operating system (or family of operating systems).<br>\nI can't see a language evolution without a dedicated operating system. <br>\nIn my opinion this is not bad but something to be leveraged on.<br>\nThanks again!</p>",
        "id": 227192786,
        "sender_full_name": "Giuseppe Palmeri",
        "timestamp": 1613940218
    },
    {
        "content": "<p>more OS projects are list here: <a href=\"https://wiki.osdev.org/Rust#Active_Projects\">https://wiki.osdev.org/Rust#Active_Projects</a></p>",
        "id": 227324178,
        "sender_full_name": "oliver",
        "timestamp": 1614022490
    },
    {
        "content": "<p>Thanks Oliver!<br>\nI went through the list well.<br>\nThey are all interesting and most have been created for educational purposes.<br>\nLooking again I also found this project:<br>\n<a href=\"https://gitlab.com/robigalia\">https://gitlab.com/robigalia</a><br>\nIt sounds very interesting, especially for creating something around seL4. <br>\nI do not understand, however, why this project seems to be abandoned or practically no longer active, because as a project it seems to be very appropriate.</p>",
        "id": 227535790,
        "sender_full_name": "Giuseppe Palmeri",
        "timestamp": 1614131429
    }
]