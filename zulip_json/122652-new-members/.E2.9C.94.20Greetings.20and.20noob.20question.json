[
    {
        "content": "<p>Done, thanks for the help!</p>",
        "id": 273692523,
        "sender_full_name": "Jeff",
        "timestamp": 1646161091
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"479357\">Jeff</span> has marked this topic as resolved.</p>",
        "id": 273692585,
        "sender_full_name": "Notification Bot",
        "timestamp": 1646161120
    },
    {
        "content": "<p>i remember triagebot used to unclaim issues after a certain period, not sure what happened to that</p>",
        "id": 273745067,
        "sender_full_name": "DPC",
        "timestamp": 1646188482
    },
    {
        "content": "<p>Hi everyone! I want to create a multi lang LLVM compiler with C++ and Rust support. I request some resources, as I couldn't find much about cross-compilation support.</p>",
        "id": 273782047,
        "sender_full_name": "Rithik Sharma",
        "timestamp": 1646215394
    },
    {
        "content": "<p>by \"cross compilation\", do you mean one that can make function invocations and pass data into/from C++ and also into/from Rust?</p>",
        "id": 273834498,
        "sender_full_name": "pnkfelix",
        "timestamp": 1646238654
    },
    {
        "content": "<p>(The reason I asked for clarification: the term \"cross compilation\" is often used to denote the situation where you are building a program on a host where that program is going to be executed on a target that has incompatible differences. E.g., using an Intel Linux machine to target an ARM device.)</p>",
        "id": 273834695,
        "sender_full_name": "pnkfelix",
        "timestamp": 1646238724
    },
    {
        "content": "<p>Hello! I am making some changes in std. Locally I'm building std by running <code>x.py build --stage 1 library/std</code> using the \"library\" profile. I have a few of questions:</p>\n<ol>\n<li>I think this command builds the stage 1 compiler then builds the stage1 std, correct? </li>\n<li>I noticed when I run <code>x.py build library/std</code> it only builds stage0 std. It seems to behave as though<code>--stage 0</code> is the default, is that right? the rustc dev guide indicates that <code>--stage 1</code> is the default for <code>build</code>.</li>\n<li>Is there way of using stage0 std with the stage0 compiler instead of building stage1 std and using it with  the stage1 compiler? I created a toolchain link to my stage0 compiler but its std doesn't have my changes. I gather it is because stage0 compiler is the beta compiler with its own version of std, is that right?</li>\n</ol>",
        "id": 274318774,
        "sender_full_name": "Miguel Guarniz",
        "timestamp": 1646588684
    },
    {
        "content": "<blockquote>\n<p>I think this command builds the stage 1 compiler then builds the stage1 std, correct?</p>\n</blockquote>\n<p>Pretty close. I would say it builds <em>stage 1 std artifacts</em>.</p>\n<blockquote>\n<p>I noticed when I run x.py build library/std it only builds stage0 std. It seems to behave as though --stage 0 is the default, is that right? the rustc dev guide indicates that --stage 1 is the default for build.</p>\n</blockquote>\n<p>When you set a profile, that changes the defaults. The defaults for library development is <code>--stage 0</code> since you normally don't need to build the compiler for basic library work.</p>\n<blockquote>\n<p>Is there way of using stage0 std with the stage0 compiler instead of building stage1 std and using it with the stage1 compiler?</p>\n</blockquote>\n<p>I'm not aware of a practical way to do that. The standard library is pretty closely tied to the compiler.</p>\n<p>If you're having problems with it rebuilding rustc after every time you make a change, use something like <code>--keep-stage=std</code>, like:</p>\n<p><code>./x.py build --stage=1 --keep-stage-std=0 library/std </code></p>",
        "id": 274320515,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646591001
    },
    {
        "content": "<p>BTW, on Zulip, when posting it is best to start a new topic rather than reusing some other topic.</p>",
        "id": 274320528,
        "sender_full_name": "Eric Huss",
        "timestamp": 1646591025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120518\">@Eric Huss</span> Thank you! And will do <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 274322289,
        "sender_full_name": "Miguel Guarniz",
        "timestamp": 1646593234
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/122652-new-members/topic/.E2.9C.94.20Greetings.20and.20noob.20question/near/273834498\">said</a>:</p>\n<blockquote>\n<p>by \"cross compilation\", do you mean one that can make function invocations and pass data into/from C++ and also into/from Rust?</p>\n</blockquote>\n<p>Thanks! Initially, I wanted a toolchain with both Rust and C/C++ support for a targeted architecture, but now I want to have a Rust-LLVM toolchain for a specific architecture.</p>\n<p>I want to use my version of LLVM with that targeted architecture implementation. I read a few discussions and thought about linking Rust to my custom toolchain statically. I could not use the shared libraries from my custom toolchain. Do you have any leads with a custom LLVM source with new architecture support?</p>",
        "id": 274672886,
        "sender_full_name": "Rithik Sharma",
        "timestamp": 1646824348
    }
]