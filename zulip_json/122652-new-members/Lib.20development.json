[
    {
        "content": "<p>Hi! New around here. I am considering learning Rust in depth by implementing my templated hashmap written in C. The implementation is  currently about <em>the fastest hashmap</em> among the top c/c++ implementations out there, including <a href=\"https://bestofcpp.com/repo/greg7mdp-parallel-hashmap-cpp-data-structures\">https://bestofcpp.com/repo/greg7mdp-parallel-hashmap-cpp-data-structures</a> , <a href=\"https://bestofcpp.com/repo/martinus-robin-hood-hashing-cpp-containers\">https://bestofcpp.com/repo/martinus-robin-hood-hashing-cpp-containers</a> and <a href=\"https://medium.com/applied/gist-better-than-unordered-map-1ad07b0a81b7\">https://medium.com/applied/gist-better-than-unordered-map-1ad07b0a81b7</a>  It is also 4X faster than the current Rust HashMap in my simple benchmark. See <a href=\"http://rust_hashmap.rs\">rust_hashmap.rs</a>, rust_cmap.c and shootout2_cmap.cpp at <a href=\"https://github.com/tylov/STC\">https://github.com/tylov/STC</a>  The implementation is just 300 lines , and quite simple, so transforming it to Rust should be doable. My question is whether it is still interesting to try to push another alternative HashMap, or would I just be beating a dead horse here?</p>",
        "id": 260049140,
        "sender_full_name": "operamint",
        "timestamp": 1635883078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454812\">@operamint</span> A faster HashMap would <em>absolutely</em> be welcome. We'd have to be completely confident that the implementation was sound, though.</p>",
        "id": 260050695,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635883694
    },
    {
        "content": "<p>It'd also need to be capable of supporting the full API that we currently have.</p>",
        "id": 260050768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635883736
    },
    {
        "content": "<p>Also, in the interests of a fair comparison, does the performance of your hash table depend on the hasher? You need to compare collision-resistant hashes to collision-resistant hashes, and non-collision-resistant hashes to non-collision-resistant hashes.</p>",
        "id": 260051097,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635883866
    },
    {
        "content": "<p>A non-collision-resistant hash will be faster than a collision-resistant hash.</p>",
        "id": 260051121,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635883879
    },
    {
        "content": "<p>Keeping all those things in mind, though, if you can make a substantially faster HashMap, that would make many, many things faster.</p>",
        "id": 260051253,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635883933
    },
    {
        "content": "<p>I'd start by translating it to Rust and comparing the result to hashbrown. If you compare very favorably to hashbrown given all the above considerations, that'd be incredible.</p>",
        "id": 260051378,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635883995
    },
    {
        "content": "<p>It may also be worth talking to <span class=\"user-mention\" data-user-id=\"248590\">@Acrimon</span> , who has done a lot of similar work (I believe) on Dashmap: <a href=\"https://github.com/xacrimon/dashmap\">https://github.com/xacrimon/dashmap</a></p>",
        "id": 260051719,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1635884144
    },
    {
        "content": "<p>Oh hey!</p>",
        "id": 260052397,
        "sender_full_name": "Acrimon",
        "timestamp": 1635884416
    },
    {
        "content": "<p>That said dashmap is concurrent, this isn't.</p>",
        "id": 260052434,
        "sender_full_name": "Acrimon",
        "timestamp": 1635884436
    },
    {
        "content": "<p>If I understand correctly anyway.</p>",
        "id": 260052517,
        "sender_full_name": "Acrimon",
        "timestamp": 1635884481
    },
    {
        "content": "<p>Right. It might be possible to build a concurrent algorithm based on this, but a fast non-concurrent hash table is hugely valuable regardless.</p>",
        "id": 260054606,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635885407
    },
    {
        "content": "<p>Absolutely good to get more -- the one the standard library is currently using started as a normal crate (and still is, &lt;<a href=\"https://lib.rs/crates/hashbrown\">https://lib.rs/crates/hashbrown</a>&gt;), so you probably want to do the same, and if the new one turns out better it could absolutely become the default in <code>std</code>.</p>\n<p>(Obligatory warning that starting with complex datastructures is one of the harder ways to learn Rust, as its lifetime checks are the least helpful there.  You might want to start with a few simpler toy programs first to get a feel for how using hashmaps in safe code goes with those checks.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/122652-new-members/topic/Lib.20development/near/260051097\">said</a>:</p>\n<blockquote>\n<p>Also, in the interests of a fair comparison, does the performance of your hash table depend on the hasher? You need to compare collision-resistant hashes to collision-resistant hashes, and non-collision-resistant hashes to non-collision-resistant hashes.</p>\n</blockquote>\n<p>+1 to this.  It looks like &lt;<a href=\"https://github.com/tylov/STC/blob/master/benchmarks/rust_hashmap.rs#L17\">https://github.com/tylov/STC/blob/master/benchmarks/rust_hashmap.rs#L17</a>&gt; is using the default hasher, which I suspect doesn't match what the C++ is using.</p>",
        "id": 260065190,
        "sender_full_name": "scottmcm",
        "timestamp": 1635891136
    },
    {
        "content": "<p>FWIW, I agree that complex structures are a harsh way to learn rust, but also, with the performance you're talking about it would be fine if this data structure was built entirely on raw pointers and unsafe if necessary.</p>",
        "id": 260070470,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635894712
    },
    {
        "content": "<p>Oh, I'd definitely expect it would have a bunch of raw pointers and <code>unsafe</code> internally.  But it'll still need to have a safe external API, so it'll be important to learn about how those look from the outside too, in order to provide it.</p>",
        "id": 260097987,
        "sender_full_name": "scottmcm",
        "timestamp": 1635925202
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"454812\">@operamint</span> If you do end up working on this, please follow up here; I'd love to amplify it on Reddit and Twitter.</p>",
        "id": 260267153,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636031571
    }
]