[
    {
        "content": "<p>Hi, I just want to advertise the issue I opened on Github here since there seems to be more traffic in this chatroom.</p>\n<p>TL; DR: I think its a good idea to pass the allocated type to the allocator. It costs extra monomorphization but enables some security and performance features:</p>\n<ul>\n<li>The allocator can have a slower secure path to hide boxed functions or cryptographic keys to defend against heap overflow attacks and;</li>\n<li>put short-lived-request-related objects in a thread local linear allocator or;</li>\n<li>separate known shared global objects from thread-specific sub-allocators </li>\n</ul>\n<p><a href=\"https://github.com/rust-lang/wg-allocators/issues/91\">https://github.com/rust-lang/wg-allocators/issues/91</a></p>",
        "id": 257727325,
        "sender_full_name": "Casper",
        "timestamp": 1634315885
    },
    {
        "content": "<p>This would have huge implications for <code>Vec::from_raw_parts(_in)</code> and similar, I think.  Right now you can rebuild a <code>Vec</code> as a different type so long as you meet</p>\n<blockquote>\n<p><code>T</code> needs to have the same size and alignment as what <code>ptr</code> was allocated with.</p>\n</blockquote>\n<p>And you can use that to soundly go between <code>Vec&lt;Color&gt;</code> and <code>Vec&lt;[u8; 3]&gt;</code> and such, which I think is a reasonable expectation.</p>\n<p>Things like putting short-lived things in a request-specific allocator sounds to me like it should be done by passing the allocator, not by specializing an allocator for particular types.  I'd want <code>String</code>s to be request-local often, but I definitely can't do that by specializing on <code>u8</code> in the allocator.</p>",
        "id": 257794817,
        "sender_full_name": "scottmcm",
        "timestamp": 1634353105
    },
    {
        "content": "<p>Good points. For backwards compatibility, I agree its not a good idea to enforce \"allocate and deallocate with the same T\", and  the request-specific-allocator for performance idea is a little bit of a reach. Local allocators are sufficient. That said, local allocators can still benefit, performance-wise, from type awareness by allocating data that is known to be moved between threads in a non-thread-specific arena. (and of course hide secrets/fn ptrs)</p>",
        "id": 257796045,
        "sender_full_name": "Casper",
        "timestamp": 1634354340
    },
    {
        "content": "<p>If allocate and deallocate don't need to be the same <code>T</code>, though, I think that's pretty much fatal to the whole usefulness, though.  I could make a <code>Vec&lt;*const u32&gt;</code> -- where <code>T: !Send + !Sync</code> -- but then do the <code>from_raw_parts</code> trick to make turn it into a <code>Vec&lt;ReprTransparentAroundAPointer&gt;</code> that actually does go between threads.</p>",
        "id": 257798512,
        "sender_full_name": "scottmcm",
        "timestamp": 1634356858
    },
    {
        "content": "<p>Scott, what do you think of my response on github?</p>",
        "id": 258453081,
        "sender_full_name": "Casper",
        "timestamp": 1634768154
    }
]