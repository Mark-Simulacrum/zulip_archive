[
    {
        "content": "<p><strong>matthieum</strong> has started an <a href=\"https://internals.rust-lang.org/t/is-custom-allocators-the-right-abstraction/13460\">interesting proposal at IRL.org</a> which is really worth taking a look at.</p>\n<p><strong>TL;DR: </strong><br>\nUse a more generic trait for collections, which abstracts over storages rather than allocators.</p>",
        "id": 218178617,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1606593524
    },
    {
        "content": "<p>Storage instead of an Allocator as a generic makes sense for contiguous data structures (Vec, Box), but not as much for non-contiguous ones (LinkedList), I think?</p>",
        "id": 218179020,
        "sender_full_name": "nagisa",
        "timestamp": 1606594166
    },
    {
        "content": "<p>Agreed</p>",
        "id": 218179076,
        "sender_full_name": "John Ericson",
        "timestamp": 1606594231
    },
    {
        "content": "<p>But it would be nice to do both</p>",
        "id": 218179079,
        "sender_full_name": "John Ericson",
        "timestamp": 1606594237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Is.20custom.20allocators.20the.20right.20abstraction.3F/near/218179020\">said</a>:</p>\n<blockquote>\n<p>Storage instead of an Allocator as a generic makes sense for contiguous data structures (Vec, Box), but not as much for non-contiguous ones (LinkedList), I think?</p>\n</blockquote>\n<p>Interesting question, the OP says, it <em>could</em> be possible.</p>",
        "id": 218179083,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1606594252
    },
    {
        "content": "<p>(I wrote a one off ring buffer recently and was sad)</p>",
        "id": 218179088,
        "sender_full_name": "John Ericson",
        "timestamp": 1606594263
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220594\">John Ericson</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Is.20custom.20allocators.20the.20right.20abstraction.3F/near/218179079\">said</a>:</p>\n<blockquote>\n<p>But it would be nice to do both</p>\n</blockquote>\n<p>Like having <code>AllocRef</code> and <code>Storage</code>?</p>",
        "id": 218179090,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1606594268
    },
    {
        "content": "<p>That would be simply possible with <code>AllocatorStorage</code> I think.</p>",
        "id": 218179093,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1606594293
    },
    {
        "content": "<p>I'll need to look at the propose, but i mean in vague terms all collections should allow some variation on this front, and the \"flat\" ones should allow more</p>",
        "id": 218182695,
        "sender_full_name": "John Ericson",
        "timestamp": 1606600039
    },
    {
        "content": "<p>Is this proposal still under consideration? I've seen a few proofs of concept but I haven't seen any movement recently. It was mentioned in <a href=\"https://github.com/rust-lang/rust/pull/90822#issuecomment-1042578706\">this PR comment</a>.</p>",
        "id": 272299445,
        "sender_full_name": "David Koloski",
        "timestamp": 1645121108
    },
    {
        "content": "<p>speaking as a member of t-libs-api, its certainly under my consideration now</p>",
        "id": 272317353,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129215
    },
    {
        "content": "<p>I can't speak for wg-allocators tho because I've been uninvolved so far</p>",
        "id": 272317426,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129257
    },
    {
        "content": "<p>though hoping to change that</p>",
        "id": 272317431,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129264
    },
    {
        "content": "<p>and on a related note <span class=\"user-mention\" data-user-id=\"447178\">@David Koloski</span>, I'm having trouble understanding your comment <a href=\"https://github.com/rust-lang/rust/pull/90822#issuecomment-1043248588\">https://github.com/rust-lang/rust/pull/90822#issuecomment-1043248588</a></p>",
        "id": 272317872,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129490
    },
    {
        "content": "<blockquote>\n<p>Boxed allocators and pinned boxes (that is, Pin&lt;&amp;mut Box&lt;T, A&gt;&gt; not Pin&lt;Box&lt;T, A&gt;&gt;) don't seem like they have a use case. Everything would just end up trading Allocator for PinAllocator and nobody would use Allocator.</p>\n</blockquote>",
        "id": 272317908,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129507
    },
    {
        "content": "<p>confused by what <code>Pin&lt;&amp;mut Box&lt;T, A&gt;&gt;</code> has to do with using a marker trait instead of <code>'static</code> for relaxing usage of <code>Box::pin_in</code> and I don't understand what you mean in the second bit about <code>PinAllocator</code>.</p>",
        "id": 272318062,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129577
    },
    {
        "content": "<p>I was mostly trying not to type out another mile of text <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> If we introduced some extra marker trait (<code>PinAlloc</code>) that said \"you can move this allocator without invalidating its memory blocks\" then the regular <code>Allocator</code> would have to stay pinned in order to keep memory blocks valid.</p>",
        "id": 272318487,
        "sender_full_name": "David Koloski",
        "timestamp": 1645129826
    },
    {
        "content": "<p>So everyone would just use <code>PinAlloc</code> and there would be no point in having the un-pin <code>Allocator</code> trait</p>",
        "id": 272318537,
        "sender_full_name": "David Koloski",
        "timestamp": 1645129854
    },
    {
        "content": "<p>maybe i misinterpreted what <code>PinAlloc</code> would mean</p>",
        "id": 272318594,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129891
    },
    {
        "content": "<p>I assumed <span class=\"user-mention\" data-user-id=\"132829\">@Christopher Durham</span> meant it would indicate that the allocator upholds <code>Pin</code>'s drop requirements and that it is safe to use that allocator with <code>Box::pin_in</code>, not that you could move the allocator</p>",
        "id": 272318760,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645129979
    },
    {
        "content": "<p>so <code>PinAlloc</code> would more or less only be referenced in <code>Box::pin_in</code></p>",
        "id": 272318800,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130009
    },
    {
        "content": "<p><code>pin_in</code> should be sound for any <code>Allocator</code> with the current safety docs. I interpreted the comment as suggesting that we should move that particular safety guarantee to a new trait that augments <code>Allocator</code>. Without that guarantee, <code>Allocator</code> wouldn't be suitable for many use cases. So it wouldn't end up just gating <code>pin_in</code>, it would prevent most uses of <code>Allocator</code> without that extra trait.</p>",
        "id": 272319425,
        "sender_full_name": "David Koloski",
        "timestamp": 1645130344
    },
    {
        "content": "<p>The <code>Storage</code> API suggestion works around this by returning some intermediary <code>Handle</code> type from <code>alloc</code> instead of a raw pointer. That way we don't need to guarantee that the pointer to the memory is stable, we just need to guarantee that the handle will continue to work. I think this brings its own set of problems, but I haven't dug into it too deeply.</p>",
        "id": 272319689,
        "sender_full_name": "David Koloski",
        "timestamp": 1645130495
    },
    {
        "content": "<p>do you have examples of other usages that would need to introduce a <code>A: PinAlloc</code> if we made the suggested change without also swapping to <code>Storage</code>?</p>",
        "id": 272319773,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130528
    },
    {
        "content": "<p>i guess this ties back into the earlier question about whether the pin drop validity requirement and the one on Allocator are really the same requirement or if there are other reasons why Allocators would need to ensure data is valid until the allocator and all of its clones are dropped</p>",
        "id": 272319980,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130667
    },
    {
        "content": "<p>Pretty much all the containers like <code>Box</code>, <code>Vec</code>, <code>HashMap</code>, etc would have to switch to <code>A: PinAlloc</code>. Anything that acts like an owning pointer and isn't pinned. Otherwise we could move our <code>Box&lt;T, A: Allocator&gt;</code> and there's no guarantee its pointer will continue to be valid since we moved the allocator that it allocated with.</p>",
        "id": 272319987,
        "sender_full_name": "David Koloski",
        "timestamp": 1645130673
    },
    {
        "content": "<p>wait one sec</p>",
        "id": 272320055,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130711
    },
    {
        "content": "<blockquote>\n<p>Memory blocks returned from an allocator must point to valid memory and retain their validity until the instance and all of its clones are dropped,</p>\n<p>cloning or moving the allocator must not invalidate memory blocks returned from this allocator. A cloned allocator must behave like the same allocator, and</p>\n</blockquote>",
        "id": 272320083,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130728
    },
    {
        "content": "<p>these are two of the safety requirements on allocator rn</p>",
        "id": 272320134,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130757
    },
    {
        "content": "<p>I thought we were talking about the first one</p>",
        "id": 272320156,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130762
    },
    {
        "content": "<p>but you seem to be talking about the second?</p>",
        "id": 272320195,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130778
    },
    {
        "content": "<p>am I misunderstanding</p>",
        "id": 272320204,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130786
    },
    {
        "content": "<p>Oh, I'm sorry! I was talking about the second, that's the one that <code>Storage</code> is keen on changing.</p>",
        "id": 272320205,
        "sender_full_name": "David Koloski",
        "timestamp": 1645130786
    },
    {
        "content": "<p>Let's actually talk about the first one</p>",
        "id": 272320234,
        "sender_full_name": "David Koloski",
        "timestamp": 1645130807
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"132829\">@Christopher Durham</span> was suggesting only moving the first requirement onto <code>PinAlloc</code></p>",
        "id": 272320237,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130810
    },
    {
        "content": "<p>and presumably the second one would only be removed by replacing <code>Allocator</code> with <code>Storage</code></p>",
        "id": 272320296,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130847
    },
    {
        "content": "<p>I guess an open question is what could even replace the first safety requirement</p>",
        "id": 272320351,
        "sender_full_name": "David Koloski",
        "timestamp": 1645130880
    },
    {
        "content": "<p>im not sure replacing the first requirement should even be a goal</p>",
        "id": 272320495,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130958
    },
    {
        "content": "<p>just isolating it</p>",
        "id": 272320498,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645130960
    },
    {
        "content": "<p><code>PinAlloc</code> almost feels like it should be called <code>PinSafe</code> or something</p>",
        "id": 272320728,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131083
    },
    {
        "content": "<p>its like send / sync for whether you can pin memory from a given allocator</p>",
        "id": 272320750,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131101
    },
    {
        "content": "<blockquote>\n<p>Memory blocks returned from an allocator must point to valid memory</p>\n</blockquote>\n<p>This part is probably uncontroversial, we need valid blocks.</p>\n<blockquote>\n<p>and retain their validity until the instance and all of its clones are dropped,</p>\n</blockquote>\n<p>If we don't guarantee this, then when are those memory blocks still valid? Any container needs to know (and control?) how long its allocated memory will live for. Without that part, I again don't think that the base trait would usable without the augment.</p>",
        "id": 272320757,
        "sender_full_name": "David Koloski",
        "timestamp": 1645131105
    },
    {
        "content": "<p>and it should only prevent using exciting allocator in async land where they want to store self referential pointers to that data</p>",
        "id": 272320789,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131122
    },
    {
        "content": "<blockquote>\n<p>If we don't guarantee this, then when are those memory blocks still valid? Any container needs to know (and control?) how long its allocated memory will live for. Without that part, I again don't think that the base trait would usable without the augment.</p>\n</blockquote>\n<p>I'm having trouble figuring out how to best describe the change in the guarantee, so maybe let me come at this backwards</p>",
        "id": 272320881,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131158
    },
    {
        "content": "<p>so starting with the usecase I'm imagining we want to enable</p>",
        "id": 272321151,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131308
    },
    {
        "content": "<p>and then we can poke holes in why its could become bad</p>",
        "id": 272321186,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131327
    },
    {
        "content": "<p>so we have a stack local allocator</p>",
        "id": 272321196,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131332
    },
    {
        "content": "<p>this allocator is not <code>'static</code></p>",
        "id": 272321203,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131339
    },
    {
        "content": "<p>lets say it was created from a <code>&amp;mut [u8]</code> or something</p>",
        "id": 272321231,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131360
    },
    {
        "content": "<p>pointing to some stack array</p>",
        "id": 272321290,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131370
    },
    {
        "content": "<p>we want to be able to allocate boxes inside of this allocator and use them for some time, possibly forget them, and then eventually cleanup the backing storage</p>",
        "id": 272321330,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131401
    },
    {
        "content": "<p>the one thing we want to disallow is pinning, taking a pointer to the storage, and then forgetting the box</p>",
        "id": 272321375,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131428
    },
    {
        "content": "<p>since this stack local allocator does not impl <code>unsafe trait PinAlloc</code></p>",
        "id": 272321395,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131447
    },
    {
        "content": "<p>in this case it should be fine to forget a reference to the allocator and then drop the backing storage, even tho some of the memory was leaked and not everything in the backing <code>&amp;mut [u8]</code> was freed before cleaning up, we don't have to abort in this case because we know that nobody would have saved a pointer into any of the forgotten memory because they cannot have pinned that data</p>",
        "id": 272321666,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131581
    },
    {
        "content": "<p>Right, that makes sense. I'm gonna need a moment to think about that more deeply.</p>",
        "id": 272321856,
        "sender_full_name": "David Koloski",
        "timestamp": 1645131630
    },
    {
        "content": "<p>sounds good, hopefully poking holes in this will help us figure out what guarantees we need to add to <code>Allocator</code> as part of moving the pin drop safety requirement to a marker trait instead of using <code>'static</code> or ref-counting / aborting. Assuming this is even sound at all to start with</p>",
        "id": 272322044,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645131720
    },
    {
        "content": "<p>Would something like this work?</p>\n<blockquote>\n<p>Memory blocks returned from an allocator must point to valid memory and retain their validity until the instance and all of its clones are <strong>unreachable</strong></p>\n</blockquote>\n<p>I'm not sure if we have a formal definition of \"unreachable\" but that would relax <code>Allocator</code> to say that we can reuse memory from forgotten allocators.</p>",
        "id": 272322727,
        "sender_full_name": "David Koloski",
        "timestamp": 1645132092
    },
    {
        "content": "<p>I can do the legwork on getting something like this changed if that would help. I imagine we'd close that soundness hole first. Would this be something I can just PR on, or should I go through a more formal channel?</p>",
        "id": 272325750,
        "sender_full_name": "David Koloski",
        "timestamp": 1645133524
    },
    {
        "content": "<p>it would definitely help! I think a PR is the best starting point. I'm not sure if this should also be going through some different channels, it may be that we want to do some updates to previously approved <code>Allocator</code> RFCs or note somewhere the departures from existing plans so we don't accidentally stabilize these changes as part of a larger stabilization without ppl specifically reviewing these changes. We will almost certainly want to get other members of wg-allocators to sign off on the change but that seems unlikely to be an issue given that it was originally suggested by a member of wg-allocators.</p>",
        "id": 272331290,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1645135742
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"447178\">@David Koloski</span> what I was thinking was to phrase it directly paralleling the Pin guarantee. That is, talking about when <code>drop</code> is called.<br>\n(And to be clear: yes, my <code>PinAlloc</code> is just about the pinned-after-forget guarantee.)<br>\nSpecifically having not looked at the PR yet, I was thinking it'd look like<br>\n<code>PinAlloc</code>: memory blocks retain validity until all clones of the allocator are dropped (pin language)<br>\n<code>Alloc</code>: memory blocks retain validity while any clone is live (mut ref language)</p>",
        "id": 272362683,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1645162976
    },
    {
        "content": "<p>I think that’s about what I got down. I can’t find the mut ref docs you mentioned but I can update the PR with changed language (after I get some sleep)</p>",
        "id": 272363090,
        "sender_full_name": "David Koloski",
        "timestamp": 1645163633
    }
]