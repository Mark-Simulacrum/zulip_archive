[
    {
        "content": "<p><code>AbortAlloc</code> is implemented as a wrapper around an arbitrary allocator <code>A</code>. <code>AbortAlloc</code> maps the returend error to <code>handle_alloc_error</code>. So if an OOM occures, there is no way to recover. Thus, <code>AbortAlloc</code> is incompatible with <code>try_reserve</code>. Any thoughts/idea on this?</p>",
        "id": 181572440,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574362455
    },
    {
        "content": "<p>What do you mean that it's incompatible?</p>",
        "id": 181599481,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1574382537
    },
    {
        "content": "<p>When calling <code>try_reserve</code> (or any other try_method), you expect to get an allocation error on OOM. <code>AbortAlloc</code> aborts before the function returns.</p>",
        "id": 181613250,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574404091
    },
    {
        "content": "<p>This is the desired effect on methods like <code>reserve</code>, but not on <code>try_resersve</code>.</p>",
        "id": 181613265,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574404135
    },
    {
        "content": "<p>Is <code>try_reserve</code> stable ?</p>",
        "id": 182123371,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574960463
    },
    {
        "content": "<p>I think I would prefer to, e.g., get <code>try_</code> versions of all allocating methods, not only <code>reserve</code>, but all of them, by just using a <code>PanicAlloc</code> that panics, such that the panic can be caught</p>",
        "id": 182123397,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574960502
    },
    {
        "content": "<p>I think it is stable</p>",
        "id": 182123410,
        "sender_full_name": "John Ericson",
        "timestamp": 1574960518
    },
    {
        "content": "<p>The default allocator can <code>abort</code> on OOM</p>",
        "id": 182123411,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574960520
    },
    {
        "content": "<p>*unstable</p>",
        "id": 182123456,
        "sender_full_name": "John Ericson",
        "timestamp": 1574960525
    },
    {
        "content": "<p>I tried to prevent it from being stabilized for exactly this reason</p>",
        "id": 182123465,
        "sender_full_name": "John Ericson",
        "timestamp": 1574960540
    },
    {
        "content": "<p>We can always deprecate it afterwards</p>",
        "id": 182123477,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574960553
    },
    {
        "content": "<p>One situation were this approach wouldn't work is if <code>-C panic=abort</code>.</p>",
        "id": 182124132,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961165
    },
    {
        "content": "<p>In that case, <code>Vec::try_reserve</code> would still work properly, since no panics occur, but a <code>PanicOnOomAlloc&lt;MyAlloc&gt;</code> adapter would terminate the process.</p>",
        "id": 182124155,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961192
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>  in my PR, I used <code>repr(transparent)</code> so I could cast on and off the wrapper</p>",
        "id": 182124236,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961270
    },
    {
        "content": "<p>So if you want today's <code>try_reserve</code>, you just cast away the <code>PanicOnOomAlloc&lt;_&gt;</code>, and then call <code>try_reserve</code>.</p>",
        "id": 182124275,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961324
    },
    {
        "content": "<p>It's slightly more verbose but I don't really care. I think anyone that's using <code>try_reserve</code> today is much better off without <code>PanicOnOomAlloc</code> anyways.</p>",
        "id": 182124338,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961377
    },
    {
        "content": "<p><code>try_reserve</code> is a hacky way to make the thing you actually want to do hopefully succeed. But that's racy; you still want to do not panic on the thing itself. And in that case unless you are reserving way before, you probably don't need the <code>try_reserve</code> at all.</p>",
        "id": 182124383,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961446
    },
    {
        "content": "<blockquote>\n<p>It's slightly more verbose but I don't really care. I think anyone that's using try_reserve today is much better off without PanicOnOomAlloc anyways.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span> without or with ?</p>",
        "id": 182124549,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961604
    },
    {
        "content": "<p>without</p>",
        "id": 182124572,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961629
    },
    {
        "content": "<p>So you are in favour of only doing <code>try_reserve</code> ?</p>",
        "id": 182124589,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> if you scroll up in that issue you posted in, you can read me describe the stuff I am saying here with more words</p>",
        "id": 182124593,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961651
    },
    {
        "content": "<p>ok i will</p>",
        "id": 182124599,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961658
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> I mean that <code>PanicOnOomAlloc</code> definitely should exist, but you shouldn't be mixing sometimes panicking and somtimes not panicking</p>",
        "id": 182124626,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961691
    },
    {
        "content": "<blockquote>\n<p>The default allocator can <code>abort</code> on OOM</p>\n</blockquote>\n<p>No, in today’s standard library it’s <code>Vec</code> and other callers that check for errors and call <code>handle_alloc_error</code> which in turn defaults to abort.</p>",
        "id": 182124642,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574961708
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span> this one: <a href=\"https://github.com/rust-lang/rust/issues/48043#issuecomment-501416660\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/48043#issuecomment-501416660\">https://github.com/rust-lang/rust/issues/48043#issuecomment-501416660</a> ?</p>",
        "id": 182124750,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961783
    },
    {
        "content": "<p>Im not sure I fully understand what you are propossing, it feels as if you want all <code>Vec</code> methods to return a <code>Result</code></p>",
        "id": 182124769,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961808
    },
    {
        "content": "<blockquote>\n<p><code>AbortAlloc</code> is implemented as a wrapper around an arbitrary allocator <code>A</code>. <code>AbortAlloc</code> maps the returend error to <code>handle_alloc_error</code>. So if an OOM occures, there is no way to recover. Thus, <code>AbortAlloc</code> is incompatible with <code>try_reserve</code>. Any thoughts/idea on this?</p>\n</blockquote>\n<p>Yes, making the choice to abort or not be part of the type signature is incompatible with having it only as part of the choice of method being called on a given type. I personally prefer the latter.</p>",
        "id": 182124817,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574961842
    },
    {
        "content": "<blockquote>\n<p>No, in today’s standard library it’s Vec and other callers that check for errors and call handle_alloc_error which in turn defaults to abort.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"219747\">@Simon Sapin</span> yes, but I can provide a <code>#[global_allocator]</code> that aborts on OOM or panics instead by using <code>AbortOnOOM&lt;std::alloc::Heap&gt;;</code> right ?</p>",
        "id": 182124881,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574961898
    },
    {
        "content": "<p>I think <a href=\"https://github.com/rust-lang/rust/issues/48043#issuecomment-409967652\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/48043#issuecomment-409967652\">https://github.com/rust-lang/rust/issues/48043#issuecomment-409967652</a> is the first in my thread. It's somewhat hard to follow the convo rereading it again I'll admit. These sorts of discussions tended to be strewn around a bunch of issues, sadly.</p>",
        "id": 182124968,
        "sender_full_name": "John Ericson",
        "timestamp": 1574961967
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> yes there should be a <code>try_</code> version of every method that returns a result.</p>",
        "id": 182124987,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962018
    },
    {
        "content": "<p>Ah gotcha</p>",
        "id": 182124999,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962027
    },
    {
        "content": "<p>There’s nothing technically stopping you from aborting inside your <code>#[global_allocator]</code>, but <a href=\"https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#errors\" target=\"_blank\" title=\"https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#errors\">https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html#errors</a> “encourages” not to</p>",
        "id": 182125007,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962037
    },
    {
        "content": "<p>So do you want <code>try_clone</code> as well in the <code>Clone</code> trait ?</p>",
        "id": 182125011,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962045
    },
    {
        "content": "<p>Probably yes</p>",
        "id": 182125026,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962064
    },
    {
        "content": "<p>Like if I <code>extend</code> a <code>Vec&lt;T&gt;</code>, and <code>try_reserve</code> succeeded, but extending requires calls to <code>T::clone</code>, and those <code>T::clone</code> allocate, then, you are screwed</p>",
        "id": 182125037,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962081
    },
    {
        "content": "<p>exactly!</p>",
        "id": 182125083,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962096
    },
    {
        "content": "<p>I think the idea of an <code>AbortOnOOM</code> wrapper type is flawed</p>",
        "id": 182125085,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962099
    },
    {
        "content": "<p>What's the goal of <code>AbortOnOOM</code> ?</p>",
        "id": 182125095,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962125
    },
    {
        "content": "<p>the only way to systematically ensure your program will not crash is to never panic and <code>?</code> the <code>Result</code>  --- ideomatic error handling.</p>",
        "id": 182125099,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962129
    },
    {
        "content": "<p>I don’t know, you mentioned it</p>",
        "id": 182125105,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962141
    },
    {
        "content": "<p>I mentioned <code>PanicOnOOM</code></p>",
        "id": 182125114,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962149
    },
    {
        "content": "<p>which is quite differently</p>",
        "id": 182125117,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962152
    },
    {
        "content": "<p><a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Design.20of.20.60AbortAlloc.60.20not.20compatible.20with.20.60try_reserve.60/near/182124881\" title=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Design.20of.20.60AbortAlloc.60.20not.20compatible.20with.20.60try_reserve.60/near/182124881\">https://rust-lang.zulipchat.com/#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Design.20of.20.60AbortAlloc.60.20not.20compatible.20with.20.60try_reserve.60/near/182124881</a></p>",
        "id": 182125131,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962178
    },
    {
        "content": "<p>I was asking if that is a possibility</p>",
        "id": 182125143,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962196
    },
    {
        "content": "<p>the non-try methods would require the allocator parameter to have <code>!</code> as the error type, which means that alllocation failure is \"impossible\", which means something panics. <code>PanicOnOOM</code> would have the <code>!</code> error  type.</p>",
        "id": 182125185,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962203
    },
    {
        "content": "<p>and if your goal is to abort on any OOM, it is quite simple</p>",
        "id": 182125197,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962208
    },
    {
        "content": "<p>and doesn't rely on anybody calling the <code>handle_alloc_error</code></p>",
        "id": 182125204,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962225
    },
    {
        "content": "<p>It’s technically possible. IMO it’s not a good idea.</p>",
        "id": 182125211,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962234
    },
    {
        "content": "<p>the same applies if you want to panic on any OOM</p>",
        "id": 182125213,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962236
    },
    {
        "content": "<p>Why?</p>",
        "id": 182125216,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962251
    },
    {
        "content": "<p>Why would you panic or abort if the caller has specifically written code to handle both outcomes of <code>try_reserve</code>?</p>",
        "id": 182125243,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962292
    },
    {
        "content": "<p>That just seems hostile to me</p>",
        "id": 182125255,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962314
    },
    {
        "content": "<p>Because if I'm writing <code>#[global_allocator]</code>, i'm in charge of building the final binary, and I can do whatever I want?</p>",
        "id": 182125261,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> or you can read <a href=\"https://github.com/rust-lang/rust/pull/60703\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/60703\">https://github.com/rust-lang/rust/pull/60703</a> where I implemented everything I've talked about</p>",
        "id": 182125301,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962325
    },
    {
        "content": "<p>Like, maybe I just want my binary to fail as fast as possible on OOM without any kind of cleanup - its kind of up to me</p>",
        "id": 182125328,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219747\">@Simon Sapin</span> with the associated error type <code>try_*</code> would return <code>Result&lt;_, !&gt;</code>, with <code>PanicOnOOM</code> so the  user gets a heads up that their code isn't doing what they through via dead code warnings.</p>",
        "id": 182125335,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962379
    },
    {
        "content": "<p>One way to implement all standard collections more \"concisely\" would be to wrap the user allocator in a <code>HandleAllocError&lt;Alloc&gt;</code> wrapper internally, that always calls <code>handle_alloc_error</code> on OOM.</p>",
        "id": 182125358,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span> I’m sorry, you and I already had this discussion a couple times and I don’t have anything new to add</p>",
        "id": 182125365,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962411
    },
    {
        "content": "<p>The things you are telling @gnzlbg seem like the same things you have told me?</p>",
        "id": 182125426,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962460
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span> I think the difference is that I'm not suggesting for everything to return <code>Result</code></p>",
        "id": 182125433,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962482
    },
    {
        "content": "<p>I'll not @ you then and at @ <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> instead, I guess</p>",
        "id": 182125434,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962483
    },
    {
        "content": "<p>I meant about <code>Result&lt;_, !&gt;</code> everywhere</p>",
        "id": 182125435,
        "sender_full_name": "Simon Sapin",
        "timestamp": 1574962483
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> so without a bunch of new <code>try_</code> methods, what are you proposing for writing code that never blows up on allocation failure?</p>",
        "id": 182125449,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962519
    },
    {
        "content": "<p><code>Vec&lt;T, PanicOnOOM&lt;Alloc&gt;&gt;</code></p>",
        "id": 182125453,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962535
    },
    {
        "content": "<p>that still panics?</p>",
        "id": 182125464,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962547
    },
    {
        "content": "<p>it immediately panics, always</p>",
        "id": 182125470,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962557
    },
    {
        "content": "<p>is the application supposed to catch the panic?</p>",
        "id": 182125473,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962559
    },
    {
        "content": "<p>Yes, it could, if it wanted</p>",
        "id": 182125515,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962566
    },
    {
        "content": "<p>Say you don't want to panic or abort</p>",
        "id": 182125517,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962569
    },
    {
        "content": "<p>Only works with unwinding</p>",
        "id": 182125520,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962577
    },
    {
        "content": "<p>If you don't have unwinding, or don't want to unwind, this won't work for you</p>",
        "id": 182125529,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962592
    },
    {
        "content": "<p>that's why I want <code>try_*</code></p>",
        "id": 182125534,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962603
    },
    {
        "content": "<p>I want my code to not fail, and so I don't write any panics, and I cannot unwind so I do panic == abort</p>",
        "id": 182125551,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962624
    },
    {
        "content": "<p>But if you want to support <code>Vec&lt;T&gt;</code> failing to resize, <code>T::clone</code> failing, etc. , a global allocator that panics on OOM, and an allocator wrapper that panics on OOM, give you that if you have unwinding</p>",
        "id": 182125556,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962628
    },
    {
        "content": "<p>And it gives you that without having <code>Result</code> everywhere</p>",
        "id": 182125561,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962649
    },
    {
        "content": "<p>Isn't <code>Result</code> everywhere the ideomatic way of doing error handling in rust?</p>",
        "id": 182125571,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962665
    },
    {
        "content": "<p>and catching panics <em>not</em>?</p>",
        "id": 182125575,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962673
    },
    {
        "content": "<p>Not for allocation errors</p>",
        "id": 182125577,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962677
    },
    {
        "content": "<p>why is allocation different?</p>",
        "id": 182125621,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962685
    },
    {
        "content": "<p>Because somebody decided so</p>",
        "id": 182125624,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962691
    },
    {
        "content": "<p>That decision happened long time ago, and we can't change it</p>",
        "id": 182125632,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962708
    },
    {
        "content": "<p>Right we have some legacy cruft, but I rather things be different for principled reasons.</p>",
        "id": 182125635,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962715
    },
    {
        "content": "<p>You can write RFCs for adding a lot of try_methods, and maybe they'll go through</p>",
        "id": 182125643,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962727
    },
    {
        "content": "<p>But for me, unwinding is ok, and a small <code>Alloc&lt;A&gt;</code> wrapper makes allocation fallible, without having to change anything or add any APIs</p>",
        "id": 182125665,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962756
    },
    {
        "content": "<p>Or rely on people actually using those APIs</p>",
        "id": 182125670,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> so what makes this difficult is to me <code>PanicOnOOM</code>, <code>Result</code>, and <code>try_*</code> all go together.</p>",
        "id": 182125681,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962783
    },
    {
        "content": "<p>I need all 3 of them to make the coherent argument</p>",
        "id": 182125684,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962793
    },
    {
        "content": "<p>I don't need Result and try_</p>",
        "id": 182125692,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962802
    },
    {
        "content": "<p>What does <code>PanicOnOOM</code> do without <code>try_*</code>?</p>",
        "id": 182125736,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962808
    },
    {
        "content": "<p>because I have unwinding, and can use it to handle OOM</p>",
        "id": 182125737,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962809
    },
    {
        "content": "<p>Say you <em>diddn't</em> use <code>PanicOnOOM</code>. What would happen?</p>",
        "id": 182125748,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962828
    },
    {
        "content": "<p><code>PanicOom&lt;A: Alloc&gt;: Alloc</code> is an allocator wrapper, that forwards arguments and returns from / to <code>A</code>, but if a return is a null pointer due to an allocation error, it immediately panics.</p>",
        "id": 182125759,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962846
    },
    {
        "content": "<p>So what happens if I try to do <code>Vec&lt;A&gt;</code> without <code>Vec&lt;PanicOnOOM&lt;A&gt;</code></p>",
        "id": 182125780,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962878
    },
    {
        "content": "<p>and <code>A</code> returns a null pointer</p>",
        "id": 182125789,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962890
    },
    {
        "content": "<p>If <code>A</code> forwards to the <code>#[global_allocator]</code> then that would panic, if you make it a <code>PanicOnOOM</code></p>",
        "id": 182125802,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962915
    },
    {
        "content": "<p>If <code>A</code> is its own thing, it would call <code>handle_alloc_err</code> at some point, which you can configure to also panic</p>",
        "id": 182125862,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962960
    },
    {
        "content": "<p>panic or abort, right?</p>",
        "id": 182125873,
        "sender_full_name": "John Ericson",
        "timestamp": 1574962979
    },
    {
        "content": "<p>but then you are relying on <code>Vec</code> always calling <code>handle_alloc_err</code> when it should</p>",
        "id": 182125874,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962980
    },
    {
        "content": "<p>You can provide your own handler</p>",
        "id": 182125883,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574962987
    },
    {
        "content": "<p>So in my case, I would provide a <code>PanicOnOom</code> global allocator, a handler that panics, etc.</p>",
        "id": 182125896,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574963003
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> I don't feel very motivated by your <code>PanicOnOOM</code></p>",
        "id": 182125897,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963003
    },
    {
        "content": "<p>So it always panics</p>",
        "id": 182125902,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963009
    },
    {
        "content": "<p>and we just muddle who has the oblilgation</p>",
        "id": 182125910,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963021
    },
    {
        "content": "<p>yes, and I can catch those panics, if I care about that, and where I care about that</p>",
        "id": 182125916,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574963028
    },
    {
        "content": "<p>it would be nice to say \"Vec, you don't need to worry about null pointers because that is already taken care of\"</p>",
        "id": 182125925,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963037
    },
    {
        "content": "<p>but you cannot rely on the allocator using <code>PanicOnOOM</code> so Vec has to be defensive anyways</p>",
        "id": 182125978,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963055
    },
    {
        "content": "<p>so you get both sides panicking</p>",
        "id": 182125984,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963062
    },
    {
        "content": "<p>what's the point?</p>",
        "id": 182125988,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963066
    },
    {
        "content": "<p>That there are collections that are not <code>Vec</code> that I also use</p>",
        "id": 182126005,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574963078
    },
    {
        "content": "<p>inside the 100s of my crates I depend on</p>",
        "id": 182126010,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574963086
    },
    {
        "content": "<p>and I don't trustthem</p>",
        "id": 182126012,
        "sender_full_name": "gnzlbg",
        "timestamp": 1574963088
    },
    {
        "content": "<p>But they either need to return <code>Result</code>, or panic themselves</p>",
        "id": 182126020,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963097
    },
    {
        "content": "<p>the type system forces this</p>",
        "id": 182126032,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963104
    },
    {
        "content": "<p>Are you worried about those other collections just not handling null pointers at all?</p>",
        "id": 182126046,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963125
    },
    {
        "content": "<p>Then the solution is to make sure that no collection needs to worry about nullness</p>",
        "id": 182126103,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> here's the thing, even if every collection is to be used with OOM panics and unwinding, when <em>building</em> collections it's much easier to use <code>Result</code></p>",
        "id": 182126129,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963206
    },
    {
        "content": "<p>You don't have to be a careful C programmer and remember all your null pointers</p>",
        "id": 182126136,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963222
    },
    {
        "content": "<p>and collections can be made out of other collections, etc etc</p>",
        "id": 182126144,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963232
    },
    {
        "content": "<p>therefore I don't recognize there being a clear division of labor between \"collections code\" and \"applications code\"</p>",
        "id": 182126150,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963254
    },
    {
        "content": "<p>It's best if we just add all the <code>try_</code> methods and associated error type so we can safely create all these other collections, and the responsibility for error handling is clearly laid out and no one needs to be defense without help from the compiler. Nobody is being forced to use the <code>try_*</code> methods, remember.</p>",
        "id": 182126220,
        "sender_full_name": "John Ericson",
        "timestamp": 1574963321
    },
    {
        "content": "<blockquote>\n<p>I think the idea of an <code>AbortOnOOM</code> wrapper type is flawed</p>\n</blockquote>\n<p>Yes it is, that's the reason why I removed it from alloc-wg. The thing is, that it will always aborts (or panics in the case of <code>PanicOnOom</code>) as soon as an allocation fails, even before <code>try_reserve</code> can return a result.</p>\n<p>Personally I'm not fine with relying on unwinding on OOM. That defeats the purpose on returning a Result. Personally I also think, that the current design of the collections isn't that great, but we can't change this anyway, so we shouldn't bother.</p>",
        "id": 182130211,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574967717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> I would be happy to contribute my PR to that library</p>",
        "id": 182130478,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968007
    },
    {
        "content": "<p>I don't get all this \"ship has sailed\" talk when there is no problem with adding a bunch of new methods</p>",
        "id": 182130498,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968031
    },
    {
        "content": "<p>And there could be some lang thing down the road for Result&lt;T,!&gt; to T</p>",
        "id": 182130550,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968084
    },
    {
        "content": "<p>So it's not like 2x methods is necessary a permanent state of affairs</p>",
        "id": 182130562,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968108
    },
    {
        "content": "<p>Sure, go ahead and let's see, how it turns out. The crate tries to collect proposals of the WG to try them, not to be merged as the new liballoc.</p>",
        "id": 182130585,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574968143
    },
    {
        "content": "<p>Ok thanks</p>",
        "id": 182130599,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968162
    },
    {
        "content": "<blockquote>\n<p>I don't get all this \"ship has sailed\" talk</p>\n</blockquote>\n<p>Me neither</p>",
        "id": 182130612,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574968194
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> now I'm confused :) Didn't you just say \"but we can't change this anyway\"? Or were you referring to something more specific?</p>",
        "id": 182130794,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968392
    },
    {
        "content": "<p>A few commits back you can see the design with <code>AbortAlloc</code> and the bound for <code>AllocRed&lt;Error = !&gt;</code> for infallible methods .</p>",
        "id": 182130805,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574968417
    },
    {
        "content": "<p>Wait a second searching for a cite</p>",
        "id": 182130865,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574968463
    },
    {
        "content": "<p>OK</p>",
        "id": 182130872,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968470
    },
    {
        "content": "<p>Can't find it right now. However I don't see why the collections defaults to abort instead of panicking. Or even don't return <code>Result</code></p>",
        "id": 182131163,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574968819
    },
    {
        "content": "<p>OK, sweet!</p>",
        "id": 182131175,
        "sender_full_name": "John Ericson",
        "timestamp": 1574968839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> oh, looks like alloc-wg does a lot of this stuff already?! Sorry, I am comming back to these things after quite a while</p>",
        "id": 182131308,
        "sender_full_name": "John Ericson",
        "timestamp": 1574969015
    },
    {
        "content": "<p>No problem :D</p>",
        "id": 182132562,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574970674
    },
    {
        "content": "<p>As mentioned before: I tried to collect many proposals so it turns out how much sense everything makes.</p>",
        "id": 182132648,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1574970734
    },
    {
        "content": "<blockquote>\n<p>Yes it is, that's the reason why I removed it from alloc-wg. The thing is, that it will always aborts (or panics in the case of PanicOnOom) as soon as an allocation fails, even before try_reserve can return a result.</p>\n</blockquote>\n<p>That is kind of the point right? What can you do to prevent this from happening? e.g. I can write an <code>AbortOnOom</code> wrapper that sets the <code>#[global_allocator]</code> to abort on OOM, and there is nothing the standard library can do against that.</p>",
        "id": 182171590,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575028558
    },
    {
        "content": "<p>For something like <code>PanicOnOom</code>, we can protect against this by saying that a <code>GlobalAlloc</code> that unwinds is UB, and e.g. making the <code>GlobalAlloc</code> hooks <code>nounwind</code>, to be able to optimize under this assumption.</p>",
        "id": 182171798,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575028738
    },
    {
        "content": "<p>But if you write a library that uses <code>Vec::try_reserve</code>, you are not guaranteed a <code>Result</code> on allocation error, because your allocator might abort the process if that happens, and there is nothing you can do about that.</p>",
        "id": 182171826,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575028777
    },
    {
        "content": "<p>On Linux, you might get even an <code>Ok</code>, and only when you touch the memory, the OOM-killer kills your process</p>",
        "id": 182171841,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575028800
    },
    {
        "content": "<p>So the best that <code>Vec::try_reserve</code> can do is guarantee that <code>handle_alloc_error</code> won't be called</p>",
        "id": 182171913,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575028861
    },
    {
        "content": "<p>which is very different from the guarantee that allocation errors will be reported as <code>Err</code>, there is no way to guarantee that in Rust</p>",
        "id": 182172002,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575028927
    },
    {
        "content": "<p>you need the allocator and the OS to conspire together with <code>Vec::try_reserve</code> to support those semantics</p>",
        "id": 182172033,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575028963
    },
    {
        "content": "<p>(the goal of <code>Vec::try_reserve</code> is to support supporting those semantics when all those components align)</p>",
        "id": 182172161,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029089
    },
    {
        "content": "<blockquote>\n<p>That is kind of the point right?</p>\n</blockquote>\n<p>I tried to modify the collection API, that allocating methods like <code>Vec::reserve</code> can only be used for infallible allocators (<code>AllocRef&lt;Error = !&gt;</code>). To maintain backwards combatibility, I introduced the wrapping allocator <code>AbortAlloc</code>.</p>",
        "id": 182172559,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029441
    },
    {
        "content": "<p>To achieve this, the design of <code>AbortAlloc</code> simply didn't work out</p>",
        "id": 182172593,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029474
    },
    {
        "content": "<p>Ah yes, that won't work</p>",
        "id": 182172624,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029501
    },
    {
        "content": "<p>What I think could be done is provide a different <code>FallibleVec</code> in libstd, where all allocating methods return <code>Result&lt;(), AllocRef::Error&gt;</code> or some other error type.</p>",
        "id": 182172693,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029537
    },
    {
        "content": "<p>This brings me to two points:<br>\n- Does an infallible generic allocator even makes sense?<br>\n- I think this could only be solved with an additional trait: <code>InfallibleAlloc</code> (and <code>InfallibleRealloc</code>?)</p>",
        "id": 182172698,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029540
    },
    {
        "content": "<p>Then, <code>Vec</code> can be implemented on top of such a <code>FallibleVec</code> type by just <code>.unwrap()</code>ing everything</p>",
        "id": 182172709,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029556
    },
    {
        "content": "<blockquote>\n<p>What I think could be done is provide a different FallibleVec in libstd</p>\n</blockquote>\n<p>Right, this would be another possibility</p>",
        "id": 182172746,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029592
    },
    {
        "content": "<p>If we ever get a <code>prelude::v2</code> in a future edition, we could add a <code>Vec</code> type alias for <code>FallibleVec</code></p>",
        "id": 182172748,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029593
    },
    {
        "content": "<p>and offer the old Vec through a <code>std::v1::collections::Vec</code>.</p>",
        "id": 182172754,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029607
    },
    {
        "content": "<p>Only for crates on the new edition, on the old edition, the prelude would just point to <code>v1</code>, so that would be a backward compatible change.</p>",
        "id": 182172768,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029630
    },
    {
        "content": "<p>Code in the new edition interfacing with APIs from crates using the old edition using <code>Vec</code>, would need to use <code>std::v1::collection::Vec</code> instead, so this might end up being quite a pain, but... is doable.</p>",
        "id": 182172828,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029664
    },
    {
        "content": "<p>I think introducing <code>FallibleVec</code> wouldn't be the optimal solution, as <code>Vec</code> isn't the only collection which allocates. We would need a fallible variant for all collections</p>",
        "id": 182172838,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029680
    },
    {
        "content": "<p>Yes</p>",
        "id": 182172844,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029687
    },
    {
        "content": "<p>but we can do that one collection at a time</p>",
        "id": 182172850,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029692
    },
    {
        "content": "<p>without breaking backward compatibility, and just changing what the defaults are between editions, while providing both version on all editions</p>",
        "id": 182172877,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029714
    },
    {
        "content": "<p>What do you think on introducing <code>liballoc::alloc::Infallible</code>?</p>",
        "id": 182172896,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029747
    },
    {
        "content": "<p>as trait</p>",
        "id": 182172898,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029754
    },
    {
        "content": "<p>What does that mean ?</p>",
        "id": 182172997,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029827
    },
    {
        "content": "<p>An alloc that impls <code>Infallible</code> never fails ?</p>",
        "id": 182173006,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575029841
    },
    {
        "content": "<p>Kind of, an alloc, which will never return on OOM</p>",
        "id": 182173027,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029874
    },
    {
        "content": "<p>But I don't know if we end up with the same problem...</p>",
        "id": 182173112,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575029976
    },
    {
        "content": "<p>We shouldn't forget that most of the users will never use or write a custom allocator or even use <code>try_reserve</code>.</p>",
        "id": 182173215,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575030081
    },
    {
        "content": "<p>So we shouldn't clutter the namespace with too much types.</p>",
        "id": 182173288,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575030136
    },
    {
        "content": "<p>But the question remains: How much sense does a generic infallible allocator make? Won't all allocator OOM at a time without introducing additional constraints?</p>",
        "id": 182173477,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575030351
    },
    {
        "content": "<p>I think that until somebody actually tries to implement this, and shows how it is used to implement <code>Vec</code>, and then how <code>Vec</code> is end up being used, it will be very hard to tell.</p>",
        "id": 182186502,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575041930
    },
    {
        "content": "<p>I'm skeptic that it will be as useful as <span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span> says,  but I'm also skeptic about this being completely useless, as <span class=\"user-mention\" data-user-id=\"219747\">@Simon Sapin</span> seems to believe. I'll probably only be able to tell when I see both options next to each other.</p>",
        "id": 182186624,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575042019
    },
    {
        "content": "<p><code>Vec::try_reserve</code> is a solution that's a bit \"in-between\", and maybe it is the best solution there is. No idea yet.</p>",
        "id": 182186647,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575042044
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span>  I am working on my allog-wg, why does <code>Box</code> use unchecked stuff?</p>",
        "id": 182221300,
        "sender_full_name": "John Ericson",
        "timestamp": 1575086568
    },
    {
        "content": "<p>That's a good catch. I forgot to remove it when I removed <code>AbortAlloc</code>, thanks</p>",
        "id": 182233854,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575110251
    },
    {
        "content": "<p>You basically reverted my <code>AbortAlloc</code> :D</p>",
        "id": 182234499,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575111367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> I tried to find <code>AbortAlloc</code> but didn't, thanks</p>",
        "id": 182241121,
        "sender_full_name": "John Ericson",
        "timestamp": 1575123864
    },
    {
        "content": "<p>I removed it at 0.7.0. You can find it in the docs for 0.6.0</p>",
        "id": 182241130,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575123903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> OK I read your explanation, thanks, and I think I get it now</p>",
        "id": 182241137,
        "sender_full_name": "John Ericson",
        "timestamp": 1575123945
    },
    {
        "content": "<p>So this goes back to what <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> said about it might be best to change the meaning of <code>try_reserve</code></p>",
        "id": 182241188,
        "sender_full_name": "John Ericson",
        "timestamp": 1575123980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> and I thought about another solution yesterday, you can see the discussion above :)</p>",
        "id": 182241192,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575123991
    },
    {
        "content": "<p><code>FallibleVec</code>?</p>",
        "id": 182241204,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124046
    },
    {
        "content": "<p>I think the current meaning of <code>try_reserve</code> is intuitive, don't you?</p>",
        "id": 182241207,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124054
    },
    {
        "content": "<p>Well let's  just talk about <code>FallibleVec</code> for a second</p>",
        "id": 182241213,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124074
    },
    {
        "content": "<p>- <code>FallibleVec</code>, but this introduces a lot more structures<br>\n- <code>Infallible</code> as another alloc trait is another option</p>",
        "id": 182241253,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124089
    },
    {
        "content": "<p>sure!</p>",
        "id": 182241254,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124091
    },
    {
        "content": "<p>So we have this split ecosytem that's part \"I don't care about allocation failure\" and \"I really care about allocation failure\"</p>",
        "id": 182241259,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124106
    },
    {
        "content": "<p>Yeah, true</p>",
        "id": 182241265,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124129
    },
    {
        "content": "<p>I want there to be libraries that support both</p>",
        "id": 182241269,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124139
    },
    {
        "content": "<p>Me too. The best case would be an API which supports both</p>",
        "id": 182241285,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124165
    },
    {
        "content": "<p>My best idea for that is the with the <code>foo</code> = <code>try_foo.infallible_unwrap()</code> pattern</p>",
        "id": 182241286,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124167
    },
    {
        "content": "<p>Is <code>FallibleVec</code> supposed to be a whole different struct?</p>",
        "id": 182241292,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124183
    },
    {
        "content": "<p>Maybe a more compatible with the above alternative would be an extension trait that you don't get in the prelude, so regular users aren't confused?</p>",
        "id": 182241341,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124209
    },
    {
        "content": "<p>Also I think a <code>type Panic = !</code> would make things a lot more intuitive?</p>",
        "id": 182241356,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124250
    },
    {
        "content": "<blockquote>\n<p>Maybe a more compatible with the above alternative would be an extension trait that you don't get in the prelude, so regular users aren't confused?</p>\n</blockquote>\n<p>I thought about that, too</p>",
        "id": 182241357,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124251
    },
    {
        "content": "<blockquote>\n<p>Also I think a type Panic = ! would make things a lot more intuitive?</p>\n</blockquote>\n<p>Yes, indeed. That's why I really  liked the <code>AllocRef&lt;Error = !&gt;</code> approach</p>",
        "id": 182241367,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124301
    },
    {
        "content": "<p>If you see <code>fn try_reserve(&amp;mut self) -&gt; Result&lt;(), Panic&gt;</code>, &lt;- after subsitutition, I think it makes a bit more sense what is going on.</p>",
        "id": 182241368,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> so back to the test failures, is this just a matter of changing the tests?</p>",
        "id": 182241489,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124517
    },
    {
        "content": "<p>In the current state (0.7.0), you can just call <code>reserve</code> and it will abort on OOM. However, when calling <code>try_reserve</code> it will return <code>Result&lt;(), Err&gt;</code>. If your allocator never fails, it still returns <code>Return&lt;(), !&gt;</code>, which is pretty intuitive. The user, who don't care about fallible collections can still use <code>reserve</code>. Do I get you right, that you want to introduce all the <code>try_</code> methods in an extension traits excluded from the prelude?</p>",
        "id": 182241493,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124523
    },
    {
        "content": "<p>You can fix this when exchanging <code>AbortAlloc&lt;Global&gt;</code> (forgot your name :) ) with <code>Global</code>. This requires a bit of dancing for the <code>String</code> tests, but it's possible. Let me search the commit, where I fixed this test - I also had those failures before.</p>",
        "id": 182241547,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> also in general, sorry for making a bug fuss and not finding the commits that showed you had tried all of the stuff in that PR.</p>",
        "id": 182241605,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124731
    },
    {
        "content": "<p>I've wasted both our time <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 182241606,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124741
    },
    {
        "content": "<p>I found the tests commit now</p>",
        "id": 182241612,
        "sender_full_name": "John Ericson",
        "timestamp": 1575124751
    },
    {
        "content": "<p>for <code>Vec</code>: <a href=\"https://github.com/TimDiekmann/alloc-wg/pull/10/commits/dfa9939e4bd6007fcd9d5a89537d3081ef1634a7\" target=\"_blank\" title=\"https://github.com/TimDiekmann/alloc-wg/pull/10/commits/dfa9939e4bd6007fcd9d5a89537d3081ef1634a7\">https://github.com/TimDiekmann/alloc-wg/pull/10/commits/dfa9939e4bd6007fcd9d5a89537d3081ef1634a7</a><br>\nfor <code>String</code>: <a href=\"https://github.com/TimDiekmann/alloc-wg/pull/10/commits/06fff0335cc00abf195659056cb52286b43b43d5\" target=\"_blank\" title=\"https://github.com/TimDiekmann/alloc-wg/pull/10/commits/06fff0335cc00abf195659056cb52286b43b43d5\">https://github.com/TimDiekmann/alloc-wg/pull/10/commits/06fff0335cc00abf195659056cb52286b43b43d5</a></p>",
        "id": 182241614,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124757
    },
    {
        "content": "<p>Me too <span aria-label=\"yum\" class=\"emoji emoji-1f60b\" role=\"img\" title=\"yum\">:yum:</span></p>",
        "id": 182241615,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124769
    },
    {
        "content": "<p>I think you better \"waste\" my time for one hour, than don't participate at all :)<br>\nNow you know about my design decisions, so don't worry <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 182241669,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124826
    },
    {
        "content": "<p>Don't know if the second commit is required now, but the first definitely fixed your test case</p>",
        "id": 182241688,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575124911
    },
    {
        "content": "<p>But back to the design: I don't think we should stick with <code>AbortAlloc</code>/<code>PanicAdapter</code> at all. Do you want to try out, how the extension trait works out?<br>\nPersonally, I'd love to have more traits on collections anyway, but this is another story.</p>",
        "id": 182241748,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575125002
    },
    {
        "content": "<p>Like generic traits for slicing, random access, len etc.</p>",
        "id": 182241793,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575125051
    },
    {
        "content": "<p>But this wasn't done yet due to the lack of GAT</p>",
        "id": 182241799,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575125066
    },
    {
        "content": "<p>GAT?</p>",
        "id": 182242542,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126415
    },
    {
        "content": "<p>Generic associated type</p>",
        "id": 182242552,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126426
    },
    {
        "content": "<p>ah ok</p>",
        "id": 182242558,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126432
    },
    {
        "content": "<p>yeah it is ugly without it</p>",
        "id": 182242559,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126438
    },
    {
        "content": "<p>So if you like <code>type Panic = !</code>, what is the remaing issue with the adapter?</p>",
        "id": 182242565,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126468
    },
    {
        "content": "<p>Or really, I am much more fond of the <code>Error = !</code> bounds than the adapter itself</p>",
        "id": 182242610,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126490
    },
    {
        "content": "<p>I combined my work with the reverts or reverts, and the tests pass now</p>",
        "id": 182242616,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126525
    },
    {
        "content": "<p>fwiw</p>",
        "id": 182242618,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126530
    },
    {
        "content": "<p>Calling <code>try_reserve</code> with <code>AbortAlloc</code> has an unintuitive behavior: It aborts on OOM. When <code>AbortAlloc</code> is the default for <code>Vec</code>, <code>try_reserve</code> is pretty useless for non-custom allocators</p>",
        "id": 182242633,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126581
    },
    {
        "content": "<p>The expected behavior would be, that it aborts on <code>reserve</code> and returns a result on <code>try_reserve</code></p>",
        "id": 182242697,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126671
    },
    {
        "content": "<p>But without an additional trait or more methods in <code>ReallocRef</code> this isn't possible</p>",
        "id": 182242700,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> Are you just worried about <code>try_reserve</code>, or all such <code>try_*</code> methods?</p>",
        "id": 182242763,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126762
    },
    {
        "content": "<p>All <code>try_*</code> methods</p>",
        "id": 182242770,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126778
    },
    {
        "content": "<p>So we could do some associated type monstrosity to fix this</p>",
        "id": 182242789,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126820
    },
    {
        "content": "<p>But <code>try_reserve</code> is the most intuitive example. What's the point on having <code>Vec::&lt;T, AbortAlloc&lt;Global&gt;&gt;::try_reserve</code> if it only checks for capacity overflow?</p>",
        "id": 182242798,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126834
    },
    {
        "content": "<p>so, this would be </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"o\">!</span><span class=\"p\">[];</span><span class=\"w\"></span>\n<span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">try_reserve</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// may abort</span>\n</pre></div>",
        "id": 182242852,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126898
    },
    {
        "content": "<p>Yes, the point is just so <code>reserve</code> can be written in terms of <code>try_reserve</code></p>",
        "id": 182242861,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126909
    },
    {
        "content": "<p>BTW, how does capacity overlow happen without an alloc failure? Shouldn't it be underflow?</p>",
        "id": 182242867,
        "sender_full_name": "John Ericson",
        "timestamp": 1575126948
    },
    {
        "content": "<p>You can still do this, but you get the desired behavior when not using <code>AbortAlloc</code> and dropping the <code>Error = !</code> bound</p>",
        "id": 182242870,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575126957
    },
    {
        "content": "<p>capacity overflow may only occure on 16bit and 32 bit platforms, as only <code>isize</code> capacity is allowed there. If you try to reserve <code>isize::MAX / 4</code> slots with <code>size_of::&lt;T&gt;() == 8</code> it will overflow</p>",
        "id": 182242932,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575127039
    },
    {
        "content": "<p>Wouldn't that also be an allocation failure?</p>",
        "id": 182242983,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127094
    },
    {
        "content": "<p>err nevermind</p>",
        "id": 182242988,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127114
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> So honestly if what is in alloc-wg landed soon, and the <code>try_*</code> methods were unstable until GAT, I would be perfectly happy</p>",
        "id": 182243021,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127191
    },
    {
        "content": "<p>what do you think about that?</p>",
        "id": 182243024,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127198
    },
    {
        "content": "<blockquote>\n<p>Wouldn't that also be an allocation failure?</p>\n</blockquote>\n<p>Yes, but currently <code>CapacityOverflow</code> simply panics in <code>RawVec::reserve</code>. In <code>RawVec::try_reserve</code> it returns <code>Err(CapacityAllocError::CapacityOverflow)</code>.<br>\n<code>Vec::try_reserve</code> also returns <code>Result&lt;(), CapacityAllocError&gt;</code>, but only the <code>CapacityOverflow</code> variant.</p>",
        "id": 182243187,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575127465
    },
    {
        "content": "<p>Even if the alloc-wg stuff will be merged upstream, it will take at least a year I guess until anything is stabilized. GATs are not required for the <code>try_*</code> methods, only for other trait methods on collections, but this is another story and probably out of scope for this WG (currently).</p>",
        "id": 182243217,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575127548
    },
    {
        "content": "<p>It might be for like <code>clone_in</code> and other multi-allocator ones?</p>",
        "id": 182243266,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127597
    },
    {
        "content": "<p>No, generic trait methods for more collections. <code>CloneIn</code> is possible without GATs, too. However, even if a trait would need GATs I'd also be fine waiting for it. We shouldn't make the API more complicated than necessary, only because an approved language feature isn't completed yet.</p>",
        "id": 182243330,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575127705
    },
    {
        "content": "<p>sorry <code>try_clone_in</code> if we wanted to somehow gate that too</p>",
        "id": 182243346,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127786
    },
    {
        "content": "<p><a href=\"https://docs.rs/alloc-wg/0.7.0/alloc_wg/clone/trait.CloneIn.html#tymethod.try_clone_in\" target=\"_blank\" title=\"https://docs.rs/alloc-wg/0.7.0/alloc_wg/clone/trait.CloneIn.html#tymethod.try_clone_in\"><code>try_clone_in</code></a> <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 182243398,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575127847
    },
    {
        "content": "<p>Oh right, that workaround</p>",
        "id": 182243407,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127874
    },
    {
        "content": "<p>And an additional trait could also use it</p>",
        "id": 182243411,
        "sender_full_name": "John Ericson",
        "timestamp": 1575127884
    },
    {
        "content": "<p>master doc: <a href=\"https://timdiekmann.github.io/alloc-wg/alloc_wg/clone/trait.CloneIn.html#tymethod.try_clone_in\" target=\"_blank\" title=\"https://timdiekmann.github.io/alloc-wg/alloc_wg/clone/trait.CloneIn.html#tymethod.try_clone_in\">https://timdiekmann.github.io/alloc-wg/alloc_wg/clone/trait.CloneIn.html#tymethod.try_clone_in</a></p>",
        "id": 182243412,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575127887
    },
    {
        "content": "<p>But I'm unsure about the error type there. The error type may should be associated with the <code>CloneIn</code> trait itself, so we can return <code>CollectionAllocErr</code> to retrieve the layout</p>",
        "id": 182243473,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575127987
    },
    {
        "content": "<p>This is dropped <a href=\"https://timdiekmann.github.io/alloc-wg/src/alloc_wg/vec.rs.html#2215\" target=\"_blank\" title=\"https://timdiekmann.github.io/alloc-wg/src/alloc_wg/vec.rs.html#2215\">here</a></p>",
        "id": 182243478,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128019
    },
    {
        "content": "<p>Ah that</p>",
        "id": 182243533,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span>  To finish this topic, do you agree that <code>AbortAlloc</code> makes no sense like this?</p>",
        "id": 182243534,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128081
    },
    {
        "content": "<p>I think it makes sense if you are very used to <code>!</code>,  but I'm fine not doing it unless it can be made less surprising for everything that isn't.</p>",
        "id": 182243558,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128152
    },
    {
        "content": "<p>The big battle here is just getting <code>try_</code> methods on the collections at all</p>",
        "id": 182243598,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128167
    },
    {
        "content": "<p>Yeah, it's a nice thing regarding <code>!</code>, but incompatible with <code>try_*</code>.</p>",
        "id": 182243606,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128202
    },
    {
        "content": "<p>So without the <code>Error = !</code> bounds, I suspect people will push to drop the associated error type altogether?</p>",
        "id": 182243619,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128246
    },
    {
        "content": "<p>However, <code>Error=!</code> as bound on <code>reserve</code> and other non-<code>try_</code> methods is just a way to force the user to use <code>try</code> instead.</p>",
        "id": 182243625,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128260
    },
    {
        "content": "<p>Yes, it is nice to pass in a collection to a library that is allocator polymorphic, and force it to do the right thing</p>",
        "id": 182243677,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128320
    },
    {
        "content": "<blockquote>\n<p>So without the Error = ! bounds, I suspect people will push to drop the associated error type altogether?</p>\n</blockquote>\n<p>Yes, another thing I totally forgot: You would have need to wrap nearly all allocators in <code>AbortAlloc</code> to just ignore the associated error. Just as you mentioned, the ecosystem is split there.</p>",
        "id": 182243678,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128321
    },
    {
        "content": "<p>It's a nice thing, if you <strong>want</strong> to never panic/abort. But that's only the unusual case.</p>",
        "id": 182243693,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128379
    },
    {
        "content": "<p>Normal programs will never recover from OOM anyway.</p>",
        "id": 182243698,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128395
    },
    {
        "content": "<p>We can still support both ecosystem with the approach on master today</p>",
        "id": 182243739,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128409
    },
    {
        "content": "<p>And the capacity overflow panic is a bug in the program</p>",
        "id": 182243741,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128411
    },
    {
        "content": "<p>Just you are really reliant on checking for master by hand</p>",
        "id": 182243745,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128423
    },
    {
        "content": "<p>But I'll admit that any library should be able to do the <code>foo</code> <code>try_foo</code> duplication with the panic rather than <code>Error = !</code> bound</p>",
        "id": 182243755,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128454
    },
    {
        "content": "<p>so the same libraries can support both still</p>",
        "id": 182243764,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128469
    },
    {
        "content": "<p>Yeah I am much more sympathetic to capacity overflow always being a regular overflow panic</p>",
        "id": 182243779,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128510
    },
    {
        "content": "<p>and well, if you don't want to panic run a model checker or something</p>",
        "id": 182243783,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128521
    },
    {
        "content": "<p>as you shouldn't sanitize uncontrolled values by catching those errors, since as you say this program really is broken whereas normal allocation failure can be not the program's fault</p>",
        "id": 182243848,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128577
    },
    {
        "content": "<p>Another Idea: I think we are able to support both ecosystems this way: ...</p>",
        "id": 182243865,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128596
    },
    {
        "content": "<p>- Introduce a marker trait <code>Abort</code><br>\n- for <code>reserve</code> and allocating non-<code>try_*</code> methods add this as bound<br>\n- Implement <code>Abort</code> on <code>Global</code> and <code>System</code></p>",
        "id": 182243877,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128640
    },
    {
        "content": "<p>That's basically the inversion of <code>AbortAlloc</code>, right?</p>",
        "id": 182243929,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128688
    },
    {
        "content": "<p>And if you want to be forced to check OOM, you just have to wrap your allocator but don't implement <code>Abort</code></p>",
        "id": 182243957,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128714
    },
    {
        "content": "<p>:)</p>",
        "id": 182243961,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128722
    },
    {
        "content": "<p>That also removes the very missleading term of \"infallible\"</p>",
        "id": 182243967,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128734
    },
    {
        "content": "<p><code>Global</code> isn't infallible, we want to ignore the error</p>",
        "id": 182243977,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128751
    },
    {
        "content": "<p><code>Abort</code> allows the allocator to fail</p>",
        "id": 182244005,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128762
    },
    {
        "content": "<p>the one thing is it's the collection doing the panicking, not the allocator, right?</p>",
        "id": 182244033,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128797
    },
    {
        "content": "<p>I think you want <code>Abort</code> and <code>AbortAlloc</code></p>",
        "id": 182244036,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128808
    },
    {
        "content": "<p>Yes, I think so</p>\n<p>Hmm, let's see. let me write a few lines of code...</p>",
        "id": 182244056,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128851
    },
    {
        "content": "<p>if you have an <code>A: Abort</code> Then it does a cast to <code>AbortAlloc&lt;A&gt;</code> and calls the method with that?</p>",
        "id": 182244058,
        "sender_full_name": "John Ericson",
        "timestamp": 1575128854
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">DeallocRef</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">reserve</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">additional</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">A</span>: <span class=\"nc\">ReallocRef</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">try_reserve</span><span class=\"p\">(</span><span class=\"n\">additional</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">CollectionAllocErr</span>::<span class=\"n\">CapacityOverflow</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">capacity_overflow</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">CollectionAllocErr</span>::<span class=\"n\">AllocError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">layout</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">..</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">handle_alloc_error</span><span class=\"p\">(</span><span class=\"n\">layout</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">try_reserve</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">additional</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">CollectionAllocErr</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">A</span>: <span class=\"nc\">ReallocRef</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">buf</span><span class=\"p\">.</span><span class=\"n\">try_reserve</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">additional</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 182244128,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575128971
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// Don&#39;t implement `Abort` on `SaveAlloc`</span>\n<span class=\"k\">struct</span> <span class=\"nc\">SaveAlloc</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// impl `AllocRef` etc. for `SaveAlloc`</span>\n</pre></div>",
        "id": 182244235,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129086
    },
    {
        "content": "<p>oh nice!</p>",
        "id": 182244240,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129103
    },
    {
        "content": "<p>Yeah that's good, you can make a method that also requires <code>Abort</code> which calls <code>handle_alloc_error</code></p>",
        "id": 182244245,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129110
    },
    {
        "content": "<p>Yeah, true! nice!</p>",
        "id": 182244247,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129121
    },
    {
        "content": "<p>the <code>A</code> is sort of phantom as it takes an <code>Result&lt;T, A::Error&gt;</code></p>",
        "id": 182244290,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129133
    },
    {
        "content": "<p>and another for <code>Result&lt;T, CollectionsError&lt;A::Error&gt;&gt;</code></p>",
        "id": 182244296,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129156
    },
    {
        "content": "<p>Wow, I'm very excited, I think this is really a very good solution :)</p>",
        "id": 182244326,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129225
    },
    {
        "content": "<p>me too! I was worried it would be endless type machinary, but this isn't even that bad!</p>",
        "id": 182244373,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129251
    },
    {
        "content": "<p>It's just a single marker trait. We already got plenty marker traits anyway</p>",
        "id": 182244384,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129271
    },
    {
        "content": "<p>yeah that's not a controversial thing by now</p>",
        "id": 182244403,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129333
    },
    {
        "content": "<p>If you want to delegate to me to write it up, then you can get your time back with me rehashing the old AbortAlloc :)</p>",
        "id": 182244407,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129356
    },
    {
        "content": "<p>I have to go now anyway. If you want to do this, go ahead!</p>",
        "id": 182244453,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129382
    },
    {
        "content": "<p>I'll close your current PR then?</p>",
        "id": 182244454,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129388
    },
    {
        "content": "<p>Yeah</p>",
        "id": 182244476,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129465
    },
    {
        "content": "<p>Hey:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">AllocRef</span><span class=\"o\">&lt;</span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 182244517,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129486
    },
    {
        "content": "<p>Yes can do that too, though will still need the separate <code>Global</code> and <code>System</code> ones</p>",
        "id": 182244522,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129532
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 182244526,
        "sender_full_name": "Gurwinder Singh",
        "timestamp": 1575129540
    },
    {
        "content": "<blockquote>\n<p>Yes can do that too, though will still need the separate <code>Global</code> and <code>System</code> ones</p>\n</blockquote>\n<p>Sure, but at least you don't have to implement <code>Abort</code> on any new allocators :)</p>",
        "id": 182244591,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129652
    },
    {
        "content": "<p>Isn't this a good point to keep the associated error type?</p>",
        "id": 182244738,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575129870
    },
    {
        "content": "<p>Yes it is!</p>",
        "id": 182244825,
        "sender_full_name": "John Ericson",
        "timestamp": 1575129996
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> OK so first issue is I think we do need AbortAlloc with this, because in general don't have the <code>layout</code> for <code>handle_alloc_error</code></p>",
        "id": 182244832,
        "sender_full_name": "John Ericson",
        "timestamp": 1575130030
    },
    {
        "content": "<p>this is partially why the boxed ones still use <code>unwrap_unchecked</code>  by mistake</p>",
        "id": 182244837,
        "sender_full_name": "John Ericson",
        "timestamp": 1575130051
    },
    {
        "content": "<p>it's a lot less mechanical to fix</p>",
        "id": 182244841,
        "sender_full_name": "John Ericson",
        "timestamp": 1575130059
    },
    {
        "content": "<p>but <code>AbortAlloc</code> can be private</p>",
        "id": 182244842,
        "sender_full_name": "John Ericson",
        "timestamp": 1575130065
    },
    {
        "content": "<p>Yes, this would replace the <code>AbortAlloc</code> thing entirely.</p>\n<p>I don't have more time today to head more into this, I'll look more into this tomorrow :)<br>\nJust go ahead :)</p>",
        "id": 182245458,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575131114
    },
    {
        "content": "<p>FWIW the <code>FallibleVec</code> would be what <code>Vec</code> is today</p>",
        "id": 182247866,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575135245
    },
    {
        "content": "<p>and <code>Vec</code> would just become a \"thin\" wrapper over <code>FallibleVec</code> that \"<code>.unwraps()</code>\" (calls <code>handle_alloc_error</code>)  on every method</p>",
        "id": 182247871,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575135264
    },
    {
        "content": "<p>There wouldn't be any <code>_try</code> methods</p>",
        "id": 182247946,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575135371
    },
    {
        "content": "<p>You would just pick <code>Vec</code> or <code>FallibleVec</code> depending on whether you want an infallible or fallible API</p>",
        "id": 182247953,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575135388
    },
    {
        "content": "<p>Yes, but it would introduce many many new structs</p>",
        "id": 182248295,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575135914
    },
    {
        "content": "<blockquote>\n<p>You would just pick <code>Vec</code> or <code>FallibleVec</code> depending on whether you want an infallible or fallible API</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> beyond the many new structs, it would be much harder to reuse the implementation</p>",
        "id": 182249333,
        "sender_full_name": "John Ericson",
        "timestamp": 1575137456
    },
    {
        "content": "<p><a href=\"https://github.com/TimDiekmann/alloc-wg/pull/16\" target=\"_blank\" title=\"https://github.com/TimDiekmann/alloc-wg/pull/16\">https://github.com/TimDiekmann/alloc-wg/pull/16</a> is now up with <span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span>'s <code>Abort</code> trait idea. I had to put in <code>AllocAbort</code> as an implementation detail, but a better method might be changing the error types to be something ~~ <code>(AllocError, NonZeroLayout)</code></p>",
        "id": 182249348,
        "sender_full_name": "John Ericson",
        "timestamp": 1575137522
    },
    {
        "content": "<p>I say we try to get this one merged with the private <code>AllocAbort</code>, and then make another issue for the error handling, as the temporary <code>AllocAbort</code> is good to make the issue clear.</p>",
        "id": 182249402,
        "sender_full_name": "John Ericson",
        "timestamp": 1575137607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span> by many new structs you mean, ~5 structs ? (Vec, List, HashMap, BTreeSet, Deque) ?</p>",
        "id": 182326746,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575278250
    },
    {
        "content": "<p>Also, why do you think it would be harder to reuse the implementation ?</p>",
        "id": 182326755,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575278265
    },
    {
        "content": "<p>You can reuse <code>Vec</code> like you do today, and for <code>FallibleVec</code> it would be just the same.</p>",
        "id": 182326769,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575278276
    },
    {
        "content": "<p>At least those 5 structs + strings + any other structs that will be associated with an allocator.<br>\nAdditionally, every api addition has to be added to both structs, which is very error prone. Also, it's a huge documentation bloat. I don't see the advantages of <code>FallibleVec</code> in comparison to the <code>Abort</code> trait or the current solution.</p>",
        "id": 182350837,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575297454
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/wg-allocators/issues/7\" target=\"_blank\" title=\"https://github.com/rust-lang/wg-allocators/issues/7\">Tracking Issue for structs which needs an allocator</a><br>\nThis would introduce at least 15(!) new structs for a rarely used API.</p>",
        "id": 182350968,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575297536
    },
    {
        "content": "<p>Yeah those 15 types would be pretty much it</p>",
        "id": 182351378,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575297817
    },
    {
        "content": "<p>Many API additions already need to be added to multiple types, e.g., to <code>Vec</code> and <code>RawVec</code>, particularly when they interact with allocators</p>",
        "id": 182351452,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575297850
    },
    {
        "content": "<p>notice that this duplication of the API is only required for functions that could allocate</p>",
        "id": 182351466,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575297866
    },
    {
        "content": "<p>so maybe there is a better way to land it than duplicating all structs</p>",
        "id": 182351480,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575297882
    },
    {
        "content": "<p>I doubt that though, because while it is possible to write an infallible API on top of a fallible one, e.g., using a trait, you can't write a fallible API on top of an infallible one</p>",
        "id": 182351541,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575297920
    },
    {
        "content": "<p>also, with a stable allocator interface, if somebody wants a fallible vector, they can just use one from <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a></p>",
        "id": 182351643,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575297982
    },
    {
        "content": "<p>doing that this way literally requires duplicating most of the code, but it can be done</p>",
        "id": 182351736,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575298062
    },
    {
        "content": "<p>@gnzlbg I'm confused. There's now way to write arbitrary vec-polymorphic code without higher kinded types, so having multiple vecs seems like a disaster? What problems do you have with <a href=\"https://github.com/TimDiekmann/alloc-wg/pull/16\" target=\"_blank\" title=\"https://github.com/TimDiekmann/alloc-wg/pull/16\">https://github.com/TimDiekmann/alloc-wg/pull/16</a> ?</p>",
        "id": 182353016,
        "sender_full_name": "John Ericson",
        "timestamp": 1575298839
    },
    {
        "content": "<p>Also confused about the <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a> bit. I agree it would be good if more collections came from crates.io—std can even have private deps and re-export. But this is totally  separate from allocator stuff? I.e. we should \"pull a hash brown\" for everything else anyways?</p>",
        "id": 182353277,
        "sender_full_name": "John Ericson",
        "timestamp": 1575298986
    },
    {
        "content": "<blockquote>\n<p>What problems do you have with <a href=\"https://github.com/TimDiekmann/alloc-wg/pull/16\" target=\"_blank\" title=\"https://github.com/TimDiekmann/alloc-wg/pull/16\">https://github.com/TimDiekmann/alloc-wg/pull/16</a> ?</p>\n</blockquote>\n<p>If I'm writing a library that should propagate all alloaction errors to users, and my library uses an API like <code>Vec::extend</code>, how do I propagate the allocation error to a user such that it can recover ?</p>",
        "id": 182354941,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575299912
    },
    {
        "content": "<blockquote>\n<p>There's now way to write arbitrary vec-polymorphic code without higher kinded types, so having multiple vecs seems like a disaster?</p>\n</blockquote>\n<p>Why would you need that ?</p>",
        "id": 182355251,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575300068
    },
    {
        "content": "<p>If you have an API that should accept / return multiple vector types, like <code>Vec</code>, <code>SmallVec</code>, or <code>ArrayVec</code>, then you can write a <code>VecLike</code> trait, and implement it for those types.</p>",
        "id": 182355321,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575300112
    },
    {
        "content": "<p>I don't see how another kind of <code>Vec</code> makes this problem worse.</p>",
        "id": 182355377,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575300130
    },
    {
        "content": "<blockquote>\n<p>If I'm writing a library that should propagate all alloaction errors to users, and my library uses an API like <code>Vec::extend</code>, how do I propagate the allocation error to a user such that it can recover ?</p>\n</blockquote>\n<p>You write a <code>mylib::try_method</code> with <code>Vec::try_extend</code>, and then in the same manner make your <code>mylib::method</code> in terms of <code>mylib::try_method</code>.</p>",
        "id": 182356732,
        "sender_full_name": "John Ericson",
        "timestamp": 1575300826
    },
    {
        "content": "<blockquote>\n<p>I don't see how another kind of Vec makes this problem worse.</p>\n</blockquote>\n<p>I don't see how another kind of <code>Vec</code> makes this problem worse. It doesn't make the problem worse, but it's already bad. There's no good way to write <code>VecLike</code> today, and generic associated types only make that slightly better.</p>",
        "id": 182356829,
        "sender_full_name": "John Ericson",
        "timestamp": 1575300878
    },
    {
        "content": "<p>I reviewed your PR <span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span>. Thanks again for implementing it :)</p>",
        "id": 182366178,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575306324
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220594\">@John Ericson</span> </p>\n<blockquote>\n<p>You write a mylib::try_method with Vec::try_extend</p>\n</blockquote>\n<p>There is no <code>try_extend</code> method.</p>",
        "id": 182461186,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575387703
    },
    {
        "content": "<p>And that approach would require duplicating most of the API of all collections</p>",
        "id": 182461208,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575387719
    },
    {
        "content": "<p>I don't see how that is better than having two types providing the different APIs, and without the <code>try_</code> suffixes</p>",
        "id": 182461286,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575387752
    },
    {
        "content": "<blockquote>\n<p>It doesn't make the problem worse, but it's already bad. There's no good way to write VecLike today, and generic associated types only make that slightly better.</p>\n</blockquote>\n<p>I see that as an orthogonal issue. The argument that we should not do this because it would make something that's already impossible to do not harder isn't very strong.</p>",
        "id": 182461396,
        "sender_full_name": "gnzlbg",
        "timestamp": 1575387831
    },
    {
        "content": "<p>I actually tried out a <code>FallibleVec</code>. Besides my previous concerns, I also went into a no-go: You cannot trivially switch between a fallible and an aborting allocation, you have to know beforehand, if all OOMs aborts or return a <code>Result</code>.</p>",
        "id": 182948732,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575892617
    },
    {
        "content": "<p>With the <code>Abort</code> marker trait, you can chose, if you allow aborting: you have to implement <code>Abort</code> for your allocator. If you don't implement it, the collection cannot abort. But if you do, you can chose, if your current allocation is allowed to abort or not.</p>",
        "id": 182948840,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1575892746
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> i'm not sure i follow</p>",
        "id": 183361252,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576245837
    },
    {
        "content": "<p>With a <code>FallibleVec</code> if a call to an allocation function returns <code>ptr::null()</code> then you just propagate <code>Result::Err</code> up to the caller. The caller is then in charge of , if that <code>Result</code> is an error, calling <code>handle_alloc_error</code></p>",
        "id": 183361383,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576245917
    },
    {
        "content": "<p>e.g. that;s what a <code>Vec&lt;T&gt;</code> wrapper built on top of <code>FallibleVec&lt;T&gt;</code> would do</p>",
        "id": 183361393,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576245933
    },
    {
        "content": "<p>(this is in the current world where there is no <code>AllocRef</code> trait)</p>",
        "id": 183361421,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576245954
    },
    {
        "content": "<p>Which vector would you use, when you don't care about OOM in one place, but catch OOMs in another place?</p>",
        "id": 183361502,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576245998
    },
    {
        "content": "<p>When you don't care about OOM, you use <code>Vec&lt;T&gt;</code>, which calls <code>handle_alloc_error</code> on OOM</p>",
        "id": 183361656,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246115
    },
    {
        "content": "<p>When you care about OOM you use <code>FallibleVec</code> which returns a <code>Result::Err</code> on OOM</p>",
        "id": 183361675,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246133
    },
    {
        "content": "<p>Yeah, but you need two dedicated structs here<br>\nYou always have to know beforehand if you want to catch OOM or not</p>",
        "id": 183361700,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246152
    },
    {
        "content": "<p>The layout of both vector types is identical, so if you need to handle OOM in certain situations, and not in others</p>",
        "id": 183361706,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246157
    },
    {
        "content": "<p>you can just go from Vec -&gt; FallibleVec and from FallibleVec-&gt;Vec</p>",
        "id": 183361725,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246172
    },
    {
        "content": "<p>its a noop</p>",
        "id": 183361731,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246177
    },
    {
        "content": "<p>well sure, that's the point, allowing users that know before hand what they want what to do</p>",
        "id": 183361797,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246206
    },
    {
        "content": "<p>Hmm, That's a pretty bad design IMO, as you probably want to store the vector in a struct</p>",
        "id": 183361809,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246222
    },
    {
        "content": "<p>if you need a library that supports both, you can always just use FallibleVec</p>",
        "id": 183361813,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246225
    },
    {
        "content": "<p>And call <code>handle_alloc_error</code> manually?</p>",
        "id": 183361824,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246241
    },
    {
        "content": "<p>Or propagate the errors to the API of your library</p>",
        "id": 183361837,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246260
    },
    {
        "content": "<p>if the final binary doesn't care about OOM, they can just choose a global allocator that does that for you to fail fast</p>",
        "id": 183361858,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246284
    },
    {
        "content": "<blockquote>\n<p>Hmm, That's a pretty bad design IMO, as you probably want to store the vector in a struct</p>\n</blockquote>\n<p>Maybe, you can just swap the Vec out, since that is a nop as well</p>",
        "id": 183361969,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246357
    },
    {
        "content": "<p>But i'm open to any better design that satisfies all the constraints</p>",
        "id": 183361974,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246366
    },
    {
        "content": "<p>The current design supports all constraints :D</p>",
        "id": 183362010,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246388
    },
    {
        "content": "<p>Then I didn't understood it, because <code>Vec::push</code> calls <code>handle_alloc_err</code></p>",
        "id": 183362021,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246403
    },
    {
        "content": "<p>and that's a constraint that it doesn't satisfy AFAICT</p>",
        "id": 183362031,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246416
    },
    {
        "content": "<p>Yeah, this is just like the current implementation does</p>",
        "id": 183362058,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246441
    },
    {
        "content": "<p>Yeah, so I think a constraint is that every function that can trigger an OOM in any std collection should be recoverable</p>",
        "id": 183362116,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246464
    },
    {
        "content": "<p>If you want to get the alloc-error on <code>push</code> you have to call <code>try_push</code></p>",
        "id": 183362125,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246468
    },
    {
        "content": "<p>And I'd prefer not to have to learn which subset of these APIs are available via <code>try_</code> methods</p>",
        "id": 183362138,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246482
    },
    {
        "content": "<p>but instead just be able to call the normal method and get a result</p>",
        "id": 183362150,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246491
    },
    {
        "content": "<p>That's a good point</p>",
        "id": 183362170,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246511
    },
    {
        "content": "<p>if you don't want to move the vector out of a struct, you can always have a <code>Vec::fallible_mut_ref(&amp;mut self) -&gt; &amp;mut FallibleVec</code></p>",
        "id": 183362180,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246525
    },
    {
        "content": "<p>that provides fallible operations</p>",
        "id": 183362185,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246529
    },
    {
        "content": "<p>because they have the exact same layout, you can safely transmute a &amp;Vec/&amp;mut Vec into a &amp;FallibleVec/&amp;mut FallibleVec in place</p>",
        "id": 183362216,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246560
    },
    {
        "content": "<p>But then <code>Vec</code> and <code>FallibleVec</code> are not interchangable</p>",
        "id": 183362251,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246563
    },
    {
        "content": "<p>as the signatures of the functions differ</p>",
        "id": 183362271,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246570
    },
    {
        "content": "<p>that's the goal?</p>",
        "id": 183362285,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246579
    },
    {
        "content": "<p>with one API, you don't get <code>Result</code>s returned, because you don't care</p>",
        "id": 183362299,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246591
    },
    {
        "content": "<p>Yeah, but then it's pretty unflexible</p>",
        "id": 183362300,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246592
    },
    {
        "content": "<p>and with the other, you get Results returned, because you do care</p>",
        "id": 183362314,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246600
    },
    {
        "content": "<p>and you can choose whether you care or not</p>",
        "id": 183362326,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246612
    },
    {
        "content": "<p>If you do care about OOM, you can just use an allocator, which does not support aborting</p>",
        "id": 183362337,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246623
    },
    {
        "content": "<p>Whether to abort on OOM or not is not up to the allocator though</p>",
        "id": 183362360,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246642
    },
    {
        "content": "<p>Then the compiler won't let you call <code>push</code></p>",
        "id": 183362366,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246648
    },
    {
        "content": "<p>Then you have two types <code>Vec&lt;T, A&gt;</code>, and <code>Vec&lt;T, AbortA&gt;</code> and these types are not interchangeable AFAICT</p>",
        "id": 183362404,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246676
    },
    {
        "content": "<p>Maybe we need a third opinion here :)</p>",
        "id": 183362409,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246678
    },
    {
        "content": "<p>But you can call any methods on <code>Vec&lt;T, AbortA&gt;</code></p>",
        "id": 183362470,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246700
    },
    {
        "content": "<p>Your option of not allowing calling <code>Vec::push</code> still has the drawback of requiring to duplicate the whole API with <code>try_</code> methods.</p>",
        "id": 183362492,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246717
    },
    {
        "content": "<p>With your option you has to duplicate the whole vector, even the non-allocating functions</p>",
        "id": 183362540,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576246752
    },
    {
        "content": "<p>Sure, but users don't have to learn any new APIs</p>",
        "id": 183362557,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246763
    },
    {
        "content": "<p>Duplicating the whole vector is cheap</p>",
        "id": 183362567,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246770
    },
    {
        "content": "<p>Gbzlbg we can do something about the try thing long term</p>",
        "id": 183362599,
        "sender_full_name": "John Ericson",
        "timestamp": 1576246796
    },
    {
        "content": "<p>As in, its just a simple wrapper type <code>struct Vec&lt;T, A&gt;(FallibleVec&lt;T, A&gt;);</code> that exposes the same API as FallibleVec, but calling handle_alloc_error instead of returning Result</p>",
        "id": 183362659,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246811
    },
    {
        "content": "<p>But it's a lot harder to merge two types that have impls in the wild long term</p>",
        "id": 183362660,
        "sender_full_name": "John Ericson",
        "timestamp": 1576246812
    },
    {
        "content": "<p>I think having the collections be infallible by default, but offering a way to get a fallible handle, is much more simpler for users, than duplicating the whole API with different function names.</p>",
        "id": 183362727,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246868
    },
    {
        "content": "<p>its also more amenable for <code>macro!</code>s, since they don't have to, e.g., concatenate <code>try_</code> to identifiers</p>",
        "id": 183362742,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246884
    },
    {
        "content": "<p>although that would be another option, e.g., <code>fallible!(foo.push())</code> gets expanded to <code>foo.try_push()</code></p>",
        "id": 183362832,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576246925
    },
    {
        "content": "<p>With the current way it's really easy to make foo and try_foo methods downstream</p>",
        "id": 183362880,
        "sender_full_name": "John Ericson",
        "timestamp": 1576246972
    },
    {
        "content": "<p>That's a big requirement for me</p>",
        "id": 183362888,
        "sender_full_name": "John Ericson",
        "timestamp": 1576246978
    },
    {
        "content": "<p>So we can actually have an ecosystem that supports both</p>",
        "id": 183362912,
        "sender_full_name": "John Ericson",
        "timestamp": 1576246990
    },
    {
        "content": "<p>Two types create <em>so</em> much more friction</p>",
        "id": 183363016,
        "sender_full_name": "John Ericson",
        "timestamp": 1576247057
    },
    {
        "content": "<p>I don't think anyone is going to bother supporting both</p>",
        "id": 183363025,
        "sender_full_name": "John Ericson",
        "timestamp": 1576247069
    },
    {
        "content": "<p>And the whole thing is dead in the water</p>",
        "id": 183363034,
        "sender_full_name": "John Ericson",
        "timestamp": 1576247078
    },
    {
        "content": "<p>I don't understand the difference</p>",
        "id": 183363270,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247253
    },
    {
        "content": "<p>Maybe you can try to explain it in a different way?</p>",
        "id": 183363278,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247261
    },
    {
        "content": "<p>With my proposal, when you implement a collection, you make all methods fallible, and then generate a wrapper that just calls <code>handle_alloc_error</code>, you can probably auto-generate the infallible wrapper with a proc macro derive.</p>",
        "id": 183363382,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247315
    },
    {
        "content": "<p>Since you can go from one type to the other, you don't have to support two types AFAICT.</p>",
        "id": 183363432,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247356
    },
    {
        "content": "<p>Or at least, no more than having to support different kinds of collections.</p>",
        "id": 183363469,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247388
    },
    {
        "content": "<p>I mean, if you have something like serde serialize, it is trivial to derive two implementation for the two vectors, such that one propagates oom errors and the otherone doesn't</p>",
        "id": 183363581,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247439
    },
    {
        "content": "<p>If you only have a single <code>Vec</code> type with <code>Vec::try_</code> methods, you get a single <code>Deserialize</code> implementation, that's not going to use the <code>Vec::try_</code> methods.</p>",
        "id": 183363635,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247469
    },
    {
        "content": "<p>and if you want to recover from a deserialization that fails due to OOM, you need to write a vector wrapper anyways</p>",
        "id": 183363667,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247496
    },
    {
        "content": "<p>Say your type has public constructors and uses Vec</p>",
        "id": 183363812,
        "sender_full_name": "John Ericson",
        "timestamp": 1576247589
    },
    {
        "content": "<p>Say your type has methods that use Vec</p>",
        "id": 183363828,
        "sender_full_name": "John Ericson",
        "timestamp": 1576247597
    },
    {
        "content": "<p>Now you can't use macro</p>",
        "id": 183363843,
        "sender_full_name": "John Ericson",
        "timestamp": 1576247607
    },
    {
        "content": "<p>?</p>",
        "id": 183364045,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247728
    },
    {
        "content": "<p>If you have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nc\">FallibleVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// you just:</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nc\">FallibleVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">infallible</span><span class=\"p\">()).</span><span class=\"n\">fallible</span><span class=\"p\">();</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183364123,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247773
    },
    {
        "content": "<p>where <code>FallibleVec::infallible(self) -&gt; Vec</code> and <code>Vec::fallible(self) -&gt; FallibleVec</code></p>",
        "id": 183364205,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576247829
    },
    {
        "content": "<p>I don't think the macro can do that for arbitrary signatures with Vec</p>",
        "id": 183364609,
        "sender_full_name": "John Ericson",
        "timestamp": 1576248010
    },
    {
        "content": "<p>Especially if the thing parameterized with a Vec is abstract</p>",
        "id": 183364763,
        "sender_full_name": "John Ericson",
        "timestamp": 1576248035
    },
    {
        "content": "<p>You need something like Haskell's Coercible to do this</p>",
        "id": 183364891,
        "sender_full_name": "John Ericson",
        "timestamp": 1576248135
    },
    {
        "content": "<p>Full stop</p>",
        "id": 183364898,
        "sender_full_name": "John Ericson",
        "timestamp": 1576248144
    },
    {
        "content": "<p>I'm not sure what you mean with \"the macro can do that\"</p>",
        "id": 183365992,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576248873
    },
    {
        "content": "<p>They are different types, if you need to go from one to another, you just call a conversion function.</p>",
        "id": 183366104,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576248962
    },
    {
        "content": "<p><code>Into::into</code> would do</p>",
        "id": 183366148,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576248971
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nc\">FallibleVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">()).</span><span class=\"n\">into</span><span class=\"p\">();</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183366168,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576248993
    },
    {
        "content": "<p>I would favor always writing <code>try_foo</code> first and then also having <code>foo</code> that simply does <code>try_foo(arg).unwrap()</code> be available for however much of the stuff you think people would want to unwrap all the time (perhaps even 100% of it)</p>",
        "id": 183392507,
        "sender_full_name": "Lokathor",
        "timestamp": 1576265838
    },
    {
        "content": "<p>actually in the case of this it would be more like <code>try_foo(arg).or_else(|_|handle_alloc_error())</code></p>",
        "id": 183392616,
        "sender_full_name": "Lokathor",
        "timestamp": 1576265906
    },
    {
        "content": "<p>Default to infallible is just not robust in the same way that unwrapping every Result and Option isn't very robust</p>",
        "id": 183392716,
        "sender_full_name": "Lokathor",
        "timestamp": 1576265975
    },
    {
        "content": "<p>I'm not sure what you are arguing for or against</p>",
        "id": 183842131,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760081
    },
    {
        "content": "<p>Are you suggesting that every liballoc method that alloactes should have a <code>try_</code> counterpart ?</p>",
        "id": 183842148,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760101
    },
    {
        "content": "<p>Like <code>Vec::try_extend</code> ?</p>",
        "id": 183842172,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760115
    },
    {
        "content": "<p>I find that handling allocation errors is already uncomfortable enough, adding also the burden of writing <code>try_{everything}</code> makes this worse, and it also makes it easier for \"bugs\" to be introduced by accidentally using a non-<code>try_</code> method when you shouldn't.</p>",
        "id": 183842295,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760228
    },
    {
        "content": "<p>Currently you don't handle allocation errors in collection at all (besides <code>handle_alloc_error</code>, which defaults to abort and I never have seen anyone using it).<br>\nWhy this would it makes easier for bugs? It's not possible to use non-<code>try</code> methods on allocators, which are not allowed to abort</p>",
        "id": 183842440,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760356
    },
    {
        "content": "<p><code>Vec::try_reserve</code> exists</p>",
        "id": 183842452,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760367
    },
    {
        "content": "<p>If I have code that must not fail on OOM, and I use <code>try_</code> methods everywhere, and then somebody accidentally slips a non-<code>try_</code> call somewhere, that's a bug, potentially a very big one.</p>",
        "id": 183842546,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760420
    },
    {
        "content": "<p>On the level of a security vulnerability</p>",
        "id": 183842556,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760432
    },
    {
        "content": "<p>Then you use an allocator, which does not implement <code>Abort</code></p>",
        "id": 183842571,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760444
    },
    {
        "content": "<p>And then the non-<code>try_</code> methods are not available ?</p>",
        "id": 183842589,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760465
    },
    {
        "content": "<p>yup</p>",
        "id": 183842594,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760471
    },
    {
        "content": "<p>So why do I have to type more ?</p>",
        "id": 183842600,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760477
    },
    {
        "content": "<p>And why do I need a different allocator ?</p>",
        "id": 183842612,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760490
    },
    {
        "content": "<p>Because you may want to use <code>try_</code> on collection, which are allowed to abort</p>",
        "id": 183842632,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760516
    },
    {
        "content": "<p>How is handling OOM an allocator issue ?</p>",
        "id": 183842679,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760526
    },
    {
        "content": "<p>An allocator reports whether OOM happen, but it isn't its job to handle it</p>",
        "id": 183842689,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760535
    },
    {
        "content": "<p>I see, that using <code>try_</code> isn't the best thing. but it's still much better than duplicating every collection</p>",
        "id": 183842714,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760569
    },
    {
        "content": "<p>You are not duplicating every collection</p>",
        "id": 183842729,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760582
    },
    {
        "content": "<p>That claim is super misleading</p>",
        "id": 183842733,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760586
    },
    {
        "content": "<p>You are providing a type safe thin wrapper that expresses an invariant at the type level</p>",
        "id": 183842741,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760599
    },
    {
        "content": "<p>You are not duplicating all the code involved</p>",
        "id": 183842751,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760612
    },
    {
        "content": "<p>However you have two nearly same collection</p>",
        "id": 183842752,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760616
    },
    {
        "content": "<p>Additionally, the allocator isn't envolved in OOM handling. <code>Abort</code> is just a marker trait</p>",
        "id": 183842815,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760647
    },
    {
        "content": "<p>No, you have two different _types_ exposing two different ways of modifying a collections owned data using a single API</p>",
        "id": 183842818,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760650
    },
    {
        "content": "<p>So if I have an allocator, when should I implement Abort for it ?</p>",
        "id": 183842835,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760666
    },
    {
        "content": "<p><code>Abort</code> is implemented for <code>Global</code>, <code>System</code> and every allocator, which are infallible</p>",
        "id": 183842879,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760711
    },
    {
        "content": "<p>This isn't true</p>",
        "id": 183842888,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760727
    },
    {
        "content": "<p>Since Global and System can return a <code>ptr::null</code> on allocations</p>",
        "id": 183842894,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760737
    },
    {
        "content": "<p>and that means that the allocation failed</p>",
        "id": 183842896,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760742
    },
    {
        "content": "<blockquote>\n<p>Abort is implemented for <code>Global</code>, <code>System</code> <strong>and</strong> every allocator, which are infallible</p>\n</blockquote>",
        "id": 183842914,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760757
    },
    {
        "content": "<p>Sure but that isn't true, since Global and System are fallible</p>",
        "id": 183842973,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760779
    },
    {
        "content": "<p>today</p>",
        "id": 183842976,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760781
    },
    {
        "content": "<p>You marking allocators, which are allowed to abort</p>",
        "id": 183842977,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760783
    },
    {
        "content": "<p><code>Abort</code> does not mean, the allocator is infallible</p>",
        "id": 183842987,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760794
    },
    {
        "content": "<blockquote>\n<p>which are infallible</p>\n</blockquote>",
        "id": 183842991,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760803
    },
    {
        "content": "<p>So what does <code>Abort</code> mean ?</p>",
        "id": 183843003,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760812
    },
    {
        "content": "<p>Otherwise it would be named <code>Infallible</code></p>",
        "id": 183843005,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760817
    },
    {
        "content": "<blockquote>\n<p>Marker trait to indicate that the allocator is allowed to abort on OOM.</p>\n</blockquote>",
        "id": 183843035,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760855
    },
    {
        "content": "<p>Allowed but not required</p>",
        "id": 183843095,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760891
    },
    {
        "content": "<p>right?</p>",
        "id": 183843099,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760893
    },
    {
        "content": "<p>Yes</p>",
        "id": 183843104,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760903
    },
    {
        "content": "<p>So the allocator can still return a null pointer</p>",
        "id": 183843116,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760912
    },
    {
        "content": "<p>yes</p>",
        "id": 183843118,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760918
    },
    {
        "content": "<p>the collection handles the abortion then</p>",
        "id": 183843125,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760932
    },
    {
        "content": "<p>And allocators that do not have the <code>Abort</code> marker trait can abort on OOM, right ?</p>",
        "id": 183843126,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760933
    },
    {
        "content": "<p>It's a marker trait regarding handling the OOM, not regarding allocating</p>",
        "id": 183843154,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576760972
    },
    {
        "content": "<p>Can you be more clearer ?</p>",
        "id": 183843179,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576760994
    },
    {
        "content": "<p>Seems like you are suggesting that implementing <code>Abort</code> for allocators means that the allocator might abort on OOM, which is something that all allocators are allowed to do any ways, but that this trait should hint users of the allocator, that they should abort if the allocator returns an error, which is something that users of the allocators can already do without the trait.</p>",
        "id": 183843267,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761054
    },
    {
        "content": "<p>If an allocator without <code>Abort</code> returns a null pointer, handle_alloc_error still can be called</p>",
        "id": 183843301,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761079
    },
    {
        "content": "<p>Take the <code>Vec</code> method <code>reserve</code>, it's bound on <code>Abort</code>: </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">reserve</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">additional</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">ReallocRef</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>If you chose an allocator, which implements <code>Abort</code> you may call <code>Vec::reserve</code>. But you are still able to call `try_reserve:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">try_reserve</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">additional</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">CollectionAllocErr</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">ReallocRef</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183843439,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761184
    },
    {
        "content": "<p>That's the whole thing of the <code>Abort</code> trait</p>",
        "id": 183843476,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761213
    },
    {
        "content": "<p>It feels very weird to use a trait on allocators to customize collections behavior</p>",
        "id": 183843484,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761224
    },
    {
        "content": "<p>That's probably a good point</p>",
        "id": 183843505,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761242
    },
    {
        "content": "<p>Like for <code>jemalloc</code>, should I implement abort or not ?</p>",
        "id": 183843549,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761253
    },
    {
        "content": "<p>Depends on your needs</p>",
        "id": 183843557,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761264
    },
    {
        "content": "<p>that's for the user of jemalloc to decide on every vector they use</p>",
        "id": 183843558,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761265
    },
    {
        "content": "<p>not for the allocator to decide</p>",
        "id": 183843561,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761272
    },
    {
        "content": "<p>But I see the point</p>",
        "id": 183843564,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761274
    },
    {
        "content": "<p>What you want to express is whether a particular vector should abort on OOM, or return an error</p>",
        "id": 183843597,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761306
    },
    {
        "content": "<p>and that's orthogonal to the allocator used</p>",
        "id": 183843603,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761318
    },
    {
        "content": "<p>Right now, Vec::reserve just calls <code>try_reserve</code> and unwraps.</p>",
        "id": 183843616,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761341
    },
    {
        "content": "<p>I'd rather just express the property as part of the vector type somehow</p>",
        "id": 183843673,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761367
    },
    {
        "content": "<p>When you take <code>Jemalloc</code>, and  <code>JemallocAbort</code> (like jemalloc, but implementing Abort), and instantiate <code>Vec&lt;T, Jemalloc&gt;</code> and <code>Vec&lt;T, JemallocAbort&gt;</code> you are duplicating the collection</p>",
        "id": 183843700,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761412
    },
    {
        "content": "<p>It's probably better to express it on the collection, but not in the way of have two very similar collection of each type in std</p>",
        "id": 183843706,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761420
    },
    {
        "content": "<p>If we would just have collection traits...</p>",
        "id": 183843726,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761451
    },
    {
        "content": "<blockquote>\n<p>you are duplicating the collection</p>\n</blockquote>\n<p>As in, this will instantiate the collection twice.</p>",
        "id": 183843728,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761456
    },
    {
        "content": "<p>Why would you need collection traits?</p>",
        "id": 183843745,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761480
    },
    {
        "content": "<p>Then you could implement a generic wrapper around collections</p>",
        "id": 183843802,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761494
    },
    {
        "content": "<p>If you had a <code>VecLike</code> trait, that has a <code>VecLike::reserve -&gt; ???</code>  method, what would the <code>???</code> be ?</p>",
        "id": 183843820,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761507
    },
    {
        "content": "<p>well, true^^</p>",
        "id": 183843838,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761521
    },
    {
        "content": "<p>I think the <code>FallibleVec + Vec</code> solution is straightforward</p>",
        "id": 183843868,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761549
    },
    {
        "content": "<p>Sure, you need to write the same API twice, but that's straightforward to do, and to understand</p>",
        "id": 183843886,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761568
    },
    {
        "content": "<p>And well you need to implement <code>Vec</code> on top of <code>FallibleVec</code>, but that's also kind of trivial</p>",
        "id": 183843910,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761590
    },
    {
        "content": "<p>It is more work than adding <code>try_</code> methods, cause you need to implement the traits for the vector, etc.</p>",
        "id": 183843985,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761614
    },
    {
        "content": "<p>But from a user of the standard library, both APIs are the same, there is only one API to learn, etc.</p>",
        "id": 183844023,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761638
    },
    {
        "content": "<p>An alternative might be a <code>Vec&lt;T, A, const ErrorOnOOM: bool = true&gt;</code> kind of thing</p>",
        "id": 183844108,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761704
    },
    {
        "content": "<p>Where we change the return types of all methods depending on the value of the <code>bool</code>..</p>",
        "id": 183844168,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761735
    },
    {
        "content": "<p>I like the const generics approach, but I wouldn't use a boolean here. An enum expresses it better, like </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">enum</span> <span class=\"nc\">OomBehavior</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Abort</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Error</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183844249,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761827
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ErrorOnOOM</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"o\">&gt;</span><span class=\"p\">(...);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">fn</span> <span class=\"nf\">reserve</span><span class=\"p\">(...)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">handle_alloc_error</span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"k\">fn</span> <span class=\"nf\">reserve</span><span class=\"p\">(...)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">....</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183844306,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> the enum sounds like a better idea</p>",
        "id": 183844319,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761868
    },
    {
        "content": "<p>I still don't know, if changing the return type is a good idea though</p>",
        "id": 183844414,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576761957
    },
    {
        "content": "<p>I suppose we don't even need const generics</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">ErrorBehavior</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Error</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Abort</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ErrorBehavior</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ErrorBehavior</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span>: <span class=\"nc\">ErrorBehavior</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"o\">&gt;</span><span class=\"p\">(...);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">fn</span> <span class=\"nf\">reserve</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Error</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">fn</span> <span class=\"nf\">reserve</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183844478,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576761991
    },
    {
        "content": "<p>Okay, but I'd go with this approach:</p>",
        "id": 183844513,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762024
    },
    {
        "content": "<p>We can't change the return type for current behavior (would be a backward incompat change), and we want to be able to use <code>Result</code> for the non-standard case, so i'm not sure how else to handle it.</p>",
        "id": 183844556,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762071
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"o\">&gt;</span><span class=\"p\">(...);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">fn</span> <span class=\"nf\">try_reserve</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Abort</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">fn</span> <span class=\"nf\">reserve</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183844634,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762115
    },
    {
        "content": "<p>However, const generics is more clear. The trait approach is a workaround</p>",
        "id": 183844663,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762156
    },
    {
        "content": "<p>Sure, I agree.</p>",
        "id": 183844962,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762368
    },
    {
        "content": "<p>For prototyping purposes, we can get the trait approach working today. The const generics part, I'm not 100% sure if this already works</p>",
        "id": 183844983,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762393
    },
    {
        "content": "<p>With my last approach, <code>Error</code> is a superset of <code>Abort</code>: when using <code>Abort</code>, you have more methods which can be used</p>",
        "id": 183845086,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762498
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=99631852589832f4d8214729ab418803\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=99631852589832f4d8214729ab418803\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=99631852589832f4d8214729ab418803</a></p>",
        "id": 183845230,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762634
    },
    {
        "content": "<p>This works!</p>",
        "id": 183845233,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762636
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216785\">@Tim Diekmann</span> yes, I don't know how I feel about that</p>",
        "id": 183845251,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762662
    },
    {
        "content": "<p>I understand the idea behind the super set, i don't know if that's a better API than just choosing whether all methods should abort or report error</p>",
        "id": 183845300,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762689
    },
    {
        "content": "<p>Typically, it is not that you only care for a single operation, which is what your approach allows</p>",
        "id": 183845335,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762724
    },
    {
        "content": "<p>Yes, the const generic approach works, but it's not possible to pass a default argument.</p>",
        "id": 183845385,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762781
    },
    {
        "content": "<p>Not yet</p>",
        "id": 183845395,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762788
    },
    {
        "content": "<p>The feature isn't finished</p>",
        "id": 183845400,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762794
    },
    {
        "content": "<p>Is it possible to do so for types on stable rust ?</p>",
        "id": 183845451,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762806
    },
    {
        "content": "<p>IIRC that's a nightly only feature</p>",
        "id": 183845457,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762820
    },
    {
        "content": "<p>Yes, as you suggested, a trait should fulfill the needs until landing</p>",
        "id": 183845459,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762822
    },
    {
        "content": "<p>I think it is. At least, array implementations uses const generics</p>",
        "id": 183845468,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762840
    },
    {
        "content": "<blockquote>\n<p>I understand the idea behind the super set, i don't know if that's a better API than just choosing whether all methods should abort or report error</p>\n</blockquote>\n<p>I think it's more understandable, than changing the API</p>",
        "id": 183845502,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762890
    },
    {
        "content": "<p>IMO it feels unnaturally, when a return type changes with another parameter</p>",
        "id": 183845568,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576762927
    },
    {
        "content": "<p>Which is why I think I still believe that making this two types might still be better</p>",
        "id": 183845585,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762950
    },
    {
        "content": "<p>But I think it feels unnatural to me to have a different method for it</p>",
        "id": 183845600,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762970
    },
    {
        "content": "<p>I'm already expressing that I want to handle errors manually at the type level</p>",
        "id": 183845622,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576762997
    },
    {
        "content": "<p>why do i then need to also use completely different method names ?</p>",
        "id": 183845632,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763007
    },
    {
        "content": "<p>Fair point</p>\n<p>The parameter type has still a huge advange: Only the allocating functions has to be duplicated</p>",
        "id": 183845714,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763057
    },
    {
        "content": "<p>Yes, that's a pretty big advantage</p>",
        "id": 183845728,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763081
    },
    {
        "content": "<p>Converting between <code>Vec&lt;_, _, Abort&gt;</code> and <code>Vec&lt;_, _, Error&gt;</code> is a noop. Do you have suitable method names?</p>",
        "id": 183845761,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763114
    },
    {
        "content": "<p>One probably minor disadvantage is the order of the type parameters, if you want to change how the error type is handled, you need to specify an allocator</p>",
        "id": 183845762,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763114
    },
    {
        "content": "<p>And if we were to change the order of the type parameters, then to specify a different allocator you'd need to specify how errors are handled</p>",
        "id": 183845778,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763137
    },
    {
        "content": "<p>Yes, but this also applies to HashMap and the hasher</p>",
        "id": 183845788,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763157
    },
    {
        "content": "<p>yes, I don't think this is a major issue, nor a problem worth solving</p>",
        "id": 183845834,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763168
    },
    {
        "content": "<p>It's a problem I already didn't like in C++</p>",
        "id": 183845841,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763175
    },
    {
        "content": "<p>But, yes, minor one</p>",
        "id": 183845851,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763186
    },
    {
        "content": "<p>Yes, but the solution would be \"named type parameters\", and that has other problems</p>",
        "id": 183845862,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763194
    },
    {
        "content": "<p>Either way, if we ever get a general solution to this problem, the Vec API would automatically benefit from it</p>",
        "id": 183845880,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763213
    },
    {
        "content": "<p>Let's just not focus on this for now</p>",
        "id": 183845905,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763240
    },
    {
        "content": "<p>So I think I like this approach more than the <code>Abort</code> approach, unless I'm missing more details about how <code>Abort</code> is supposed to work</p>",
        "id": 183845923,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763261
    },
    {
        "content": "<p>Other WGs have \"summary documents\", so maybe we could have a hackmd or similar with a summary of the different approaches, and pros and con, that we can keep updated ?</p>",
        "id": 183845988,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763291
    },
    {
        "content": "<p>Our summary is <code>alloc-wg</code> I guess <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 183846025,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763335
    },
    {
        "content": "<blockquote>\n<p>So I think I like this approach more than the <code>Abort</code> approach, unless I'm missing more details about how <code>Abort</code> is supposed to work</p>\n</blockquote>\n<p>No, I think that's it</p>",
        "id": 183846050,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763363
    },
    {
        "content": "<p>The main reason I think I prefer this approach is the separation of concerns</p>",
        "id": 183846141,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763408
    },
    {
        "content": "<p>Allocators should just need to worry about allocating and deallocating memory, turns out this is already hard enough.</p>",
        "id": 183846162,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763428
    },
    {
        "content": "<p>to summarize our todays discussion: </p>\n<ul>\n<li>OOM behavior should be expressed on the collection, not on the allocator</li>\n<li>the <code>OomBevahior</code> approach is better, than implementing two distinct types, as most of the API isn't affected by allocators anyway</li>\n</ul>",
        "id": 183846178,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763449
    },
    {
        "content": "<p>Regarding the return type:</p>",
        "id": 183846190,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763460
    },
    {
        "content": "<p>Yes, you are right, we are already expressing \"I want to handle errors on this collection, give me the result\"</p>",
        "id": 183846217,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763486
    },
    {
        "content": "<blockquote>\n<p>the OomBevahior approach is better, than implementing two distinct types, as most of the API isn't affected by allocators anyway</p>\n</blockquote>\n<p>It's better from the implementation point-of-view. It is ok-ish from the user point-of-view, except when they want to change the error behavior, and this requires them to also pass an allocator, but that's a minor inconvenience. The <code>FallibleVec + Vec</code> approach requires duplicating the whole API, but one API reuses the other.</p>",
        "id": 183846315,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763544
    },
    {
        "content": "<p>One thing I'm not sure is, how to re-use <code>Vec::try_reserve</code> (Or the <code>Vec::reserve(...) -&gt; Result</code> version, from the infallible one with this approach.</p>",
        "id": 183846365,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763585
    },
    {
        "content": "<p><code>try_reserve</code> isn't stabilized yet. I don't think I get your point</p>",
        "id": 183846483,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763666
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=c18da87e5fc8691e18362451a4a59e05\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=c18da87e5fc8691e18362451a4a59e05\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=c18da87e5fc8691e18362451a4a59e05</a></p>",
        "id": 183846613,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763762
    },
    {
        "content": "<p>THis works</p>",
        "id": 183846632,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763765
    },
    {
        "content": "<p>I meant, that when implementing the <code>Vec&lt;T, A, Abort&gt;::reserve(&amp;mut self, N) -&gt; () { .... }</code> method, we want to call the <code>Vec&lt;T, A, Error&gt;::reserve(...) -&gt; Result</code> method, and \"unwrap\" (or call handle_alloc_error)</p>",
        "id": 183846695,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763812
    },
    {
        "content": "<p>To reuse its implementation</p>",
        "id": 183846708,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763822
    },
    {
        "content": "<p>This \"solves\" it, but it is not guaranteed to work:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">OnOomError</span>::<span class=\"n\">Abort</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">fn</span> <span class=\"nf\">fallible</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">OnOomError</span>::<span class=\"n\">Error</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">          </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183846819,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763896
    },
    {
        "content": "<p>Ah yes, your playground would have been my proposal there</p>",
        "id": 183846821,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576763898
    },
    {
        "content": "<p>The problem is that the layout of the two <code>repr(Rust)</code> types isn't necessarily the same</p>",
        "id": 183846863,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763937
    },
    {
        "content": "<p>so the <code>&amp;mut Vec&lt;.., Abort&gt; -&gt; &amp;mut Vec&lt;..., Error&gt;</code> cast might be unsound</p>",
        "id": 183846887,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576763955
    },
    {
        "content": "<p>The transmute is only safe if the layouts are the same</p>",
        "id": 183846934,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764002
    },
    {
        "content": "<p>Ahhhhh! wait, i think there is a clause somewhere that says that 1-ZSTs do not affect layout</p>",
        "id": 183847005,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764020
    },
    {
        "content": "<p>We have the <code>RawVec</code> struct underneath anyway</p>",
        "id": 183847015,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764028
    },
    {
        "content": "<p>You could just call <code>try_reserve</code> and <code>reserve</code> on <code>RawVec</code> then</p>",
        "id": 183847036,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764040
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 183847056,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764057
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/layout/structs-and-tuples.md#structs-with-1-zst-fields\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/layout/structs-and-tuples.md#structs-with-1-zst-fields\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/layout/structs-and-tuples.md#structs-with-1-zst-fields</a></p>",
        "id": 183847079,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764069
    },
    {
        "content": "<blockquote>\n<p>For the purposes of struct layout 1-ZST fields are ignored.</p>\n</blockquote>",
        "id": 183847090,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764077
    },
    {
        "content": "<p><code>PhantomData&lt;T&gt;</code> is a 1-ZST</p>",
        "id": 183847133,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764103
    },
    {
        "content": "<p>So this might be sound</p>",
        "id": 183847217,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764134
    },
    {
        "content": "<p>You don't have <code>PhantomData&lt;T&gt;</code> in the real <code>Vec</code> implementation</p>",
        "id": 183847225,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764142
    },
    {
        "content": "<p>Every allocation is backed by <code>RawVec</code></p>",
        "id": 183847231,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764150
    },
    {
        "content": "<p>We would need to add it for the <code>OnOomError</code> type parameter</p>",
        "id": 183847235,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764153
    },
    {
        "content": "<p>Because otherwise the generic parameter is unused</p>",
        "id": 183847241,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764162
    },
    {
        "content": "<p>You just forward the error type from the <code>Alloc</code> implementation</p>",
        "id": 183847338,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764232
    },
    {
        "content": "<p>No, I meant for the <code>OnOomError</code> type parameter</p>",
        "id": 183847404,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764254
    },
    {
        "content": "<p>Ah, true</p>",
        "id": 183847412,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764264
    },
    {
        "content": "<p>that's not passed to <code>RawVec</code>, or is used anywhere</p>",
        "id": 183847416,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764264
    },
    {
        "content": "<p>So we need to \"use\" it</p>",
        "id": 183847422,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764270
    },
    {
        "content": "<p>Thought your <code>PhantomData&lt;T&gt;</code> denotes the value type</p>",
        "id": 183847450,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764298
    },
    {
        "content": "<p>Yeah sorry, that was a confusing way to put it</p>",
        "id": 183847487,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764323
    },
    {
        "content": "<p>However, we don't have to worry about transmuting, as <code>RawVec</code> already has the logic implemented</p>",
        "id": 183847516,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764348
    },
    {
        "content": "<p>Yeah true, but not for all methods</p>",
        "id": 183847530,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764361
    },
    {
        "content": "<p>That is, for <code>reserve</code>, sure, we can call <code>RawVec</code>, but for other methods like <code>extend</code>, <code>insert</code>, <code>resize</code>, etc. it might make sense to re-use some of the logic of these methods</p>",
        "id": 183847633,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764404
    },
    {
        "content": "<p>is <code>Foo(T, U)</code> guaranteed to be the same as <code>Bar(T, U)</code>?</p>",
        "id": 183847782,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576764497
    },
    {
        "content": "<p><a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Guarantees.20about.20layout.20of.20generic.20aggregates/near/183847831\" title=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Guarantees.20about.20layout.20of.20generic.20aggregates/near/183847831\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Guarantees.20about.20layout.20of.20generic.20aggregates/near/183847831</a></p>",
        "id": 183847873,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764576
    },
    {
        "content": "<p>I've asked this in the UCGs, but in general no, that's not guaranteed.</p>",
        "id": 183847886,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764588
    },
    {
        "content": "<p>E.g. <code>rustc</code> is allowed to re-order the fields of <code>Foo</code> and <code>Bar</code> differently, e.g., using PGO data, to put the \"hottest\" field at the front, and improve cache usage and performance</p>",
        "id": 183847978,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764633
    },
    {
        "content": "<p>If you want more layout guarantees, you need to use, e.g., <code>repr(C)</code></p>",
        "id": 183848009,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576764659
    },
    {
        "content": "<p>It would still be possible to implement the logic on a dedicated type</p>",
        "id": 183848768,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576765091
    },
    {
        "content": "<p>Do you have a proper name for converting between those two types? Or should we just use <code>Into</code>, <code>AsRef</code>, and <code>AsMut</code>?</p>",
        "id": 183850324,
        "sender_full_name": "Tim Diekmann",
        "timestamp": 1576766101
    },
    {
        "content": "<p>We could do both.</p>",
        "id": 183852966,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576767691
    },
    {
        "content": "<p>We can provide, e.g., <code>into()</code> to convert one into the other, taking ownership.</p>",
        "id": 183852986,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576767710
    },
    {
        "content": "<p>But we also could provide a <code>Vec::fallible(&amp;mut self) -&gt;&amp;mut FallibleVec</code> method to allow users to perform fallible operations in a scope, without having to call into twice (to go from Vec-&gt;FallibleVec-&gt;Vec), or without having to move the vector out of a struct, etc.</p>",
        "id": 183853123,
        "sender_full_name": "gnzlbg",
        "timestamp": 1576767774
    }
]