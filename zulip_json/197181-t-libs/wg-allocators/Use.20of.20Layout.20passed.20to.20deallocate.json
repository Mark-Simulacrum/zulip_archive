[
    {
        "content": "<p>Am I correct in understanding that the <code>Layout</code> passed to <code>deallocate</code> of the <code>Allocator</code> trait is like a \"hint\" to the allocator, perhaps to help it \"find\" the original allocation (e.g. for a size-segregated allocator)? Based on the rules here <a href=\"https://doc.rust-lang.org/std/alloc/trait.Allocator.html#currently-allocated-memory\">https://doc.rust-lang.org/std/alloc/trait.Allocator.html#currently-allocated-memory</a> (listing just some of them):</p>\n<ul>\n<li>the starting address for that memory block was previously returned by allocate, grow, or shrink, and...</li>\n<li>The provided layout.size() must fall in the range min ..= max, where: min is the size of the layout most recently used to allocate the block, and max is the latest actual size returned from allocate, grow, or shrink.</li>\n</ul>\n<p>It doesn't seem like the <code>Layout</code> the user passes to <code>deallocate</code> has any purpose for the user. For example, the user of the allocator has to assume that the entire memory block of length <code>max</code> (the actual size returned from allocate/grow/shrink) has been deallocated even if <code>min</code> (the size of the layout used to allocate the block) is passed to <code>deallocate</code>, correct?</p>\n<p>I've read the discussions here <a href=\"https://github.com/rust-lang/rust/pull/42313\">https://github.com/rust-lang/rust/pull/42313</a> and some of the issues in the wg-allocators repo, e.g. <a href=\"https://github.com/rust-lang/wg-allocators/issues/78\">https://github.com/rust-lang/wg-allocators/issues/78</a></p>",
        "id": 252718550,
        "sender_full_name": "Raekye",
        "timestamp": 1631236048
    },
    {
        "content": "<p>No, it is not a hint. The allocator can avoid storing any info about the size at all.</p>",
        "id": 252723544,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631240808
    },
    {
        "content": "<p>Say a buddy allocator, then the allocator will allocate a chunk of memory with the size of the next power of two. And when deallocating it could simply calculate the next power of two of the size and perform a deallocation.</p>",
        "id": 252723588,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631240875
    },
    {
        "content": "<p>The \"max\" here is under the control of the allocator, so it's up to the allocator to determine how the info can be used.</p>",
        "id": 252723660,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631240929
    },
    {
        "content": "<p>Another example is that if the allocator never \"overallocates\" for the allocate calls, then min will be equal to max.</p>",
        "id": 252723693,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631240974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437904\">Raekye</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Use.20of.20Layout.20passed.20to.20deallocate/near/252718550\">said</a>:</p>\n<blockquote>\n<p>It doesn't seem like the <code>Layout</code> the user passes to <code>deallocate</code> has any purpose for the user. For example, the user of the allocator has to assume that the entire memory block of length <code>max</code> (the actual size returned from allocate/grow/shrink) has been deallocated even if <code>min</code> (the size of the layout used to allocate the block) is passed to <code>deallocate</code>, correct?</p>\n</blockquote>\n<p>The entire allocation is deallocated at once. It's defined as a range to provide flexibility to the user. For example, a <code>Box</code> type does not need additional memory allocated, it'll just use size of T for both allocation and deallocation, so it'll always use min. On the other hand, <code>Vec</code> could benefit from additional capacity, so it'll stick to the max, and it doesn't need to store the actual size (min) used for allocation but instead use its capacity (which gives max).</p>",
        "id": 252724167,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631241410
    },
    {
        "content": "<p>i think the way the allocation functions return a slice is not a good idea. There's no allocator I'm aware of where returning the precise size doesn't require additional work (generally either via a goodsize or a usablesize fn), and the only places you want this information are inside collection type.</p>\n<p>i think instead there should be a parameter for that the allocator provide information about allocation excess.</p>",
        "id": 252744606,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631259118
    },
    {
        "content": "<p>more concretely for dealloc and layout, i used to be opposed to it (i even wrote <a href=\"https://shift.click/blog/on-dealloc/\">https://shift.click/blog/on-dealloc/</a>) at one point. then i didnt mind it so much, and started working on <a href=\"https://gist.github.com/thomcc/426c836f105e8ad41488ac07a6290ffb\">https://gist.github.com/thomcc/426c836f105e8ad41488ac07a6290ffb</a> to address the cases where it's bad.</p>\n<p>but honestly it felt like this wg was dead or near dead, and very little if any motion or discussion happened on anything, so I gave up after it seemed like nobody cared anymore, even though I think there are a lot of gaps or problems with the current API</p>",
        "id": 252744745,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631259209
    },
    {
        "content": "<p>(note that that gist is still extremely rough around the edges, since I stopped working on before polishing it all the way. the apis have definite flaws, and still need further work)</p>",
        "id": 252744920,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631259312
    },
    {
        "content": "<p>Another example of an allocator that don't store the size is <code>bumpalo</code>: if you free the block at the bottom of the stack of allocation then you can simply raise the bump pointer by the size of the <code>Layout</code> that is passed in.</p>",
        "id": 252755808,
        "sender_full_name": "Amanieu",
        "timestamp": 1631265266
    },
    {
        "content": "<p>The rationale for passing the <code>Layout</code> in was that allocators can be more efficient. Jemalloc has a sized free API which avoids certain lookups.</p>",
        "id": 252755913,
        "sender_full_name": "Amanieu",
        "timestamp": 1631265343
    },
    {
        "content": "<p>It's preferable to make this the main deallocation API since in the vast majority of cases (<code>Box</code> and <code>Vec</code>) the layout of the allocation is readily available.</p>",
        "id": 252756023,
        "sender_full_name": "Amanieu",
        "timestamp": 1631265396
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Use.20of.20Layout.20passed.20to.20deallocate/near/252744606\">said</a>:</p>\n<blockquote>\n<p>i think the way the allocation functions return a slice is not a good idea. There's no allocator I'm aware of where returning the precise size doesn't require additional work (generally either via a goodsize or a usablesize fn), and the only places you want this information are inside collection type.</p>\n<p>i think instead there should be a parameter for that the allocator provide information about allocation excess.</p>\n</blockquote>\n<p>If returning the precise size requires additional work then the allocator should just return the original size. It's usually not worth the extra work to obtain a precise size for a very common type like <code>Vec</code>.</p>",
        "id": 252756284,
        "sender_full_name": "Amanieu",
        "timestamp": 1631265557
    },
    {
        "content": "<p>Iirc there was a recent change or proposed change to unconditionally query available size and set vector capacity to that.</p>",
        "id": 252759419,
        "sender_full_name": "nagisa",
        "timestamp": 1631267259
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Use.20of.20Layout.20passed.20to.20deallocate/near/252723544\">said</a>:</p>\n<blockquote>\n<p>No, it is not a hint. The allocator can avoid storing any info about the size at all.</p>\n</blockquote>\n<p>My bad, \"hint\" was not a good word. By \"hint\" I meant to suggest that based on my understanding, ignoring zero sized allocations/dangling pointers (not sure the status of those based on <a href=\"https://github.com/rust-lang/wg-allocators/issues/82\">https://github.com/rust-lang/wg-allocators/issues/82</a>), the block of memory to be freed is uniquely identified by the pointer returned by one of the allocating functions. As such, hypothetically, an allocator does not need the Layout passed in, is that correct? Of course, as you noted, an implementation of an allocator may require that the valid size is passed to deallocate</p>\n<blockquote>\n<p>It doesn't seem like the <code>Layout</code> the user passes to <code>deallocate</code> has any purpose for the user.</p>\n</blockquote>\n<p>Was also incorrectly worded by my part. My main concern was that by passing in a value less than max, somehow the user might want to continue using the excess. Of course, that seems in conflict with the other allocator requirements (but I wanted to be sure there was no way to \"use\" the excess). But I think your comment \"the entire allocation is deallocated at once\" clarifies my concerns.  Thank you!</p>",
        "id": 252772279,
        "sender_full_name": "Raekye",
        "timestamp": 1631273859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Use.20of.20Layout.20passed.20to.20deallocate/near/252744745\">said</a>:</p>\n<blockquote>\n<p>but honestly it felt like this wg was dead or near dead, and very little if any motion or discussion happened on anything, so I gave up after it seemed like nobody cared anymore, even though I think there are a lot of gaps or problems with the current API</p>\n</blockquote>\n<p>That's unfortunate to hear, because I would like to see this stabilized :/ (of course, it's better to take time and get it \"right\"). I'm fairly new to rust but have some experience with systems programming (as much as a phd student might). Is this a good place to try to get involved? In particular, what is current work on, and what needs to be discussed for the <code>Allocator</code> trait to be stabilized? The <a href=\"https://github.com/rust-lang/rust/issues/32838\">tracking issue</a> has \"trivial\" open questions like the naming of <code>AllocErr</code> but hasn't been commented on since 2019</p>",
        "id": 252773774,
        "sender_full_name": "Raekye",
        "timestamp": 1631274681
    },
    {
        "content": "<p>A more up-to-date tracking is on the allocator working group's issue tracker: <a href=\"https://github.com/rust-lang/wg-allocators/issues\">https://github.com/rust-lang/wg-allocators/issues</a></p>",
        "id": 252777831,
        "sender_full_name": "Amanieu",
        "timestamp": 1631276610
    },
    {
        "content": "<p>Actually the roadmap issue might be better: <a href=\"https://github.com/rust-lang/wg-allocators/issues/48\">https://github.com/rust-lang/wg-allocators/issues/48</a></p>",
        "id": 252778050,
        "sender_full_name": "Amanieu",
        "timestamp": 1631276703
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"437904\">Raekye</span> [said](<a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic\">https://rust-lang.zulipchat.com/#narrow/stream/197181-t-libs.2Fwg-allocators/topic</a></p>\n<blockquote>\n<p>My bad, \"hint\" was not a good word. By \"hint\" I meant to suggest that based on my understanding [...] the block of memory to be freed is uniquely identified by the pointer returned by one of the allocating functions. As such, hypothetically, an allocator does not need the Layout passed in, is that correct?</p>\n</blockquote>\n<p>Hypothetically yes, but as far as I know the practical consequence is in how much work the allocator needs to do (and how much space it needs to spend on the metadata) to be able to free the allocation usefully.  Especially for allocators that use different strategies for different sizes.</p>",
        "id": 253309197,
        "sender_full_name": "scottmcm",
        "timestamp": 1631647752
    },
    {
        "content": "<p><a href=\"https://gitlab.redox-os.org/redox-os/ralloc\">ralloc</a> needs the <code>Layout</code> as it allows partial deallocation of allocated memory. Without the <code>Layout</code> it doesn't know how much it needs to deallocate. Partial deallocation means that there is no mapping from allocated pointer to allocation size possible. The middle of the original allocation may have been deallocated, leaving to halves that need to be deallocated individually, with the second half never being returned by the allocation function.</p>",
        "id": 253310269,
        "sender_full_name": "bjorn3",
        "timestamp": 1631648054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/Use.20of.20Layout.20passed.20to.20deallocate/near/253310269\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://gitlab.redox-os.org/redox-os/ralloc\">ralloc</a> needs the <code>Layout</code> as it allows partial deallocation of allocated memory. Without the <code>Layout</code> it doesn't know how much it needs to deallocate. Partial deallocation means that there is no mapping from allocated pointer to allocation size possible. The middle of the original allocation may have been deallocated, leaving to halves that need to be deallocated individually, with the second half never being returned by the allocation function.</p>\n</blockquote>\n<p>I previously thought this was not possible, but reading \"Currently allocated memory\" again here <a href=\"https://doc.rust-lang.org/std/alloc/trait.Allocator.html\">https://doc.rust-lang.org/std/alloc/trait.Allocator.html</a> , I see that it's possible. In which case, I see the use case</p>\n<p>(\"Currently allocated memory\" says \"the starting address for that memory block was previously returned by allocate, grow, or shrink, and...\" and <code>deallocate</code> says \"ptr must denote a block of memory currently allocated via this allocator, and...\" Previously, I interpreted it as \"ptr == starting address\", but I suppose by \"ptr must denote a block of memory...\" just means that ptr must lie in some previous allocation)</p>\n<p>Thanks for the clarification!</p>",
        "id": 254987513,
        "sender_full_name": "Raekye",
        "timestamp": 1632714250
    },
    {
        "content": "<p>Thinking about this more, doesn't this mean a conforming <code>Allocator</code> <em>must</em> support partial deallocations? For example, it would be incorrect to build an allocator that directly uses libc's <code>malloc</code> and <code>free</code>, since <code>free</code> only takes pointers returned by the <code>malloc</code> family of functions. I'm not sure if jemalloc and other malloc replacements support partial deallocations, but I would be at least slightly surprised if they did (and it would have to be through custom APIs). As far as I can tell, there's no way for a Rust <code>Allocator</code> to indicate that it can't support partial deallocations</p>",
        "id": 254988927,
        "sender_full_name": "Raekye",
        "timestamp": 1632715375
    },
    {
        "content": "<p>Rust's <code>System</code> default allocator on unix-y platforms directly calls <code>libc::free</code> <a href=\"https://doc.rust-lang.org/src/std/sys/unix/alloc.rs.html#41-43\">https://doc.rust-lang.org/src/std/sys/unix/alloc.rs.html#41-43</a> </p>\n<p>Unless I'm missing something, either the <code>ptr</code> passed to <code>dealloc</code> must be the address returned by an allocation/reallocation function (i.e. the starting address), because that's what <code>libc::free</code> requires, or the <code>System</code> allocator doesn't conform to <code>Allocator</code>...? Is there something I'm missing?</p>",
        "id": 254989610,
        "sender_full_name": "Raekye",
        "timestamp": 1632715839
    },
    {
        "content": "<p>Sorry for all the messages... to be clear, this stems from the interpretation of what \"denote a block of memory\" means. The two obvious ways to me are 1. it must be the starting address of a previously allocated block of memory, or 2. it can be any address within a previously allocated block of memory. If I understood bjorn3, ralloc assumes 2, which allows for partial deallocations. But <code>System</code> assumes 1, because it uses <code>free</code></p>",
        "id": 254990233,
        "sender_full_name": "Raekye",
        "timestamp": 1632716501
    },
    {
        "content": "<p>1</p>",
        "id": 254995331,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632721085
    },
    {
        "content": "<p>I think bjorn3 means that you can use <code>shrink</code> to deallocate some memory</p>",
        "id": 254995375,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632721128
    },
    {
        "content": "<p>which is partial deallocation from the end</p>",
        "id": 254995434,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632721199
    },
    {
        "content": "<p>but you cannot just arbitary split the allocation and free them</p>",
        "id": 254995489,
        "sender_full_name": "Gary Guo",
        "timestamp": 1632721218
    },
    {
        "content": "<p>He says \"the middle of the original allocation may have been deallocated, leaving [two] halves that need to be deallocated individually...\", which sounds like arbitrarily splitting an allocation (although I agree what you said makes more sense to me)</p>",
        "id": 254998342,
        "sender_full_name": "Raekye",
        "timestamp": 1632723325
    },
    {
        "content": "<p>ralloc can actually split it in the middle. The Allocator interface doesn't allow this, but ralloc can't keep metadata about where blocks start and end to allow for a single pointer <code>free()</code> like interface without taking a <code>Layout</code> because it does allow arbitrary splits.</p>",
        "id": 255000287,
        "sender_full_name": "bjorn3",
        "timestamp": 1632724706
    },
    {
        "content": "<p>I see, that clarifies my confusions. Thank you!</p>",
        "id": 255846593,
        "sender_full_name": "Raekye",
        "timestamp": 1633156009
    }
]