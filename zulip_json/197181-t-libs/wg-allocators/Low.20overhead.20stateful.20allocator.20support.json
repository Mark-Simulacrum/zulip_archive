[
    {
        "content": "<p>Has there been thought given to supporting stateful allocators without storing the required state multiple times? For example, given a struct like:</p>\n<div class=\"codehilite\"><pre><span></span><code>struct Outer {\n    a: Box&lt;A&gt;,\n    b: Box&lt;B&gt;,\n    c: Box&lt;C&gt;,\n    ...\n}\n</code></pre></div>\n<p>A stateful allocator with a usize state would take up 3 usize's in the struct rather than 1. If there were a mechanism to provide the allocator/deallocator with the state explicitly, then the state could be stored in the <code>Outer</code> struct and provided during it's destructor.</p>",
        "id": 270317671,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1643764490
    },
    {
        "content": "<p>For Larger allocators (&gt;pointer sized) , you can use <code>&amp;'a A</code> allocators. Doesn't become ZST, though.</p>",
        "id": 270325800,
        "sender_full_name": "Connor Horman",
        "timestamp": 1643770332
    },
    {
        "content": "<p>The hard part is figuring out how to pass the allocator to the individual boxes when they are dropped. Rust currently has no mechanism to enable this.</p>",
        "id": 270414800,
        "sender_full_name": "Amanieu",
        "timestamp": 1643819869
    },
    {
        "content": "<p>You'd have to make an alternative Box type that was manually dropped and then the drop of the Outer type would pass in the usize to each manual drop. Annoying to write, but saves space and all that.</p>",
        "id": 270424639,
        "sender_full_name": "Lokathor",
        "timestamp": 1643822959
    }
]