[
    {
        "content": "<p><a href=\"https://cad97.github.io/storages-api/storage_api/index.html\">https://cad97.github.io/storages-api/storage_api/index.html</a></p>",
        "id": 278441541,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649554533
    },
    {
        "content": "<p>You could describe this revision as \"<code>Allocator</code>, but dealing in <code>&lt;T as Pointee::Metadata&gt;</code> instead of <code>Layout</code>\"</p>",
        "id": 278441586,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649554567
    },
    {
        "content": "<p>If I've done my homework right, there's only one soundness hole, and it's one I need language cooperation to plug</p>",
        "id": 278441605,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649554669
    },
    {
        "content": "<p>Specifically, the inability to go from <code>&lt;T as Pointee::Metadata&gt;</code> to <code>Option&lt;Layout&gt;</code> safely</p>",
        "id": 278441646,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649554692
    },
    {
        "content": "<p>So for right now it's just using a polyfill that always returns <code>Some</code></p>",
        "id": 278441659,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649554719
    },
    {
        "content": "<p>repo: <a href=\"https://github.com/CAD97/storages-api\">https://github.com/CAD97/storages-api</a></p>",
        "id": 278441663,
        "sender_full_name": "Christopher Durham",
        "timestamp": 1649554732
    },
    {
        "content": "<p>So, I think the promises that the storage approach brings are compelling, and this does seem to be the most approachable version yet -- so I'm glad someone is still actively thinking about storage. (so please don't take the next part harshly)</p>\n<p>That said, I think in it's current state it's quite a bit too complex. It's very conceptually dense, with storages, handles, pointee::metadata as an alternative to layout, and many unsafe traits with complex safety requirements. So, I think it needs to be simplified to be viable -- as it is it feels like it would be the one of the most complex pieces of the stdlib. Concrete feedback would be:</p>\n<ol>\n<li>It is probably too trait and generic heavy. I know this is nearly impossible, but use of these things within moderatation, the way the bulk of the stdlib does. If nothing else, if used as the backing of box, vec, etc, I'd be worried some about compiler errors, compile times, and the like.</li>\n<li>I think it tries to encode too many of the UCG rules into the type system. I think I see why it does this for the most part, and I do think you need to have an idea of how the design will interact here both as you go (and def before it lands)... But, well, it feels like this is where the design <em>started</em>, and I'm not sure that's the right way to go about it here.</li>\n<li>I'm unsure handle and metadata are worth the trouble. I also am unsure that it's worth the restrictions this seems to add to metadata.</li>\n</ol>\n<p>I also am concerned about trying to implement storages that don't neatly fit the rules that this lays out (and there are a <em>lot</em> of rules). This goes along with two, since given that to be useful this would need to be the backbone of data structure implementations and all integration with external allocators and such would need to go through it as well. So I'd lean towards favoring flexibility in various ways, rather than to lock down the possible ways it can be implemented so much. I think you need to have pretty strong justification for requirements that restrict all implementations (the current allocator trait has this problem too, but I won't go into it and it's not the most important issue).</p>\n<p>So yeah that's my 2c. It's definitely good progress and storages would enable cool functionality for our collection types, but I think in this state it would be not quite worth it. That said, I think this is the first version of the storage proposal where I thought the design was focused enough (it's complex but somewhat less... sprawling?). But maybe that's a me issue.</p>",
        "id": 278507803,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1649651556
    },
    {
        "content": "<p><code>trait Handle</code> used to have a <code>fn metadata(&amp;self)</code> function, but it doesn't now, since I added in <a href=\"https://cad97.github.io/storages-api/storage_api/struct.RefStorage.html\"><code>RefStorage</code></a>, which needs to only deal in a single type. In its current state, <code>Handle</code> doesn't do anything and can definitely be dropped. I'm very unsure about how everything should interact with unsizing, though.</p>",
        "id": 278508150,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649652053
    },
    {
        "content": "<p>Before <code>RefStorage</code>, everything was using a GAT handle type, so it was <code>trait Storage { fn create&lt;T&gt;</code> rather than <code>trait Storage&lt;T&gt; { fn create</code></p>",
        "id": 278508168,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649652099
    },
    {
        "content": "<p>Is this one of those storages you're not supposed to use generically?</p>",
        "id": 278508249,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649652235
    },
    {
        "content": "<p><code>RefStorage</code> exists because it allows <code>Box</code> to be <code>&amp;move</code>: <a href=\"https://github.com/CAD97/storages-api/blob/main/tests/box_tricks.rs\">https://github.com/CAD97/storages-api/blob/main/tests/box_tricks.rs</a></p>",
        "id": 278508302,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649652279
    },
    {
        "content": "<p>But honestly <code>RefStorage</code> is kind of a party trick and I'd be fine rolling it back for only any type storage</p>",
        "id": 278508351,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649652314
    },
    {
        "content": "<p>You can still have borrowed storage in a world with <code>&amp;mut MaybeUninit&lt;T&gt;</code></p>",
        "id": 278508355,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649652338
    },
    {
        "content": "<p>I just want to make sure that the \"<code>dyn*</code> use case\" continues to work, and that requires at least a <code>&amp;mut T</code>-like box, though I think maybe not a <code>&amp;move T</code>-like box</p>",
        "id": 278508405,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649652383
    },
    {
        "content": "<p><code>dyn*</code> may be happy enough with a <code>&amp;mut MaybeUninit&lt;T&gt;</code> place that it allocates into</p>",
        "id": 278508414,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649652423
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/A.20new.20storages.20API.20proposal/near/278507803\">said</a>:</p>\n<blockquote>\n<ol start=\"2\">\n<li>I think it tries to encode too many of the UCG rules into the type system. I think I see why it does this for the most part, and I do think you need to have an idea of how the design will interact here both as you go (and def before it lands)... But, well, it feels like this is where the design <em>started</em>, and I'm not sure that's the right way to go about it here.</li>\n</ol>\n</blockquote>\n<p>This is the only one I have a fundamental disagreement to. The refinement traits are <em>required</em> to support both inline storage and outline storage. Inline storage is fundamentally restricted: it can't allocate more than one object, it's <code>'static</code> but the object is not pinned, you need <code>resolve_mut</code> in order to mutate the object. (<code>SliceStorage</code> is the only one that could apply cleanly to inline storages.) However, all of these are useful properties to have and that an outline <code>Allocator</code> provides. The only ones I think could just be outright dropped are <code>SharedMutabilityStorage</code> and <code>SliceStorage</code>; the former at a loss of its functionality, and the latter by just failing by default. <code>PinningStorage</code> is required for <code>Pin&lt;Box&lt;T, S&gt;&gt;</code> to ever be valid, and <code>MultipleStorage</code> is required for graph-like collections that have multiple allocations.</p>",
        "id": 278508824,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649653083
    },
    {
        "content": "<p>The two most restrictive <code>Storage</code> impls I can think of are <code>RefStorage</code> (you have <code>&amp;mut T</code> and use it as backing storage; restriction: you can only have an object of type <code>T</code>, because otherwise you could write invalid data.) and <code>InlineStorage</code> (you have a <code>MaybeUninit</code> buffer; restriction: <code>resolve</code> cannot give write access, reborrowing the storage invalidates resolved pointers). The current shape of <code>Storage</code> is specifically to allow those two implementations to exist.</p>",
        "id": 278509072,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649653370
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/197181-t-libs.2Fwg-allocators/topic/A.20new.20storages.20API.20proposal/near/278507803\">said</a>:</p>\n<blockquote>\n<p>I also am unsure that it's worth the restrictions this seems to add to metadata.</p>\n</blockquote>\n<p>The specific restriction this adds to metadata is that <code>Layout::for_metadata&lt;T&gt;(&lt;T as Pointee&gt;::Metadata) -&gt; Option&lt;Layout&gt;</code> should be safely implementable. Equivalently, there should be a safe <code>Layout::for_value_raw(*const T) -&gt; Option&lt;Layout&gt;</code>. <code>align_of_val_raw</code> is already safe in its current implementation, and <code>size_of_val_raw</code> is safe except for the fact that it can return bogus results for oversized slice tails. This is fairly simple to provide a non-wrapping version of (just saturate).</p>",
        "id": 278509305,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649653735
    },
    {
        "content": "<p>How much of that would be fixable by a <code>const Layout</code> param?</p>",
        "id": 278509381,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649653850
    },
    {
        "content": "<p>The problem with that is <code>?Sized</code> things, things which don't have a compile-time known layout</p>",
        "id": 278509405,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649653910
    },
    {
        "content": "<p>The main use case that makes storage metadata-aware is actually <code>RefStorage</code>, as the backing <code>&amp;mut T</code> already has the metadata, so for <code>Box&lt;T, &amp;mut ManuallyDrop&lt;T&gt;&gt;</code> to be the same size as <code>&amp;mut T</code>, the handle needs to be ZST</p>",
        "id": 278509763,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649654427
    },
    {
        "content": "<p>I plan to write a blog post / whitepaper / w/e deriving the <code>Storage</code> API from its use cases, so we'll see how that lands. I do think the current set of storage traits is minimal, though.</p>",
        "id": 278509766,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649654432
    },
    {
        "content": "<p>Hmm does this current proposal support stack pinning?</p>",
        "id": 278510016,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649654844
    },
    {
        "content": "<p>It morally feels like a <code>Pin&lt;Storage&gt;</code> should have some way of supporting getting pinned data out, but I'm not sure if that's justifiable.</p>",
        "id": 278510080,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649654913
    },
    {
        "content": "<p><code>Pin&lt;&amp;mut impl Storage&gt;</code> would be able to provide pinned objects always, yes</p>",
        "id": 278510097,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649654958
    },
    {
        "content": "<p>But <code>Pin&lt;Box&lt;T&gt;&gt;</code> doesn't have a <code>Pin&lt;&amp;mut impl Storage&gt;</code></p>",
        "id": 278510101,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649654978
    },
    {
        "content": "<p>You'd need <code>Pin&lt;&amp;mut Box&lt;T&gt;&gt;</code></p>",
        "id": 278510107,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649654991
    },
    {
        "content": "<p>I don't have a <code>&amp;mut MaybeUninit&lt;DataStore&gt;</code> storage implemented yet, but it would provide pinned storage</p>",
        "id": 278510151,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649655008
    },
    {
        "content": "<p>So roughly</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">uninit</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">boxed</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">pin_in</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">store</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would work.</p>",
        "id": 278510182,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649655073
    },
    {
        "content": "<p>I was thinking more along the lines of <code>Pin&lt;&amp;mut Vec&lt;T, InlineStorage&lt;...&gt;&gt;</code></p>",
        "id": 278510242,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649655132
    },
    {
        "content": "<p>And I think the allocator could be projected when pinned in this case, so you'd get <code>Pin&lt;&amp;mut InlineStorage&lt;...&gt;&gt;</code>, internally.</p>",
        "id": 278510272,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1649655212
    }
]