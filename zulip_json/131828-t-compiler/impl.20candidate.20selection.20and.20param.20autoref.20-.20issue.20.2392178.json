[
    {
        "content": "<p>Hey y'all! I'm investigating <a href=\"https://github.com/rust-lang/rust/issues/92178\">#92178</a> (<a href=\"https://github.com/rust-lang/rust/issues/92178\">https://github.com/rust-lang/rust/issues/92178</a>) and I think I understand why the issue is occuring. I commented in the original issue, but basically:</p>\n<p>We try to call <code>Add</code> on a <code>String</code> and a <code>&amp;String</code>. Right now, we have one candidate for <code>impl Add&lt;_&gt; for String</code> in std, and this works fine. <br>\nThe issue arises when adding another relevant <code>Add</code> impl in scope (by implementing <code>Add&lt;Other&gt; for String</code> locally, or in the issue's case, <code>use</code>ing a module which does this). <br>\nThis causes us to skip the short-circuiting logic in <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs#L153\"><code>SelectionContext::candidate_from_obligation_no_cache</code> @ L153</a>. <br>\nSince we don't short-circuit, we try winnowing the (in this case, two) relevant <code>impl Add for String</code> candidates, which fails to account for autoref coersion in the parameter.. leading to us collecting zero candidate impls, and reporting \"<code>Add&lt;&amp;String&gt;</code> is not implemented for <code>String</code>\".</p>\n<p>So my questions are: </p>\n<ol start=\"0\">\n<li>This isn't due to any recent change in trait selection behavior that I'm missing, right?</li>\n<li>Do we want to account for parameter autoref in impl candidate winnowing? </li>\n<li>If so, how? I'd love to help implement this change.</li>\n<li>If not, do we want to add <code>Add&lt;&amp;String&gt; for String</code> to fix the github issue (and related <a href=\"https://github.com/rust-lang/rust/issues/92209\">#92209</a>)?</li>\n</ol>\n<p>I'd love to help fixing this issue, but I don't think I should start touching fundamental trait selection logic without asking whether we want this behavior in the first place.</p>",
        "id": 265884439,
        "sender_full_name": "Michael Goulet",
        "timestamp": 1640236541
    },
    {
        "content": "<p>side-note: Does this belong in t-lang or here? Or perhaps another stream? wg-traits seemed a bit too chalk-focused :^)</p>",
        "id": 265884519,
        "sender_full_name": "Michael Goulet",
        "timestamp": 1640236639
    },
    {
        "content": "<p><em>Correction</em>: </p>\n<blockquote>\n<p>we try winnowing the (in this case, two) relevant impl Add for String candidates, which fails to account for autoref coersion in the parameter.. leading to us collecting zero candidate impls,</p>\n</blockquote>\n<p>So this is actually is not exactly what happens. <br>\nSo first we try to solve <code>String as Add&lt;_&gt;</code> which for the 1 impl case, short-circuits as above. In the case we have our custom impl, we call this ambiguous since we have 2 impl candidates. Then inferencing progresses, and we infer the type variable to be <code>&amp;String</code>. Then we try solving <code>String as Add&lt;&amp;String&gt;</code> which fails, of course.</p>\n<p>So integrating autoref into impl candidate winnowing won't fix this actually. This is really just due to the fact that <code>Add</code> currently has one impl candidate for <code>String</code>, and adding another one breaks things :/</p>",
        "id": 265885925,
        "sender_full_name": "Michael Goulet",
        "timestamp": 1640238578
    }
]