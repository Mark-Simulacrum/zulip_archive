[
    {
        "content": "<p>Hi, I am doing a strange thing where I am (ab)using the ELF support in the Watcom linker to create DPMI executables with Rust. However, for <code>_memset</code> (and the likes), rustc generates <code>R_386_PLT32</code> relocations in <strong>debug</strong> whereas in <strong>release</strong> it generates <code>R_386_PC32</code>. Issue is that the Watcom linker does not support PLT relocations. Is there any way to not generate <code>R_386_PLT32</code> relocations in debug? I have tried using <code>-Z plt=off</code> but that does not seem to do anything (this is 32-bit x86 code).</p>\n<p>Example:</p>\n<div class=\"codehilite\"><pre><span></span><code>readelf -r target/dos/debug/deps/libcore-1f0298ee783f3e78.rlib | grep _memset\n00000089  00024504 R_386_PLT32       00000000   _memset\n0000009a  00024502 R_386_PC32        00000000   _memset\n00000089  00024504 R_386_PLT32       00000000   _memset\n00000089  00024504 R_386_PLT32       00000000   _memset\n...\n</code></pre></div>\n<p>whereas release gives</p>\n<div class=\"codehilite\"><pre><span></span><code> readelf -r target/dos/release/deps/libcore-57b25a09c66a3e47.rlib  | grep _memset\n00000225  0000c702 R_386_PC32        00000000   _memset\n000002ac  0000c702 R_386_PC32        00000000   _memset\n0000000e  0000b702 R_386_PC32        00000000   _memset\n0000001c  0000b702 R_386_PC32        00000000   _memset\n00000335  0000b702 R_386_PC32        00000000   _memset\n00000016  00007302 R_386_PC32        00000000   _memset\n00000023  00007302 R_386_PC32        00000000   _memset\n...\n</code></pre></div>",
        "id": 255026368,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632739226
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"298746\">@Albert Cervin</span> What target triple are you compiling for?</p>",
        "id": 255055830,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1632752424
    },
    {
        "content": "<p>i686-unknown-none-elf</p>",
        "id": 255056116,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632752527
    },
    {
        "content": "<p>Are you buiding with <code>-Z build-std</code>?</p>",
        "id": 255071920,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1632757981
    },
    {
        "content": "<p>I suspect that this is an LLVM issue</p>",
        "id": 255072216,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1632758082
    },
    {
        "content": "<p>Yes, exactly. It seems to be an LLVM issue yes (the code that disables decides to not use a PLT reloc seems to check for x64). However, that does not explain the difference between debug and release?</p>",
        "id": 255075174,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632759081
    },
    {
        "content": "<p>My guess is that there's a pass which only runs in release mode</p>",
        "id": 255077347,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1632759948
    },
    {
        "content": "<p>which is responsible for adjusting relocations in some way</p>",
        "id": 255077376,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1632759959
    },
    {
        "content": "<p>Could it be <a href=\"https://bugs.llvm.org//show_bug.cgi?id=36674#c6\">https://bugs.llvm.org//show_bug.cgi?id=36674#c6</a>?</p>",
        "id": 255094385,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632766452
    },
    {
        "content": "<p>This is actually for the references to for example <code>memset</code> in the init of slices (e.g. <code>[0; 4]</code>). How are those generated?</p>",
        "id": 255107246,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632771380
    },
    {
        "content": "<p>Seems to be this: <a href=\"https://github.com/rust-lang/rust/blob/22719efcc570b043f2e519d6025e5f36eab38fe2/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp#L1446\">https://github.com/rust-lang/rust/blob/22719efcc570b043f2e519d6025e5f36eab38fe2/compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp#L1446</a></p>",
        "id": 255107962,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632771662
    },
    {
        "content": "<p>which, I guess, should ultimately end up here: <a href=\"https://github.com/llvm/llvm-project/blob/f7e82e4fa849376ea9226220847a098dc92d74a0/llvm/lib/Target/X86/X86Subtarget.cpp#L217\">https://github.com/llvm/llvm-project/blob/f7e82e4fa849376ea9226220847a098dc92d74a0/llvm/lib/Target/X86/X86Subtarget.cpp#L217</a>, but seems not to</p>",
        "id": 255109467,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632772269
    },
    {
        "content": "<p>for _some_ cases of <code>memset</code></p>",
        "id": 255110395,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632772660
    },
    {
        "content": "<p>Could it be that some are generated by LLVM and some by \"core\" as indicated here: <a href=\"https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library/core/src/lib.rs#L24\">https://github.com/rust-lang/rust/blob/0273e3bce7a0ce49e96a9662163e2380cb87e0be/library/core/src/lib.rs#L24</a> and they somehow get annotated differently?</p>",
        "id": 255111000,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632772877
    },
    {
        "content": "<p>For example, we can see that <code>fmt_int</code> is generated differently for u8 and u128:</p>\n<p>u8</p>\n<div class=\"codehilite\"><pre><span></span><code>Relocation section &#39;.rel.text.__ZN4core3fmt3num12GenericRadix7fmt_int17hf5976642c34c8537E&#39; at offset 0x2ae44 contains 36 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n00000025  00016902 R_386_PC32        00000000   __ZN49_$LT$u8$u20[...]\n00000046  00017602 R_386_PC32        00000000   __ZN4core3cmp5imp[...]\n00000089  00024504 R_386_PLT32       00000000   _memset\n</code></pre></div>\n<p>u128</p>\n<div class=\"codehilite\"><pre><span></span><code>Relocation section &#39;.rel.text.__ZN4core3fmt3num12GenericRadix7fmt_int17hf666fec66e88c170E&#39; at offset 0x2af64 contains 36 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n00000050  00022502 R_386_PC32        00000000   __ZN51_$LT$u128$u[...]\n000000a5  00017c02 R_386_PC32        00000000   __ZN4core3cmp5imp[...]\n000000e7  00024502 R_386_PC32        00000000   _memset\n</code></pre></div>\n<p>note PLT32 for u8 and PC32 for u128</p>",
        "id": 255111509,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632773081
    },
    {
        "content": "<p>Furthermore, here is a Godbolt example: <a href=\"https://godbolt.org/z/7GdeeP8bc\">https://godbolt.org/z/7GdeeP8bc</a>. Note that, when adding <code>-C relocation-model=static</code>, the call to <code>getenv</code> loses its' \"@PLT\" label but the <code>memcpy</code> call from the array initialization does not which, seems like a bug to me.</p>",
        "id": 255113230,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632773818
    },
    {
        "content": "<p>Would be grateful for any pointers as to where to start looking where this \"@PLT\" call comes from <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 255205998,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1632831314
    },
    {
        "content": "<p>Debugging this further, it is definitely an LLVM thing, it relies on link-time-relaxation of the PLT calls (which of course makes a lot of sense)</p>",
        "id": 255940821,
        "sender_full_name": "Albert Cervin",
        "timestamp": 1633256084
    }
]