[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@Kevin Leimkuhler</span> hey =)</p>",
        "id": 134981309,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538411614
    },
    {
        "content": "<p>So you asked:</p>\n<blockquote>\n<p>Do you have any pointers on how to get a value: &amp;ast::Expr from this situation that I can pass on to check_unused_parens_core to indicate that a PatKind::Wild should not need parens?</p>\n</blockquote>\n<p>I think the answer is that you cannot =) patterns are not expressions, at least in Rust's HIR, and you can't readily interconvert. We'll have to make the logic in <code>check_unused_parens_core</code> either generic over both patterns and types or else make a distinct copy</p>",
        "id": 134981392,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538411706
    },
    {
        "content": "<p>I don't really remember how general that logic is, tbh</p>",
        "id": 134981396,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538411715
    },
    {
        "content": "<p>a lot of times we can make logic generic over things by making it just operate on a <code>NodeId</code> or <code>HirId</code></p>",
        "id": 134981398,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538411725
    },
    {
        "content": "<p>Ok that makes sense. So I think it could be reasonable to make <code>check_unused_parens_core</code> generic over both patterns and types, since the fields that it uses from <code>ast::Expr</code> already exist in <code>ast::Pat</code> (<code>node</code> and <code>span</code>)</p>",
        "id": 134989077,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538419600
    },
    {
        "content": "<p>Since this is my first time really digging into the Rust source code, I think I may work towards a distinct copy that works with the specific case pointed out in the issue. I was able to speak about other patterns with <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> over Discord, and think that as I make the check more robust I can look into generalizing <code>check_unused_parens_core</code>.</p>",
        "id": 134989381,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538419957
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@Kevin Leimkuhler</span> sounds reasonable</p>",
        "id": 134989602,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538420170
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I have a minimal working implementation that properly warns on the example in the issue: <a href=\"https://github.com/rust-lang/rust/issues/51087#issuecomment-397918200\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/51087#issuecomment-397918200\">https://github.com/rust-lang/rust/issues/51087#issuecomment-397918200</a>.</p>\n<p>I have essentially copied <code>check_unused_parens_core</code> into <code>check_unused_parens_expr</code> and <code>check_unused_parens_pat</code>; the differ only in how they handle <code>value</code> (either <code>ast::Expr</code> or <code>ast::Pat</code>).</p>\n<p>I'd like to ideally make <code>check_unused_parens_core</code> generic of the type of <code>value</code>, but <code>ast::Expr</code> and <code>ast::Pat</code> don't share an obvious parent struct to match on.</p>",
        "id": 135053657,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538504420
    },
    {
        "content": "<p>Would it make sense to consider making <code>check_unused_parens_core</code> generic of a <code>value</code> type <code>T</code> where <code>T</code> implements <code>Clone</code>, <code>RustEncodable</code>, and <code>RustDecodable</code> (the traits that <code>ast</code> structs implement) and match from there?</p>",
        "id": 135053688,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538504480
    },
    {
        "content": "<p>If it helps clarify, here is the commit I'm currently working off of: <a href=\"https://github.com/kleimkuhler/rust/commit/9229b025b993bcc6892c0afa1a0ac834005cecea\" target=\"_blank\" title=\"https://github.com/kleimkuhler/rust/commit/9229b025b993bcc6892c0afa1a0ac834005cecea\">https://github.com/kleimkuhler/rust/commit/9229b025b993bcc6892c0afa1a0ac834005cecea</a></p>",
        "id": 135053799,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538504560
    },
    {
        "content": "<p>I don't think <code>RustEncodable</code> and <code>RustDecodable</code> makes much sense; it might not be worth trying to collapse it</p>",
        "id": 135054330,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> it seems like we could extract most of the logic from that fn into a helper anyway</p>",
        "id": 135054374,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505061
    },
    {
        "content": "<p>we could certainly make this generic in various ways</p>",
        "id": 135054394,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505088
    },
    {
        "content": "<p>one would be to supply closures -- there are basically only two things we do: \"check if this is parens\" and \"pretty print\"</p>",
        "id": 135054404,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505105
    },
    {
        "content": "<p>or we could make a little one-off trait and implement it for <code>hir::Expr</code> and <code>hir::Pat</code></p>",
        "id": 135054410,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505119
    },
    {
        "content": "<p>(with those two methods)</p>",
        "id": 135054453,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505126
    },
    {
        "content": "<p>or we could just have two functions but share the \"guts\" — basically starting from the point where we pretty-print</p>",
        "id": 135054464,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505140
    },
    {
        "content": "<p>at which point, the function seems to just be operating over spans and strings</p>",
        "id": 135054469,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538505150
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Great, those are definitely all good starting points I can work from. I think there may need to be three things covered - the two you mentioned plus a <code>necessary</code> check (<code>ast::Pat</code> does not have an equivalent <code>parser::contains_exterior_struct_lit(&amp;inner)</code> so I just simplified it to <code>if !struct_lit_needs_parens</code>?</p>\n<p>Either way for the issue this is solving I lean towards just sharing the \"guts\". A generic solution seems like an interesting path I can explore after it's ready to go, but seems maybe a little unnecessary right now. Do you agree or would you a generic solution put in place for this?</p>",
        "id": 135081153,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538542226
    },
    {
        "content": "<p>I'd prefer to share the guts</p>",
        "id": 135115481,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538584510
    },
    {
        "content": "<p>if that works out</p>",
        "id": 135115485,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538584515
    },
    {
        "content": "<p>generics are great sometimes but other times kind of obfuscating</p>",
        "id": 135115488,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538584527
    },
    {
        "content": "<p>to me, this feels like it will be the latter</p>",
        "id": 135115494,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538584540
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I am trying to get the match arms in <code>check_pat</code> to all have the same type and I'm having an issue in handling the <code>Paren</code> case. In the <code>Paren</code> case, it should pass along the entire <code>&amp;ast::Pat</code> (to indicate the entire pattern does not need to be surrounded by parentheses). In the other cases, it should pass along a <code>ref</code>.</p>\n<p>For example, the last two currently are:</p>\n<div class=\"codehilite\"><pre><span></span>Slice(_, Some(ref pat), _) =&gt; (pat, &quot;optional position pattern&quot;, false),\nParen(_) =&gt; (p, &quot;pattern&quot;, false),\n</pre></div>\n\n\n<p>which produce the following types:</p>\n<div class=\"codehilite\"><pre><span></span>(&amp;syntax::ptr::P&lt;syntax::ast::Pat&gt;, &amp;str, bool)\n(&amp;syntax::ast::Pat, &amp;&#39;static str, bool)\n</pre></div>",
        "id": 135200393,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538670632
    },
    {
        "content": "<p>I've tried wrapping the <code>p</code> in the <code>Paren</code> case with <code>&amp;P::new(p)</code> and a few variants of it (supplying the type it should be and all), but can't seem to get things to align.</p>\n<p>Is there a different way to go about handling the case that does not involve the fiddling with wrapping it in a new <code>syntax::ptr::P</code>?</p>",
        "id": 135200496,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538670724
    },
    {
        "content": "<p>if you have a <code>&amp;P&lt;Pat&gt;</code>, you can deref that to a <code>&amp;Pat</code></p>",
        "id": 135200528,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538670770
    },
    {
        "content": "<p>is that what you need?</p>",
        "id": 135200530,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538670774
    },
    {
        "content": "<p>maybe you can send along the code that doesn't build + the errors?</p>",
        "id": 135200537,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538670783
    },
    {
        "content": "<p>The other arms all produce values of <code>&amp;P&lt;Pat&gt;</code>, it's the <code>Paren</code> case that just produces a <code>Pat</code> is the issue.</p>",
        "id": 135200622,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538670870
    },
    {
        "content": "<p>Sure that may be more helpful. How do you prefer that usually - just push up what I have to a branch or a different way?</p>",
        "id": 135200643,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538670905
    },
    {
        "content": "<p>I usually prefer a <code>[WIP]</code> PR</p>",
        "id": 135200653,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538670914
    },
    {
        "content": "<p>but pushing to a branch and sending a link to the branch is also ok</p>",
        "id": 135200658,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538670923
    },
    {
        "content": "<p>it's just that it's easier to comment on PRs</p>",
        "id": 135200660,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538670928
    },
    {
        "content": "<p>Ok here is a comment: <a href=\"https://github.com/rust-lang/rust/pull/54820/files#r222748510\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/54820/files#r222748510\">https://github.com/rust-lang/rust/pull/54820/files#r222748510</a></p>",
        "id": 135201718,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538672036
    },
    {
        "content": "<p>And the reason I want to pass <code>p</code> and not what <code>Paren</code> matches on, is because it then strips the <code>Paren</code> and will not lint on a case like <code>(_) =&gt; {},</code></p>",
        "id": 135201952,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538672248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> try one of two things:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">struct_lit_needs_parens</span><span class=\"p\">)</span>: <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ast</span>::<span class=\"n\">Pat</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>or </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"w\"> </span><span class=\"n\">Ident</span><span class=\"p\">(..,</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">ref</span><span class=\"w\"> </span><span class=\"n\">pat</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;*</span><span class=\"n\">pat</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">&quot;optional subpattern&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">),</span><span class=\"w\"></span>\n</pre></div>",
        "id": 135202171,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672452
    },
    {
        "content": "<p>the former will force a coercion, the latter does the coercion explicitly</p>",
        "id": 135202184,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672461
    },
    {
        "content": "<p>you'll have to change all the arms to match, in the second case</p>",
        "id": 135202191,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672471
    },
    {
        "content": "<p><code>P</code> is a \"smart pointer\", much like <code>Box</code>, so it can be deref'd</p>",
        "id": 135202197,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672484
    },
    {
        "content": "<p>you might need <code>&amp;**pat</code> though (ugh..)</p>",
        "id": 135202202,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672491
    },
    {
        "content": "<p>Hm yea that's what I was trying to avoid (changing all the arms to match)... I'll try the coercion explicitly and hopefully can get somewhere with that.</p>",
        "id": 135202264,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538672558
    },
    {
        "content": "<p>Does it make sense though in trying to make a new <code>syntax::ptr::P</code> with <code>p</code>? That way I don't need to be explicit about the coercion and I just handle the <code>Paren</code> case?</p>",
        "id": 135202299,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538672610
    },
    {
        "content": "<p>And quick unrelated question... how should <code>[WIP]</code> PRs be handled once they've served the purpose of sharing progress? Should I close and reopen a new one when it's ready, or keep it open and just edit the title when it's ready?</p>",
        "id": 135202481,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538672776
    },
    {
        "content": "<blockquote>\n<p>Does it make sense though in trying to make a new <code>syntax::ptr::P</code> with <code>p</code>? That way I don't need to be explicit about the coercion and I just handle the <code>Paren</code> case?</p>\n</blockquote>\n<p>That does not make sense</p>",
        "id": 135202609,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672959
    },
    {
        "content": "<blockquote>\n<p>And quick unrelated question... how should <code>[WIP]</code> PRs be handled once they've served the purpose of sharing progress? Should I close and reopen a new one when it's ready, or keep it open and just edit the title when it's ready?</p>\n</blockquote>\n<p>I would say just keep it open — then I can come along and make quick comments</p>",
        "id": 135202621,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672977
    },
    {
        "content": "<p>depends how actively you are working on it, I think</p>",
        "id": 135202623,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672983
    },
    {
        "content": "<p>to elaborate: <code>P</code> is an \"owning\" pointer, like <code>Box</code></p>",
        "id": 135202631,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538672994
    },
    {
        "content": "<p>so you never convert things <em>into</em> a <code>P</code>, you only convert from <code>&amp;P&lt;T&gt;</code> into <code>&amp;T</code>; otherwise, you'd be deep-cloning a piece of the tree</p>",
        "id": 135202701,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538673018
    },
    {
        "content": "<p>I’ll keep it open; I plan to wrap it up soon.</p>\n<p>Thanks for the elaboration on that!</p>",
        "id": 135203114,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538673390
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> send me a link to the PR</p>",
        "id": 135203760,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538674028
    },
    {
        "content": "<p>when it's open..</p>",
        "id": 135203767,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1538674036
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  It is ready for a review! <a href=\"https://github.com/rust-lang/rust/pull/54820\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/54820\">https://github.com/rust-lang/rust/pull/54820</a>. The <code>Paren</code> check ended up being a lot simpler in the end.</p>",
        "id": 135294379,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1538792317
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> nice! I <a href=\"https://github.com/rust-lang/rust/pull/54820#pullrequestreview-162511830\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/54820#pullrequestreview-162511830\">left a review</a> describing how we could make it more precise, if we wanted. What do you think?</p>",
        "id": 135409342,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539010887
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I like your suggestion! My reply points out that the paren usage in expressions does also seem to specifically look for <code>&amp;pat</code> and <code>box pat</code>, so while I agree it seems a little hacky, it is a sure way to warn when necessary.</p>\n<p>I'll work on implementing those changes and leave a comment when it's good to go again. Thanks for the review!</p>",
        "id": 135412990,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539014553
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I have a working implementation based off your review. I'd like to add at least an additional test to make sure the \"more cases\" part of these additions is covered.</p>\n<p>A <code>ast::PatKind::Range</code> deconstructs into an <code>a: ast::Expr</code> and <code>b: ast::Expr</code> (so a little different than your review where you mentioned it would deconstruct into <code>Pat</code>s). This means at the very least, a match arm should have the form <code>&amp;(expr ..= expr) =&gt; {}</code></p>\n<p>What I'm struggling on is finding <code>expr: ast::Expr</code>s that fit into those slots (as in it compiles). I thought something like <code>&amp;((1+1)..=(1+2)) =&gt; {}</code> would be a simple case, but it does not seem to parse correctly.</p>",
        "id": 135432767,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539039366
    },
    {
        "content": "<p>Looking at: <a href=\"https://doc.rust-lang.org/beta/reference/expressions/range-expr.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/beta/reference/expressions/range-expr.html\">https://doc.rust-lang.org/beta/reference/expressions/range-expr.html</a>, it seems like <code>Expression ..= Expression</code> should be Ok, but I may be interpreting or assuming something incorrectly about that.</p>",
        "id": 135432856,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539039515
    },
    {
        "content": "<p>So it looks like right here: <a href=\"https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs#L4065-L4066\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs#L4065-L4066\">https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs#L4065-L4066</a>, a pattern the starts similar to the one above <code>&amp;(...</code> will be parsed to be a <code>token::OpenDelim</code> and only expect a <code>(pat, ..)</code> tuple pattern. However, what I really want to happen is the surround the <code>&amp;(...)</code> to be dropped, and it be parsed as a <code>token::DotDotEq</code>.</p>",
        "id": 135442941,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539058079
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> ok so you are correct about the ranges -- that's ok, it can return a <code>Vec&lt;&amp;Expr&gt;</code> I suppose, though even better might be to return something like a trait object — but that's a bit of \"premature generalization\" I suppose</p>",
        "id": 135468631,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539091119
    },
    {
        "content": "<p>ultimately it just needs to return something \"visitable\"</p>",
        "id": 135468639,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539091125
    },
    {
        "content": "<p>I don't really understand why you are looking at the parser though :)</p>",
        "id": 135468660,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539091152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> So you can see here the commit where I've added what you recommended in your review: <a href=\"https://github.com/rust-lang/rust/pull/54820/commits/2cb37eaea52c8ab3e97a7d536686c78ffe5e9c29#diff-d85eb66bc4756598e30d93a5d07d3d7fR401\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/54820/commits/2cb37eaea52c8ab3e97a7d536686c78ffe5e9c29#diff-d85eb66bc4756598e30d93a5d07d3d7fR401\">https://github.com/rust-lang/rust/pull/54820/commits/2cb37eaea52c8ab3e97a7d536686c78ffe5e9c29#diff-d85eb66bc4756598e30d93a5d07d3d7fR401</a></p>\n<p>I'm trying to add an additional test case where a match arm matches that additional block: <code>&amp;(expr ..= expr) =&gt; {}</code></p>",
        "id": 135471726,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539093865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> great, I'll take a look in a bit :)</p>",
        "id": 135471841,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539093971
    },
    {
        "content": "<p>I was looking at the parser because I was having a hard time writing a test case that properly fits that format. I tried things like <code>&amp;(&amp;1 ..= &amp;2) =&gt; {}</code> and variations of surround the <code>expr</code>s with parentheses, as well as different <code>expr</code>s like <code>(1+1)</code>, but I was getting parsing errors... so I trying to figure out why</p>",
        "id": 135471889,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539094030
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Ah great appreciate it! <span class=\"emoji emoji-1f642\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 135471900,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539094061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> I just realized that I was confused about something</p>",
        "id": 135482937,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539104073
    },
    {
        "content": "<p>somewhat annoyingly, the lint visitor (I believe) always walks <em>all</em> the patterns</p>",
        "id": 135482947,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539104087
    },
    {
        "content": "<p>this means that the scheme I had in mind doesn't quite work</p>",
        "id": 135482971,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539104111
    },
    {
        "content": "<p>since it relied on \"skipping over\" parens that were necessary during the walk</p>",
        "id": 135482975,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539104118
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  I'm not sure where you'd like to carry out conversation on this since it's split half/half between here and GH. I'll plan on getting a better idea of the mutable state here and then reply on GH if thats Ok</p>",
        "id": 135485878,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539107068
    },
    {
        "content": "<blockquote>\n<p>One option would be to keep a little mutable state in the UnusedParens lint itself; we could for example add the ids for 'necessary' parens into a set stored in the lint. Then when we reach the paren node, we can check if it is present in that set</p>\n</blockquote>\n<p>I'm not sure I completely follow what the <em>ids</em> part of this would hold. Is it the patterns that should be surrounded by parens in the match arm? Since the lint visitor visits all the subpatterns, is it checking something in <em>ids</em> each time to see if that subpattern needs to be surrounded by parens?</p>",
        "id": 135486070,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539107268
    },
    {
        "content": "<p>each pattern has a <code>NodeId</code></p>",
        "id": 135486390,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107585
    },
    {
        "content": "<p>(I think)</p>",
        "id": 135486395,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107592
    },
    {
        "content": "<p>so the lint would store a set of these ids</p>",
        "id": 135486402,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107598
    },
    {
        "content": "<p>we would add \"necessary parens\" into the set</p>",
        "id": 135486410,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107607
    },
    {
        "content": "<p>e.g., the paren in <code>&amp;(a ..= b)</code></p>",
        "id": 135486413,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107614
    },
    {
        "content": "<p>then, when we reach a paren, we could check if it is in the set (and, probably, remove it if it is)</p>",
        "id": 135486421,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107624
    },
    {
        "content": "<p>if it was <em>not</em> in the set, we can lint</p>",
        "id": 135486423,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107630
    },
    {
        "content": "<p>so basically when visiting the <code>&amp;</code>, we would see that it has a child which is a paren, and this paren has a \"low priority\" pat as its child</p>",
        "id": 135486493,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107664
    },
    {
        "content": "<p>this makes the pat necessary</p>",
        "id": 135486494,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107667
    },
    {
        "content": "<p>so we could add its id to the set</p>",
        "id": 135486496,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107671
    },
    {
        "content": "<p>then when we visit the paren node (which we will do next), we can remove it from the set</p>",
        "id": 135486507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539107681
    },
    {
        "content": "<p>Replying to acknowledge I've read the above, but I think I may need to familiarize myself more with the pattern visitor before understanding the distinction in adding \"necessary parens\" into the set, and then reaching a paren to check if it's there.</p>\n<p>Am I correct in understanding that the visitor adds all the <code>NodeId</code>s for patterns <em>and</em> expressions (e.g. <code>PatKind::Range(Expr, Expr, _)</code>) and then <code>check_pat</code> is where it actually determines if a paren should be present?</p>",
        "id": 135488334,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539109453
    },
    {
        "content": "<p>In order to understand the responsibilities of the lint visitor and <code>check_pat</code> for implementing the above, is starting from here a good place to work from? <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc/lint/context.rs#L972-L973\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc/lint/context.rs#L972-L973\">https://github.com/rust-lang/rust/blob/master/src/librustc/lint/context.rs#L972-L973</a></p>",
        "id": 135488467,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539109605
    },
    {
        "content": "<p>that does not sound correct</p>",
        "id": 135488781,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109871
    },
    {
        "content": "<p>when you write a lint and implement the <code>EarlyLintPass</code> trait</p>",
        "id": 135488795,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109883
    },
    {
        "content": "<p>there is some <em>outside</em> code that is walking over the AST</p>",
        "id": 135488803,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109892
    },
    {
        "content": "<p>and invoking <code>check_pattern</code> and <code>check_expr</code> on what it finds</p>",
        "id": 135488809,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109902
    },
    {
        "content": "<p>so that is just going to happen regardless</p>",
        "id": 135488819,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109909
    },
    {
        "content": "<p>our job is to implement those callbacks and figure out what to do</p>",
        "id": 135488823,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109917
    },
    {
        "content": "<p>so if you have e.g. a pattern like <code>&amp;(a ..= b)</code></p>",
        "id": 135488870,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109926
    },
    {
        "content": "<p>you will get a callback at the <code>&amp;</code> pattern</p>",
        "id": 135488877,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109931
    },
    {
        "content": "<p>then it will desend and you will get a callback on the <code>(..)</code> pattern</p>",
        "id": 135488886,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109941
    },
    {
        "content": "<p>then you will get a callback on the <code>a ..= b</code> pattern</p>",
        "id": 135488891,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109950
    },
    {
        "content": "<p>and then you will get callbacks for the <code>a</code> and <code>b</code> expressions</p>",
        "id": 135488897,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109958
    },
    {
        "content": "<p>I am saying that when we get the callback for the outermost <code>&amp;</code> pattern, we can add the id for the <code>(..)</code> pattern into a set; the reason we would do this is that — once we reach the <code>(..)</code> pattern – we have lost the context of <em>where</em> it appears</p>",
        "id": 135488923,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109985
    },
    {
        "content": "<p>you can only look \"down\" the tree, in other words</p>",
        "id": 135488931,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539109992
    },
    {
        "content": "<p>did that help <span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span> at all?</p>",
        "id": 135495153,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539115852
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Trying not to follow-up with another question, but my best point of reference right now is when <code>check_pat</code>/<code>check_expr</code> gets called for <code>UnusedParens</code>. I'm trying to understand where the \"add id for the <code>(..)</code> pattern into a set\" differs from \"once we reach the <code>(..)</code> pattern\" because I currently think that would occur at the same time.</p>\n<p>I understand about how the pattern is deconstructed down the tree, but I also don't really know why we can assume that a \"lower priority\" paren is always necessary. That may be solved with the <code>is_high_precedence_pat</code>/<code>is_low_precedence_pat</code> methods?</p>",
        "id": 135496865,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539117123
    },
    {
        "content": "<p>So I just need to familiarize myself more with the code before I have a better reply I think.</p>",
        "id": 135496906,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539117171
    },
    {
        "content": "<p>a paren is necessary if it is (a) a child of a high-precedence pattern and (b) contains a low-precedence pattern</p>",
        "id": 135496929,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539117207
    },
    {
        "content": "<p>that is, parentheses are basically the way you get low-precedence things <em>into</em> high-precedence ones</p>",
        "id": 135496939,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539117221
    },
    {
        "content": "<p>Ok so when (a) and (b) are satisfied the paren <code>NodeId</code> is considered necessary and should be added to the mutable set</p>",
        "id": 135497436,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539117704
    },
    {
        "content": "<p>And when we arrive at a paren outside the context of (a) and (b), we need to check if that paren <code>NodeId</code> is considered required</p>",
        "id": 135497493,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539117737
    },
    {
        "content": "<p>(and do the removal or lint if it is in the set or not)</p>",
        "id": 135497532,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539117808
    },
    {
        "content": "<p>right</p>",
        "id": 135497631,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539117913
    },
    {
        "content": "<blockquote>\n<p>I'm trying to understand where the \"add id for the (..) pattern into a set\" differs from \"once we reach the (..) pattern\" because I currently think that would occur at the same time.</p>\n</blockquote>",
        "id": 135497650,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539117932
    },
    {
        "content": "<p>the first one (\"add to set\") would occur while we are visiting the high-precedence pattern</p>",
        "id": 135497659,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539117946
    },
    {
        "content": "<p>the problem is that when we are visiting the paren (the child of the high-precedence pattern) we don't know anymore what its parent was</p>",
        "id": 135497716,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539117972
    },
    {
        "content": "<p>also, the helpers we introducd are fine, but since we don't need to control the walk anymore, the \"is low-precedence\" helper can just return a boolean</p>",
        "id": 135497730,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539117990
    },
    {
        "content": "<p>Great I'll work on those adjustments. Thank you for the clarifications in this.</p>\n<p>I can work towards this so that there is a working implementation, but is the other option you mentioned in the PR after discussion with @manishearth something you'd like to still consider?</p>",
        "id": 135498236,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539118451
    },
    {
        "content": "<p>I see the appeal if that allows a solution to to be implemented without adding a mutable set to <code>struct UnusedParens</code></p>",
        "id": 135498261,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539118496
    },
    {
        "content": "<p>Also... to bring up an old point I was trying to explain earlier, I'm having a hard time making a test case that actually compiles. Essentially it would be a pattern of the form <code>&amp;(expr ..= expr) =&gt; {}</code> in a match.</p>\n<p><code>expr</code> should be something like <code>&amp;1</code> or <code>(1+1)</code></p>",
        "id": 135498439,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539118683
    },
    {
        "content": "<p>I'll make a playground link one moment</p>",
        "id": 135498460,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539118702
    },
    {
        "content": "<blockquote>\n<p>I see the appeal if that allows a solution to to be implemented without adding a mutable set to <code>struct UnusedParens</code></p>\n</blockquote>\n<p>@manishearth felt that the mutable set was superior</p>",
        "id": 135498585,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118816
    },
    {
        "content": "<p>it's more performant, for one thing, since it allows us to have all active lints visit each node as we walk</p>",
        "id": 135498595,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118835
    },
    {
        "content": "<p>versus walking many times, once per lint</p>",
        "id": 135498600,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118839
    },
    {
        "content": "<p>I'm not sure how much that matters, really</p>",
        "id": 135498603,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118844
    },
    {
        "content": "<p>one question I guess is \"what does the expr code do here\"</p>",
        "id": 135498631,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118869
    },
    {
        "content": "<p>my guess is that it is simply not as precise as it could be</p>",
        "id": 135498635,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118874
    },
    {
        "content": "<p>b/c I don't see how you could get the right answers</p>",
        "id": 135498643,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118889
    },
    {
        "content": "<p>without doing a similar scheme</p>",
        "id": 135498646,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118892
    },
    {
        "content": "<p>hypothesis confirmed:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>gets no warnings</p>",
        "id": 135498662,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118916
    },
    {
        "content": "<p>I am not convinced this is bad</p>",
        "id": 135498667,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118920
    },
    {
        "content": "<p>that is, another option would be for us to just give less lints :)</p>",
        "id": 135498711,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118927
    },
    {
        "content": "<p>I guess I don't remember what the real motivation was here</p>",
        "id": 135498728,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118957
    },
    {
        "content": "<p>:)</p>",
        "id": 135498737,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118968
    },
    {
        "content": "<p>that is, I don't know whether it is the \"mission statement\" of unused parens to be as precise as possible, or just capture certain silly patterns</p>",
        "id": 135498754,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539118987
    },
    {
        "content": "<blockquote>\n<p>I am not convinced this is bad</p>\n</blockquote>\n<p>in particular, I know that many people add extra parens to things like <code>(A &amp;&amp; B) || C</code> because they don't care to memorize the precedence</p>",
        "id": 135498779,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119019
    },
    {
        "content": "<p>and it's hard to argue with that...</p>",
        "id": 135498784,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119027
    },
    {
        "content": "<p>Yes I agree the additional paren linting would be issuing warnings on patterns that are already complicated looking based off the predicates that have to be satisfied for <code>paren</code> to be necessary</p>",
        "id": 135499011,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119211
    },
    {
        "content": "<p>(The parsing stuff I was talking about earlier is demonstrated here: <a href=\"https://play.rust-lang.org/?gist=4e7a62b619c2f8bdd8c4ddac6898561f&amp;version=stable&amp;mode=debug&amp;edition=2015\" target=\"_blank\" title=\"https://play.rust-lang.org/?gist=4e7a62b619c2f8bdd8c4ddac6898561f&amp;version=stable&amp;mode=debug&amp;edition=2015\">https://play.rust-lang.org/?gist=4e7a62b619c2f8bdd8c4ddac6898561f&amp;version=stable&amp;mode=debug&amp;edition=2015</a>)</p>",
        "id": 135499034,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119228
    },
    {
        "content": "<p>I'm happy to take this as far as linting should be. I picked this up as my first issue and have learned a lot from it already</p>",
        "id": 135499142,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119330
    },
    {
        "content": "<p>:)</p>",
        "id": 135499148,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119341
    },
    {
        "content": "<p>maybe we should leave some comments on the issue</p>",
        "id": 135499159,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119347
    },
    {
        "content": "<p>I think that to be most analogous to the existing lint</p>",
        "id": 135499177,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119364
    },
    {
        "content": "<p>If you want to see how aggressive the paren lints seem with the above implemented, I can do that. I also think the original implementation is just helpful enough as well.</p>",
        "id": 135499185,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119371
    },
    {
        "content": "<p>we might <em>only</em> warn in the case where the <em>outermost</em> pattern has parens</p>",
        "id": 135499187,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119372
    },
    {
        "content": "<p>that I think is how expressions work</p>",
        "id": 135499193,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119377
    },
    {
        "content": "<p>e.g. <code>if (expr) { .. }</code> warns</p>",
        "id": 135499200,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119383
    },
    {
        "content": "<p>but <code>if (1 * 2) + 3 { .. }</code> does not, even though the parens are equally unnecessary</p>",
        "id": 135499213,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119397
    },
    {
        "content": "<p>honestly I think this was more about nudging people away from C/Java style</p>",
        "id": 135499262,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119410
    },
    {
        "content": "<p>It incorrectly warns though as well in expressions</p>",
        "id": 135499286,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119435
    },
    {
        "content": "<p>I believe there is an open issue on that</p>",
        "id": 135499303,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119447
    },
    {
        "content": "<p>define incorrect?</p>",
        "id": 135499341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119479
    },
    {
        "content": "<p>there is a pending PR I saw about changing how expressions work in at least some cases</p>",
        "id": 135499349,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119488
    },
    {
        "content": "<p>maybe related</p>",
        "id": 135499352,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119490
    },
    {
        "content": "<p>Looks like it's currently being worked on: <a href=\"https://github.com/rust-lang/rust/issues/54704\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/54704\">https://github.com/rust-lang/rust/issues/54704</a></p>",
        "id": 135499359,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119501
    },
    {
        "content": "<p>ah yes</p>",
        "id": 135499443,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119541
    },
    {
        "content": "<p>(there is a pending attempt to fix this that I was supposed to review)</p>",
        "id": 135499454,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119551
    },
    {
        "content": "<p>If you look at the test cases I originally added, I do think the cases that are covered are generally what I would expect from a lint. It covers outer parens, but inner parens as well in a not very obtrusive way (mostly just by avoiding the <code>Range</code> cases)</p>",
        "id": 135499608,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119699
    },
    {
        "content": "<p>yeah, I guess that's reasonable</p>",
        "id": 135499746,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119824
    },
    {
        "content": "<p>maybe we should just go back to that :)</p>",
        "id": 135499752,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119826
    },
    {
        "content": "<p>and consider this little diversion a \"learning exercise\"</p>",
        "id": 135499754,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119831
    },
    {
        "content": "<p>I can add some of this conversation back to GH, but I also don't know where we stand exactly. I can add the mutable state and see what it looks like? I can keep it how it is. Or I can make it even less and just warn on the outer parens (which still may require then knowing <em>where</em> we are at in the pattern)</p>",
        "id": 135499757,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539119836
    },
    {
        "content": "<p>I think I would add a note to the GH issue like:</p>\n<p>We decided not to try and get more precise (maybe give an example where we don't warn but parens are not needed) since it would complicate the lint and expressions are also not this precise.</p>",
        "id": 135499851,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119927
    },
    {
        "content": "<p>I think the old behavior was just not to warn on parens that wrap a range?</p>",
        "id": 135499858,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119938
    },
    {
        "content": "<p>(unless they are at the top-level, perhaps?)</p>",
        "id": 135499867,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119944
    },
    {
        "content": "<p>in that case, you could give an example like <code>((a ..= b), (a ..= b))</code> as a pattern that \"could warn\" but doesn't</p>",
        "id": 135499881,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119970
    },
    {
        "content": "<p>seems pretty obscure</p>",
        "id": 135499884,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539119978
    },
    {
        "content": "<p>Yes correct. How it was before adding the high/low precedence stuff it would not warn on the pattern above.</p>",
        "id": 135500053,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539120161
    },
    {
        "content": "<p>I think this set of my test cases is a pretty reasonable expectation of lints</p>\n<div class=\"codehilite\"><pre><span></span>match &amp;1 {\n        (e @ &amp;(1...2)) =&gt; {} //~ WARNING: unnecessary parentheses around outer pattern\n        &amp;(_) =&gt; {}           //~ WARNING: unnecessary parentheses around pattern\n        e @ &amp;(1...2) =&gt; {}   // Ambiguous range pattern should not warn\n        &amp;(1..=2) =&gt; {}       // Ambiguous range pattern should not warn\n    }\n</pre></div>",
        "id": 135500072,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539120180
    },
    {
        "content": "<p>ok, let's go back to the old way :)</p>",
        "id": 135500375,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539120471
    },
    {
        "content": "<p>and just add some notes on the uncovered cases</p>",
        "id": 135500418,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539120485
    },
    {
        "content": "<p>Ok sounds good. I'll remove the most recent commit and add some comments for uncovered cases in the <code>check_pat</code> method. I won't be able to make those changes until I'm home tonight. I'll make sure it's good to go for a final review by end of day though!</p>",
        "id": 135500582,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539120642
    },
    {
        "content": "<p>great! :)</p>",
        "id": 135500718,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539120790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Knowing my next commit will most likely be the final one for this PR, the PR will contain 5 (4 after I remove the last, +1 with adding comments for uncovered cases). Is there a preference that I squash them or will that be covered upon a merge/approval by you?</p>",
        "id": 135504066,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539124754
    },
    {
        "content": "<p>Can't really find any preference for that noted in contributing guidelines.</p>",
        "id": 135504093,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539124790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119335\">@kleimkuhler</span>: generally, reviewers tend not to be too fussy, but if each commit is approximately a unit, that's preferable</p>",
        "id": 135504382,
        "sender_full_name": "varkor",
        "timestamp": 1539125102
    },
    {
        "content": "<p>Great sounds good, thanks!</p>",
        "id": 135504407,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539125137
    },
    {
        "content": "<p>it's mainly the long chains of \"fix typo\"-style commits that get annoying if they're left unsquashed <span class=\"emoji emoji-1f601\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 135504414,
        "sender_full_name": "varkor",
        "timestamp": 1539125149
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Hey since you picked this up more as a mentor issue and it's good to go, want me to switch the reviewer to anyone else? It's been ready to go for a few days, but I can take it off your plate since it's small if you'd prefer that.</p>",
        "id": 135844612,
        "sender_full_name": "kleimkuhler",
        "timestamp": 1539623198
    },
    {
        "content": "<p>no problem, I'll r+, I haven't done my \"PR sweep\" for the day though</p>",
        "id": 135844741,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1539623376
    }
]