[
    {
        "content": "<p>Hey compiler team!</p>\n<p>We've had this issue open for a  while now: <a href=\"https://github.com/rust-lang/rust/issues/71359\">https://github.com/rust-lang/rust/issues/71359</a></p>\n<p>It's about how changes in the complexity of standard library types can cause a <code>overflow representing the type</code> error for users. This isn't really a part of the stable public api we watch for, but it does affect end users. Any ideas on what to do with this? Breaking people is not  great, but increasing the default limit every time is also not a great solution.</p>",
        "id": 249126680,
        "sender_full_name": "Mara",
        "timestamp": 1628696902
    },
    {
        "content": "<p>I don't see how there's any way to fix this, really :/ at least not without completely removing the recursion limit</p>",
        "id": 249133574,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1628699790
    },
    {
        "content": "<p>I guess the compiler could special-case certain types in libstd to raise the limit just for them? but that seems hacky and prone to error</p>",
        "id": 249133629,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1628699824
    },
    {
        "content": "<p>A recursion limit that is per-crate - types from that crate contribute to a counter which fires at that crate's recursion limit - (with a minimum set by the currently compiling crate) may allow us to bump the limit locally to std, at least.</p>",
        "id": 249134645,
        "sender_full_name": "simulacrum",
        "timestamp": 1628700310
    },
    {
        "content": "<p>A harder solution is to try to redesign the code to avoid a hard limit and instead try to detect progress somehow. Not possible in general, but seems like it could eliminate common cases.</p>",
        "id": 249134796,
        "sender_full_name": "simulacrum",
        "timestamp": 1628700374
    },
    {
        "content": "<p>What about a dynamic limit? You get extra budget for each method call that's processed. That allows n + c type length growth but prevents n^c or worse</p>",
        "id": 249138003,
        "sender_full_name": "The 8472",
        "timestamp": 1628701805
    }
]