[
    {
        "content": "<p>Hi, not sure if <a class=\"stream\" data-stream-id=\"257204\" href=\"/#narrow/stream/257204-project-error-handling\">#project-error-handling</a> or <a class=\"stream\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler\">#t-compiler</a> is the best place for this, I'm quite new here.</p>\n<p>I am experimenting with <code>#[feature(try_trait_v2)]</code> to write a new <code>Result</code> type. It uses <code>#[track_caller]</code> and <code>FromResidual</code> to automatically append the location of every <code>?</code> invocation to a running stack trace.</p>\n<p>My experiments have been a success, but I'm very bummed that I cannot retrieve the <em>function name</em> of the caller from a <code>panic::Location</code>. Having <code>file</code> and <code>line</code> is workable, but having <code>function</code> as well would be pretty damn sweet.</p>\n<p>I'd like to ask the community for its opinion on adding the ability to get the caller's function name from <code>#[track_caller]</code>/<code>panic::Location</code>, at least optionally.</p>\n<p>There would obviously be code size concerns, so I think a compiler option similar to the <code>-Z location-detail</code> option mentioned <a href=\"https://github.com/rust-lang/rust/issues/70580\">here</a> would be good.</p>\n<p>I'd be willing to take a stab at a very rough POC for this. I skimmed through the compiler code and noticed that the <code>caller_location</code> and <code>type_name</code> intrinsics are already very close together, almost begging to be paired up <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> </p>\n<p>What's the process for getting the ball rolling on this if people are generally not opposed to the idea? I was going to make an issue, but GitHub suggested that feature requests should go to the forums.</p>",
        "id": 250883323,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1630040097
    },
    {
        "content": "<p>It'll actually be very helpful for rust-for-linux if we can get the function name from <code>Location</code> and the function name is terminated with a <code>\\0</code>. There are many C code in the kernel that expects a function name string when called (aka. poor man's track caller <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>).</p>",
        "id": 250911775,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630060312
    },
    {
        "content": "<p>Another even more powerful extension to track caller would be add a state to it, e.g. <code>AtomicUsize</code>. Kernel has a dead-lock detection called lockdep. It requires a <code>static</code> state at the callsite that creates a mutex. In C it's all wrapped in a macro so user just calls <code>mutex_init</code> but rust-for-linux has to implement it as a macro. If a <code>Location</code> has a state it would also such function to be implemented as a function as well.</p>",
        "id": 250912435,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630060702
    },
    {
        "content": "<p>not everything in rust that can call is a \"function\" per se.</p>",
        "id": 250931587,
        "sender_full_name": "nagisa",
        "timestamp": 1630071041
    },
    {
        "content": "<p>0 termination is a different matter altogether as well.</p>",
        "id": 250931661,
        "sender_full_name": "nagisa",
        "timestamp": 1630071073
    },
    {
        "content": "<p>I don't think it would be a huge deal to add a terminating null, but guaranteeing that would be a different matter.</p>",
        "id": 250932788,
        "sender_full_name": "nagisa",
        "timestamp": 1630071577
    },
    {
        "content": "<p>because the current APIs return regular rust slices, and its probably not a great design to say \"hey we return this, but you can also find a null byte after so feel free to use this for your c needs\"</p>",
        "id": 250932973,
        "sender_full_name": "nagisa",
        "timestamp": 1630071640
    },
    {
        "content": "<p>I kinda want to say that I wanted function names in the past too sometimes, but in practice I find that module name, line and filename are sufficient enough to me. And I hack on tracing stuff a lot.</p>",
        "id": 250933246,
        "sender_full_name": "nagisa",
        "timestamp": 1630071758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/131828-t-compiler/topic/function.20names.20in.20.60.23.5Btrack_caller.5D.60/near/250933246\">said</a>:</p>\n<blockquote>\n<p>I kinda want to say that I wanted function names in the past too sometimes, but in practice I find that module name, line and filename are sufficient enough to me. And I hack on tracing stuff a lot.</p>\n</blockquote>\n<p>File name and line number is sufficient for diagnosing problems, but it makes the process slower as a human. Often I can get a very good idea about the root cause of an error just by looking at a backtrace that has all the function names. Without function names, I'd have to go digging through code to even form an idea of what's going wrong.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/131828-t-compiler/topic/function.20names.20in.20.60.23.5Btrack_caller.5D.60/near/250931587\">said</a>:</p>\n<blockquote>\n<p>not everything in rust that can call is a \"function\" per se.</p>\n</blockquote>\n<p>True, but I think everything in Rust that can call has a useful representation from the <code>type_name</code> intrinsic. See <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2015&amp;gist=df5975cd589ae7286a769e1c70e7715d\">this playground demo</a>.</p>",
        "id": 250975378,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1630089361
    },
    {
        "content": "<p>I think the point is that some types have non-useful names: closures and generators are printed without differentiation or with their location and nothing else. impl Trait types have similar issues. But I agree that these names might be <em>good enough</em>.</p>",
        "id": 254569571,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1632416750
    }
]