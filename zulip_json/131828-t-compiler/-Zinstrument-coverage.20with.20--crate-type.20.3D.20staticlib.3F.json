[
    {
        "content": "<p>Hey, folks. Where's the best place to ask questions about -Zinstrument-coverage?</p>\n<p>I'm trying to run code coverage for a Windows DLL, which contains a mixture of Rust code and C++ code. The Rust code is compiled using <code>--crate-type staticlib</code>, and the C++ code references symbols exported by the Rust code using <code>#[no_mangle]</code> and similar.  All of this works fine (when not compiling with -Zinstrument-coverage).</p>\n<p>When compiling with <code>RUSTFLAGS=-Zinstrument-coverage</code>, though, the DLL fails to link, because it cannot resolve the symbol <code>__llvm_profile_runtime</code>. It looks like this symbol is defined in <code>libprofiler_runtime-XXXXX.rlib</code>, which seems reasonable. However, that symbol is _not_ carried over to the static lib generated by Rustc / Cargo, so it fails to be resolved at link time.  I'm guessing that this symbol is defined by C/C++ code, which is why it isn't being implicitly carried over to the static lib generated by Rust.</p>\n<p>Is there a reasonable solution to this?  I sorta understand why it's happening, but I don't see any obvious great solution.</p>",
        "id": 239181406,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621298905
    },
    {
        "content": "<p>This seems a good place to ask such questions :) but I believe it'll be best to mention <span class=\"user-mention\" data-user-id=\"296355\">@Rich Kadel</span> or <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span>, as the primary author and reviewer of that work, they'll be the most able to answer them</p>",
        "id": 239229003,
        "sender_full_name": "lqd",
        "timestamp": 1621332841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"274471\">@Arlie Davis</span> can you throw <code>libprofiler_runtime-XXXXX.rlib</code> on the linker line and see what happens?</p>",
        "id": 239344704,
        "sender_full_name": "tmandry",
        "timestamp": 1621382704
    },
    {
        "content": "<p>(<code>rlib</code>s are just static lib archives with extra files, I think some linkers at least let you add them directly)</p>",
        "id": 239344804,
        "sender_full_name": "tmandry",
        "timestamp": 1621382782
    },
    {
        "content": "<p>I think I tried that, and I think it works. But it's not much of a solution, because it requires knowing the path to the libstd install, as well as the -XXX hash part of the filename.</p>",
        "id": 239344960,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621382908
    },
    {
        "content": "<p>yeah. of course normally rustc would do this for you, but since you're building a staticlib it doesn't control linking anymore</p>",
        "id": 239345027,
        "sender_full_name": "tmandry",
        "timestamp": 1621382950
    },
    {
        "content": "<p>Right.  For Rust code, that's fine because rustc pulls in all of the dependent (Rust) code into the static lib file. But it apparently doesn't do the same for non-Rust code that is packaged in upstream .rlib files.</p>",
        "id": 239345059,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621382999
    },
    {
        "content": "<p>yeah, and I'm unclear on whether rustc actually considers this to be a dependency</p>",
        "id": 239345203,
        "sender_full_name": "tmandry",
        "timestamp": 1621383084
    },
    {
        "content": "<p>so generally the lib will be in <code>$(rustc --print=sysroot)/lib/rustlib/$TARGET_TRIPLE/lib</code></p>",
        "id": 239345227,
        "sender_full_name": "tmandry",
        "timestamp": 1621383101
    },
    {
        "content": "<p>the <code>--print=sysroot</code> thing you can rely on always being there. the exact path I'm not sure about</p>",
        "id": 239345323,
        "sender_full_name": "tmandry",
        "timestamp": 1621383151
    },
    {
        "content": "<p>it's not clear to me that bundling the profiler runtime into a staticlib binary would be <em>correct</em>, since you might end up with duplicate symbols if you try linking multiple instrumented staticlibs</p>",
        "id": 239345394,
        "sender_full_name": "tmandry",
        "timestamp": 1621383235
    },
    {
        "content": "<p>I think you're already in trouble if you try to link multiple staticlibs, because they already contain duplicated copies of libstd and friends.</p>",
        "id": 239345448,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383263
    },
    {
        "content": "<p>Basically, you get one Rust staticlib per link invocation.</p>",
        "id": 239345461,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383277
    },
    {
        "content": "<p>oh really..</p>",
        "id": 239345490,
        "sender_full_name": "tmandry",
        "timestamp": 1621383295
    },
    {
        "content": "<p>(you can work around issues like this with weak symbols, but you have to <em>know</em> that every definition is the same)</p>",
        "id": 239345538,
        "sender_full_name": "tmandry",
        "timestamp": 1621383336
    },
    {
        "content": "<p>Yeah, that's not really a path I want to go down. My team has already accepted the constraint of \"1 Rust staticlib per module\".  Also, weak symbols are a platform-specific concept; Win32 / PE has no such concept, so it just fails.</p>",
        "id": 239345604,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383383
    },
    {
        "content": "<p>so, clang solves this with an option that can print the path to any library it ships with</p>",
        "id": 239345679,
        "sender_full_name": "tmandry",
        "timestamp": 1621383472
    },
    {
        "content": "<p>Verified, manually linking against libprofiler_builtins works.</p>",
        "id": 239345722,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383490
    },
    {
        "content": "<p>so you can say e.g. <code>clang --target=foo -print-file-name=libunwind.so</code> and it will give you the path for that target</p>",
        "id": 239345797,
        "sender_full_name": "tmandry",
        "timestamp": 1621383597
    },
    {
        "content": "<p>I think the best way to solve this would be with a flag like that</p>",
        "id": 239345849,
        "sender_full_name": "tmandry",
        "timestamp": 1621383619
    },
    {
        "content": "<p>bundling into the staticlib might work, but it could become a problem for anyone doing cross-language instrumentation</p>",
        "id": 239345936,
        "sender_full_name": "tmandry",
        "timestamp": 1621383681
    },
    {
        "content": "<p>That seems reasonable. Do you know whether <code>__llvm_profile_runtime</code> is implemented in C/C++ or Rust?  I could just link directly against the appropriate LLVM library.</p>",
        "id": 239345937,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383686
    },
    {
        "content": "<p>ah so I think it is implemented in C/C++</p>",
        "id": 239345947,
        "sender_full_name": "tmandry",
        "timestamp": 1621383702
    },
    {
        "content": "<p>but you're allowed to override it, according to <a href=\"https://clang.llvm.org/docs/SourceBasedCodeCoverage.html#id10\">these docs</a></p>",
        "id": 239345962,
        "sender_full_name": "tmandry",
        "timestamp": 1621383722
    },
    {
        "content": "<p>That's what I was guessing.  It might be sufficient to provide a copy of the LLVM static lib, outside of <code>libprofiler_runtime-XXX.rlib</code>, for situations like this.</p>",
        "id": 239346020,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383741
    },
    {
        "content": "<p>yeah, I'm trying to remember if the rlib is just a repackaging of that</p>",
        "id": 239346052,
        "sender_full_name": "tmandry",
        "timestamp": 1621383791
    },
    {
        "content": "<p>If the path I need to build is just <code>$TOOLCHAIN/$TRIPLE/libllvm_profile_runtime.lib</code> or some such, then that would work for me.</p>",
        "id": 239346055,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383792
    },
    {
        "content": "<p>I'm guessing that whatever part of <code>libprofiler_runtime</code> is in Rust, is already being packaged into the static lib, and it's only the C/C++ part that isn't.</p>",
        "id": 239346084,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621383822
    },
    {
        "content": "<p>yeah <a href=\"https://github.com/rust-lang/rust/blob/master/library/profiler_builtins/build.rs\">it is</a></p>",
        "id": 239346183,
        "sender_full_name": "tmandry",
        "timestamp": 1621383901
    },
    {
        "content": "<p>there is actually no Rust code in that library at all</p>",
        "id": 239346232,
        "sender_full_name": "tmandry",
        "timestamp": 1621383927
    },
    {
        "content": "<p>Neat.</p>",
        "id": 239346336,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621384004
    },
    {
        "content": "<p>I'm not sure if LLVM doesn't export a lib target for this, or if Rust is intentionally building a subset to save space, or what</p>",
        "id": 239346375,
        "sender_full_name": "tmandry",
        "timestamp": 1621384049
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>link /dump /symbols c:\\llvm\\lib\\clang\\11.0.0\\lib\\windows\\clang_rt.profile-x86_64.lib | findstr llvm_profile_runtime\n</code></pre></div>\n<p>Looks like it's here.</p>",
        "id": 239346534,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621384191
    },
    {
        "content": "<p>I guess I could link to that.  I feel a bit queasy about using version $FOO of rustc, and version $BAR of LLVM, though.</p>",
        "id": 239346603,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621384227
    },
    {
        "content": "<p>There's another problem, though. If you compile a Rust library with <code>--crate-type cdylib -Z instrument-coverage</code>, and run something that uses that DLL, it does generate a coverage file. However, when I run llvm-cov and point it at the DLL, it says that it can't find any coverage data in it.</p>",
        "id": 239347845,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1621385255
    }
]