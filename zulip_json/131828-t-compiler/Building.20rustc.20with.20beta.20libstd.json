[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> do you think <code>build --stage 0 compiler/rustc</code> <em>without</em> depending on <code>build --stage 0 library/std</code> makes sense as a goal? And if so, do you mind if I open a tracking issue/MCP?</p>",
        "id": 209899890,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944612
    },
    {
        "content": "<p>that would cut down on compile times too (maybe not a ton, but significantly)</p>",
        "id": 209899943,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944663
    },
    {
        "content": "<p>It would cut compile times by like a minute or two?</p>",
        "id": 209899948,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944687
    },
    {
        "content": "<p>right</p>",
        "id": 209899950,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944696
    },
    {
        "content": "<p>At least for me building std takes less than a minute</p>",
        "id": 209899952,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944700
    },
    {
        "content": "<p>that's not the <em>primary</em> focus of doing this but it seems like an easy improvement</p>",
        "id": 209899959,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944723
    },
    {
        "content": "<p>(for some definition of easy)</p>",
        "id": 209899965,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944741
    },
    {
        "content": "<p>I don't think it's feasible though - we lose all of the advantages of rustc having a dependable std</p>",
        "id": 209899967,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944754
    },
    {
        "content": "<p>What do you mean by dependable std?</p>",
        "id": 209900015,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944782
    },
    {
        "content": "<p>Currently rustc only supports one std</p>",
        "id": 209900019,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944796
    },
    {
        "content": "<p>That's great, makes things much easier</p>",
        "id": 209900023,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944804
    },
    {
        "content": "<p>it sounds like you're talking about only supporting <em>building</em> one std</p>",
        "id": 209900036,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944833
    },
    {
        "content": "<p>and I want to be able to <em>use</em> (link to) beta std</p>",
        "id": 209900047,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944852
    },
    {
        "content": "<p>I agree being able to compile beta std with master rustc is a non-goal</p>",
        "id": 209900054,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944870
    },
    {
        "content": "<p>No, I'm saying that rustc only supports linking to one std and that makes things much easier because rustc can just immediately start using unstable features as they get added</p>",
        "id": 209900100,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944890
    },
    {
        "content": "<blockquote>\n<p>rustc can just immediately start using unstable features as they get added</p>\n</blockquote>\n<p>that's nice, but is it worth the confusion and compile times? rustc can still use the features 6 weeks later on beta promotion</p>",
        "id": 209900113,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944948
    },
    {
        "content": "<p>Adding even more cfg bootstrap seems like a regression</p>",
        "id": 209900116,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944952
    },
    {
        "content": "<p>this is the same way that libstd can't depend on stage1 rustdoc and has to work with beta too</p>",
        "id": 209900119,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944963
    },
    {
        "content": "<p>And this proposal requires that</p>",
        "id": 209900121,
        "sender_full_name": "simulacrum",
        "timestamp": 1599944965
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/131828-t-compiler/topic/improving.20bootstrap.20times.20for.20contributor.20fun.20and.20profit/near/209900116\">said</a>:</p>\n<blockquote>\n<p>Adding even more cfg bootstrap seems like a regression</p>\n</blockquote>\n<p>I'm proposing <em>less</em> cfg bootstrap</p>",
        "id": 209900122,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944975
    },
    {
        "content": "<p>like, after 1.48 gets promoted and you remove all the cfgs, just never adding them back</p>",
        "id": 209900129,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599944993
    },
    {
        "content": "<p>No, or at least I don't see how. Both std and rustc will be full of cfg bootstrap</p>",
        "id": 209900134,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945000
    },
    {
        "content": "<p>let me say this a little differently maybe</p>",
        "id": 209900185,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945049
    },
    {
        "content": "<p>the reason cfg(bootstrap) has to exist at all is because rustc and std interact with each other, right? they have to have the same lang items, builtin macros, and so on</p>",
        "id": 209900195,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945078
    },
    {
        "content": "<p>in stage 0 the compiler would link to beta std, in stage 1 to master std, ergo, you end up with cfg(bootstrap) in the compiler</p>",
        "id": 209900197,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945085
    },
    {
        "content": "<p>that's the <em>current reason</em></p>",
        "id": 209900199,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945097
    },
    {
        "content": "<p>but if we end up with rustc linking to different stds, you gain another reason -- the thing you're using in std has changed APIs</p>",
        "id": 209900200,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945116
    },
    {
        "content": "<p>currently when that change happens we just update the compiler and we're good</p>",
        "id": 209900241,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945128
    },
    {
        "content": "<p>but here we'd need to maintain two copies, one using old API and one using new API</p>",
        "id": 209900250,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945145
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/131828-t-compiler/topic/improving.20bootstrap.20times.20for.20contributor.20fun.20and.20profit/near/209900200\">said</a>:</p>\n<blockquote>\n<p>but if we end up with rustc linking to different stds, you gain another reason -- the thing you're using in std has changed APIs</p>\n</blockquote>\n<p>not if it doesn't use unstable features! that's the really big change I'm proposing, is not <em>needing</em> to use any APIs that might change</p>",
        "id": 209900251,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945145
    },
    {
        "content": "<p>which maybe is not super feasible right now</p>",
        "id": 209900258,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945164
    },
    {
        "content": "<p>IMO saying \"rustc does not use unstable libs features\" is not going to fly right now</p>",
        "id": 209900261,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945167
    },
    {
        "content": "<p>like, at that point we might as well push for compiler being a stable-compatible tool, which sure, is <em>feasible</em> to do eventually, but I think not right now, and maybe shouldn't be a goal</p>",
        "id": 209900276,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945202
    },
    {
        "content": "<p>even with aggressively bumped MSRV</p>",
        "id": 209900282,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945218
    },
    {
        "content": "<p>that said, there should be no reason to actually want this</p>",
        "id": 209900330,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945277
    },
    {
        "content": "<p>in practice the solution to fast local builds is just \"bring your own master std\"</p>",
        "id": 209900332,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945287
    },
    {
        "content": "<p>(and master compiler)</p>",
        "id": 209900337,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945296
    },
    {
        "content": "<p>which means rebasing -&gt; re-download compiler + std, but that's not horrible</p>",
        "id": 209900346,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945315
    },
    {
        "content": "<p>and we could maybe get away with just redownloading std with some interesting gymnastics</p>",
        "id": 209900352,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945337
    },
    {
        "content": "<p>so, I agree this might be more work than it's worth right now, <em>but</em> one of the other benefits to this is no more <code>cfg(bootstrap)</code> in libstd: it <em>only</em> has to compile with master rustc, not with beta</p>",
        "id": 209900393,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945363
    },
    {
        "content": "<p>since you no longer need it for compiling rustc itself</p>",
        "id": 209900399,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945375
    },
    {
        "content": "<p>since I'm not volunteering to put in the work ;) I'm fine with saying 'the project doesn't have time for this right now', but does this make sense as a goal?</p>",
        "id": 209900418,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945422
    },
    {
        "content": "<p>it would be a lot simpler than the current situation IMO</p>",
        "id": 209900455,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945483
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> btw, it's your blog post that sparked all this <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 209900489,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945534
    },
    {
        "content": "<p>I don't think it makes sense personally</p>",
        "id": 209900654,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945770
    },
    {
        "content": "<p>cfg(bootstrap) is much easier to understand in std than in rustc, IMO, because in std it's usually basically \"this function/impl\" doesn't exist</p>",
        "id": 209900664,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945794
    },
    {
        "content": "<p>vs. \"in the middle of complicated logic, there are now two copies of a function call doing some sort of interesting algorithmic detail\"</p>",
        "id": 209900671,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945821
    },
    {
        "content": "<p>The end goal is 'no cfg(bootstrap)', not 'move cfg(bootstrap) to rustc', I agree the second is definitely not worth it</p>",
        "id": 209900716,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945875
    },
    {
        "content": "<p>Anyway, maybe this is just idle speculation</p>",
        "id": 209900735,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945916
    },
    {
        "content": "<p>I think the x.py changes are more likely to make things easier in the short term</p>",
        "id": 209900742,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599945935
    },
    {
        "content": "<p>That end goal is only feasible with \"rustc compiles on stable\" I think</p>",
        "id": 209900744,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945938
    },
    {
        "content": "<p>and though that's true-ish already today -- rustc can't use new language features -- rustc <em>can</em> use library features and that's helpful</p>",
        "id": 209900797,
        "sender_full_name": "simulacrum",
        "timestamp": 1599945992
    },
    {
        "content": "<p>the dogfooding with library features and older language features has historically been really useful</p>",
        "id": 209900804,
        "sender_full_name": "simulacrum",
        "timestamp": 1599946017
    },
    {
        "content": "<p>It would still be possible to dogfood, you'd just have to wait 6 weeks</p>",
        "id": 209900875,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946131
    },
    {
        "content": "<p>sure, I guess</p>",
        "id": 209900889,
        "sender_full_name": "simulacrum",
        "timestamp": 1599946164
    },
    {
        "content": "<p>I'm not at all proposing that we remove RUSTC_BOOTSTRAP</p>",
        "id": 209900896,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946179
    },
    {
        "content": "<p>but not if you wanted to avoid:</p>\n<blockquote>\n<p>vs. \"in the middle of complicated logic, there are now two copies of a function call doing some sort of interesting algorithmic detail\"</p>\n</blockquote>",
        "id": 209900897,
        "sender_full_name": "simulacrum",
        "timestamp": 1599946182
    },
    {
        "content": "<p>maybe I'm over promoting that point, I don't know how often it would happen in practice</p>",
        "id": 209900951,
        "sender_full_name": "simulacrum",
        "timestamp": 1599946216
    },
    {
        "content": "<p>I'm not sure how that would come up if rustc compiled with beta</p>",
        "id": 209900961,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946251
    },
    {
        "content": "<p>well, you'd have something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>// ...\n#[cfg(bootstrap)]\nvec.retain(|x| x != y);\n#[cfg(not(bootstrap))]\nvec.drain_filter(|x| x == y);\n//...\n</code></pre></div>",
        "id": 209901031,
        "sender_full_name": "simulacrum",
        "timestamp": 1599946327
    },
    {
        "content": "<p>Oh I see - I was suggesting to just not have the second version</p>",
        "id": 209901034,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946351
    },
    {
        "content": "<p>I mean if the API changed... you have no choice?</p>",
        "id": 209901039,
        "sender_full_name": "simulacrum",
        "timestamp": 1599946364
    },
    {
        "content": "<p>because you need to compile with beta std and master std</p>",
        "id": 209901043,
        "sender_full_name": "simulacrum",
        "timestamp": 1599946372
    },
    {
        "content": "<p>Right, <code>retain</code> would work with both</p>",
        "id": 209901047,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946390
    },
    {
        "content": "<p>And if you want to keep dogfooding, then wait to use drain_filter until beta has it (which it does currently)</p>",
        "id": 209901127,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946512
    },
    {
        "content": "<p>let me clarify: I don't think rustc needs to compile on stable, I think it would be nice to compile on beta <em>with RUSTC_BOOTSTRAP</em></p>",
        "id": 209901164,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946697
    },
    {
        "content": "<p>which still allows using unstable features as long as they made the last beta cutoff</p>",
        "id": 209901167,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599946711
    },
    {
        "content": "<p>distro flag -- sometimes we don't have the previous rustc/std available, as we're rebuilding the current version of the package</p>",
        "id": 209901534,
        "sender_full_name": "cuviper",
        "timestamp": 1599947746
    },
    {
        "content": "<p>so \"compiler always uses beta std\" (or N-1) doesn't work</p>",
        "id": 209901574,
        "sender_full_name": "cuviper",
        "timestamp": 1599947772
    },
    {
        "content": "<p>if an unstable API changes between N-1 and N, rustc has to compile either way</p>",
        "id": 209901591,
        "sender_full_name": "cuviper",
        "timestamp": 1599947845
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/131828-t-compiler/topic/improving.20bootstrap.20times.20for.20contributor.20fun.20and.20profit/near/209901591\">said</a>:</p>\n<blockquote>\n<p>if an unstable API changes between N-1 and N, rustc has to compile either way</p>\n</blockquote>\n<p>stage1 builds stage2, so CI would catch that anyway</p>",
        "id": 209902862,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599950057
    },
    {
        "content": "<p>but that's a good point there could be changes in the unstable API - maybe have a policy that unstable features go through a release of deprecation before being removed?</p>",
        "id": 209902868,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599950090
    },
    {
        "content": "<p>that seems like a good policy anyway</p>",
        "id": 209902870,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599950095
    },
    {
        "content": "<p>also, could someone split this into a separate topic starting from around <a href=\"#narrow/stream/131828-t-compiler/topic/improving.20bootstrap.20times.20for.20contributor.20fun.20and.20profit/near/209899890\">https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler/topic/improving.20bootstrap.20times.20for.20contributor.20fun.20and.20profit/near/209899890</a> ? maybe named 'building rustc from beta libstd'</p>",
        "id": 209903274,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599950923
    },
    {
        "content": "<p>oh it turns out I can do it haha</p>",
        "id": 209903281,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599950955
    },
    {
        "content": "<p>I don't think we can afford to impose changes like that on all unstable features at this stage of development, they're way too high cost</p>",
        "id": 209904294,
        "sender_full_name": "simulacrum",
        "timestamp": 1599952848
    },
    {
        "content": "<p>well, maybe we could switch the compiler to use a different (stable) API if one it's using gets changed</p>",
        "id": 209904355,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599952939
    },
    {
        "content": "<p>these are changes in the standard library so they shouldn't be too hard to work around</p>",
        "id": 209904365,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599952957
    },
    {
        "content": "<p>Especially considering you win maybe a minute or two of time at most, and that after a rebase. And a good bit of that time can be shaved off if we invested in faster std builds more than we do now</p>",
        "id": 209904368,
        "sender_full_name": "simulacrum",
        "timestamp": 1599952964
    },
    {
        "content": "<p>the main benefit I see is not really the lower compile times, but having a simpler model of x.py and being able to get rid of <code>cfg(bootstrap)</code></p>",
        "id": 209904378,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599953006
    },
    {
        "content": "<p>and like matklad mentioned in the post, maybe being able to <code>cargo build</code> rustc itself some day</p>",
        "id": 209904380,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599953032
    },
    {
        "content": "<p>I think the cost of what you suggest to standard library and compiler development is way too high</p>",
        "id": 209904382,
        "sender_full_name": "simulacrum",
        "timestamp": 1599953034
    },
    {
        "content": "<p>You can already cargo build rustc, in theory, on latest master</p>",
        "id": 209904422,
        "sender_full_name": "simulacrum",
        "timestamp": 1599953054
    },
    {
        "content": "<p>FWIW, when I was on a slow CPU, the time to build stage0 std was nowhere close to my big problem.  Now part of that was I'd use <code>--keep-stage 0</code> when changing just core/alloc/std, which I hear some people say I shouldn't, but it always worked perfectly for me.</p>",
        "id": 209905724,
        "sender_full_name": "scottmcm",
        "timestamp": 1599955294
    },
    {
        "content": "<blockquote>\n<p>part of that was I'd use --keep-stage 0</p>\n</blockquote>\n<p>another thing this would help is modifying libstd would no longer need to rebuild the whole compiler</p>",
        "id": 209906141,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599956000
    },
    {
        "content": "<p>only <code>--stage 1 library/std</code>, and it would be sound unlike --keep-stage</p>",
        "id": 209906148,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599956020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd/near/209904422\">said</a>:</p>\n<blockquote>\n<p>You can already cargo build rustc, in theory, on latest master</p>\n</blockquote>\n<p>I tried this (<code>cargo check</code> in the top-level directory) and got 190 errors about things not being Sized <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 209906191,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599956064
    },
    {
        "content": "<p>oh interesting, <code>cargo check</code> in <code>compiler/rustc</code> seems to be working though</p>",
        "id": 209906334,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599956355
    },
    {
        "content": "<p>well, if I set <code>CFG_RELEASE</code>, <code>CFG_RELEASE_CHANNEL</code>, and <code>RUSTC_INSTALL_BINDIR</code></p>",
        "id": 209906343,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599956390
    },
    {
        "content": "<p>Sized errors are just compiler being overeager, probably - it's likely really the duplicate lang items or lack of any definition or something like that</p>",
        "id": 209907337,
        "sender_full_name": "simulacrum",
        "timestamp": 1599958249
    },
    {
        "content": "<p>We are trying to synchronize the disscussion in <a href=\"https://hackmd.io/u-kT-u6PS0aGUls_7A-fUQ\">https://hackmd.io/u-kT-u6PS0aGUls_7A-fUQ</a></p>",
        "id": 209931464,
        "sender_full_name": "matklad",
        "timestamp": 1600003657
    },
    {
        "content": "<blockquote>\n<p>that's nice, but is it worth the confusion and compile times? rustc can still use the features 6 weeks later on beta promotion</p>\n</blockquote>\n<p>which confusion? and if it's about 60s of compile time <em>once</em> (as libstd does not get rebuilt when you just change rustc), then -- yes it is definitely worth it, with my regular compiler contributor hat on.</p>\n<blockquote>\n<p>so, I agree this might be more work than it's worth right now, but one of the other benefits to this is no more cfg(bootstrap) in libstd: it only has to compile with master rustc, not with beta</p>\n</blockquote>\n<p>I dont think that's true though. libstd has to still build with both beta and nightly rustc, so cfg(bootstrap) is still needed for any new lang item, new intrinsic, lint change, using a new lang feature (unless we want to wait 6 weeks before using it, which will slow down development <em>a lot</em> as we often notice problems when starting to actually use features), lang feature stabilization, ... (all the same things where it is needed now). your proposal makes it so that cfg(bootstrap) is needed <em>both</em> in libstd and rustc, instead of just in libstd like now.</p>",
        "id": 209939997,
        "sender_full_name": "RalfJ",
        "timestamp": 1600016644
    },
    {
        "content": "<p>I'm deeply anti compile time, but if we're talking about +1 minute in a build that's already <strong>tens</strong> of minutes long, probably keep things simpler and eat the extra minute. If it gets to the point where the average user has a 5 minute build and we could make it a 4 minute build, <em>then</em> consider again.</p>",
        "id": 209940509,
        "sender_full_name": "Lokathor",
        "timestamp": 1600017367
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/49119\">https://github.com/rust-lang/rust/pull/49119</a> is a past effort at doing this, I think, which received mostly positive feedback (but also seems to not address the downsides we've noted here?)</p>",
        "id": 209941152,
        "sender_full_name": "simulacrum",
        "timestamp": 1600018310
    },
    {
        "content": "<p>That changes wasn't removing <code>cfg(bootstrap)</code> from libstd</p>",
        "id": 209941724,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600019129
    },
    {
        "content": "<p>So it had a different set of tradeoffs</p>",
        "id": 209941731,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600019137
    },
    {
        "content": "<p>Maybe those were better trade-offs? Having stage0 rustc not depend on stage0 libstd still seems useful</p>",
        "id": 209941779,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600019181
    },
    {
        "content": "<blockquote>\n<p>If we're talking about +1 minute in a build that's already <strong>tens</strong> of minutes long, probably keep things simpe and eat the extra minute</p>\n</blockquote>\n<p>Again, my primary motivation is <em>not</em> the compile times, but removing the need for <code>--keep-stage 0</code> and simplifying the bootstrap model</p>",
        "id": 209942556,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600020260
    },
    {
        "content": "<p>But maybe that's not worth the tradeoffs <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 209942560,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600020282
    },
    {
        "content": "<p>\"Low information voter\" here <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>. One of the stated goals in the hackMD is removing <code>cfg(bootstrap)</code>, but it seems like the proposed change would just move it into <code>rustc</code>. Why is this better? There's an \"important note\" that seems to allude to some mitigating factors, but I don't really understand it.</p>",
        "id": 209943395,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1600021482
    },
    {
        "content": "<p>there are two different discussions going on, one about moving rustc to stable and one about moving it to beta libstd</p>",
        "id": 209943486,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021626
    },
    {
        "content": "<p>oh wait no the threads diverged again ahhh too much discussion <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 209943496,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021648
    },
    {
        "content": "<p>there are <em>three</em> different discussions going on <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 209943510,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021674
    },
    {
        "content": "<ol>\n<li>Should rustc compile on stable?</li>\n<li>Should rustc compile on beta using beta libstd? (right now it uses beta with master libstd)</li>\n<li>Should libstd compile with beta? (right now it does)</li>\n</ol>",
        "id": 209943579,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021710
    },
    {
        "content": "<p>only changing 3 allows removing <code>cfg(bootstrap)</code>, but it requires first having 2</p>",
        "id": 209943593,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021739
    },
    {
        "content": "<p>but.. (2) means introducing cfg(bootstrap) into rustc, unless its expanded to \"Should rustc compile on beta using beta libstd, by removing unstable libs feature use?\"</p>",
        "id": 209943612,
        "sender_full_name": "simulacrum",
        "timestamp": 1600021802
    },
    {
        "content": "<p>sure</p>",
        "id": 209943651,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021810
    },
    {
        "content": "<p>anyway, I'm not convinced anymore this is the right change</p>",
        "id": 209943656,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021819
    },
    {
        "content": "<p>maybe <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> has different opinions</p>",
        "id": 209943663,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600021828
    },
    {
        "content": "<p>I just mean that there's no way to remove cfg(bootstrap) that I've seen so far that isn't \"rustc just works on stable entirely\"</p>",
        "id": 209943670,
        "sender_full_name": "simulacrum",
        "timestamp": 1600021849
    },
    {
        "content": "<blockquote>\n<p>Bad: #[cfg(bootstrap)] is hard to understand, using beta compiler and master libstd is mind-bending (even some members of the compiler team were not aware this was the case)</p>\n</blockquote>\n<p>I also would like someone to elaborate on this, because both cfg(bootstrap) and the beta compiler+master std seem pretty reasonable/intuitive to me. Could someone who finds this mind-bending try to elaborate on why that is? (Maybe examples or something)?</p>",
        "id": 209943689,
        "sender_full_name": "simulacrum",
        "timestamp": 1600021910
    },
    {
        "content": "<p>like, not being aware of something and still being able to function as a compiler team member seems great, not a bad thing</p>",
        "id": 209943742,
        "sender_full_name": "simulacrum",
        "timestamp": 1600021942
    },
    {
        "content": "<p>we shouldn't expect everyone to know/understand every detail of the bootstrapping processs</p>",
        "id": 209943747,
        "sender_full_name": "simulacrum",
        "timestamp": 1600021957
    },
    {
        "content": "<p>I've seen confusion about <code>cfg(bootstrap)</code> a few times</p>",
        "id": 209943748,
        "sender_full_name": "lcnr",
        "timestamp": 1600021962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> I think I have too, but without concrete examples I don't think we can work out strategies that'll address it</p>",
        "id": 209943761,
        "sender_full_name": "simulacrum",
        "timestamp": 1600021990
    },
    {
        "content": "<p>I do think that this can be (and has been <span aria-label=\"sparkles\" class=\"emoji emoji-2728\" role=\"img\" title=\"sparkles\">:sparkles:</span> ) improved using better documentation and tools, but we can never reduce the mental burden to nothing here</p>",
        "id": 209943782,
        "sender_full_name": "lcnr",
        "timestamp": 1600022037
    },
    {
        "content": "<p>well, beyond the \"just works on stable\", but I think we have broad agreement that we're not ready for that</p>",
        "id": 209943838,
        "sender_full_name": "simulacrum",
        "timestamp": 1600022091
    },
    {
        "content": "<p>When you say \"stable\", do you mean \"latest beta with nightly features enabled\" or something else?</p>",
        "id": 209943865,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1600022157
    },
    {
        "content": "<p>well, \"beta without nightly features\"</p>",
        "id": 209943912,
        "sender_full_name": "simulacrum",
        "timestamp": 1600022174
    },
    {
        "content": "<p>nighty features once again require <code>cfg(bootstrap)</code> if they change on master</p>",
        "id": 209943928,
        "sender_full_name": "lcnr",
        "timestamp": 1600022214
    },
    {
        "content": "<p>(so just super-aggressive MSRV, essentially)</p>",
        "id": 209943929,
        "sender_full_name": "simulacrum",
        "timestamp": 1600022220
    },
    {
        "content": "<p>But that's mostly a strawman proposal?</p>",
        "id": 209943943,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1600022245
    },
    {
        "content": "<p>I think I'll check back in when things settle down a bit <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 209943954,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1600022273
    },
    {
        "content": "<p>/me retreats into apocalypse-proof bunker</p>",
        "id": 209944007,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1600022314
    },
    {
        "content": "<p>/me joins <span class=\"user-mention silent\" data-user-id=\"118594\">ecstatic-morse</span></p>",
        "id": 209944020,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600022343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> There's enough food for three weeks. After that, we have a difficult conversation.</p>",
        "id": 209944039,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1600022374
    },
    {
        "content": "<p>What's \"three weeks\"?</p>",
        "id": 209944130,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1600022484
    },
    {
        "content": "<p>Ah, yes, half a release cycle</p>",
        "id": 209944138,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1600022497
    },
    {
        "content": "<blockquote>\n<p>I dont think that's true though. libstd has to still build with both beta and nightly rustc</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  I think this need not to be the case. We can require that only master rustc can compile master libstd (this has tradeoffs, but is doable).</p>",
        "id": 209944508,
        "sender_full_name": "matklad",
        "timestamp": 1600023029
    },
    {
        "content": "<blockquote>\n<p>maybe @matklad has different opinions</p>\n</blockquote>\n<p>I am pretty sure I am not qualified to have a heavy-weight opinion here, I'd personally trust <span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> 's opinion more than mine :-)</p>\n<p>That said, I do believe \"rustc is just a standard crate\"  is conceptually right, and that n-order benefits of this setup would be substantional. I believe that the current setup is incompatible with that, and should be changed. </p>\n<p>I see two ways to make a \"just a crate rustc\": a) build rustc with beta stdlib b) implement cargo feature to allow building <em>any</em> crate with custom stdlib. Among the two, a) seems to be conceptually right.</p>\n<p>I do think \"no more <code>cfg(bootstrap)</code> in stdlib\" of <code>a</code> is a significant (100) benefit. (The fact that me, <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> and <span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> can't agree on whether it is removable in theory is a good example of confusion).</p>\n<p>I do think that delaying the usage of unstable library features by 6 weeks is a significant drawback (-80), which we already face for language features anyway.</p>\n<p>I agree that \"changing a nightly library feature which is used in the compiler\" would require some busy work, but I don't think the scale of this problem would be large (-10): this work needs to be done only for features which actually change, and, although compiler uses a lot of lib features in total, I think any particular feature is not used <em>that</em> much, and it shouldn't be a problem to write the code without a nightly library feature for a specific feature for transition period.</p>",
        "id": 209945208,
        "sender_full_name": "matklad",
        "timestamp": 1600023984
    },
    {
        "content": "<p>Obligatory note that for every 1 person who complains audibly that x.py is frustratingly opaque to them, there's at least 10 other dev corpses who never survived to the point of posting a complaint. :^)</p>",
        "id": 209970237,
        "sender_full_name": "Jubilee",
        "timestamp": 1600066546
    },
    {
        "content": "<p>well and there's also all those for whom it works fine so they see no need to speak up^^</p>",
        "id": 209971465,
        "sender_full_name": "RalfJ",
        "timestamp": 1600067665
    },
    {
        "content": "<blockquote>\n<p>That said, I do believe \"rustc is just a standard crate\" is conceptually right, and that n-order benefits of this setup would be substantional. I believe that the current setup is incompatible with that, and should be changed. </p>\n</blockquote>\n<p>The hackMD talks about \"as if the compiler was written in Go\", but IMO that misses the point. If the Rust compiler was written in Go, <em>it would use the Go standard library</em>, not the Rust one. Our standard library plays double-duty as the standard library for the compiler and the standard library for code compiled by the compiler. So it is only natural that these standard libraries differ a bit, which is reflected by <code>cfg(bootstrap)</code>.<br>\nThe \"imagine rustc was written in a different language\" proposal is essentially equivalent to having a standard library with a top-level</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[cfg(bootstrap)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std_for_compiler</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"cp\">#[cfg(not(bootstrap))]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std_for_ecosystem</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>So, even in that view, <code>cfg(bootstrap)</code> is not avoided, quite the contrary.</p>\n<p>Also, there is something fundamentally recursive that happens when a compiler compiles itself. It <em>is</em> mind-bending, but the only way to avoid that is to indeed write the compiler in a different language, which has way more drawbacks than advantages (for a language like Rust). I don't understand how that's even listed as a desirable goal.^^<br>\nSo, I do not think it is possible to have a self-hosting compiler without some amount of \"mind-bending\", and I think the proposals here just move the mind-bending around while also making compiler development much more painful than it is right now.</p>",
        "id": 209971742,
        "sender_full_name": "RalfJ",
        "timestamp": 1600067972
    },
    {
        "content": "<p>To give an example for what works fairly well right now: I plan to submit a PR that stabilizes <code>union</code> with <code>ManuallyDrop&lt;T&gt;</code> fields. In the same PR I want to be sure that this actually works and is useful, so besides a few tests, I will remove the <code>untagged_union</code> feature from library/ and compiler/ and make everything compile again. Of course the beta compiler still trets this as unstable, so this will require <code>cfg(bootstrap)</code>.<br>\nI am fairly strongly opposed to any proposal that would force me to split this PR into two (so when I do the stabilization I have much lower confidence that everything actually works as intended), and -- even worse -- to let 6 weeks pass between these two PRs (so I need to keep track of doing this somewhere, making sure I do not forget -- I already have more than enough things to keep track of).</p>\n<p>I don't think bootstrapping with <code>cfg(bootstrap)</code> is hard enough to understand that the few people that actually have to interact with it cannot be taught, with some proper documentation. Removing cfg(bootstrap)  (if it can be done) will make contribution easier for some but harder for others -- but the \"some\" just need to learn less while for the \"others\", some of what they did becomes impossible (using a new language/library feature immediately). So overall IMO this makes rustc a much less attractive codebase to hack on.<br>\nOf course, I am biased since I am one of the \"others\". ;)</p>",
        "id": 209972087,
        "sender_full_name": "RalfJ",
        "timestamp": 1600068290
    },
    {
        "content": "<p>OTOH, y'all seem convinced that what I think is impossible can actually be achieved, so I guess -- don't let me stop you, I'll wait until there is a concrete proposal and then I'll comment on that. ;)</p>",
        "id": 209972424,
        "sender_full_name": "RalfJ",
        "timestamp": 1600068539
    },
    {
        "content": "<blockquote>\n<p>I am fairly strongly opposed to any proposal that would force me to split this PR into two </p>\n</blockquote>\n<p>I don't see why you would need to split the PR in two in this case.<code>#![feature(untagged_unions)]</code> is used only in <code>/library</code>, so, in my proposal, you just remove it without adding <code>cfg(bootstrap)</code> anywhere.</p>",
        "id": 209977468,
        "sender_full_name": "matklad",
        "timestamp": 1600072317
    },
    {
        "content": "<p>ah because you think you can make it so that library/ is not built by the bootstrap compiler, just by nightly... I see. interesting.</p>",
        "id": 210031532,
        "sender_full_name": "RalfJ",
        "timestamp": 1600101724
    },
    {
        "content": "<p>The <code>std_for_compiler</code> and <code>std_for_ecosystem</code> above would be related in the sense that <code>std_for_ecosystem</code> is a backwards compatible, drop in replacement for <code>std_for_compiler</code> when used to build the compiler. That's that same as saying <code>rustc</code> builds on stable, effectively. Clang/LLVM have this restriction primarily because they support compiling without a bootstrap phase with 3 or more other C++ compilers, GCC/Clang/MSVC. If Rust had multiple viable compilers written in Rust, I imagine the second compiler would be designed to 'compile on stable', simply because the alternative wouldn't be feasible.</p>",
        "id": 210203741,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600211821
    },
    {
        "content": "<p>Perhaps my opinion isn't worth much, but perhaps it's useful when considering that it's a possible 'outsider' opinion. I've previously hacked on clang and rustc. When rust was pre 1.0, I took the bootstrap process as a cool novelty in it's recursive nature. But I also assumed that when 1.0 came around, surely the compiler would migrate to being built on stable, especially after years of stabilizing more and more features. I guess I'm not sure why one needs the equivalent of <code>Option::zip</code> while writing the compiler rather than just writing:</p>\n<div class=\"codehilite\"><pre><span></span><code>    pub fn unstable_option_zip_free_function&lt;T, U&gt;(this: Option&lt;T&gt;, other: Option&lt;U&gt;) -&gt; Option&lt;(T, U)&gt; {\n        match (this, other) {\n            (Some(a), Some(b)) =&gt; Some((a, b)),\n            _ =&gt; None,\n        }\n    }\n</code></pre></div>",
        "id": 210204334,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600212279
    },
    {
        "content": "<p>And in that sense, contributing to clang meant that I wrote an implementation of <code>std::make_unique</code> because the code couldn't rely on the standard library having it, but it also meant only ever having to do one compile cycle and never hearing the word bootstrap.</p>",
        "id": 210204478,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600212395
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd/near/209972087\">said</a>:</p>\n<blockquote>\n<p>I am fairly strongly opposed to any proposal that would force me to split this PR into two (so when I do the stabilization I have much lower confidence that everything actually works as intended), and -- even worse -- to let 6 weeks pass between these two PRs (so I need to keep track of doing this somewhere, making sure I do not forget -- I already have more than enough things to keep track of)</p>\n</blockquote>\n<p>One could think about adding FIXME's to the code that automatically ping people when the bootstrap compiler is updated.</p>",
        "id": 210210838,
        "sender_full_name": "est31",
        "timestamp": 1600217575
    },
    {
        "content": "<p>Also, isn't there a lint already that warns if you use a stable <code>#![feature(..)]</code>? One could think about adding customizability to warn if you use a feature that's been stable since N releases</p>",
        "id": 210211005,
        "sender_full_name": "est31",
        "timestamp": 1600217757
    },
    {
        "content": "<p>As for the \"to make sure it's working\" point, most lang features aren't used by std, so it's apparently not very important. If it is, then one should think about better ways/policies for testing stabilizations.</p>",
        "id": 210211177,
        "sender_full_name": "est31",
        "timestamp": 1600217901
    },
    {
        "content": "<blockquote>\n<p>ah because you think you can make it so that library/ is not built by the bootstrap compiler, just by nightly... I see. interesting.</p>\n</blockquote>\n<p>Yesssss! I am glad we are on the same page, I was fearing I was bugging you all with my crazy ideas without understanding something crucial :)</p>\n<p>To be clear, I am not going to use this as a leverage for my proposal (as I am not sure myself if it's good), I am just glad about resolving misunderstanding.</p>",
        "id": 210243595,
        "sender_full_name": "matklad",
        "timestamp": 1600252001
    },
    {
        "content": "<blockquote>\n<p>ah because you think you can make it so that library/ is not built by the bootstrap compiler, just by nightly... I see. interesting.</p>\n</blockquote>\n<p>so won't one consequence of that be that it will be <em>harder</em> to hack on the library because you cannot use the bootstrap compiler for that?<br>\nI guess you could do something like rustup-toolchain-install-master or so... is that the plan?</p>",
        "id": 210251411,
        "sender_full_name": "RalfJ",
        "timestamp": 1600257928
    },
    {
        "content": "<p>Yes, it would be harder. </p>\n<p>In the ideal world, where building the compiler is reasonable, and not a giant pita, just using some magical <code>rust-toolchain</code> which points at master would work OK I think. </p>\n<p>In today's world, requiring to build the compiler to hack on stdlib would be a giant regression. But requiring to use the latest nightly probably won't be that bad. </p>\n<p>More details in <a href=\"https://hackmd.io/u-kT-u6PS0aGUls_7A-fUQ\">https://hackmd.io/u-kT-u6PS0aGUls_7A-fUQ</a></p>",
        "id": 210266259,
        "sender_full_name": "matklad",
        "timestamp": 1600265183
    },
    {
        "content": "<p>Technically, if all unstable features/lang items used by std were stabilized, then building std with stable would be doable and would only require a sufficiently recent stable compiler/core combination. Not that it's a goal but it certainly seems plausible in the long term.</p>",
        "id": 210277776,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600269677
    },
    {
        "content": "<p>lang items will never be stabilized, they are an implementation detail of rustc</p>",
        "id": 210277851,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1600269718
    },
    {
        "content": "<p>Not that it matters much, a <code>rust-toolchain</code> file makes working with nightly projects very painless</p>",
        "id": 210278246,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1600269858
    },
    {
        "content": "<p>Ah... I thought <code>#[global_allocator]</code> was an example of a lang_item which was stabilized, but perhaps my understanding of the terms is confused.</p>",
        "id": 210282541,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600271722
    },
    {
        "content": "<p>Same with <code>#[panic_handler]</code>.</p>",
        "id": 210282666,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600271765
    },
    {
        "content": "<p>The ones that are intended to not be stable are likely ones which are in core, hence why I didn't mention being able to build core with stable, only std.</p>",
        "id": 210282776,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600271827
    },
    {
        "content": "<p>And I'm not sure what <code>rust-toolchain</code> is but typing <code>cargo +nightly build</code> isn't the painful part of working with nightly projects.</p>",
        "id": 210282928,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600271894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"336395\">@Ahmed Charles</span> <code>core</code> will, I think, always fundamentally always use unstable things.  And if one cannot build <code>core</code> on stable, I'm not sure it's all that helpful for <code>std</code> to be able to be built on stable, since I would expect them to generally be built by the same process.</p>",
        "id": 210300740,
        "sender_full_name": "scottmcm",
        "timestamp": 1600280607
    },
    {
        "content": "<p>And <code>std</code> depends on <code>core</code>, so you would need to build them with the same toolchain, right?</p>",
        "id": 210332360,
        "sender_full_name": "Noah Lev",
        "timestamp": 1600298955
    },
    {
        "content": "<p>yes</p>",
        "id": 210332387,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600298989
    },
    {
        "content": "<p>Just to clarify, my point was:</p>\n<ol>\n<li>In a world where <code>#[cfg(bootstrap)]</code> doesn't exist.</li>\n<li>And <code>std</code> doesn't itself contain unstable features or lang items.</li>\n<li>Building <code>std</code> on master wouldn't require building the <code>rustc</code> on master first, it would be sufficient to download stable on rustup and build/test <code>std</code> using it.</li>\n</ol>\n<p>Note, the requirement that <code>core</code> and <code>std</code> be built by the same toolchain holds. As for <code>core</code> and <code>std</code> being built by the same 'process', the notion of process is vague enough that I don't know how to respond.</p>",
        "id": 210339961,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1600307049
    },
    {
        "content": "<blockquote>\n<p>And std doesn't itself contain unstable features or lang items.</p>\n</blockquote>\n<p>I don't think this makes sense really</p>",
        "id": 210340046,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600307180
    },
    {
        "content": "<p>here's an example of 'never stabilized features' libstd uses (by the very rough criteria 'attribute that starts with <code>rustc_</code>'):</p>\n<div class=\"codehilite\"><pre><span></span><code>#[rustc_allocator]\n#[rustc_allocator_nounwind]\n#[rustc_allow_const_fn_ptr]\n#[rustc_args_required_const\n#[rustc_builtin_macro]\n#[rustc_const_stable\n#[rustc_const_unstable\n#[rustc_conversion_suggestion]\n#[rustc_deprecated\n#[rustc_diagnostic_item\n#[rustc_force_min_const_fn]`\n#[rustc_inherit_overflow_checks]\n#[rustc_layout_scalar_valid_range_start\n#[rustc_macro_transparency\n#[rustc_nonnull_optimization_guaranteed]\n#[rustc_on_unimplemented\n#[rustc_paren_sugar]\n#[rustc_promotable]\n#[rustc_reservation_impl\n#[rustc_specialization_trait]\n#[rustc_std_internal_symbol]\n#[rustc_unsafe_specialization_marker]\n</code></pre></div>",
        "id": 210340125,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600307333
    },
    {
        "content": "<p>the standard library would be worse without these, but I don't think it's clear in most cases that the ecosystem would be better with them</p>",
        "id": 210340142,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600307367
    },
    {
        "content": "<p>and lang_items are basically necessary if you want <code>core</code> to be usable separate from <code>alloc</code> due to coherence</p>",
        "id": 210340167,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600307403
    },
    {
        "content": "<p>I would be interested to see a rundown/analysis of each of these features and the rationale for keeping them unstable or keeping them in std</p>",
        "id": 210340219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600307436
    },
    {
        "content": "<p>anyway I <em>strongly</em> request that we separate the goals of 'building on stable' and 'building with RUSTC_BOOTSTRAP and beta libstd'</p>",
        "id": 210340225,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600307452
    },
    {
        "content": "<p>the stream for 'building on stable' is <a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358\">https://rust-lang.zulipchat.com/#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/MCP.3A.20move.20compiler.2F.20crates.20to.20stable.20Rust.20compiler-team.23358</a></p>",
        "id": 210340234,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600307471
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd/near/209972087\">said</a>:</p>\n<blockquote>\n<p>To give an example for what works fairly well right now: I plan to submit a PR that stabilizes <code>union</code> with <code>ManuallyDrop&lt;T&gt;</code> fields. In the same PR I want to be sure that this actually works and is useful, so besides a few tests, I will remove the <code>untagged_union</code> feature from library/ and compiler/ and make everything compile again. Of course the beta compiler still trets this as unstable, so this will require <code>cfg(bootstrap)</code>.<br>\nI am fairly strongly opposed to any proposal that would force me to split this PR into two (so when I do the stabilization I have much lower confidence that everything actually works as intended), and -- even worse -- to let 6 weeks pass between these two PRs (so I need to keep track of doing this somewhere, making sure I do not forget -- I already have more than enough things to keep track of).</p>\n</blockquote>\n<p>(Warning: outsider opinion) Here is a setup that is used in other projects I have worked on: We have a compiler <code>A</code> that compiles standard library <code>B</code>. Both change continuously, but <code>B.1.n</code> (master) compiles with compiler <code>A.1</code> (beta), while at the same time <code>B.1.next</code> (release branch) compiles with <code>A.1.m</code> (master). When the compiler releases a new version, <code>A.1.m</code> becomes <code>A.2</code> and <code>B.1.next</code> becomes <code>B.2</code>.</p>\n<p>Rust has it a bit more complicated because of the bootstrapping, but it seems like you can still do the same thing the other way. <code>A.1.n</code> compiles on <code>B.1</code>, and you have a feature branch <code>A.1.next</code> tracking either <code>B.1.m</code> or <code>B.1.next</code> (hopefully there is no difference here, or you are probably being more mind bending than you need to be).</p>\n<p>Applied to your example, that means that you put the <code>#[feature(...)]</code> removal on the release branch, which accumulates with all changes that have been made since the last beta.</p>",
        "id": 210343700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600311909
    },
    {
        "content": "<p>Note that the \"nightly std only adds a minute of additional compile time\" argument is wrong. The moment you change the tiniest part of std, <em>all</em> stage0 artifacts are recompiled, both from <a href=\"http://crates.io\">crates.io</a> and from the local checkout. So rebasing prs means you have to do a full build now if there has been any change in std since. The build could have been much cheaper. Flags like <code>--keep-stage</code> are great but not easily discoverable, also didn't get it to work for myself. I said <code>--keep-stage 1</code>, changed std, hit recompile and it happily started compilation of stage0 std again...</p>",
        "id": 210481716,
        "sender_full_name": "est31",
        "timestamp": 1600409172
    },
    {
        "content": "<p>You need <code>--keep-stage 0</code>.</p>",
        "id": 210486156,
        "sender_full_name": "bjorn3",
        "timestamp": 1600413778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I don't entirely understand the naming you are using, but it sounds like my example would still involve separate PRs to multiple branches? The release branch (<code>beta</code>) is only changed for critical bugfixes so not sure how that would all work with Rust.</p>",
        "id": 210507548,
        "sender_full_name": "RalfJ",
        "timestamp": 1600429593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  When I say \"release branch\" above, <code>B.1.next</code>, I mean the \"release-directed\" branch that accumulates all the compatibility changes that have been made so far in the <code>A.1.m</code> master branch. What I mean by this is that you imagine a bunch of commits happening on master as A.1.1, A.1.2, ... while the beta <code>A.1</code> is the more-stable version (the 6 weeks release in rust's case). With every commit that breaks the library, a parallel fixup commit is made to the standard library on the <code>B.1.next</code> branch, which  is not otherwise used \"in production\", so that all upcoming breakage is fixed in advance without touching the \"production\" master version of the standard library B.1.1, B.1.2, ... which compiles with the last major release of the compiler. <code>B.1.next</code> is not versioned but you would normally keep it up to date with changes to the compiler (always) and changes to the standard library (as necessary), but only contains bugfixes, no features.</p>",
        "id": 210526023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600439202
    },
    {
        "content": "<p>In lean's nomenclature, A.1.n would be the compiler nightly, A.1 would be the beta version, and similarly B.1.n and B.1 are the nightly resp. beta versions of the standard library. My contention is that there is no analogue of A.1.next (the nightly plays double duty in this role) and this is the source of some problems wrt over-frequent bootstrapping.</p>",
        "id": 210526504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600439399
    },
    {
        "content": "<p>I still dont understand what this \"A/B.x.y\" syntax means, and whether \"next\", \"n\" and \"m\" are to be interpreted literally or as representing some integer... but you seem to say that the alternative you describe involves spreading development across two branches (A.1.next and something else), which seems like a worse situation to me than what rustc is doing.</p>",
        "id": 210530103,
        "sender_full_name": "RalfJ",
        "timestamp": 1600440822
    },
    {
        "content": "<p>The rustc repo is fully self-contained in terms of specifying what exactly it takes to bootstrap this compiler (the beta binaries requried for this are stored out-of-tree because having binaries in git is a bad idea, but the git repo says exactly which binary you need). That's a very important feature IMO, for all sorts of reasons from reproducible CI to deterministic builds to ease of development.</p>",
        "id": 210530783,
        "sender_full_name": "RalfJ",
        "timestamp": 1600441047
    },
    {
        "content": "<p>In the situation I am more familiar with, A and B are separate repositories. (Doing that for rust though is an entirely separate discussion.) Here  <code>n</code> and <code>m</code> are variables ranging over integers, patch level version numbers</p>",
        "id": 210531072,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600441150
    },
    {
        "content": "<p>So you might have A.1 being like Rust 1.46 and then a bunch of mini versions A.1.1, A.1.2 (I don't know if these have names in rust besides just git commits) as master evolves, then you cut the next release A.2. A.1.next (you could call it literally this or some other name if you prefer) is a branch of the repo that tracks changes in dependencies; when you cut a new release you make sure A.1.next is up to date with master (or at least the parts of it you want to release) as well as all dependencies and then rename it to A.2</p>",
        "id": 210531565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600441333
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd/near/210530783\">said</a>:</p>\n<blockquote>\n<p>The rustc repo is fully self-contained in terms of specifying what exactly it takes to bootstrap this compiler (the beta binaries requried for this are stored out-of-tree because having binaries in git is a bad idea, but the git repo says exactly which binary you need). That's a very important feature IMO, for all sorts of reasons from reproducible CI to deterministic builds to ease of development.</p>\n</blockquote>\n<p>I'm not sure why precise bootstrapping of master branch subversions is considered important. Why not just limit the bootstrap to major versions? Otherwise you don't have any isolation from instability in dependencies, causing a lot more churn than is necessary</p>",
        "id": 210532163,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600441575
    },
    {
        "content": "<p>we only technically support bootstrapping from a particular beta for each commit on master</p>",
        "id": 210532300,
        "sender_full_name": "simulacrum",
        "timestamp": 1600441663
    },
    {
        "content": "<p>I don't think Ralf said otherwise?</p>",
        "id": 210532321,
        "sender_full_name": "simulacrum",
        "timestamp": 1600441673
    },
    {
        "content": "<p>That said, it is probably possible to simultaneously support a precise bootstrap and the more relaxed bootstrap I'm suggesting. I'm not totally clear on how rust does it but I think this is already the case</p>",
        "id": 210532325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600441674
    },
    {
        "content": "<p>I think a general decoupling of rustc and std is a good thing. There are many things to bikeshed about the details there though</p>",
        "id": 210532581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600441773
    },
    {
        "content": "<p>I would not necessarily characterize it as a bikeshed. Those details are <em>really important</em> IMO.</p>",
        "id": 210532718,
        "sender_full_name": "simulacrum",
        "timestamp": 1600441816
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Building.20rustc.20with.20beta.20libstd/near/210532581\">said</a>:</p>\n<blockquote>\n<p>I think a general decoupling of rustc and std is a good thing.</p>\n</blockquote>\n<p>I'm not sure how feasible that is :/</p>",
        "id": 210532782,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600441850
    },
    {
        "content": "<p>my original proposal didn't decouple libstd from rustc at all, only rustc from libstd</p>",
        "id": 210532821,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600441867
    },
    {
        "content": "<p>FWIW glibc does this too - it has <em>tons</em> of <code>#ifdef __GNUC__</code> everywhere</p>",
        "id": 210533008,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600441928
    },
    {
        "content": "<p>so it can behave differently when compiled with gcc</p>",
        "id": 210533035,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600441942
    },
    {
        "content": "<p>For a bit of context, my \"day job\" is on the lean theorem prover, which also has a large standard library called mathlib. Both projects are worked on by the same people and have very high incompatibility rates w.r.t earlier versions, so I deal with this problem on a pretty regular basis. The main difference with rust is that it's not bootstrapped</p>",
        "id": 210533172,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600442000
    },
    {
        "content": "<p>They are actually in separate repositories, which has some consequences re: not being able to PR simultaneously to both</p>",
        "id": 210533476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600442115
    },
    {
        "content": "<p>which is part of why we settled on a \"release cycle\" of the sort I've described</p>",
        "id": 210533553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600442139
    },
    {
        "content": "<p>when everything is in one repo there is no bound your incompatibility rate. This is good for agility but means recompiles are more frequent than desirable (especially important if compiles are expensive, as in rust's case)</p>",
        "id": 210534048,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1600442254
    }
]