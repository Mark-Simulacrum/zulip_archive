[
    {
        "content": "<p>I am not exactly sure how tags are transformed into discriminants, can anyone ELI5 to me the computation to go from tag to discriminant? I'm trying to reverse that computation to get a SwitchTargets that works on the tag itself</p>",
        "id": 263472558,
        "sender_full_name": "nox",
        "timestamp": 1638466164
    },
    {
        "content": "<p>This is the logic cg_clif uses: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/516b478c8161c7a90e604f96d0f5878990550f21/src/discriminant.rs#L63-L169\">https://github.com/bjorn3/rustc_codegen_cranelift/blob/516b478c8161c7a90e604f96d0f5878990550f21/src/discriminant.rs#L63-L169</a></p>",
        "id": 263476917,
        "sender_full_name": "bjorn3",
        "timestamp": 1638468037
    },
    {
        "content": "<p>Here is the code in rustc for converting a variant to a discriminant <a href=\"https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_middle/ty/adt.rs.html#432-436\">https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_middle/ty/adt.rs.html#432-436</a></p>",
        "id": 263522581,
        "sender_full_name": "DevinR528",
        "timestamp": 1638493389
    },
    {
        "content": "<p>Thanks. In a <code>SwitchInt</code> that matches on a <code>Discriminant(_)</code> of an niche-encoded enum, the values are always discriminants, which are always variant indices, right?</p>",
        "id": 263582607,
        "sender_full_name": "nox",
        "timestamp": 1638539776
    },
    {
        "content": "<p>Discriminants can be different from variant indices. Discriminants are what you write as user using eg <code>Foo = 100</code>, while variant indices always start from 0.</p>",
        "id": 263584201,
        "sender_full_name": "bjorn3",
        "timestamp": 1638540382
    },
    {
        "content": "<p>I said \"of a niche-encoded enum\" though. A niche-encoded enum cannot have explicit discriminants</p>",
        "id": 263585082,
        "sender_full_name": "nox",
        "timestamp": 1638540806
    },
    {
        "content": "<p>A niche-encoded enum will use unused bit patterns, which aren't necessarily the same as variant indices either IIUC.</p>",
        "id": 263675112,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638582276
    },
    {
        "content": "<p>So, e.g., let's say <code>None</code> has variant index zero. With <code>Option&lt;char&gt;</code>, its discriminant will be a large value that's not in use in Unicode:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span>::<span class=\"o\">&lt;</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// prints 1114112</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263675229,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638582420
    },
    {
        "content": "<p>So the variant index is different from the discriminant; my understanding is the variant index is more like a DefId.</p>",
        "id": 263675243,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638582459
    },
    {
        "content": "<blockquote>\n<p>In a <code>SwitchInt</code> that matches on a <code>Discriminant(_)</code> of an niche-encoded enum, the values are always discriminants, which are always variant indices, right?</p>\n</blockquote>\n<p>Right. The current implementation uses niche optimization only if there are no explicit discriminants, since it relies on variant indices and discriminants matching exactly: <a href=\"https://github.com/rust-lang/rust/blob/532d2b14c05f9bc20b2d27cbb5f4550d28343a36/compiler/rustc_middle/src/ty/layout.rs#L1036-L1047\">https://github.com/rust-lang/rust/blob/532d2b14c05f9bc20b2d27cbb5f4550d28343a36/compiler/rustc_middle/src/ty/layout.rs#L1036-L1047</a></p>",
        "id": 263675956,
        "sender_full_name": "tm",
        "timestamp": 1638583342
    },
    {
        "content": "<blockquote>\n<p>since it relies on variant indices and discriminants matching exactly</p>\n</blockquote>\n<p>That is really bizarre. Indeed, </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(core_intrinsics)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">discriminant_value</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nb\">Option</span>::<span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span>::<span class=\"nb\">None</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>prints <code>0</code>. That's obviously not the \"real\" discriminant, which is effectively 1114112. But I guess returning that would expose the unstable layout details?</p>",
        "id": 263676465,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638583943
    },
    {
        "content": "<blockquote>\n<p>if T has no discriminant, returns 0.</p>\n</blockquote>\n<p>Ah, so perhaps the 0 it's returning is a \"sentinel value\". Why doesn't this intrinsic return <code>Option&lt;&lt;T as DiscriminantKind&gt;::Discriminant&gt;</code>?</p>",
        "id": 263676490,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638584037
    },
    {
        "content": "<p>Try calling it with a <code>Some</code>; I suspect that's a \"real\" discriminant, just not one set by a user.  (The same way that <code>enum Foo { Zero, One, Two }</code> has \"real\" discriminants despite the lack of <code>= 1</code>, <code>=2</code>, ...)</p>",
        "id": 263684195,
        "sender_full_name": "scottmcm",
        "timestamp": 1638593817
    },
    {
        "content": "<p>But it's not a discriminant (since it's a niche-encoded variant), though I guess it could be the VariantIdx?</p>",
        "id": 263684489,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638594163
    },
    {
        "content": "<p><code>Some</code> returns 1, so yeah, I suspect it's actually returning the VariantIdx...</p>",
        "id": 263684508,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638594213
    },
    {
        "content": "<blockquote>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(core_intrinsics)]</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">discriminant_value</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nb\">Option</span>::<span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span>::<span class=\"nb\">None</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>prints <code>0</code>. That's obviously not the \"real\" discriminant, which is effectively 1114112.</p>\n</blockquote>\n<p>The encoding of discriminant in a memory is called tag. The discriminant of None variant is zero, which is encoded by a tag 1114112.</p>",
        "id": 263691342,
        "sender_full_name": "tm",
        "timestamp": 1638604524
    },
    {
        "content": "<p>Regarding the question about target values in <code>switchInt</code> matching on a discriminant, I would also mention the general caveat that the target values can be arbitrary, since the MIR could correspond to a user written code. For example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">intrinsics</span>::<span class=\"n\">discriminant_value</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263691771,
        "sender_full_name": "tm",
        "timestamp": 1638605182
    }
]