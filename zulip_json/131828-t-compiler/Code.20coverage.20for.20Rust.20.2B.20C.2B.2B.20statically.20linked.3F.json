[
    {
        "content": "<p>Hey, folks. I'm working on code coverage for a codebase that statically links Rust code into C++ DLLs / shared objects.  The Rust code is compiled using <code>crate-type = [\"staticlib\"]</code>, which works great. But when I compiled with <code>-Zinstrument-coverage</code>, then the Rust static lib does not contain the guts of <code>profiler_builtins</code>, so it fails to find those paths.  I could hard-code that path, but since the filename has a version hash in it, that's not really a stable solution.</p>\n<p>Also, is it possible to perform code coverage analysis across C++ _and_ Rust?  As in, run Clang with <code>--coverage</code>?  I tried this, and it successfully produces a <code>profraw</code> file, but <code>grcov</code> was not able to analyze it.  I'm not super-familiar with the file types used in LLVM's coverage world, so I'm not sure how to debug this.</p>",
        "id": 262898789,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1638056159
    },
    {
        "content": "<p>You need to use <code>-fprofile-instr-generate -fcoverage-mapping</code> with Clang, not <code>--coverage</code>. Also make sure that you are using Clang 13 (since Rust nightly uses LLVM 13).</p>",
        "id": 262899589,
        "sender_full_name": "Amanieu",
        "timestamp": 1638057511
    },
    {
        "content": "<p>Ah, super!  I'll try that.</p>",
        "id": 262899805,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1638057761
    },
    {
        "content": "<p>Will Clang handle linking the profiler_builtins?</p>",
        "id": 262899873,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1638057850
    },
    {
        "content": "<p>Yes.</p>",
        "id": 262901938,
        "sender_full_name": "Amanieu",
        "timestamp": 1638061579
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> That indeed worked. Thanks much!</p>",
        "id": 262902161,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1638062007
    },
    {
        "content": "<p>Great! I have a similar setup but inverted: a Rust program that uses a C staticlib. Those flags worked for me.</p>",
        "id": 262902210,
        "sender_full_name": "Amanieu",
        "timestamp": 1638062056
    },
    {
        "content": "<p>With some of the coverage toolchains that I've used in the past, you could create a file that contained coverage baselines, like \"src/foo/zap must be at least 88% coverage\", and then in CI pipelines could trigger a warning/error if coverage dropped below those baselines.  Is there anything like that which works with LLVM-based coverage files?</p>",
        "id": 262902434,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1638062466
    },
    {
        "content": "<p>Is there a way to output just the coverage percentage programmatically? If so that should be pretty easy to check even with a shell script</p>",
        "id": 262902681,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638062944
    },
    {
        "content": "<p>I don't see anything yet, but I haven't dug too deeply, yet.  Really, any reliable form of baseline would work.  A percentage covered per file would be a good enough signal to start with.</p>",
        "id": 262902749,
        "sender_full_name": "Arlie Davis",
        "timestamp": 1638063033
    }
]