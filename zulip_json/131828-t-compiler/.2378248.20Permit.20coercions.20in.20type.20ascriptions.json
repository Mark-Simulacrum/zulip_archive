[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  One problem I've encountered:</p>\n<p>When I use Path expressions inside type ascriptions, I get coercion errors. E.g the following does not work: </p>\n<div class=\"codehilite\"><pre><span></span><code>fn foo&lt;&#39;a&gt;(arg : (u32, (u32, &amp;&#39;a [u32;3]))) -&gt; (u32, (u32, &amp;&#39;a [u32])) {\n  arg : (u32, (u32, &amp;[u32]))\n}\n</code></pre></div>\n<p>The way this is currently implemented is that we pass a <code>TypeAscriptionCtxt</code> along with an Expectation (and also use that context in <code>check_expr_coercable_to_type</code> since not all sites from which 'check_expr_coercable_to_type' is called are coercion sites, e.g. ExprKind::Assign is not a coercion site going by <a href=\"https://doc.rust-lang.org/reference/type-coercions.html#coercion-sites\">the reference</a>). <code>TypeAscriptionCtxt</code> has a variant <code>Coercion</code>, which signals that this Expectation arises from some coercion site (possibly higher up in the check_expr_... call sequence), so if we find a type ascription in some expression and <code>TypeAscriptionCtxt::Coercion</code> holds, we try to coerce the type ascription using <code>check_expr_coercable_to_type</code>, so inside <code>check_expr_kind</code> we now have the following for <code>ExprKind::Type</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>            ExprKind::Type(ref e, ref t) =&gt; {\n                let ty = self.to_ty_saving_user_provided_ty(&amp;t);\n                if expected.coerce_type_ascriptions() {\n                    self.check_expr_coercable_to_type(e, ty, None, TypeAscriptionCtxt::Coercion)\n                } else {\n                    self.check_expr_eq_type(&amp;e, ty);\n                    ty\n                }\n            }\n</code></pre></div>\n<p>When we're dealing with path expressions inside <a href=\"https://github.com/rust-lang/rust/blob/d015f0d92144f0e72735a918aee8510b0fe2cff5/compiler/rustc_typeck/src/check/expr.rs#L101\"><code>check_expr_coercable_to_type</code></a> we call <code>check_expr_with_expectation</code> on this path expression, which in our example returns <code>(u32, (u32, &amp;[u32;3])</code> for <code>arg</code>, calling <code>demand_coerce</code> with the types <code>(u32, (u32, &amp;[u32;3]) -&gt; (u32, (u32, &amp;[u32])</code> inside <code>check_expr_coercable_to_type</code> then yields an error, because those two types cannot be unified.</p>\n<p>I'm not sure what behaviour is expected here, I would think using <code>arg :  (u32, (u32, &amp;[u32]))</code> should compile in this example?</p>",
        "id": 218690823,
        "sender_full_name": "BN",
        "timestamp": 1607001358
    }
]