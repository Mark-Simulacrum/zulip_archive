[
    {
        "content": "<p>What's the difference between <code>x.py build --stage 0 library/std</code> and <code>x.py build --stage 0 library/test</code>?</p>",
        "id": 265729401,
        "sender_full_name": "nnethercote",
        "timestamp": 1640117650
    },
    {
        "content": "<p>And how do they differ from <code>x.py build --stage 0</code>? AFAICT they're all equivalent</p>",
        "id": 265729693,
        "sender_full_name": "nnethercote",
        "timestamp": 1640117853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> I believe they are the same</p>",
        "id": 265729754,
        "sender_full_name": "Eric Huss",
        "timestamp": 1640117885
    },
    {
        "content": "<p>I swear someone in the past told me <code>library/test</code> was a more useful target than <code>library/std</code>; I have <code>library/test</code> in all my aliases.</p>",
        "id": 265729834,
        "sender_full_name": "nnethercote",
        "timestamp": 1640117947
    },
    {
        "content": "<p>Also, given that <code>--stage 0</code> means \"build with the stage 0 compiler\" I would have thought <code>x.py build --stage 0</code> would build a local rustc, but it doesn't</p>",
        "id": 265729874,
        "sender_full_name": "nnethercote",
        "timestamp": 1640117976
    },
    {
        "content": "<p>Every time I think I've got my head around how this stuff works, some new misunderstanding arises</p>",
        "id": 265729899,
        "sender_full_name": "nnethercote",
        "timestamp": 1640117993
    },
    {
        "content": "<p><code>x.py build --stage 0 library/alloc</code> and <code>x.py build -stage 0 library/proc_macro</code> are also valid, and seemingly equivalent to the ones above.</p>",
        "id": 265730051,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118093
    },
    {
        "content": "<p>But <code>x.py build --stage 0 library/backtrace</code> fails with:</p>\n<div class=\"codehilite\"><pre><span></span><code>thread &#39;main&#39; panicked at &#39;error: no rules matched library/backtrace&#39;, src/bootstrap/builder.rs:236:17\n</code></pre></div>",
        "id": 265730146,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265730051\">said</a>:</p>\n<blockquote>\n<p><code>x.py build --stage 0 library/alloc</code> and <code>x.py build -stage 0 library/proc_macro</code> are also valid, and seemingly equivalent to the ones above.</p>\n</blockquote>\n<p>Referencing the directory of any crate that is part of the standard library causes the standard library to be built.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265730146\">said</a>:</p>\n<blockquote>\n<p>But <code>x.py build --stage 0 library/backtrace</code> fails with:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>thread &#39;main&#39; panicked at &#39;error: no rules matched library/backtrace&#39;, src/bootstrap/builder.rs:236:17\n</code></pre></div><br>\n</p>\n</blockquote>\n<p><code>library/backtrace</code> isn't a standalone crate but directly included into libstd using <code>#[path = \"...\"] mod backtrace;</code> as libbacktrace itself depends on libstd for reading files.</p>",
        "id": 265730573,
        "sender_full_name": "bjorn3",
        "timestamp": 1640118441
    },
    {
        "content": "<p>For various reasons, <code>library/backtrace</code> isn't a real dependency.  It is embedded via a <code>#[path]</code> attribute.</p>",
        "id": 265730583,
        "sender_full_name": "Eric Huss",
        "timestamp": 1640118448
    },
    {
        "content": "<p>Ok, thanks</p>",
        "id": 265730771,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118539
    },
    {
        "content": "<p>The output of <code>x.py build -h</code> includes this:</p>\n<div class=\"codehilite\"><pre><span></span><code>    This subcommand accepts a number of paths to directories to the crates\n    and/or artifacts to compile. For example:\n\n        ./x.py build library/core\n        ./x.py build library/core library/proc_macro\n        ./x.py build library/std --stage 1\n\n    If no arguments are passed then the complete artifacts for that stage are\n    also compiled.\n\n        ./x.py build\n        ./x.py build --stage 1\n\n    For a quick build of a usable compiler, you can pass:\n\n        ./x.py build --stage 1 library/test\n\n    This will first build everything once (like `--stage 0` without further\n    arguments would), and then use the compiler built in stage 0 to build\n    library/test and its dependencies.\n    Once this is done, build/$ARCH/stage1 contains a usable compiler.\n</code></pre></div>",
        "id": 265730858,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118595
    },
    {
        "content": "<p>I think those first three commands are equivalent now?</p>",
        "id": 265730959,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118636
    },
    {
        "content": "<p>Also, the last command mentions <code>library/test</code></p>",
        "id": 265730976,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118647
    },
    {
        "content": "<p>yeah, all of {core,proc_macro,std,test} are currently equivalent.</p>",
        "id": 265731016,
        "sender_full_name": "simulacrum",
        "timestamp": 1640118670
    },
    {
        "content": "<p>I want to improve the docs on this, because they are not great and I'm tired of not understanding this stuff</p>",
        "id": 265731046,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118703
    },
    {
        "content": "<p>should be in src/bootstrap/flags.rs, happy to accept PRs :)</p>",
        "id": 265731193,
        "sender_full_name": "simulacrum",
        "timestamp": 1640118804
    },
    {
        "content": "<p>Yep, this is partly in bootstrap/, partly in the rustc-dev-guide</p>",
        "id": 265731219,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118831
    },
    {
        "content": "<p>So far I only have small changes to the bootstrap output. Most notably a \"Building rustbuild\" label, which clears up a confusion I've had for ages</p>",
        "id": 265731316,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118881
    },
    {
        "content": "<p>(Like, if you get a fresh clone and run <code>x.py clean</code> it starts building Rust code, which was always a head-scratcher to me)</p>",
        "id": 265731367,
        "sender_full_name": "nnethercote",
        "timestamp": 1640118913
    },
    {
        "content": "<p>Next question: if I run <code>./x.py build --stage 1 library/std</code>it ends with this:</p>\n<div class=\"codehilite\"><pre><span></span><code>  - Assembling stage1 compiler\n  - Building stage1 std artifacts\n  - Copying stage1 std from stage1\n</code></pre></div>\n<p>But if I run <code>./x.py build --stage 2 library/std</code> it ends with this:</p>\n<div class=\"codehilite\"><pre><span></span><code>  - Assembling stage2 compiler\n  - Uplifting stage1 std\n  - Copying stage2 std from stage1\n</code></pre></div>\n<p>It doesn't build <code>std</code> again. Does it just copy the <code>std</code> built previously -- is that what \"uplifting\" means?</p>",
        "id": 265731696,
        "sender_full_name": "nnethercote",
        "timestamp": 1640119117
    },
    {
        "content": "<p>yeah, uplifting is just a copy</p>",
        "id": 265731751,
        "sender_full_name": "simulacrum",
        "timestamp": 1640119149
    },
    {
        "content": "<p>It builds libstd again if you use full-bootstrap=true I believe.</p>",
        "id": 265731770,
        "sender_full_name": "bjorn3",
        "timestamp": 1640119163
    },
    {
        "content": "<p>Presumably this is just to save time, because rebuilding again is rarely going to be useful</p>",
        "id": 265731855,
        "sender_full_name": "nnethercote",
        "timestamp": 1640119208
    },
    {
        "content": "<p>Yeah, it should be the same anyway if there aren't any bugs.</p>",
        "id": 265731908,
        "sender_full_name": "bjorn3",
        "timestamp": 1640119246
    },
    {
        "content": "<p>So what's the full list of sensible targets(?) for <code>x.py build</code>? Definitely <code>library/std</code> and <code>compiler/rust</code>. Anything else?</p>",
        "id": 265732216,
        "sender_full_name": "nnethercote",
        "timestamp": 1640119478
    },
    {
        "content": "<p>There are lots of targets, it all depends on what someone is doing.  There's a full list in <code>./x.py build --help -v</code> (albeit, some of those overlap with each other).</p>",
        "id": 265732538,
        "sender_full_name": "Eric Huss",
        "timestamp": 1640119735
    },
    {
        "content": "<p>Is there any way to know which ones overlap?</p>",
        "id": 265732709,
        "sender_full_name": "nnethercote",
        "timestamp": 1640119851
    },
    {
        "content": "<p>for <code>./x.py build</code> I think the <code>library/*</code> ones are the only ones that do that.</p>",
        "id": 265732892,
        "sender_full_name": "Eric Huss",
        "timestamp": 1640119975
    },
    {
        "content": "<p>If you're curious code-wise how that happens, it is the <a href=\"https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/compile.rs#L48\"><code>all_krates</code></a> function.</p>",
        "id": 265732978,
        "sender_full_name": "Eric Huss",
        "timestamp": 1640120031
    },
    {
        "content": "<p>Also all compiler/* paths do the same I believe. (with the exception of rustc_codegen_cranelift and rustc_codegen_gcc)</p>",
        "id": 265733393,
        "sender_full_name": "bjorn3",
        "timestamp": 1640120330
    },
    {
        "content": "<p>The only two available <code>compiler/*</code> paths for me are</p>\n<div class=\"codehilite\"><pre><span></span><code>    ./x.py build compiler/rustc\n    ./x.py build compiler/rustc_codegen_cranelift\n</code></pre></div>",
        "id": 265733453,
        "sender_full_name": "nnethercote",
        "timestamp": 1640120375
    },
    {
        "content": "<p>for cg_gcc looks like <a href=\"https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/compile.rs#L779\">https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/compile.rs#L779</a> hasn't been updated yet. cc <span class=\"user-mention\" data-user-id=\"404242\">@antoyo</span></p>",
        "id": 265733823,
        "sender_full_name": "bjorn3",
        "timestamp": 1640120534
    },
    {
        "content": "<p>only compiler/rustc is used indeed: <a href=\"https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/compile.rs#L1030\">https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/compile.rs#L1030</a></p>",
        "id": 265733895,
        "sender_full_name": "bjorn3",
        "timestamp": 1640120605
    },
    {
        "content": "<p><code>./x.py check compiler/...</code> also uses the <code>all_krates</code> function so that passing any path will check the entire compiler, so that's maybe what you're thinking of.</p>\n<p>I think that should probably change to just check the path you pass in.  I don't know why it does the whole compiler.</p>",
        "id": 265734185,
        "sender_full_name": "Eric Huss",
        "timestamp": 1640120796
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265733823\">said</a>:</p>\n<blockquote>\n<p>for cg_gcc looks like <a href=\"https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/compile.rs#L779\">https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/compile.rs#L779</a> hasn't been updated yet. cc <span class=\"user-mention silent\" data-user-id=\"404242\">antoyo</span></p>\n</blockquote>\n<p>I believe that's on purpose. AFAIK, we did not want to enable that until it's ready, no?</p>",
        "id": 265734658,
        "sender_full_name": "antoyo",
        "timestamp": 1640121091
    },
    {
        "content": "<p>That isn't the dist pass, just the build pass. Also you can build it anyway by adding <code>\"gcc\"</code> to the <code>codegen-backends</code> array in <code>config.toml</code>.</p>",
        "id": 265738957,
        "sender_full_name": "bjorn3",
        "timestamp": 1640123629
    },
    {
        "content": "<p>I still don't have a coherent explanation for the behaviour of the basic build command <code>./x.py build --stage N &lt;path&gt;</code>.</p>\n<p>E.g. consider these three example commands, and what actions they perform:</p>\n<div class=\"codehilite\"><pre><span></span><code>./x.py build --stage 1 library/std\n  Building stage0 std artifacts\n  Copying stage0 std from stage0\n  Building stage0 compiler artifacts\n  Copying stage0 rustc from stage0\n  Assembling stage1 compiler\n  Building stage1 std artifacts\n  Copying stage1 std from stage1\n\n./x.py build --stage 1\n  Building stage0 std artifacts\n  Copying stage0 std from stage0\n  Building stage0 compiler artifacts\n  Copying stage0 rustc from stage0\n  Assembling stage1 compiler\n  Building stage1 std artifacts\n  Copying stage1 std from stage1\n    Building rustdoc for stage1\n\n./x.py build --stage 1 compiler/rustc\n  Building stage0 std artifacts\n  Copying stage0 std from stage0\n  Building stage0 compiler artifacts\n  Copying stage0 rustc from stage0\n  Assembling stage1 compiler\n  Building stage1 std artifacts\n  Copying stage1 std from stage1\n    Building stage1 compiler artifacts\n    Copying stage1 rustc from stage1\n    Assembling stage2 compiler\n</code></pre></div>",
        "id": 265739347,
        "sender_full_name": "nnethercote",
        "timestamp": 1640123890
    },
    {
        "content": "<p>Why does adding the <code>library/std</code> path cause <em>less</em> stuff to happen than no path, but adding the <code>compiler/rustc</code> path causes <em>more</em> stuff to happen than no path?</p>",
        "id": 265739403,
        "sender_full_name": "nnethercote",
        "timestamp": 1640123941
    },
    {
        "content": "<p>this is the list for each x.py subcommand by step -- <a href=\"https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/builder.rs#L372\">https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/builder.rs#L372</a></p>",
        "id": 265739935,
        "sender_full_name": "simulacrum",
        "timestamp": 1640124217
    },
    {
        "content": "<p>it looks like no path ends up building rustdoc, which forces stage1 std + compiler artifacts, but doesn't need the stage2 rustc binary and sysroot assembled, so skips that setp. invoking compiler/rustc assembles that sysroot.</p>",
        "id": 265740088,
        "sender_full_name": "simulacrum",
        "timestamp": 1640124307
    },
    {
        "content": "<p>in general, there's not a lot of \"principled\" thought behind the differences between these options, it largely amounts to historical artifact of which steps ended up on the DEFAULT list and which didn't, as well as the relationships between them to some extent.</p>",
        "id": 265740130,
        "sender_full_name": "simulacrum",
        "timestamp": 1640124347
    },
    {
        "content": "<p>Right, I think this is a big part of why people find it so confusing, and why the docs are so hard to read and write</p>",
        "id": 265740295,
        "sender_full_name": "nnethercote",
        "timestamp": 1640124473
    },
    {
        "content": "<p>It ends up being a case of memorizing particular incantations for scenarios of interest</p>",
        "id": 265740395,
        "sender_full_name": "nnethercote",
        "timestamp": 1640124519
    },
    {
        "content": "<p>yeah, for sure</p>",
        "id": 265740417,
        "sender_full_name": "simulacrum",
        "timestamp": 1640124532
    },
    {
        "content": "<p>fwiw, I think part of it is also that the interface (at least IMO) is designed less so for \"why is this building this\" kind of question, but rather \"what do you want to build\" -- at least in theory, there's no intrinsic <em>reason</em> you need to know if you always specify a set of paths what the defaults are.</p>\n<p>I've even thought about hard requiring paths on ~all commands, with some kind of --literally-everything option, potentially.</p>",
        "id": 265740599,
        "sender_full_name": "simulacrum",
        "timestamp": 1640124670
    },
    {
        "content": "<p>(the value of the defaults is somewhat questionable, imo, given the questions they bring up and the relatively low likelihood we actually get it right when you run x.py build for a significant fraction of people)</p>",
        "id": 265740647,
        "sender_full_name": "simulacrum",
        "timestamp": 1640124709
    },
    {
        "content": "<p>Requiring paths seems reasonable to me, could potentially have an \"all\" path</p>",
        "id": 265741263,
        "sender_full_name": "nnethercote",
        "timestamp": 1640124973
    },
    {
        "content": "<p>\"What do I want to build?\" seems the key question</p>",
        "id": 265741306,
        "sender_full_name": "nnethercote",
        "timestamp": 1640125037
    },
    {
        "content": "<p>The answer \"everything (or something approximating that) within stage N\" doesn't seem that useful, especially when the meaning of \"within stage N\" is non-obvious</p>",
        "id": 265741348,
        "sender_full_name": "nnethercote",
        "timestamp": 1640125073
    },
    {
        "content": "<p>More useful answers are things like \"a <code>std</code> built from local sources\" (for <code>std</code> devs) or \"a <code>rustc</code> built from local sources\" or \"a <code>rustdoc</code> built from local sources\"</p>",
        "id": 265741446,
        "sender_full_name": "nnethercote",
        "timestamp": 1640125153
    },
    {
        "content": "<p>I'm looking at the <code>Step</code> type now, wow, every command+path combination is its own unique snowflake</p>",
        "id": 265742035,
        "sender_full_name": "nnethercote",
        "timestamp": 1640125644
    },
    {
        "content": "<blockquote>\n<p>The answer \"everything (or something approximating that) within stage N\" doesn't seem that useful</p>\n</blockquote>\n<p>Except <code>./x.py build</code> to get something one can rustup link.</p>",
        "id": 265742074,
        "sender_full_name": "The 8472",
        "timestamp": 1640125681
    },
    {
        "content": "<p>but even that is pretty vague -- I guess we can limit it to <em>just</em> std by default in theory, but even that seems a little presumptive to some extent.</p>",
        "id": 265742350,
        "sender_full_name": "simulacrum",
        "timestamp": 1640125841
    },
    {
        "content": "<p>Oh, so paths are not necessarily related to actual file system paths, they're just magic strings within <code>bootstrap</code> that <em>usually</em> correspond to file system paths?</p>",
        "id": 265743050,
        "sender_full_name": "nnethercote",
        "timestamp": 1640126321
    },
    {
        "content": "<p>\"I want to build a stage 1 compiler\" --&gt; \"oh, you need to run <code>x.py build --stage 1 library/std</code>\" --&gt; \"what?\"</p>",
        "id": 265743357,
        "sender_full_name": "nnethercote",
        "timestamp": 1640126543
    },
    {
        "content": "<p>yeah, that's right</p>",
        "id": 265743650,
        "sender_full_name": "simulacrum",
        "timestamp": 1640126745
    },
    {
        "content": "<p>(though the <em>idea</em> is that the correspond to filesystem paths or some similar namespace, in general)</p>",
        "id": 265743718,
        "sender_full_name": "simulacrum",
        "timestamp": 1640126774
    },
    {
        "content": "<p>And now I realize all the docs suggest running <code>x.py build --stage 1 library/std</code> but you can just write <code>x.py build --stage 1 std</code>, which I think is better</p>",
        "id": 265744767,
        "sender_full_name": "nnethercote",
        "timestamp": 1640127512
    },
    {
        "content": "<p><code>rustc</code> is also a valid path, apparently</p>",
        "id": 265745104,
        "sender_full_name": "nnethercote",
        "timestamp": 1640127732
    },
    {
        "content": "<p>suffixes, I think</p>",
        "id": 265745111,
        "sender_full_name": "simulacrum",
        "timestamp": 1640127745
    },
    {
        "content": "<p>It does suffix matching? lol</p>",
        "id": 265745962,
        "sender_full_name": "nnethercote",
        "timestamp": 1640128295
    },
    {
        "content": "<p>I can't work out where the default stage for each subcommand is specified</p>",
        "id": 265746823,
        "sender_full_name": "nnethercote",
        "timestamp": 1640128920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> <a href=\"https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/config.rs#L1029\">https://github.com/rust-lang/rust/blob/e100ec5bc7cd768ec17d75448b29c9ab4a39272b/src/bootstrap/config.rs#L1029</a></p>",
        "id": 265746920,
        "sender_full_name": "simulacrum",
        "timestamp": 1640128996
    },
    {
        "content": "<p>complicated, and not sure if entirely helpful, but I pretty much always use like ~two commands so likely not really representative.</p>",
        "id": 265746954,
        "sender_full_name": "simulacrum",
        "timestamp": 1640129029
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265729834\">said</a>:</p>\n<blockquote>\n<p>I swear someone in the past told me <code>library/test</code> was a more useful target than <code>library/std</code>; I have <code>library/test</code> in all my aliases.</p>\n</blockquote>\n<p>Eventually I and <span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> would like to make x.py \"crate-aware\" but right now it's only \"step-aware\", so it will build <em>all</em> crates in the standard library if you specify any of them.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265729874\">said</a>:</p>\n<blockquote>\n<p>Also, given that <code>--stage 0</code> means \"build with the stage 0 compiler\" I would have thought <code>x.py build --stage 0</code> would build a local rustc, but it doesn't</p>\n</blockquote>\n<p>It used to, but no longer does because people use <code>build --stage 1</code> most often and it would end up building the compiler twice. You can opt-in to the old behavior with <code>build --stage 0 compiler/rustc</code>. See also <a href=\"https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html\">https://blog.rust-lang.org/inside-rust/2020/08/30/changes-to-x-py-defaults.html</a>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265739403\">said</a>:</p>\n<blockquote>\n<p>Why does adding the <code>library/std</code> path cause <em>less</em> stuff to happen than no path, but adding the <code>compiler/rustc</code> path causes <em>more</em> stuff to happen than no path?</p>\n</blockquote>\n<p>I very much wanted this to <em>not</em> be the case, but my MCP was shot down and I ran out of energy to fight over it. <a href=\"https://github.com/rust-lang/compiler-team/issues/351\">https://github.com/rust-lang/compiler-team/issues/351</a></p>\n<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265743357\">said</a>:</p>\n<blockquote>\n<p>\"I want to build a stage 1 compiler\" --&gt; \"oh, you need to run <code>x.py build --stage 1 library/std</code>\" --&gt; \"what?\"</p>\n</blockquote>\n<p>Well, you <em>can</em> run <code>build --stage 0 compiler/rustc</code>, but it's not very useful - this is discussed more in <a href=\"https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#stages-and-std\">https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#stages-and-std</a>.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265746823\">said</a>:</p>\n<blockquote>\n<p>I can't work out where the default stage for each subcommand is specified</p>\n</blockquote>\n<p>in the code like <span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> said, and also in the dev-guide: <a href=\"https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#building-the-stages\">https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#building-the-stages</a></p>",
        "id": 265821550,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640189240
    },
    {
        "content": "<p>cc <a href=\"https://github.com/rust-lang/rust/pull/77489\">https://github.com/rust-lang/rust/pull/77489</a></p>",
        "id": 265821728,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640189329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120518\">Eric Huss</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265734185\">said</a>:</p>\n<blockquote>\n<p><code>./x.py check compiler/...</code> also uses the <code>all_krates</code> function so that passing any path will check the entire compiler, so that's maybe what you're thinking of.</p>\n<p>I think that should probably change to just check the path you pass in.  I don't know why it does the whole compiler.</p>\n</blockquote>\n<p>happy to take a PR for this!</p>",
        "id": 265821807,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640189376
    },
    {
        "content": "<blockquote>\n<p>Eventually I and simulacrum would like to make x.py \"crate-aware\" but right now it's only \"step-aware\", so it will build all crates in the standard library if you specify any of them.</p>\n</blockquote>\n<p>fwiw, I'd personally love to see crate builds get fast enough that there's not much point in being crate-aware but that's maybe an unreachable goal :)</p>",
        "id": 265821808,
        "sender_full_name": "simulacrum",
        "timestamp": 1640189377
    },
    {
        "content": "<blockquote>\n<p>fwiw, I'd personally love to see crate builds get fast enough that there's not much point in being crate-aware but that's maybe an unreachable goal :)</p>\n</blockquote>\n<p>I'm not sure why, though? If you only need the AST parsing, e.g. for building rustfmt, building rustc_middle will <em>always</em> take significantly longer</p>",
        "id": 265821913,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640189414
    },
    {
        "content": "<p>it seems silly to force people to take the compile time hit</p>",
        "id": 265821924,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640189421
    },
    {
        "content": "<p>That's a slightly different thing -- dependency edges to parts of a step.</p>\n<p>But in general if e.g. you could build a full compiler in 5 seconds, then interface wise there's potentially a preference to avoid complexity and prefer fewer options over lots of small bits.</p>",
        "id": 265822970,
        "sender_full_name": "simulacrum",
        "timestamp": 1640190051
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> I would still prefer it to take 2 seconds over 5 seconds if I didn't need the full compiler</p>",
        "id": 265823022,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640190095
    },
    {
        "content": "<p>cc <a href=\"https://github.com/rust-lang/rustc-dev-guide/issues/914\">https://github.com/rust-lang/rustc-dev-guide/issues/914</a> (although it's a little out of date now that the compiler artifacts aren't built by default)</p>",
        "id": 265823717,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640190487
    },
    {
        "content": "<p>I'm wondering why this is so complicated.</p>\n<ul>\n<li>Some of it feels inevitable: the compiler is complicated and so is the bootstrapping process. The staggered std/rustc dance is also inherently challenging.</li>\n<li>Some doesn't: the fact that every subcommand+path combination (including \"no path\") has a separate implementation is... interesting. It means that building a mental model of how subcommands work is pretty much impossible.</li>\n</ul>",
        "id": 265861791,
        "sender_full_name": "nnethercote",
        "timestamp": 1640212332
    },
    {
        "content": "<ul>\n<li>And the reason there are so many paths is that compilation is slow, so there's a lot of desire for fine-grained control over exactly what is compiled, even when there's a risk of bad builds involved (e.g. --keep-stage)</li>\n</ul>",
        "id": 265862907,
        "sender_full_name": "nnethercote",
        "timestamp": 1640213064
    },
    {
        "content": "<p>Oh wow, default stages for different subcommands can be overridden in the config.toml with <code>check-stage</code>, <code>build-stage</code>, <code>test-stage</code>, etc.</p>",
        "id": 265950587,
        "sender_full_name": "nnethercote",
        "timestamp": 1640291201
    },
    {
        "content": "<p>And <code>x.py setup</code> will change those values depending on what profile you select! Oh my goodness. That means you can't write docs explaining what <code>x.py &lt;subcommand&gt;</code> does without reference to what you selected via <code>x.py setup</code>.</p>",
        "id": 265950638,
        "sender_full_name": "nnethercote",
        "timestamp": 1640291277
    },
    {
        "content": "<p>I also don't like how the <code>profile</code> feature refers to other TOML files. I would prefer it if <code>x.py setup</code> just generated the appropriate settings within <code>config.toml</code>.</p>",
        "id": 265950752,
        "sender_full_name": "nnethercote",
        "timestamp": 1640291382
    },
    {
        "content": "<p>Think about this from the docs writer's point of view. \"<code>x.py build</code> does a stage 1 build. Unless you ran <code>x.py setup</code> and chose option (a), which changes the <code>build-stage</code> setting. But it doesn't change it in config.toml, it's buried in src/bootstrap/defaults/config.library.toml which your config.toml refers to via the <code>profile</code> setting.\"</p>",
        "id": 265950894,
        "sender_full_name": "nnethercote",
        "timestamp": 1640291481
    },
    {
        "content": "<p>Is removing <code>[profile]</code> and just generating the appropriate options directly via <code>x.py setup</code> a possibility?</p>",
        "id": 265952200,
        "sender_full_name": "nnethercote",
        "timestamp": 1640292582
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> ^^</p>",
        "id": 265952208,
        "sender_full_name": "nnethercote",
        "timestamp": 1640292589
    },
    {
        "content": "<p>I almost always <code>--stage N</code> to x.py (except for <code>tidy</code>) because I can't remember the defaults.</p>",
        "id": 265955910,
        "sender_full_name": "The 8472",
        "timestamp": 1640295886
    },
    {
        "content": "<p>Me too</p>",
        "id": 265958796,
        "sender_full_name": "nnethercote",
        "timestamp": 1640298168
    },
    {
        "content": "<p>I'm on vacation the next month or so.</p>",
        "id": 265963285,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640302871
    },
    {
        "content": "<p>partly because I'm burned out thinking about bootstrapping</p>",
        "id": 265963316,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640302912
    },
    {
        "content": "<p>I will keep posting here, but I know it's holiday season and I'm not expecting answers from anyone in particular.</p>",
        "id": 265978003,
        "sender_full_name": "nnethercote",
        "timestamp": 1640322997
    },
    {
        "content": "<p>On that note, <a href=\"https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html\">https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html</a> says:</p>\n<blockquote>\n<p>The stage0 compiler is then used only to compile rustbuild, std, and rustc. When compiling rustc, the stage0 compiler uses the freshly compiled std.</p>\n</blockquote>",
        "id": 265978014,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323037
    },
    {
        "content": "<p>I'm pretty sure the second sentence is wrong, that it uses the downloaded std.</p>",
        "id": 265978019,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323054
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265978019\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure the second sentence is wrong, that it uses the downloaded std.</p>\n</blockquote>\n<p>No, it's correct. Rustc only builds with master libstd, that's why it doesn't need cfg(bootstrap).</p>",
        "id": 265978067,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323097
    },
    {
        "content": "<p>I just tested this by changing my local std to print stuff out, and nothing was printed when the first rustc was being compiled. Stuff only started being printed out when the second new std was built.</p>",
        "id": 265978069,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323114
    },
    {
        "content": "<p><a href=\"https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#why-does-only-libstd-use-cfgbootstrap\">https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#why-does-only-libstd-use-cfgbootstrap</a></p>",
        "id": 265978070,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323116
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265978069\">said</a>:</p>\n<blockquote>\n<p>I just tested this by changing my local std to print stuff out, and nothing was printed when the first rustc was being compiled. Stuff only started being printed out when the second new std was built.</p>\n</blockquote>\n<p>rustc is <em>linked</em> to std</p>",
        "id": 265978079,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323133
    },
    {
        "content": "<p>any changes you made to std will only be reflected at runtime</p>",
        "id": 265978082,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265950752\">said</a>:</p>\n<blockquote>\n<p>I also don't like how the <code>profile</code> feature refers to other TOML files. I would prefer it if <code>x.py setup</code> just generated the appropriate settings within <code>config.toml</code>.</p>\n</blockquote>\n<p>this means that changes to the \"default defaults\" won't be reflected, and you'd have to rerun x.py setup to see the changes</p>",
        "id": 265978151,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265861791\">said</a>:</p>\n<blockquote>\n<p>I'm wondering why this is so complicated.</p>\n<ul>\n<li>Some of it feels inevitable: the compiler is complicated and so is the bootstrapping process. The staggered std/rustc dance is also inherently challenging.</li>\n<li>Some doesn't: the fact that every subcommand+path combination (including \"no path\") has a separate implementation is... interesting. It means that building a mental model of how subcommands work is pretty much impossible.</li>\n</ul>\n</blockquote>\n<p>I'm not sure what you mean by a separate implementation? This is no different than how normal build systems work, in a makefile you'd have a separate rule for each target</p>",
        "id": 265978166,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323253
    },
    {
        "content": "<p><code>x.py build path1</code> and <code>x.py  build path2</code> are different <code>Step</code>s, right? And could conceivably do completely different things</p>",
        "id": 265978190,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323308
    },
    {
        "content": "<p>correct, but I'm not sure why you think that's unique to x.py</p>",
        "id": 265978230,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265978069\">said</a>:</p>\n<blockquote>\n<p>I just tested this by changing my local std to print stuff out, and nothing was printed when the first rustc was being compiled. Stuff only started being printed out when the second new std was built.</p>\n</blockquote>\n<p>the proper test is deleting some function rustc uses and seeing whether you get a compile error or not</p>",
        "id": 265978263,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323416
    },
    {
        "content": "<p>So you think <code>x.py build path1</code> and <code>x.py build path2</code> doing completely different things is reasonable? The names chosen for <code>path1</code> and <code>path2</code> look a lot like filesystem paths, but they're actually not. Perhaps that's the problem.</p>",
        "id": 265978352,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323528
    },
    {
        "content": "<p>I don't know what you mean by completely different things, and I resent the implication that bootstrap is doing unreasonable things and intentionally trying to confuse people. <code>build</code> does the minimum amount of work necessary to compile the target.</p>",
        "id": 265978403,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323574
    },
    {
        "content": "<p>what do you mean by \"The names chosen for path1 and path2 look a lot like filesystem paths, but they're actually not\"? what would you rather the model be?</p>",
        "id": 265978431,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323644
    },
    {
        "content": "<p>x.py doesn't enforce internally that target names match filesystem paths, the way <code>make</code> does, but I'm not aware of any examples where the name looks like a path and doesn't match the path on disk.</p>",
        "id": 265978519,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323767
    },
    {
        "content": "<p>Probably just a label without any slashes. Like, all these paths <code>library/std</code> and <code>library/test</code> and <code>library/alloc</code> actually end up meaning the same thing, right? So just <code>std</code> seems better.</p>",
        "id": 265978526,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323773
    },
    {
        "content": "<p><code>x build std</code> works already I'm pretty sure</p>",
        "id": 265978532,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323787
    },
    {
        "content": "<p><code>x doc std</code> certainly does</p>",
        "id": 265978581,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323805
    },
    {
        "content": "<p>From the guide:</p>\n<blockquote>\n<p>Note this is different from any other Rust program: stage1 rustc is built by the beta compiler, but using the master version of libstd!</p>\n</blockquote>\n<p>/me wonders what \"master\" means here</p>",
        "id": 265978589,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323809
    },
    {
        "content": "<p>\"in-tree\"</p>",
        "id": 265978595,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323819
    },
    {
        "content": "<p>thx</p>",
        "id": 265978602,
        "sender_full_name": "nnethercote",
        "timestamp": 1640323829
    },
    {
        "content": "<p>as opposed to the version distributed on the beta or nightly channel</p>",
        "id": 265978607,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323836
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265978532\">said</a>:</p>\n<blockquote>\n<p><code>x build std</code> works already I'm pretty sure</p>\n</blockquote>\n<p>yeah, this works already</p>",
        "id": 265978625,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640323867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265978526\">said</a>:</p>\n<blockquote>\n<p>Probably just a label without any slashes. Like, all these paths <code>library/std</code> and <code>library/test</code> and <code>library/alloc</code> actually end up meaning the same thing, right? So just <code>std</code> seems better.</p>\n</blockquote>\n<p>I agree this is confusing today, but breaking it is a no-go, and warning seems like overkill when it still works fine; especially since I <em>would</em> like them to just build that crate in the future</p>",
        "id": 265978706,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640324019
    },
    {
        "content": "<p>maybe that's what you mean, it's confusing that <code>build library/core</code> is the same as <code>build library/std</code>?</p>",
        "id": 265978714,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640324034
    },
    {
        "content": "<p>As a user, I thought the paths given to <code>x.py build</code> were file system paths. Because they look like file system paths, and all the common ones are file system paths. Which made me think that I could use any file system path as an argument. But then you try something like <code>x.py build library/stdarch</code> and it says \"error: no rules matched library/stdarch\" and then it's like, whoa, what's going on?</p>",
        "id": 265978802,
        "sender_full_name": "nnethercote",
        "timestamp": 1640324145
    },
    {
        "content": "<p>And then I learned they're just hardcoded strings in bootstrap, labels basically.</p>",
        "id": 265978856,
        "sender_full_name": "nnethercote",
        "timestamp": 1640324187
    },
    {
        "content": "<blockquote>\n<p>Which made me think that I could use any file system path as an argument.</p>\n</blockquote>\n<p>this seems like an unreasonable expectation though? like, obviously <code>x build src/ci</code> and <code>x build README.md</code> don't make sense, and at that point it's just a question of where the cutoff happens</p>",
        "id": 265978918,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640324295
    },
    {
        "content": "<p>\"directories that are standalone crates\" seems like a reasonable cutoff to me</p>",
        "id": 265978922,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640324307
    },
    {
        "content": "<p>FWIW I would be ok with changing <code>build library/backtrace</code> to either give a warning or build the standard library, I can see how that particular case is confusing</p>",
        "id": 265979034,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640324466
    },
    {
        "content": "<p>but I don't see why it means the whole model is bad</p>",
        "id": 265979037,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640324474
    },
    {
        "content": "<p>Well, when a user says \"I found this confusing\", you can respond to that in a variety of ways.</p>",
        "id": 265979192,
        "sender_full_name": "nnethercote",
        "timestamp": 1640324704
    },
    {
        "content": "<p>/me should have stayed on vacation</p>",
        "id": 265979410,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1640325021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/265978079\">said</a>:</p>\n<blockquote>\n<p>rustc is <em>linked</em> to std</p>\n</blockquote>\n<p>Ah, it finally clicked, thanks</p>",
        "id": 265980113,
        "sender_full_name": "nnethercote",
        "timestamp": 1640325964
    },
    {
        "content": "<p>FWIW in general I think we've not fully succeeded on the \"filesystem paths\" mapping, but it also feels potentially more discoverable than crate names (and in particular maps well to \"build these UI tests\", for example).</p>\n<p>It's worth noting that many of the steps are actually sharing code (at least for build), and to the extent we can unify it's generally something we should do.</p>\n<p>Across subcommands, we have much less uniform treatment (particularly around stages). I think this may actually be good - for example, if you're building documentation, a local compiler build may not be necessary. One of my hopes is to continue fine tuning download llvm and download rustc options to make it more straightforward to use those, which I think will help unify things since it reduces the need for potentially bad defaults.</p>\n<p>One thought I did have, which is pretty simple but maybe meaningful, is that we could add (or replace) the option for requesting things via stages and what to build with the option of requesting a particular set of outputs, and then we do our best to provide them; for example, maybe something like rustc+std would be equivalent to today's <code>--stage 1 library/std</code>.</p>\n<p>It seems like a good idea regardless of that to add a line to build output of \"what did we produce\" roughly, e.g. pointing users at stage1/bin/rustc.</p>",
        "id": 266000744,
        "sender_full_name": "simulacrum",
        "timestamp": 1640351211
    },
    {
        "content": "<p>An small advantage of using filesystem paths is that your shell autocompletes filesystem paths without having to install any completion script unlike crate names.</p>",
        "id": 266000842,
        "sender_full_name": "bjorn3",
        "timestamp": 1640351296
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Bootstrapping.20questions/near/266000744\">said</a>:</p>\n<blockquote>\n<p>FWIW in general I think we've not fully succeeded on the \"filesystem paths\" mapping, but it also feels potentially more discoverable than crate names (and in particular maps well to \"build these UI tests\", for example).</p>\n</blockquote>\n<p>opened <a href=\"https://github.com/rust-lang/rust/pull/95906\">https://github.com/rust-lang/rust/pull/95906</a> trying to enforce this internally a bit better</p>",
        "id": 278492829,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1649629257
    }
]