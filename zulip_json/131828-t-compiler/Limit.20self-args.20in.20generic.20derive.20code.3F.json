[
    {
        "content": "<p>I noticed that the code generated by e.g. #[derive(PartialEq)] is not really good for things like Option&lt;char&gt;, i.e. an enum with two variants and a non-zero niche value. One reason for this is the duplicated discriminant generation (once for the equality check and once for the match) that LLVM can't always eliminate. Additionally, LLVM trips over the \"if true &amp;&amp; ...\" part, the extra BBs/conditional jumps somehow break some optimizations. I have a WIP fix for both (tests are still missing), but  I wonder whether we could simplify the code by limiting self args to two. Currently the code supports an arbitrary number of self args, which seems unnecessary. Is there anything that actually needs that or can I simplify the code there?</p>",
        "id": 223053995,
        "sender_full_name": "Björn Steinbrink",
        "timestamp": 1610904852
    },
    {
        "content": "<p>what do you mean by 'an arbitrary number of self args'?</p>",
        "id": 223054017,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610904920
    },
    {
        "content": "<p>\"self_args\" is the name used in the code. These are the args that have type Self in the method definition. e.g. Hash has one self arg, PartialEq has two, etc. The generic deriving code generates a match to generate individual arms for each variant, iff all self args have the same variant, plus one for mismatching variants, is applicable</p>",
        "id": 223054323,
        "sender_full_name": "Björn Steinbrink",
        "timestamp": 1610905333
    },
    {
        "content": "<p>this sounds like the sort of question to ask the reviewer of the code</p>",
        "id": 223054402,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610905450
    },
    {
        "content": "<p>I don't think I can answer it without seeing the changes</p>",
        "id": 223054403,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610905457
    },
    {
        "content": "<p>Thanks, but in that case, I'd like to get feedback from someone who's familiar with that area of the compiler before I put in a significant amount of time to refactor it just to be told by a reviewer that the refactoring was pointless due to a use case that was not obvious to me</p>",
        "id": 223073184,
        "sender_full_name": "Björn Steinbrink",
        "timestamp": 1610932395
    },
    {
        "content": "<p>I think if we observe benefits from special casing N self-args, we would likely land that PR - even if the generic code path is actually necessary.</p>",
        "id": 223073879,
        "sender_full_name": "simulacrum",
        "timestamp": 1610933551
    },
    {
        "content": "<p>I ran a build and tests with <code>assert!(self_args.len() &lt; 3)</code> which succeeded, so I guess now the better question is whether that code is exposed or reused somewhere outside the compiler, maybe any of the proc macro related crates?</p>",
        "id": 223111469,
        "sender_full_name": "Björn Steinbrink",
        "timestamp": 1610971499
    },
    {
        "content": "<p>The compiler API is unstable, so if all the tests pass it's fine to make the change. Have you tried a derive with more than 3 variants to make sure it works?</p>",
        "id": 223121495,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1610977853
    },
    {
        "content": "<p>Did you mean self args? Since variants don' factor into this AFAICT. Either way, there are no derives with more than 2 self args, but some have more args in total (args are split between Self type and others). Also my other changes need to take into account the number of fieldless variants in particular and differentiate between enums with varying numbers of variants, so yeah, I tested that with enums with up to 4 variants in different combinations.</p>",
        "id": 223131385,
        "sender_full_name": "Björn Steinbrink",
        "timestamp": 1610982509
    }
]