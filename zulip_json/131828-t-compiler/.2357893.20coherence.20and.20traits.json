[
    {
        "content": "<p>hi @RalfJung</p>",
        "id": 169073560,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561578351
    },
    {
        "content": "<p>what do you mean by \"assuming coherence\" exactly</p>",
        "id": 169073608,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561578363
    },
    {
        "content": "<p>It seems like a basic rule of Rust that we want to keep that it is possible to follow impls. e.g., with IntoIterator, you really want typeck to be able to assume that &lt;T as IntoIterator&gt;::Item = U := T: Iterator, &lt;T as Iterator&gt;::Item = U.</p>",
        "id": 169073651,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561578398
    },
    {
        "content": "<p>(pinging <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> so he sees this ^)</p>",
        "id": 169077447,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1561581285
    },
    {
        "content": "<blockquote>\n<p>It seems like a basic rule of Rust that we want to keep that it is possible to follow impls. e.g., with IntoIterator, you really want typeck to be able to assume that &lt;T as IntoIterator&gt;::Item = U := T: Iterator, &lt;T as Iterator&gt;::Item = U.</p>\n</blockquote>\n<p>that's exactly what I mean by \"exploiting coherence\"</p>",
        "id": 169078849,
        "sender_full_name": "RalfJ",
        "timestamp": 1561582383
    },
    {
        "content": "<p>it's very useful and very subtle and makes analysis very complicated</p>",
        "id": 169078861,
        "sender_full_name": "RalfJ",
        "timestamp": 1561582395
    },
    {
        "content": "<p>which is why I wrote</p>\n<blockquote>\n<p>But there's likely already tons of code out there that exploits this.</p>\n</blockquote>",
        "id": 169078895,
        "sender_full_name": "RalfJ",
        "timestamp": 1561582429
    },
    {
        "content": "<p>so this is likely a moot point</p>",
        "id": 169078900,
        "sender_full_name": "RalfJ",
        "timestamp": 1561582434
    },
    {
        "content": "<p>but if this were pre-1.0 I would argue fiercly against doing what we are doing ;)</p>",
        "id": 169078953,
        "sender_full_name": "RalfJ",
        "timestamp": 1561582449
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> <span class=\"user-mention\" data-user-id=\"126804\">@Ariel Ben-Yehuda</span>   (also keep pinging me, I have t-compiler muted because there is too much traffic and Zulip does not support unmuting just one topic in a stream)<br>\n(also who is the real ariel?^^)</p>",
        "id": 169079013,
        "sender_full_name": "RalfJ",
        "timestamp": 1561582504
    },
    {
        "content": "<p>Haskell does allow something similar:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cm\">{-# LANGUAGE TypeFamilies, MultiParamTypeClasses, FlexibleInstances #-}</span>\n\n<span class=\"kr\">class</span> <span class=\"kt\">Object</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"kr\">where</span>\n  <span class=\"kr\">type</span> <span class=\"kt\">Output</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"ow\">::</span> <span class=\"o\">*</span>\n\n<span class=\"kr\">instance</span> <span class=\"kt\">Object</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"kr\">where</span>\n  <span class=\"kr\">type</span> <span class=\"kt\">Output</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"ow\">=</span> <span class=\"n\">u</span>\n\n<span class=\"nf\">foo</span> <span class=\"ow\">::</span> <span class=\"kt\">Output</span> <span class=\"n\">t</span> <span class=\"n\">u</span> <span class=\"ow\">-&gt;</span> <span class=\"n\">u</span>\n<span class=\"nf\">foo</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"n\">x</span>\n</pre></div>",
        "id": 169079734,
        "sender_full_name": "centril",
        "timestamp": 1561582999
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <br>\nI accidentally created a new zulip account. Probably a github vs. google login problem.</p>",
        "id": 169081207,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584006
    },
    {
        "content": "<blockquote>\n<p>it's very useful and very subtle and makes analysis very complicated</p>\n</blockquote>\n<p>I think it's hard to work with associated types without this</p>",
        "id": 169081334,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584106
    },
    {
        "content": "<p>unless there is some restricted version of this rule that works, I don't see how you could use associated types in a generic context otherwise</p>",
        "id": 169081506,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584223
    },
    {
        "content": "<p>you just have to state the assumptions you are making?</p>",
        "id": 169081633,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584284
    },
    {
        "content": "<p>on the function?</p>",
        "id": 169081642,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584290
    },
    {
        "content": "<p>we would have stabilized equality constraints much sooner in that alternative universe ;)</p>",
        "id": 169081655,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584296
    },
    {
        "content": "<p>but then you can't use \"new\" associated types</p>",
        "id": 169081657,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584297
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> wait doesnt haskell also have a flag to allow overlapping instances...?</p>",
        "id": 169081676,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584312
    },
    {
        "content": "<p>consider that <code>T: Sized</code> is a bound</p>",
        "id": 169081704,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> not sure what you mean</p>",
        "id": 169081706,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584329
    },
    {
        "content": "<p>I mean, suppose you have a function that takes a generic <code>T</code></p>",
        "id": 169081721,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Yeah but don't ever use it</p>",
        "id": 169081729,
        "sender_full_name": "centril",
        "timestamp": 1561584352
    },
    {
        "content": "<p>it needs to be able to evaluate <code>&lt;Vec&lt;T&gt; as IntoIterator&gt;::Item</code></p>",
        "id": 169081733,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584353
    },
    {
        "content": "<p>or <code>&lt;slice::Iter&lt;'a, T&gt; as IntoIterator&gt;::Item</code></p>",
        "id": 169081795,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584374
    },
    {
        "content": "<p>that's an opaque type at that point</p>",
        "id": 169081801,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584376
    },
    {
        "content": "<p>if you couldn't do <code>&lt;Vec&lt;T&gt; as IntoIterator&gt;::Item = T</code>, then <code>IntoIterator</code> wouldn't be very useful</p>",
        "id": 169081830,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584402
    },
    {
        "content": "<p>I mean, for a generic <code>T: Sized</code></p>",
        "id": 169081839,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584409
    },
    {
        "content": "<p>then add that as a <code>where</code> clause</p>",
        "id": 169081860,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584429
    },
    {
        "content": "<p><em>every function</em> that takes a <code>T: Sized</code> also needs a <code>&lt;Vec&lt;T&gt; as IntoIterator&gt;::Item = T</code> where-clause?</p>",
        "id": 169081882,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584449
    },
    {
        "content": "<p>(that's what someone else suggested in the thread, basically interpret our current scheme as adding all those <code>where</code> clauses implicitly)</p>",
        "id": 169081909,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584470
    },
    {
        "content": "<p>I suppose you'll also want a <code>Vec&lt;Option&lt;T&gt;&gt; as IntoIterator&gt;::Item = Option&lt;T&gt;</code></p>",
        "id": 169081913,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584475
    },
    {
        "content": "<p>that would be a very complicated family of where-clauses</p>",
        "id": 169081978,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584495
    },
    {
        "content": "<p>hm I see, you are saying that constraint would have to bubble up way beyond the code that actually does the iteration</p>",
        "id": 169082016,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584537
    },
    {
        "content": "<p>I mean, if you couldn't reduce it to \"where all the impls in this crate hold\"</p>",
        "id": 169082018,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584538
    },
    {
        "content": "<p>which is the state we have today :-)</p>",
        "id": 169082031,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584549
    },
    {
        "content": "<p>so maybe this is less practical than I thought...</p>",
        "id": 169082184,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584671
    },
    {
        "content": "<p>I mean, you could prohibit associated types in structs</p>",
        "id": 169082196,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584684
    },
    {
        "content": "<p>*in item fields</p>",
        "id": 169082202,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584690
    },
    {
        "content": "<p>but the alternative seems to be to consider the implicit <code>impl Trait for dyn Trait</code> a real impl in terms of coherence, which would reject plenty of generic impls</p>",
        "id": 169082228,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584706
    },
    {
        "content": "<blockquote>\n<p>but the alternative seems to be to consider the implicit <code>impl Trait for dyn Trait</code> a real impl in terms of coherence, which would reject plenty of generic impls</p>\n</blockquote>\n<p>or do \"impl priority\" where it only holds if there is no other impl, or some hack like that</p>",
        "id": 169082302,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584735
    },
    {
        "content": "<p>I prefer having to specify explicitly whether a trait is object-safe to not having associated types in struct fields</p>",
        "id": 169082336,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584763
    },
    {
        "content": "<p>even from a blank-slate POV</p>",
        "id": 169082343,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584773
    },
    {
        "content": "<p>(not that \"having to specify explicitly whether a trait is object-safe\" is a good idea)</p>",
        "id": 169082359,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584782
    },
    {
        "content": "<blockquote>\n<p>or do \"impl priority\" where it only holds if there is no other impl, or some hack like that</p>\n</blockquote>\n<p>this needs chalk and a proof or I dont believe it to be sound^^</p>",
        "id": 169082388,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584800
    },
    {
        "content": "<blockquote>\n<p>(not that \"having to specify explicitly whether a trait is object-safe\" is a good idea)</p>\n</blockquote>\n<p>that's actually a great idea</p>",
        "id": 169082415,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <br>\nthe most basic form would be having a <code>dyn Trait</code> be non-object-safe if it has a blanket impl</p>",
        "id": 169082418,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584825
    },
    {
        "content": "<p>also in terms of semver where today you can accidentally break rev dependencies by changing a trait from obj-safe to not-obj-safe</p>",
        "id": 169082476,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584843
    },
    {
        "content": "<p>I have seen people asking for an explicit annotation like that before</p>",
        "id": 169082508,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584857
    },
    {
        "content": "<p>that might be the solution area</p>",
        "id": 169082525,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584871
    },
    {
        "content": "<blockquote>\n<p>I prefer having to specify explicitly whether a trait is object-safe to not having associated types in struct fields</p>\n</blockquote>\n<p>why would struct fields be special here?</p>",
        "id": 169082534,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584876
    },
    {
        "content": "<blockquote>\n<p>why would struct fields be special here?</p>\n</blockquote>\n<p>if item fields don't have associated types, you \"sort of don't need associated types\"</p>",
        "id": 169082552,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584896
    },
    {
        "content": "<p>you could stay in the pre-1.0 world where everything was type parameters and HRTBs</p>",
        "id": 169082575,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584907
    },
    {
        "content": "<p>and a bit of inference magic</p>",
        "id": 169082582,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561584913
    },
    {
        "content": "<p>that sounds... surprising?</p>",
        "id": 169082619,
        "sender_full_name": "RalfJ",
        "timestamp": 1561584951
    },
    {
        "content": "<p>I mean, when you have a <code>trait Foo { type Assoc; }</code>, you can translate it to <code>trait Foo {}. trait Foo2&lt;Assoc&gt;; \"forall&lt;T&gt; T: Foo -&gt; exists U. T: Foo2&lt;U&gt;\"</code></p>",
        "id": 169082711,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585002
    },
    {
        "content": "<p>i.e., just give up on associated type uniqueness</p>",
        "id": 169082724,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585020
    },
    {
        "content": "<p>but didnt you just argue above that that would be awful for e.g. <code>&lt;Vec&lt;T&gt; as IntoIterator&gt;::Item</code>?</p>",
        "id": 169082763,
        "sender_full_name": "RalfJ",
        "timestamp": 1561585052
    },
    {
        "content": "<p>I mean, in that place, type inference can pick the impl associated type</p>",
        "id": 169082769,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585065
    },
    {
        "content": "<p>and it does not matter whether there is any <em>other</em> impl</p>",
        "id": 169082776,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585076
    },
    {
        "content": "<p>(you also need to move all trait-items to the \"most detailed\" trait)</p>",
        "id": 169082827,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585099
    },
    {
        "content": "<p>(or parameterize them or something)</p>",
        "id": 169082836,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585110
    },
    {
        "content": "<p>that was what rust did before 1.0</p>",
        "id": 169082876,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585157
    },
    {
        "content": "<p>and I think this is basically Haskell without TypeFamilies</p>",
        "id": 169082898,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585185
    },
    {
        "content": "<p>which is a language that you can do things in</p>",
        "id": 169082905,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585193
    },
    {
        "content": "<p>and the main problem is basically \"putting associated types in structs\"</p>",
        "id": 169082914,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585202
    },
    {
        "content": "<blockquote>\n<p>and it does not matter whether there is any <em>other</em> impl</p>\n</blockquote>\n<p>oh I see... the case that wouldn't work though is <code>fn foo&lt;T&gt;(t: &lt;T as Iterator&gt;::Item) -&gt; &lt;T as IntoIterator&gt;::Item where T: Iterator + IntoIterator</code></p>",
        "id": 169083114,
        "sender_full_name": "RalfJ",
        "timestamp": 1561585328
    },
    {
        "content": "<p>because then you dont know which impl it is</p>",
        "id": 169083120,
        "sender_full_name": "RalfJ",
        "timestamp": 1561585334
    },
    {
        "content": "<p>so maybe we can just rule out <em>that</em> kind of \"expoitingcoherence\"? or does your other example in the issue show that that's not enough?</p>",
        "id": 169083148,
        "sender_full_name": "RalfJ",
        "timestamp": 1561585358
    },
    {
        "content": "<blockquote>\n<p>because then you dont know which impl it is</p>\n</blockquote>\n<p>sure, and in that case you'll need an extra equality clause</p>",
        "id": 169083177,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585389
    },
    {
        "content": "<blockquote>\n<p>so maybe we can just rule out <em>that</em> kind of \"expoitingcoherence\"? or does your other example in the issue show that that's not enough?</p>\n</blockquote>\n<p>I think that once you have associated types in struct fields, you need full coherence</p>",
        "id": 169083214,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585415
    },
    {
        "content": "<p>or a struct could require you to \"commit\" to all of the types of its fields, but that would be ugly</p>",
        "id": 169083323,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585475
    },
    {
        "content": "<p>so yea I think T-lang should come up with the solution for <a href=\"https://github.com/rust-lang/rust/issues/57893\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/57893\">#57893</a></p>",
        "id": 169083441,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585553
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> by \"coherence\" do you mean \"every different valid typing derivation of a program leads to a resulting program that has the same dynamic semantics\" or do you mean canonicity (global uniqueness)? I assume the latter</p>",
        "id": 169083517,
        "sender_full_name": "centril",
        "timestamp": 1561585592
    },
    {
        "content": "<p>I mean unique associated type resolution</p>",
        "id": 169083540,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585610
    },
    {
        "content": "<p>for every concrete associated trait-ref <code>&lt;Foo as Bar&gt;::Baz</code>, there is exactly 1 way to resolve it</p>",
        "id": 169083576,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585640
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> I'll need to digest your example on the issue tomorrow then... too tired now ^^</p>",
        "id": 169083678,
        "sender_full_name": "centril",
        "timestamp": 1561585727
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span>  Anyways, we've booked a lang team meeting for <a href=\"https://github.com/rust-lang/rust/issues/57893\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/57893\">#57893</a> on the 11th of July; there's an entry on the lang team calendar if you want to join (which would be great)</p>",
        "id": 169083816,
        "sender_full_name": "centril",
        "timestamp": 1561585839
    },
    {
        "content": "<p>which time is that?</p>",
        "id": 169083829,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585854
    },
    {
        "content": "<p>(btw, if we treat methods as associated trait-refs, that description of coherence explains why incoherent marker traits are not a problem - still every ATR resolves in exactly 1 way)</p>",
        "id": 169083874,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561585911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> 21:00 CEST I believe (summer time is tricky... check the calendar :D )</p>",
        "id": 169084065,
        "sender_full_name": "centril",
        "timestamp": 1561586078
    },
    {
        "content": "<p>it says 15:00 boston time, which is indeed 21:00 CEST</p>",
        "id": 169084110,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561586151
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> so looking at your example, adding <code>where dyn Object&lt;U, Output = T&gt;: Object&lt;U, Output = T&gt;,</code> to <code>iso1</code> solves nothing; A constraint <code>where dyn Object&lt;U, Output = T&gt;: Object&lt;U, Output = V&gt;,</code>  on <code>transmute_m</code> would solve things but to do that you'd need to look inside <code>transmute_m</code> which would be very ungreat in terms of the phase separation of the current compiler</p>",
        "id": 169112490,
        "sender_full_name": "centril",
        "timestamp": 1561622781
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span>  Oh but interestingly, if we add <code>X: Object&lt;U, Output = V&gt;</code> to <code>iso2</code> we make <code>transmute_m</code> not type check. <em>This</em> assumption can be deduced purely from the signature of <code>iso2</code> so we do not have to ruin phase separation</p>",
        "id": 169112854,
        "sender_full_name": "centril",
        "timestamp": 1561623170
    },
    {
        "content": "<p>From what I can tell this comes down to a question of  increased compile-times + a-more-trusted-analysis (adding new proof obligations when derivations from coherence are made) vs. giving up on some sound code and losing out on completeness (object safety taking blanket impls into account)</p>",
        "id": 169113683,
        "sender_full_name": "centril",
        "timestamp": 1561623894
    },
    {
        "content": "<p>Yeah <code>iso2</code> is the \"bad\" one there I think</p>",
        "id": 169116854,
        "sender_full_name": "RalfJ",
        "timestamp": 1561626793
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> In the sense that it is not requiring things it should from its callers (which really makes <code>transmute_m</code> the bit that would stop type checking)</p>",
        "id": 169117104,
        "sender_full_name": "centril",
        "timestamp": 1561626970
    },
    {
        "content": "<p>yes</p>",
        "id": 169117375,
        "sender_full_name": "RalfJ",
        "timestamp": 1561627221
    },
    {
        "content": "<p>@RalfJ @centril do you have a principled rule?</p>\n<p>I think we have 4 classes of options for fixing things here:<br>\n1. Making the blanket impl a coherence violation, which might have bad back-compat consequences, and is somewhat hard to implement in the compiler today (because of the <code>dyn Trait+AnySetOfSubtraits</code> problem, and also the <code>for&lt;'a&gt; dyn Trait&lt;'a&gt;</code> problem, unless we already modified coherence such that it is eqty to <code>dyn Trait&lt;'a&gt;</code> in coherence).<br>\n2. Making <code>iso_1</code> be illegal in its current form (\"requiring it to have an extra where-clause\"). In Chalk terms, the rule <code>iso_1</code> uses is the  <code>&lt;dyn Object&lt;U, Output=T&gt; as Object&lt;U, Output=T&gt;&gt;::Output = T :-</code>, the <code>ObjectCandidate</code> in rustc terms.<br>\n    I think it is possible to allow the <code>ObjectCandidate</code> rule only if there are no potentially-conflicting impls. One way of doing it would be to make <code>Trait</code> non-object-safe (in Rust terms), using the coherence conflict as the justificataion.<br>\n3. Making <code>iso_2</code> be illegal in its current form (\"requiring it to have an extra where-clause\"). In Chalk terms, the rule <code>iso_2</code> uses is <code>&lt;T as Object&lt;U&gt;&gt;::Output = V := U: Mark, &lt;U as Mark&gt;::Output = V</code>. This is very similar to the rule that allows you to work with <code>IntoIterator</code>, so I don't think it is a good idea to get rid of it, unless you have a principled exception in mind.<br>\n4. Making <code>transmute_m</code> illegal. ~~I can't think of a way of doing this that doesn't also make <code>iso_1</code> directly illegal.<br>\n~~ Actually, if we consider the \"object impl\" to be an implied bound on the object ADT, then the equivalent of <code>2.</code> would prohibit <code>transmute_m</code> rather than <code>iso_1</code>, because <code>iso_1</code> would get what it needs through an implied bound and not need the <code>ObjectCandidate</code>.</p>\n<p>How do your ideas fit in this mold?</p>",
        "id": 169241943,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561740820
    },
    {
        "content": "<p>@RalfJung <span class=\"user-mention\" data-user-id=\"126931\">@centril</span> </p>\n<p>so I think what you wrote is basically a variant of <code>3.</code>, except it would add an \"implicit\" <code>X: Object&lt;U, Output = V&gt;</code> bound to <code>iso_2</code> to make it \"work again\". Do you  have a principled way of doing it?</p>",
        "id": 169242177,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561740997
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 169242190,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741007
    },
    {
        "content": "<p>I'm afraid I dont have anything principled to say here</p>",
        "id": 169242331,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741140
    },
    {
        "content": "<p>I have an intuition from thinking about modelling traits in lambda-rust, but we haven't modeled them yet</p>",
        "id": 169242358,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741171
    },
    {
        "content": "<p>and I know nothing about how rustc/chalk actually implements all the trait rules</p>",
        "id": 169242372,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741182
    },
    {
        "content": "<p>sure, I think the precise modeling of trait objects is important here</p>",
        "id": 169242377,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741188
    },
    {
        "content": "<p>absolutely</p>",
        "id": 169242456,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741233
    },
    {
        "content": "<p>every time some knocks on derek's door that's one of the projects he is proposing ;)</p>",
        "id": 169242480,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741258
    },
    {
        "content": "<p>but so far people picked other projects</p>",
        "id": 169242490,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741264
    },
    {
        "content": "<p>my intuition here is that <code>iso_2</code> is sneakily hiding an assumption that it is making... <code>iso_1</code> seems perfectly fine to me, after all it specifically asked for this associated type</p>",
        "id": 169242523,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741287
    },
    {
        "content": "<p>All I can say is... we need to steal Stephanie Weirich, Richard Eisenberg, and more Haskell folks ;)</p>",
        "id": 169242666,
        "sender_full_name": "centril",
        "timestamp": 1561741394
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> so I think mine (our?) thinking is that we do 4. by adding an implicit <code>V == &lt;X as Object&lt;U&gt;&gt;::Output</code> eq-constraint</p>",
        "id": 169242779,
        "sender_full_name": "centril",
        "timestamp": 1561741462
    },
    {
        "content": "<p>@centril I consider it a form of 3.</p>",
        "id": 169242794,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741477
    },
    {
        "content": "<p>or of 2</p>",
        "id": 169242806,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741483
    },
    {
        "content": "<p>actually, forbidding you from proving <code>WF(dyn Object&lt;U, Output=T&gt;)</code> would be a form of 4. that might not be 2.</p>",
        "id": 169242869,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741539
    },
    {
        "content": "<p>Well it revolves around <code>iso2</code>; I agree with <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  that <code>iso2</code> is not properly propagating its assumption</p>",
        "id": 169242870,
        "sender_full_name": "centril",
        "timestamp": 1561741540
    },
    {
        "content": "<p>because <code>2</code> would get <code>WF(dyn Object&lt;U, Output=T&gt;)</code> as an assumption, and therefore it wouldn't need to prove it</p>",
        "id": 169242948,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741568
    },
    {
        "content": "<p>what happened to the idea that one can do <code>#[dyn] trait { ... }</code> and doing so makes coherence consider the implicit impl, thereby ruling out the blanket impl in your example?</p>",
        "id": 169243137,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span>  as for \"how do we do this\"... I'm thinking that \"when we assume a blanket impl in a signature we also add a constraint for that assumption to said signature\"</p>",
        "id": 169243147,
        "sender_full_name": "centril",
        "timestamp": 1561741698
    },
    {
        "content": "<p>i guess that would be a variant of 1)</p>",
        "id": 169243157,
        "sender_full_name": "RalfJ",
        "timestamp": 1561741702
    },
    {
        "content": "<p>but that might be awfully hand-wavy</p>",
        "id": 169243179,
        "sender_full_name": "centril",
        "timestamp": 1561741721
    },
    {
        "content": "<p>@RalfJ that's 1.</p>",
        "id": 169243213,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741756
    },
    {
        "content": "<p>@centril but you don't assume the blanket impl in the signature</p>",
        "id": 169243262,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741800
    },
    {
        "content": "<p>I suppose we might ask the Chalk people <span class=\"user-mention\" data-user-id=\"131694\">@scalexm</span></p>",
        "id": 169243421,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561741891
    },
    {
        "content": "<p>Then I don't get how:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">iso_2</span><span class=\"o\">&lt;</span><span class=\"n\">X</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">data</span>: <span class=\"nc\">Data</span><span class=\"o\">&lt;</span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">V</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">U</span>: <span class=\"nc\">Mark</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// similarly, this shouldn&#39;t &quot;see&quot; the trait-object impl.</span>\n<span class=\"w\">    </span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>can type-check</p>",
        "id": 169243623,
        "sender_full_name": "centril",
        "timestamp": 1561742009
    },
    {
        "content": "<p>Removing:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span>: <span class=\"nc\">Mark</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Object</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">V</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>makes <code>fn iso2</code> not type-check</p>",
        "id": 169243659,
        "sender_full_name": "centril",
        "timestamp": 1561742032
    },
    {
        "content": "<p>This notably does not rely on the body of <code>iso2</code>; if you replace it with <code>panic!()</code> and remove either <code>U: Mark&lt;Output = V&gt;</code> or the blanket impl it won't type check</p>",
        "id": 169243832,
        "sender_full_name": "centril",
        "timestamp": 1561742124
    },
    {
        "content": "<p>Yea it requires an <code>X: Object&lt;U&gt;</code> bound</p>",
        "id": 169243952,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561742212
    },
    {
        "content": "<p>and because of a weird rustc limitation, a <code>X: Object&lt;U&gt;</code> requires you to specify <code>V</code></p>",
        "id": 169243977,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561742228
    },
    {
        "content": "<p>but perhaps that rustc limitation could be formalized</p>",
        "id": 169244000,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561742248
    },
    {
        "content": "<p>but in an implied bounds setting, <code>iso_2</code> would compile and the <code>X: Object&lt;U&gt;</code> bound would be passed to the caller</p>",
        "id": 169244088,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561742292
    },
    {
        "content": "<p>(in fact, today, <code>transmute_m</code> already has to prove <code>X: Object&lt;U&gt;</code>)</p>",
        "id": 169244133,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561742330
    },
    {
        "content": "<p>Propagating these assumed un-propagated constraints may however be expensive... I would suggest that we try the various 1-4 strategies, <code>@craterbot</code> and <code>@rust-timer build</code> them and see what falls out</p>",
        "id": 169244153,
        "sender_full_name": "centril",
        "timestamp": 1561742344
    },
    {
        "content": "<p>so I'm still thinking whether there is a way to abuse the absence of coherence</p>",
        "id": 169245709,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561743422
    },
    {
        "content": "<p>or rather, of figuring out a sound/allows-all-the-code-we-want-compiling--to-compile rule, or why we don't want such a rule</p>",
        "id": 169245861,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561743544
    },
    {
        "content": "<p>of course, the general boogeyman of these would be specialization</p>",
        "id": 169245904,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561743575
    },
    {
        "content": "<p>but we still have no idea when specialization is sound, so I'll rather not try to rely on it</p>",
        "id": 169245923,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561743593
    },
    {
        "content": "<p>So I think I found a hole in my naïve attempt to implement <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>'s suggestion: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=dc1bdbf5d59a3dba86fa3c9ece8556fc\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=dc1bdbf5d59a3dba86fa3c9ece8556fc\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=dc1bdbf5d59a3dba86fa3c9ece8556fc</a></p>",
        "id": 169260721,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561754818
    },
    {
        "content": "<p>there's no way to see <code>Object</code> in the signature of <code>iso_2</code>, because it gets wrapped in the <code>HidingPlace</code></p>",
        "id": 169260787,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561754872
    },
    {
        "content": "<p>Thanks <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  I'll read it tomorrow</p>",
        "id": 169260860,
        "sender_full_name": "centril",
        "timestamp": 1561754910
    },
    {
        "content": "<p><code>iso_2</code> still stops type-checking without the blanket impl though</p>",
        "id": 169260937,
        "sender_full_name": "RalfJ",
        "timestamp": 1561754970
    },
    {
        "content": "<p>@RalfJ sure it does</p>",
        "id": 169261243,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755229
    },
    {
        "content": "<p>but what can you do with it?</p>",
        "id": 169261248,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755233
    },
    {
        "content": "<p>I mean, you don't want type inference to depend on function bodies</p>",
        "id": 169261317,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755269
    },
    {
        "content": "<p>*function signatures to depend on function bodies</p>",
        "id": 169261322,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755275
    },
    {
        "content": "<p>it doesnt have to -- but (and I think I said that in the issue) it would have to basically aggressively collect all the facts that the body <em>might</em> use and add them to the \"signature\"</p>",
        "id": 169261356,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755313
    },
    {
        "content": "<blockquote>\n<ul>\n<li>but (and I think I said that in the post) it would have to basically aggressively collect all the facts that the body might use and add them to the \"signature\"</li>\n</ul>\n</blockquote>\n<p>That means that type inference depends on function bodies</p>",
        "id": 169261369,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755340
    },
    {
        "content": "<p>I have no idea if that is even remotely practical</p>",
        "id": 169261375,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755346
    },
    {
        "content": "<p>and I expect it to have weird effects with things like <code>IntoIterator</code></p>",
        "id": 169261376,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755348
    },
    {
        "content": "<p>hu, how that?</p>",
        "id": 169261377,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755349
    },
    {
        "content": "<p>I mean, to see whether <code>iso_2</code> typechecks, you have to see the body of <code>iso_2</code></p>",
        "id": 169261427,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755366
    },
    {
        "content": "<p>plus, you can make <code>iso_2</code> a trait function</p>",
        "id": 169261434,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755375
    },
    {
        "content": "<p>so you can't do \"naive\" propagation</p>",
        "id": 169261438,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755386
    },
    {
        "content": "<p>I said none of that</p>",
        "id": 169261448,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755402
    },
    {
        "content": "<p>I said collect all facts it <em>might</em> use</p>",
        "id": 169261453,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755409
    },
    {
        "content": "<p>without knowing what it actually <em>does</em> use</p>",
        "id": 169261455,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755415
    },
    {
        "content": "<p>basically going forward from the where clauses we got, what are all the things we can deduce? these all become part of the \"signature\"</p>",
        "id": 169261475,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755444
    },
    {
        "content": "<p>and again, I have no idea if that's even remotely practical ;)</p>",
        "id": 169261481,
        "sender_full_name": "RalfJ",
        "timestamp": 1561755453
    },
    {
        "content": "<p>That feels like it could blow up very easily in terms of compile times ^^</p>",
        "id": 169261562,
        "sender_full_name": "centril",
        "timestamp": 1561755494
    },
    {
        "content": "<p>I mean, if you go by the \"might use\" idea, you can notice that  you have a coherence violation</p>",
        "id": 169261568,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755498
    },
    {
        "content": "<p><em>everything</em> \"might use\" a coherence violation</p>",
        "id": 169261577,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755509
    },
    {
        "content": "<p>which means that code with a coherence violation does not compile</p>",
        "id": 169261583,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755517
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span></p>\n<blockquote>\n<p>That means that type inference depends on function bodies</p>\n</blockquote>\n<p>I'm not opposed to this <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 169261592,
        "sender_full_name": "centril",
        "timestamp": 1561755531
    },
    {
        "content": "<p>I know everyone else is tho</p>",
        "id": 169261611,
        "sender_full_name": "centril",
        "timestamp": 1561755539
    },
    {
        "content": "<blockquote>\n<p>I'm not opposed to this </p>\n</blockquote>\n<p>This doesn't scale to traits. Suppose you have</p>\n<div class=\"codehilite\"><pre><span></span>trait Iso2 {\nfn iso_2&lt;X: ?Sized, U, V, D&gt;(data: D) -&gt; V\n    where U: Mark&lt;Output=V&gt;, D: HidingPlace&lt;X, U&gt;;\n}\n\nimpl Iso2 for MyIso2 {\n    ...\n}\n\ntrait TransmuteM {\nfn transmute_m&lt;T, U, V, I: Iso2&gt;(data: T) -&gt; V\n    where U: Mark&lt;Output=V&gt;;\n}\n\nimpl TransmuteM for MyTransmuteM {\nfn transmute_m&lt;T, U, V, I: Iso2&gt;(data: T) -&gt; V\n    where U: Mark&lt;Output=V&gt; { /* ... */ }\n}\n</pre></div>",
        "id": 169261644,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755587
    },
    {
        "content": "<p>(Is there anything in particular that Rust has that Haskell doesn't here apart from type based dispatch with methods?)</p>",
        "id": 169261829,
        "sender_full_name": "centril",
        "timestamp": 1561755721
    },
    {
        "content": "<p>(Given that Haskell does have global type inference)</p>",
        "id": 169261886,
        "sender_full_name": "centril",
        "timestamp": 1561755734
    },
    {
        "content": "<p>The problem here is not global type inference</p>",
        "id": 169261899,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755744
    },
    {
        "content": "<p>I don't think typeclasses in haskell have type inference</p>",
        "id": 169261911,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755757
    },
    {
        "content": "<p><code>TransmuteM</code> would be a typeclass in Haskell</p>",
        "id": 169261923,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755768
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span>  type class definitions and instance heads do not; functions certainly do infer type class constraints in Haskell</p>",
        "id": 169262049,
        "sender_full_name": "centril",
        "timestamp": 1561755844
    },
    {
        "content": "<p>@centril sure, but here what you want is for the constraint on the body of <code>MyIso2</code> to somehow transfer to the typeclass definition for the trait <code>Iso2</code></p>",
        "id": 169262085,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755882
    },
    {
        "content": "<p>I'll need to look at your newest example more carefully tomorrow and get back to you <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 169262147,
        "sender_full_name": "centril",
        "timestamp": 1561755945
    },
    {
        "content": "<p>ok</p>",
        "id": 169262200,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561755963
    },
    {
        "content": "<p>And my next obstacle to iso-2-blaming: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b96e34ea38383adabe1850d049e9e9b0\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b96e34ea38383adabe1850d049e9e9b0\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b96e34ea38383adabe1850d049e9e9b0</a></p>",
        "id": 169305934,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561829763
    },
    {
        "content": "<p>which \"hides\" the evidence for <code>Mark</code> by using <code>MarkWitness</code></p>",
        "id": 169305938,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561829782
    },
    {
        "content": "<p>in that place, <code>Iso2Observer::observe</code> uses the <code>ImplCandidate</code> (to normalize the result of <code>get_data</code>). However, I don't see a way of forcing it to propagate its requirement without breaking <code>IntoIterator</code></p>",
        "id": 169306161,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561830296
    },
    {
        "content": "<p>aka, while allowing it to use things like <code>&lt;Vec&lt;U&gt; as IntoIterator&gt;</code></p>",
        "id": 169306170,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1561830337
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> I’ve not exactly followed the solutions you have in mind so far, but to me there are basically two realistic solutions:</p>\n<ul>\n<li>resolve through impl precedence</li>\n<li>more brutal: if <code>dyn Trait&lt;?X1,...?Xn&gt;</code> would unify with the receiver of an impl for <code>Trait&lt;T1,...,Tn&gt;</code>, make the trait non object safe</li>\n</ul>\n<p>Is that right? Are there any problems with, e.g. the second approach?</p>",
        "id": 169582932,
        "sender_full_name": "scalexm",
        "timestamp": 1562172703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"131694\">@scalexm</span> </p>\n<p>I'm not sure the coherence solution is too bad</p>",
        "id": 169583017,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562172739
    },
    {
        "content": "<p>(Other than breaking compatibility of course)</p>",
        "id": 169583020,
        "sender_full_name": "scalexm",
        "timestamp": 1562172742
    },
    {
        "content": "<p>I'm not sure people are abusing things sufficiently badly that we have a coherence problem</p>",
        "id": 169583036,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562172761
    },
    {
        "content": "<p>What are you calling « coherence solution »?</p>",
        "id": 169583045,
        "sender_full_name": "scalexm",
        "timestamp": 1562172772
    },
    {
        "content": "<p>making the bad impl illegal</p>",
        "id": 169583052,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562172782
    },
    {
        "content": "<p>I mean, we have an unsoundness, everything is going to break compatibility</p>",
        "id": 169583070,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562172794
    },
    {
        "content": "<p>Right</p>",
        "id": 169583083,
        "sender_full_name": "scalexm",
        "timestamp": 1562172798
    },
    {
        "content": "<p>So you prefer « making the impl illegal » rather than « making it illegal to use the trait as a trait object »</p>",
        "id": 169583174,
        "sender_full_name": "scalexm",
        "timestamp": 1562172875
    },
    {
        "content": "<p>I'm not sure</p>",
        "id": 169583241,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562172941
    },
    {
        "content": "<p>this feels like a lang-design question that might need some thought</p>",
        "id": 169583311,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562172971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"131694\">@scalexm</span> BTW, how <em>can</em> we do impl precedence?</p>",
        "id": 169583331,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562172996
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"228094\">@Ariel Ben-Yehuda</span> I don’t know :)</p>",
        "id": 169583362,
        "sender_full_name": "scalexm",
        "timestamp": 1562173031
    },
    {
        "content": "<p>But if it were possible, it would presumably break less code?</p>",
        "id": 169583377,
        "sender_full_name": "scalexm",
        "timestamp": 1562173056
    },
    {
        "content": "<p>I'm not sure</p>",
        "id": 169583379,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562173061
    },
    {
        "content": "<p>it feels like any real way of doing it would manage to break some code</p>",
        "id": 169583394,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562173077
    },
    {
        "content": "<p>what with it being a fairly-big change and all</p>",
        "id": 169583453,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562173088
    },
    {
        "content": "<p>Yes</p>",
        "id": 169583472,
        "sender_full_name": "scalexm",
        "timestamp": 1562173102
    },
    {
        "content": "<p>and we're still not sure that preventing the trait from being \"object-safe\" would break things</p>",
        "id": 169583476,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562173104
    },
    {
        "content": "<p>my actual idea for non-object-safety was uglier but more permitting</p>",
        "id": 169583502,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562173126
    },
    {
        "content": "<p>you make the <code>ObjectCandidate</code> not apply when an <code>ImplCandidate</code> can \"possibly\" match</p>",
        "id": 169583521,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562173143
    },
    {
        "content": "<p>i.e., basically add negative bounds to the object candidate</p>",
        "id": 169583549,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1562173168
    },
    {
        "content": "<p>I see</p>",
        "id": 169583591,
        "sender_full_name": "scalexm",
        "timestamp": 1562173202
    }
]