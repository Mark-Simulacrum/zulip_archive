[
    {
        "content": "<p>I've been thinking about layout optimizations a little recently, and have a question. I realize this may have been asked before, so links to previous discussions are greatly appreciated. Consider <code>type S = Option&lt;Option&lt;(NonZeroU8, u8)&gt;&gt;;</code> it is possible to layout optimize this into 2 bytes by having</p>\n<div class=\"codehilite\"><pre><span></span><code>Some(Some(a, b)) =&gt; [a, b]\nSome(None) =&gt; [0, 1]\nNone =&gt; [0, 0]\n</code></pre></div>\n<p>I will call this the \"small\" layout. Alternatively, one could choose not to optimize this much, and give this type a size of 3 bytes, with</p>\n<div class=\"codehilite\"><pre><span></span><code>Some(Some([a, b])) =&gt; [0, a, b]\nSome(None) =&gt; [1, x, x]\nNone =&gt; [2, x, x]\n</code></pre></div>\n<p>where <code>x</code> represent padding bytes. I will call this the \"large\" layout. In either case the alignment is <code>1</code>. (Neither are what this currently compiles to, but that is not the point). Ignoring implementation difficulties for a second, which version do we want? I assume in general the first is better, but I see an advantage to the second as well: Consider the function</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">S</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1000</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"mi\">1000</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In the case of the large layout, this can compile to repeated invocations of <code>mov byte ptr [rdi] 2</code>. In the case of the small layout, this instead compiles to repeated invocations of <code>mov word ptr [rdi] 0</code>. Importantly, that second write is a <em>potentially unaligned</em> write, unlike the first one. That means that in a case like this, the relative performance of this function for these two layouts is at least unclear (I may try and see if I can bench this later).</p>\n<p>Is there some general guiding principle for how to decide what is better? Speaking abstractly, the \"cause\" of this kind of pessimization is the size of the tag growing from 1 byte to 2. These kinds of issues sound like they'll get especially complicated with types like <code>Vec&lt;T&gt;</code>, where we could realistically give it <code>2^128</code> niches or <code>1</code> (on 64 bit anyway); we'd pay for the <code>2^128</code> niches with tags larger than a register.</p>",
        "id": 263784182,
        "sender_full_name": "Jake",
        "timestamp": 1638731839
    },
    {
        "content": "<p>For vec specifically you could get away with a much cheaper optimization on many platforms by declaring the pointer to be in the range of 1 .. 2^63-1 since the upper half of the addressspace isn't available in userspace.</p>",
        "id": 263785089,
        "sender_full_name": "The 8472",
        "timestamp": 1638733001
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263785089\">said</a>:</p>\n<blockquote>\n<p>For vec specifically you could get away with a much cheaper optimization on many platforms by declaring the pointer to be in the range of 1 .. 2^63-1 since the upper half of the addressspace isn't available in userspace.</p>\n</blockquote>\n<p>Good point. Even then though, the question of \"how big do we make the tag\" is not always clear.</p>",
        "id": 263785602,
        "sender_full_name": "Jake",
        "timestamp": 1638733699
    },
    {
        "content": "<p>IMHO, all layout optimizations are desirable. In the end, we could even investigate enhanced optimizations for <code>Copy</code> types where we pack bits of neighbouring fields together.</p>",
        "id": 263785860,
        "sender_full_name": "cjgillot",
        "timestamp": 1638734129
    },
    {
        "content": "<p>runtime memory compression! ram doubler!</p>",
        "id": 263786745,
        "sender_full_name": "The 8472",
        "timestamp": 1638735363
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263785860\">said</a>:</p>\n<blockquote>\n<p>In the end, we could even investigate enhanced optimizations for <code>Copy</code> types where we pack bits of neighbouring fields together.</p>\n</blockquote>\n<p>I'd like to see that, but I think it requires an opt-in since it's incompatible with getting <code>&amp;mut</code> to the fields.  Previous conversation: <a href=\"https://internals.rust-lang.org/t/towards-even-smaller-structs/14686/3?u=scottmcm\">https://internals.rust-lang.org/t/towards-even-smaller-structs/14686/3?u=scottmcm</a></p>",
        "id": 263786850,
        "sender_full_name": "scottmcm",
        "timestamp": 1638735487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263785860\">said</a>:</p>\n<blockquote>\n<p>IMHO, all layout optimizations are desirable. In the end, we could even investigate enhanced optimizations for <code>Copy</code> types where we pack bits of neighbouring fields together.</p>\n</blockquote>\n<p>Indeed, although, having looked at some of the ways rustc layout optimizes right now, this kind of thing seems to be fairly far from the first steps for rustc. For example, even this type:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Large</span><span class=\"p\">(</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Small</span><span class=\"p\">(</span><span class=\"kt\">u64</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is currently 32 bytes, despite it being unambiguously better for it to be 24 bytes.</p>",
        "id": 263787351,
        "sender_full_name": "Jake",
        "timestamp": 1638736196
    },
    {
        "content": "<p>I don't know that there is a way go have that by 24 bytes.</p>",
        "id": 263787512,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638736442
    },
    {
        "content": "<p>The u64 wants to be aligned. So the niche would have to go into the 3rd value of vec, which currently is...</p>",
        "id": 263787551,
        "sender_full_name": "The 8472",
        "timestamp": 1638736477
    },
    {
        "content": "<p>the length field</p>",
        "id": 263787565,
        "sender_full_name": "The 8472",
        "timestamp": 1638736516
    },
    {
        "content": "<p>It could theoretically fit in any of the fields, but I don't think there's enough of a niche to stick the entire value in.</p>",
        "id": 263787568,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638736525
    },
    {
        "content": "<p>And length has to cover 0..usize::max.</p>",
        "id": 263787572,
        "sender_full_name": "The 8472",
        "timestamp": 1638736539
    },
    {
        "content": "<p>In theory, you could do something with cap=0, len=value but that just seems too absolutely magic.</p>",
        "id": 263787626,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638736580
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263787568\">said</a>:</p>\n<blockquote>\n<p>It could theoretically fit in any of the fields, but I don't think there's enough of a niche to stick the entire value in.</p>\n</blockquote>\n<p>There is. You can have</p>\n<div class=\"codehilite\"><pre><span></span><code>Large([ptr, len, capacity]) =&gt; [ptr, len, cap]\nSmall(val) =&gt; [0, val, x]\n</code></pre></div>\n<p>And this is not even that magic, I see a fairly simple way to do it in general.</p>",
        "id": 263787673,
        "sender_full_name": "Jake",
        "timestamp": 1638736666
    },
    {
        "content": "<p>Oh yeah, true.</p>",
        "id": 263787691,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638736683
    },
    {
        "content": "<p>hrrm, right. then why doesn't it do that already? ptr is nonnull</p>",
        "id": 263787738,
        "sender_full_name": "The 8472",
        "timestamp": 1638736704
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263787738\">said</a>:</p>\n<blockquote>\n<p>hrrm, right. then why doesn't it do that already? ptr is nonnull</p>\n</blockquote>\n<p>The \"fundamental\" reason is that the <code>Vec</code> reports its niche as <code>0..1</code>, not <code>0..2^128</code>, if I understand correctly. The thing is though, doing this kind of layouting without lots of global analysis is just a little tricky</p>",
        "id": 263787779,
        "sender_full_name": "Jake",
        "timestamp": 1638736799
    },
    {
        "content": "<p>but it only needs a single niche to represent \"not the variant containing a vec\", why would it need 0..2^128 just to store the discriminant?</p>",
        "id": 263787854,
        "sender_full_name": "The 8472",
        "timestamp": 1638736887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263787854\">said</a>:</p>\n<blockquote>\n<p>but it only needs a single niche to represent \"not the variant containing a vec\", why would it need 0..2^128 just to store the discriminant?</p>\n</blockquote>\n<p>Not quite sure what you're saying here, can you rephrase?</p>",
        "id": 263787921,
        "sender_full_name": "Jake",
        "timestamp": 1638736958
    },
    {
        "content": "<p>The \"correct\" way to lay that type out is even</p>\n<div class=\"codehilite\"><pre><span></span><code>Large([ptr, len, capacity]) =&gt; [ptr, len, cap]\nSmall(val) =&gt; [0, 0, val]\n</code></pre></div>\n<p>since now <code>E</code> has a niche nearly the size of the one of <code>Vec</code>, and so we could add <code>2^64-1</code> more variants that look like <code>Small</code> to <code>E</code> without growing the size</p>",
        "id": 263787942,
        "sender_full_name": "Jake",
        "timestamp": 1638737022
    },
    {
        "content": "<p>Oh, I think I understand, the issue is that the variant payload would have to participate in the optimization, not just for finding a place to stash the tag.</p>",
        "id": 263788089,
        "sender_full_name": "The 8472",
        "timestamp": 1638737190
    },
    {
        "content": "<p>Yes, that is the case. The reason this is difficult to do in general though is issues like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">F</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">First</span><span class=\"p\">(</span><span class=\"kt\">u64</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Second</span><span class=\"p\">(</span><span class=\"kt\">u64</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">enum</span> <span class=\"nc\">Bad</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">EV</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"c1\">// from previous example</span>\n<span class=\"w\">    </span><span class=\"n\">FV</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where we first compute the layout of <code>F</code> to be</p>\n<div class=\"codehilite\"><pre><span></span><code>First(a) =&gt; [0, a]\nSecond(a) =&gt; [1, a]\n</code></pre></div>\n<p>Unfortunately now there's no way to lay out <code>B</code> in 24 bytes, since <code>EV</code> would have to have the same exact layout as <code>E</code> (no extra bytes for a tag), but <code>F</code> now has nowhere to go, with the layout as computed</p>",
        "id": 263788380,
        "sender_full_name": "Jake",
        "timestamp": 1638737621
    },
    {
        "content": "<p>Of course, if we knew about <code>Bad</code> when computing the layout of <code>F</code>, we could instead have <code>F</code> look like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">First</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">Second</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">]</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and now <code>F</code> can be put in the bytes <code>8..24</code> without issue, but that kind of analysis seems hard and essentially has to be global</p>",
        "id": 263788446,
        "sender_full_name": "Jake",
        "timestamp": 1638737690
    },
    {
        "content": "<p>I don't think for <code>S</code> you would need global analysis. Sure, another enum around S would have to add some extra space, but it would be no worse off because without optimization S would already have been one usize larger.<br>\nSo in that case it's only necessary for <code>S::Small</code> to move its payload around, but that's still more than what currently happens.</p>\n<p>Also, you forgot to declare <code>E</code>  ;)</p>",
        "id": 263788889,
        "sender_full_name": "The 8472",
        "timestamp": 1638738185
    },
    {
        "content": "<p>It says <code>// from previous example</code> :P</p>",
        "id": 263788907,
        "sender_full_name": "Jake",
        "timestamp": 1638738218
    },
    {
        "content": "<p>...and it was called <code>S</code> in the previous example. Oops</p>",
        "id": 263789167,
        "sender_full_name": "Jake",
        "timestamp": 1638738513
    },
    {
        "content": "<p>Ah, now it makes more sense</p>",
        "id": 263789300,
        "sender_full_name": "The 8472",
        "timestamp": 1638738680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263788889\">said</a>:</p>\n<blockquote>\n<p>I don't think for <code>S</code> you would need global analysis. Sure, another enum around S would have to add some extra space, but it would be no worse off because without optimization S would already have been one usize larger.<br>\nSo in that case it's only necessary for <code>S::Small</code> to move its payload around, but that's still more than what currently happens.</p>\n<p>Also, you forgot to declare <code>E</code>  ;)</p>\n</blockquote>\n<p>Yes, absolutely, there is an option here to improve the layout of <code>S</code> but not <code>Bad</code>, but if we want to get the \"best possible\" layout optimizations in the long term, the algorithm could not simply compute the layout of a type on the basis of its fields</p>",
        "id": 263789386,
        "sender_full_name": "Jake",
        "timestamp": 1638738796
    },
    {
        "content": "<p>Oh, this problem is actually pretty trivially NP-Hard too. Fun.</p>",
        "id": 263789467,
        "sender_full_name": "Jake",
        "timestamp": 1638738862
    },
    {
        "content": "<p>best possible depends on constraints anyway. otherwise we can escalate further and demand PGO</p>",
        "id": 263789521,
        "sender_full_name": "The 8472",
        "timestamp": 1638738948
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/46213\">#46213</a></p>",
        "id": 263789634,
        "sender_full_name": "The 8472",
        "timestamp": 1638739072
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263789634\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://github.com/rust-lang/rust/issues/46213\">#46213</a></p>\n</blockquote>\n<p>see <a href=\"https://github.com/rust-lang/rust/pull/75866\">https://github.com/rust-lang/rust/pull/75866</a> for the latest (afaik) attempt at that<br>\nit works, but it causes a perf regression, likely due to match/\"get discriminant\" codegen being more complex for niche layouts</p>",
        "id": 263789767,
        "sender_full_name": "erikdesjardins",
        "timestamp": 1638739214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263789521\">said</a>:</p>\n<blockquote>\n<p>best possible depends on constraints anyway. otherwise we can escalate further and demand PGO</p>\n</blockquote>\n<p>Well, yes, by \"best possible\" I mean giving each type a layout that is not bigger than the smallest possible layout for that type, with the restriction being that the layout must support referencing all fields</p>",
        "id": 263789876,
        "sender_full_name": "Jake",
        "timestamp": 1638739382
    },
    {
        "content": "<p>Ok I have some ideas here actually, let me try and implement a proof of concept</p>",
        "id": 263790068,
        "sender_full_name": "Jake",
        "timestamp": 1638739622
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/263785860\">said</a>:</p>\n<blockquote>\n<p>IMHO, all layout optimizations are desirable. In the end, we could even investigate enhanced optimizations for <code>Copy</code> types where we pack bits of neighbouring fields together.</p>\n</blockquote>\n<p>So I've written a little code for this, and I'm pretty sure that you definitely dont want <em>all</em> layout optimizations :P . In particular, consider the types below: (I use <code>U</code> for <code>usize</code>)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Long</span><span class=\"p\">(</span><span class=\"n\">NonZeroU</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">U</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"k\">enum</span> <span class=\"nc\">E</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Long</span><span class=\"p\">(</span><span class=\"n\">Long</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Short</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Lets assume the desirable layout of <code>Long</code> is the niched value first and the array after (actually, this is wrong on little endian, but that doesn't actually matter). This means that now <code>Long</code> has a fairly big niche, <code>2^(64*3)</code> values! Now how do you lay out <code>E</code>? Well, <code>E</code> will have the same size as <code>Long</code>, so the long variant is easy, but how about the <code>Short</code> variant. Well, the <em>most</em> space efficient thing to do is this:</p>\n<div class=\"codehilite\"><pre><span></span><code>Short(a) =&gt; [0, 0, 0, a]\n</code></pre></div>\n<p>But that's a perf disaster, since now <code>matches!(x, E::Short(_))</code> now requires loading 3 usizes and making sure they're all zero. You can make this much faster by instead laying it out like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>Short(a) =&gt; [0, a, x, x] // x is padding\n</code></pre></div>\n<p>Unfortunately, if someone in another crate who depends on my <code>E</code> type comes along and writes</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">F</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">E</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Other</span><span class=\"p\">([</span><span class=\"n\">U</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>we're in trouble. With the slow layout, <code>F</code> would have size <code>4*U</code> since we can fit <code>Other([a, b]) =&gt; [0, 1, a, b]</code>. On the other hand, with the big layout, we can't do any such thing and now <code>F</code> is one <code>U</code> bigger. Whether this particular trade-off is desirable, who knows, but if you imagine changing the <code>3</code> in long to some <code>N</code> much bigger (and then having <code>Other([U; N-1])</code>) you definitely do not want this anymore, and want to just take the memory hit</p>",
        "id": 263803869,
        "sender_full_name": "Jake",
        "timestamp": 1638759363
    },
    {
        "content": "<p>(on the other hand, if you had PGO data telling you the <code>Short</code> variant is extremely cold...)</p>",
        "id": 263803966,
        "sender_full_name": "Jake",
        "timestamp": 1638759522
    },
    {
        "content": "<p>I actually take some of that back, there is a general way to do decent things here</p>",
        "id": 263806506,
        "sender_full_name": "Jake",
        "timestamp": 1638763202
    },
    {
        "content": "<p>I'm currently working on optimising discriminant switches to land the PR that was postponed</p>",
        "id": 263823294,
        "sender_full_name": "nox",
        "timestamp": 1638781674
    },
    {
        "content": "<p>Wrote some thoughts about that here: <a href=\"https://twitter.com/nokusu/status/1467533619321503744\">https://twitter.com/nokusu/status/1467533619321503744</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/nokusu/status/1467533619321503744\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/baaa98f97f785abbde33bb21439562aa83878aca/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3433303730373837323431393135313837322f774d42616e7a704e5f6e6f726d616c2e706e67\"></a><p>I decided to go a different route, I'm trying to optimize them switches on the fly during monomorphization, instead of introducing a new kind of terminator.</p><span>- Anthony Ramine (@nokusu)</span></div></div>",
        "id": 263823584,
        "sender_full_name": "nox",
        "timestamp": 1638781846
    },
    {
        "content": "<p>Random thought while I'm in the monomorphization of discriminant-related code: we could also make enums with uninhabited variants smaller.</p>\n<p>I know that rustc needs to reserve space for uninhabited variants because of partial initialisations, but that doesn't mean it needs to reserve space for an actual variant with a discriminant.</p>",
        "id": 264176826,
        "sender_full_name": "nox",
        "timestamp": 1638979310
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=af13e24a8c4c598dcf0f070af9b96fe7\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=af13e24a8c4c598dcf0f070af9b96fe7</a> Consider this, there would be nothing wrong making both types be 24 bytes, right?</p>",
        "id": 264176987,
        "sender_full_name": "nox",
        "timestamp": 1638979365
    },
    {
        "content": "<blockquote>\n<p>I know that rustc needs to reserve space for uninhabited variants because of partial initialisations</p>\n</blockquote>\n<p>By \"partial initialisations\", do you mean something like this (<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=df6e88e1b1e6bd56749b9458581f9d20\">playground</a>)?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">UninhabitedButLarge</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">().</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264213442,
        "sender_full_name": "Noah Lev",
        "timestamp": 1638994328
    },
    {
        "content": "<p>Kind of. There was a discussion of wanting to make it possible to also write </p>\n<div class=\"codehilite\"><pre><span></span><code>let x: UninhabitedButLarge;\nx.0 = [0;3];\nprintln!(&quot;{:?}&quot;, x.0);\n</code></pre></div>",
        "id": 264214831,
        "sender_full_name": "nagisa",
        "timestamp": 1638995005
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Noah Lev</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/264213442\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I know that rustc needs to reserve space for uninhabited variants because of partial initialisations</p>\n</blockquote>\n<p>By \"partial initialisations\", do you mean something like this (<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=df6e88e1b1e6bd56749b9458581f9d20\">playground</a>)?</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">UninhabitedButLarge</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">().</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I dug that conversation back out <a href=\"#narrow/stream/213817-t-lang/topic/size_of.20never.20type.3F/near/264104953\">here</a> yesterday for basically exactly this reason</p>",
        "id": 264233811,
        "sender_full_name": "Jake",
        "timestamp": 1639004540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263648\">nox</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/264176987\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=af13e24a8c4c598dcf0f070af9b96fe7\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=af13e24a8c4c598dcf0f070af9b96fe7</a> Consider this, there would be nothing wrong making both types be 24 bytes, right?</p>\n</blockquote>\n<p>Agreed, I've already implemented that one :P</p>",
        "id": 264233831,
        "sender_full_name": "Jake",
        "timestamp": 1639004567
    },
    {
        "content": "<p>(locally, to be clear, I'm hoping to share by the end of the week)</p>",
        "id": 264234155,
        "sender_full_name": "Jake",
        "timestamp": 1639004770
    },
    {
        "content": "<p>Nice</p>",
        "id": 264235390,
        "sender_full_name": "nox",
        "timestamp": 1639005560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jake</span> That sounds awesome! I look forward to seeing possibilities for more layout optimizations.</p>",
        "id": 264252928,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639021193
    },
    {
        "content": "<p>Current status: writing many tests to be sure I'm not breaking everyone's code hah. <a href=\"https://github.com/rust-lang/rust/compare/nox/i-need-a-niche-but-i-have-no-dog#diff-74a0e452d84e41c5e5df5307518b967e87da0ad574c67a55b2d772800bc870f8\">https://github.com/rust-lang/rust/compare/nox/i-need-a-niche-but-i-have-no-dog#diff-74a0e452d84e41c5e5df5307518b967e87da0ad574c67a55b2d772800bc870f8</a></p>",
        "id": 264473391,
        "sender_full_name": "nox",
        "timestamp": 1639154467
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263648\">nox</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Which.20Layout.20Optimizations.20are.20Desirable/near/264473391\">said</a>:</p>\n<blockquote>\n<p>Current status: writing many tests to be sure I'm not breaking everyone's code hah. <a href=\"https://github.com/rust-lang/rust/compare/nox/i-need-a-niche-but-i-have-no-dog#diff-74a0e452d84e41c5e5df5307518b967e87da0ad574c67a55b2d772800bc870f8\">https://github.com/rust-lang/rust/compare/nox/i-need-a-niche-but-i-have-no-dog#diff-74a0e452d84e41c5e5df5307518b967e87da0ad574c67a55b2d772800bc870f8</a></p>\n</blockquote>\n<p>Can you check if your patch causes the <code>otherwise</code> branch in <code>bb0</code> in <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2021&amp;gist=44832a064ba1cc661f591aaadf22d6b9\">this example</a> to be correctly marked as unreachable? (Don't worry if not, this feels only kind of related, and I can write an MIR opt pass to do this pretty easily)</p>",
        "id": 264586005,
        "sender_full_name": "Jake",
        "timestamp": 1639258371
    },
    {
        "content": "<p>Actually, this probably should be done pre-monomorphization time anyway, so writing the pass regardless is probably right</p>",
        "id": 264587485,
        "sender_full_name": "Jake",
        "timestamp": 1639260164
    }
]