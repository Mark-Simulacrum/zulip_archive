[
    {
        "content": "<p>To parse and emit Rust code, what's the current recommendation? - I'm about to breathe life into this old repo <a href=\"https://github.com/offscale/cdd-rust\">https://github.com/offscale/cdd-rust</a> - that had a bunch of <a href=\"https://github.com/dtolnay/syn\"><code>syn</code></a> usage - or my slightly newer repo that was all custom code - <a href=\"https://github.com/offscale/cdd-openapi\">https://github.com/offscale/cdd-openapi</a></p>\n<p>The idea is to:</p>\n<p>0. parse a language/framework (Rust with diesel + actix was the previous [planned] combination);<br>\n   1. extract pertinent information (in this case, JSON schema for the [diesel] 'models' extraction, and any exposed routes—e.g., with actix—and related tests &amp; mocks &amp; docs);<br>\n   2. generate a new OpenAPI schema from this structure.</p>\n<p>Then in reverse, support this workflow:</p>\n<div class=\"codehilite\"><pre><span></span><code>0. Take OpenAPI schema as input;\n1. Either:\n    a. Existing codebase:\n        i. parse existing codebase;\n        ii. merge new changes matching existing structure to expected structure (OpenAPI in this scenario is the &#39;gold standard&#39;);\n    b. Nonexistent codebase:\n        i. Generate boilerplate + CRUD API endpoints + tests &amp; mocks + docs matching OpenAPI schema… potentially using  fancy emitter library but potentially just using simple string templates.\n</code></pre></div>\n\n<p>Oh and I'll probably CC0 the project at some point… it's currently (Apache-2.0 OR MIT). <strong>Which crates would you recommend depending on to achieve these aforementioned goals?</strong></p>\n<p>Thanks for your insights</p>",
        "id": 268935365,
        "sender_full_name": "Samuel Marks",
        "timestamp": 1642824513
    }
]