[
    {
        "content": "<p>hey <span class=\"user-mention\" data-user-id=\"124287\">@mw</span> and/or <span class=\"user-mention\" data-user-id=\"116015\">@Alex Crichton</span> , I wanted to bounce some thoughts off of you two</p>",
        "id": 180529010,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573573208
    },
    {
        "content": "<p>in particular, I wanted to talk about a theory I put forth <a href=\"https://github.com/rust-lang/rust/issues/59535#issuecomment-552894688\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/59535#issuecomment-552894688\">here</a>.</p>",
        "id": 180529065,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573573242
    },
    {
        "content": "<p>We currently make decisions about whether to change a symbol's Linkage from External to Internal based on the set of accessors we currently observe. However, I theorize that old incremental codegen artifacts may be relying on a symbol's previous classification as External</p>",
        "id": 180529209,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573573330
    },
    {
        "content": "<p>so I was wondering: can/should we have a rule that if a symbol was considered External in any previous compile, then an incremental compilation is forced to keep it External?</p>",
        "id": 180529300,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573573396
    },
    {
        "content": "<p>(this is not the only possible solution to the theorized problem. For example, instead of constraining which symbols can be marked Internal based on previous compiles, we could instead force the codegen artifacts to be recompiled rather than reused; but doing this well would require determiniing which codegen artifacts depend on the symbols previously marked as External, and I do not know how hard that is to implement.)</p>",
        "id": 180531826,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573574751
    },
    {
        "content": "<p>mw will probably have more to say about this than I, but at least from my perspective I would say that artifacts from a previous compile should only ever accelerate future compiles, never actually change the future compile</p>",
        "id": 180536052,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1573577172
    },
    {
        "content": "<p>so that way no matter what your cache looks like <code>cargo build</code> always produces the same thing</p>",
        "id": 180536070,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1573577181
    },
    {
        "content": "<p>so I'd probably say that this should lean on the side of recompiling more rather than keeping something External</p>",
        "id": 180536087,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1573577196
    },
    {
        "content": "<p>although if that's too onerous, then we could also perhaps start exporting more symbols in incremental mode</p>",
        "id": 180536108,
        "sender_full_name": "Alex Crichton",
        "timestamp": 1573577211
    },
    {
        "content": "<blockquote>\n<p>However, I theorize that old incremental codegen artifacts may be relying on a symbol's previous classification as External</p>\n</blockquote>\n<p>Old artifacts must not be used if they are not the same as the artifacts produced by the current compilation session, so what the previous classification was should not matter. In theory at least, there might be bugs in the compiler.</p>",
        "id": 180582262,
        "sender_full_name": "Zoxc",
        "timestamp": 1573610119
    },
    {
        "content": "<p>my current inclination is to try turning off the internalize_symbols optimization if we have incremental compilation turned on...</p>",
        "id": 180589633,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573618378
    },
    {
        "content": "<p>(Though I worry that may cause too great a regression in code quality, especially code size...)</p>",
        "id": 180589696,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573618475
    },
    {
        "content": "<p>One question related to this: Am I right that LLVM <em>could</em> be inlining a function that comes from a <em>different</em> codegen unit in the current crate? To be honest that part of the story does not match my mental model of how LLVM optimization works.</p>",
        "id": 180589819,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573618654
    },
    {
        "content": "<p>Hmm: is there some #[rustc_attribute] I can use to force items to be assigned to particular codegen units? That would help me write a test case that would allow exploring the behavior here without relying on the oddities of this particular test.</p>",
        "id": 180589998,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573618894
    },
    {
        "content": "<p>/me is busy at the moment. Will take a closer look on Friday.</p>",
        "id": 180613483,
        "sender_full_name": "mw",
        "timestamp": 1573642647
    },
    {
        "content": "<blockquote>\n<p>One question related to this: Am I right that LLVM <em>could</em> be inlining a function that comes from a <em>different</em> codegen unit in the current crate? To be honest that part of the story does not match my mental model of how LLVM optimization works.</p>\n</blockquote>\n<p>further update on this detail: I think the inlining here is occurring during LTO</p>",
        "id": 180615390,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573644125
    },
    {
        "content": "<blockquote>\n<p>Hmm: is there some #[rustc_attribute] I can use to force items to be assigned to particular codegen units? That would help me write a test case that would allow exploring the behavior here without relying on the oddities of this particular test.</p>\n</blockquote>\n<p>(maybe getting this effect is supposed to be as simple as choosing the right set of <code>mod</code> items. still looking; but I think an explicit attribute could potentially be a good thing.)</p>",
        "id": 180617486,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573646096
    },
    {
        "content": "<p>I left more notes in the bug (<a href=\"https://github.com/rust-lang/rust/issues/59535\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/59535\">#59535</a>). I now better understand what's happening. Part of the problem is that we are reusing the post-ThinLTO object file for a codegen-unit (and that's what holds the result of inlining <code>fn B</code> from a different codegen-unit); so <code>fn B</code>'s call to <code>fn A</code> has been inlined into that object file. But independently, due to changes elsewhere in the source code, we reclassified <code>fn A</code> as internal, and subsequently optimized away the definition of <code>fn A</code>.</p>",
        "id": 180713730,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573724154
    },
    {
        "content": "<p>I am looking over <a href=\"https://github.com/rust-lang/rust/blob/5e380b797b22e5361a43b2b82f6278df17d89f3e/src/librustc_codegen_llvm/back/lto.rs#L499\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/5e380b797b22e5361a43b2b82f6278df17d89f3e/src/librustc_codegen_llvm/back/lto.rs#L499\">lto.rs</a> now, and also trying to understand the LLVM LTO docs. One oddity is that the erroneously reused codegen unit claims it does not import from any modules; but surely the call to the other function should be considered an import?</p>",
        "id": 180713920,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573724283
    },
    {
        "content": "<p>Argh, sorry I didn't get to this before the weekend ...</p>",
        "id": 180846860,
        "sender_full_name": "mw",
        "timestamp": 1573834421
    },
    {
        "content": "<p>I think there is a small bug somewhere here, as opposed to a conceptual problems because otherwise we'd see much more of this</p>",
        "id": 180847130,
        "sender_full_name": "mw",
        "timestamp": 1573834604
    },
    {
        "content": "<p>and I remember that I ran into problems immediately when not handling symbol internalization properly while initially implementing incremental ThinLTO</p>",
        "id": 180847183,
        "sender_full_name": "mw",
        "timestamp": 1573834651
    },
    {
        "content": "<p>yes I am working my way gradually towards the camp of \"small bug somewhere\" rather than \"conceptual problem\"</p>",
        "id": 180847290,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834718
    },
    {
        "content": "<p>it just took me a while to put all the pieces together</p>",
        "id": 180847299,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834724
    },
    {
        "content": "<p>at this point I'm not sure whether the small bug is on our end or within LLVM.</p>",
        "id": 180847322,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834742
    },
    {
        "content": "<p>yeah, it's non trivial and should be better documented</p>",
        "id": 180847342,
        "sender_full_name": "mw",
        "timestamp": 1573834756
    },
    {
        "content": "<p>I was pretty sure for a while it was our fault, but then when I was trying to walk through some of the execution, the behavior  I saw from LLVM was pretty strange</p>",
        "id": 180847363,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834775
    },
    {
        "content": "<p>I'll reserved a 2h time slot for this on Tuesday</p>",
        "id": 180847369,
        "sender_full_name": "mw",
        "timestamp": 1573834778
    },
    {
        "content": "<p>anyway don't worry about delaying this</p>",
        "id": 180847374,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834783
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 180847445,
        "sender_full_name": "mw",
        "timestamp": 1573834804
    },
    {
        "content": "<p>I spent a long time on it because I know how painful incremetnal bugs are, but also, we have so many that we <em>don't</em> have reproducible test cases for</p>",
        "id": 180847462,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834816
    },
    {
        "content": "<p>so the fact that we could actually reproduce this one got me very excited.</p>",
        "id": 180847481,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834827
    },
    {
        "content": "<p>:D</p>",
        "id": 180847497,
        "sender_full_name": "mw",
        "timestamp": 1573834839
    },
    {
        "content": "<p>perhaps over enthusiastically so</p>",
        "id": 180847501,
        "sender_full_name": "pnkfelix",
        "timestamp": 1573834842
    },
    {
        "content": "<p>this is incredibly weird :)</p>",
        "id": 181105791,
        "sender_full_name": "mw",
        "timestamp": 1574166013
    },
    {
        "content": "<p>I've been able to reproduce with <code>doit2.sh</code> from <a href=\"https://github.com/pnkfelix/rust-issue-59535\" target=\"_blank\" title=\"https://github.com/pnkfelix/rust-issue-59535\">https://github.com/pnkfelix/rust-issue-59535</a></p>",
        "id": 181105815,
        "sender_full_name": "mw",
        "timestamp": 1574166040
    },
    {
        "content": "<p>but I have no clue what's going on yet</p>",
        "id": 181105854,
        "sender_full_name": "mw",
        "timestamp": 1574166076
    },
    {
        "content": "<p>it looks like this has nothing to do with ThinLTO</p>",
        "id": 181105862,
        "sender_full_name": "mw",
        "timestamp": 1574166087
    },
    {
        "content": "<p>the <code>volatile</code> cgu for <code>rubble::ble</code> declares <code>&lt;rubble[317d481089b8c8fe]::ble::Duration as core[5e7ea8cd6850b425]::fmt::Display&gt;::fmt</code> in the initial version</p>",
        "id": 181106332,
        "sender_full_name": "mw",
        "timestamp": 1574166557
    },
    {
        "content": "<p>in the next version it should declare <code>&lt;rubble[317d481089b8c8fe]::ble::Duration as core[5e7ea8cd6850b425]::fmt::Debug&gt;::fmt</code> but the CGU is exactly the same version as initially</p>",
        "id": 181106409,
        "sender_full_name": "mw",
        "timestamp": 1574166619
    },
    {
        "content": "<p>the internalizer <em>correctly</em> makes the symbol for <code>&lt;rubble[317d481089b8c8fe]::ble::Duration as core[5e7ea8cd6850b425]::fmt::Display&gt;::fmt</code> internal, but it looks like the <code>volatile</code> object file for <code>rubble::ble</code> is not recompiled, although the MIR it is generated from should have changed.</p>",
        "id": 181106512,
        "sender_full_name": "mw",
        "timestamp": 1574166731
    },
    {
        "content": "<p>I'm trying to debug further but for that I need a local build of rustc that can handle the <code>thumbv7em-none-eabi</code> target</p>",
        "id": 181106576,
        "sender_full_name": "mw",
        "timestamp": 1574166834
    },
    {
        "content": "<p>how hard can that be :P</p>",
        "id": 181106624,
        "sender_full_name": "mw",
        "timestamp": 1574166849
    },
    {
        "content": "<p>Oh I should have warned you about that target dependence</p>",
        "id": 181107157,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167326
    },
    {
        "content": "<p>what did I end up having to do there ...</p>",
        "id": 181107161,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167331
    },
    {
        "content": "<p>I'm curious you say the MIR should have changed. I could have sworn that I validated that the inlining in question was happening during a LTO optimization pass</p>",
        "id": 181107234,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167434
    },
    {
        "content": "<p>regarding the target dependence, I know that I installed thumbv7em-none-eabi via <code>rustup</code>, but that's not the local build</p>",
        "id": 181107297,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167482
    },
    {
        "content": "<p>if I compile v2 with an empty cache, the volatile cgu does not reference the function in question anymore</p>",
        "id": 181107316,
        "sender_full_name": "mw",
        "timestamp": 1574167516
    },
    {
        "content": "<p>it references a different function instead</p>",
        "id": 181107326,
        "sender_full_name": "mw",
        "timestamp": 1574167536
    },
    {
        "content": "<p>and everything works</p>",
        "id": 181107332,
        "sender_full_name": "mw",
        "timestamp": 1574167544
    },
    {
        "content": "<p>but let me take another look...</p>",
        "id": 181107417,
        "sender_full_name": "mw",
        "timestamp": 1574167607
    },
    {
        "content": "<p>okay, this is how I built: <code>time python /home/pnkfelix/Dev/Mozilla/rust.git/x.py dist --stage 2   --target thumbv7em-none-eabi</code></p>",
        "id": 181107437,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167627
    },
    {
        "content": "<p>though that might need to be preceded by a <code>python x.py build --stage 2 --target thumbv7em-none-eabi</code></p>",
        "id": 181107464,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167658
    },
    {
        "content": "<p>(for some reason I vaguely recall being unhappy about my attempts to go directly to <code>dist</code>)</p>",
        "id": 181107485,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167680
    },
    {
        "content": "<p>I'm getting <code>thread 'main' panicked at 'All the *-none-* and nvptx* targets are no-std targets', src/bootstrap/sanity.rs:186:17</code> with that</p>",
        "id": 181107590,
        "sender_full_name": "mw",
        "timestamp": 1574167776
    },
    {
        "content": "<p>regarding the obj file, already the \"no-opt\" version of the LLVM IR should look different, so this is before ThinLTO, unless I'm overlooking something</p>",
        "id": 181107665,
        "sender_full_name": "mw",
        "timestamp": 1574167836
    },
    {
        "content": "<p>hmm.</p>",
        "id": 181107671,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167848
    },
    {
        "content": "<p>when you say \"the volatile cgu\", is that referring to <code>mks4f5lxe2i4sqc</code> ? (I am assuming the names are stable between your platform and my own, but perhaps  that is an invalid assumption)</p>",
        "id": 181107770,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574167929
    },
    {
        "content": "<p>I'm compiling with <code>-Zhuman-readable-cgu-names</code>, which gives me names corresponding to the module path</p>",
        "id": 181107829,
        "sender_full_name": "mw",
        "timestamp": 1574167985
    },
    {
        "content": "<p>ah hmm</p>",
        "id": 181107847,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574168000
    },
    {
        "content": "<p>e.g. rubble.rubble.7rcbfp3g-ble.volatile.rcgu.bc</p>",
        "id": 181107849,
        "sender_full_name": "mw",
        "timestamp": 1574168001
    },
    {
        "content": "<p>didn't know about that flag</p>",
        "id": 181107850,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574168003
    },
    {
        "content": "<p>the above can be decoded as <code>rubble[7rcbfp3g]::ble</code></p>",
        "id": 181107872,
        "sender_full_name": "mw",
        "timestamp": 1574168041
    },
    {
        "content": "<p>where the version with <code>volatile</code> will contain the code corresponding to generic instances</p>",
        "id": 181107941,
        "sender_full_name": "mw",
        "timestamp": 1574168083
    },
    {
        "content": "<p>and the one without <code>volatile</code> will contain the code for non-generic stuff from that module</p>",
        "id": 181107958,
        "sender_full_name": "mw",
        "timestamp": 1574168109
    },
    {
        "content": "<p>I don't understand the no_std logic in x.py</p>",
        "id": 181108607,
        "sender_full_name": "mw",
        "timestamp": 1574168641
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> or <span class=\"user-mention\" data-user-id=\"121055\">@Pietro Albini</span>, do you happen to know how I can locally build a rustc that can target <code>thumbv7em-none-eabi</code>?</p>",
        "id": 181109122,
        "sender_full_name": "mw",
        "timestamp": 1574169020
    },
    {
        "content": "<p>should be able to <code>x.py build src/libstd --target thumbv7em-none-eabi</code></p>",
        "id": 181109138,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169041
    },
    {
        "content": "<p>unless you need C compiler or something</p>",
        "id": 181109149,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169048
    },
    {
        "content": "<p><code>x.py dist --stage 2   --target thumbv7em-none-eabi</code> gives me <code>thread 'main' panicked at 'All the *-none-* and nvptx* targets are no-std targets', src/bootstrap/sanity.rs:186:17</code></p>",
        "id": 181109151,
        "sender_full_name": "mw",
        "timestamp": 1574169051
    },
    {
        "content": "<p>maybe if I delete my config.toml?</p>",
        "id": 181109159,
        "sender_full_name": "mw",
        "timestamp": 1574169065
    },
    {
        "content": "<blockquote>\n<p>should be able to <code>x.py build src/libstd --target thumbv7em-none-eabi</code></p>\n</blockquote>\n<p>I know this was not sufficient for me</p>",
        "id": 181109181,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574169085
    },
    {
        "content": "<p>you can also wait for a while and just use dist-various-1</p>",
        "id": 181109189,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169096
    },
    {
        "content": "<p>that'll definitely work</p>",
        "id": 181109193,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169098
    },
    {
        "content": "<p>I definitely had to do <em>something</em> beyond <code>x.py build</code> to get a libstd built (and put into a working location) for the target</p>",
        "id": 181109196,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574169099
    },
    {
        "content": "<p><code>./src/ci/docker/run.sh dist-various-1</code></p>",
        "id": 181109201,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169107
    },
    {
        "content": "<p>Re-running <code>x.py build src/libstd --target thumbv7em-none-eabi</code> without a <code>config.toml</code> now ...</p>",
        "id": 181109298,
        "sender_full_name": "mw",
        "timestamp": 1574169182
    },
    {
        "content": "<p>(I think) I have the correct GCC arm toolchain installed already</p>",
        "id": 181109327,
        "sender_full_name": "mw",
        "timestamp": 1574169212
    },
    {
        "content": "<p>we don't seem to do anything special in that docker container so I <em>would</em> expect that to work</p>",
        "id": 181109332,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169218
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/a0d40f8bdfcc3c28355467973f97fd4c45ac5876/src/ci/docker/dist-various-1/Dockerfile#L170\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/a0d40f8bdfcc3c28355467973f97fd4c45ac5876/src/ci/docker/dist-various-1/Dockerfile#L170\">https://github.com/rust-lang/rust/blob/a0d40f8bdfcc3c28355467973f97fd4c45ac5876/src/ci/docker/dist-various-1/Dockerfile#L170</a></p>",
        "id": 181109392,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169251
    },
    {
        "content": "<p>I'll try a clean build with <code>x.py build src/libstd --target thumbv7em-none-eabi</code> to try to get a better record of what went wrong there. I had assume it was user error back when I found that to be insufficient.</p>",
        "id": 181109543,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574169365
    },
    {
        "content": "<p>/me is still waiting for build ...</p>",
        "id": 181109702,
        "sender_full_name": "mw",
        "timestamp": 1574169503
    },
    {
        "content": "<p>(I'm glad I have a rather snappy desktop machine available)</p>",
        "id": 181109727,
        "sender_full_name": "mw",
        "timestamp": 1574169534
    },
    {
        "content": "<p>OK, it failed with something different</p>",
        "id": 181109847,
        "sender_full_name": "mw",
        "timestamp": 1574169605
    },
    {
        "content": "<p>7 mins for a stage 2 build is not bad though!</p>",
        "id": 181109864,
        "sender_full_name": "mw",
        "timestamp": 1574169616
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>cargo:warning=/xoxo/3-rust/src/llvm-project/compiler-rt/lib/builtins/int_util.c:57:10: fatal error: stdlib.h: No such file or directory\ncargo:warning=   57 | #include &lt;stdlib.h&gt;\ncargo:warning=      |          ^~~~~~~~~~\ncargo:warning=compilation terminated.\n</pre></div>",
        "id": 181109894,
        "sender_full_name": "mw",
        "timestamp": 1574169663
    },
    {
        "content": "<p>hm that is ... unexpected</p>",
        "id": 181110243,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169936
    },
    {
        "content": "<p>dist-various-1 would be my recommendation (you can comment a bunch in the relevant dockerfile to get it faster)</p>",
        "id": 181110268,
        "sender_full_name": "simulacrum",
        "timestamp": 1574169956
    },
    {
        "content": "<p>I had to install <code>arm-none-eabi-newlib</code> on my system, now it works</p>",
        "id": 181110589,
        "sender_full_name": "mw",
        "timestamp": 1574170199
    },
    {
        "content": "<p>why would the GCC package not include that? weird</p>",
        "id": 181110659,
        "sender_full_name": "mw",
        "timestamp": 1574170218
    },
    {
        "content": "<p>now I need to get <code>rust-lld</code> working :(</p>",
        "id": 181110680,
        "sender_full_name": "mw",
        "timestamp": 1574170238
    },
    {
        "content": "<p>Is that not just a <code>rustup</code> thing?</p>",
        "id": 181110800,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574170336
    },
    {
        "content": "<p>you are really making wish I had kept a full transcript of my full debugging session...</p>",
        "id": 181110807,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574170354
    },
    {
        "content": "<p>using rust-lld for the rustup's nightly now fails compiling the support libraries... frustrating</p>",
        "id": 181111528,
        "sender_full_name": "mw",
        "timestamp": 1574170914
    },
    {
        "content": "<p>now my reproduction script seems broken even with nightly :(</p>",
        "id": 181112217,
        "sender_full_name": "mw",
        "timestamp": 1574171462
    },
    {
        "content": "<p>(btw, thanks for you help, <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>!)</p>",
        "id": 181112233,
        "sender_full_name": "mw",
        "timestamp": 1574171479
    },
    {
        "content": "<p>Hm, so the thing that changes is <code>&lt;&amp;rubble[317d481089b8c8fe]::ble::Duration as core[5e7ea8cd6850b425]::fmt::Debug&gt;::fmt</code>. Is this maybe something completely compiler generated for which we never instantiate any MIR?</p>",
        "id": 181113471,
        "sender_full_name": "mw",
        "timestamp": 1574172455
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"c\">; Function Attrs: nounwind optsize</span>\n<span class=\"k\">define</span> <span class=\"k\">hidden</span> <span class=\"k\">zeroext</span> <span class=\"k\">i1</span> <span class=\"vg\">@_RNvXsL_NtCs86ZAEM1TFWr_4core3fmtRNtNtCs4fqI2P2rA04_6rubble3ble8DurationNtB5_5Debug3fmtBz_</span><span class=\"p\">(</span><span class=\"k\">i32</span><span class=\"p\">**</span> <span class=\"k\">noalias</span> <span class=\"k\">nocapture</span> <span class=\"k\">readonly</span> <span class=\"k\">align</span> <span class=\"m\">4</span> <span class=\"k\">dereferenceable</span><span class=\"p\">(</span><span class=\"m\">4</span><span class=\"p\">),</span> <span class=\"nv\">%&quot;core::fmt::Formatter&quot;</span><span class=\"p\">*</span> <span class=\"k\">align</span> <span class=\"m\">4</span> <span class=\"k\">dereferenceable</span><span class=\"p\">(</span><span class=\"m\">52</span><span class=\"p\">))</span> <span class=\"k\">unnamed_addr</span> <span class=\"vg\">#0</span> <span class=\"p\">{</span>\n  <span class=\"nv nv-Anonymous\">%3</span> <span class=\"p\">=</span> <span class=\"k\">load</span> <span class=\"k\">i32</span><span class=\"p\">*,</span> <span class=\"k\">i32</span><span class=\"p\">**</span> <span class=\"nv nv-Anonymous\">%0</span><span class=\"p\">,</span> <span class=\"k\">align</span> <span class=\"m\">4</span><span class=\"p\">,</span> <span class=\"nv\">!nonnull</span> <span class=\"nv nv-Anonymous\">!0</span>\n  <span class=\"nv nv-Anonymous\">%4</span> <span class=\"p\">=</span> <span class=\"k\">tail</span> <span class=\"k\">call</span> <span class=\"k\">zeroext</span> <span class=\"k\">i1</span> <span class=\"vg\">@_RNvXs_NtCs4fqI2P2rA04_6rubble3bleNtB4_8DurationNtNtCs86ZAEM1TFWr_4core3fmt5Debug3fmt</span><span class=\"p\">(</span><span class=\"k\">i32</span><span class=\"p\">*</span> <span class=\"k\">noalias</span> <span class=\"k\">nonnull</span> <span class=\"k\">readonly</span> <span class=\"k\">align</span> <span class=\"m\">4</span> <span class=\"k\">dereferenceable</span><span class=\"p\">(</span><span class=\"m\">4</span><span class=\"p\">)</span> <span class=\"nv nv-Anonymous\">%3</span><span class=\"p\">,</span> <span class=\"nv\">%&quot;core::fmt::Formatter&quot;</span><span class=\"p\">*</span> <span class=\"k\">nonnull</span> <span class=\"k\">align</span> <span class=\"m\">4</span> <span class=\"k\">dereferenceable</span><span class=\"p\">(</span><span class=\"m\">52</span><span class=\"p\">)</span> <span class=\"nv nv-Anonymous\">%1</span><span class=\"p\">)</span>\n  <span class=\"k\">ret</span> <span class=\"k\">i1</span> <span class=\"nv nv-Anonymous\">%4</span>\n<span class=\"p\">}</span>\n</pre></div>",
        "id": 181113472,
        "sender_full_name": "mw",
        "timestamp": 1574172463
    },
    {
        "content": "<p>Might be a shim that incr. comp. is somehow missing?</p>",
        "id": 181113531,
        "sender_full_name": "mw",
        "timestamp": 1574172490
    },
    {
        "content": "<p>/me needs to run now unfortunately</p>",
        "id": 181113551,
        "sender_full_name": "mw",
        "timestamp": 1574172510
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I suggest trying to find out where the above LLVM IR is generated and what MIR it is generated from if any. You can use <code>-Zprint-mono-items=lazy</code> to get additional information.</p>",
        "id": 181291875,
        "sender_full_name": "mw",
        "timestamp": 1574332112
    },
    {
        "content": "<p>okay thanks</p>",
        "id": 181291892,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332130
    },
    {
        "content": "<p>I did have a question for you</p>",
        "id": 181291924,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332156
    },
    {
        "content": "<p>related to this</p>",
        "id": 181291929,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332162
    },
    {
        "content": "<p>but I don't think I'm going to be able to re-establish the context for my Q quickly enough...</p>",
        "id": 181292038,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332251
    },
    {
        "content": "<p>the big picture of the Question was that I had tracked down a spot in the rust &lt;-&gt; LLVM interactions</p>",
        "id": 181292072,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332273
    },
    {
        "content": "<p>where Rust was querying LLVM for a list of the modules that a given cgu depended upon</p>",
        "id": 181292085,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332286
    },
    {
        "content": "<p>and I remember being surprised to see an empty list for the case in question, something where the given cgu was making a call out to a function in another cgu</p>",
        "id": 181292118,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332317
    },
    {
        "content": "<p>So that was what I had wanted to ask you about, the expected semantics of what that list contained</p>",
        "id": 181292170,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332333
    },
    {
        "content": "<p>but now I cannot find any of the details quickly. (I restarted the relevant emacs sessions so that I could reboot the machine, and this effectively obliterates my brain's working memory.)</p>",
        "id": 181292188,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332374
    },
    {
        "content": "<p>ah, wait, thank goodness, my working directory still has my instrumentation in it</p>",
        "id": 181292616,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332790
    },
    {
        "content": "<p><code>rustc_codegen_llvm::back::lto</code>  is the relevant module in rustc</p>",
        "id": 181292736,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332873
    },
    {
        "content": "<p>and I added some code to instrument this loop: <a href=\"https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src/librustc_codegen_llvm/back/lto.rs#L509\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src/librustc_codegen_llvm/back/lto.rs#L509\">https://github.com/rust-lang/rust/blob/f1b882b55805c342e46ee4ca3beeef1d1fa2044b/src/librustc_codegen_llvm/back/lto.rs#L509</a></p>",
        "id": 181292804,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574332927
    },
    {
        "content": "<p>but of course I have since lost my build of the <code>libcore</code> for the thumbv7em target. <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span></p>",
        "id": 181292900,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574333026
    },
    {
        "content": "<p>well, I guess my question is still relevant, nonetheless: should we expect <code>import_map.modules_imported_by(module_name)</code> to include modules that hold the definitions for functions being called <em>from</em> <code>module_name</code> ? Or do I misunderstand what \"imported_by\" is meant to mean here?</p>",
        "id": 181293037,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574333129
    },
    {
        "content": "<p>(because it is just those sorts of functions, undergoing changes, that I would expect would lead us to conclude that we cannot reuse the post-ThinLTO-optimized artifact.)</p>",
        "id": 181293111,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574333182
    },
    {
        "content": "<p>iirc, <code>import_map.modules_imported_by(module_name)</code> should contain all LLVM modules that ThinLTO actually pulled definitions in from. So it is ThinLTO specific. There is another \"import step\" that is done already in rustc: All functions that are marked as <code>#[inline]</code> are instantiated in all  LLVM module that contain calls to them.</p>",
        "id": 181298766,
        "sender_full_name": "mw",
        "timestamp": 1574338828
    },
    {
        "content": "<p>so there can be functions that get \"inlined across modules\" before ThinLTO is invoked.</p>",
        "id": 181298909,
        "sender_full_name": "mw",
        "timestamp": 1574338952
    },
    {
        "content": "<p>but in that case we actually don't inline across module boundaries, we just instantiate internal copies of a given function in each calling module.</p>",
        "id": 181298953,
        "sender_full_name": "mw",
        "timestamp": 1574339000
    },
    {
        "content": "<p>this functionality comes from a time before there was ThinLTO and it yields better results than ThinLTO, so we had to keep it.</p>",
        "id": 181299049,
        "sender_full_name": "mw",
        "timestamp": 1574339056
    },
    {
        "content": "<p>The reason I asked the question is that my (old, but still possibly current) hypothesis was that ThinLTO was doing an inlining step here that is subsequently invalidated by a later incremental compile</p>",
        "id": 181299935,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574339853
    },
    {
        "content": "<p>and that we fail to deduce that we cannot reuse the post-ThinLTO-optimized object because the import_map is failing to tell us about the dependence</p>",
        "id": 181300027,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574339922
    },
    {
        "content": "<p>But I need to create my original work environment before I can provide better information</p>",
        "id": 181300053,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574339943
    },
    {
        "content": "<blockquote>\n<p>hypothesis was that ThinLTO was doing an inlining step here that is subsequently invalidated by a later incremental compile</p>\n</blockquote>\n<p>that's not what I found. it would be good to verify that you are really seeing something different than I.</p>",
        "id": 181300985,
        "sender_full_name": "mw",
        "timestamp": 1574340603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span>  I want to spend a little bit of time on this, to try to get us in sync on our mutual understanding of the problem</p>",
        "id": 181631914,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574424833
    },
    {
        "content": "<p>I can either: 1. try to recreate the steps I followed previously that led me to my earlier hypothesis, spelling out my thinking as I go in more detail. Or I could: 2. try to reproduce your result and in the process understand your thinking</p>",
        "id": 181631986,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574424889
    },
    {
        "content": "<p>I do want to at least confirm: You <em>did</em> get to a point eventually where you were yourself  reproducing the whole problem locally, right?</p>",
        "id": 181632033,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574424941
    },
    {
        "content": "<p>(it seems like you must have, based on the statements you were making. but I just want to be certain that you weren't drawing conclusions based on reading stuff I had posted.)</p>",
        "id": 181632118,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574424979
    },
    {
        "content": "<p>Yes, I was able to reproduce the linker error mentioned in the GH issue:</p>\n<div class=\"codehilite\"><pre><span></span>= note: rust-lld: error: undefined symbol: _$LT$rubble..ble..time..Duration$u20$as$u20$core..fmt..Display$GT$::fmt::h343296729f83afc4\n          &gt;&gt;&gt; referenced by time.rs:129 (src/ble/time.rs:129)\n          &gt;&gt;&gt;               /home/jonas/dev/rubble/target/thumbv7em-none-eabi/debug/deps/rubble-a38354bf4561073f.3qtzuenakrd0qcaf.rcgu.o:(_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$::fmt::h26ac05bd6f4f461e)\n</pre></div>",
        "id": 181636631,
        "sender_full_name": "mw",
        "timestamp": 1574428972
    },
    {
        "content": "<p>I was able to do so with your reproduction repro, via <code>doit2.sh</code></p>",
        "id": 181636665,
        "sender_full_name": "mw",
        "timestamp": 1574429011
    },
    {
        "content": "<p>I added <code>-Zsymbol-mangling-version=v0 -Zhuman-readable-cgu-names</code> to all rustc invocations for better readability.</p>",
        "id": 181636803,
        "sender_full_name": "mw",
        "timestamp": 1574429110
    },
    {
        "content": "<p>okay. Oh, maybe the <code>-Zsymbol-mangling-version=v0</code> is why I've been getting different symbols than you</p>",
        "id": 181637502,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574429706
    },
    {
        "content": "<p>definitely :)</p>",
        "id": 181638143,
        "sender_full_name": "mw",
        "timestamp": 1574430197
    },
    {
        "content": "<p>I don't know if we have an online demangler for the new scheme somewhere yet</p>",
        "id": 181638163,
        "sender_full_name": "mw",
        "timestamp": 1574430226
    },
    {
        "content": "<p>the <code>rustc-demangle</code> crate can handle it.</p>",
        "id": 181638236,
        "sender_full_name": "mw",
        "timestamp": 1574430261
    },
    {
        "content": "<p>it's better than the old scheme for debugging because symbol names actually contain information about generic arguments in a decodable form</p>",
        "id": 181638322,
        "sender_full_name": "mw",
        "timestamp": 1574430321
    },
    {
        "content": "<p>I've been sitting here wondering why my stage2 is taking so long to build. And then I remembered that in this build, I set llvm.optimize to false (to get assertions and try to improve my ability to use it with <code>rr</code>)</p>",
        "id": 181641555,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574432382
    },
    {
        "content": "<p>I think stage1 rustc has been building librustc for 2.5 hours</p>",
        "id": 181641620,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574432408
    },
    {
        "content": "<p>(having been interacting with rustc symbol mangling recently, I’ve been intending to try <a href=\"https://github.com/luser/rustfilt\" target=\"_blank\" title=\"https://github.com/luser/rustfilt\">rustfilt</a> when I’m next looking at things, allegedly supports the new mangling scheme)</p>",
        "id": 181642847,
        "sender_full_name": "davidtwco",
        "timestamp": 1574433248
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> <code>rustfilt</code> needs to update it's <code>rustc-demangle</code> version, but then it should work</p>",
        "id": 181644981,
        "sender_full_name": "mw",
        "timestamp": 1574434784
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> what is your schedule like today? Maybe we could pair-program on this a bit so that I can show you my observations?</p>",
        "id": 181807123,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574676341
    },
    {
        "content": "<p>(the other options is that I could try to document them, as I described <a href=\"#narrow/stream/131828-t-compiler/topic/internalize_symbols.20and.20incremental.20artifacts.20.2359535/near/181631986\" title=\"#narrow/stream/131828-t-compiler/topic/internalize_symbols.20and.20incremental.20artifacts.20.2359535/near/181631986\">above</a>. But if we can talk live, that would probably be more efficient.)</p>",
        "id": 181807186,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574676376
    },
    {
        "content": "<p>I'd could make time for this between 15:30 and 17:00 today.</p>",
        "id": 181808562,
        "sender_full_name": "mw",
        "timestamp": 1574677741
    },
    {
        "content": "<p>hmm, I have to pick up my son at school today, and I have to leave at like 15:45</p>",
        "id": 181809114,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574678226
    },
    {
        "content": "<p>we could either try for a very short sync up today, or we wait for another day</p>",
        "id": 181809126,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574678246
    },
    {
        "content": "<p>I will say that I still don't see the <em>exact</em> symbols that you are seeing in <a href=\"#narrow/stream/131828-t-compiler/topic/internalize_symbols.20and.20incremental.20artifacts.20.2359535/near/181113472\" title=\"#narrow/stream/131828-t-compiler/topic/internalize_symbols.20and.20incremental.20artifacts.20.2359535/near/181113472\">your code snippet</a>; but I see something similar enough (in terms of its code) that I do think we are talking about the same thing</p>",
        "id": 181809192,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574678287
    },
    {
        "content": "<p>you asked there where that code was coming from. I had thought it was an artifact of the derived <code>fmt::Debug</code> impl for <code>Option&lt;Duration&gt;</code>, but I don't know if I actually verified that.</p>",
        "id": 181809276,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574678385
    },
    {
        "content": "<blockquote>\n<p>I see something similar enough (in terms of its code) that I do think we are talking about <em>the same thing</em></p>\n</blockquote>\n<p>(To be clear: I mean that we are talking about the same code snippet. But I don't think we've reached consensus on what is going wrong.)</p>",
        "id": 181809762,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574678714
    },
    {
        "content": "<blockquote>\n<p>you asked there where that code was coming from. I had thought it was an artifact of the derived <code>fmt::Debug</code> impl for <code>Option&lt;Duration&gt;</code>, but I don't know if I actually verified that.</p>\n</blockquote>\n<p>(Hmm, I guess if this were the case, then we would be finding this in one of the cgu's named <code>core.xxxx-in-rubble.yyyy-coremodname.volatile.*</code>. So that impression may be wrong.)</p>",
        "id": 181810218,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574679087
    },
    {
        "content": "<p>but, oh: There is a call from <code>core.3u8ad80z-in-rubble.7rcbfp3g-option.volatile</code> over into the function we're discussing. From reading the .ll, it is indeed <del>called</del> referenced from the method <code>&lt;core::option::Option&lt;rubble::ble::Duration&gt; as core::fmt::Debug&gt;::fmt</code></p>",
        "id": 181810472,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574679349
    },
    {
        "content": "<p>I can try to make it ~15:00 if that works for you</p>",
        "id": 181818364,
        "sender_full_name": "mw",
        "timestamp": 1574685719
    },
    {
        "content": "<p>Okay yeah if you can do 15:00 I think that would be good</p>",
        "id": 181819202,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574686365
    },
    {
        "content": "<p>hey <span class=\"user-mention\" data-user-id=\"124287\">@mw</span> i have more questions</p>",
        "id": 181910762,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574766421
    },
    {
        "content": "<p>in particular, after adding some more instrumentation and then looking at things more, I noticed this:</p>",
        "id": 181910786,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574766440
    },
    {
        "content": "<p>during the first (clean) compile, we <em>do</em> observe from LLVM that the ble.volatile module imports the ble module: </p>\n<div class=\"codehilite\"><pre><span></span>[DEBUG rustc_codegen_llvm::back::lto] imported_module_callback importing_module_name: rubble.7rcbfp3g-ble.volatile imported_module_name: rubble.7rcbfp3g-ble\n</pre></div>",
        "id": 181910848,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574766492
    },
    {
        "content": "<p>but during the second compile (the one reusing incremental state, including the PostLTO optimized version of that cgu) , the data fed back from LLVM does not include that import information anymore (IOW the callback is not invoked for that importing/imported pair)</p>",
        "id": 181910913,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574766562
    },
    {
        "content": "<p>which leads me to wonder: Who is in charge in this scenario of remembering that dependency link?</p>",
        "id": 181910942,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574766602
    },
    {
        "content": "<p>since the whole point here is that the imported module <em>has</em> changed. But I think its the Rust's compilers job to know that, not LLVM's, right?</p>",
        "id": 181911009,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574766627
    },
    {
        "content": "<p>Do we somehow seed the initial LLVM state with information about previous compilation sessions? Or should we be incorporating past dependencies into this map somehow?</p>",
        "id": 181911186,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574766800
    },
    {
        "content": "<p>... Update: Using <code>rr</code> to step through the second LLVM run now. It looks like LLVM's <code>computeImportForFunction</code> may be failing to resolve the callee for the ble.volatile function's call.</p>",
        "id": 181914510,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574769933
    },
    {
        "content": "<p>AH! Huge realization: I had one hand tied behind my back this whole time because every time I tried to pass along <code>-C llvm-args=...</code>, the bug went away</p>",
        "id": 181915440,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574770777
    },
    {
        "content": "<p>But I just realized: Its because we (rightly) invalidate the previous incremental state if you don't pass the same set of llvm-args to <em>both</em> compiler invocations.</p>",
        "id": 181915469,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574770801
    },
    {
        "content": "<p>So now I just pass the same extra settings to both invocations, and <em>boom</em>, I now can start getting debug output from LLVM!</p>",
        "id": 181915515,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574770824
    },
    {
        "content": "<p>iirc, the ThinLTO import logic should always run on the full set of modules, so including the modules that we are going to re-use.</p>",
        "id": 181919449,
        "sender_full_name": "mw",
        "timestamp": 1574774185
    },
    {
        "content": "<p>So here's what LLVM debug info tells me so far:</p>",
        "id": 181919533,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774257
    },
    {
        "content": "<p>in the following, <code>rubble1</code> means the first (clean) compile, and <code>rubble2</code> means the second one that reuses previous work-products.</p>",
        "id": 181919601,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774287
    },
    {
        "content": "<p>Some <code>rubble1</code> output:</p>",
        "id": 181919605,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774295
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>* Module rubble.7rcbfp3g-ble.volatile exports 0 functions and 0 vars. Imports from 1 modules.\n - 1 functions imported from rubble.7rcbfp3g-ble\n - 0 global vars imported from rubble.7rcbfp3g-ble\n</pre></div>",
        "id": 181919627,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774315
    },
    {
        "content": "<p>analogous <code>rubble2</code> output: </p>\n<div class=\"codehilite\"><pre><span></span>* Module rubble.7rcbfp3g-ble.volatile exports 0 functions and 0 vars. Imports from 0 modules.\n</pre></div>",
        "id": 181919662,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774345
    },
    {
        "content": "<p>when I worked my way backwards to the place where these import lists were computed, I found this:</p>",
        "id": 181919690,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774367
    },
    {
        "content": "<p><code>rubble1</code> output:</p>\n<div class=\"codehilite\"><pre><span></span>Computing import for Module &#39;rubble.7rcbfp3g-ble.volatile&#39;\nInitialize import for 544407980792537262 (_RNvXsL_NtCs2KcseFXz5HB_4core3fmtRNtNtCs4fqI2P2rA04_6rubble3ble8DurationNtB5_5Debug3fmtBz_)\n edge -&gt; 5161150766116740131 (_RNvXs_NtCs4fqI2P2rA04_6rubble3bleNtB4_8DurationNtNtCs2KcseFXz5HB_4core3fmt5Debug3fmt) Threshold:100\n edge -&gt; 10788096245104502577 (_RNvXNtCs4fqI2P2rA04_6rubble3bleNtB2_8DurationNtNtCs2KcseFXz5HB_4core3fmt7Display3fmt) Threshold:70\nignored! No qualifying callee with summary found.\n</pre></div>",
        "id": 181919732,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774399
    },
    {
        "content": "<p>Analogous <code>rubble2</code> output:</p>\n<div class=\"codehilite\"><pre><span></span>Computing import for Module &#39;rubble.7rcbfp3g-ble.volatile&#39;\nInitialize import for 544407980792537262 (_RNvXsL_NtCs2KcseFXz5HB_4core3fmtRNtNtCs4fqI2P2rA04_6rubble3ble8DurationNtB5_5Debug3fmtBz_)\n edge -&gt; 5161150766116740131 (_RNvXs_NtCs4fqI2P2rA04_6rubble3bleNtB4_8DurationNtNtCs2KcseFXz5HB_4core3fmt5Debug3fmt) Threshold:100\nignored! No qualifying callee with summary found.\n</pre></div>",
        "id": 181919797,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774426
    },
    {
        "content": "<p>When I tried to step through the latter computation, it seemed like it was rejecting during <code>selectCallee</code> because of <code>ImportFailureReason::TooLarge</code></p>",
        "id": 181919891,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774514
    },
    {
        "content": "<p>But there's something super weird there. The call that its showing is the call as if the inlining didn't happen. I guess the import list construction is based on the LLVM IR prior to the optimization steps, even though we are going to end up deciding to reuse the PostLTO optimized cgu in the end?</p>",
        "id": 181920055,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774619
    },
    {
        "content": "<blockquote>\n<p>iirc, the ThinLTO import logic should always run on the full set of modules, so including the modules that we are going to re-use.</p>\n</blockquote>\n<p>So basically, it looks to me like it <em>is</em> running on the modules we are re-using, but its making different decisions about what to construct for the Import List</p>",
        "id": 181920194,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774678
    },
    {
        "content": "<p>Which actually brings me to a question I've had in the back of my mind for the past hour or so...:</p>",
        "id": 181920237,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> What do you think of this theory as to the root bug here: <code>lto.rs</code>, when it decides which modules can be reused in PostLTO form, looks at the import-list and sees if they are all on the green modules list. But it is looking at the import list that it <em>currently</em> gets from LLVM. Should we be instead (or additionally) looking at the <em>old</em> import list, from <em>the time that we did the LTO optimization that we are reusing</em>? (Presumably we would just serialize the <code>ThinLTOImports</code> and re-load that, or add it to the dep-graph maybe.)</p>",
        "id": 181920504,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774887
    },
    {
        "content": "<p>hm, so the import list of <code>rubble1</code> above says that <code>rubble.ble.volatile</code> imports from <code>rubble.ble</code>, and <code>rubble.ble</code> clearly changes in <code>rubble2</code>, so my question is: why is <code>rubble.ble.volatile</code> marked as PostLTO reuse?</p>",
        "id": 181920520,
        "sender_full_name": "mw",
        "timestamp": 1574774907
    },
    {
        "content": "<p>we are only looking at the previous import list</p>",
        "id": 181920551,
        "sender_full_name": "mw",
        "timestamp": 1574774941
    },
    {
        "content": "<p>the new import list is just stored for subsequent sessions</p>",
        "id": 181920573,
        "sender_full_name": "mw",
        "timestamp": 1574774960
    },
    {
        "content": "<p>I don't think that's true?</p>",
        "id": 181920580,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774970
    },
    {
        "content": "<p>By \"import list\" I mean the <code>ThinLTOImports</code></p>",
        "id": 181920596,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574774984
    },
    {
        "content": "<p>those are never serialized today AFAICT</p>",
        "id": 181920640,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574775003
    },
    {
        "content": "<p>(let me just make sure this hasn't changed in the last month)</p>",
        "id": 181920696,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574775038
    },
    {
        "content": "<p>maybe I'm misremembering. let me take a closer look</p>",
        "id": 181920736,
        "sender_full_name": "mw",
        "timestamp": 1574775081
    },
    {
        "content": "<p>so this <a href=\"https://github.com/rust-lang/rust/blob/0f6f66fcdc4abf110171ee06b1a72bdd2883b74f/src/librustc_codegen_llvm/back/lto.rs#L474\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/0f6f66fcdc4abf110171ee06b1a72bdd2883b74f/src/librustc_codegen_llvm/back/lto.rs#L474\"><code>import_map</code></a> is relying on <a href=\"https://github.com/rust-lang/rust/blob/0f6f66fcdc4abf110171ee06b1a72bdd2883b74f/src/librustc_codegen_llvm/back/lto.rs#L854\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/0f6f66fcdc4abf110171ee06b1a72bdd2883b74f/src/librustc_codegen_llvm/back/lto.rs#L854\">this LLVM call</a></p>",
        "id": 181920763,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574775104
    },
    {
        "content": "<p>Yes, I think what I was talking about was how I did things in the first version of the PR implementing all of this. but  that was missing out on some re-use. Maybe we need a combination of both? I need to think more thoroughly about this...</p>",
        "id": 181921169,
        "sender_full_name": "mw",
        "timestamp": 1574775380
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> would it be plausible for the incr_comp_session_dir to store, for each LTO-optimized work-product <code>M</code>, the value associated in the <code>import_map</code> for key <code>M</code> (i.e. <code>import_map[M]</code>)?</p>",
        "id": 181922735,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574776546
    },
    {
        "content": "<p>Yeah, I had already implemented that in <a href=\"https://github.com/rust-lang/rust/pull/53673\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/53673\">https://github.com/rust-lang/rust/pull/53673</a>. Alex talked me out of it <code>;)</code></p>",
        "id": 181922919,
        "sender_full_name": "mw",
        "timestamp": 1574776662
    },
    {
        "content": "<p>does that mean <a href=\"https://github.com/rust-lang/rust/pull/53673#discussion_r212702032\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/53673#discussion_r212702032\">this comment from alex</a> ?</p>",
        "id": 181923016,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574776712
    },
    {
        "content": "<p>I'm willing to treat this bug as a concrete counter-example. Though of course I'd prefer a smaller example... :(</p>",
        "id": 181923062,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574776747
    },
    {
        "content": "<p>Given all the information you've gathered so far, I have the feeling that I would understand exactly what's going if I sat down and thought about this for half an hour in peace and quiet. Unfortunately I need to run now <code>:(</code></p>",
        "id": 181923102,
        "sender_full_name": "mw",
        "timestamp": 1574776780
    },
    {
        "content": "<p>But if you want, you can assign the bug to me.</p>",
        "id": 181923179,
        "sender_full_name": "mw",
        "timestamp": 1574776806
    },
    {
        "content": "<blockquote>\n<p>does that mean <a href=\"https://github.com/rust-lang/rust/pull/53673#discussion_r212702032\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/53673#discussion_r212702032\">this comment from alex</a> ?</p>\n</blockquote>\n<p>rather this comment, I think: <a href=\"https://github.com/rust-lang/rust/pull/53673#discussion_r212708336\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/53673#discussion_r212708336\">https://github.com/rust-lang/rust/pull/53673#discussion_r212708336</a></p>",
        "id": 181923305,
        "sender_full_name": "mw",
        "timestamp": 1574776867
    },
    {
        "content": "<p>But I still haven't paged in all the logic here -- having just discovered that some of my \"knowledge\" is in fact based on a version of the PR that never landed.</p>",
        "id": 181923564,
        "sender_full_name": "mw",
        "timestamp": 1574776986
    },
    {
        "content": "<blockquote>\n<p>Yeah, I had already implemented that in <a href=\"https://github.com/rust-lang/rust/pull/53673\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/53673\">https://github.com/rust-lang/rust/pull/53673</a>. Alex talked me out of it <code>;)</code></p>\n</blockquote>\n<p>I'm guessing the answer here is \"No\", but: Do you still have the original code for this lying around somewhere, for me to look at and maybe try out myself, rather than trying to reimplement it myself?</p>",
        "id": 181926772,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574779130
    },
    {
        "content": "<p>the github comments are still referencing it, so it might be just a matter of a few clicks?</p>",
        "id": 181955069,
        "sender_full_name": "mw",
        "timestamp": 1574796451
    },
    {
        "content": "<p>The github comments say \"outdated code\" and when I tried to follow them, I got one of those pages that says \"We went looking everywhere, but couldn’t find those commits.\"</p>",
        "id": 182007550,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574851878
    },
    {
        "content": "<p>The force-push messages have working before and after commit links in them.</p>",
        "id": 182055006,
        "sender_full_name": "bjorn3",
        "timestamp": 1574885784
    },
    {
        "content": "<p>ah thanks <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> , I've always overlooked that</p>",
        "id": 182096234,
        "sender_full_name": "pnkfelix",
        "timestamp": 1574935618
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> okay I think I have a patch for this</p>",
        "id": 182188404,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575043534
    },
    {
        "content": "<p>I'm going to do some internal testing, but here is the relevant <a href=\"https://github.com/pnkfelix/rust/commit/fe85919c74686a0de188dd4900467cf40bab73f5\" target=\"_blank\" title=\"https://github.com/pnkfelix/rust/commit/fe85919c74686a0de188dd4900467cf40bab73f5\">commit</a>; it is largely inspired by the approach you referenced in that earlier PR.</p>",
        "id": 182188488,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575043588
    },
    {
        "content": "<p>Great, I'll put looking at that on my todo list</p>",
        "id": 182322558,
        "sender_full_name": "mw",
        "timestamp": 1575273383
    },
    {
        "content": "<p>at this point I'm going to spend some time today exploring whether I can make a more robust regression test</p>",
        "id": 182331935,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575282351
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> am I correct that the tests in <code>src/incremental/thinlto</code> are supposedly exercising ThinLTO because they have <code>-O</code> in their <code>// compile-flags</code> ?</p>",
        "id": 182336017,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575286010
    },
    {
        "content": "<p>yes</p>",
        "id": 182339008,
        "sender_full_name": "mw",
        "timestamp": 1575289075
    },
    {
        "content": "<p>I'm not sure I'm going to be able to construct a (robust) test case for this. Even with  the knowledge of the bug that I've garnered, I really don't know how to reliably get LLVM to reproduce the at-LTO-time inlining behavior that we need to witness on my local machine.</p>",
        "id": 182344993,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575293588
    },
    {
        "content": "<p>small functions like <code>fn foo() -&gt; u32 { 0 }</code> are imported very reliably by ThinLTO</p>",
        "id": 182345484,
        "sender_full_name": "mw",
        "timestamp": 1575293879
    },
    {
        "content": "<p>and functions with <code>#[inline(never)]</code> are also reliably not imported by ThinLTO, afaik</p>",
        "id": 182345566,
        "sender_full_name": "mw",
        "timestamp": 1575293911
    },
    {
        "content": "<p>maybe that helps?</p>",
        "id": 182345582,
        "sender_full_name": "mw",
        "timestamp": 1575293919
    },
    {
        "content": "<p>The scenario I need to recreate is one where we change our mind about whether to mark a fn as internal or not</p>",
        "id": 182346104,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575294270
    },
    {
        "content": "<p>while at the same time, LTO has inlined the reference to that (to-be-marked internal) fn into some cgu that won't be rebuilt under the old logic</p>",
        "id": 182346147,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575294306
    },
    {
        "content": "<p>I'm able to get the first step down pretty reliably</p>",
        "id": 182346159,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575294316
    },
    {
        "content": "<p>but I haven't made much luck with the second part.</p>",
        "id": 182346185,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575294341
    },
    {
        "content": "<p>I guess I could try inspecting the generated intermediate products from the LTO passes to try to figure things out more</p>",
        "id": 182346280,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575294387
    },
    {
        "content": "<p>is there an <code>#[inline(..)]</code> attribute with the effect of \"inline at link-time if possible, but not earlier.\" ?</p>",
        "id": 182360321,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575302838
    },
    {
        "content": "<p>nope</p>",
        "id": 182362196,
        "sender_full_name": "mw",
        "timestamp": 1575303935
    },
    {
        "content": "<p>but functions without an <code>#[inline]</code> attribute are guaranteed to not be inlined across CGU boundaries before ThinLTO</p>",
        "id": 182362297,
        "sender_full_name": "mw",
        "timestamp": 1575303996
    },
    {
        "content": "<p>and you can rely on different <code>mod</code>s to end up as separate CGUs (when compiling incrementally), even if they are defined in the same source file.</p>",
        "id": 182362398,
        "sender_full_name": "mw",
        "timestamp": 1575304067
    },
    {
        "content": "<p>yeah, i've been making use of the latter property</p>",
        "id": 182363695,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575304921
    },
    {
        "content": "<p>(the test infrastructure is impressive. The main thing missing is docs explaining how the tests work in the first place.)</p>",
        "id": 182363834,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575305000
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> I decided to give up on finding a more robust test</p>",
        "id": 182555195,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575466297
    },
    {
        "content": "<p>I filed PR <a href=\"https://github.com/rust-lang/rust/issues/67020\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/67020\">#67020</a>. It still has a test, it just embeds the one we've already been using as a run-make test for the corresponding thumb target.</p>",
        "id": 182555251,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575466323
    },
    {
        "content": "<p>I'll try to review tomorrow before the triage meeting</p>",
        "id": 182565781,
        "sender_full_name": "mw",
        "timestamp": 1575473158
    },
    {
        "content": "<p>thanks for your input. I really wish we could get a smaller test case</p>",
        "id": 182656310,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575550674
    },
    {
        "content": "<p>I keep musing about trying to dive deeper into my understanding of LLVM optimization passes, with the thought that if I knew the right <code>-C llvm-opts=...</code> to feed in, I could replicate this more readily (and more generally)</p>",
        "id": 182656388,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575550729
    },
    {
        "content": "<p>When you write \"Yes, but the import map is always re-computed from scratch from the entire set of modules, including the older ones\", do you mean that the import map somehow uses the state of the compiled <em>object code</em> ?</p>",
        "id": 182656435,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575550784
    },
    {
        "content": "<p>another option here, which may be unpalatable, but <strong>would</strong> satisfy your desire to ensure we don't rely on anything beyond the previous serialized import map: for each CGU, if there is any change <strong>at all</strong> to the <del>import map</del> imports for the current (green) module, just do not reuse the PostLTO object file</p>",
        "id": 182656630,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575550898
    },
    {
        "content": "<p>given that the import map seems to very rarely change for green modules, this condition seems like it would fire so rarely that it would not regress anything.</p>",
        "id": 182656718,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575550949
    },
    {
        "content": "<p>oh, maybe this is what you meant by \" If the two things match up\" ?</p>",
        "id": 182656763,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575550995
    },
    {
        "content": "<blockquote>\n<p>When you write \"Yes, but the import map is always re-computed from scratch from the entire set of modules, including the older ones\", do you mean that the import map somehow uses the state of the compiled <em>object code</em> ?</p>\n</blockquote>\n<p>the import map is based on the state of the pre-optimization LLVM bitcode (which we also keep around for cached modules)</p>",
        "id": 182656795,
        "sender_full_name": "mw",
        "timestamp": 1575551038
    },
    {
        "content": "<blockquote>\n<p>another option here, which may be unpalatable, but <strong>would</strong> satisfy your desire to ensure we don't rely on anything beyond the previous serialized import map: for each CGU, if there is any change <strong>at all</strong> to the import map, just do not reuse the PostLTO object file</p>\n</blockquote>\n<p>I need to think about that. It might be the correct fix actually</p>",
        "id": 182656956,
        "sender_full_name": "mw",
        "timestamp": 1575551147
    },
    {
        "content": "<p>I would have no problem adopting the latter.</p>",
        "id": 182656969,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551160
    },
    {
        "content": "<p>and I think I could hack it up fast</p>",
        "id": 182657015,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551168
    },
    {
        "content": "<p>just set-equality; so sort both slices and compare them for equality. easy peasy.</p>",
        "id": 182657044,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551200
    },
    {
        "content": "<p>I can believe that it is correct and clean because it sounds like a manual re-implementation of the red-green algorithm</p>",
        "id": 182657071,
        "sender_full_name": "mw",
        "timestamp": 1575551224
    },
    {
        "content": "<p>okay cool, i prefer this</p>",
        "id": 182657105,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551277
    },
    {
        "content": "<p>and then only save the \"current\" version of the import map?</p>",
        "id": 182657167,
        "sender_full_name": "mw",
        "timestamp": 1575551303
    },
    {
        "content": "<p>exactly</p>",
        "id": 182657247,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551391
    },
    {
        "content": "<p>that sounds good then</p>",
        "id": 182657297,
        "sender_full_name": "mw",
        "timestamp": 1575551404
    },
    {
        "content": "<p>let me go ahead and give it a whirl. I just finished pushing a new version of the PR with the test fixed in a couple ways</p>",
        "id": 182657308,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551417
    },
    {
        "content": "<p>oh but I guess I need to do triage for the rustc meeting first (!)</p>",
        "id": 182657336,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551451
    },
    {
        "content": "<p>i'll follow up on this after the meeting.</p>",
        "id": 182657345,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551462
    },
    {
        "content": "<p>(or when I finish triage; whichever comes first)</p>",
        "id": 182657356,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551477
    },
    {
        "content": "<p>this bug is a cautionary tale about trying to do incremental compilation outside of the well-tested framework <code>:)</code></p>",
        "id": 182657360,
        "sender_full_name": "mw",
        "timestamp": 1575551481
    },
    {
        "content": "<p>no rush <code>:)</code></p>",
        "id": 182657372,
        "sender_full_name": "mw",
        "timestamp": 1575551496
    },
    {
        "content": "<p>its definitely getting on my list of \"favorite bugs\" now, though</p>",
        "id": 182657375,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551501
    },
    {
        "content": "<p>right up there with some great GC bugs I tracked down back in the day</p>",
        "id": 182657387,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551514
    },
    {
        "content": "<p>It also has led me to think harder about how to go about testing incremental in the first place</p>",
        "id": 182657468,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551562
    },
    {
        "content": "<p>my favorite is still a random memory corruption/dangling pointer bug in LLVM that only rustc triggered :)</p>",
        "id": 182657477,
        "sender_full_name": "mw",
        "timestamp": 1575551574
    },
    {
        "content": "<p>this was my attempt to create a test that would expose the bug for me locally: <a href=\"https://gist.github.com/pnkfelix/8a5870135def2f6c46bbd37feed70e2c\" target=\"_blank\" title=\"https://gist.github.com/pnkfelix/8a5870135def2f6c46bbd37feed70e2c\">https://gist.github.com/pnkfelix/8a5870135def2f6c46bbd37feed70e2c</a></p>",
        "id": 182657520,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551616
    },
    {
        "content": "<p>I was basically trying to manually enumerate as many ways to combine calls between modules that I could think of</p>",
        "id": 182657605,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575551660
    },
    {
        "content": "<p>I'll probably give this a quick try tomorrow morning, just from the scenario description in your PR.</p>",
        "id": 182657800,
        "sender_full_name": "mw",
        "timestamp": 1575551830
    },
    {
        "content": "<blockquote>\n<p>I'll probably give this a quick try tomorrow morning, just from the scenario description in your PR.</p>\n</blockquote>\n<p>making a test, you mean? That would be great.</p>",
        "id": 182658069,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575552056
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> FYI I have updated the PR with the simpler strategy. It makes me happy.</p>",
        "id": 182707560,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575581970
    },
    {
        "content": "<p>I'm so proud: <a href=\"https://github.com/rust-lang/rust/pull/67020#issuecomment-562526208\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/67020#issuecomment-562526208\">https://github.com/rust-lang/rust/pull/67020#issuecomment-562526208</a></p>",
        "id": 182749019,
        "sender_full_name": "mw",
        "timestamp": 1575629499
    },
    {
        "content": "<p>Your description of the failure scenario is spot on</p>",
        "id": 182749096,
        "sender_full_name": "mw",
        "timestamp": 1575629530
    },
    {
        "content": "<p>I cannot say how happy I am you found that</p>",
        "id": 182749333,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575629713
    },
    {
        "content": "<p>import-instr-limit seems important. :)</p>",
        "id": 182749353,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575629739
    },
    {
        "content": "<p>(as in, I should learn about it. it may have made my life easier)</p>",
        "id": 182749366,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575629752
    },
    {
        "content": "<p>it should make the test more stable, although I don;t think it is needed with the current defaults</p>",
        "id": 182749422,
        "sender_full_name": "mw",
        "timestamp": 1575629770
    },
    {
        "content": "<p>I only found out about it recently too</p>",
        "id": 182749438,
        "sender_full_name": "mw",
        "timestamp": 1575629797
    },
    {
        "content": "<p>the fact that the intermediate function needs to be a certain size was something I was not paying attention to in my attempts to replicate</p>",
        "id": 182749471,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575629840
    },
    {
        "content": "<p>it needs to be not too big, but not too small either, right?</p>",
        "id": 182749483,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575629851
    },
    {
        "content": "<p>(it can massively speed up optimized compilation in exchange for slightly lower runtime performance: <a href=\"https://github.com/rust-lang/rust/pull/66625\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/66625\">https://github.com/rust-lang/rust/pull/66625</a>)</p>",
        "id": 182749490,
        "sender_full_name": "mw",
        "timestamp": 1575629855
    },
    {
        "content": "<p>(I'm speaking of <code>foo::bar</code>, here)</p>",
        "id": 182749494,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575629861
    },
    {
        "content": "<p>Since it is an <code>internal</code> function in cfail2 and LLVM knows that there is only a single call site, it will probably inline it even if it gets very big</p>",
        "id": 182749588,
        "sender_full_name": "mw",
        "timestamp": 1575629912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> I assume we'd all be happiest if I incorporate your new test into my PR. <span aria-label=\"smiley\" class=\"emoji emoji-1f603\" role=\"img\" title=\"smiley\">:smiley:</span></p>",
        "id": 182759314,
        "sender_full_name": "pnkfelix",
        "timestamp": 1575638470
    },
    {
        "content": "<p>yes please</p>",
        "id": 182760974,
        "sender_full_name": "mw",
        "timestamp": 1575639664
    },
    {
        "content": "<p>Very nice compilation time speedup! I would love to see that in CI.</p>",
        "id": 183115529,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1576022376
    },
    {
        "content": "<blockquote>\n<p>Very nice compilation time speedup! I would love to see that in CI.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> this was aimed at a different topic, no?</p>",
        "id": 183206585,
        "sender_full_name": "pnkfelix",
        "timestamp": 1576101634
    },
    {
        "content": "<p>No, it was related to <a href=\"https://github.com/rust-lang/rust/pull/66625\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/66625\">https://github.com/rust-lang/rust/pull/66625</a> posted above.</p>",
        "id": 183206771,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1576101760
    }
]