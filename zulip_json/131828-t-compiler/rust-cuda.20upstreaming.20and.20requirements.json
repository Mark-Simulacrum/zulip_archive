[
    {
        "content": "<p>There was also another issue i was wondering about, the codegen exposes internal things to cuda_std, then cuda_std provides a stable interface to them, it is kind of impossible to do anything with the codegen unless you also use cuda_std. How would this issue be resolved? it would be a bit useless to have a stable target and an unstable interface to it</p>",
        "id": 264110948,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638937946
    },
    {
        "content": "<p>Would we have to stabilize an interface to the codegen through something like core::arch or something?</p>",
        "id": 264110987,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938030
    },
    {
        "content": "<p>But then you get into the issue of having to bump MSRV every time the codegen wants to add a new feature, because now cuda_std only works with that stable version and up</p>",
        "id": 264111064,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938097
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> should prob also rename this thread to something better, like rust-cuda upstreaming or something</p>",
        "id": 264111195,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938202
    },
    {
        "content": "<p>Either that, or core exposes the internal stuff through itself, like declaring a kernel, then cuda_std builds on top of that, but then you still have the MSRV issue</p>",
        "id": 264111242,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938278
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/131828-t-compiler/topic/rust-cuda.20upstreaming.20and.20requirements/near/264110987\">said</a>:</p>\n<blockquote>\n<p>Would we have to stabilize an interface to the codegen through something like core::arch or something?</p>\n</blockquote>\n<p>Ideally you'd expose appropriate target-specific intrinsics, and then if someone wants to implement that same target on another codegen they could implement those same intrinsics.</p>",
        "id": 264111306,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938329
    },
    {
        "content": "<p>Another alternative would be to expose higher-level mechanisms in <code>std</code>.</p>",
        "id": 264111324,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938348
    },
    {
        "content": "<p>Well the codegen actually communicates mostly through attrs</p>",
        "id": 264111333,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938365
    },
    {
        "content": "<p>We've also talked about the idea of having <code>-Zbuild-std</code> work for a std that comes from <a href=\"http://crates.io\">crates.io</a>...</p>",
        "id": 264111336,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938370
    },
    {
        "content": "<p>currently for declaring kernels and declaring address spaces for statics</p>",
        "id": 264111341,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/131828-t-compiler/topic/rust-cuda.20upstreaming.20and.20requirements/near/264111333\">said</a>:</p>\n<blockquote>\n<p>Well the codegen actually communicates mostly through attrs</p>\n</blockquote>\n<p>(Side note: those would need to get reviewed for stabilization, orthogonally to the target being upstreamed.)</p>",
        "id": 264111346,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938387
    },
    {
        "content": "<p>Yeah</p>",
        "id": 264111353,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938397
    },
    {
        "content": "<p>There aren't a ton of things that need special codegen handling, and i could prob knock most of those out before stabilization, but im not sure</p>",
        "id": 264111419,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938429
    },
    {
        "content": "<p>the 2 major things are <code>#[nvvm_internal(kernel)]</code>, and <code>#[nvvm_internal(address_space(...)]</code></p>",
        "id": 264111440,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938459
    },
    {
        "content": "<p>FWIW, \"address spaces for statics\" (and for non-statics) is something I'd love to have a <em>general</em> attribute for, not just cuda.</p>",
        "id": 264111445,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938463
    },
    {
        "content": "<p>Yeah i could probably PR the stuff i did to cg_nvvm back to cg_llvm for that</p>",
        "id": 264111465,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938486
    },
    {
        "content": "<p><code>#[address_space(...)]</code> should be a thing, no <code>nvvm</code> required.</p>",
        "id": 264111466,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938486
    },
    {
        "content": "<p>hmm yeah but nobody remembers address space numbers for cuda ;)</p>",
        "id": 264111477,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938506
    },
    {
        "content": "<p>They should ideally have semantic names. :)</p>",
        "id": 264111484,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938516
    },
    {
        "content": "<p>(or strings interpretable by the target, perhaps)</p>",
        "id": 264111521,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938526
    },
    {
        "content": "<p>like target-specific options?</p>",
        "id": 264111523,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938528
    },
    {
        "content": "<p>Can you give me an example of what the CUDA address spaces actually are?</p>",
        "id": 264111535,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938546
    },
    {
        "content": "<p>theres 4 of them, global, shared, constant, and local, global is normal memory every thread can use, shared is super fast memory shared in individual blocks, constant is global mem but read-only, local is thread-local memory</p>",
        "id": 264111550,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938583
    },
    {
        "content": "<p>each one has its own weird things, like anything declared in shared will be uninitialized no matter if u specify an initializer (libnvvm will delete it)</p>",
        "id": 264111569,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938614
    },
    {
        "content": "<p>So, I think something like <code>#[address_space(\"constant\")]</code> or <code>#[address_space(\"local\")]</code> might make sense.</p>",
        "id": 264111571,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938615
    },
    {
        "content": "<p>although one big thing i do is automatically put any freeze/non-mutable static in constant addrspace, but thats mostly a codegen detail</p>",
        "id": 264111612,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/131828-t-compiler/topic/rust-cuda.20upstreaming.20and.20requirements/near/264111569\">said</a>:</p>\n<blockquote>\n<p>each one has its own weird things, like anything declared in shared will be uninitialized no matter if u specify an initializer (libnvvm will delete it)</p>\n</blockquote>\n<p>One nice thing about the compiler semantically understanding the address spaces: we should warn or possibly error if you have an initializer then.</p>",
        "id": 264111625,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938651
    },
    {
        "content": "<p>but then that gets into target-specific handling...</p>",
        "id": 264111631,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938665
    },
    {
        "content": "<p>a lot of it</p>",
        "id": 264111632,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938667
    },
    {
        "content": "<p>That's fine, the address spaces <em>can</em> be target specific.</p>",
        "id": 264111637,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938678
    },
    {
        "content": "<p>it would have to be a very unsafe attr, but we dont have those yet</p>",
        "id": 264111648,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938692
    },
    {
        "content": "<p>We have attributes that you can't write if you have <code>deny(unsafe_code)</code>.</p>",
        "id": 264111666,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938717
    },
    {
        "content": "<p>hmm</p>",
        "id": 264111670,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938725
    },
    {
        "content": "<p>Like no_mangle.</p>",
        "id": 264111673,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938730
    },
    {
        "content": "<p>oh can you really not do that?</p>",
        "id": 264111681,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938740
    },
    {
        "content": "<p>i didnt know that</p>",
        "id": 264111682,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938743
    },
    {
        "content": "<p>i mean, i know how no_mangle can cause ub</p>",
        "id": 264111684,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938748
    },
    {
        "content": "<p>We did a review a while back and marked any attribute that could cause UB as effectively unsafe.</p>",
        "id": 264111729,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938766
    },
    {
        "content": "<p>Yeah the address space issue isnt too bad, but the <code>#[kernel]</code> issue is much more target-specific</p>",
        "id": 264111745,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938789
    },
    {
        "content": "<p>So, can you explain what <code>#[kernel]</code> identifies in CUDA? An entry point?</p>",
        "id": 264111757,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938803
    },
    {
        "content": "<p>(I know what a kernel is in general, I'm asking what the attribute means.)</p>",
        "id": 264111772,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938843
    },
    {
        "content": "<p>It does a lot of things actually, it does safety checks like making sure params are Copy, it marks the function extern C, it forces it to have no return value, (not added yet) it parses some custom attributes for optimization, it tells the codegen to not remove it during DCE, and tells libnvvm its a kernel</p>",
        "id": 264111782,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938863
    },
    {
        "content": "<p>So, my <em>first</em> guess would be to make it an ABI. <code>extern \"cuda-kernel\"</code>.</p>",
        "id": 264111830,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938908
    },
    {
        "content": "<p>We already have target-specific ABIs.</p>",
        "id": 264111837,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938921
    },
    {
        "content": "<p>thats kind of a thing, <code>extern \"ptx-kernel\"</code>, but its broken currently</p>",
        "id": 264111839,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938924
    },
    {
        "content": "<p>We could fix it. :)</p>",
        "id": 264111846,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938932
    },
    {
        "content": "<p>Yeah</p>",
        "id": 264111848,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938935
    },
    {
        "content": "<p>Seems preferable, rather than an attribute.</p>",
        "id": 264111850,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938945
    },
    {
        "content": "<p>the codegen also does some special abi handling for it, like guaranteeing the pass modes of certain things</p>",
        "id": 264111859,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938954
    },
    {
        "content": "<p>That sounds even more like an <code>extern \"ABI\"</code>. :)</p>",
        "id": 264111867,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638938965
    },
    {
        "content": "<p>im also not 100% sure, but i think you are not allowed to call kernels from other kernels or other functions</p>",
        "id": 264111872,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938972
    },
    {
        "content": "<p>so that may need a little bit of rustc handling</p>",
        "id": 264111881,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638938992
    },
    {
        "content": "<p>That still seems OK to me, in terms of how much we expect rustc to know about a target-specific ABI.</p>",
        "id": 264111946,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638939039
    },
    {
        "content": "<p>nvvm also has some special properties u can provide for kernels through metadata which are helpful <a href=\"https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html#global-property-annotation-chapter-11\">https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html#global-property-annotation-chapter-11</a></p>",
        "id": 264111972,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939073
    },
    {
        "content": "<p>minctasm, reqntid, and maxntid</p>",
        "id": 264111987,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939096
    },
    {
        "content": "<p>i havent implemented them yet but i plan to in the future</p>",
        "id": 264111992,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939106
    },
    {
        "content": "<p>Other than that, i don't think theres anything else that needs special codegen communication</p>",
        "id": 264112135,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939250
    },
    {
        "content": "<p>everything else is inline asm or intrinsics</p>",
        "id": 264112145,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939257
    },
    {
        "content": "<p>although i cant link to llvm intrinsics on stable because its unstable <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 264112160,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939292
    },
    {
        "content": "<p>so that will probably be a blocker for stabilization since you need llvm intrinsics to do literally anything inside of a cuda kernel, including querying the thread id</p>",
        "id": 264112366,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939540
    },
    {
        "content": "<p>well... you can use inline asm but that is kind of cursed and probably inefficient</p>",
        "id": 264112376,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638939554
    },
    {
        "content": "<p>You could wrap those intrinsics in stable APIs.</p>",
        "id": 264116615,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638944697
    },
    {
        "content": "<p>(even if the stable APIs just re-export the intrinsics.)</p>",
        "id": 264116621,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638944704
    },
    {
        "content": "<p>Yeah, core::arch::nvptx already has some of them, but its unstable because of stdsimd, so we may have to decouple arch::nvptx from stdsimd, since stdsimd is years away from being stable. Its missing a lot of things too but that can be fixed</p>",
        "id": 264208980,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638992442
    },
    {
        "content": "<p>As for per-kernel attributes, im not sure what could be done, i dont see a way to do it without a special attr</p>",
        "id": 264209135,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638992519
    },
    {
        "content": "<p>Also, for address spaces, the only reason i could do it in my codegen is because libnvvm has the concept of generic pointers (not in a specific addrspace), so i could just addrspacecast the global from specific to generic when rustc wants it, otherwise, its kind of impossible to do because rustc would need to keep track of addrspaces since llvm doesnt allow things like bitcasting between addrspaces</p>",
        "id": 264209401,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638992627
    },
    {
        "content": "<p>although i think llvm has an InferAddressSpaces pass which can \"expand\" generic address spaces to specific</p>",
        "id": 264209501,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638992662
    },
    {
        "content": "<p>As for the ptx-kernel abi, should i open an issue of some sort detailing what needs to be done? that can be fixed before upstreaming the whole codegen</p>",
        "id": 264209804,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638992802
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/131828-t-compiler/topic/rust-cuda.20upstreaming.20and.20requirements/near/264209804\">said</a>:</p>\n<blockquote>\n<p>As for the ptx-kernel abi, should i open an issue of some sort detailing what needs to be done? that can be fixed before upstreaming the whole codegen</p>\n</blockquote>\n<p>Makes sense to me.</p>",
        "id": 264211672,
        "sender_full_name": "bjorn3",
        "timestamp": 1638993567
    },
    {
        "content": "<p>Alright, most of the work id say is deciding on how different types should be passed through the ABI. Which is <strong>very</strong> important because if it is unpredictable it can yield some nice unsoundness</p>",
        "id": 264212195,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638993762
    },
    {
        "content": "<p>Currently the codegen defines the following pass modes for the following types:</p>\n<ul>\n<li>ADTs are always passed by value.</li>\n<li>Arrays are passed by value</li>\n<li>Slices are passed as 2 params, pointer and length.</li>\n<li>ZSTs are ignored</li>\n<li>Primitives map to special ptx types, 128 bit numbers are passed as byte arrays (same as structs)</li>\n</ul>",
        "id": 264212386,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1638993855
    }
]