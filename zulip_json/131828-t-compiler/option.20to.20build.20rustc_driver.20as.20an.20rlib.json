[
    {
        "content": "<p>Hey everyone,</p>\n<p>We are playing around with the idea of building a custom statically linked rustc. We have a custom build setup for the toolchain, we build it once in a while and distribute it to clients, e.g., via Bazel rules. Having a statically linked rustc would simplify our distribution setup and we hope could save a bit of rustc startup runtime overhead. Additionally when we use rustc in some content addressable store build environments we have seen some issues around dynamic library search path resolution and dynamic library symlink canonization that a more statically linked rustc could alleviate.</p>\n<p>IIUC, the major reason why we can't have a statically linked rustc right now is that rustc_driver is only built as a dylib. What do you think about providing an option to build rustc_driver as an rlib as well?</p>\n<p>The main use case is rustc, but this would allow other tools from the toolchain that dynamically link to the rustc_driver to be built in a more statically linked mode.</p>",
        "id": 275345445,
        "sender_full_name": "Krasimir Georgiev",
        "timestamp": 1647334913
    },
    {
        "content": "<p>Fully statically linked rustc can't load proc macros. Rustc statically linked rustc_driver but dynamically linked libc can still load them. However it can't load custom codegen backends. The llvm backend is linked into rustc_driver. The experimental gcc and cranelift backends are dynamically linked to rustc_driver and then dlopened at runtime. (a statically linked rustc also can't load rustc plugins, but those are deprecated and almost entirely removed already anyway)</p>",
        "id": 275349499,
        "sender_full_name": "bjorn3",
        "timestamp": 1647337247
    },
    {
        "content": "<p>What are the exact problems you have? We use rpath to allow the toolchain to be placed anywhere without having to use <code>LD_LIBRARY_PATH</code>?</p>",
        "id": 275349542,
        "sender_full_name": "bjorn3",
        "timestamp": 1647337289
    },
    {
        "content": "<p>If you really need you can manually patch <code>compiler/rustc_driver/Cargo.toml</code> to omit <code>crate-type = [\"dylib\"]</code>.</p>",
        "id": 275349637,
        "sender_full_name": "bjorn3",
        "timestamp": 1647337339
    },
    {
        "content": "<p>Thank you!</p>\n<blockquote>\n<p>If you really need you can manually patch compiler/rustc_driver/Cargo.toml to omit crate-type = [\"dylib\"].</p>\n</blockquote>\n<p>We are experimenting with something something exactly like that.</p>\n<blockquote>\n<p>it can't load custom codegen backends</p>\n</blockquote>\n<p>I think not being able to dynamically load custom backends is workable, but will double check. If we want to support the gcc or cranelift backends we could define a variant of the toolchain that statically links those, if that's possible.</p>\n<blockquote>\n<p>Fully statically linked rustc can't load proc macros. Rustc statically linked rustc_driver but dynamically linked libc can still load them.</p>\n</blockquote>\n<p>Interesting! How does rustc load proc macros? (but yeah the resulting rustc binary when rustc_driver is statically linked will still be dynamically linked to libc AFAICT).</p>\n<blockquote>\n<p>What are the exact problems you have? We use rpath to allow the toolchain to be placed anywhere without having to use LD_LIBRARY_PATH?</p>\n</blockquote>\n<p>We've got a couple of problems related to building in environments with content addressable storage. The setup is described in this $EXEC_ORIGIN patch:<br>\n<a href=\"https://sourceware.org/legacy-ml/libc-alpha/2017-10/msg01109.html\">https://sourceware.org/legacy-ml/libc-alpha/2017-10/msg01109.html</a>.<br>\nIn a content addressable environment, the toolchain setup looks something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>ls $sysroot -lR\n  bin/rustc -&gt; /cas/3b36eaa4/3b36eaa4-a337-4186-a614-653a8033d557\n  lib/librustc_driver-123.so -&gt; /cas/171f0b2a/171f0b2a-c176-4c56-ad98-f9b5d8cfcc5c\n</code></pre></div>\n<p>One problem is that using an rpath $ORIGIN resolves to the symlink directory, where relative paths to the rustc_driver don't work. This can be addressed by patching the rustc binary using the above $EXEC_ORIGIN patch.</p>\n<p>Another problem is that rustc canonizes paths to dynamic libraries which effectively breaks the library search. We believe it's coming from here: <a href=\"https://github.com/rust-lang/rust/blob/3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8/compiler/rustc_metadata/src/locator.rs#L434\">https://github.com/rust-lang/rust/blob/3ba1ebea122238d1a5c613deb1bf60ce24bd8fd8/compiler/rustc_metadata/src/locator.rs#L434</a>. I'm not sure what are the reasons for this canonization in the first place and whether it would be reasonable to adapt rustc for this use case.</p>",
        "id": 275356632,
        "sender_full_name": "Krasimir Georgiev",
        "timestamp": 1647341489
    },
    {
        "content": "<blockquote>\n<p>Interesting! How does rustc load proc macros?</p>\n</blockquote>\n<p>Proc macros are dynamic libraries that are dlopen'ed. If libc is statically linked, dlopen doesn't work. Unlike codegen backends they don't depend on <a href=\"http://rustc_driver.so\">rustc_driver.so</a> though. libproc_macro is statically linked into the proc macro and rustc. It is specifically designed such that multiple copies of it can interact even if compiled with different rustc version. (this is necessary for bootstrapping)</p>\n<blockquote>\n<p>If we want to support the gcc or cranelift backends we could define a variant of the toolchain that statically links those, if that's possible.</p>\n</blockquote>\n<p>It is possible, but it will require patching the source of rustc and the codegen backend. Basically the codegen backend has to get a dependency on the respective compiler crates rather than loading it from the sysroot. rustc_interface needs to be patched to add a cargo dependency on the codegen backend and to add a case in rustc_interface/src/util.rs to run the respective codegen backend when the right <code>-Zcodegen-backend=</code> is passed.</p>",
        "id": 275360338,
        "sender_full_name": "bjorn3",
        "timestamp": 1647343973
    },
    {
        "content": "<blockquote>\n<p>One problem is that using an rpath $ORIGIN resolves to the symlink directory, where relative paths to the rustc_driver don't work. This can be addressed by patching the rustc binary using the above $EXEC_ORIGIN patch.</p>\n</blockquote>\n<p>A bit hacky but assuming that the content addressable storage path is stable would it be possible to patch the DT_NEEDED path from <code>$ORIGIN/../lib/librustc_driver-*.so</code> to <code>/cas/.../...</code>?</p>",
        "id": 275360524,
        "sender_full_name": "bjorn3",
        "timestamp": 1647344103
    },
    {
        "content": "<blockquote>\n<p>Another problem is that rustc canonizes paths to dynamic libraries which effectively breaks the library search.</p>\n</blockquote>\n<p>This was added in <a href=\"https://github.com/rust-lang/rust/commit/8922fa01228f5161aa0ebd714f86f2712a3c7ea8\">https://github.com/rust-lang/rust/commit/8922fa01228f5161aa0ebd714f86f2712a3c7ea8</a> to prevent an error when two symlinks point to the same file. How exactly does it break library search for you?</p>",
        "id": 275360922,
        "sender_full_name": "bjorn3",
        "timestamp": 1647344359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"478017\">@Krasimir Georgiev</span></p>",
        "id": 275360951,
        "sender_full_name": "bjorn3",
        "timestamp": 1647344378
    },
    {
        "content": "<p>For the $ORIGIN issue, we can just patch rustc, not a biggie. I hope that eventually some form of $EXEC_ORIGIN support lands upstream and we can use that then.</p>\n<p>For breaking library search, I came up with this that seems to roughly approximate what we're seeing with cas:<br>\n<a href=\"https://gist.github.com/krasimirgg/14179e9ddc73b051c1a1c9eefc7cd25a\">https://gist.github.com/krasimirgg/14179e9ddc73b051c1a1c9eefc7cd25a</a>.</p>",
        "id": 275492041,
        "sender_full_name": "Krasimir Georgiev",
        "timestamp": 1647426916
    },
    {
        "content": "<p>I think that could be fixed by switching from the <code>-lfoo</code> to the <code>-l:/path/to/foo</code> syntax for the linker in case the filename doesn't match whatever the linker expects as library name. The relevant code can be found here: <a href=\"https://github.com/rust-lang/rust/blob/d8e564715e0eb17130e99e8fcc92a36fce7feaf5/compiler/rustc_codegen_ssa/src/back/link.rs#L2368-L2381\">https://github.com/rust-lang/rust/blob/d8e564715e0eb17130e99e8fcc92a36fce7feaf5/compiler/rustc_codegen_ssa/src/back/link.rs#L2368-L2381</a></p>",
        "id": 275494344,
        "sender_full_name": "bjorn3",
        "timestamp": 1647428301
    },
    {
        "content": "<p>Ah nice! I believe it would be better to switch from the <code>-lfoo</code> to (literally) <code>/path/to/foo</code>, or else to <code>-l:foo</code>. Afaik the <code>-l:</code> doesn't work with absolute paths like that. The <code>-l:</code> would work to specify the verbatim basename, where it still searches for it in the library search path. I'll try this out.</p>",
        "id": 275494999,
        "sender_full_name": "Krasimir Georgiev",
        "timestamp": 1647428736
    },
    {
        "content": "<p>Does literally <code>/path/to/foo</code> work for dylibs?</p>",
        "id": 275496364,
        "sender_full_name": "bjorn3",
        "timestamp": 1647429607
    },
    {
        "content": "<p>At link time both <code>-l:foo</code> and <code>/path/to/foo</code> work for dylibs (at leaston linux with ld). However these paths get embedded in the produced binary (<code>ldd</code> reports <code>foo</code> when using <code>-l:foo</code> and <code>/path/to/foo</code> when using <code>/path/to/foo</code>), which is not great (binaries fail to dynamically link since at binary run time the cas structure may be different). How about if we either:</p>\n<ol>\n<li>don't do canonization for dylibs, or</li>\n<li>try to do canonization for dylibs, and if the canonical name doesn't match the <code>libfoo.so</code> pattern (on linux, in general platform-dependent), fall back to using the symlink path and name to derive the linker arguments?<br>\nc.f. <a href=\"https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler/rustc_metadata/src/locator.rs#L434\">https://github.com/rust-lang/rust/blob/f132bcf3bdf6d3ff9be7d02e8d0088b99007cd5e/compiler/rustc_metadata/src/locator.rs#L434</a></li>\n</ol>",
        "id": 277106208,
        "sender_full_name": "Krasimir Georgiev",
        "timestamp": 1648626799
    }
]