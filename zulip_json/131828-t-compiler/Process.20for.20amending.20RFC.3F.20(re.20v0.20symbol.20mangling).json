[
    {
        "content": "<p>It looks like we'll want to extend the v0 symbol mangling scheme to allow for \"vendor-specific suffixes\" because LLVM will append <code>.llvm.&lt;numbers&gt;</code> to some symbols during ThinLTO (see <a href=\"https://github.com/rust-lang/rust/pull/89917#issuecomment-963755731\">https://github.com/rust-lang/rust/pull/89917#issuecomment-963755731</a> for more info).</p>\n<p>What's the process for making a change to an RFC? Do we just open a PR to the RFC repo? It looks like we've done that <a href=\"https://github.com/rust-lang/rfcs/pull/3130\">here</a> for example and the RFC got updated without much discussion. I wonder if that is visible enough though? Maybe do an FCP on the PR that amends the RFC?</p>",
        "id": 261137860,
        "sender_full_name": "mw",
        "timestamp": 1636639643
    },
    {
        "content": "<p>I think an amendment to the RFC is fine, but I also would encourage us to move the \"canonical\" docs into something like src/doc/rustc (or the unstable book, since it's not technically stable yet) -- and then we can edit with PRs to rust-lang/rust (maybe FCP'd)</p>",
        "id": 261138745,
        "sender_full_name": "simulacrum",
        "timestamp": 1636640147
    },
    {
        "content": "<p>I'm fine with any approach as long as there a single source of truth.</p>",
        "id": 261139316,
        "sender_full_name": "mw",
        "timestamp": 1636640421
    },
    {
        "content": "<p>I would also lean towards migrating the docs to the unstable book and then to the rustc book.  They will need to be captured outside of the RFC eventually, and now seems as good as time as any.</p>",
        "id": 261147594,
        "sender_full_name": "Eric Huss",
        "timestamp": 1636644589
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> I'm surprised that sticks around in the final binary.</p>",
        "id": 261163308,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636652078
    },
    {
        "content": "<p>Or is this about intermediate objects?</p>",
        "id": 261163340,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636652093
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$ </span>nm librustc_driver-535ad5bbd58fc935.so  <span class=\"p\">|</span> grep --count -F .llvm.\n<span class=\"go\">22865</span>\n</code></pre></div>",
        "id": 261171835,
        "sender_full_name": "tm",
        "timestamp": 1636656941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Final binary. I'm seeing lots of non-demangled <code>.llvm.&lt;numbers&gt;</code> symbols in Cachegrind output, because the Valgrind (libiberty) v0 demangler doesn't handle the suffixes.</p>",
        "id": 261175884,
        "sender_full_name": "nnethercote",
        "timestamp": 1636659217
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Huh. Any idea why those suffixes stick around in the final binary?</p>",
        "id": 261194251,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671949
    },
    {
        "content": "<p>Symbols wouldn't go away unless you strip them</p>",
        "id": 261198573,
        "sender_full_name": "Gary Guo",
        "timestamp": 1636675775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> As I understand it, ThinLTO needs to make some previously private symbols public so they can be accessed from other object files (e.g. if a function <code>fn foo() -&gt; u32 { return some_large_private_fn(); }</code> gets imported into another module, <code>some_large_private_fn</code> must be reachable externally. But since there might be other symbols called <code>some_large_private_fn</code> somewhere else, the suffix is added to disambiguate the name. Since ThinLTO still works with separate object files and there can also be regular object files in the mix, a ThinLTO'd object file (after codegen) still has to look like a regular object file to the linker.</p>",
        "id": 261259361,
        "sender_full_name": "mw",
        "timestamp": 1636727408
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>, to clarify: you expected all <code>.llvm.</code> symbols to be removed from the final binary because all relocations referring to them have been replaced by actual addresses?</p>",
        "id": 261262533,
        "sender_full_name": "mw",
        "timestamp": 1636728817
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>, <span class=\"user-mention\" data-user-id=\"120518\">@Eric Huss</span> if we move the specification from the RFC into documentation then I think the <a href=\"https://doc.rust-lang.org/reference/\">Reference</a> would be the best place. It already has sections on linkage, ABI, and the runtime, for example.</p>",
        "id": 261263070,
        "sender_full_name": "mw",
        "timestamp": 1636729023
    },
    {
        "content": "<p>Seems OK to me.</p>",
        "id": 261263147,
        "sender_full_name": "simulacrum",
        "timestamp": 1636729066
    },
    {
        "content": "<p>It would also be good to update the RFC to contain a note that the official specification lives at <code>{url}</code>.</p>",
        "id": 261264075,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1636729351
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> Ah, I see! No, I had expected the suffixes to disappear, but that's because I thought they were modifications of public symbols, not private ones.</p>",
        "id": 261268283,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636730933
    },
    {
        "content": "<p>I would prefer not to make it part of the reference, as the reference focuses on the behavior of the language. From my understanding, this is somewhat outside of the language definition, but more of an implementation issue, right?  I also think it will be easier to maintain in the rustc repo.</p>\n<p>The section on linkage needs to be rewritten so that it is not so much about <code>rustc</code>.  The others are relevant to how the language behavior interfaces with the system.  It doesn't seem like the mangling scheme is something that surfaces in the language?</p>",
        "id": 261281097,
        "sender_full_name": "Eric Huss",
        "timestamp": 1636736451
    },
    {
        "content": "<p>I agree that the mangling is not part of the language as such. But it's also more than an implementation detail of <code>rustc</code>. I still think that the reference would be good place for hosting its definition -- but I don't have a strong opinion about it. I'm also fine with just keeping the RFC up-to-date (it does have a change-log section after all).</p>",
        "id": 261508680,
        "sender_full_name": "mw",
        "timestamp": 1636988696
    },
    {
        "content": "<p>It seems like something other compilers would want to match, yeah - otherwise there's compatibility issues if you want to get gdb or valgrind to demangle symbols</p>",
        "id": 261510782,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636989447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Process.20for.20amending.20RFC.3F.20.28re.20v0.20symbol.20mangling.29/near/261510782\">said</a>:</p>\n<blockquote>\n<p>It seems like something other compilers would want to match, yeah - otherwise there's compatibility issues if you want to get gdb or valgrind to demangle symbols</p>\n</blockquote>\n<p>The larger compatibility issues would be if you wanted to link rlib/dylib code from different compilers, but that's not currently possible (you can't even do it between rustc versions). As long as valgrind/gdb support exists for both schemes, it should work fine. Although I agree that <code>v0</code> mangling should be more than just an implementation-detail, as it's a good advisory option for other compilers, similar to things like the UCG (which can inform implementors on layout/option choices, despite not being normative and constraining them).</p>",
        "id": 261512289,
        "sender_full_name": "Connor Horman",
        "timestamp": 1636990033
    }
]