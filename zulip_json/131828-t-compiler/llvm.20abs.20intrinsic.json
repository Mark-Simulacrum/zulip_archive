[
    {
        "content": "<p>Could someone with LLVM knowledge point me to where the <code>abs</code> intrinsic is defined in the LLVM source? Context: I'm trying to learn more about LLVM, and I noticed how <code>@llvm.abs</code> is optimized in different ways depending on the target, so I thought it would be a good start to understanding LLVM better :)</p>",
        "id": 227862813,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614299105
    },
    {
        "content": "<p>I found <code>llvm/lib/CodeGen/IntrinsicLowering.cpp</code>, but that doesn't seem to mention the <code>abs</code> intrinsic.</p>",
        "id": 227862983,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614299216
    },
    {
        "content": "<p>I also found <a href=\"https://llvm.org/docs/ExtendingLLVM.html#adding-a-new-intrinsic-function\">https://llvm.org/docs/ExtendingLLVM.html#adding-a-new-intrinsic-function</a>, but still couldn't find the intrinsic in the places it mentioned.</p>",
        "id": 227863117,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614299314
    },
    {
        "content": "<p>I'm especially curious to see the codegen for <code>@llvm.abs</code> on RISC-V, since it seems very clever.</p>",
        "id": 227863229,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614299396
    },
    {
        "content": "<p>Clang seems to be really great at recognizing that my function computes an absolute value (and I don't think it's looking at the name <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>) and is able to convert it into <code>@llvm.abs</code> which then has target-specific implementations. <a href=\"https://godbolt.org/z/qE8xPW\">https://godbolt.org/z/qE8xPW</a></p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">int</span> <span class=\"nf\">abs</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
        "id": 227863361,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614299480
    },
    {
        "content": "<p>Looks like rustc is able to do the same recognition, though maybe it's actually LLVM in both cases. <a href=\"https://rust.godbolt.org/z/zG4sb6\">https://rust.godbolt.org/z/zG4sb6</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![no_std]</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">abs</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 227863583,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614299619
    },
    {
        "content": "<p>Yeah, that'll be LLVM's optimizers doing that work.</p>",
        "id": 227863600,
        "sender_full_name": "Alex Gaynor",
        "timestamp": 1614299641
    },
    {
        "content": "<p>LLVM's intelligence really amazes and inspires me <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 227863693,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614299695
    },
    {
        "content": "<p>You want to grep for <code>ISD::ABS</code> I think.</p>",
        "id": 227864309,
        "sender_full_name": "nagisa",
        "timestamp": 1614300138
    },
    {
        "content": "<p>Grep for <code>Intrinsic::abs</code> in <code>CodeGen/SelectionDAG/SelectionDAGBuilder.cpp</code> for where it becomes a DAG node.</p>",
        "id": 227864568,
        "sender_full_name": "nagisa",
        "timestamp": 1614300320
    },
    {
        "content": "<p>RISCV does not appear to have target-specific lowering code, so it goes through generic paths.</p>",
        "id": 227864722,
        "sender_full_name": "nagisa",
        "timestamp": 1614300424
    },
    {
        "content": "<p>The RISCV impl you're seeing appears to be the most generic lowering LLVM has: <a href=\"https://github.com/llvm/llvm-project/blob/d7fca3f0bf176536fc8769ad02a18884d993d7ce/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp#L7047\">https://github.com/llvm/llvm-project/blob/d7fca3f0bf176536fc8769ad02a18884d993d7ce/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp#L7047</a></p>",
        "id": 227865302,
        "sender_full_name": "nagisa",
        "timestamp": 1614300762
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 227865309,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614300768
    },
    {
        "content": "<p>Hmm, I did <code>rg -i Intrinsic::abs llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp</code> but got nothing.</p>",
        "id": 227865326,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614300785
    },
    {
        "content": "<p>Just <code>::abs</code> returns:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"gp\">$</span> rg -i ::abs llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp\n<span class=\"go\">3238:      Opc = ISD::ABS;</span>\n</code></pre></div>",
        "id": 227865353,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614300799
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227865302\">said</a>:</p>\n<blockquote>\n<p>The RISCV impl you're seeing appears to be the most generic lowering LLVM has: <a href=\"https://github.com/llvm/llvm-project/blob/d7fca3f0bf176536fc8769ad02a18884d993d7ce/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp#L7047\">https://github.com/llvm/llvm-project/blob/d7fca3f0bf176536fc8769ad02a18884d993d7ce/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp#L7047</a></p>\n</blockquote>\n<p>Ah, so that's how it figures out to <code>&gt;&gt; 31</code>:</p>\n<div class=\"codehilite\" data-code-language=\"C++\"><pre><span></span><code>  <span class=\"n\">SDValue</span> <span class=\"n\">Shift</span> <span class=\"o\">=</span>\n      <span class=\"n\">DAG</span><span class=\"p\">.</span><span class=\"n\">getNode</span><span class=\"p\">(</span><span class=\"n\">ISD</span><span class=\"o\">::</span><span class=\"n\">SRA</span><span class=\"p\">,</span> <span class=\"n\">dl</span><span class=\"p\">,</span> <span class=\"n\">VT</span><span class=\"p\">,</span> <span class=\"n\">Op</span><span class=\"p\">,</span>\n                  <span class=\"n\">DAG</span><span class=\"p\">.</span><span class=\"n\">getConstant</span><span class=\"p\">(</span><span class=\"n\">VT</span><span class=\"p\">.</span><span class=\"n\">getScalarSizeInBits</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">dl</span><span class=\"p\">,</span> <span class=\"n\">ShVT</span><span class=\"p\">));</span>\n</code></pre></div>",
        "id": 227865451,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614300859
    },
    {
        "content": "<p>I meant <a href=\"https://github.com/llvm/llvm-project/blob/d7fca3f0bf176536fc8769ad02a18884d993d7ce/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp#L6399\">https://github.com/llvm/llvm-project/blob/d7fca3f0bf176536fc8769ad02a18884d993d7ce/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp#L6399</a></p>",
        "id": 227865460,
        "sender_full_name": "nagisa",
        "timestamp": 1614300870
    },
    {
        "content": "<p>Weird, it's not in my local <code>rust/llvm-project</code>.</p>",
        "id": 227865510,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614300912
    },
    {
        "content": "<p>make sure your checkout is not on master, that's probably ancient.</p>",
        "id": 227865533,
        "sender_full_name": "nagisa",
        "timestamp": 1614300926
    },
    {
        "content": "<p>You want one of the branches for LLVM11 or LLVM12</p>",
        "id": 227865546,
        "sender_full_name": "nagisa",
        "timestamp": 1614300940
    },
    {
        "content": "<p>It looks like it's a month old (Jan 20)</p>",
        "id": 227865655,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614301001
    },
    {
        "content": "<p>Btw, how do people come up with these optimization tricks? I wouldn't even know where to start <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">abs:</span>                                    <span class=\"c1\"># @abs</span>\n        <span class=\"nf\">srai</span>    <span class=\"no\">a1</span><span class=\"p\">,</span> <span class=\"no\">a0</span><span class=\"p\">,</span> <span class=\"mi\">31</span>\n        <span class=\"nf\">add</span>     <span class=\"no\">a0</span><span class=\"p\">,</span> <span class=\"no\">a0</span><span class=\"p\">,</span> <span class=\"no\">a1</span>\n        <span class=\"nf\">xor</span>     <span class=\"no\">a0</span><span class=\"p\">,</span> <span class=\"no\">a0</span><span class=\"p\">,</span> <span class=\"no\">a1</span>\n        <span class=\"nf\">ret</span>\n</code></pre></div>",
        "id": 227865710,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614301052
    },
    {
        "content": "<p>As somebody who has implemented generic lowering for overflowing unsigned multiplication for arbitrary width integers in LLVM, its probably involves expressing the problem as a math equation first.</p>",
        "id": 227865821,
        "sender_full_name": "nagisa",
        "timestamp": 1614301123
    },
    {
        "content": "<p>Which typically will start involving operations modulo bitwidth and those get confusing fast ^^</p>",
        "id": 227866068,
        "sender_full_name": "nagisa",
        "timestamp": 1614301299
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"307537\">@Camelid</span> there are a large number of well explored algorithms like these written down in various books and guides. PPC compiler writer's guide is one of such collections, knuth's book is another.</p>",
        "id": 227866181,
        "sender_full_name": "nagisa",
        "timestamp": 1614301380
    },
    {
        "content": "<p><a href=\"https://graphics.stanford.edu/~seander/bithacks.html\">https://graphics.stanford.edu/~seander/bithacks.html</a> is another classic</p>",
        "id": 227866236,
        "sender_full_name": "scottmcm",
        "timestamp": 1614301408
    },
    {
        "content": "<p>Also <a href=\"https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685\">Hacker's delight</a></p>",
        "id": 227866609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614301660
    },
    {
        "content": "<p>This makes me wonder. To me personally the strength reduction of division/remainder by constant (to shifts and multiplies) always seemed like the most non-obvious but clever transformations out there.</p>",
        "id": 227866615,
        "sender_full_name": "nagisa",
        "timestamp": 1614301662
    },
    {
        "content": "<p>So I wonder if there are more widely applied and equally convoluted equivalences out there.</p>",
        "id": 227866720,
        "sender_full_name": "nagisa",
        "timestamp": 1614301716
    },
    {
        "content": "<p>I tried looking at ASM for that for a bunch of constants to figure out the pattern, without much success. Is there a good reference for it?</p>",
        "id": 227866743,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614301732
    },
    {
        "content": "<p>ppc compiler writer's guide has a good explanation on how to implement the transformation.</p>",
        "id": 227866795,
        "sender_full_name": "nagisa",
        "timestamp": 1614301764
    },
    {
        "content": "<p>that's how I \"got\" it.</p>",
        "id": 227866804,
        "sender_full_name": "nagisa",
        "timestamp": 1614301773
    },
    {
        "content": "<p>/me looks up the page.</p>",
        "id": 227866820,
        "sender_full_name": "nagisa",
        "timestamp": 1614301785
    },
    {
        "content": "<p>section 3.2.3.5, explanation starts on page 53 of <a href=\"https://cr.yp.to/2005-590/powerpc-cwg.pdf\">https://cr.yp.to/2005-590/powerpc-cwg.pdf</a></p>",
        "id": 227866998,
        "sender_full_name": "nagisa",
        "timestamp": 1614301910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Camelid</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227865710\">said</a>:</p>\n<blockquote>\n<p>Btw, how do people come up with these optimization tricks? I wouldn't even know where to start <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n</blockquote>\n<p>For that one in particular, it's using the fairly well known trick that arithmetic-shift-right by one less than the bit width gives you a mask of all zeros for positive numbers or all ones for negative numbers, because it replaces every bit with the sign bit.  One can use that to make a \"poor man's\" conditional move, and then the rest is probably just simplifications, remembering that <code>-x == ~x + 1</code> in 2s-complement.</p>\n<p>(<code>x ^ (x ASHR 31)</code> is abs in 1s-complement, so then it's just a matter of doing a fixup for the off-by-one.  You'll see a similar idea in &lt;<a href=\"https://doc.rust-lang.org/nightly/std/primitive.f32.html#method.total_cmp\">https://doc.rust-lang.org/nightly/std/primitive.f32.html#method.total_cmp</a>&gt;)</p>",
        "id": 227867164,
        "sender_full_name": "scottmcm",
        "timestamp": 1614302028
    },
    {
        "content": "<p>Oh, I was actually thinking of a slightly different optimization <span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> , although that one is interesting too. Have you seen multiplication by constants reduced to shift and add/sub? I think it's not as relevant on modern PCs since the relative cost of multiply over add is not as much as it used to be, but it's interesting to see</p>",
        "id": 227867556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614302299
    },
    {
        "content": "<p>sorry, lurker here, but is this optimization just using the multiplicative inverse modulo 2^n? which would be calculated using the extended euclidean algorithm.</p>",
        "id": 227867727,
        "sender_full_name": "jessa0",
        "timestamp": 1614302442
    },
    {
        "content": "<p>I'm sure the trick for turning division by constants into multiplication by constants can be interpreted as finding approximate modular inverses in the ring Z/2^64 (you don't always get exact inverses because 2^64 isn't prime)</p>",
        "id": 227867731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614302444
    },
    {
        "content": "<p>Personally, what I would really like to read a book on is not a laundry list of optimizations but a collection of heuristics for when to apply them. This latter information is much harder to obtain and is the most valuable thing to learn from production compilers IMO</p>",
        "id": 227867954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614302602
    },
    {
        "content": "<p>especially inlining and register allocation, which are straightforward in principle but leave a lot of choice to the implementer</p>",
        "id": 227868194,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614302757
    },
    {
        "content": "<p>I don't recall seeing multiplications by constants turning into shifts except for powers of two, but only because I haven't ever looked at architectures where this would be beneficial. But from your description I intuit you'd do is something like, say <code>7x = 4x + 2x + x</code>?</p>",
        "id": 227868236,
        "sender_full_name": "nagisa",
        "timestamp": 1614302765
    },
    {
        "content": "<p>yes, but you can do better than that with subtraction</p>",
        "id": 227868266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614302788
    },
    {
        "content": "<p>I will see if I can show an example</p>",
        "id": 227868281,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614302799
    },
    {
        "content": "<p>Right.</p>",
        "id": 227868284,
        "sender_full_name": "nagisa",
        "timestamp": 1614302801
    },
    {
        "content": "<p>yeah like <code>7x = 8x - x</code> reduces number of terms/operations.</p>",
        "id": 227868311,
        "sender_full_name": "nagisa",
        "timestamp": 1614302817
    },
    {
        "content": "<p>Sounds fairly reasonable that you'd be able to find pretty optimal solution, I would guess using at most <code>log(n)</code> terms where <code>n</code> is number of bits of operation.</p>",
        "id": 227868463,
        "sender_full_name": "nagisa",
        "timestamp": 1614302913
    },
    {
        "content": "<p><a href=\"https://www.godbolt.org/z/ovrY5d\">https://www.godbolt.org/z/ovrY5d</a></p>",
        "id": 227868553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614302997
    },
    {
        "content": "<p>Most constants don't optimize, I think on x86 gcc only does it for numbers of the form 2^n+-2^m, and clang even less</p>",
        "id": 227868632,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303048
    },
    {
        "content": "<p>On older processors you can get gcc to generate six terms or more</p>",
        "id": 227868689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303102
    },
    {
        "content": "<p>Six additions/subtractions? for 32 bit integers?</p>",
        "id": 227868769,
        "sender_full_name": "nagisa",
        "timestamp": 1614303146
    },
    {
        "content": "<p>six shift/add combos</p>",
        "id": 227868799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303187
    },
    {
        "content": "<p>I think that covers a good chunk of all 32 bit values</p>",
        "id": 227868859,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303233
    },
    {
        "content": "<p>It's a weird complexity measure though, I'm not exactly sure how to find the optimal representation</p>",
        "id": 227868928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303259
    },
    {
        "content": "<p>if you use only shift and add it's obvious by just reading the binary string but with subtraction you do a kind of run length encoding</p>",
        "id": 227868949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303298
    },
    {
        "content": "<p>I see. That seems interesting enough that I might scribble and see if I can prove an upper bound of strictly necessary operations. I still feel like this should be possible with <code>log_2(bits)</code> adds/subs, but that's just, like, my intuition speaking.</p>",
        "id": 227868958,
        "sender_full_name": "nagisa",
        "timestamp": 1614303307
    },
    {
        "content": "<p>Yes, log_2(bits) is an upper bound, because you can just read the constant as a sum of powers of two</p>",
        "id": 227869010,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303351
    },
    {
        "content": "<p>I mean like for 32 bit integers, do it in &lt;= 5 adds/subs. For any given constant operand.</p>",
        "id": 227869074,
        "sender_full_name": "nagisa",
        "timestamp": 1614303375
    },
    {
        "content": "<p>Also it gets even more fun when you consider that you can shift intermediates in the computation, so something like <code>a = x * (2^10 + 2^8 + 2^2 + 1)</code> can be calculated as <code>y = x * (2^2 + 1); a = y * (2^8 + 1)</code></p>",
        "id": 227869153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303459
    },
    {
        "content": "<p>You mentioned you saw 6 steps so that smells like gcc utilizing heuristics and those are not achieving an optimal solution in all instances.</p>",
        "id": 227869202,
        "sender_full_name": "nagisa",
        "timestamp": 1614303487
    },
    {
        "content": "<p>Well even with 6 steps you will be hard pressed to hit all 2^32 possible constant values</p>",
        "id": 227869235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303510
    },
    {
        "content": "<p>that's a lot of entropy</p>",
        "id": 227869240,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303516
    },
    {
        "content": "<p>with the basic shift/add approach you can need anywhere from 1 to 32 steps</p>",
        "id": 227869285,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303561
    },
    {
        "content": "<p>This seems like a perfect opportunity for another very nice approach to trying these things out – exhaustive search over a small problem size!</p>",
        "id": 227869390,
        "sender_full_name": "nagisa",
        "timestamp": 1614303616
    },
    {
        "content": "<p>so for instance, if you're verifying your strength reduction is correct, you can see if you can prove its correct for u8 or u16 by trying _all_ values, and the same algorithm will most likely be equally correct for u32/u64/u128 etc.</p>",
        "id": 227869452,
        "sender_full_name": "nagisa",
        "timestamp": 1614303671
    },
    {
        "content": "<p>With the reuse of intermediates it looks a lot like the <a href=\"https://en.wikipedia.org/wiki/Addition-chain_exponentiation\">addition-chain exponentiation</a> problem</p>",
        "id": 227869455,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614303671
    },
    {
        "content": "<p>Wow, this stuff is over my head <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 227869914,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304072
    },
    {
        "content": "<p>This looks like it might be the trick LLVM uses: <a href=\"https://graphics.stanford.edu/~seander/bithacks.html#IntegerAbs\">https://graphics.stanford.edu/~seander/bithacks.html#IntegerAbs</a></p>\n<h1>Compute the integer absolute value (abs) without branching</h1>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">int</span> <span class=\"n\">v</span><span class=\"p\">;</span>           <span class=\"c1\">// we want to find the absolute value of v</span>\n<span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">;</span>  <span class=\"c1\">// the result goes here</span>\n<span class=\"kt\">int</span> <span class=\"k\">const</span> <span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">v</span> <span class=\"o\">&gt;&gt;</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">CHAR_BIT</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">+</span> <span class=\"n\">mask</span><span class=\"p\">)</span> <span class=\"o\">^</span> <span class=\"n\">mask</span><span class=\"p\">;</span>\n</code></pre></div>\n<p>Patented variation:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">^</span> <span class=\"n\">mask</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">mask</span><span class=\"p\">;</span>\n</code></pre></div>",
        "id": 227870048,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304199
    },
    {
        "content": "<p>When they say \"Patented variation\", do they mean literally patented, as in patent office?</p>",
        "id": 227870147,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304254
    },
    {
        "content": "<blockquote>\n<p>problem of finding a shortest addition chain for a given set of exponents has been proven NP-complete.</p>\n</blockquote>\n<p>Welp, I guess?</p>",
        "id": 227870153,
        "sender_full_name": "nagisa",
        "timestamp": 1614304257
    },
    {
        "content": "<p>Time to learn a habit of proving my problems aren't NP-complete before I attempt to solve the problems themselves.</p>",
        "id": 227870267,
        "sender_full_name": "nagisa",
        "timestamp": 1614304331
    },
    {
        "content": "<p>Some time in the SAT solver industry has taught me to take \"NP-complete\" more as a challenge than a \"do not enter\" sign</p>",
        "id": 227870343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304414
    },
    {
        "content": "<p>My instructor had the saying \"NP is the new P\"</p>",
        "id": 227870425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227868311\">said</a>:</p>\n<blockquote>\n<p>yeah like <code>7x = 8x - x</code> reduces number of terms/operations.</p>\n</blockquote>\n<p>Are you saying replace <code>7*x</code> with <code>8*x - x</code>, or the reverse? Because replacing <code>7*x</code> with <code>8*x - x</code> seems like it would be slower.</p>",
        "id": 227870426,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304479
    },
    {
        "content": "<p><code>8*x - x</code> is faster because it can be calculated as <code>x &lt;&lt; 3 - x</code></p>",
        "id": 227870484,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304533
    },
    {
        "content": "<p>Huh, but doesn't that use an extra register?</p>",
        "id": 227870497,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304550
    },
    {
        "content": "<p>assuming that the shift and sub instructions are much faster than imul</p>",
        "id": 227870502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304553
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227870343\">said</a>:</p>\n<blockquote>\n<p>Some time in the SAT solver industry has taught me to take \"NP-complete\" more as a challenge than a \"do not enter\" sign</p>\n</blockquote>\n<p>Does SAT mean <a href=\"https://en.wikipedia.org/wiki/Boolean_satisfiability_problem\">https://en.wikipedia.org/wiki/Boolean_satisfiability_problem</a>?</p>",
        "id": 227870510,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304560
    },
    {
        "content": "<p>yes</p>",
        "id": 227870550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304564
    },
    {
        "content": "<p>see in particular <a href=\"https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT\">https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#Algorithms_for_solving_SAT</a></p>",
        "id": 227870582,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227870502\">said</a>:</p>\n<blockquote>\n<p>assuming that the shift and sub instructions are much faster than imul</p>\n</blockquote>\n<p>I was trying to read the 8086 manual the other day to understand what each cycle of an instruction does, but I'm guessing it's proprietary.</p>",
        "id": 227870592,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304614
    },
    {
        "content": "<p>Agner Fog has some public measurements of the latency and throughput of all the instructions on all the hardware</p>",
        "id": 227870635,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304667
    },
    {
        "content": "<p><a href=\"https://www.agner.org/optimize/instruction_tables.pdf\">https://www.agner.org/optimize/instruction_tables.pdf</a></p>",
        "id": 227870644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304681
    },
    {
        "content": "<p>most of x86 hardware (you want the document 4. Instruction tables: Lists of instruction latencies, throughputs and micro-operation breakdowns for Intel, AMD and VIA CPUs)</p>",
        "id": 227870712,
        "sender_full_name": "nagisa",
        "timestamp": 1614304725
    },
    {
        "content": "<p>Over time I found that its easy to misinterpret these tables, but they should give you a broad idea of how instructions stack up against each other regardless.</p>",
        "id": 227870776,
        "sender_full_name": "nagisa",
        "timestamp": 1614304796
    },
    {
        "content": "<p>Yeah, I'm just curious :)</p>",
        "id": 227870862,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304819
    },
    {
        "content": "<p>406 pages!</p>",
        "id": 227870871,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614304829
    },
    {
        "content": "<p>What kind of issues do you run into?</p>",
        "id": 227870876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614304834
    },
    {
        "content": "<p>Well, its easy for the actual measurements not really match up with the numbers from these tables in real world operation due to pipelining and the fact that CPUs have multiple execution units that are able to do variety of different things. And then the fact that you can have stalls and often need to wait for instructions to retire etc.</p>",
        "id": 227871033,
        "sender_full_name": "nagisa",
        "timestamp": 1614304951
    },
    {
        "content": "<p>I was wondering what µops were (micro-operations, I assume), so I looked up \"microps\" and found several photos of fish. Apparently <em>Pareiodon microps</em> is a species of catfish <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 227871208,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305068
    },
    {
        "content": "<p>Probably should have searched for \"micro-ops\"</p>",
        "id": 227871219,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305084
    },
    {
        "content": "<p>I much prefer looking at llvm-mca's output (though having information that's in Agner's tables is a prerequisite to do analysis mca does)</p>",
        "id": 227871265,
        "sender_full_name": "nagisa",
        "timestamp": 1614305120
    },
    {
        "content": "<p>x86 is way too complicated due to backwards compatibility stuff, so intel processors basically do jit compilation during execution</p>",
        "id": 227871266,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305121
    },
    {
        "content": "<p>Hold on let me find the movinator lol</p>",
        "id": 227871293,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1614305146
    },
    {
        "content": "<p>lolol</p>",
        "id": 227871298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305151
    },
    {
        "content": "<p>Sorry, movfuscator<br>\n<a href=\"https://github.com/xoreaxeaxeax/movfuscator\">https://github.com/xoreaxeaxeax/movfuscator</a></p>",
        "id": 227871393,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1614305188
    },
    {
        "content": "<p>Btw, why does it tend to be that the more cores a machine has, the lower the clock speed? Is it because of synchronization?</p>",
        "id": 227871434,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305239
    },
    {
        "content": "<p>power, heat. Clocks don't need to be synchronized between cores, they communicate over a bus.</p>",
        "id": 227871475,
        "sender_full_name": "nagisa",
        "timestamp": 1614305272
    },
    {
        "content": "<p>Hm, so otherwise the machine might overheat?</p>",
        "id": 227871543,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227871393\">said</a>:</p>\n<blockquote>\n<p>Sorry, movfuscator<br>\n<a href=\"https://github.com/xoreaxeaxeax/movfuscator\">https://github.com/xoreaxeaxeax/movfuscator</a></p>\n</blockquote>\n<p>Wow, that's cool!</p>",
        "id": 227871547,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305302
    },
    {
        "content": "<p>You can really turn branches into <code>mov</code>s?</p>",
        "id": 227871555,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305312
    },
    {
        "content": "<p>I think branches are done with conditional moves on everything in the not-taken branch</p>",
        "id": 227871581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305347
    },
    {
        "content": "<p>Doesn't look that way, at least not for this example: </p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">int</span> <span class=\"nf\">is_prime</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">==</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">&lt;=</span><span class=\"n\">x</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">%</span><span class=\"n\">i</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>mov asm: <a href=\"https://github.com/xoreaxeaxeax/movfuscator/blob/master/overview/prime_mov.asm\">https://github.com/xoreaxeaxeax/movfuscator/blob/master/overview/prime_mov.asm</a></p>",
        "id": 227871697,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305410
    },
    {
        "content": "<p>There's a trick to encode conditional movs by moving either a dummy value or the real value and using memory addressing to pick the right one</p>",
        "id": 227871815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Camelid</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227871543\">said</a>:</p>\n<blockquote>\n<p>Hm, so otherwise the machine might overheat?</p>\n</blockquote>\n<p>power/tdp is just an arbitrary design constraint, ways we have to deal with the heat dissipation is only one of the considerations that go into making such a constraint. If nothing was a concern, engineers could design chips that consume/dissipate thousands of watts of heat and in doing so run very many cores very fast, if they wanted to.</p>",
        "id": 227871909,
        "sender_full_name": "nagisa",
        "timestamp": 1614305568
    },
    {
        "content": "<p>Christopher Domas has a presentation on it somewhere. (I highly recommend all his talks BTW, he's a pretty amazing reverse engineer)</p>",
        "id": 227871961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305606
    },
    {
        "content": "<p><a href=\"https://www.youtube.com/watch?v=2VF_wPkiBJY\">https://www.youtube.com/watch?v=2VF_wPkiBJY</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"2VF_wPkiBJY\" href=\"https://www.youtube.com/watch?v=2VF_wPkiBJY\"><img src=\"https://i.ytimg.com/vi/2VF_wPkiBJY/default.jpg\"></a></div>",
        "id": 227871988,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305642
    },
    {
        "content": "<p>Btw, do you know of any good resources to start learning about making digital circuits? I tried to make an AND gate once but it didn't work quite right :)</p>",
        "id": 227871990,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305642
    },
    {
        "content": "<p>(My [extreme] stretch goal is to build a RISC-V CPU and run Rust on it <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span> <span aria-label=\"crab\" class=\"emoji emoji-1f980\" role=\"img\" title=\"crab\">:crab:</span>)</p>",
        "id": 227872185,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305772
    },
    {
        "content": "<p>Btw, thanks for all the helpful resources and interesting conversation :)</p>",
        "id": 227872205,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614305804
    },
    {
        "content": "<p>The clock speed is determined by the propagation delay of the most complicated circuit. So if you want a one clock cycle multiplier then your clock speed will be slow. This is improved by pipelining, and modern machines are highly pipelined, but you need registers to buffer stuff between each stage and eventually the switching overhead of those buffers dominates and you don't make any more progress by pipelining further</p>",
        "id": 227872250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305860
    },
    {
        "content": "<p>Also it's really hard to write one fifth of an adder</p>",
        "id": 227872326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305907
    },
    {
        "content": "<p>Imagine writing an async function where every fourth word in the code has to be <code>.await</code></p>",
        "id": 227872385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614305987
    },
    {
        "content": "<p>Asynchronous circuits ftw!</p>",
        "id": 227872458,
        "sender_full_name": "nagisa",
        "timestamp": 1614306016
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227872250\">said</a>:</p>\n<blockquote>\n<p>The clock speed is determined by the propagation delay of the most complicated circuit. So if you want a one clock cycle multiplier then your clock speed will be slow. This is improved by pipelining, and modern machines are highly pipelined, but you need registers to buffer stuff between each stage and eventually the switching overhead of those buffers dominates and you don't make any more progress by pipelining further</p>\n</blockquote>\n<p>Thanks, that helps clarify it!</p>",
        "id": 227872735,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227872326\">said</a>:</p>\n<blockquote>\n<p>Also it's really hard to write one fifth of an adder</p>\n</blockquote>\n<p>Hmm, what do you mean? Say <code>add</code> takes 5 cycles—doesn't mean there are five fifths of an adder?</p>",
        "id": 227872793,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306326
    },
    {
        "content": "<p>Yes, and they are all separate \"functions\"</p>",
        "id": 227872807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614306351
    },
    {
        "content": "<p>so you have to carefully write the logic so that it can be partitioned into 5 equal sized pieces</p>",
        "id": 227872861,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614306374
    },
    {
        "content": "<p>which means that you are usually <code>.await</code>ing at really inconvenient points</p>",
        "id": 227872891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614306408
    },
    {
        "content": "<p>Huh, I didn't realize that's how multi-cycle instructions work.</p>",
        "id": 227873069,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306560
    },
    {
        "content": "<p>That seems incredibly hard <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span></p>",
        "id": 227873075,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306565
    },
    {
        "content": "<p>So there's basically <code>add1</code>, <code>add2</code>, <code>add3</code>, <code>add4</code>, and <code>add5</code>, and every clock cycle the next is called?</p>",
        "id": 227873297,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306729
    },
    {
        "content": "<p>yes</p>",
        "id": 227873301,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614306739
    },
    {
        "content": "<p>the pipelining means that actually all five pieces are being used at the same time for different data</p>",
        "id": 227873323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614306771
    },
    {
        "content": "<p>Huh, so because it's in multiple pieces, multiple numbers can be going through at the same time?</p>",
        "id": 227873374,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306804
    },
    {
        "content": "<p>Wow</p>",
        "id": 227873384,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306838
    },
    {
        "content": "<p>All I can say is, compared to this, configuring DNS is easy <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 227873444,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614306858
    },
    {
        "content": "<p>Thanks again for all the fascinating information :)</p>",
        "id": 227873576,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614307024
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Camelid</span> <a href=\"#narrow/stream/131828-t-compiler/topic/llvm.20abs.20intrinsic/near/227870497\">said</a>:</p>\n<blockquote>\n<p>Huh, but doesn't that use an extra register?</p>\n</blockquote>\n<p>Big desktop chips do register renaming and have huge register files internally, so that's usually not an important concern.</p>",
        "id": 227874013,
        "sender_full_name": "scottmcm",
        "timestamp": 1614307462
    },
    {
        "content": "<p>So many layers of abstraction <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 227874127,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614307574
    },
    {
        "content": "<p>well, for the compiler optimization it does affect register pressure since they can only use the registers in the ISA, but it just gets folded in with everything else</p>",
        "id": 227874141,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614307596
    },
    {
        "content": "<blockquote>\n<p>Big desktop chips do register renaming and have huge register files internally, so that's usually not an important concern.</p>\n</blockquote>\n<p>One thing I've wondered for a while is why there is no ISA that gives explicit access to these register files. I get that there are instruction size limits, but you could always have special \"store in / load from extended register set\" instructions, that would get elided by register renaming during pipelining.</p>",
        "id": 227911538,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1614337297
    },
    {
        "content": "<p>The more exposed registers there are, the less freedom the cpu has to rename registers as it has to preserve all exposed registers. For example it can store results of speculatively executed instructions in non-exposed registers and discard them if the instruction never retired.</p>",
        "id": 227913989,
        "sender_full_name": "bjorn3",
        "timestamp": 1614338723
    },
    {
        "content": "<p>There's also ISA portability – you must have silicon for each register you have in the ISA, but you don't necessarily want to put as many registers in a laptop chip as you do in a server chip.</p>",
        "id": 227914159,
        "sender_full_name": "nagisa",
        "timestamp": 1614338804
    },
    {
        "content": "<p>Furthermore, register renaming is a well explored algorithm that's easy and cheap to implement AFAIK.</p>",
        "id": 227914189,
        "sender_full_name": "nagisa",
        "timestamp": 1614338825
    },
    {
        "content": "<p>If you make the API leak architectural details then it becomes a lot harder to program. I think there are some architectures that have attempted this but it's a very different ballgame</p>",
        "id": 227914224,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614338839
    },
    {
        "content": "<p>Delegating responsibility of managing this kind of things to the compiler doesn't help. Itanium tried it, but failed. A big reason for this is that for many things the most efficient decision can only be made at runtime and not statically.</p>",
        "id": 227914234,
        "sender_full_name": "bjorn3",
        "timestamp": 1614338846
    },
    {
        "content": "<p>The Mill architecture is an interesting exploration in this direction</p>",
        "id": 227914269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614338871
    },
    {
        "content": "<p>they have a bunch of youtube videos about the design and it's really different from the usual, but they don't have any hardware yet</p>",
        "id": 227914406,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614338934
    },
    {
        "content": "<p>I used to be super excited about Mill, but I haven't heard anything about Mill for years now.</p>",
        "id": 227914626,
        "sender_full_name": "nagisa",
        "timestamp": 1614339058
    },
    {
        "content": "<p>yeah I doubt they will actually deliver, but I like the ideas anyway</p>",
        "id": 227914659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614339093
    },
    {
        "content": "<p>I asked at some point if they ran out of steam, was told its still being worked on, so perhaps they turned in a less public direction or something, idk.</p>",
        "id": 227914665,
        "sender_full_name": "nagisa",
        "timestamp": 1614339096
    },
    {
        "content": "<p>Someone should make a WASM machine.</p>",
        "id": 227914768,
        "sender_full_name": "bjorn3",
        "timestamp": 1614339144
    },
    {
        "content": "<p>Heh, that made me think: WAT looks like Lisp and so it would be a little bit like a return to a Lisp machine <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 227983028,
        "sender_full_name": "Noah Lev",
        "timestamp": 1614369249
    }
]