[
    {
        "content": "<p>Hi folks—feel free to reparent this as necessary, but my employer is doing some half/yearly planning right about now, and my colleague Greg Clayton (who created lldb) is looking at improving the state of rust support in lldb. With his permission, I'm sharing his thoughts that he shared with Felix and I for longer-term approaches to improve rust support in lldb.</p>\n<blockquote>\n<p>We have really good language support inside of lldb for different languages. Each language can make a new lldb_private::TypeSystem for any given language and the type system's job is to be able to accurately represent types and declaration contexts for that language. The type system is also responsible for the expression parser for that language. This allows each language to have its own dedicated expression parser and types. </p>\n</blockquote>\n<blockquote>\n<p>There are two different approaches being used currently: one for C/C++/ObjC and other languages that the clang::ASTContext supports natively, and one for Swift,</p>\n</blockquote>\n<blockquote>\n<p>For the clang::ASTContext based languages, of which Rust currently claims to be a part of, we convert DWARF debug information in the native clang AST context classes and then we actually use the clang compiler as our expression parser. Since we re-create the clang types in a clang::ASTContext, this is really easy and allows us to re-use the compiler code base to implement our expression parser. Anytime a new C++ language feature is implemented in clang, we just re-compile LLDB with the latest clang, and our expression parser is able to take advantage of all the new features without any modifications to the LLDB sources. The pros of this approach is we can convert DWARF into clang types and we can use any debug info from any compiler. The cons of this approach are that DWARF sometimes doesn't contain enough debug information to perfectly recreate types. For example, template instantiated of template classes don't define all methods, just the ones that were used in the current source file. So you might have a std::vector&lt;int&gt; and if you only use std::vector&lt;int&gt;::clear() and std::vector&lt;int&gt;::push_back(), then only those two member functions will exist in the DWARF. If we try to re-create the std::vector&lt;int&gt; class from just one source file like this, the template class will be missing all other method declarations. Again, this all comes down to how accurately the DWARF represents types for your language.</p>\n</blockquote>\n<blockquote>\n<p>For the Swift language, the DWARF contains just mangled type names for each type, and the Swift compiler serializes the swift::ASTContext into the main executable. We then hand this blob of data to the Swift compiler and then there is an API in the swift::ASTContext that can re-create types for us given a mangled type name from the DWARF. The pros of this approach is that we have lossless type representation and we can recreate inlined functions since the AST context has all of the basic block info for all types. The cons of this approach is that the LLDB Swift compiler sources must match the compiler that generates the binary since the swift AST context data is not portable across compiler versions.</p>\n</blockquote>\n<blockquote>\n<p>Each of the above type systems has its own expression parser, so both languages have really good support for each languages since they have dedicated expression parsers.</p>\n</blockquote>\n<blockquote>\n<p>Any code in LLDB that uses a type from a type system does so by using the lldb_private::CompilerType class. This class contains a \"TypeSystem *\" virtual interface and a \"void *\" which represents a type inside this type system. This allows each language to have its own native types, and the virtual interfaces on the \"TypeSystem\" class can help us extract information about a type from your language. We also have abstracted the CompilerDeclContext to represent a declaration context in a language AST, and CompilerDecl for declarations. Each of these classes can be augmented if needed to help support other languages so that the LLDB code base can use CompilerType, CompilerDecl and CompilerDeclContext in abstract ways. CompilerType is the class that helps our variable display code to display variables and contains things like \"how many children does this type have\" and \"get me the name and type of the child at index I\" along with many more APIs for accessing type information agnostic to any language that created the type.</p>\n</blockquote>\n<p>(<span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> shared his thoughts in response, but I haven't asked him yet if I can share them, so I'll hold off!)</p>",
        "id": 268769928,
        "sender_full_name": "David Barsky",
        "timestamp": 1642719255
    },
    {
        "content": "<p>also, feel free to re-parent this thread elsewhere, but I figured it could be useful to share this information to begin with :)</p>",
        "id": 268770003,
        "sender_full_name": "David Barsky",
        "timestamp": 1642719305
    },
    {
        "content": "<p>there's also a sense that there's probably some low-hanging fruit that can be improved before committing to something as large as a swift-style approach for debugging rust code, and I would be remiss if I didn't mention that as well</p>",
        "id": 268770132,
        "sender_full_name": "David Barsky",
        "timestamp": 1642719368
    },
    {
        "content": "<p>I am happy to answer any questions people might have about making integration of Rust into LLDB better than it is today!</p>",
        "id": 268770417,
        "sender_full_name": "Greg Clayton",
        "timestamp": 1642719542
    },
    {
        "content": "<p>(i’m going to move this under <a class=\"stream\" data-stream-id=\"131828\" href=\"/#narrow/stream/131828-t-compiler\">#t-compiler</a> ; i think that is a good (more-targeted) audience for this discussion</p>",
        "id": 268770572,
        "sender_full_name": "pnkfelix",
        "timestamp": 1642719616
    },
    {
        "content": "<p>This topic was moved here from <a class=\"stream-topic\" data-stream-id=\"122651\" href=\"/#narrow/stream/122651-general/topic/improving.20lldb.20support.20in.20rust\">#general &gt; improving lldb support in rust</a> by <span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span></p>",
        "id": 268770640,
        "sender_full_name": "Notification Bot",
        "timestamp": 1642719640
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"198819\">@David Barsky</span> and <span class=\"user-mention\" data-user-id=\"473134\">@Greg Clayton</span>! Sorry for the long silence but we're just starting to get the debugging working group off the ground. If you're still interested, it would be great if you could stop by <a class=\"stream\" data-stream-id=\"317568\" href=\"/#narrow/stream/317568-t-compiler.2Fwg-debugging\">#t-compiler/wg-debugging</a> and leave a comment in the introductory thread. We're looking for all different levels of participation so even if you don't have a lot of time but would be willing to answer occasional questions about lldb, that would be hugely appreciated! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 275804160,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1647611124
    }
]