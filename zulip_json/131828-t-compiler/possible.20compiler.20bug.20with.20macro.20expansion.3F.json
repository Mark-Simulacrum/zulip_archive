[
    {
        "content": "<p>is it intentional that this fails or is it some sort of compiler bug? </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"s\">\"u32\"</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">works</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$arg</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">map</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"cp\">$arg</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">broken</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$arg</span>:<span class=\"nc\">ty</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">map</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"cp\">$arg</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">works</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">broken</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>   Compiling playground v0.0.1 (/playground)\nerror: no rules expected the token `u32`\n  --&gt; src/main.rs:15:14\n   |\n1  | macro_rules! map {\n   | ---------------- when calling this macro\n...\n15 |         map!($arg)\n   |              ^^^^ no rules expected this token in macro call\n...\n21 |     broken!(u32);\n   |     ------------ in this macro invocation\n   |\n   = note: this error originates in the macro `broken` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: could not compile `playground` due to previous error\n</code></pre></div>",
        "id": 266528441,
        "sender_full_name": "devsnek",
        "timestamp": 1640992385
    },
    {
        "content": "<p>Yes, I think this is intentional. When the <code>ty</code> gets matched in <code>broken</code>, it's internally wrapped up and prevented from being matched as a different thing in the future. Then, when matching <code>map</code>, ig it looks for an ident (u32) and finds instead a type. <code>works!</code> is different because <code>tt</code>s are exempt from this rule</p>",
        "id": 266528600,
        "sender_full_name": "Jake",
        "timestamp": 1640992647
    },
    {
        "content": "<p>See</p>\n<blockquote>\n<p>When forwarding a matched fragment to another macro-by-example, matchers in the second macro will see an opaque AST of the fragment type. The second macro can't use literal tokens to match the fragments in the matcher, only a fragment specifier of the same type. The ident, lifetime, and tt fragment types are an exception, and can be matched by literal tokens. The following illustrates this restriction:</p>\n</blockquote>\n<p>from <a href=\"https://doc.rust-lang.org/reference/macros-by-example.html\">https://doc.rust-lang.org/reference/macros-by-example.html</a></p>",
        "id": 266528657,
        "sender_full_name": "Jake",
        "timestamp": 1640992692
    },
    {
        "content": "<p>is there a workaround? i don't know a way to pass a ty down with this behavior</p>",
        "id": 266528672,
        "sender_full_name": "devsnek",
        "timestamp": 1640992723
    },
    {
        "content": "<p>Really depends on what exactly you want to do. You can either match on a <code>ident</code> in the outer macro, match on a <code>ty</code> in the inner macro, or do other stuff depending</p>",
        "id": 266528694,
        "sender_full_name": "Jake",
        "timestamp": 1640992768
    },
    {
        "content": "<p>you mean match on <code>ty</code> in <code>map</code>? how would i do that</p>",
        "id": 266528759,
        "sender_full_name": "devsnek",
        "timestamp": 1640992808
    },
    {
        "content": "<p>Same way as in <code>broken</code></p>",
        "id": 266528769,
        "sender_full_name": "Jake",
        "timestamp": 1640992853
    },
    {
        "content": "<p>i don't understand, map needs to match specific tokens</p>",
        "id": 266528772,
        "sender_full_name": "devsnek",
        "timestamp": 1640992881
    },
    {
        "content": "<p>Right, that's the thing this is specifically designed to prevent. The  other option you have is to add more cases to <code>broken</code>, where you match exactly on <code>ident</code> first and then forward that to <code>map</code> (<code>ident</code> is also one of the exceptions to this rule), falling back to <code>ty</code> otherwise</p>",
        "id": 266528833,
        "sender_full_name": "Jake",
        "timestamp": 1640992967
    },
    {
        "content": "<p>i can't match on ident, there are actual types being used</p>",
        "id": 266528851,
        "sender_full_name": "devsnek",
        "timestamp": 1640993003
    },
    {
        "content": "<p>Types and idents are not mutually exclusive; with your <code>u32</code> case it would work just fine</p>",
        "id": 266528918,
        "sender_full_name": "Jake",
        "timestamp": 1640993053
    },
    {
        "content": "<p><code>&amp;str</code> for example. <code>$(tt)+</code> won't work because it is ambiguous</p>",
        "id": 266528934,
        "sender_full_name": "devsnek",
        "timestamp": 1640993091
    }
]