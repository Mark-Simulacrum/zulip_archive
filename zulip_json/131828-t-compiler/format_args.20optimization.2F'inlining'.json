[
    {
        "content": "<p>Hey compiler people!</p>\n<p>There are quite a few macros out there that forward to formatting macros after <code>concat!()</code>'ing the format string. E.g. we used to have <code>println</code> forward to <code>print</code> after concating a <code>\"\\n\"</code>. That turned out to be a bad idea, because <code>concat!(1, \"\\n\")</code> implicitly converts the <code>1</code> to a string and results in <code>\"1\\n\"</code> rather than an error. That's fixed now in a way that's not available outside std, with an unstable <code>format_args_nl</code> macro.</p>\n<p>Macros like <code>unreachable</code> use <code>format_args!(concat!(\"prefix: \", $fmt), $($args)*)</code> to prepend a prefix, which mostly works out okay, but isn't great either. This has recently become a bigger problem with the stabilization of implicit format args (<code>format_args!(\"{x}\")</code>), which don't work through <code>concat</code>. This leaves a solution like <code>format_args!(\"prefix: {}\", format_args!($fmt, $($args)*))</code>, which works great, except it is inefficient to create two nested fmt::Arguments.</p>\n<p>So I'd really like it if nested format_args like that would get 'inlined'/optimized into a single one at some point in the compiler. However, the expansion of <code>format_args</code> is a rather complicated expression (a <code>match</code> with <code>fmt::Arguments::new(.. lots of things ..)</code>), and will change every time we improve how <code>fmt::Arguments</code> is implemented. So making a pass that recognizes those expressions and tranforms them seems like a bad idea.</p>\n<p>Instead, I was thinking it'd be super nice if <code>format_args!(..)</code> would expand to a new <code>ast::ExprKind::FormatArgs</code>. Then later passes (in hir or mir?) could easily manipulate them. This will also help a lot with const panic i presume. And then only after nested FormatArgs and literal arguments etc. are all 'inlined' into the outermost FormatArgs, can it be expanded to the actual expression that results in a <code>fmt::Arguments</code> object. This will easily make <code>fmt::Arguments::as_str()</code> more powerful too, as it could more easily work for <code>format_args!(\"a: {}\", \"b\")</code>, and so on.</p>\n<p>There's some discussion about this here: <a href=\"https://github.com/rust-lang/rust/issues/78356#issuecomment-862379533\">https://github.com/rust-lang/rust/issues/78356#issuecomment-862379533</a></p>\n<p>Does this sound resonable? Is this something I shoud write an MCP for and work on? Is this something that should be discussed in a meeting first?</p>",
        "id": 268953151,
        "sender_full_name": "Mara",
        "timestamp": 1642851237
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> who had some thoughts about this iirc.</p>",
        "id": 268953207,
        "sender_full_name": "Mara",
        "timestamp": 1642851332
    },
    {
        "content": "<p>and cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> and <span class=\"user-mention\" data-user-id=\"326176\">@Boxy [she/her]</span> who i discussed this with a long time ago</p>",
        "id": 268953301,
        "sender_full_name": "Mara",
        "timestamp": 1642851480
    },
    {
        "content": "<p>I'm mildly opposed - I'm not sure the advantages are worth the loss of format_args being just a library feature (where the macro could be implemented as a proc macro), which makes it much easier to understand IMO.</p>\n<p>If the goal is permitting convenient prefixes/suffixes, could we add an unstable feature that permits multiple string literals as the format string in format_args!, with the macro impl internally concat'ing them? That feels like a much simpler iteration, and could be a nice feature even outside format_args in the long run to make it easier to know behavior of multiline strings.</p>",
        "id": 268957646,
        "sender_full_name": "simulacrum",
        "timestamp": 1642858018
    },
    {
        "content": "<p>there are many situations where a constant string or a nested format_args get passed to a format_args, which we basically cannot optimize right now. see <a href=\"https://github.com/rust-lang/rust/issues/78356#issuecomment-862242999\">this comment</a> for a few examples of different optimizations/simplifications we could do.</p>",
        "id": 268957737,
        "sender_full_name": "Mara",
        "timestamp": 1642858174
    },
    {
        "content": "<p>right now we already have <a href=\"https://github.com/rust-lang/rust/blob/ecf72996eda4f8af19b0ca7235c6f62e0245a313/library/core/src/panic.rs#L34-L37\">an ugly hack</a> to make specifically <code>panic!(\"{}\", const_str)</code> work in const panic. none of that would've been necessary if that fmt::Arguments would've reduced to a trivial fmt::Arguments</p>",
        "id": 268957992,
        "sender_full_name": "Mara",
        "timestamp": 1642858527
    },
    {
        "content": "<p>and your idea of taking multiple string literals wouldn't work for constants, only for literals. plenty of code ends up doing something like <code>format_args!(\"{}: {}\", SOME_CONST, x)</code> that could've been <code>format_args(\"bla: {}\", x)</code>. the exact optimizations that make sense will need to be investigated of course, but right now it's not an option at all.</p>",
        "id": 268958065,
        "sender_full_name": "Mara",
        "timestamp": 1642858655
    },
    {
        "content": "<p>solutions for anything with nested format_args are hard to get wrong. messing with concat or multiple literals as input will likely result in non-(format-)strings being used as format strings, etc.</p>",
        "id": 268958129,
        "sender_full_name": "Mara",
        "timestamp": 1642858741
    },
    {
        "content": "<p>Sure, I agree that the compiler is more powerful and can do these optimizations,  no question there.</p>\n<p>It feels problematic for the semantics of e.g. as_str to depend on whether we managed to inline things in the compiler - if we make it purely about performance optimization, then that seems much more acceptable to me, though still unfortunate that we can't expose it more generally.</p>",
        "id": 268958216,
        "sender_full_name": "simulacrum",
        "timestamp": 1642858920
    },
    {
        "content": "<p>and if your prefix/suffix contains any placeholders itself, you won't be able to make sure your own arguments and user's arguments get re-ordered if they use explicit numbers.</p>\n<p>E.g. <code>format_args!(concat!(\"{}: error: \", $fmt), $level, $($args)*)</code> will go completely wrong if the user calls that macro as <code>m!(\"{} {0}\", 123)</code>. the only option is a nested format_args.</p>",
        "id": 268958261,
        "sender_full_name": "Mara",
        "timestamp": 1642858948
    },
    {
        "content": "<blockquote>\n<p>It feels problematic for the semantics of e.g. as_str to depend on whether we managed to inline things in the compiler </p>\n</blockquote>\n<p>it was always the plan for <code>as_str</code> to start returning <code>Some</code> in more cases in the future: <a href=\"https://github.com/rust-lang/rust/issues/74442#issuecomment-767424377\">https://github.com/rust-lang/rust/issues/74442#issuecomment-767424377</a></p>",
        "id": 268958326,
        "sender_full_name": "Mara",
        "timestamp": 1642859046
    },
    {
        "content": "<p>I mean, I'm not sure I agree with that plan :) obviously, not necessarily a blocker.</p>\n<p>In general I guess it seems fine to explore an impl, but I'd at least prefer we try to aim for something end-user code could write too - even if with worse diagnostics</p>",
        "id": 268958678,
        "sender_full_name": "simulacrum",
        "timestamp": 1642859338
    },
    {
        "content": "<p>One thought - if we changed format args to basically generate a closure, then presumably the optimization side of things for nested args isn't really an issue anymore? Since it's then just a matter of inlining?</p>\n<p>Presumably the as_str piece would still be nice, though I might say that we should make that happen by making to_string const fn - with some features in const eval that makes any const-compatible format work with as_str, which should work well to address that desire imo for the common cases. It wouldn't likely address 100% because there's then a need for something like symbolic evaluation where parts of the string are const and parts aren't, but I suspect it's pretty close in practice</p>",
        "id": 268962223,
        "sender_full_name": "simulacrum",
        "timestamp": 1642864344
    },
    {
        "content": "<p>While having something that the end user could in theory write on their own is fine and all, doing an optimization is far more useful. Particularly, since we're all already using the standard library version anyway, that version might as well be a effective as possible.</p>",
        "id": 268966822,
        "sender_full_name": "Lokathor",
        "timestamp": 1642870766
    },
    {
        "content": "<blockquote>\n<p>One thought - if we changed format args to basically generate a closure, then presumably the optimization side of things for nested args isn't really an issue anymore? Since it's then just a matter of inlining?</p>\n</blockquote>\n<p>yeah that's an interesting thought. though i don't see the compiler optimizing <code>f.write_str(\"a\")?; f.write_str(\"b\")?;</code> to <code>f.write_str(\"ab\")?;</code> any time soon.</p>",
        "id": 268970490,
        "sender_full_name": "Mara",
        "timestamp": 1642875532
    },
    {
        "content": "<p>If it's just such simple chains and we made the method a lang item, then that's a trivial MIR opt. But I am guessing you have more complex examples in mind?</p>",
        "id": 268975288,
        "sender_full_name": "oli",
        "timestamp": 1642882109
    },
    {
        "content": "<p>It's somewhat difficult to justify (they're not the same in terms of possible behavior), so it's not clear how worthwhile it is to MIR opt those away</p>",
        "id": 268975376,
        "sender_full_name": "simulacrum",
        "timestamp": 1642882237
    }
]