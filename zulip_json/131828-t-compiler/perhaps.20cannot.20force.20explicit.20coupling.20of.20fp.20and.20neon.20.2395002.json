[
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span></p>",
        "id": 275721527,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549056
    },
    {
        "content": "<p>background context for others following along: a month ago, we were looking at PR <a href=\"https://github.com/rust-lang/rust/issues/91608\">#91608</a> in a T-compiler meeting</p>",
        "id": 275722039,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143274\">Amanieu</span> <a href=\"#narrow/stream/238009-t-compiler.2Fmeetings/topic/.5Bweekly.5D.202022-02-17.20.2354818/near/272275351\">said</a>:</p>\n<blockquote>\n<p>I'm OK with a compromise solution where we force both features to be enabled/disabled together. But I don't want to merge the features since they are separate in the ISA spec.</p>\n</blockquote>",
        "id": 275722043,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549266
    },
    {
        "content": "<p>the above was the rough compromise that we said we'd look into in that meeting, and we said we'd have further conversation on the PR itself</p>",
        "id": 275722103,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549296
    },
    {
        "content": "<p>since then, <a href=\"https://github.com/rust-lang/rust/issues/95002\">#95002</a> was filed</p>",
        "id": 275722197,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549347
    },
    {
        "content": "<p>Hello.</p>\n<p>So in <a href=\"https://github.com/rust-lang/rust/issues/91608\">#91608</a> I brought up an issue that we went back and forth on.<br>\nIn brief, the issue is this:<br>\nRust developers consider <code>\"+neon\"</code> to mean functionally the same thing as <code>\"+fp, +neon\"</code>.<br>\nI proposed simply eliminating both, and having one feature as a superset: <code>\"+neon\"</code>.<br>\nThis is in accordance with the semantics of the machine: the instructions and architectural state are tied to the same bit to initialize in the firmware, and the Arm manuals do mention the two features separately, they also specify the features <strong>cannot</strong> be configured on or off separately. That no public compiler should allow such.</p>",
        "id": 275722201,
        "sender_full_name": "Jubilee",
        "timestamp": 1647549351
    },
    {
        "content": "<p>The reason they are expressed as separate for AArch64 is because in AArch32 state, they <strong>are</strong>. There is another possible FPU. It is not so in AArch64. The machine is defined to have one baseline architectural float processor, the \"Neon\" Advanced SIMD unit, that handles both vector instructions and floating point instructions, matching common practice in e.g. x86-64 which does the same with SSE2 and xmm registers.</p>",
        "id": 275722604,
        "sender_full_name": "Jubilee",
        "timestamp": 1647549543
    },
    {
        "content": "<p>meanwhile, <span class=\"user-mention\" data-user-id=\"382356\">@Adam Gemmell</span> has posted PR <a href=\"https://github.com/rust-lang/rust/issues/95044\">#95044</a> as a fix for <a href=\"https://github.com/rust-lang/rust/issues/95002\">#95002</a></p>",
        "id": 275723241,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549710
    },
    {
        "content": "<p>where <a href=\"https://github.com/rust-lang/rust/issues/95044\">#95044</a> makes the presence of \"neon\" (on the function's features, for aarch64) implicitly add \"fp\" to that feature list, if necessary</p>",
        "id": 275723526,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549806
    },
    {
        "content": "<p>In x86's \"long mode\", however, the x87 FPU is still available as a separate unit that can handle separate instructions, this is not the same for AArch64 which only has Neon and in fact the \"Neon\" feature in AArch64 is subtly different from the \"Neon\" feature in AArch32 in several ways. Ahem.</p>\n<p>Yes.<br>\n<a href=\"https://github.com/rust-lang/rust/issues/95002\">#95002</a> is only a problem because the existing practice is to treat <code>\"+neon\"</code> as <code>\"+neon, +fp\"</code>.</p>",
        "id": 275723638,
        "sender_full_name": "Jubilee",
        "timestamp": 1647549847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> so just to clarify: something called \"neon\" <em>is</em> available on AArch32? Is there anything in the Arm ARM about mixing \"neon\" and \"fp\" in the context of AArch32 ?</p>",
        "id": 275723780,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647549923
    },
    {
        "content": "<p>Correct.</p>",
        "id": 275723806,
        "sender_full_name": "Jubilee",
        "timestamp": 1647549934
    },
    {
        "content": "<p>At this point the breakage shown in <a href=\"https://github.com/rust-lang/rust/issues/95002\">#95002</a> does seem to make a case for having \"neon\" imply \"fp\" in the context of AArch64. (I don't yet have a position for other contexts, and I'm not sure whether the way its <em>implemented</em> in PR <a href=\"https://github.com/rust-lang/rust/issues/95044\">#95044</a> is exactly how I would do it, but that's probably because <code>&amp;mut iter().stuff().collect()</code> makes me pretty nervous.)</p>",
        "id": 275724180,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647550089
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"143274\">@Amanieu</span> is already assigned as a reviewer for PR <a href=\"https://github.com/rust-lang/rust/issues/95044\">#95044</a>, and <a href=\"https://github.com/rust-lang/rust/issues/95002\">#95002</a> has been flagged as a stable-to-nightly regression. I'm confident we'll address this within a week. Hopefully even sooner.</p>",
        "id": 275724422,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647550208
    },
    {
        "content": "<p>I'm looking at it now.</p>",
        "id": 275724511,
        "sender_full_name": "Amanieu",
        "timestamp": 1647550247
    },
    {
        "content": "<p>thanks!</p>",
        "id": 275724528,
        "sender_full_name": "pnkfelix",
        "timestamp": 1647550253
    },
    {
        "content": "<p>The situation is still a bit muddy though, I need to double-check some stuff.</p>",
        "id": 275724565,
        "sender_full_name": "Amanieu",
        "timestamp": 1647550271
    },
    {
        "content": "<p>The story for how floating point works on pre-AArch64 Arm is...<br>\n...complicated.</p>\n<p>Which actually is why I am relatively insistent on trying to expose the simplest interface possible for AArch64. It is absolute hell to debug floating point feature toggles on x86-64 if you tinker with them, to even understand what is happening.</p>",
        "id": 275724577,
        "sender_full_name": "Jubilee",
        "timestamp": 1647550274
    },
    {
        "content": "<p>I would rather avoid another \"have you tried both <code>-sse2</code> and <code>-sse</code>?\" if we can.</p>",
        "id": 275724739,
        "sender_full_name": "Jubilee",
        "timestamp": 1647550333
    },
    {
        "content": "<p>Personally I would prefer if all the dependencies between features were explicitly handled in rustc, rather than passing the responsibility off to LLVM.</p>",
        "id": 275724759,
        "sender_full_name": "Amanieu",
        "timestamp": 1647550345
    },
    {
        "content": "<p>I agree.</p>",
        "id": 275724798,
        "sender_full_name": "Jubilee",
        "timestamp": 1647550356
    },
    {
        "content": "<p>I think that we can probably do several things to improve the Rust ABI situation if we do.</p>",
        "id": 275724931,
        "sender_full_name": "Jubilee",
        "timestamp": 1647550416
    },
    {
        "content": "<p>Looking, and we don't have a <code>\"+fp\"</code> feature for \"just Arm\" (AArch32).</p>",
        "id": 275725217,
        "sender_full_name": "Jubilee",
        "timestamp": 1647550536
    },
    {
        "content": "<p>The closest thing is <code>vfp2</code></p>",
        "id": 275725404,
        "sender_full_name": "Amanieu",
        "timestamp": 1647550597
    },
    {
        "content": "<p>Yeah, we have +neon for AArch32 and also all these:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"p\">(</span><span class=\"s\">\"vfp2\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">sym</span>::<span class=\"n\">arm_target_feature</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"s\">\"vfp3\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">sym</span>::<span class=\"n\">arm_target_feature</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"s\">\"vfp4\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">sym</span>::<span class=\"n\">arm_target_feature</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"s\">\"fp-armv8\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">sym</span>::<span class=\"n\">arm_target_feature</span><span class=\"p\">)),</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275725506,
        "sender_full_name": "Jubilee",
        "timestamp": 1647550638
    },
    {
        "content": "<p>The ARM target features are a mess and need to be completely reworked eventually, I don't want to think too hard about them right now.</p>",
        "id": 275726612,
        "sender_full_name": "Amanieu",
        "timestamp": 1647551003
    },
    {
        "content": "<p>(The 32-bit ones that is)</p>",
        "id": 275726621,
        "sender_full_name": "Amanieu",
        "timestamp": 1647551012
    },
    {
        "content": "<p>Yeah, I frankly don't claim to fully understand the nuances of the floating point units <strong>before</strong> the Neon FPU, aside from that they are addressed in a different manner and that they are why AArch32 machines have the ABIs of<br>\n\"software float\"<br>\n\"hardware float\"<br>\n\"do parameter-passing and and linkage as software float but use hardware float in the actual functions\"</p>",
        "id": 275726630,
        "sender_full_name": "Jubilee",
        "timestamp": 1647551020
    },
    {
        "content": "<p>regardless, best not to overcalibrate on them.</p>",
        "id": 275726712,
        "sender_full_name": "Jubilee",
        "timestamp": 1647551045
    },
    {
        "content": "<p>Ah, so in AArch32, the Neon and VFPvN registers overlap, and Neon fully overlaps any VFP unit.</p>",
        "id": 275727642,
        "sender_full_name": "Jubilee",
        "timestamp": 1647551481
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/131828-t-compiler/topic/perhaps.20cannot.20force.20explicit.20coupling.20of.20fp.20and.20neon.20.2395002/near/275723780\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> so just to clarify: something called \"neon\" <em>is</em> available on AArch32? Is there anything in the Arm ARM about mixing \"neon\" and \"fp\" in the context of AArch32 ?</p>\n</blockquote>\n<p>so the answer is for AArch32 FPUs, if Neon is also present and enabled then you have the entire architectural state also.<br>\nAn AArch32 FPU may support Neon and not VFP instructions, however.</p>",
        "id": 275729676,
        "sender_full_name": "Jubilee",
        "timestamp": 1647552312
    },
    {
        "content": "<p>So the VFP and Neon instruction sets share the same architectural state but they are \"actually separate\".</p>",
        "id": 275730093,
        "sender_full_name": "Jubilee",
        "timestamp": 1647552517
    },
    {
        "content": "<p>Actually looking at configurations, however, I think it progresses in the same way in actual practice between all the control registers and the hardware. Things that have Neon have both VFPv3 and Neon.</p>",
        "id": 275732255,
        "sender_full_name": "Jubilee",
        "timestamp": 1647553581
    },
    {
        "content": "<p>I had seen a report of an Arm CPU that uses Neon only, but it seems to also have VFPv3 enabled.</p>",
        "id": 275732488,
        "sender_full_name": "Jubilee",
        "timestamp": 1647553722
    },
    {
        "content": "<p>I'm pretty sure that NEON support implies VFPv3.</p>",
        "id": 275732984,
        "sender_full_name": "Amanieu",
        "timestamp": 1647554004
    },
    {
        "content": "<p>Yeah.</p>\n<p>I think the actual difference is that for some compilers, toggling Neon without VFP (<code>-mfpu=\"neon\"</code> vs. <code>-mfpu=\"neon-vfp3\"</code>) prompts the compiler to <strong>prefer</strong> Neon instructions, which can result in some computations coming out differently. That goes away in AArch64 though, as it's fully conformant.</p>",
        "id": 275733253,
        "sender_full_name": "Jubilee",
        "timestamp": 1647554147
    },
    {
        "content": "<p>I rebased <a href=\"https://github.com/rust-lang/rust/pull/91608\">https://github.com/rust-lang/rust/pull/91608</a>.<br>\nSo as to summarize the above meandering, since it's a lot: as far as we can tell, Neon always implies full FPU support, regardless of mode, even though the mode changes a fair number of nuances about how that actually works. On AArch64, Neon is the minimum.</p>",
        "id": 275743516,
        "sender_full_name": "Jubilee",
        "timestamp": 1647560772
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/95002\">#95002</a> arising at all is kind of <strong>why</strong> I said that we should do it:<br>\nIt is less fragile and more error-resilient to simply <strong>not</strong> have a configuration option that is not separately meaningful.</p>",
        "id": 275744477,
        "sender_full_name": "Jubilee",
        "timestamp": 1647561585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/131828-t-compiler/topic/perhaps.20cannot.20force.20explicit.20coupling.20of.20fp.20and.20neon.20.2395002/near/275724739\">said</a>:</p>\n<blockquote>\n<p>I would rather avoid another \"have you tried both <code>-sse2</code> and <code>-sse</code>?\" if we can.</p>\n</blockquote>\n<p>if <code>+neon</code> implies <code>+fp</code>, then can we go ahead and make <code>+sse2</code> imply <code>+sse</code>?</p>",
        "id": 275792656,
        "sender_full_name": "bstrie",
        "timestamp": 1647604908
    },
    {
        "content": "<p>I'm pretty sure that <code>+sse2</code> implies <code>+sse</code>.</p>",
        "id": 275812599,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647615011
    },
    {
        "content": "<p>Or maybe I'm misunderstanding what is meant?</p>",
        "id": 275812643,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647615030
    },
    {
        "content": "<p>At the codegen backend level maybe, but not at the frontend level.</p>",
        "id": 275812703,
        "sender_full_name": "bjorn3",
        "timestamp": 1647615062
    },
    {
        "content": "<p>That's interesting.</p>",
        "id": 275815172,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647616070
    },
    {
        "content": "<p>I'm not sure I understand what that means.  Either <code>-Ctarget-feature=+sse2</code> or <code>#[target_feature=\"sse2\"]</code> should also imply sse.  What is meant by \"frontend\" here?</p>",
        "id": 275815837,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647616332
    },
    {
        "content": "<p>Or perhaps that is in regards to how it interacts with a different backend like cg_clif?</p>",
        "id": 275815964,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647616390
    },
    {
        "content": "<p><code>#[cfg(target_feature = \"...\")]</code> and checking validity of <code>#[target_feature(enable = \"...\")]</code> are handled by the frontend, not the backend.</p>",
        "id": 275817531,
        "sender_full_name": "bjorn3",
        "timestamp": 1647617031
    },
    {
        "content": "<p>The frontend currently doesn't know anything about the relation between features. Except for a hard coded error that neon requires fp enabled I think.</p>",
        "id": 275817684,
        "sender_full_name": "bjorn3",
        "timestamp": 1647617078
    },
    {
        "content": "<p>Ah, yea, the <code>cfg</code> checking isn't aware of the <code>#[target_feature]</code>.  I believe that is <a href=\"https://github.com/rust-lang/rust/issues/42515\">#42515</a>?  I think the RFC indicated that should work, but that is difficult (impossible?) to do today?</p>",
        "id": 275818389,
        "sender_full_name": "Eric Huss",
        "timestamp": 1647617352
    },
    {
        "content": "<p>Unsafety checking for calls to functions with target features also currently doesn't know about implied features.</p>",
        "id": 275819316,
        "sender_full_name": "tm",
        "timestamp": 1647617702
    },
    {
        "content": "<p>In LLVM SSE support is represented as a level, rather than bitset. That is, <code>+sse3</code> will set SSE level to SSE3, and thus all SSE revisions before will be enabled. This extends all the way to AVX512: <a href=\"https://github.com/llvm/llvm-project/blob/920c2e576377281e52adba3e3244fb8a930d3841/llvm/lib/Target/X86/X86Subtarget.h#L637-L648\">https://github.com/llvm/llvm-project/blob/920c2e576377281e52adba3e3244fb8a930d3841/llvm/lib/Target/X86/X86Subtarget.h#L637-L648</a></p>",
        "id": 275823079,
        "sender_full_name": "nagisa",
        "timestamp": 1647619303
    },
    {
        "content": "<p>I'm not sure if we should encode this sort of thing at the rustc level, primarily because there's nothing preventing Intel or AMD waking one day and deciding that “screw SSE2 in particular” and releasing a chip that has SSE, and AVX but not SSE2.</p>",
        "id": 275823435,
        "sender_full_name": "nagisa",
        "timestamp": 1647619413
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> It is architecturally incoherent to have SSE3 and not SSE1 and SSE2.<br>\nYou are correct, however, that it is not so for AVX!<br>\nIn fact, Intel made chips that had the prototype versions of AVX512 but not SSE support.</p>",
        "id": 275853453,
        "sender_full_name": "Jubilee",
        "timestamp": 1647632706
    },
    {
        "content": "<p>However, my opinion is that such is not an AMD64 platform, because quite simply, the AMD64 platform is <strong>defined by</strong> including SSE2 support.<br>\nThough I suspect what they specifically dropped support, if memory serves, was for legacy encodings.<br>\nThere are VEX and EVEX encodings of \"SSE\" instructions, that can only be executed by AVX-enabled processors.</p>",
        "id": 275854030,
        "sender_full_name": "Jubilee",
        "timestamp": 1647633008
    },
    {
        "content": "<p>this is, IMO, a fundamental problem with the current ways of representing these features. We don't have a good way of saying, \"AVX512 but only the xmm and ymm registers, not the full zmm, so it <del>doesn't downclock</del> is calling-convention-compatible with AVX functions?\"</p>",
        "id": 275854273,
        "sender_full_name": "Jubilee",
        "timestamp": 1647633165
    },
    {
        "content": "<p>another related issue: <a href=\"https://github.com/rust-lang/rust/issues/89586\">https://github.com/rust-lang/rust/issues/89586</a></p>",
        "id": 275854343,
        "sender_full_name": "bstrie",
        "timestamp": 1647633213
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/131828-t-compiler/topic/perhaps.20cannot.20force.20explicit.20coupling.20of.20fp.20and.20neon.20.2395002/near/275853453\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> It is architecturally incoherent to have SSE3 and not SSE1 and SSE2.<br>\nYou are correct, however, that it is not so for AVX!<br>\nIn fact, Intel made chips that had the prototype versions of AVX512 but not SSE support.</p>\n</blockquote>\n<p>I don't see why that's the case, since SSE2/3/4a  have all only added instructions, and there's nothing to stop them from removing support for these instructions from e.g. decoder.</p>",
        "id": 275858567,
        "sender_full_name": "nagisa",
        "timestamp": 1647635207
    },
    {
        "content": "<p>Or more plausibly for somebody to disable one of these for a VM guest.</p>",
        "id": 275858593,
        "sender_full_name": "nagisa",
        "timestamp": 1647635224
    },
    {
        "content": "<p>ultimately the thing is that LLVM does not have a stability promise as stringent as we do in this regard.</p>",
        "id": 275859157,
        "sender_full_name": "nagisa",
        "timestamp": 1647635549
    },
    {
        "content": "<p>if we make a mistake, we'll live with it forever, just like C is living with e.g. intmax_t. LLVM? if they really want to they can just make a breaking change and pass on the responsibility onto the frontends.</p>",
        "id": 275859240,
        "sender_full_name": "nagisa",
        "timestamp": 1647635609
    },
    {
        "content": "<p>Only so-so. The strings can be ignored.</p>",
        "id": 275859338,
        "sender_full_name": "Jubilee",
        "timestamp": 1647635654
    },
    {
        "content": "<p>IMO, SSE and AVX are actually multiple features, properly considered, before even considering the leveling scheme:</p>\n<ul>\n<li><strong>feature partie un:</strong> the architectural presence of the xmm, ymm, or zmm registers</li>\n<li><strong>feature partie deux:</strong> the instructions that use them</li>\n<li><strong>feature partie trois</strong>: the legacy, VEX, and EVEX encodings of these instructions</li>\n</ul>",
        "id": 275859817,
        "sender_full_name": "Jubilee",
        "timestamp": 1647635931
    },
    {
        "content": "<p>that may seem incredibly pedantic but consider the interactions between:</p>\n<ul>\n<li>legacy-encoded xmm-addressing SSE instructions</li>\n<li>VEX-encoded xmm-addressing SSE instructions</li>\n<li>VEX-encoded ymm-addressing AVX instructions</li>\n</ul>",
        "id": 275860164,
        "sender_full_name": "Jubilee",
        "timestamp": 1647636151
    },
    {
        "content": "<p>you can combine the xmm+SSE+VEX set with ymm+AVX+VEX <strong>xor</strong> xmm+SSE+legacy</p>",
        "id": 275860261,
        "sender_full_name": "Jubilee",
        "timestamp": 1647636227
    },
    {
        "content": "<p>combining ymm+AVX+VEX with xmm+SSE+legacy starts triggering speed penalties at minimum.</p>",
        "id": 275860328,
        "sender_full_name": "Jubilee",
        "timestamp": 1647636257
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/131828-t-compiler/topic/perhaps.20cannot.20force.20explicit.20coupling.20of.20fp.20and.20neon.20.2395002/near/275858567\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/131828-t-compiler/topic/perhaps.20cannot.20force.20explicit.20coupling.20of.20fp.20and.20neon.20.2395002/near/275853453\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> It is architecturally incoherent to have SSE3 and not SSE1 and SSE2.<br>\nYou are correct, however, that it is not so for AVX!<br>\nIn fact, Intel made chips that had the prototype versions of AVX512 but not SSE support.</p>\n</blockquote>\n<p>I don't see why that's the case, since SSE2/3/4a  have all only added instructions, and there's nothing to stop them from removing support for these instructions from e.g. decoder.</p>\n</blockquote>\n<p>Theoretically, but in a practical sense the only time instruction sets go away is if they get no adoption or don't serve their intended purpose (e.g. MPX).</p>",
        "id": 275861256,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647636802
    },
    {
        "content": "<p>Anyways, as far as AArch64 goes, a more important detail is that the registers are enabled and disabled via the same bit in the processor for both \"NEON\" and \"floating point\" functionality, which is why I view having a separate \"bit\" on the Rust side as unnecessary.</p>",
        "id": 275862731,
        "sender_full_name": "Jubilee",
        "timestamp": 1647637570
    },
    {
        "content": "<p>Note that it is more complex for AArch32: unlike x86, where \"long mode\" is reached via transition from protected mode, a processor can have <strong>only</strong> the AArch64 state!</p>",
        "id": 275862971,
        "sender_full_name": "Jubilee",
        "timestamp": 1647637710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/131828-t-compiler/topic/perhaps.20cannot.20force.20explicit.20coupling.20of.20fp.20and.20neon.20.2395002/near/275862971\">said</a>:</p>\n<blockquote>\n<p>Note that it is more complex for AArch32: unlike x86, where \"long mode\" is reached via transition from protected mode, a processor can have <strong>only</strong> the AArch64 state!</p>\n</blockquote>\n<p>I've seen hypotheses that x86-64 could do the same: start in long mode, and omit 16-bit mode.</p>",
        "id": 275863724,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647638094
    },
    {
        "content": "<p>(Such CPUs don't currently exist, but architecturally it'd be feasible, and current OSes wouldn't care.)</p>",
        "id": 275863867,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647638125
    },
    {
        "content": "<p>I imagine so, I just note it because it's a distinctly different approach.</p>",
        "id": 275864231,
        "sender_full_name": "Jubilee",
        "timestamp": 1647638320
    },
    {
        "content": "<p>Even if you omitted 16-bit mode, most instructions we think of as \"x86-64\" instructions actually have a naturally equivalent semantics in protected mode (thus x86-32), and the architectural state is preserved largely as-is. A32 vs. A64 just wholesale tosses that idea.</p>",
        "id": 275864676,
        "sender_full_name": "Jubilee",
        "timestamp": 1647638634
    },
    {
        "content": "<p>And SSE instructions vs. the addressing registers is more obvious when you have things like the new \"crc32\" feature in LLVM, which, instead of having an <code>(xmm, sse, _)</code> tuple, is <code>(r32, sse4.2, _)</code>.</p>",
        "id": 275873102,
        "sender_full_name": "Jubilee",
        "timestamp": 1647644754
    },
    {
        "content": "<p>Another issue came up: <a href=\"https://github.com/rust-lang/rust/issues/95122\">https://github.com/rust-lang/rust/issues/95122</a><br>\nAnd now <a href=\"https://github.com/rust-lang/rust/pull/91608\">https://github.com/rust-lang/rust/pull/91608</a> includes a fix for it as well.</p>",
        "id": 276132551,
        "sender_full_name": "Jubilee",
        "timestamp": 1647910747
    }
]