[
    {
        "content": "<p>I'm probably missing something obvious but what exactly is the reason that there are seemingly no plans to have inbuilt support in the compiler to compile Rust to run on the Java virtual machine? Is there something that makes Rust fundamentally unsuitable to bring to Java platforms? I mean just look at something like Kotlin. It can run on the JVM and natively. I know there's stuff like <a href=\"https://github.com/jni-rs/jni-rs\">https://github.com/jni-rs/jni-rs</a> which surely helps (although it seems its development has slightly ceased) but I don't understand why having inbuilt JVM compiler support right in <code>rustc</code> isn't a big priority considering that the Java market is so huge. Rust would literally gain access to an entirely new big market.<br>\nI mean, just imagine if Rust couldn't just be a replacement for languages like C or C++ and others but even for a language as widely used as Java.</p>",
        "id": 251074458,
        "sender_full_name": "ruster",
        "timestamp": 1630176295
    },
    {
        "content": "<p>Essentially anything that can run a JVM can also be targeted for native Rust compilation. And JVM code can call to native code already. So I don't understand why you can't already use Rust as part of a JVM project.</p>\n<p>For similar situations: you can call a native compiled Rust library from Python and Erlang/Elixir.</p>",
        "id": 251074808,
        "sender_full_name": "Lokathor",
        "timestamp": 1630176719
    },
    {
        "content": "<p>Could you elaborate on what you see as the benefits of being compiled to JVM byte code as opposed to just being called via JNI? Do you see it as a portability issue?</p>",
        "id": 251074970,
        "sender_full_name": "Lokathor",
        "timestamp": 1630176877
    },
    {
        "content": "<p>Hmm I suppose you are right but then why can't we use the same argument for Kotlin? Why didn't Kotlin only implement native support and then have itself just be called via JNI?</p>",
        "id": 251075110,
        "sender_full_name": "ruster",
        "timestamp": 1630177052
    },
    {
        "content": "<p>For one, there's an overhead. And also I'm pretty sure making use of the existing Java ecosystem is harder through JNI compared to if Rust were compiled to JVM byte code.</p>",
        "id": 251075193,
        "sender_full_name": "ruster",
        "timestamp": 1630177142
    },
    {
        "content": "<p>And if Rust had first-class support for Java, actual Java developers would also see and consider it more, simply for that reason.<br>\nIf Kotlin had only native support and had just said \"just call me through JNI, no need to compile me to Java byte code\" then I doubt as much Java code would have been rewritten in Kotlin as it has.<br>\nAnd again, I'm pretty sure easy access to the Java ecosystem (which is a huge one) is harder to do only through JNI.</p>",
        "id": 251075347,
        "sender_full_name": "ruster",
        "timestamp": 1630177274
    },
    {
        "content": "<p>Compiling rust to jvm is difficult to say the least, and nearly impossible without emulating memory (which is highly inefficient).</p>",
        "id": 251075762,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630177740
    },
    {
        "content": "<p>Can you elaborate on that? Will Rust be required to be GCed when it's compiled to the JVM?</p>",
        "id": 251075793,
        "sender_full_name": "ruster",
        "timestamp": 1630177789
    },
    {
        "content": "<p>I (attempted) to write a C/++ compiler to JVM byte code, and while I was unsuccessful, I noted that it could be done reasonably efficiently by exploiting strict aliasing. Rust does not have similar requirements, and rather treats memory as a flat object space (which you can read and write as any type you choose, provided the validity invariants remain intact).</p>",
        "id": 251075870,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630177842
    },
    {
        "content": "<p>First I will say that Kotlin started as a JVM language, \"java but better\" essentially, and Rust did not. So what's good for Kotlin isn't necessarily good for Rust.</p>\n<p>Second I will echo what Connor just said: Rust and Java have <em>radically</em> different ideas of how the universe works, and you would be very very limited trying to map large portions of one onto the other. The JNI works because you transmit through the very tiny, limited interface of the C ABI</p>",
        "id": 251075875,
        "sender_full_name": "Lokathor",
        "timestamp": 1630177846
    },
    {
        "content": "<p>Hmm, then I suppose the problem will indeed be that Rust is fundamentally unsuitable to run on the JVM with acceptable performance. That's a bummer.</p>",
        "id": 251075977,
        "sender_full_name": "ruster",
        "timestamp": 1630177962
    },
    {
        "content": "<p>If I write 4 bytes as a float in C++, I can't just read them as an int, so I can internally store it as a float, and use pointers that only act properly on floats. In rust, I can store an f32 then read it as an i32.</p>",
        "id": 251075996,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630177992
    },
    {
        "content": "<p>There isn't a reasonable way of doing that, other than storing the f32 in a large byte[].</p>",
        "id": 251076010,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630178016
    },
    {
        "content": "<p>I see. The environments are too different after all. To make Rust work on the JVM in a nice manner with acceptable performance it would probably require breaking changes that would have to change the whole language which will obviously not happen.</p>",
        "id": 251076092,
        "sender_full_name": "ruster",
        "timestamp": 1630178109
    },
    {
        "content": "<p>I think graalvm can run llvm-ir and thus possibly rust.</p>",
        "id": 251079132,
        "sender_full_name": "The 8472",
        "timestamp": 1630181315
    },
    {
        "content": "<p>In the JVM world there are actually efforts to start to support wasm that is already targeted by rust, like for example: <a href=\"https://github.com/oracle/graal/tree/master/wasm\">https://github.com/oracle/graal/tree/master/wasm</a> or <a href=\"https://github.com/cretz/asmble\">https://github.com/cretz/asmble</a></p>",
        "id": 251079174,
        "sender_full_name": "tglman",
        "timestamp": 1630181390
    },
    {
        "content": "<p>actually searching graalvm and llvm-ir I got this <a href=\"https://gist.github.com/eginez/c9c033a75ac85627996dd0a102981532\">https://gist.github.com/eginez/c9c033a75ac85627996dd0a102981532</a> simple example on how to do that</p>",
        "id": 251079324,
        "sender_full_name": "tglman",
        "timestamp": 1630181536
    },
    {
        "content": "<p>They're also working in the other direction, to improve their FFI story. Instead of JNI you'll be able to call C functions once they have been linked.<br>\nParts of that seem to be in JDK16. <a href=\"https://openjdk.java.net/projects/panama/\">https://openjdk.java.net/projects/panama/</a></p>",
        "id": 251079358,
        "sender_full_name": "The 8472",
        "timestamp": 1630181585
    },
    {
        "content": "<p>So you can export C APIs from rust and then import them in java.</p>",
        "id": 251079383,
        "sender_full_name": "The 8472",
        "timestamp": 1630181630
    },
    {
        "content": "<p>more of that in 17: <a href=\"https://download.java.net/java/early_access/jdk17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/package-summary.html\">https://download.java.net/java/early_access/jdk17/docs/api/jdk.incubator.foreign/jdk/incubator/foreign/package-summary.html</a></p>",
        "id": 251079547,
        "sender_full_name": "The 8472",
        "timestamp": 1630181770
    },
    {
        "content": "<p>I wonder how GraalVM and others solve those performance issues we've discussed above when compiling LLVM IR or WASM. Seems it's not so impossible after all?</p>",
        "id": 251080117,
        "sender_full_name": "ruster",
        "timestamp": 1630182450
    },
    {
        "content": "<p>graalvm is a superset of regular jvms, it acts more like a general-purpose compiler than of a java bytecode compiler</p>",
        "id": 251080220,
        "sender_full_name": "The 8472",
        "timestamp": 1630182563
    }
]