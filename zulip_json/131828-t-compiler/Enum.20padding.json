[
    {
        "content": "<p>It bugs me endlessly that a huge fraction of enums start with a 1 byte tag followed by 7 bytes of padding. And in complicated types (e.g. the compiler AST/HIR/whatever) you often have 2 or 3 or 4 layers of nested enums, each with their own padding.</p>",
        "id": 261088665,
        "sender_full_name": "nnethercote",
        "timestamp": 1636600779
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Are you thinking of enums with data, or C-like enums (just a discriminant)?</p>",
        "id": 261124147,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636632000
    },
    {
        "content": "<p>I also feel like AST &amp; HIR are hugely inefficient in terms of memory. Variants have typically (1) vastly different sizes, (2) high alignment requirements, (3) some fields with few possible values. They may benefit from a much more aggressive variant optimization mode. However, such optimizations may require to pack bits and have some fields non-adressable. Still, since most of the optimizable fields are Copy (whole HIR could be), that does not really seem like a deal breaker.</p>",
        "id": 261134806,
        "sender_full_name": "cjgillot",
        "timestamp": 1636637991
    },
    {
        "content": "<p>Yeah this has been an issue for windows-rs, <em>just</em> running configure_and_expand already uses like 9 GB before rustdoc gets a chance to run</p>",
        "id": 261136125,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636638672
    },
    {
        "content": "<p>(time-passes output if anyone is interested: <a href=\"https://github.com/microsoft/windows-docs-rs/pull/6#issuecomment-904022881\">https://github.com/microsoft/windows-docs-rs/pull/6#issuecomment-904022881</a>)</p>",
        "id": 261136237,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636638730
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Very much enums with data. One (partial) example I was looking at yesterday:</p>\n<div class=\"codehilite\"><pre><span></span><code>print-type-size type: `rustc_infer::traits::ObligationCauseCode`: 40 bytes, alignment: 8 bytes\nprint-type-size     discriminant: 1 bytes\nprint-type-size     variant `BuiltinDerivedObligation`: 39 bytes\nprint-type-size         padding: 7 bytes\nprint-type-size         field `.0`: 32 bytes, alignment: 8 bytes\nprint-type-size     variant `ImplDerivedObligation`: 39 bytes\nprint-type-size         padding: 7 bytes\nprint-type-size         field `.0`: 32 bytes, alignment: 8 bytes\nprint-type-size     variant `DerivedObligation`: 39 bytes\nprint-type-size         padding: 7 bytes\nprint-type-size         field `.0`: 32 bytes, alignment: 8 bytes\nprint-type-size     variant `FunctionArgumentObligation`: 31 bytes\nprint-type-size         padding: 3 bytes\nprint-type-size         field `.arg_hir_id`: 8 bytes, alignment: 4 bytes\nprint-type-size         field `.call_hir_id`: 8 bytes\nprint-type-size         padding: 4 bytes\nprint-type-size         field `.parent_code`: 8 bytes, alignment: 8 bytes\n...\n</code></pre></div>",
        "id": 261174747,
        "sender_full_name": "nnethercote",
        "timestamp": 1636658558
    },
    {
        "content": "<p>I wonder why the layout code isn't putting the discriminant at the end of the \"layout\", so we can avoid the extra padding. Maybe that's a good win?</p>",
        "id": 261175107,
        "sender_full_name": "simulacrum",
        "timestamp": 1636658793
    },
    {
        "content": "<p>I was also looking at <code>TyKind</code>. It's biggest variant is <code>FnPtr</code>, which contains a <code>PolyFnSig</code>, which is a <code>Binder&lt;FnSig&gt;</code>. <code>FnSig</code> has four fields, and <code>Binder&lt;T&gt;</code> adds another field. I tried \"inlining\" the five fields directly into <code>FnPtr</code>, like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>-    FnPtr(PolyFnSig&lt;&#39;tcx&gt;),\n+    FnPtr(&amp;&#39;tcx List&lt;Ty&lt;&#39;tcx&gt;&gt;, bool, hir::Unsafety, abi::Abi, &amp;&#39;tcx List&lt;BoundVariableKind&gt;),\n</code></pre></div>\n<p>This reduced the size of <code>TyKind</code> from 32 bytes to 24 bytes because it avoided padding. Then I had to change all the use points to account for the less ergonomic layout, using a new function that reconstituted a <code>PolyFnSig</code> from the five fields. A bit of a hassle and had negligible perf effect in the end.</p>",
        "id": 261175191,
        "sender_full_name": "nnethercote",
        "timestamp": 1636658844
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Interesting idea! For it to help I think every variant would need to have some padding at the end, which isn't so common IME.</p>",
        "id": 261175412,
        "sender_full_name": "nnethercote",
        "timestamp": 1636658961
    },
    {
        "content": "<p>The <code>TyKind</code> example shows how lots of padding occurs when you have multiple layers, enums within enums.</p>",
        "id": 261175459,
        "sender_full_name": "nnethercote",
        "timestamp": 1636658987
    },
    {
        "content": "<p>If you have an enum within an enum within an enum, you might have 7 bytes of padding after the discriminant for each one, for example.</p>",
        "id": 261175597,
        "sender_full_name": "nnethercote",
        "timestamp": 1636659042
    },
    {
        "content": "<p>The layout/alignment requirements for a type T are more strict when a type is within a Vector, say, than when you know it appears by itself within an enum variant. But the same layout is used in both cases.</p>",
        "id": 261175770,
        "sender_full_name": "nnethercote",
        "timestamp": 1636659131
    },
    {
        "content": "<p>yeah, true</p>",
        "id": 261175785,
        "sender_full_name": "simulacrum",
        "timestamp": 1636659140
    },
    {
        "content": "<p>I do recall mildly a comment (on a PR that implemented them layout opts) that layout optimizations don't currently cover discriminant but there is no reason why it couldn't.</p>",
        "id": 261177411,
        "sender_full_name": "nagisa",
        "timestamp": 1636660175
    },
    {
        "content": "<p>I guess just putting the discriminant at the end is likely to be most straightforward, an ideal implementation would have the ability to place a discriminant between fields of a variant in case that somehow helps.</p>",
        "id": 261177820,
        "sender_full_name": "nagisa",
        "timestamp": 1636660428
    },
    {
        "content": "<p>The discriminant surely has to be in the same place for every variant, right?</p>",
        "id": 261186842,
        "sender_full_name": "nnethercote",
        "timestamp": 1636666409
    },
    {
        "content": "<p>yeah, but there are still situations where e.g. there's some common unused between variants that could be used for the discriminant.</p>",
        "id": 261188773,
        "sender_full_name": "nagisa",
        "timestamp": 1636667862
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> One thing we've talked about various times is the idea of a \"type you can't take a reference to\".</p>",
        "id": 261193582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671455
    },
    {
        "content": "<p>Such a type would not need to use the same layout as that type normally does, because you can't write code that references it without knowing what it's contained in.</p>",
        "id": 261193653,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671487
    },
    {
        "content": "<p>Yes!</p>",
        "id": 261193660,
        "sender_full_name": "nnethercote",
        "timestamp": 1636671498
    },
    {
        "content": "<p>That would allow more aggressive niche optimizations, such as rearranging the fields of a sub-structure into the containing structure.</p>",
        "id": 261193663,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671502
    },
    {
        "content": "<p>That's one possible approach to solve this. I can think of two more.</p>",
        "id": 261193716,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671572
    },
    {
        "content": "<p>We could also teach the compiler to handle \"alignment\" niches: if it knows <code>T</code> must be 4-byte aligned, then <code>&amp;T</code> always has the low bits zero, so that's two bits that could be used for a small discriminant or similar.</p>",
        "id": 261193817,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671613
    },
    {
        "content": "<p>And we could teach the compiler to have target-specific opt-in niches for pointers that can never be valid; for instance, under x86_64 Linux, it'd be reasonable to default to \"valid pointers may never be less than 4096\".</p>",
        "id": 261193907,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671668
    },
    {
        "content": "<p>Would the \"type you can't take a reference to\" be an explicitly marked thing, or inferred by the compiler?</p>",
        "id": 261193965,
        "sender_full_name": "nnethercote",
        "timestamp": 1636671708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Enum.20padding/near/261193965\">said</a>:</p>\n<blockquote>\n<p>Would the \"type you can't take a reference to\" be an explicitly marked thing, or inferred by the compiler?</p>\n</blockquote>\n<p>Initially the former.</p>",
        "id": 261194015,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671726
    },
    {
        "content": "<p>I can imagine inferring the latter via whole-program optimization or similar, but we should add the support via explicit type first.</p>",
        "id": 261194038,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671753
    },
    {
        "content": "<p>(Also, this wouldn't necessarily be a property of a type, so much as a field of a type. Or an entire aggregate: \"splat out all fields of this and don't allow field references\".)</p>",
        "id": 261194060,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636671776
    },
    {
        "content": "<p>Feels a bit like <code>repr(packed)</code></p>",
        "id": 261194373,
        "sender_full_name": "nnethercote",
        "timestamp": 1636672054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> FWIW, if you're interested in working on any of those three, I'd be thrilled to be the lang-team liaison for the lang components of them.</p>",
        "id": 261194399,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636672080
    },
    {
        "content": "<p>I think they'd be valuable optimizations, and they can be the kind of thing that you flip a switch on in Rust, versus pervasive bit-swizzling accesses in C.</p>",
        "id": 261194519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636672163
    },
    {
        "content": "<p>My current problem is too many shiny things to work on, but I'll keep it in mind <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 261194611,
        "sender_full_name": "nnethercote",
        "timestamp": 1636672224
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Fair. Though it does seem like a useful path towards mass-optimizing memory usage.</p>",
        "id": 261196377,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673914
    },
    {
        "content": "<p>The existing optimizations for things like <code>Option&lt;Rc&lt;T&gt;&gt;</code> must already take advantage of low bits, is that right?</p>",
        "id": 261196505,
        "sender_full_name": "nnethercote",
        "timestamp": 1636674071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> I <em>think</em> that <code>Option&lt;Rc&lt;T&gt;&gt;</code> just takes advantage of the niche for NULL.</p>",
        "id": 261196766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674325
    },
    {
        "content": "<p>I don't think we can take advantage of alignment niches at all right now.</p>",
        "id": 261196771,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674335
    },
    {
        "content": "<p>Oh, so NULL means <code>None</code> and non-NULL means <code>Some</code>?</p>",
        "id": 261196854,
        "sender_full_name": "nnethercote",
        "timestamp": 1636674391
    },
    {
        "content": "<p>Just like in C <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 261196904,
        "sender_full_name": "nnethercote",
        "timestamp": 1636674446
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Enum.20padding/near/261196854\">said</a>:</p>\n<blockquote>\n<p>Oh, so NULL means <code>None</code> and non-NULL means <code>Some</code>?</p>\n</blockquote>\n<p>Right, that's the standard <code>Option</code> optimization we use in many places. We even guarantee it in FFI; you can write <code>Option&lt;&amp;T&gt;</code> instead of <code>*T</code> and we guarantee <code>None</code> will be NULL.</p>",
        "id": 261197134,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674652
    },
    {
        "content": "<p>Is <code>Option</code> special-cased, or will that work for any type with the same shape? I'm thinking of</p>\n<div class=\"codehilite\"><pre><span></span><code>pub enum Poll&lt;T&gt; {\n    Ready(T),\n    Pending,\n}\n</code></pre></div>",
        "id": 261197433,
        "sender_full_name": "nnethercote",
        "timestamp": 1636674926
    },
    {
        "content": "<p>It works for any enum of the same shape.</p>",
        "id": 261197452,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674949
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e4854a41747d7942badd00f02b6125e7\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=e4854a41747d7942badd00f02b6125e7</a></p>",
        "id": 261197551,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636675046
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>size_of::&lt;Option&lt;bool&gt;&gt;() = 1\nsize_of::&lt;Result&lt;(), char&gt;&gt;() = 4\n</code></pre></div>",
        "id": 261197562,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636675062
    },
    {
        "content": "<p>But types can only have one niche, which must be contiguous.</p>",
        "id": 261197626,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636675105
    },
    {
        "content": "<p>And because of the reference problem: <code>size_of::&lt;Result&lt;bool, char&gt;&gt;() = 8</code></p>",
        "id": 261197634,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636675112
    },
    {
        "content": "<p>If you applied \"no references\" to either the bool or the char (or both), that could be just 4 bytes.</p>",
        "id": 261197702,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636675190
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/45225\">#45225</a> was the big one, some tweaks and support for generators since then</p>",
        "id": 261198424,
        "sender_full_name": "The 8472",
        "timestamp": 1636675636
    },
    {
        "content": "<p>As far as official guarantees go it's only <code>Option</code> though, the others are unstable optimizations.</p>",
        "id": 261198564,
        "sender_full_name": "The 8472",
        "timestamp": 1636675759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Enum.20padding/near/261198564\">said</a>:</p>\n<blockquote>\n<p>As far as official guarantees go it's only <code>Option</code> though, the others are unstable optimizations.</p>\n</blockquote>\n<p>I thought that was only a limitation of FFI (that only Option is FFI-safe), not that we didn't guarantee the rest.</p>",
        "id": 261198776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636675942
    },
    {
        "content": "<p>repr(Rust) has no spec, hence no guarantees in general. this is the only explicit one <a href=\"https://doc.rust-lang.org/std/option/index.html#representation\">https://doc.rust-lang.org/std/option/index.html#representation</a></p>",
        "id": 261199301,
        "sender_full_name": "The 8472",
        "timestamp": 1636676536
    },
    {
        "content": "<p>And there's no RFC for niches either.</p>",
        "id": 261199336,
        "sender_full_name": "The 8472",
        "timestamp": 1636676580
    },
    {
        "content": "<p>Note that using LSBs and using null for niche are orthogonal</p>",
        "id": 261199729,
        "sender_full_name": "Gary Guo",
        "timestamp": 1636676984
    },
    {
        "content": "<p>Since null is also \"well-aligned\"</p>",
        "id": 261199745,
        "sender_full_name": "Gary Guo",
        "timestamp": 1636676996
    }
]