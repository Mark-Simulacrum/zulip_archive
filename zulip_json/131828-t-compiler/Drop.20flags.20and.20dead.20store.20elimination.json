[
    {
        "content": "<p>Here's the existing <a href=\"https://github.com/rust-lang/rust/blob/98a5a98f44130b5bafb4f2b2f3126fb22a5a3228/compiler/rustc_mir_dataflow/src/impls/liveness.rs\">liveness pass</a>. I'd be careful if trying to adapt its def/use categorization for your use case. It's only used for the generator transform.</p>",
        "id": 261886263,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637211135
    },
    {
        "content": "<p>There's a separate live variable analysis in the borrow-checker that uses a lazy paradigm, if you get bored and run out of MIR passes to read.</p>",
        "id": 261886270,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637211179
    },
    {
        "content": "<p>I think I can start by only considering assignments of boolean constants, if that makes it easier, because drop flags seem to be the common case here</p>",
        "id": 261886367,
        "sender_full_name": "nnethercote",
        "timestamp": 1637211293
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span> any suggestions where in the MIR phases this should go?</p>",
        "id": 261886484,
        "sender_full_name": "nnethercote",
        "timestamp": 1637211414
    },
    {
        "content": "<p>with the other optimizations</p>",
        "id": 261886495,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637211428
    },
    {
        "content": "<p>Or do you mean where within the optimizations? I don't know. As long as it runs after drop elaboration it should do what you want.</p>",
        "id": 261886516,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637211469
    },
    {
        "content": "<p>In here somewhere? <a href=\"https://github.com/rust-lang/rust/blob/55111d656f7ecd511ebfad09d3b4b41e44cbcc23/compiler/rustc_mir_transform/src/lib.rs#L502-L527\">https://github.com/rust-lang/rust/blob/55111d656f7ecd511ebfad09d3b4b41e44cbcc23/compiler/rustc_mir_transform/src/lib.rs#L502-L527</a></p>",
        "id": 261886781,
        "sender_full_name": "nnethercote",
        "timestamp": 1637211716
    },
    {
        "content": "<p>thanks</p>",
        "id": 261886854,
        "sender_full_name": "nnethercote",
        "timestamp": 1637211787
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span> <code>MutVisitor</code> runs forwards. If I want to run backwards I guess I'll need to hand-code the traversal myself? Not that it'll be hard, I just want to check I'm not missing something obvious</p>",
        "id": 261887440,
        "sender_full_name": "nnethercote",
        "timestamp": 1637212574
    },
    {
        "content": "<p>A question from someone who doesn't fully understand the architecture of the compiler in this area: does it make more sense to add dead store elimination for drop flags, or does it make more sense to attempt to eliminate drop flags in common cases?</p>",
        "id": 261930199,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637243961
    },
    {
        "content": "<p>It seems like, rather than generating drop flags everywhere and then eliminating the redundant ones, we could try to avoid generating drop flags in the first place for common patterns where we currently do generate them.</p>",
        "id": 261930258,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637243993
    },
    {
        "content": "<p>we already only create drop flags if they're needed, it's just that some assignments are not needed.</p>",
        "id": 261930463,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1637244046
    },
    {
        "content": "<p>Oh, interesting. What's the heuristic for when a drop flag is needed?</p>",
        "id": 261931192,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637244439
    },
    {
        "content": "<p>(Vs when we assign to it.)</p>",
        "id": 261931232,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637244461
    },
    {
        "content": "<p>A drop flag is needed when there's at least one drop of the variable/place in the MIR where the variables/place is not statically known to be initialized or not initialized. for example.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nb\">String</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// x is maybe initialized here</span>\n</code></pre></div>",
        "id": 261931819,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1637244734
    },
    {
        "content": "<p>Once we have a drop flag though it's assigned/unnassigned whenever the variable is initialized/moved from</p>",
        "id": 261931914,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1637244776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Drop.20flags.20and.20dead.20store.20elimination/near/261886484\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> any suggestions where in the MIR phases this should go?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> You might want to try running after <code>RemoveNoopLandingPasses</code> <a href=\"https://github.com/rust-lang/rust/blob/55111d656f7ecd511ebfad09d3b4b41e44cbcc23/compiler/rustc_mir_transform/src/lib.rs#L520\">https://github.com/rust-lang/rust/blob/55111d656f7ecd511ebfad09d3b4b41e44cbcc23/compiler/rustc_mir_transform/src/lib.rs#L520</a>. That would potentially surface more places where the drop flags are dead.</p>",
        "id": 261935059,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1637246191
    },
    {
        "content": "<p>I was thinking about this a while ago and it looked to me like a lot of the unnecessary drop flags we hand off to LLVM come from MIR that has generic types in play and at MIR opt time we don't know if they have effectful drops or not. We should certainly do better with these cases you highlighted but I wonder if eliminating redundant drop flags at codegen time (when we know all the concrete types) and then finding a way to share the optimization results across types would show improvements as well.</p>",
        "id": 261937412,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1637247235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span> Thanks for the great explanation!</p>",
        "id": 261948329,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637251582
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125250\">@Wesley Wiser</span> That sounds like a potentially substantial win with relatively little effort required.</p>",
        "id": 261948383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637251609
    },
    {
        "content": "<p>Stepping back for a second... the reason I started asking about this is that yesterday when I starting looking at MIR, this was literally the very first basic block in the small-but-real program I'm looking at:</p>\n<div class=\"codehilite\"><pre><span></span><code>    bb0: {\n        _28 = const false;               // scope 0 at src/main.rs:89:11: 89:20\n        _28 = const true;                // scope 0 at src/main.rs:89:11: 89:20\n        _1 = do_main() -&gt; bb1;           // scope 0 at src/main.rs:89:11: 89:20\n    }\n</code></pre></div>\n<p>Like, duh.<br>\nI can appreciate that a pre-monomorphization optimization pass to remove these dead stores may not be optimal, particularly one that's only intra-basic-block. But it should also be pretty easy, and it'll teach me more about MIR, and I'm curious to see how big the effect is. So I might go ahead and implement it anyway. If it's a measurable win then we can maybe argue about whether there's a better approach. Seem reasonable?</p>",
        "id": 261986847,
        "sender_full_name": "nnethercote",
        "timestamp": 1637267713
    },
    {
        "content": "<p>That seems like a great plan. :)</p>",
        "id": 261988967,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637268768
    },
    {
        "content": "<p>FWIW, it seems these drop flags are added in the <code>ElaborateDrops</code> pass, viz: <code>ElaborateDrops.before.mir</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>    bb0: {\n        StorageLive(_1);                 // scope 0 at src/main.rs:89:11: 89:20\n        _1 = do_main() -&gt; bb1;           // scope 0 at src/main.rs:89:11: 89:20\n    }\n</code></pre></div>\n<p>Becomes <code>ElaborateDrops.after.mir</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>    bb0: {\n        _36 = const false;               // scope 0 at src/main.rs:89:11: 89:20\n        _37 = const false;               // scope 0 at src/main.rs:89:11: 89:20\n        StorageLive(_1);                 // scope 0 at src/main.rs:89:11: 89:20\n        _36 = const true;                // scope 0 at src/main.rs:89:11: 89:20\n        _37 = const true;                // scope 0 at src/main.rs:89:11: 89:20\n        _1 = do_main() -&gt; bb1;           // scope 0 at src/main.rs:89:11: 89:20\n    }\n</code></pre></div>\n<p>The <code>SimplifyLocals</code> pass later somehow combines <code>_36</code> and <code>_37</code> into a single <code>_28</code></p>",
        "id": 261996626,
        "sender_full_name": "nnethercote",
        "timestamp": 1637272472
    },
    {
        "content": "<blockquote>\n<p>The <code>SimplifyLocals</code> pass later somehow combines <code>_36</code> and <code>_37</code> into a single <code>_28</code></p>\n</blockquote>\n<p>SimplifyLocals doesn't do anything that clever ;-). It only removes unused locals. The indexes will change, so diff tends to be confusing.</p>",
        "id": 261999011,
        "sender_full_name": "tm",
        "timestamp": 1637273578
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> what’s the input program like? I’m assuming its something where one field of a struct is moved on one branch of control flow but not another?</p>",
        "id": 261999262,
        "sender_full_name": "pnkfelix",
        "timestamp": 1637273686
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>fn main() -&gt; io::Result&lt;()&gt; {\n    // Ignore broken pipes, which occur for `counts input.txt | head -11`.\n    match do_main() {\n        Ok(_) =&gt; Ok(()),\n        Err(ref err) if err.kind() == io::ErrorKind::BrokenPipe =&gt; Ok(()),\n        Err(err) =&gt; {\n            eprintln!(&quot;counts: {}&quot;, err);\n            std::process::exit(1);\n        }\n    }\n}\n</code></pre></div>",
        "id": 261999496,
        "sender_full_name": "nnethercote",
        "timestamp": 1637273746
    },
    {
        "content": "<p>yep okay</p>",
        "id": 261999594,
        "sender_full_name": "pnkfelix",
        "timestamp": 1637273802
    },
    {
        "content": "<p>In the past before we had <code>ElaborateDrops</code> pass we would introduce dynamic flags for every possible variable in codegen.</p>",
        "id": 261999618,
        "sender_full_name": "nagisa",
        "timestamp": 1637273812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> You're referring to the two <code>Err</code> cases?</p>",
        "id": 261999671,
        "sender_full_name": "nnethercote",
        "timestamp": 1637273845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> yeah. The third branch moves <code>err</code>, the second does not. (I’m not actually sure how elaborate-drops represents the distinction between enum variants.)</p>",
        "id": 261999808,
        "sender_full_name": "pnkfelix",
        "timestamp": 1637273895
    },
    {
        "content": "<p>Which is why it seems that <code>ElaborateDrops</code> actually makes the code worse, but it doesn't, as it obviated the worse thing we used to do in codegen.</p>",
        "id": 261999862,
        "sender_full_name": "nagisa",
        "timestamp": 1637273921
    },
    {
        "content": "<p>(but I assume its something like “allocate a seperate variable for every field of every variant.”)</p>",
        "id": 261999880,
        "sender_full_name": "pnkfelix",
        "timestamp": 1637273927
    }
]