[
    {
        "content": "<p>discussion scheduled for 17:00 GMT with <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span></p>",
        "id": 182188490,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575043591
    },
    {
        "content": "<p>I am back. No problem if you want to wait till 17:00 GMT.</p>",
        "id": 182190940,
        "sender_full_name": "bjorn3",
        "timestamp": 1575046200
    },
    {
        "content": "<p>Context: <a href=\"https://github.com/rust-lang/compiler-team/issues/213#issuecomment-559055312\" target=\"_blank\" title=\"https://github.com/rust-lang/compiler-team/issues/213#issuecomment-559055312\">https://github.com/rust-lang/compiler-team/issues/213#issuecomment-559055312</a> and following comments.</p>",
        "id": 182190994,
        "sender_full_name": "bjorn3",
        "timestamp": 1575046216
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span></p>",
        "id": 182191904,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047194
    },
    {
        "content": "<p>Hi</p>",
        "id": 182191923,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047223
    },
    {
        "content": "<p>I think the most important part is saving the user variables</p>",
        "id": 182191945,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047267
    },
    {
        "content": "<p>Right</p>",
        "id": 182192003,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047292
    },
    {
        "content": "<p>Debug-printing also to some degree</p>",
        "id": 182192013,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047303
    },
    {
        "content": "<p>One possibility for the variables is heap allocating them and telling cg_clif to look at a certain location for the locals of the main closure.</p>",
        "id": 182192032,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047338
    },
    {
        "content": "<p>Hmm</p>",
        "id": 182192133,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047404
    },
    {
        "content": "<p>The <code>as_debug</code> intrinsic is easily implementable in cg_clif or any other backend I think.</p>",
        "id": 182192146,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047413
    },
    {
        "content": "<p>Oh great</p>",
        "id": 182192164,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047430
    },
    {
        "content": "<p>Ideally we donâ€™t heap allocate, since the main point of the cranelift backend is performance.</p>",
        "id": 182192195,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047468
    },
    {
        "content": "<p>Heap allocation would also make stack pinning automatically work, as the stack variables are never moved</p>",
        "id": 182192196,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047468
    },
    {
        "content": "<p>But still, there are worse things.</p>",
        "id": 182192201,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047479
    },
    {
        "content": "<p>True</p>",
        "id": 182192209,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047493
    },
    {
        "content": "<p>Is there support for stack-pinning at present?</p>",
        "id": 182192265,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047534
    },
    {
        "content": "<p>A bump allocator should work for the heap</p>",
        "id": 182192269,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047546
    },
    {
        "content": "<p>Stack-pinning should just work in cg_clif,  as it only depends on the stack not moving (why would it) and the MIR being correctly evaluated (duh)</p>",
        "id": 182192300,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047605
    },
    {
        "content": "<p>Execution would be using SpiderMonkey I presume?</p>",
        "id": 182192304,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047610
    },
    {
        "content": "<p>Yes fair</p>",
        "id": 182192359,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047655
    },
    {
        "content": "<p>Cranelift can be used as compiler backend for SpiderMonkey when compiling wasm. It doesn't depend on SpiderMonkey itself.</p>",
        "id": 182192381,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047686
    },
    {
        "content": "<p>I mean, we could run using one of several engines, but SpiderMonkey by default makes sense right?</p>",
        "id": 182192384,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047694
    },
    {
        "content": "<p>Yep of course.</p>",
        "id": 182192397,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047703
    },
    {
        "content": "<p>In cg_clif I use <a href=\"https://docs.rs/cranelift-simplejit/0.51.0/cranelift_simplejit/\" target=\"_blank\" title=\"https://docs.rs/cranelift-simplejit/0.51.0/cranelift_simplejit/\"><code>simplejit</code></a> for JIT execution</p>",
        "id": 182192402,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047713
    },
    {
        "content": "<p>We want to avoid assumptions in the REPL about the execution engine I suppose.</p>",
        "id": 182192424,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047749
    },
    {
        "content": "<p>I see.</p>",
        "id": 182192427,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575047752
    },
    {
        "content": "<p>Is is called \"simple\" as it doesn't support on stack replacement of function for deoptimization and many other things.</p>",
        "id": 182192469,
        "sender_full_name": "bjorn3",
        "timestamp": 1575047767
    },
    {
        "content": "<p>hmm</p>",
        "id": 182192748,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048004
    },
    {
        "content": "<p>How is panicking/intrinsics::abort handled by the REPL? I assume it rolls-back all possible changes. However for example written files can't be rolled-back.</p>",
        "id": 182192765,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048021
    },
    {
        "content": "<p>I haven't worried about that until now. It's not really a concern for the MVP, though I admit more thought will need to be given to it.</p>",
        "id": 182192788,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048057
    },
    {
        "content": "<p>at the moment I <em>believe</em> it just ignores the current evaluation session.</p>",
        "id": 182192812,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048088
    },
    {
        "content": "<p>like it never happened (modulo I/O)</p>",
        "id": 182192818,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048095
    },
    {
        "content": "<p>This would be even worse for cg_clif as intrinsic::abort and SIGSEGV would kill the REPL.</p>",
        "id": 182192821,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048104
    },
    {
        "content": "<p>true</p>",
        "id": 182192825,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048114
    },
    {
        "content": "<p>BTW, what do you mean \"stack replacement of function\"?</p>",
        "id": 182192883,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048141
    },
    {
        "content": "<p>I am far from expert when it comes to low-level languages / bytecodes / etc.</p>",
        "id": 182192922,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048192
    },
    {
        "content": "<p>That the execution gets reverted back to an interpreter with all locals available to that interpreter. And when function returns the interpreter returns to the parent. I believe the other way around (interpreter -&gt; jit) is also possible.</p>",
        "id": 182192951,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048241
    },
    {
        "content": "<p>ah</p>",
        "id": 182193056,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048332
    },
    {
        "content": "<p>So, can we maybe discuss a high-level overview of how this should work?</p>",
        "id": 182193152,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048453
    },
    {
        "content": "<p>and differ from the miri backend, in particular?</p>",
        "id": 182193156,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048461
    },
    {
        "content": "<p>that would help me, I think.</p>",
        "id": 182193160,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048468
    },
    {
        "content": "<p>ok</p>",
        "id": 182193235,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048518
    },
    {
        "content": "<p>ta</p>",
        "id": 182193270,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048575
    },
    {
        "content": "<p>so, the REPL currently drives the compilation itself (doesn't really use <code>rustc_driver</code>)</p>",
        "id": 182193329,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048607
    },
    {
        "content": "<p>By the way</p>\n<blockquote>\n<p>This would be even worse for cg_clif as intrinsic::abort and SIGSEGV would kill the REPL.</p>\n</blockquote>\n<p>The <a href=\"https://github.com/google/evcxr\" target=\"_blank\" title=\"https://github.com/google/evcxr\">https://github.com/google/evcxr</a> jupyter kernel decided to thrash all non serde::Serializable values on crashes.</p>",
        "id": 182193345,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048647
    },
    {
        "content": "<p>I don't know how cg_clif integrates with rustc right now (do you have to drive compilation yourself?)</p>",
        "id": 182193364,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048669
    },
    {
        "content": "<p>cg_clif uses the same interface as cg_llvm currently does</p>",
        "id": 182193376,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048689
    },
    {
        "content": "<p>but regardless, because of the way the REPL is set up, I guess I can just depend on <code>rustc_codegen_cranelift</code> an replace the normal codegen step with this.</p>",
        "id": 182193380,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048692
    },
    {
        "content": "<p>okay nice</p>",
        "id": 182193382,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048694
    },
    {
        "content": "<p>Basically: You pass -Zcodegen-backend=/path/to/librustc_codegen_cranelift.so to rustc</p>",
        "id": 182193446,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048726
    },
    {
        "content": "<p>evcxr is a nice idea, but a terrible hacky thing I believe :-) hopefully this new REPL will lend itself towards a better Jupiter kernel in time.</p>",
        "id": 182193450,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048741
    },
    {
        "content": "<p>oh right</p>",
        "id": 182193455,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048744
    },
    {
        "content": "<p>and it outputs files, necessarily, or it can output to memory too?</p>",
        "id": 182193473,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048772
    },
    {
        "content": "<p>the Cranelift bytecode</p>",
        "id": 182193481,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048779
    },
    {
        "content": "<p>Rustc then loads it, and calls <code>__rustc_codegen_backend</code>, which returns a <code>Box&lt;dyn CodegenBackend&gt;</code></p>",
        "id": 182193483,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048780
    },
    {
        "content": "<ol>\n<li>Cranelift doesn't have a bytecode, only a text format.</li>\n<li>When using cranelift-simplejit, the executable code gets generated on the fly into <strong>memory</strong> and a pointer to a function can then be retrieved</li>\n</ol>",
        "id": 182193555,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048845
    },
    {
        "content": "<p>aha, shows me ignorance about Cranelift, sorry :-)</p>",
        "id": 182193590,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048901
    },
    {
        "content": "<p>interesting</p>",
        "id": 182193602,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048912
    },
    {
        "content": "<blockquote>\n<p>evcxr is a nice idea, but a terrible hacky thing I believe :-)</p>\n</blockquote>\n<p>Indeed. It even parses the rustc error messages.</p>",
        "id": 182193609,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048926
    },
    {
        "content": "<p>cranelift-simplejit sounds great. we should use this by default, at least (maybe the only executor for now)</p>",
        "id": 182193614,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048936
    },
    {
        "content": "<p>yep I saw that hah (error message parsing)</p>",
        "id": 182193623,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575048951
    },
    {
        "content": "<blockquote>\n<p>aha, shows me ignorance about Cranelift, sorry :-)</p>\n</blockquote>\n<p>I didn't expect you to know everything about Cranelift :)</p>",
        "id": 182193685,
        "sender_full_name": "bjorn3",
        "timestamp": 1575048980
    },
    {
        "content": "<p>so, simplejit is somehow passed as an option for the rustc_codegen_cranelift backend?</p>",
        "id": 182193732,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049026
    },
    {
        "content": "<p>as a .so too, perhaps?</p>",
        "id": 182193789,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049076
    },
    {
        "content": "<p>Yes, you set the \"SHOULD_RUN\" env var: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/65f69d10853be9e386749b08c26abd4e84193f25/src/driver.rs#L22\" target=\"_blank\" title=\"https://github.com/bjorn3/rustc_codegen_cranelift/blob/65f69d10853be9e386749b08c26abd4e84193f25/src/driver.rs#L22\">https://github.com/bjorn3/rustc_codegen_cranelift/blob/65f69d10853be9e386749b08c26abd4e84193f25/src/driver.rs#L22</a></p>",
        "id": 182193793,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049080
    },
    {
        "content": "<p>aha</p>",
        "id": 182193841,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049087
    },
    {
        "content": "<blockquote>\n<p>cranelift-simplejit sounds great. we should use this by default, at least (maybe the only executor for now)</p>\n</blockquote>\n<p>Miri is nice too, as that will show you many cases of UB if you are prototyping something.</p>",
        "id": 182193924,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049193
    },
    {
        "content": "<p>And it has better fault-tolerance (rollback instead of crashing the repl)</p>",
        "id": 182193994,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049227
    },
    {
        "content": "<p>exactly my thoughts</p>",
        "id": 182194008,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049242
    },
    {
        "content": "<p>also, we may build in advanced debugging capabilities that are only possible in the miri backend.</p>",
        "id": 182194024,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049262
    },
    {
        "content": "<p>but that's post-MVP obviously</p>",
        "id": 182194029,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049266
    },
    {
        "content": "<p>I have plans for various features after the MVP, like value and type holes, but I think they should be backend-independent.</p>",
        "id": 182194043,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049292
    },
    {
        "content": "<p>Yeah, priroda support would be nice. (disclaimer: I got write perm)</p>",
        "id": 182194102,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049332
    },
    {
        "content": "<p>okay nice</p>",
        "id": 182194112,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049340
    },
    {
        "content": "<p>so, the idea is, once JIT execution finishes, cg-clif can return a set of live variables? this is already possible, right?</p>",
        "id": 182194118,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049353
    },
    {
        "content": "<p>and we know their types, so we can recursively serialise all the memory they reference?</p>",
        "id": 182194148,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049397
    },
    {
        "content": "<p>How would you implement value holes in cg_clif? There may not be an invalid value for the type. (<code>MaybeUninit&lt;u8&gt;</code>)</p>",
        "id": 182194154,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049403
    },
    {
        "content": "<p>it would be done at the MIR level in fact, as I envisage, so by the time it gets to cranelift, there is nothing uninitialised, no holes, etc., until they get filled later :-)</p>",
        "id": 182194216,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049465
    },
    {
        "content": "<blockquote>\n<p>so, the idea is, once JIT execution finishes, cg-clif can return a set of live variables? this is already possible, right?</p>\n</blockquote>\n<p>That should be on the MIR level I think.</p>",
        "id": 182194228,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049485
    },
    {
        "content": "<blockquote>\n<p>and we know their types, so we can recursively serialise all the memory they reference?</p>\n</blockquote>\n<p>No, <em>cough</em> ptr-int casts <em>cough</em></p>",
        "id": 182194252,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049511
    },
    {
        "content": "<p>heh</p>",
        "id": 182194336,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049572
    },
    {
        "content": "<p>but wait: is the idea is the idea to keep all the memory around after JIT finishes, so serialisation isn't needed at all in theory? (sorry for my naivety)</p>",
        "id": 182194359,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049608
    },
    {
        "content": "<p>obviously we can't really do this with miri</p>",
        "id": 182194364,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049619
    },
    {
        "content": "<p>but simplejit...</p>",
        "id": 182194371,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049625
    },
    {
        "content": "<blockquote>\n<p>but wait: is the idea is the idea to keep all the memory around after JIT finishes, so serialisation isn't needed at all in theory? (sorry for my naivety)</p>\n</blockquote>\n<p>Yes, except for crash survival</p>",
        "id": 182194383,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049651
    },
    {
        "content": "<p>Except that that would need to serialize way more (c memory, open fds, memmaps, ...)</p>",
        "id": 182194441,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049690
    },
    {
        "content": "<p><code>fork()</code> should work I think</p>",
        "id": 182194451,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049727
    },
    {
        "content": "<p>yep true</p>",
        "id": 182194492,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049800
    },
    {
        "content": "<p>serialisation would also be nice to have feature-parity with using the miri backend (where you can actually save REPL sessions to disk and load them back up again later!)</p>",
        "id": 182194552,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049831
    },
    {
        "content": "<p>but maybe not an MVP thing for the Cranelift backend</p>",
        "id": 182194562,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049844
    },
    {
        "content": "<p><code>serde::Serialize</code> would be the most reliable</p>",
        "id": 182194579,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049865
    },
    {
        "content": "<p>How does the REPL handle compilation of extern crates?</p>",
        "id": 182194663,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049935
    },
    {
        "content": "<p>Would it be possible to force compilation as dylib?</p>",
        "id": 182194674,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049947
    },
    {
        "content": "<p>well, I use rustc's in-built serialisation framework right now, for obvious reasons... but I believe that is migrating over to serde anyway, at some point</p>",
        "id": 182194677,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049951
    },
    {
        "content": "<p>I've thought about that a bit</p>",
        "id": 182194681,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049955
    },
    {
        "content": "<p>but not in any depth</p>",
        "id": 182194685,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575049960
    },
    {
        "content": "<p>cg_clif in jit mode can currently only load dylibs, as it doesn't link rlibs.</p>",
        "id": 182194703,
        "sender_full_name": "bjorn3",
        "timestamp": 1575049985
    },
    {
        "content": "<p>right now it's all miri-evaluated (there's actually no explicit support for extern crates in the REPL, but in theory that's how it would work)</p>",
        "id": 182194714,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050003
    },
    {
        "content": "<p>right</p>",
        "id": 182194716,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050008
    },
    {
        "content": "<p>anyway, is there something special we need to do to tell simplejit where the memory for the previous compilation session was?</p>",
        "id": 182194839,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050155
    },
    {
        "content": "<p>I don't think that is necessary. Only cg_clif needs to know that to emit clif ir to load the locals from the right place.</p>",
        "id": 182194938,
        "sender_full_name": "bjorn3",
        "timestamp": 1575050250
    },
    {
        "content": "<p>aha</p>",
        "id": 182195011,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050312
    },
    {
        "content": "<p>makes sense</p>",
        "id": 182195017,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050316
    },
    {
        "content": "<p>so how do we tell it?</p>",
        "id": 182195019,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050319
    },
    {
        "content": "<p>Given that you are already using a custom driver, it should be possible to export another function like <code>__rustc_codegen_backend</code>, but which returns a struct, whose <code>codegen_crate</code> method accepts a map between main closure locals and addresses</p>",
        "id": 182195148,
        "sender_full_name": "bjorn3",
        "timestamp": 1575050440
    },
    {
        "content": "<p>Or something like that</p>",
        "id": 182195151,
        "sender_full_name": "bjorn3",
        "timestamp": 1575050446
    },
    {
        "content": "<p>right, this makes sense</p>",
        "id": 182195243,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050536
    },
    {
        "content": "<p>so, re liveness, there's a slight issue:</p>",
        "id": 182195339,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050642
    },
    {
        "content": "<p>I currently compute liveness dynamically, with the miri backend</p>",
        "id": 182195364,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050656
    },
    {
        "content": "<p>which is less conservative than static liveness calculations</p>",
        "id": 182195387,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050694
    },
    {
        "content": "<p>obviously</p>",
        "id": 182195393,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050698
    },
    {
        "content": "<p>maybe the solution is to use static liveness for both backends, and just accept the conservativeness?</p>",
        "id": 182195411,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050719
    },
    {
        "content": "<p>You mean:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">rand_bool</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 182195415,
        "sender_full_name": "bjorn3",
        "timestamp": 1575050723
    },
    {
        "content": "<p>exactly</p>",
        "id": 182195496,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050804
    },
    {
        "content": "<p>When a variable is possibly uninitialized, it is impossible to use it. However I believe the following works:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">rand_bool</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"n\">b</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Which means that the possibly uninitialized variable must not be dropped yet.</p>",
        "id": 182195539,
        "sender_full_name": "bjorn3",
        "timestamp": 1575050857
    },
    {
        "content": "<p>hah, I wondered what was going on there until you edited it!</p>",
        "id": 182195607,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050917
    },
    {
        "content": "<p>hmm</p>",
        "id": 182195608,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050919
    },
    {
        "content": "<p>I think just keeping all variables allocated on the heap would work.</p>",
        "id": 182195629,
        "sender_full_name": "bjorn3",
        "timestamp": 1575050950
    },
    {
        "content": "<p>what's the default allocator for simplejit, a bump allocator?</p>",
        "id": 182195644,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575050980
    },
    {
        "content": "<p>For code it just <code>mmap</code>'s. For stack, it uses the native stack. For codegened code <code>Box::new</code> it uses the same allocator as normally.</p>",
        "id": 182195752,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051073
    },
    {
        "content": "<p>wait, mmap's? I thought there was nothing on disk...</p>",
        "id": 182195770,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051110
    },
    {
        "content": "<p><code>mmap</code> can also be used for creating a large chunk of memory out of the void, not just for files.</p>",
        "id": 182195820,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051147
    },
    {
        "content": "<p>ah, sorry</p>",
        "id": 182195832,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051160
    },
    {
        "content": "<p>I see</p>",
        "id": 182195833,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051162
    },
    {
        "content": "<p>anyway</p>",
        "id": 182195835,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051173
    },
    {
        "content": "<p>I agree with you now: heap-allocating all locals just makes sense.</p>",
        "id": 182195845,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051185
    },
    {
        "content": "<p>I made a issue for cg_clif to do all this: <a href=\"https://github.com/bjorn3/rustc_codegen_cranelift/issues/817\" target=\"_blank\" title=\"https://github.com/bjorn3/rustc_codegen_cranelift/issues/817\">https://github.com/bjorn3/rustc_codegen_cranelift/issues/817</a></p>",
        "id": 182195858,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051224
    },
    {
        "content": "<p>but you're thinking of using a separate allocator for that, right? a bump allocator?</p>",
        "id": 182195861,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051228
    },
    {
        "content": "<p>yes, if it has a measurable impact on the execution time. (even ~10ms) as a REPL has to be as fast as possible</p>",
        "id": 182195925,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051283
    },
    {
        "content": "<p>yep</p>",
        "id": 182196020,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051394
    },
    {
        "content": "<p>I will post a summary of this discussion on the issue later</p>",
        "id": 182196030,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051407
    },
    {
        "content": "<p>incidentally, I will probably try to optimise the miri backend anyway, but I doubt we can get any better than 100x native speed.</p>",
        "id": 182196035,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051440
    },
    {
        "content": "<p>which is fine for many cases (especially considering certain benefits of miri), but equally a big enough slowdown that a Cranelift backend is really worth the effort.</p>",
        "id": 182196041,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051466
    },
    {
        "content": "<p>okay cool. a summary would be great!</p>",
        "id": 182196044,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051473
    },
    {
        "content": "<p>is there anything else to discuss?</p>",
        "id": 182196110,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051539
    },
    {
        "content": "<p>okay, just one other thing came to mind:</p>",
        "id": 182196124,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051564
    },
    {
        "content": "<p>as part of this struct we could pass into <code>codegen_crate</code>, we would specify both the \"user fn\" locals &lt;-&gt; memory addresses mapping but also which locals should be kept live (not deallocated), which is calculated ahead of time in some MIR pass, yes?</p>",
        "id": 182196197,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051629
    },
    {
        "content": "<p>I think it would be the easiest to let the REPL handle all allocation and deallocation of the locals</p>",
        "id": 182196223,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051673
    },
    {
        "content": "<p>okay</p>",
        "id": 182196236,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051722
    },
    {
        "content": "<p>so the REPL would have its own bump allocator (there are already one or two crates out there for this, I believe), and just feed in the addresses?</p>",
        "id": 182196287,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051764
    },
    {
        "content": "<p>yes</p>",
        "id": 182196290,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051770
    },
    {
        "content": "<p>I will have to leave</p>",
        "id": 182196307,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051785
    },
    {
        "content": "<p>sorry</p>",
        "id": 182196311,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051788
    },
    {
        "content": "<p>thanks for your time</p>",
        "id": 182196312,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051790
    },
    {
        "content": "<p>it's been very useful</p>",
        "id": 182196314,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051793
    },
    {
        "content": "<p>no problem</p>",
        "id": 182196328,
        "sender_full_name": "bjorn3",
        "timestamp": 1575051821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> I guess Cranelift will have to know not to deallocate any local that's specified in that struct, and just let the caller (REPL) handle it, but that shouldn't be hard to implement I guess.</p>",
        "id": 182196392,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051881
    },
    {
        "content": "<p>I think we've covered all the main points</p>",
        "id": 182196396,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051886
    },
    {
        "content": "<p>the reset will be details as we go along</p>",
        "id": 182196398,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051891
    },
    {
        "content": "<p>anyway, see you later.</p>",
        "id": 182196402,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575051897
    },
    {
        "content": "<p>yes, cg_clif shouldn't dealloc those locals</p>",
        "id": 182197313,
        "sender_full_name": "bjorn3",
        "timestamp": 1575053053
    },
    {
        "content": "<p>i forgot to mention one thing: currently any jitted function will remain allocated forever and be jitted again during the next compilation round.</p>",
        "id": 182197469,
        "sender_full_name": "bjorn3",
        "timestamp": 1575053282
    },
    {
        "content": "<p>i think i should teach simplejit how to dealloc specified functions and do that from cg_clif for all functions not potentially reachable from a fn ptr or vtable.</p>",
        "id": 182197512,
        "sender_full_name": "bjorn3",
        "timestamp": 1575053292
    },
    {
        "content": "<p>as for the recompilation, that will need something else. maybe a static hashmap between instance hash and address?</p>",
        "id": 182197532,
        "sender_full_name": "bjorn3",
        "timestamp": 1575053347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> I see. the problem is, knowing whether a given fn pointer is still hanging around is not something that can be statically analysed, obviously. this would be a very hard problem to solve in the general case, I think. I'm not sure how. However, since only \"new\" code is sent to Cranelift (including functions), I think you'll only get this problem if the fn definition is changed. (And in that case you may want the old definition of the fn to hang around anyway, although not necessarily.)</p>",
        "id": 182202298,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575059161
    },
    {
        "content": "<p>Still, we can be conservative and keep all versions of a fn around, throughout redefinitions.</p>",
        "id": 182202344,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575059174
    },
    {
        "content": "<p>Actually all functions which would normally end up in a rlib are all codegened by cg_clif, even if unchanged. the incremental cache is currently not used for codegen artifacts. also for simplejit it would be impossible to use the incremental cache, as no files are written. instead it must be kept in memory.</p>",
        "id": 182202667,
        "sender_full_name": "bjorn3",
        "timestamp": 1575059533
    },
    {
        "content": "<p>for fn pointer liveness i was thinking about assuming that every function which gets turned into a fnptr is assumed to be alive forever.</p>",
        "id": 182202704,
        "sender_full_name": "bjorn3",
        "timestamp": 1575059589
    },
    {
        "content": "<p>the latter could work yes</p>",
        "id": 182202724,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575059620
    },
    {
        "content": "<p>ah, I see about the incremental compilation...</p>",
        "id": 182202779,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575059679
    },
    {
        "content": "<p>for function redefinitions, i think it is the safest to keep the old function as target of function pointers. somebody might have spawned a thread which called it. (though cg_clif doesnt yet support threads)</p>",
        "id": 182202785,
        "sender_full_name": "bjorn3",
        "timestamp": 1575059686
    },
    {
        "content": "<p>this seems reasonable I think. this way only <em>new code getting evaluated</em> (current session) which <em>turns a fn into a fn-ptr</em> will make that fn stay around forever in memory</p>",
        "id": 182202871,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575059779
    },
    {
        "content": "<p>so this will probably need to be a MIR pass in rustc itself, which is enabled only in interpreter mode. that can come down the line...</p>",
        "id": 182202912,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575059876
    },
    {
        "content": "<p>it can also be done at the cg_clif end, which has to implement FnDef -&gt; FnPtr casts anyway.</p>",
        "id": 182202975,
        "sender_full_name": "bjorn3",
        "timestamp": 1575059940
    },
    {
        "content": "<p>hmm</p>",
        "id": 182203043,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575060011
    },
    {
        "content": "<p>maybe this makes more sense, since although checking at MIR level should be equivalent, doing it at Cranelift level is guaranteed to be more reliable, I suppose.</p>",
        "id": 182203080,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575060078
    },
    {
        "content": "<p>Yes, and mir passes are done before monomorphization, so you may not yet know what type a vtable is created for.</p>",
        "id": 182203833,
        "sender_full_name": "bjorn3",
        "timestamp": 1575061151
    },
    {
        "content": "<p>yeah fair point</p>",
        "id": 182204221,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575061617
    },
    {
        "content": "<p>basically, cg-clif should take care by itself of when to deallocate functions and when not to.</p>",
        "id": 182204309,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575061644
    },
    {
        "content": "<p>yes</p>",
        "id": 182204589,
        "sender_full_name": "bjorn3",
        "timestamp": 1575061879
    },
    {
        "content": "<p>Opened <a href=\"https://github.com/bytecodealliance/cranelift/issues/1260\" target=\"_blank\" title=\"https://github.com/bytecodealliance/cranelift/issues/1260\">https://github.com/bytecodealliance/cranelift/issues/1260</a> for the simpleJIT part of function dealloc.</p>",
        "id": 182204941,
        "sender_full_name": "bjorn3",
        "timestamp": 1575062349
    },
    {
        "content": "<p>good stuff, cheers</p>",
        "id": 182205070,
        "sender_full_name": "Alexander Regueiro",
        "timestamp": 1575062505
    }
]