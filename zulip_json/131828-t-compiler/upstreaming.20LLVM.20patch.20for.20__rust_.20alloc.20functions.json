[
    {
        "content": "<p>I'm back on this. Is there a reason to not send that patch upstream? There's plenty of caselaw for non-C++ stuff in LLVM (eg Swift) and it seems like it might make sense to just land this patch there. I'm happy to try and have that discussion with LLVM folks if there's not a compelling reason to keep it Rust-local.</p>",
        "id": 247370657,
        "sender_full_name": "durin42",
        "timestamp": 1627409840
    },
    {
        "content": "<p>LLVM hardcoding those symbols would effectively mean they're stable and we can't fix them</p>",
        "id": 247426192,
        "sender_full_name": "eddyb",
        "timestamp": 1627453705
    },
    {
        "content": "<p>I've been meaning to switch them for a while to something more \"mangled\" to avoid them looking like C symbols</p>",
        "id": 247426209,
        "sender_full_name": "eddyb",
        "timestamp": 1627453738
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"316805\">@durin42</span> also, as the PR linked above (<a href=\"https://github.com/rust-lang/llvm-project/pull/89\">https://github.com/rust-lang/llvm-project/pull/89</a>) makes it clear, <em>the signatures have changed</em>, so we'd also need some kind of versioning in the symbol name</p>",
        "id": 247426300,
        "sender_full_name": "eddyb",
        "timestamp": 1627453833
    },
    {
        "content": "<p>it would be useful to be able to use attributes or something to pass this information to LLVM, so we don't need LLVM to know about Rust symbols <em>at all</em></p>",
        "id": 247426389,
        "sender_full_name": "eddyb",
        "timestamp": 1627453943
    },
    {
        "content": "<p>maybe metadata connecting alloc/realloc/free functions together</p>",
        "id": 247426485,
        "sender_full_name": "eddyb",
        "timestamp": 1627454100
    },
    {
        "content": "<p>The signatures are unlikely to change nowadays as <code>GlobalAlloc</code> has been stabilized and the <code>__rust_*</code> allocator methods have a 1-to-1 correspondence with <code>GlobalAlloc</code> methods. They only happen to expand <code>Layout</code> into a separate size and align argument.</p>",
        "id": 247431351,
        "sender_full_name": "bjorn3",
        "timestamp": 1627459024
    },
    {
        "content": "<p>I just don't want to bake any assumptions about <em>unstable Rust std internals</em> into LLVM</p>",
        "id": 247434689,
        "sender_full_name": "eddyb",
        "timestamp": 1627461610
    },
    {
        "content": "<p>sure, the API wrapping those symbols might be stable, but the linking/call ABI isn't</p>",
        "id": 247434752,
        "sender_full_name": "eddyb",
        "timestamp": 1627461675
    },
    {
        "content": "<p>in fact it's probably broken if you try to mix multiple Rust versions into one process...</p>",
        "id": 247434781,
        "sender_full_name": "eddyb",
        "timestamp": 1627461715
    },
    {
        "content": "<p>The ABI is set to \"C\", so it doesn't change unless the allocator shim is explicitly changed.</p>",
        "id": 247435193,
        "sender_full_name": "bjorn3",
        "timestamp": 1627462027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20recognizing.20.60__rust_*.60.20allocator.20.20.2E.2E.2E/near/247434689\">said</a>:</p>\n<blockquote>\n<p>I just don't want to bake any assumptions about <em>unstable Rust std internals</em> into LLVM</p>\n</blockquote>\n<p>If anything I would like it to be stabilized. That would allow C code to use the rust allocator to say allocate a <code>Box</code> or <code>Vec</code> without requiring everyone to write wrappers in rust. For example <code>cxx</code> has a lot of rust wrappers like <a href=\"https://github.com/dtolnay/cxx/blob/9c1737feff7208cd4825984614beaf09a27aefcf/src/symbols/rust_vec.rs#L15-L56\">https://github.com/dtolnay/cxx/blob/9c1737feff7208cd4825984614beaf09a27aefcf/src/symbols/rust_vec.rs#L15-L56</a> that are called from C++ when trying to do anything with a <code>rust::Vec&lt;T&gt;</code> which is a C++ type that can be converted from and to a rust <code>Vec&lt;T&gt;</code> without reallocating.</p>",
        "id": 247435798,
        "sender_full_name": "bjorn3",
        "timestamp": 1627462474
    },
    {
        "content": "<p>that just makes me want to try to hide the symbols more</p>",
        "id": 247435806,
        "sender_full_name": "eddyb",
        "timestamp": 1627462494
    },
    {
        "content": "<p>they are a way for two crates to communicate. they <em>should never</em> be accessible through other means</p>",
        "id": 247435832,
        "sender_full_name": "eddyb",
        "timestamp": 1627462522
    },
    {
        "content": "<p>also, it's not really about what changes we make today, that I'm worried about, but about baking in something that we might later find a reason to want to change</p>",
        "id": 247435869,
        "sender_full_name": "eddyb",
        "timestamp": 1627462553
    },
    {
        "content": "<p>Why would you want to change it? There are literally zero alternative implementation methods. <code>__rust_*</code> is effectively exposed to stable as <code>alloc::Global</code>.</p>",
        "id": 247435870,
        "sender_full_name": "bjorn3",
        "timestamp": 1627462553
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> currently if you try to use custom global allocators from multiple <em>independently compiled</em> Rust <code>cdylib</code>s, aren't they broken? if C can see the symbol, doesn't that mean one of the allocators will be ignored?</p>",
        "id": 247436003,
        "sender_full_name": "eddyb",
        "timestamp": 1627462654
    },
    {
        "content": "<p>that's, for example, something that should IMO be fixed</p>",
        "id": 247436071,
        "sender_full_name": "eddyb",
        "timestamp": 1627462686
    },
    {
        "content": "<p>One allocator has to be ignored either way. Imagine two cdylibs depend on the same <code>libstd.so</code>. Which allocator should <code>libstd.so</code> use?</p>",
        "id": 247436082,
        "sender_full_name": "bjorn3",
        "timestamp": 1627462703
    },
    {
        "content": "<p>my point is a situation in which <em>they don't</em></p>",
        "id": 247436107,
        "sender_full_name": "eddyb",
        "timestamp": 1627462720
    },
    {
        "content": "<p>sorry, I forgot to say \"multiple versions of Rust\" too</p>",
        "id": 247436110,
        "sender_full_name": "eddyb",
        "timestamp": 1627462730
    },
    {
        "content": "<p>(or <code>-Z build-std</code> I guess)</p>",
        "id": 247436135,
        "sender_full_name": "eddyb",
        "timestamp": 1627462742
    },
    {
        "content": "<p>If <code>__rust_*</code> becomes stabilized, there is no problem with using the same allocator from multiple versions of rust.</p>",
        "id": 247436181,
        "sender_full_name": "bjorn3",
        "timestamp": 1627462775
    },
    {
        "content": "<p>I think panicking is similarly broken, and even worse since the ABI is nowhere near as unchanging</p>",
        "id": 247436255,
        "sender_full_name": "eddyb",
        "timestamp": 1627462805
    },
    {
        "content": "<p>Probably.</p>",
        "id": 247436328,
        "sender_full_name": "bjorn3",
        "timestamp": 1627462834
    },
    {
        "content": "<p>anyway, I think stabilizing any of these <em>implementation details</em> requires an RFC, and until such a thing gets accepted, I'd rather make these \"oh we just hardcoded some symbol names\" things more hidden and less predictable</p>",
        "id": 247436361,
        "sender_full_name": "eddyb",
        "timestamp": 1627462857
    },
    {
        "content": "<p>Add the rustc version to the symbol name?</p>",
        "id": 247436385,
        "sender_full_name": "bjorn3",
        "timestamp": 1627462876
    },
    {
        "content": "<p>if we can avoid LLVM hardcoding them, then we can probably fully mangle them (since the crate defining these symbols always depends on the crate declaring them <em>anyway</em>, so they can come from the latter)</p>",
        "id": 247436481,
        "sender_full_name": "eddyb",
        "timestamp": 1627462949
    },
    {
        "content": "<p>i.e. weak lang items would require exactly one declaration and one definition, and the definition cannot be supplied unless the declaration already exists in an upstream crate</p>",
        "id": 247436517,
        "sender_full_name": "eddyb",
        "timestamp": 1627462987
    },
    {
        "content": "<p>then, you just use the declaration's mangling as the symbol name</p>",
        "id": 247436538,
        "sender_full_name": "eddyb",
        "timestamp": 1627463010
    },
    {
        "content": "<p>this could potentially allow e.g. incompatible panic runtimes from separate <code>-Z build-std</code>, to avoid interfering with eachother in the same process (but Cargo may make this non-trivial)</p>",
        "id": 247436663,
        "sender_full_name": "eddyb",
        "timestamp": 1627463102
    },
    {
        "content": "<p>That would require renaming the personality function too I think.</p>",
        "id": 247436696,
        "sender_full_name": "bjorn3",
        "timestamp": 1627463140
    },
    {
        "content": "<p>It is currently hard coded as <code>rust_eh_personality</code>. Not even with an <code>__</code> prefix.</p>",
        "id": 247436797,
        "sender_full_name": "bjorn3",
        "timestamp": 1627463218
    },
    {
        "content": "<p><em>yikes</em></p>",
        "id": 247436810,
        "sender_full_name": "eddyb",
        "timestamp": 1627463230
    },
    {
        "content": "<p>This is the full list of unmangled symbols exported by a rust dylib:</p>\n<ul>\n<li>__rust_alloc</li>\n<li>__rust_alloc_zeroed</li>\n<li>__rust_realloc</li>\n<li>__rust_dealloc</li>\n<li>rust_oom</li>\n<li>__rdl_oom</li>\n</ul>\n<hr>\n<ul>\n<li>rust_begin_unwind (deliberately unmangled to allow breakpoint placing)</li>\n</ul>\n<hr>\n<ul>\n<li>rust_panic</li>\n<li>rust_eh_personality</li>\n<li>__rust_start_panic</li>\n<li>__rust_drop_panic</li>\n<li>__rust_foreign_exception</li>\n<li>__rust_panic_cleanup</li>\n</ul>",
        "id": 247437382,
        "sender_full_name": "bjorn3",
        "timestamp": 1627463650
    },
    {
        "content": "<p>so yeah I think we need mandatory mangling + using some other method to inform LLVM of any global allocator entry-points (such as custom attributes, that we could upstream later, and which could perhaps be usable from C or C++ through Clang custom attributes)</p>",
        "id": 247437438,
        "sender_full_name": "eddyb",
        "timestamp": 1627463696
    },
    {
        "content": "<p>I still think the allocator methods should stay this way. Mangling the panic related symbols (except <code>rust_begin_unwind</code>) is a good idea.</p>",
        "id": 247437665,
        "sender_full_name": "bjorn3",
        "timestamp": 1627463864
    },
    {
        "content": "<p>even if we decide to stabilize them, I don't think they should look <em>anything</em> like C symbols</p>",
        "id": 247438234,
        "sender_full_name": "eddyb",
        "timestamp": 1627464291
    },
    {
        "content": "<p><em>and</em> they need to be versioned (whether tied to Rust version or not)</p>",
        "id": 247438268,
        "sender_full_name": "eddyb",
        "timestamp": 1627464315
    },
    {
        "content": "<p>to avoid backtraces looking terrible, one earlier idea of mine was using v0 mangling but with a special hashless crate root</p>",
        "id": 247438389,
        "sender_full_name": "eddyb",
        "timestamp": 1627464393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20for.20__rust_.20alloc.20functions/near/247438234\">said</a>:</p>\n<blockquote>\n<p>even if we decide to stabilize them, I don't think they should look <em>anything</em> like C symbols</p>\n</blockquote>\n<p>If they don't, you can't call them from C.</p>",
        "id": 247438395,
        "sender_full_name": "bjorn3",
        "timestamp": 1627464399
    },
    {
        "content": "<p>I mean they'd still be interfaceable with C, they should just not follow any existing naming conventions</p>",
        "id": 247438416,
        "sender_full_name": "eddyb",
        "timestamp": 1627464420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20for.20__rust_.20alloc.20functions/near/247438268\">said</a>:</p>\n<blockquote>\n<p><em>and</em> they need to be versioned (whether tied to Rust version or not)</p>\n</blockquote>\n<p><code>alloc::Global</code> isn't versioned either.</p>",
        "id": 247438432,
        "sender_full_name": "bjorn3",
        "timestamp": 1627464427
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20for.20__rust_.20alloc.20functions/near/247438416\">said</a>:</p>\n<blockquote>\n<p>I mean they'd still be interfaceable with C, they should just not follow any existing naming conventions</p>\n</blockquote>\n<p>In what way?</p>",
        "id": 247438477,
        "sender_full_name": "bjorn3",
        "timestamp": 1627464468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20for.20__rust_.20alloc.20functions/near/247438389\">said</a>:</p>\n<blockquote>\n<p>to avoid backtraces looking terrible, one earlier idea of mine was using v0 mangling but with a special hashless crate root</p>\n</blockquote>\n<p>this, for example</p>",
        "id": 247438506,
        "sender_full_name": "eddyb",
        "timestamp": 1627464483
    },
    {
        "content": "<p>I see. That would work I guess.</p>",
        "id": 247438575,
        "sender_full_name": "bjorn3",
        "timestamp": 1627464516
    },
    {
        "content": "<p>e.g. <code>_RNvNtC4rust5alloc7realloc</code> would demangle as <code>rust::alloc::realloc</code></p>",
        "id": 247438577,
        "sender_full_name": "eddyb",
        "timestamp": 1627464517
    },
    {
        "content": "<p>and unlike a C-looking or C++-mangled symbol, it's <em>distinctly Rust</em></p>",
        "id": 247438729,
        "sender_full_name": "eddyb",
        "timestamp": 1627464621
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> the nice thing is that if we use \"the symbol name of the declaration\", <code>#[link_name = \"...\"]</code> is all it takes to \"stabilize\" any of them</p>",
        "id": 247438950,
        "sender_full_name": "eddyb",
        "timestamp": 1627464790
    },
    {
        "content": "<p>Almost, but not quite. The allocator methods are generated directly by the backend, not as part of any standard library crate.</p>",
        "id": 247439058,
        "sender_full_name": "bjorn3",
        "timestamp": 1627464864
    },
    {
        "content": "<p>I wrote a Pre-RFC: <a href=\"https://hackmd.io/@bjorn3/B18MVoRR_\">https://hackmd.io/@bjorn3/B18MVoRR_</a> <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> do you have any feedback before I post it on i.r-l.o?</p>",
        "id": 247444191,
        "sender_full_name": "bjorn3",
        "timestamp": 1627469459
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20for.20__rust_.20alloc.20functions/near/247439058\">said</a>:</p>\n<blockquote>\n<p>Almost, but not quite. The allocator methods are generated directly by the backend, not as part of any standard library crate.</p>\n</blockquote>\n<p>they're still \"imported\" somewhere in <code>alloc</code>, so that could serve as the \"source of truth\"</p>",
        "id": 247444439,
        "sender_full_name": "eddyb",
        "timestamp": 1627469679
    },
    {
        "content": "<p>I guess so. There is currently no direction connection between the two though. <code>liballoc</code> simply uses <code>extern \"C\" { fn __rust_alloc(...</code> without a lang item.</p>",
        "id": 247444498,
        "sender_full_name": "bjorn3",
        "timestamp": 1627469753
    },
    {
        "content": "<p>right, but that's trivially fixable</p>",
        "id": 247444530,
        "sender_full_name": "eddyb",
        "timestamp": 1627469763
    },
    {
        "content": "<p><a href=\"https://internals.rust-lang.org/t/pre-rfc-support-using-the-rust-allocator-from-c/15097\">https://internals.rust-lang.org/t/pre-rfc-support-using-the-rust-allocator-from-c/15097</a></p>",
        "id": 247448169,
        "sender_full_name": "bjorn3",
        "timestamp": 1627472693
    },
    {
        "content": "<p>oh no I didn't finish writing and sending my message, found this in Zulip:</p>\n<blockquote>\n<p>anyway, I have no feedback on the Pre-RFC, other that some kind of versioning might be desirable, tho most choices we might make for the names still allow to add some kind of extra information later - tho either way, stabilizing means that whatever usecases we allow have to always be supported (which, yes, as you've mentioned, would</p>\n</blockquote>",
        "id": 247449692,
        "sender_full_name": "eddyb",
        "timestamp": 1627473809
    },
    {
        "content": "<p>not sure what I wanted to say more, I guess that while it would always be <em>possible</em> to support today's exact set of functions and ABI, we may not want that if we e.g. add another method to the trait, with a default implementation, that we do want to allow it being overriden by a global allocator, and which we'd proxy through the symbols that would be stabilized</p>",
        "id": 247449957,
        "sender_full_name": "eddyb",
        "timestamp": 1627473974
    },
    {
        "content": "<p>we couldn't do that if we promised C code could implement an allocator, because they'd be missing the function</p>",
        "id": 247449985,
        "sender_full_name": "eddyb",
        "timestamp": 1627473997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20for.20__rust_.20alloc.20functions/near/247449985\">said</a>:</p>\n<blockquote>\n<p>we couldn't do that if we promised C code could implement an allocator, because they'd be missing the function</p>\n</blockquote>\n<p>Promising this would require more than my Pre-RFC as currently there is no way to tell rustc that you wrote a global allocator without actually defining it at the same place, so rustc will either error out due to no global allocator existing in it's view or try to generate an allocator shim for libstd's default allocator.</p>",
        "id": 247450126,
        "sender_full_name": "bjorn3",
        "timestamp": 1627474088
    },
    {
        "content": "<p>instead of upstreaming rust details, could LLVM get a new API for registering allocator details?</p>",
        "id": 247488374,
        "sender_full_name": "cuviper",
        "timestamp": 1627492604
    },
    {
        "content": "<p>That's probably worth discussing with upstream. I'm happy to try and shake a tree on my side and see if there's anyone from our stable of LLVM hackers that would be interested in having the conversation. Let me know?</p>",
        "id": 247495312,
        "sender_full_name": "durin42",
        "timestamp": 1627495674
    },
    {
        "content": "<p>just to be clear, \"registering\" might not be necessary if we can have attributes/metadata instead, to annotate functions directly</p>",
        "id": 247499311,
        "sender_full_name": "eddyb",
        "timestamp": 1627497494
    },
    {
        "content": "<p>idk how willing LLVM is to retire their hacky symbol hardcoding practices</p>",
        "id": 247499371,
        "sender_full_name": "eddyb",
        "timestamp": 1627497536
    },
    {
        "content": "<p>I'll try and shake a tree and see if they're willing to consider something.</p>",
        "id": 247501269,
        "sender_full_name": "durin42",
        "timestamp": 1627498360
    },
    {
        "content": "<p>I recall there being some effort around making allocation optimization agnostic to specific symbol names.</p>",
        "id": 247502936,
        "sender_full_name": "nagisa",
        "timestamp": 1627499051
    },
    {
        "content": "<p>not sure where it was, but there was definitely some discussion about that before.</p>",
        "id": 247502956,
        "sender_full_name": "nagisa",
        "timestamp": 1627499063
    },
    {
        "content": "<p>and yes, I believe it was a metadata annotation on the declaration or somesuch.</p>",
        "id": 247503016,
        "sender_full_name": "nagisa",
        "timestamp": 1627499093
    },
    {
        "content": "<p>Similar to GCC's <code>__attribute((malloc))</code>?</p>",
        "id": 247503289,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1627499228
    },
    {
        "content": "<p>Sort of. I don't know offhand if there are other requirements imposed by LLVM for allocation functions than just no-aliases.</p>",
        "id": 247503646,
        "sender_full_name": "nagisa",
        "timestamp": 1627499391
    },
    {
        "content": "<p>So, my LLVM experts say it's plausible that we could implement more attributes in LLVM, and thread that through. I might give that a shot.</p>",
        "id": 247602894,
        "sender_full_name": "durin42",
        "timestamp": 1627574048
    },
    {
        "content": "<p>Hokay, I'm _really_ close on this, but: do we not have any cases in Rust where we use an LLVM attribute that takes a parameter?</p>",
        "id": 255283674,
        "sender_full_name": "durin42",
        "timestamp": 1632857326
    },
    {
        "content": "<p><code>stack-probe</code>, or maybe its <code>probe-stack</code>?</p>",
        "id": 255283936,
        "sender_full_name": "nagisa",
        "timestamp": 1632857419
    },
    {
        "content": "<p>It takes either a function name or <code>inline-asm</code> as an argument.</p>",
        "id": 255284308,
        "sender_full_name": "nagisa",
        "timestamp": 1632857561
    },
    {
        "content": "<p>hm, I don't see that in LLVMRustAttribute?</p>",
        "id": 255284608,
        "sender_full_name": "durin42",
        "timestamp": 1632857680
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/attributes.rs#L155\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_codegen_llvm/src/attributes.rs#L155</a></p>",
        "id": 255284786,
        "sender_full_name": "nagisa",
        "timestamp": 1632857754
    },
    {
        "content": "<p>ah, I can just do it from a string, clever</p>",
        "id": 255285035,
        "sender_full_name": "durin42",
        "timestamp": 1632857866
    },
    {
        "content": "<p>I'm surprised you need an attribute with a value, is there a LLVM diff for this attribute?</p>",
        "id": 255285264,
        "sender_full_name": "nagisa",
        "timestamp": 1632857957
    },
    {
        "content": "<p>not yet, but I need to tell LLVM which argument is the size of the allocation</p>",
        "id": 255285496,
        "sender_full_name": "durin42",
        "timestamp": 1632858048
    },
    {
        "content": "<p>sec, lemme get an llvm repo I can push to</p>",
        "id": 255285545,
        "sender_full_name": "durin42",
        "timestamp": 1632858064
    },
    {
        "content": "<p><a href=\"https://github.com/durin42/llvm-project/commit/7a6923b390669b8b9a839ef1afa9ec80d1fa9c1e\">https://github.com/durin42/llvm-project/commit/7a6923b390669b8b9a839ef1afa9ec80d1fa9c1e</a> is what I've got, totally unreviewed</p>",
        "id": 255286111,
        "sender_full_name": "durin42",
        "timestamp": 1632858282
    },
    {
        "content": "<p>I'm avoiding things I don't want to do by messing with compiler internals</p>",
        "id": 255286142,
        "sender_full_name": "durin42",
        "timestamp": 1632858296
    },
    {
        "content": "<p>ah, okay, makes sense.</p>",
        "id": 255286155,
        "sender_full_name": "nagisa",
        "timestamp": 1632858305
    },
    {
        "content": "<p>oh my gosh it compiled a stage1</p>\n<p>still doesn't _work_, but it compiled!</p>",
        "id": 255286336,
        "sender_full_name": "durin42",
        "timestamp": 1632858371
    },
    {
        "content": "<p><a href=\"https://github.com/durin42/rust/commit/43aa09f57de84dfd6d158f5c4a78a27898d5d8eb\">https://github.com/durin42/rust/commit/43aa09f57de84dfd6d158f5c4a78a27898d5d8eb</a> see anything obvious in there? I don't think I see my attributes at all in the IR?</p>",
        "id": 255286469,
        "sender_full_name": "durin42",
        "timestamp": 1632858431
    },
    {
        "content": "<p>not sure, seems okay to me, but you should be looking at the function declaration and whatnot… and if them allocations are optimised out, then the declaration won't show up <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 255287071,
        "sender_full_name": "nagisa",
        "timestamp": 1632858667
    },
    {
        "content": "<p>you want to build code with -Cno-prepopulate-passes if you want to look at what llvm gets fed in the first place.</p>",
        "id": 255287162,
        "sender_full_name": "nagisa",
        "timestamp": 1632858701
    },
    {
        "content": "<p>we're adding the attributes so the allocations _can_ optimize out</p>",
        "id": 255287165,
        "sender_full_name": "durin42",
        "timestamp": 1632858702
    },
    {
        "content": "<p>I think I might see it actually, hang on</p>",
        "id": 255287286,
        "sender_full_name": "durin42",
        "timestamp": 1632858736
    },
    {
        "content": "<p>might also be the case that LLVM just discards attributes it doesn't know about</p>",
        "id": 255287298,
        "sender_full_name": "nagisa",
        "timestamp": 1632858739
    },
    {
        "content": "<p>make sure you build LLVM with assertions enabled.</p>",
        "id": 255287332,
        "sender_full_name": "nagisa",
        "timestamp": 1632858750
    },
    {
        "content": "<p>ooh, I segfaulted llvm</p>",
        "id": 255287363,
        "sender_full_name": "durin42",
        "timestamp": 1632858762
    },
    {
        "content": "<p>that sounds like an assertion firing ^^</p>",
        "id": 255287444,
        "sender_full_name": "nagisa",
        "timestamp": 1632858792
    },
    {
        "content": "<p>compiling the stage1 std, so I broke the compiler real good</p>",
        "id": 255287524,
        "sender_full_name": "durin42",
        "timestamp": 1632858825
    },
    {
        "content": "<p>(I tried poking the attribute on the <code>ret</code> value in that function, like the <code>LLVMSetTailCall</code> call, but that's clearly wrong)</p>",
        "id": 255287600,
        "sender_full_name": "durin42",
        "timestamp": 1632858848
    },
    {
        "content": "<p>If you don't have <code>[llvm] assertions=1</code> in your config.toml you definitely should add it.</p>",
        "id": 255288473,
        "sender_full_name": "nagisa",
        "timestamp": 1632859185
    },
    {
        "content": "<p>Added that, telling things to rebuild.</p>",
        "id": 255288636,
        "sender_full_name": "durin42",
        "timestamp": 1632859223
    },
    {
        "content": "<p>even with assertions enabled, it just segfaults, how fun</p>",
        "id": 255290299,
        "sender_full_name": "durin42",
        "timestamp": 1632859805
    },
    {
        "content": "<p>oh, this is a regression in llvm I think, and I just missed it until now. \"fun\"</p>",
        "id": 255290662,
        "sender_full_name": "durin42",
        "timestamp": 1632859998
    },
    {
        "content": "<p>Okay, I've worked around the breakage (it's the same LTO breakage as before, just manifests different now). I think the attribute needs to be on the function declaration, that is on the</p>\n<div class=\"codehilite\"><pre><span></span><code>; Function Attrs: nounwind nonlazybind uwtable\ndeclare void @__rust_dealloc(i8*, i64, i64) unnamed_addr #0\n</code></pre></div>\n<p>but I'm not sure where that declaration came from, so I'm not sure how to add the attribute. Any hints?</p>",
        "id": 255337459,
        "sender_full_name": "durin42",
        "timestamp": 1632887184
    },
    {
        "content": "<p>All declarations ultimately end up happening via <code>LLVMRustGetOrInsertFunction</code> pretty much.</p>",
        "id": 255435680,
        "sender_full_name": "nagisa",
        "timestamp": 1632935072
    },
    {
        "content": "<p>There aren't many calls of this function, and you probably can just have a debugger break on a call of this function with appropriate arguments.</p>",
        "id": 255435902,
        "sender_full_name": "nagisa",
        "timestamp": 1632935153
    },
    {
        "content": "<p>Right, I've been modifying a return value of LLVMRustGetOrInsertFunction in <a href=\"http://allocator.rs\">allocator.rs</a> in rustc_codegen_llvm, but it doesn'tseem to have a side effect...</p>",
        "id": 255470450,
        "sender_full_name": "durin42",
        "timestamp": 1632947991
    },
    {
        "content": "<p>Yeah, my point was that perhaps there's some other pathway the function declaration is created..</p>",
        "id": 255472740,
        "sender_full_name": "nagisa",
        "timestamp": 1632948933
    },
    {
        "content": "<p>best way to find that out would be IMO placing a <code>if name.starts_with(\"__rust_alloc\") { bpkt(); }</code> in the LLVMRustGetOrInsertFunction (or an equivalent breakpoint in a debugger)</p>",
        "id": 255472889,
        "sender_full_name": "nagisa",
        "timestamp": 1632948985
    },
    {
        "content": "<p>and then looking at the stack trace.</p>",
        "id": 255472902,
        "sender_full_name": "nagisa",
        "timestamp": 1632948993
    },
    {
        "content": "<p>Okay, I think I figured this out by bugging tmandry a bit. It looks like I should add new <code>#[rustc_deallocator]</code> and <code>#[rustc_allocator]</code> attributes that we can then wire up to <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_typeck/src/collect.rs#L2753\">emit the right stuff in rustc_typecheck</a>, but I think that means this takes two steps, where I do the first part and then wait for the new attributes to be in the bootstrap compiler?</p>",
        "id": 255475486,
        "sender_full_name": "durin42",
        "timestamp": 1632949979
    },
    {
        "content": "<p>The attribute can be applied conditionally: <code>#[cfg_attr(not(bootstrap), rustc_allocator)]</code></p>",
        "id": 255476269,
        "sender_full_name": "tm",
        "timestamp": 1632950202
    },
    {
        "content": "<p>indeed, thanks</p>",
        "id": 255476494,
        "sender_full_name": "durin42",
        "timestamp": 1632950286
    },
    {
        "content": "<p>That's… not necessarily true. Make sure to know where the declarations are created first. Then look at the surrounding code to see what data is consumed.</p>",
        "id": 255479575,
        "sender_full_name": "nagisa",
        "timestamp": 1632951612
    },
    {
        "content": "<p>Like you could probably already try setting some attributes here: <a href=\"https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/compiler/rustc_codegen_llvm/src/attributes.rs#L286-L288\">https://github.com/rust-lang/rust/blob/11491938f80988c7261a1179cf71a25c379c8783/compiler/rustc_codegen_llvm/src/attributes.rs#L286-L288</a></p>",
        "id": 255479915,
        "sender_full_name": "nagisa",
        "timestamp": 1632951761
    },
    {
        "content": "<p>I think the reason why working around the <code>allocator.rs</code> didn't help you is because its for implementation of the allocation functions, not the declaration.</p>",
        "id": 255480393,
        "sender_full_name": "nagisa",
        "timestamp": 1632951969
    },
    {
        "content": "<p>from what I can tell, anyway.\\</p>",
        "id": 255480426,
        "sender_full_name": "nagisa",
        "timestamp": 1632951993
    },
    {
        "content": "<p>Yeah that seems to line up. Adding the new attributes definitely seems to be working, now I'm struggling to get the <code>allocator(N)</code> argument set up right, as the string version of the API is producing IR that looks wrong</p>",
        "id": 255485495,
        "sender_full_name": "durin42",
        "timestamp": 1632954282
    },
    {
        "content": "<p>Is there a convenient way to get the stage0 compiler in a debugger for one of the stage1 compile actions? I'm hitting an LLVM assertion and I can't figure out what I've done wrong</p>",
        "id": 255486384,
        "sender_full_name": "durin42",
        "timestamp": 1632954732
    },
    {
        "content": "<p><a href=\"https://github.com/durin42/rust/commit/8c3336c508893e45c87b3bb188cc3df5fe55ffef\">https://github.com/durin42/rust/commit/8c3336c508893e45c87b3bb188cc3df5fe55ffef</a> is where we are now, I have to stop and eat etc. The issue is that the attempt to do <code>Attribute::Allocator.apply_llfn_with_value(llvm::AttributePlace::Function, llfn, 1);</code> in <code>attributes.rs</code> hits an assertion that implies we didn't pass a value, but I don't see how that could be. Either I'm missing something silly like a typo or bad enum conversion, or I need a debugger.</p>",
        "id": 255487396,
        "sender_full_name": "durin42",
        "timestamp": 1632955299
    },
    {
        "content": "<p>--verbose should print the failing commands and the necessary envvars I believe.</p>",
        "id": 255488427,
        "sender_full_name": "nagisa",
        "timestamp": 1632955911
    },
    {
        "content": "<p>I wonder if the attribute problem you'll have will be in the fact that <code>\"attribute\"=\"value\"</code> is distinct from <code>\"attribute(N)\"</code>.</p>",
        "id": 255488741,
        "sender_full_name": "nagisa",
        "timestamp": 1632956079
    },
    {
        "content": "<p>Ah, looks like you're covering that.</p>",
        "id": 255488971,
        "sender_full_name": "nagisa",
        "timestamp": 1632956216
    },
    {
        "content": "<p>worse, <code>\"attribute(N)\"</code> is distinct from <code>attribute(N)</code> (I already tried that)</p>",
        "id": 255490749,
        "sender_full_name": "durin42",
        "timestamp": 1632957239
    },
    {
        "content": "<p>verbose appears to give me the CLI but not the environment vars?</p>",
        "id": 255490824,
        "sender_full_name": "durin42",
        "timestamp": 1632957272
    },
    {
        "content": "<p>My suggestion would be to construct a minimal <code>#[no_core]</code> <code>test.rs</code> that has the allocations you want to test and then just try and build it with <code>./build/$target/stage1/bin/rustc</code>.</p>",
        "id": 255491111,
        "sender_full_name": "nagisa",
        "timestamp": 1632957463
    },
    {
        "content": "<p>that's one way.</p>",
        "id": 255491123,
        "sender_full_name": "nagisa",
        "timestamp": 1632957471
    },
    {
        "content": "<p>See <a href=\"https://github.com/rust-lang/rust/pull/82403\">https://github.com/rust-lang/rust/pull/82403</a> for printing out the envvars.</p>",
        "id": 255491217,
        "sender_full_name": "nagisa",
        "timestamp": 1632957513
    },
    {
        "content": "<p>I don't have a stage1 yet, stage0 is dying</p>",
        "id": 255491309,
        "sender_full_name": "durin42",
        "timestamp": 1632957582
    },
    {
        "content": "<p>stage nomenclature is confusing, but IIRC stage0 std build is using stage1 rustc to produce stage1 libstd.</p>",
        "id": 255491444,
        "sender_full_name": "nagisa",
        "timestamp": 1632957649
    },
    {
        "content": "<p>/me runs a ./x.py build --stage=1 to see the output again.</p>",
        "id": 255491592,
        "sender_full_name": "nagisa",
        "timestamp": 1632957747
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>    Finished dev [unoptimized + debuginfo] target(s) in 0.13s\nBuilding stage0 std artifacts (x86_64-unknown-linux-gnu -&gt; x86_64-unknown-linux-gnu)\n    Finished release [optimized] target(s) in 0.13s\nCopying stage0 std from stage0 (x86_64-unknown-linux-gnu -&gt; x86_64-unknown-linux-gnu / x86_64-unknown-linux-gnu)\nBuilding stage0 compiler artifacts (x86_64-unknown-linux-gnu -&gt; x86_64-unknown-linux-gnu)\n    Finished release [optimized] target(s) in 0.20s\nCopying stage0 rustc from stage0 (x86_64-unknown-linux-gnu -&gt; x86_64-unknown-linux-gnu / x86_64-unknown-linux-gnu)\nAssembling stage1 compiler (x86_64-unknown-linux-gnu)\nBuilding stage1 std artifacts (x86_64-unknown-linux-gnu -&gt; x86_64-unknown-linux-gnu)\n   Compiling std v0.0.0 (/usr/local/google/home/augie/Programming/big/rust/library/std)\n</code></pre></div>",
        "id": 255491893,
        "sender_full_name": "durin42",
        "timestamp": 1632957954
    },
    {
        "content": "<p>that's how far I get before it dies</p>",
        "id": 255491898,
        "sender_full_name": "durin42",
        "timestamp": 1632957959
    },
    {
        "content": "<p>ahh, <code>-vv</code>for extra verbosity</p>",
        "id": 255492023,
        "sender_full_name": "durin42",
        "timestamp": 1632958020
    },
    {
        "content": "<p>Them off-by-ones, eh.</p>",
        "id": 255492088,
        "sender_full_name": "nagisa",
        "timestamp": 1632958078
    },
    {
        "content": "<p>blah. I can't figure out how to get in there in a debugger, but I've started doing fopen();fprintf() debugging and the values are what I loosely expect, so that's upsetting</p>",
        "id": 255493216,
        "sender_full_name": "durin42",
        "timestamp": 1632958797
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/131828-t-compiler/topic/upstreaming.20LLVM.20patch.20for.20__rust_.20alloc.20functions/near/255491444\">said</a>:</p>\n<blockquote>\n<p>stage nomenclature is confusing, but IIRC stage0 std build is using stage1 rustc to produce stage1 libstd.</p>\n</blockquote>\n<p><code>build --stage 0 library/std</code> builds libstds using beta and does not build the compiler at all. <code>build --stage 1 library/std</code> first builds the compiler, then builds libstd with that newly built compiler. There's not a command to only build the compiler.</p>",
        "id": 255500007,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1632963092
    },
    {
        "content": "<p><a href=\"https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#understanding-stages-of-bootstrap\">https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#understanding-stages-of-bootstrap</a></p>",
        "id": 255500023,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1632963109
    },
    {
        "content": "<p>I'm finally at the point of having rustc cracked open in lldb, but it looks like there's no debug symbols (eg no links to lines of code) and some optimizations (some functions appear to have been inlined?) - any specific config.toml tricks I should be deploying here? I've already disabled optimizations for rustc_codegen_llvm but that didn't get me the links to code I was hoping for...</p>",
        "id": 255501841,
        "sender_full_name": "durin42",
        "timestamp": 1632964493
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"316805\">@durin42</span> debug = true</p>",
        "id": 255503402,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1632965829
    },
    {
        "content": "<p>If you want local variables, debuginfo-level = 2, but it uses a metric ton of disk space</p>",
        "id": 255503421,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1632965852
    },
    {
        "content": "<p>thanks! Looks like I found the problem - I need to extend AttrBuilder in LLVM to understand the new integer-bearing attributes</p>",
        "id": 255503438,
        "sender_full_name": "durin42",
        "timestamp": 1632965874
    },
    {
        "content": "<p>I've got this working and passing rustc's codegen tests about allocations optimizing away! Now for the second 90% of the work, wherein I find out what else needs to be in my LLVM patch to get accepted there.</p>",
        "id": 255607580,
        "sender_full_name": "durin42",
        "timestamp": 1633020628
    },
    {
        "content": "<p>Please add me as a reviewer or subscriber when you submit a diff.</p>",
        "id": 255609538,
        "sender_full_name": "nagisa",
        "timestamp": 1633021285
    }
]