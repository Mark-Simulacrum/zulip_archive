[
    {
        "content": "<p>my understanding is that it just wasn't possible to use proc-macros with the stage1 compiler before that</p>",
        "id": 261149836,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636645727
    },
    {
        "content": "<p>I think that’s still perhaps a little unsatisfying, because I think proc macros are morally “part of the compiler,” so if you’re compiling using the stage1 compiler, you probably want to load stage1-compiled proc macros. But implementing that seems like maybe more trouble than it’s worth, so whatever.</p>",
        "id": 261150145,
        "sender_full_name": "Alexis King",
        "timestamp": 1636645894
    },
    {
        "content": "<p>I don't think I understand. How would you compile stage2 <code>rustc_macros</code> if the ABI didn't match?</p>",
        "id": 261150260,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636645938
    },
    {
        "content": "<p>note that these are proc macros <em>used to generate compiler code</em>, not built-in macros</p>",
        "id": 261150285,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636645952
    },
    {
        "content": "<p>Right, but proc macros currently always exist in a separate crate, right? So if you have code in the compiler that depends on some proc macro in some crate <code>a</code>, then when compiling the stage2 compiler using the stage1 compiler, you could still load the <code>a</code> crate compiled with the stage1 compiler, and there’s no problem, because the stage1-compiled proc macro just generates token streams. So the stage1 compiler will compile the generated code using the new calling convention, and everything is okay… right?</p>",
        "id": 261150611,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646096
    },
    {
        "content": "<p>Err, no it isn’t, I said that wrong. You’d need to load crate <code>a</code> compiled with the stage0 compiler.</p>",
        "id": 261150769,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646166
    },
    {
        "content": "<p>I think this is a question for <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> or <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>  <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 261150771,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646166
    },
    {
        "content": "<p>(I guess I don’t actually know whether Rust’s stage numbering starts from 0 or 1. :))</p>",
        "id": 261150846,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646210
    },
    {
        "content": "<p>don't worry, no one else does either <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span><br>\n<a href=\"https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#understanding-stages-of-bootstrap\">https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html#understanding-stages-of-bootstrap</a></p>",
        "id": 261150930,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646250
    },
    {
        "content": "<p>Okay, it looks like it uses the numbering scheme I was assuming… but what I said above was still wrong. When I wrote</p>\n<blockquote>\n<p>if you’re compiling using the stage1 compiler, you probably want to load stage1-compiled proc macros</p>\n</blockquote>\n<p>what I really should have said was</p>\n<blockquote>\n<p>if you’re compiling using the stage1 compiler, you probably want to load stage0-compiled proc macros</p>\n</blockquote>",
        "id": 261151139,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646323
    },
    {
        "content": "<p>did this thread get split from the other one?</p>",
        "id": 261151247,
        "sender_full_name": "eddyb",
        "timestamp": 1636646376
    },
    {
        "content": "<p>Because if proc macros are “morally part of the compiler,” then the point is you want them to have been compiled with the same ABI as the compiler you’re currently using.</p>",
        "id": 261151250,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646379
    },
    {
        "content": "<p>given how many times I've gotten this wrong I am very unconfident in anything other than changing x.py to actually do the thing <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 261151256,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646383
    },
    {
        "content": "<p>I clicked on a notification that pinged me and got very confused</p>",
        "id": 261151269,
        "sender_full_name": "eddyb",
        "timestamp": 1636646389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261151247\">said</a>:</p>\n<blockquote>\n<p>did this thread get split from the other one?</p>\n</blockquote>\n<p>yes</p>",
        "id": 261151273,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646390
    },
    {
        "content": "<p>sorry for the confusion</p>",
        "id": 261151282,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646396
    },
    {
        "content": "<p>is this the thread I should read?</p>",
        "id": 261151312,
        "sender_full_name": "eddyb",
        "timestamp": 1636646403
    },
    {
        "content": "<p>yes</p>",
        "id": 261151352,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646406
    },
    {
        "content": "<p>(the other was 150+ messages)</p>",
        "id": 261151384,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646413
    },
    {
        "content": "<p>(I don't have strong opinions on finishing/stabilizing the generalization of hygiene other than \"someone should get to it\" :P)</p>",
        "id": 261151466,
        "sender_full_name": "eddyb",
        "timestamp": 1636646439
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456123\">@Alexis King</span> so the problem being solved is being able to compile the proc macro with the compiler which will then load it. an ABI bridge isn't needed to do this with a normal Rust release. however, <code>stage1/bin/rustc</code> is really weird in its internals</p>",
        "id": 261151882,
        "sender_full_name": "eddyb",
        "timestamp": 1636646633
    },
    {
        "content": "<p>it can't compile code that then links to itself</p>",
        "id": 261151946,
        "sender_full_name": "eddyb",
        "timestamp": 1636646648
    },
    {
        "content": "<p>right, yeah, I guess that makes sense</p>",
        "id": 261151974,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646664
    },
    {
        "content": "<p>its own internal ABI is potentially arbitrarily mismatched (from memory layouts to symbol manglings, etc. etc.) from the ABI it knows how to compile with</p>",
        "id": 261152016,
        "sender_full_name": "eddyb",
        "timestamp": 1636646686
    },
    {
        "content": "<p>and Rust has nothing like a \"versioned protocol\" built-in, so this \"bridge\" mechanism was the best I could come up with at the time</p>",
        "id": 261152065,
        "sender_full_name": "eddyb",
        "timestamp": 1636646711
    },
    {
        "content": "<p>Yeah, you’re right, if the proc macro code depends on stuff in the compiler, then you have the same bootstrapping problems with proc macros that you do with the compiler itself</p>",
        "id": 261152121,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646743
    },
    {
        "content": "<p>additionally, it's 99% RPC, with the hope of eventually using helper processes to run proc macros in isolated separate processes</p>",
        "id": 261152153,
        "sender_full_name": "eddyb",
        "timestamp": 1636646759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261152153\">said</a>:</p>\n<blockquote>\n<p>additionally, it's 99% RPC, with the hope of eventually using helper processes to run proc macros in isolated separate processes</p>\n</blockquote>\n<p>hey, this is basically <code>watt</code> we were talking  about before<br>\n<span class=\"user-mention silent\" data-user-id=\"278740\">Anatol Ulrich</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261091883\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span>, tangentially (performance related) - have you seen <a href=\"https://github.com/dtolnay/watt\">watt</a>?</p>\n</blockquote>",
        "id": 261152252,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646796
    },
    {
        "content": "<p>sadly this stalled because even cross-thread isolation (which was really easy to implement and test) was a p sad perf hit (due to rescheduling or something?)</p>",
        "id": 261152255,
        "sender_full_name": "eddyb",
        "timestamp": 1636646797
    },
    {
        "content": "<p>yeah, I think doing that would probably be unnecessarily slow, though I do understand the desire to do so</p>",
        "id": 261152298,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646825
    },
    {
        "content": "<p>maybe using OS features to share pages across processes would make it possible to improve performance, but I’ve never actually looked into how that works and what the perf characteristics are</p>",
        "id": 261152363,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646873
    },
    {
        "content": "<p>proc macros being arbitrary Rust code sucks for various reasons, but more isolation tends to be a slow down - <span class=\"user-mention\" data-user-id=\"270901\">@Nika Layzell</span> started working on massive bridge improvements but I haven't had the bandwidth to help with the review and stuff</p>",
        "id": 261152376,
        "sender_full_name": "eddyb",
        "timestamp": 1636646879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261152363\">said</a>:</p>\n<blockquote>\n<p>maybe using OS features to share pages across processes would make it possible to improve performance, but I’ve never actually looked into how that works and what the perf characteristics are</p>\n</blockquote>\n<p>I think we would need to first make cross-thread a negligible slowdown from same-thread, to even hope to do okay with multi-process</p>",
        "id": 261152465,
        "sender_full_name": "eddyb",
        "timestamp": 1636646912
    },
    {
        "content": "<p>right, yeah, that makes sense, too</p>",
        "id": 261152506,
        "sender_full_name": "Alexis King",
        "timestamp": 1636646938
    },
    {
        "content": "<p>in fact, multi-process might not be much harder at that point than cross-thread, since the thread control-flow separation seems to have bigger implications than the address space separation (but I haven't done any fancy measurements so maybe I'm wrong)</p>",
        "id": 261152553,
        "sender_full_name": "eddyb",
        "timestamp": 1636646966
    },
    {
        "content": "<p>wouldn't multi-process lose CoW semantics? I can imagine that being a pretty big slowdown</p>",
        "id": 261152602,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636646998
    },
    {
        "content": "<p>Generally my perspective on running proc macros in a truly isolated context would be “don’t”, because I think it opens up a lot of additional cans of worms that make the cure questionably better than the disease… I think it would be more successful to try to find a way to improve safety of running proc macros in-process, on the same thread</p>",
        "id": 261152661,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647015
    },
    {
        "content": "<p>there isn't really anything you can do from what I looked at</p>",
        "id": 261152698,
        "sender_full_name": "eddyb",
        "timestamp": 1636647035
    },
    {
        "content": "<p>it's just too much of an open-ended program</p>",
        "id": 261152732,
        "sender_full_name": "eddyb",
        "timestamp": 1636647051
    },
    {
        "content": "<p>even banning global state runs into a myriad of issues from not being able to tell benign idempotent caching from true cross-invocation communication</p>",
        "id": 261152799,
        "sender_full_name": "eddyb",
        "timestamp": 1636647093
    },
    {
        "content": "<p>That would provide far weaker benefits from a true security perspective, but as I said in the previous thread, I think the security issue is a lot less meaningful than people often initially think, and what’s more important is improving usability that primarily protects the programmer from themselves rather than from bad actors</p>",
        "id": 261152833,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261152661\">said</a>:</p>\n<blockquote>\n<p>Generally my perspective on running proc macros in a truly isolated context would be “don’t”, because I think it opens up a lot of additional cans of worms that make the cure questionably better than the disease</p>\n</blockquote>\n<p>Eh, once you have out of process you can choose to let the process have system access or run pure compute. It should be <em>an option</em>.</p>",
        "id": 261152843,
        "sender_full_name": "The 8472",
        "timestamp": 1636647108
    },
    {
        "content": "<p>I'm not interested in security btw</p>",
        "id": 261152852,
        "sender_full_name": "eddyb",
        "timestamp": 1636647117
    },
    {
        "content": "<p>there's a far bigger issue that sadly is less well-known because of the incidental impacts of rustc's design on querification</p>",
        "id": 261152926,
        "sender_full_name": "eddyb",
        "timestamp": 1636647140
    },
    {
        "content": "<p>I don’t think it should necessarily be an option because it makes various parts of the system enormously more difficult to design in a useful way</p>",
        "id": 261152949,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647156
    },
    {
        "content": "<p>pushing incremental recompilation into the front-end stopped before having to account for proc macros, for now</p>",
        "id": 261152951,
        "sender_full_name": "eddyb",
        "timestamp": 1636647158
    },
    {
        "content": "<p>but even if we managed to do it, proc macros cannot be treated like pure functions</p>",
        "id": 261153056,
        "sender_full_name": "eddyb",
        "timestamp": 1636647224
    },
    {
        "content": "<p>it’s theoretically possible to make proc macros cooperate with querification/incrementalization but it is not well-tread in any existing system I am aware of, so there’s no proven designs that I know about</p>",
        "id": 261153068,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647229
    },
    {
        "content": "<p>you don't need anything other than determinism for Salsa-like systems to be correct, that's the beauty of it</p>",
        "id": 261153152,
        "sender_full_name": "eddyb",
        "timestamp": 1636647263
    },
    {
        "content": "<p>Yeah, I am about to say that I am aware of existence of stateful proc macros.</p>",
        "id": 261153153,
        "sender_full_name": "Gary Guo",
        "timestamp": 1636647264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261152951\">said</a>:</p>\n<blockquote>\n<p>pushing incremental recompilation into the front-end stopped before having to account for proc macros, for now</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> is working on this btw :)</p>",
        "id": 261153186,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636647285
    },
    {
        "content": "<p>in particular on making HIR lowering incremental</p>",
        "id": 261153203,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636647297
    },
    {
        "content": "<p>stateful proc macros are often highly desirable, you’d just need to allow their state management to cooperate with dependency tracking to allow them to be incrementalized</p>",
        "id": 261153257,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647319
    },
    {
        "content": "<p>anyway, the only future I see for that kind of endeavor is running proc macros in WASM VMs (or miri but that's too slow), with an opt-in in <code>Cargo.toml</code></p>",
        "id": 261153264,
        "sender_full_name": "eddyb",
        "timestamp": 1636647325
    },
    {
        "content": "<p>/me really wants resolving to be incremental so he can stop thinking about <a href=\"https://github.com/rust-lang/rust/issues/83761\">https://github.com/rust-lang/rust/issues/83761</a></p>",
        "id": 261153277,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636647330
    },
    {
        "content": "<p>and just not incrementalizing stateful/IO-interacting stuff</p>",
        "id": 261153291,
        "sender_full_name": "eddyb",
        "timestamp": 1636647341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> if you can run it in a wasm VM why not in a sandbox/jail? That would be faster</p>",
        "id": 261153388,
        "sender_full_name": "The 8472",
        "timestamp": 1636647373
    },
    {
        "content": "<p>exposing statefulness to macros without compromising on separate compilation is part of the design in the “Composable and Compilable Macros” paper</p>",
        "id": 261153423,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647387
    },
    {
        "content": "<p>(you can still get the dependency-firewalling benefits if the proc macro <em>happens to</em> return the same tokens again, but that requires <em>running</em> the proc macro again. a deterministic proc macro doesn't have to be re-run if the inputs changed tho, that would be the diference)</p>",
        "id": 261153476,
        "sender_full_name": "eddyb",
        "timestamp": 1636647416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261153388\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> if you can run it in a wasm VM why not in a sandbox/jail? That would be faster</p>\n</blockquote>\n<p>global state</p>",
        "id": 261153505,
        "sender_full_name": "eddyb",
        "timestamp": 1636647429
    },
    {
        "content": "<p>there is no sandbox/jail that guarantees determinism</p>",
        "id": 261153519,
        "sender_full_name": "eddyb",
        "timestamp": 1636647440
    },
    {
        "content": "<p>from global state to weird microarchitectural nonsense</p>",
        "id": 261153538,
        "sender_full_name": "eddyb",
        "timestamp": 1636647447
    },
    {
        "content": "<p>it would have to be different in Rust, because Rust’s incrementalization is more sophisticated than traditional separate compilation, and it’s more aggressive in what it attempts to achieve, but Rust proc macros also generally do less, so I don’t see why it wouldn’t be possible</p>",
        "id": 261153539,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647448
    },
    {
        "content": "<blockquote>\n<p>Rust proc macros also generally do less</p>\n</blockquote>\n<p><em>cough</em> sqlx <em>cough</em></p>",
        "id": 261153595,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636647468
    },
    {
        "content": "<p>you cannot quantify what the non-deterministic fragment of a proc macro is without running it, basically</p>",
        "id": 261153685,
        "sender_full_name": "eddyb",
        "timestamp": 1636647492
    },
    {
        "content": "<p>I suppose the main danger here is that an incorrectly-written proc macro could make incremental compilation produce a different result from non-incremental compilation, which seems probably undesirable</p>",
        "id": 261153745,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647519
    },
    {
        "content": "<p>you can still avoid doing work <em>later</em> in the compilation, if most of its output hasn't changed, but you will always have to run proc macros that aren't limited by their execution environment in drastic ways</p>",
        "id": 261153770,
        "sender_full_name": "eddyb",
        "timestamp": 1636647533
    },
    {
        "content": "<p>anyway before I get even more distracted</p>",
        "id": 261153793,
        "sender_full_name": "eddyb",
        "timestamp": 1636647540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261152252\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261152153\">said</a>:</p>\n<blockquote>\n<p>additionally, it's 99% RPC, with the hope of eventually using helper processes to run proc macros in isolated separate processes</p>\n</blockquote>\n<p>hey, this is basically <code>watt</code> we were talking  about before<br>\n<span class=\"user-mention silent\" data-user-id=\"278740\">Anatol Ulrich</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261091883\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span>, tangentially (performance related) - have you seen <a href=\"https://github.com/dtolnay/watt\">watt</a>?<br>\n</p>\n</blockquote>\n</blockquote>\n<p><code>watt</code> is a mere proof of concept using the public API, IMO the correct course of action would be to pass the RPC communication into a wasm VM, but interest in a real implementation died down after the proof of concept, instead of accelerating</p>",
        "id": 261153814,
        "sender_full_name": "eddyb",
        "timestamp": 1636647555
    },
    {
        "content": "<p>real tragedy but developer bandwidth is limited :(</p>",
        "id": 261153839,
        "sender_full_name": "eddyb",
        "timestamp": 1636647571
    },
    {
        "content": "<p>fwiw, Racket provides a fairly strong guarantee known as the “separate compilation guarantee” that makes it impossible for macros to produce different results when modules are compiled together versus compiled separately, and that really does work in practice</p>",
        "id": 261153867,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647583
    },
    {
        "content": "<p>so it's the dime-a-dozen tragedy</p>",
        "id": 261153870,
        "sender_full_name": "eddyb",
        "timestamp": 1636647585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261153867\">said</a>:</p>\n<blockquote>\n<p>fwiw, Racket provides a fairly strong guarantee known as the “separate compilation guarantee” that makes it impossible for macros to produce different results when modules are compiled together versus compiled separately, and that really does work in practice</p>\n</blockquote>\n<p>that's a weird-at-a-glance property, I don't fully understand why that's useful or how</p>",
        "id": 261153959,
        "sender_full_name": "eddyb",
        "timestamp": 1636647615
    },
    {
        "content": "<p>it’s related to incrementalization in the sense that separate compilation is a weaker form of incrementalization</p>",
        "id": 261153991,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647639
    },
    {
        "content": "<p>it sounds sort of similar to orphan rules (\"crates that compile separately compile together\")</p>",
        "id": 261153994,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636647639
    },
    {
        "content": "<p>the Salsa approach is more like a build system's dependency DAG, except instead of commands, each step is some function in the compiler</p>",
        "id": 261154008,
        "sender_full_name": "eddyb",
        "timestamp": 1636647645
    },
    {
        "content": "<p>right, I know</p>",
        "id": 261154017,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647652
    },
    {
        "content": "<p>I’m just saying you could theoretically adapt that model to extend dependency tracking to macros in an incrementalized system</p>",
        "id": 261154066,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647685
    },
    {
        "content": "<p>but, like, the reason for wanting determinism has nothing to do with the separation</p>",
        "id": 261154071,
        "sender_full_name": "eddyb",
        "timestamp": 1636647686
    },
    {
        "content": "<p>it's to be able to treat the functions opaquely and not need something like ILC</p>",
        "id": 261154111,
        "sender_full_name": "eddyb",
        "timestamp": 1636647711
    },
    {
        "content": "<p>I’m saying you want to be able to write stateful proc macros, this is sometimes a useful thing to do</p>",
        "id": 261154180,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647729
    },
    {
        "content": "<p>is it a more declarative replacement for \"state\"?</p>",
        "id": 261154216,
        "sender_full_name": "eddyb",
        "timestamp": 1636647748
    },
    {
        "content": "<p>(ILC is <a href=\"https://github.com/dotnet/corert/blob/master/Documentation/botr/ilc-architecture.md\">https://github.com/dotnet/corert/blob/master/Documentation/botr/ilc-architecture.md</a> ?)</p>",
        "id": 261154219,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636647749
    },
    {
        "content": "<p>so in that context you need the state to be able to cooperate with the dependency-tracking framework</p>",
        "id": 261154225,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647752
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261154219\">said</a>:</p>\n<blockquote>\n<p>(ILC is <a href=\"https://github.com/dotnet/corert/blob/master/Documentation/botr/ilc-architecture.md\">https://github.com/dotnet/corert/blob/master/Documentation/botr/ilc-architecture.md</a> ?)</p>\n</blockquote>\n<p>no, Incremental Lambda Calculus</p>",
        "id": 261154245,
        "sender_full_name": "eddyb",
        "timestamp": 1636647764
    },
    {
        "content": "<p>still mostly academic AFAIK</p>",
        "id": 261154265,
        "sender_full_name": "eddyb",
        "timestamp": 1636647771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261154225\">said</a>:</p>\n<blockquote>\n<p>so in that context you need the state to be able to cooperate with the dependency-tracking framework</p>\n</blockquote>\n<p>okay but is IO impossible?</p>",
        "id": 261154309,
        "sender_full_name": "eddyb",
        "timestamp": 1636647794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261154216\">said</a>:</p>\n<blockquote>\n<p>is it a more declarative replacement for \"state\"?</p>\n</blockquote>\n<p>sort of, though not exactly… the main obstacle here is, indeed, that it depends upon the compiler being able to exert some control over the way global state is managed, whereas Rust compiles global state in a more traditional fashion</p>",
        "id": 261154319,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647799
    },
    {
        "content": "<p>we cannot really even instrument proc macros, they're too much like normal code. frankly they should've been some kind of interpreted <code>const fn</code> type thing all along but the proc macros we have were ready years before miri etc. etc.</p>",
        "id": 261154480,
        "sender_full_name": "eddyb",
        "timestamp": 1636647863
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261154309\">said</a>:</p>\n<blockquote>\n<p>okay but is IO impossible?</p>\n</blockquote>\n<p>no, there is a distinction between “internal” state and “external” state; if you write macros that do I/O and modify external state you are just hosed, and the general perspective is just “don’t do that”… obviously in a Haskell-like system you could actually enforce this, but without that it’s not really possible</p>",
        "id": 261154494,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647870
    },
    {
        "content": "<p>yeah, <code>const fn</code> is a notion of purity tracking</p>",
        "id": 261154557,
        "sender_full_name": "Alexis King",
        "timestamp": 1636647900
    },
    {
        "content": "<p>okay so basically what I'm saying is we currently have <em>no choice</em> but to expect that all proc macros do IO</p>",
        "id": 261154607,
        "sender_full_name": "eddyb",
        "timestamp": 1636647928
    },
    {
        "content": "<p>the only way to backwards-compatibly transition away from that is with an opt-in in <code>Cargo.toml</code>, and some kind of deterministic execution (wasm VM or miri)</p>",
        "id": 261154665,
        "sender_full_name": "eddyb",
        "timestamp": 1636647958
    },
    {
        "content": "<p>well, sure, but technically all proc macros <em>can</em> do I/O in Racket as well, but this isn’t really a problem in practice because Racket makes it possible to do things people want to do with macros without doing I/O… so I guess the question is how much you care about providing a strong guarantee versus just expecting programmers to not write bad things</p>",
        "id": 261154817,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648024
    },
    {
        "content": "<p>there's global state that's needed for various things to work, so one way those would work is the globals would reset for each proc macro. in wasm Web API terms, a new <code>Instance</code> would be created for every invocations</p>",
        "id": 261154828,
        "sender_full_name": "eddyb",
        "timestamp": 1636648027
    },
    {
        "content": "<p>we have to provide a strong guarantee IMO, and it's not up for discussion</p>",
        "id": 261154868,
        "sender_full_name": "eddyb",
        "timestamp": 1636648048
    },
    {
        "content": "<p>or IOW, you'd have to convince a lot more people than just me if you wanted something different than a strong guarantee</p>",
        "id": 261154894,
        "sender_full_name": "eddyb",
        "timestamp": 1636648066
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261154817\">said</a>:</p>\n<blockquote>\n<p>well, sure, but technically all proc macros <em>can</em> do I/O in Racket as well, but this isn’t really a problem in practice because Racket makes it possible to do things people want to do with macros without doing I/O… so I guess the question is how much you care about providing a strong guarantee versus just expecting programmers to not write bad things</p>\n</blockquote>\n<p>really please do go read up about sqlx</p>",
        "id": 261154897,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636648067
    },
    {
        "content": "<p>people are using it in prod and it does network io</p>",
        "id": 261154911,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636648073
    },
    {
        "content": "<p>it’s impossible to provide a guarantee like what you’re describing without disallowing I/O in proc macros</p>",
        "id": 261154919,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648075
    },
    {
        "content": "<p>even ignoring incrementalization</p>",
        "id": 261154933,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648082
    },
    {
        "content": "<p>because any proc macro that does I/O can just return different code on two successive from-scratch compilations</p>",
        "id": 261154994,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648099
    },
    {
        "content": "<p>that's precisely what I (and other people) want: an opt-in in <code>Cargo.toml</code> that results in full determinism</p>",
        "id": 261155005,
        "sender_full_name": "eddyb",
        "timestamp": 1636648107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261154911\">said</a>:</p>\n<blockquote>\n<p>people are using it in prod and it does network io</p>\n</blockquote>\n<p>and it's for a <em>reason</em>, because it provides guarantees that you can't get without actually talking to a live database</p>",
        "id": 261155025,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636648121
    },
    {
        "content": "<p>similar to <code>const fn</code> but it can be more relaxed thanks to e.g. wasm VMs</p>",
        "id": 261155028,
        "sender_full_name": "eddyb",
        "timestamp": 1636648122
    },
    {
        "content": "<p>how do you propose the determinism be enforced?</p>",
        "id": 261155045,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648132
    },
    {
        "content": "<p>run it in a wasm VM</p>",
        "id": 261155060,
        "sender_full_name": "eddyb",
        "timestamp": 1636648140
    },
    {
        "content": "<p>miri can also do this, and it's a more flexible solution in terms of how much we can abstract away from the code (e.g. we could treat the entire bridge as magical values not even <code>unsafe</code> code in the proc macro can manipulate)</p>",
        "id": 261155236,
        "sender_full_name": "eddyb",
        "timestamp": 1636648211
    },
    {
        "content": "<p>it's just that miri would be even slower</p>",
        "id": 261155246,
        "sender_full_name": "eddyb",
        "timestamp": 1636648217
    },
    {
        "content": "<p>okay, I think I understand your perspective now, yeah</p>",
        "id": 261155302,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648247
    },
    {
        "content": "<p>(miri is the basis for the determinism guarantee that is one of the pillars of Rust's typesystem soundness: if you can make consteval exhibit non-determinism, then inject the resulting incoherence into the typesystem via arrays or other const generics, you can break the typesystem and e.g. <code>transmute</code> in safe code)</p>",
        "id": 261155384,
        "sender_full_name": "eddyb",
        "timestamp": 1636648284
    },
    {
        "content": "<p>I think running proc macros in a VM is still kind of a bad set of compromises, though… you could get significantly better results by implementing a more relaxed <code>const fn</code>-like thing that disallows <code>unsafe</code> code and links against different versions of I/O operations that throw</p>",
        "id": 261155607,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648379
    },
    {
        "content": "<p>one thing to be wary of is that a wasm VM can in theory be less reliable than miri in the presence of float ops, so we'd have to be careful with those. the integer fragment should be fine tho</p>",
        "id": 261155707,
        "sender_full_name": "eddyb",
        "timestamp": 1636648431
    },
    {
        "content": "<p>I just don’t understand the appeal of running everything in wasm, honestly, it seems like creating a lot of new problems for relatively little concrete gain</p>",
        "id": 261155816,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648464
    },
    {
        "content": "<p>there are other ways to enforce determinism than running the entire thing in a VM</p>",
        "id": 261155931,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648530
    },
    {
        "content": "<p>the <code>const fn</code> thing would be much harder to get into an usable state (and you don't get all the benefits without running it in miri), whereas wasm is a mature technology at this point</p>",
        "id": 261155950,
        "sender_full_name": "eddyb",
        "timestamp": 1636648540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261155931\">said</a>:</p>\n<blockquote>\n<p>there are other ways to enforce determinism than running the entire thing in a VM</p>\n</blockquote>\n<p>yeah but I don't <em>trust</em> them</p>",
        "id": 261155969,
        "sender_full_name": "eddyb",
        "timestamp": 1636648551
    },
    {
        "content": "<p>okay, sure, it could make short-term implementation costs lower</p>",
        "id": 261155973,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648556
    },
    {
        "content": "<p>anyway this only makes sense with incremental: you want to do this when most of the time it lets you <em>skip</em> running the proc macro</p>",
        "id": 261156050,
        "sender_full_name": "eddyb",
        "timestamp": 1636648583
    },
    {
        "content": "<p>running code is bad and should be avoided as much as possible :P</p>",
        "id": 261156069,
        "sender_full_name": "eddyb",
        "timestamp": 1636648594
    },
    {
        "content": "<p>anyway, sorry for all the near-incoherent rambling - a lot of this stuff has been stewing for like over two years now, and I was taken by surprise by the ping, lol</p>",
        "id": 261156149,
        "sender_full_name": "eddyb",
        "timestamp": 1636648640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261155969\">said</a>:</p>\n<blockquote>\n<p>yeah but I don't <em>trust</em> them</p>\n</blockquote>\n<p>I think it’s bizarre to demand such an extreme level of trust for proc macros, because what is your threat model in which people could maliciously exploit execution of proc macros but not get malicious code linked into the compiled binary</p>",
        "id": 261156178,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261153186\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/why.20does.20proc_macro.3A.3Abridge.20exist.3F/near/261152951\">said</a>:</p>\n<blockquote>\n<p>pushing incremental recompilation into the front-end stopped before having to account for proc macros, for now</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> is working on this btw :)</p>\n</blockquote>\n<p>just remembered to reply to this: sorry, I meant more like \"drastically slowed down\" - and yeah, HIR lowering is where I'd expect the frontier to be</p>",
        "id": 261156344,
        "sender_full_name": "eddyb",
        "timestamp": 1636648731
    },
    {
        "content": "<p>I am sympathetic to “running what we have right now in wasm is less difficult to implement than any other strategy that provides the guarantees we want”</p>",
        "id": 261156379,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648755
    },
    {
        "content": "<p>But I think that would be a pretty poor long-term solution</p>",
        "id": 261156410,
        "sender_full_name": "Alexis King",
        "timestamp": 1636648772
    },
    {
        "content": "<p>it's less about security (so we can probably ignore very obscure ways to siphon non-determinism) and more about, well, stuff like this: <a href=\"https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+unstable+fingerprints\">https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+unstable+fingerprints</a></p>",
        "id": 261156635,
        "sender_full_name": "eddyb",
        "timestamp": 1636648914
    },
    {
        "content": "<p>(if not familiar, someone else can explain it, I gotta step up, my eyes hurt from staring at this Zulip window, lol)</p>",
        "id": 261156709,
        "sender_full_name": "eddyb",
        "timestamp": 1636648944
    },
    {
        "content": "<p>Yes, I understand, and I agree that it’s important to make it impossible to cause that sort of problem without explicitly going out of your way to break things</p>",
        "id": 261157016,
        "sender_full_name": "Alexis King",
        "timestamp": 1636649124
    },
    {
        "content": "<p>i.e. I don’t think you need such extreme sandboxing that you have complete confidence it will protect against malicious actors as a security measure, but I do think it’s helpful to be able to treat any way to subvert the restrictions as a bug (just not as a CVE)</p>",
        "id": 261157258,
        "sender_full_name": "Alexis King",
        "timestamp": 1636649235
    },
    {
        "content": "<p>After thinking about this a little more, a thought: if you’re compiling to wasm, then you have to recompile all proc macros’ dependencies to wasm as well, so you’re already compiling proc macro code in a separate way from other code. I think that’s probably undesirable (as it makes compile times even worse), but if you accept it, then it’s not actually any better than just recompiling all that code to the normal arch and replacing all uses of I/O or unsafe operations with panics, right?</p>",
        "id": 261165522,
        "sender_full_name": "Alexis King",
        "timestamp": 1636653207
    },
    {
        "content": "<p>Most dependencies used by proc macros are pretty much only used by proc macros (syn, quote, proc_macro2).</p>",
        "id": 261165636,
        "sender_full_name": "bjorn3",
        "timestamp": 1636653267
    },
    {
        "content": "<p>Yes, that makes sense… that doesn’t in any way affect my actual question here, though. ;)</p>",
        "id": 261165832,
        "sender_full_name": "Alexis King",
        "timestamp": 1636653385
    },
    {
        "content": "<p>Replacing all unsafe operations with panics is not really an option. Syn has multiple unsafe blocks: <a href=\"https://github.com/dtolnay/syn/search?q=unsafe\">https://github.com/dtolnay/syn/search?q=unsafe</a></p>",
        "id": 261166086,
        "sender_full_name": "bjorn3",
        "timestamp": 1636653553
    },
    {
        "content": "<p>(Part of the search results are false-positives for parsing unsafe blocks)</p>",
        "id": 261166133,
        "sender_full_name": "bjorn3",
        "timestamp": 1636653584
    },
    {
        "content": "<p>Well, okay, I guess what I really mean is replacing whatever subset of operations that wasm disallows with panics. The point being simply that you can get the same determinism guarantees you get from wasm without using wasm by just doing what the wasm implementation of those things does.</p>",
        "id": 261166340,
        "sender_full_name": "Alexis King",
        "timestamp": 1636653663
    },
    {
        "content": "<p>And it isn’t immediately clear to me why doing that when compiling to the native target would be meaningfully more difficult than doing it when compiling to wasm. But maybe there’s something subtle I don’t understand!</p>",
        "id": 261166484,
        "sender_full_name": "Alexis King",
        "timestamp": 1636653740
    },
    {
        "content": "<p>When compiling for a native target, the entire address space is accessible, allowing trivial escape from the sandbox. With wasm all memory accesses are constrained to a \"linear memory\" that covers only a specified part of the entire address space. By placing this \"linear memory\" such that it doesn't overlap with any memory used by rustc or libc, you have done most of the work of sandboxing.</p>",
        "id": 261166724,
        "sender_full_name": "bjorn3",
        "timestamp": 1636653883
    },
    {
        "content": "<p>Sure, but I think (correct me if I’m wrong) that <span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> and I are in agreement that security isn’t the goal here, so code that goes meaningfully out of its way to do intentional/malicious sandbox escape isn’t really what we’re trying to prevent.</p>",
        "id": 261166901,
        "sender_full_name": "Alexis King",
        "timestamp": 1636653992
    },
    {
        "content": "<p>If you want to protect against accidental sandbox escape, you will have to consider that a proc macro can use a C library, which may make arbitrary calls that you can't easily interpose.</p>",
        "id": 261167084,
        "sender_full_name": "bjorn3",
        "timestamp": 1636654110
    },
    {
        "content": "<p>Right, an FFI call is exactly the sort of thing that you’d want to disallow/replace with a panic.</p>",
        "id": 261167185,
        "sender_full_name": "Alexis King",
        "timestamp": 1636654175
    },
    {
        "content": "<p>What about say a proc macro that compresses a blob? At least one of the widely used compression/decompression crates uses a C library I believe.</p>",
        "id": 261167307,
        "sender_full_name": "bjorn3",
        "timestamp": 1636654230
    },
    {
        "content": "<p>Sure, that’s a totally valid complaint about this strategy, but that wouldn’t run in wasm, either, and all I’m saying is that this strategy seems no worse than compiling everything to wasm.</p>",
        "id": 261167400,
        "sender_full_name": "Alexis King",
        "timestamp": 1636654294
    },
    {
        "content": "<p>It can. Clang supports compiling C to wasm. I am not sure if the build script of this compression crate has the necessary setup for compiling it to wasm though.</p>",
        "id": 261167552,
        "sender_full_name": "bjorn3",
        "timestamp": 1636654370
    },
    {
        "content": "<p>WASM has another benefit of crates being able to ship wasm bytecode for proc macros rather than rust code that needs to be compiled (=&gt; faster builds)</p>",
        "id": 261167585,
        "sender_full_name": "nagisa",
        "timestamp": 1636654391
    },
    {
        "content": "<p>Well, I mean, if all proc macros are <em>transparently</em> compiled to wasm, presumably people would not generally be manually shipping the wasm blobs themselves, by hand, and would not be able to just ship a wasm-compiled C library alongside it. But I guess I concede the point about it being theoretically possible to do so.</p>",
        "id": 261167724,
        "sender_full_name": "Alexis King",
        "timestamp": 1636654471
    },
    {
        "content": "<p>I suppose one additional question is: how do <code>build.rs</code> scripts fit into this? Don’t they have all the same problems? Under this plan, do they get wasmized, too?</p>",
        "id": 261172228,
        "sender_full_name": "Alexis King",
        "timestamp": 1636657173
    },
    {
        "content": "<p><code>build.rs</code> is terrible horrible thing, yes, but it doesn't really impact cargo workflows all that much.</p>",
        "id": 261173401,
        "sender_full_name": "nagisa",
        "timestamp": 1636657809
    },
    {
        "content": "<p>How does it impact them meaningfully less than proc macros do?</p>",
        "id": 261173505,
        "sender_full_name": "Alexis King",
        "timestamp": 1636657896
    },
    {
        "content": "<p>I guess just because they’re usually used to build separate things that aren’t in any way related to rustc’s dependency tracking?</p>",
        "id": 261173672,
        "sender_full_name": "Alexis King",
        "timestamp": 1636657992
    },
    {
        "content": "<p><code>build.rs</code> scripts' behaviour only influence a decision of whether <code>rustc</code> needs to be invoked again to build the crate or not, but within rustc and for the purposes of incremental <code>build.rs</code> is not a thing that exists at all.</p>",
        "id": 261173699,
        "sender_full_name": "nagisa",
        "timestamp": 1636658007
    },
    {
        "content": "<p>its entirely a cargo concept.</p>",
        "id": 261173709,
        "sender_full_name": "nagisa",
        "timestamp": 1636658013
    },
    {
        "content": "<p>The reason it is horrible and terrible is because a) it makes it hard for alternative build systems that rely on reproducibility; b) build scripts tend to do nasty stuff as downloading binaries off the internet or invoking other arbitrary executables.</p>",
        "id": 261173835,
        "sender_full_name": "nagisa",
        "timestamp": 1636658064
    },
    {
        "content": "<p>For that purpose I do believe that a wasm with a well thought out runtime exposed to the scripts would help, even if just slightly.</p>",
        "id": 261173943,
        "sender_full_name": "nagisa",
        "timestamp": 1636658130
    },
    {
        "content": "<p>But replacing typical use-cases <a href=\"http://build.rs\">build.rs</a> are being used for could be done other ways too, more declaratively.</p>",
        "id": 261174030,
        "sender_full_name": "nagisa",
        "timestamp": 1636658165
    },
    {
        "content": "<p><a href=\"https://docs.rs/metadeps/1.1.2/metadeps/\">https://docs.rs/metadeps/1.1.2/metadeps/</a> is one such example.</p>",
        "id": 261174529,
        "sender_full_name": "nagisa",
        "timestamp": 1636658431
    },
    {
        "content": "<p>I'm not sure if it was mentioned, but another reason for wanting out-of-process proc macros is for symbol isolation. Right now things go badly if you want a proc macro that uses its own LLVM, or even libstdc++ differences (since dist-x86_64-linux links that statically)</p>",
        "id": 261187003,
        "sender_full_name": "cuviper",
        "timestamp": 1636666526
    },
    {
        "content": "<p>e.g. <a href=\"https://github.com/rust-lang/rust/issues/76980\">https://github.com/rust-lang/rust/issues/76980</a></p>",
        "id": 261187129,
        "sender_full_name": "cuviper",
        "timestamp": 1636666618
    },
    {
        "content": "<p>which might be mostly solved in that case, but I think the problem still looms in general</p>",
        "id": 261187148,
        "sender_full_name": "cuviper",
        "timestamp": 1636666640
    }
]