[
    {
        "content": "<p>Would there be any interest in supporting a VFS/overlay fs in rustc directly? One rationale was to execute <code>cargo check</code> but with in-memory text buffers rather than the files on disk itself. This led to reimplementation of own wrappers VFS in RLS and Rust Analyzer; if we support that directly we could drop the extra code on each side and execute rustc directly.</p>\n<p>This would simplify one of the approaches mentioned in the rls/rust-analyzer planning meeting today, where we integrate <code>cargo check</code> directly to provide accurate errors in addition to quick IDE features by Rust Analyzer.<br>\nIt also would technically allow us to decouple RLS completely from rustc if we were to reuse the existing save-analysis architecture.</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> (did I miss anyone?)<br>\n<span class=\"user-mention\" data-user-id=\"213049\">@Jeremy Fitzhardinge</span> <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> would that be also useful in any scenario involving external build integration?</p>",
        "id": 176148821,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568932923
    },
    {
        "content": "<p>Issue at <a href=\"https://github.com/rust-lang/rust/issues/59976\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/59976\">https://github.com/rust-lang/rust/issues/59976</a></p>",
        "id": 176148830,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568932936
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> Could you expand on \"While it's possible to provide a FileLoader trait implementation when running rustc, it requires the user to run the compiler in-process.\"?</p>",
        "id": 176149216,
        "sender_full_name": "simulacrum",
        "timestamp": 1568933295
    },
    {
        "content": "<p>Why does it need to be run in-process?</p>",
        "id": 176149221,
        "sender_full_name": "simulacrum",
        "timestamp": 1568933302
    },
    {
        "content": "<p>I guess \" This particular case could be side-stepped by implementing IPC for our VFS implementation that could be relayed to using our FileLoader trait and rustc shim (rls-rustc).\" is the alternative to that? Though I'd imagine shared memory would work as well since presumably there's already some notion of locks</p>",
        "id": 176149281,
        "sender_full_name": "simulacrum",
        "timestamp": 1568933392
    },
    {
        "content": "<p>I personally feel though that this is pretty strongly out of scope for a rustc feature and it's not entirely clear to me why it can't be implemented outside and loaded in as a FileLoader impl -- maybe we can redesign FileLoader to make that more possible?</p>",
        "id": 176149341,
        "sender_full_name": "simulacrum",
        "timestamp": 1568933451
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> by in-process I meant that the trait is inherently on the rustc side and if someone wishes to use it then they have to opt into <code>rustc_private</code> anyway and wrap that around</p>",
        "id": 176150747,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935064
    },
    {
        "content": "<p>shared memory or IPC works good but requires authoring a separate wrapper</p>",
        "id": 176150799,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935091
    },
    {
        "content": "<p>hm, yes, but presumably that's not a problem for RLS etc?</p>",
        "id": 176150810,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935111
    },
    {
        "content": "<p>I was wondering if it'd be possible to support something like a pathfile supplied to rustc which it'd use and fallback to the real disk file if not found in the patch</p>",
        "id": 176150822,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935127
    },
    {
        "content": "<p>well no, it's not a problem per-se for RLS, we use the shim ourselves as of now</p>",
        "id": 176150859,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935168
    },
    {
        "content": "<p>but I imagine Rust Analyzer can't use it since they want to support stable toolchain entirely</p>",
        "id": 176150870,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935181
    },
    {
        "content": "<p>so the status quo remains that Rust Analyzer can only provide correct diagnostics if the files are saved</p>",
        "id": 176150933,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935207
    },
    {
        "content": "<p>I would be not entirely opposed to the idea of trying to factor out the FileLoader trait into a crate that compiles on stable</p>",
        "id": 176150940,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935226
    },
    {
        "content": "<p>and also RLS needs to ship its own version of the compiler, whereas I imagine it'd be good to imagine a way to just point it at the Rust toolchain (with minimum version of XYZ) and expect things to work</p>",
        "id": 176150956,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935242
    },
    {
        "content": "<p>(obviously, we might need to issue breaking changes and coordinate updates, etc. -- but that all seems viable)</p>",
        "id": 176150961,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935246
    },
    {
        "content": "<p>but given how platform-specific I imagine an virtual file system is, I'd rather not manage it ourselves</p>",
        "id": 176150992,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935285
    },
    {
        "content": "<p>unless I'm wrong about it being platform specific?</p>",
        "id": 176150997,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935293
    },
    {
        "content": "<p>the only bits I imagine can be quite hard are canonical version of the paths</p>",
        "id": 176151010,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935314
    },
    {
        "content": "<p>FileLoader already has <code>abs_path</code> - it could be a function to transform all the paths given in a pathfile and always resolve files around these</p>",
        "id": 176151099,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935400
    },
    {
        "content": "<p>other than that, we need to be able to load a <code>String</code> under a given path in rustc and not much else, thankfully</p>",
        "id": 176151123,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568935434
    },
    {
        "content": "<p>hm, so then this might be easier than I expected</p>",
        "id": 176151388,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935729
    },
    {
        "content": "<p>if this is just \"I want to make rustc load paths with root X instead of <code>/</code>\" then that seems viable to implement as an unstable (and maybe on the road to stabilization) flag</p>",
        "id": 176151403,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935765
    },
    {
        "content": "<p>Is it that simple, or am I missing something?</p>",
        "id": 176151408,
        "sender_full_name": "simulacrum",
        "timestamp": 1568935774
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> it's more of a \"hey rustc, when compiling as you do normally, please consider file \"src/some/module.rs\" to have contents of \"XYZ\" instead of the actual one on the disk, thanks\"</p>",
        "id": 176151877,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936179
    },
    {
        "content": "<p>I mean, technically you could do that if for every compilation you create a tempdir, copy everything over  and only patch the relevant bits yourself but that's seems very unpractical somehow</p>",
        "id": 176151919,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936240
    },
    {
        "content": "<p>hm, how would you expect to provide the contents?</p>",
        "id": 176151941,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936275
    },
    {
        "content": "<p>Passing them as a flag doesn't seem viable :)</p>",
        "id": 176151982,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936284
    },
    {
        "content": "<p>and might break some relative path \"upwards\" (some code may depend on the cargo OUT_DIR, so you'd need to analyze the project layout and so on, not pretty)</p>",
        "id": 176151986,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936286
    },
    {
        "content": "<p>I guess the simplest would be to pass it a path to a patchfile which would contain only the patched bits?</p>",
        "id": 176152003,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936318
    },
    {
        "content": "<p>JSON comes to mind, obviously</p>",
        "id": 176152011,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936329
    },
    {
        "content": "<p>and it'd probably be good not to use the actual diffs because then rustc would need to know how to apply them, be careful for the files not to change while it compiles and so on</p>",
        "id": 176152051,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936374
    },
    {
        "content": "<p>I guess to me it seems like this is a pretty hard thing to implement in a sort of decoupled way</p>",
        "id": 176152067,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936400
    },
    {
        "content": "<p>which makes it a poor candidate for stability in general</p>",
        "id": 176152112,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936409
    },
    {
        "content": "<p>(since it seems like it'd be somewhat prone to wanting to change)</p>",
        "id": 176152126,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936424
    },
    {
        "content": "<p>I know, it is =( it sort of just promotes FileLoader to CLI</p>",
        "id": 176152129,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936425
    },
    {
        "content": "<p>yeah, that seems.. not great</p>",
        "id": 176152138,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936434
    },
    {
        "content": "<p>(which is kind of what we want, not sure about alternatives that don't require to ship/wrap rustc themselves)</p>",
        "id": 176152152,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936454
    },
    {
        "content": "<p>hm, so maybe one alternative would be to run some binary on each file load?</p>",
        "id": 176152164,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936465
    },
    {
        "content": "<p>basically like the \"default\" is <code>cat</code></p>",
        "id": 176152170,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936476
    },
    {
        "content": "<p>like a 'proc macro' but for loaded files?</p>",
        "id": 176152176,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936489
    },
    {
        "content": "<p>well, I was thinking more .. just a binary</p>",
        "id": 176152185,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936499
    },
    {
        "content": "<p>like, not a shared object or anything</p>",
        "id": 176152189,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936506
    },
    {
        "content": "<p>okay</p>",
        "id": 176152191,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936510
    },
    {
        "content": "<p>is that too high overhead?</p>",
        "id": 176152195,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936516
    },
    {
        "content": "<p>hm</p>",
        "id": 176152198,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936519
    },
    {
        "content": "<p>not sure, haven't measured</p>",
        "id": 176152236,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936524
    },
    {
        "content": "<p>you'd have to spawn a process for every read file</p>",
        "id": 176152242,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936532
    },
    {
        "content": "<p>sure, yeah -- well, you could imagine some structure where e.g. we ban null bytes or something and can pass more than one</p>",
        "id": 176152248,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936548
    },
    {
        "content": "<p>(or just full JSON RPC, but I'd rather not)</p>",
        "id": 176152253,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936562
    },
    {
        "content": "<p>that seems extensible</p>",
        "id": 176152255,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936564
    },
    {
        "content": "<p>like a file pre-processor</p>",
        "id": 176152261,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936577
    },
    {
        "content": "<p>yeah, we could even do something like \"rustc will run <code>$cmd --format-version=1 $filepath</code>\"</p>",
        "id": 176152275,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936593
    },
    {
        "content": "<p>D: just imagined a QT moc-style preprocessing</p>",
        "id": 176152287,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936615
    },
    {
        "content": "<p>I don't know anything about that :)</p>",
        "id": 176152297,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936634
    },
    {
        "content": "<p>that seems... too? powerful</p>",
        "id": 176152337,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936645
    },
    {
        "content": "<p>it's extensible but I'm not sure if someone would abuse it anyhow?</p>",
        "id": 176152346,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936657
    },
    {
        "content": "<p>maybe I'm going in a wrong direction, sorry about that</p>",
        "id": 176152355,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936696
    },
    {
        "content": "<p>it seems powerful and would solve this use-case, yeah</p>",
        "id": 176152372,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936710
    },
    {
        "content": "<p>heh, no worries -- I personally would imagine this to be pretty high overhead though</p>",
        "id": 176152375,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936714
    },
    {
        "content": "<p>largely though I don't see any other way for us to accept the file contents</p>",
        "id": 176152440,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936773
    },
    {
        "content": "<p>like, if we're to do it on stable we want some pretty straightforward way to do so</p>",
        "id": 176152448,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936794
    },
    {
        "content": "<p>on the 'too powerful' note, one could even call a C preprocessor on top of each file</p>",
        "id": 176152462,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936829
    },
    {
        "content": "<p>which is interesting</p>",
        "id": 176152467,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936849
    },
    {
        "content": "<p>you're not wrong, but that seems like \"okay, sure\" - you could do the same with a proc macro today</p>",
        "id": 176152471,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936851
    },
    {
        "content": "<p>#![foo] atop the crate or module and replace all the tokens</p>",
        "id": 176152478,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936866
    },
    {
        "content": "<p>that is true</p>",
        "id": 176152486,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936881
    },
    {
        "content": "<p>somewhat more limited because input must tokenize as Rust I believe, but that's pretty flexible</p>",
        "id": 176152527,
        "sender_full_name": "simulacrum",
        "timestamp": 1568936888
    },
    {
        "content": "<p>well, that'd be one way to do it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I'm wondering what would be the performance overhead of that, though</p>",
        "id": 176152563,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568936992
    },
    {
        "content": "<p>in theory one can do this today, right? Like, y'all already wrap rustc so trialing this wouldn't be too hard</p>",
        "id": 176152698,
        "sender_full_name": "simulacrum",
        "timestamp": 1568937159
    },
    {
        "content": "<p>Yup</p>",
        "id": 176153690,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568938301
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> got any thoughts on that?</p>",
        "id": 176153700,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568938316
    },
    {
        "content": "<p>(mostly to see if this is at all viable, and then if it is, we can probably land it as unstable pretty easily; it might need an RFC to be stabilized though -- not sure if an FCP is enough there. It might be)</p>",
        "id": 176153752,
        "sender_full_name": "simulacrum",
        "timestamp": 1568938351
    },
    {
        "content": "<p>Hello!</p>\n<p>So, I think there are two threads here:</p>\n<ul>\n<li>we can extract VFS into a library and share it between rustc, rust-analyzer and rls</li>\n<li>we should add ability to rustc to read files not from disk</li>\n</ul>\n<p>I am very skeptical of the first one: looks like <code>FileLoader</code> is exactly what <code>rustc</code> currently needs, and it's only a trait. I don't see a benefit of moving it outside. rust-analyzer and rls need something different, and that hopefully can be shared, irrespective of rustc, but design space there is large. I am not to happy about current VFS implementations neither in rls, nor in rust-analyzer. I have a rough plan for better VFS for rust-analyzer, if it works, the result should be sharable between rls and rust-analyzer.</p>\n<p>I would like to see the second one, as it allows us to run <code>cargo check</code> without saving files to disk. The most important question here is stability. As this is intended to help IDEs, it's important that it works on stable, but it also should be an internal interface that no one should use. Can we have <code>#[doc(hidden)]</code> flags for rustc? I think we can: for one, <code>RUST_BOOTSTRAP</code> is one, and it is a much greater stabilization hazard than the proposed. If there's a constraint that we want to design this feature such that it is stable for realz, I think that maybe it's not worth it: the IDE can just save files before calling <code>cargo check</code> or the like. IntelliJ <a href=\"https://github.com/intellij-rust/intellij-rust/blob/93904a39c0f28fc9b250b2fda0700c62e3297e0c/src/main/kotlin/org/rust/ide/annotator/RsExternalLinterUtils.kt#L99\" target=\"_blank\" title=\"https://github.com/intellij-rust/intellij-rust/blob/93904a39c0f28fc9b250b2fda0700c62e3297e0c/src/main/kotlin/org/rust/ide/annotator/RsExternalLinterUtils.kt#L99\">does this</a>.</p>\n<p>I am not sure what is the right interface for IPC-ish vfs inside rustc. I don't like idea of passing a map of modified files as a json flag, as it might be hard to figure out which of modified files are relevant to rustc (that is, how IDE should figured out that there's no need to pass <code>.cpp</code> files)? I don't like the idea of shelling out to new external process to read every file, as it suffers from the opposite problem: most files are just fine as they are on disk, so this creates needless overhead. </p>\n<p>I'd love a pipe-based IPC: basically, we pass <code>VFS_FILE_DESCRIPTOR=92</code> env var, and then we shuffle something stupid like bincode or newline separate JSON over it. Not sure how cross-platform pipes are. Not sure how this should work with concurrent rustc invocations.</p>",
        "id": 176169416,
        "sender_full_name": "matklad",
        "timestamp": 1568962388
    },
    {
        "content": "<p>Apparently, IntelliJ would also be interested in this, so cc <span class=\"user-mention\" data-user-id=\"200750\">@Vlad</span>  :-) This makes my ideas of \"stable, do not use this\" interface more questionable, but I still think that it would be good to phrase this as: this API is doc-hidden, only selected set of tools (rust-analyzer, RLS, IntelliJ) are allowed to use it, API can break between releases of the compiler.</p>",
        "id": 176169776,
        "sender_full_name": "matklad",
        "timestamp": 1568962922
    },
    {
        "content": "<p>for the record I meant to tackle the second of the point you listed here =)</p>",
        "id": 176170446,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1568963891
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> I would personally object pretty strongly to what I think you're suggesting - stabilizing something \"just for IDEs\" doesn't seem viable to me, even if it is done via a env variable or so. I would definitely want that to go through RFC process to elaborate why we think it's okay to break the IDE use case but not others (if I'm understanding you correctly that we'd allow use in stable, but still reserve the right to break it)</p>",
        "id": 176182208,
        "sender_full_name": "simulacrum",
        "timestamp": 1568976747
    },
    {
        "content": "<p>Agree that it should go via RFC process, as its a departure from stability guarantees. The short reason why I think is ok is that IDEs have to track unstable features and compiler versions anyway (as std uses unstable), and that I don't see any other important consumers of this feature.</p>",
        "id": 176182422,
        "sender_full_name": "matklad",
        "timestamp": 1568976969
    },
    {
        "content": "<p>(to give a concrete example, changing sysroot crate graph definitely breaks IntelliJ, because it manually tracks deps between sysroot crates)</p>",
        "id": 176182567,
        "sender_full_name": "matklad",
        "timestamp": 1568977104
    },
    {
        "content": "<p>I tend to think it may also be viable to have a function that is avaiable \"on stable\" but documented as being exempted from the standard stability guarantees (and suitably hidden, etc)</p>",
        "id": 176659098,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505672
    },
    {
        "content": "<p>hm, sure, but I think that probably doesn't buy us much? I presume RLS etc want actual stability :)</p>",
        "id": 176659236,
        "sender_full_name": "simulacrum",
        "timestamp": 1569505750
    },
    {
        "content": "<p>why?</p>",
        "id": 176659253,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505763
    },
    {
        "content": "<p>we issue an RLS version per rustc release, right?</p>",
        "id": 176659267,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505774
    },
    {
        "content": "<p>I imagine anyway it would be documented as \"this may be changed betwen rust releases, but we make an effort to coordinate with known users\" and the expectation would be that it's \"mostly stable\"</p>",
        "id": 176659291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505801
    },
    {
        "content": "<p>anyway, i'm not sure if that's a good idea, but I think that for tools integration we may want to consider things like that</p>",
        "id": 176659346,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505815
    },
    {
        "content": "<p>hm, maybe RLS is not a good example -- since we do build that in tree. But I think <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> was saying that e.g. rust-analyzer wants to compile on arbitrary stable/nightly etc</p>",
        "id": 176659351,
        "sender_full_name": "simulacrum",
        "timestamp": 1569505819
    },
    {
        "content": "<p>yeah, it would mean the rust-analyzer has to be used with a \"matched\" version of rust</p>",
        "id": 176659376,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505845
    },
    {
        "content": "<p>(though it could be <em>built</em> with any, sounds like?)</p>",
        "id": 176659399,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505867
    },
    {
        "content": "<p>I thought that was what <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> was requesting, but maybe I misunderstood</p>",
        "id": 176659412,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569505877
    },
    {
        "content": "<p>I understood as \"used\" -- unless the function is like extern \"C\" or something we can't really support the 'build but not used' due to ABI differences, right?</p>",
        "id": 176659481,
        "sender_full_name": "simulacrum",
        "timestamp": 1569505924
    },
    {
        "content": "<p>true</p>",
        "id": 176660100,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569506407
    },
    {
        "content": "<p>anyway it does seem \"icky\"</p>",
        "id": 176660122,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569506417
    },
    {
        "content": "<p>butI thought maybe matklad was referring to some IPC-based sol'n?</p>",
        "id": 176660137,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569506428
    },
    {
        "content": "<p>tbh I didn't read all the details :)</p>",
        "id": 176660157,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569506444
    },
    {
        "content": "<p>/me too many messages right now</p>",
        "id": 176660163,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569506448
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> rust-analyzer does not link to rustc, by design, so ABI is completely irrelevant. That is, rust-analyzer is just a vanilla binary crate, which builds on the latest stable, and I prefer to keep it so for forseable future. </p>\n<p>\"what compiler/cargo can you use <em>together</em> with rust-analyzer, for developing your code?\" is another question. The current policy  is roughtly \"any compiler older that X\", where X is some constant that exists, is strictly grater than 1.0.0, but whose precise value is unknown to me. That is, we just assume that certain Cargo flags exists (most notably, <code>cargo metadata</code> which introduce somewhere around 1.10-ish). We definitely do not make a promise to work with arbitrary old rustc</p>",
        "id": 176664254,
        "sender_full_name": "matklad",
        "timestamp": 1569509253
    },
    {
        "content": "<p>I was responding to Niko's proposal of a function (which then means ABI)</p>",
        "id": 176664353,
        "sender_full_name": "simulacrum",
        "timestamp": 1569509298
    },
    {
        "content": "<p>Ah, yeah, I got confused, that's definitelly IPC we need, and not a function.</p>",
        "id": 176664487,
        "sender_full_name": "matklad",
        "timestamp": 1569509389
    },
    {
        "content": "<blockquote>\n<p>I was responding to Niko's proposal of a function (which then means ABI)</p>\n</blockquote>\n<p>really I meant IPC anyway :)</p>",
        "id": 176665266,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569509823
    },
    {
        "content": "<p>what I meant is: we can offer some interface and say \"this interface exists, but the data that passes through it is unstable\"</p>",
        "id": 176665286,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569509835
    },
    {
        "content": "<p>we've done that before...</p>",
        "id": 176665289,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569509838
    },
    {
        "content": "<p>...it seems better if it's IPC than the set of arguments etc on a fn, but it's the same principle isn't it?</p>",
        "id": 176665313,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569509857
    },
    {
        "content": "<p>Yes, I think that's true. We can definitely do that -- I was uncertain how helpful that'd be to RLA folks though.</p>",
        "id": 176665314,
        "sender_full_name": "simulacrum",
        "timestamp": 1569509859
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 176665636,
        "sender_full_name": "eddyb",
        "timestamp": 1569510015
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 176665691,
        "sender_full_name": "eddyb",
        "timestamp": 1569510059
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 176665726,
        "sender_full_name": "eddyb",
        "timestamp": 1569510084
    },
    {
        "content": "<p>oops I failed basic reading comprehension upthread</p>",
        "id": 176665942,
        "sender_full_name": "eddyb",
        "timestamp": 1569510201
    },
    {
        "content": "<p>I think it would be helpful yeah, for both rust-analyzer and maybe IntelliJ Rust, exactly because they explicitly track \"several recent stables\".</p>",
        "id": 176666148,
        "sender_full_name": "matklad",
        "timestamp": 1569510353
    },
    {
        "content": "<p>Specifically, this is the range of rusts that is guaranteed to work with IntelliJ: <a href=\"https://github.com/intellij-rust/intellij-rust/blob/06c94f051859492ceacc1e4b32a8125da112fddb/.travis.yml#L13-L15\" target=\"_blank\" title=\"https://github.com/intellij-rust/intellij-rust/blob/06c94f051859492ceacc1e4b32a8125da112fddb/.travis.yml#L13-L15\">https://github.com/intellij-rust/intellij-rust/blob/06c94f051859492ceacc1e4b32a8125da112fddb/.travis.yml#L13-L15</a></p>",
        "id": 176666220,
        "sender_full_name": "matklad",
        "timestamp": 1569510379
    },
    {
        "content": "<p>(and ide authors are ok with implementing version checks on their side, so breaking iface abruptly between two versions is also ok)</p>",
        "id": 176666324,
        "sender_full_name": "matklad",
        "timestamp": 1569510470
    },
    {
        "content": "<blockquote>\n<p>I don't like idea of passing a map of modified files as a json flag, as it might be hard to figure out which of modified files are relevant to rustc (that is, how IDE should figured out that there's no need to pass .cpp files)? </p>\n</blockquote>\n<p>Actually, a nice middle ground here could be to pass a list of potentially modified path <em>prefixes</em>. Passing <code>/</code> would cause <code>rustc</code> to query every for file, passing <code>/path/to/my-project</code> would cause it to ask for files in your project, but not in the <a href=\"http://crates.io\" target=\"_blank\" title=\"http://crates.io\">crates.io</a>. That gets rid of a nasty edge case where you have a huge number of modified files, but rustc is going to read only a dozen of them, as you probably can compress that huge number to one common prefix</p>",
        "id": 176667478,
        "sender_full_name": "matklad",
        "timestamp": 1569511253
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> I'm not sure I understand - I proposed the (made up) <code>--modified-files JSON</code> as an alternative to IPC-based solution</p>",
        "id": 177058314,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569938894
    },
    {
        "content": "<p>In general, the modified fileset will only be as big as the set of files you have currently modified-but-not-saved in the editor.</p>\n<p>I don't expect it to be too big to make a difference; the only scenario I can see that is when a user treats VS Code (or any IDE) like an OS and has opened multiple workspaces at once and thus potentially also has multiple big, modified files.</p>\n<p>Even then, I guess we could kind of only store patches, which I believe would solve the file size case but might introduce more cost/complexity at the IDE/rustc side to calculate/apply the patches</p>",
        "id": 177058547,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569939020
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"153740\">@Igor Matuszewski</span> i am slightly suspicious of the assumption that \"the set of modified files is small\". I believe that it's true in at least 99% of cases, but it would be cool if the solution didn't fundamentally depend on this.  For something like IntelliJ, the set of <em>dirty</em> files might be pretty large I think.  But I am ready to admit that this might be over-engineering :) </p>\n<p>To solve this \"perfectly\", I think we need to things:</p>\n<ul>\n<li>compiler should pull the relevant files from the client (so that the client doens't have to construct the whole set of modifed files upfront)</li>\n<li>but it should also avoid pulling most of the files, if they are known to be fresh on disk. </li>\n</ul>\n<p>Hence my idea about communicating the set of paths to the compiler which it <em>might</em> need to pull from the client.</p>",
        "id": 177065203,
        "sender_full_name": "matklad",
        "timestamp": 1569943037
    },
    {
        "content": "<p>Oh, so it's an optimization of the IPC case rather than of the \"overlayfs\" approach, I see</p>",
        "id": 177089204,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569958067
    },
    {
        "content": "<p>it definitely makes  sense in that case</p>",
        "id": 177089282,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569958102
    },
    {
        "content": "<p>in that specific case you might as well send a list of the modified files a priori rather than a specific prefix</p>",
        "id": 177089308,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569958125
    },
    {
        "content": "<p>since sending prefix only isn't as fine-grained and if someone's concerned with the combined length of the modified files' paths then it's possible you should be concerned with different problems... <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>",
        "id": 177089498,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569958225
    },
    {
        "content": "<p>however that still requires agreeing to a stable-ish IPC mechanism which still requires some plumbing on the client/server side</p>",
        "id": 177089578,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569958292
    },
    {
        "content": "<p>okay this is steering into a bit of a madman territory but what if we combine both of the approaches and allow a bit of flexibility:<br>\nWe could allow (in TS):</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"nx\">type</span> <span class=\"nx\">Fileset</span> <span class=\"o\">=</span> <span class=\"nb\">Array</span><span class=\"o\">&lt;</span><span class=\"p\">{</span> <span class=\"nx\">file</span>: <span class=\"kt\">string</span><span class=\"p\">;</span> <span class=\"nx\">contents</span>: <span class=\"kt\">Contents</span> <span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"nx\">type</span> <span class=\"nx\">Contents</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"nx\">kind</span><span class=\"o\">:</span> <span class=\"s1\">&#39;text&#39;</span><span class=\"p\">;</span> <span class=\"nx\">value</span>: <span class=\"kt\">string</span><span class=\"p\">;</span> <span class=\"p\">}</span> <span class=\"o\">|</span> <span class=\"p\">{</span> <span class=\"nx\">kind</span><span class=\"o\">:</span> <span class=\"s1\">&#39;command&#39;</span><span class=\"p\">;</span> <span class=\"nx\">value</span>: <span class=\"kt\">Command</span><span class=\"p\">;</span> <span class=\"p\">}</span> <span class=\"o\">|</span> <span class=\"p\">{</span> <span class=\"nx\">kind</span><span class=\"o\">:</span> <span class=\"s1\">&#39;diff&#39;</span><span class=\"p\">;</span> <span class=\"nx\">value</span>: <span class=\"kt\">string</span><span class=\"p\">;</span> <span class=\"p\">};</span>\n<span class=\"nx\">type</span> <span class=\"nx\">Command</span> <span class=\"o\">=</span> <span class=\"kt\">string</span><span class=\"p\">;</span> <span class=\"c1\">// or something that denotes a spawnable command</span>\n</pre></div>",
        "id": 177090703,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959152
    },
    {
        "content": "<p>(let's say that <code>diff</code> is experimental and should be left out initially)</p>",
        "id": 177090763,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959172
    },
    {
        "content": "<p>this could support passing entire file patches or if IPC approach is desired, the LS can prepare such  fileset that it leaves all of the IPC/plumbing details to that client</p>",
        "id": 177090841,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959233
    },
    {
        "content": "<p>one implementation might be to spawn and connect to an previously prepared IPC server to serve only that file</p>",
        "id": 177090866,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959262
    },
    {
        "content": "<p>with this the cost of implementation is relatively low on the <code>rustc</code> side - either read patched files or just spawn a command</p>",
        "id": 177090925,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959290
    },
    {
        "content": "<p>and if the LS wants to do anything fancy with IPC then sure</p>",
        "id": 177090954,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959323
    },
    {
        "content": "<p>one could imagine having an IPC-enabled VFS with immutable data structure with snapshots identifiable by IDs where you could invoke something like <code>vfs-client &lt;snapshot-id&gt; &lt;file-path&gt;</code></p>",
        "id": 177091000,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959369
    },
    {
        "content": "<p>or the server could spawn an IPC VFS instance for a specific snapshot and you would know that you need to do something like <code>vfs-client --fd=92 &lt;file-path&gt;</code>or anything similar</p>",
        "id": 177091111,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959444
    },
    {
        "content": "<p>the only thing this would suck is when basically everything is dirty and you need to invoke a command for each of the files listed to get the contents, but that was our starting point and as you're saying we shouldn't really assume every file is dirty (and rather tell rustc upfront)</p>",
        "id": 177091168,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959511
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> what do you think?</p>",
        "id": 177091180,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569959516
    },
    {
        "content": "<p>I think that, even long-term, diff is probably not a good idea. As far as I understand, there's no really a way to make two processes, to agree on the contents of file on disk, so diff solutions will inevitable be prone to \"someone modifed the file in the meantime, so the diff doesn't make sence\" problem.</p>",
        "id": 177091524,
        "sender_full_name": "matklad",
        "timestamp": 1569959764
    },
    {
        "content": "<p>At the same time, I don't think that sending the whole file over the wire is a problem: compiler does O(N) processing on it anyway.</p>",
        "id": 177091637,
        "sender_full_name": "matklad",
        "timestamp": 1569959869
    },
    {
        "content": "<p>Not sure about \"external command / file-in-place\" flexibility. I suspect that we might just start with only <code>kind: 'text'</code> and then figure out that its enough</p>",
        "id": 177091730,
        "sender_full_name": "matklad",
        "timestamp": 1569959913
    },
    {
        "content": "<p>well that is true, it's in fact more deterministic to send the file in a ready state or a command that's supposed to guarantee that as well</p>",
        "id": 177093716,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569961022
    },
    {
        "content": "<p>Well, do you think it's PR-worthy?</p>",
        "id": 177107946,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569972582
    },
    {
        "content": "<p>we might as well start with something  <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 177108020,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569972615
    },
    {
        "content": "<p>I assume RA and intelliJ would be more interested in the VFS implementation itself rather than the \"overlayfs\"?</p>",
        "id": 177108037,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569972639
    },
    {
        "content": "<p>(in terms of unifying IDE work)</p>",
        "id": 177108046,
        "sender_full_name": "Igor Matuszewski",
        "timestamp": 1569972648
    }
]