[
    {
        "content": "<p>So <code>#![feature(trivial_bounds)]</code> allows us to declare both trivially true or <strong>trivially false</strong> bounds on items...</p>",
        "id": 273188912,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645764844
    },
    {
        "content": "<p>The latter are problematic, because during codegen (or on the way to codegen, like mir_opt), we <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_trait_selection/src/traits/codegen.rs#L54\">ICE</a> if we cannot resolve a trait bound.</p>",
        "id": 273188918,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645764850
    },
    {
        "content": "<p>I'm trying to solve <a href=\"https://github.com/rust-lang/rust/issues/93008\">#93008</a> (which I thought I fixed in <a href=\"https://github.com/rust-lang/rust/issues/93024\">#93024</a>, but did only partially, and the solution was kinda a hack), but the \"right\" thing to do is kinda up for debate.</p>",
        "id": 273188921,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645764858
    },
    {
        "content": "<p>So, what do we want to do with trivial bounds if they get to codegen?</p>",
        "id": 273188923,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645764867
    },
    {
        "content": "<p>I guess we can:</p>\n<ol>\n<li>Only raise an error if that bound is used in a meaningful way (e.g. a method call relies on it)</li>\n<li>Always raise an error (perhaps lint against false trivial-bounds before we get to codegen)</li>\n<li>Make <code>codegen_fulfill_obligation</code> (where we see ICEs) fallible so we can handle unsatisfiable trivial bounds some other way (?!)</li>\n<li>??</li>\n</ol>",
        "id": 273189243,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645765242
    },
    {
        "content": "<p>He original example shouldn't compile, right? The bound never holds so the function is not well formes</p>",
        "id": 273193018,
        "sender_full_name": "oli",
        "timestamp": 1645769915
    },
    {
        "content": "<p>The opt example is more interesting, it should compile, but doesn't after inlining, suggesting to me that we lose the information that allows us to prove it during inlining. Are we inlining param envs into parent param envs during inlining? Do we have to because some part of rustc isn't smart enough to figure things out without a hint?</p>",
        "id": 273193122,
        "sender_full_name": "oli",
        "timestamp": 1645770051
    },
    {
        "content": "<p>I think we'll want 2, but actually error earlier in well-formendness?</p>",
        "id": 273193205,
        "sender_full_name": "oli",
        "timestamp": 1645770148
    },
    {
        "content": "<p>It was my understanding that <code>trivial_bounds</code> bounds exists to allow functions with unsatisfied bounds to compile, as long as function isn't actually called.</p>\n<p>The had been a similar issue in a constant propagation pass which at the time was resolved by checking for unsatisfiable predicates with <code>impossible_predicates</code> and skipping the optimization. Maybe this approach could be extended to cover the complete MIR optimization phase?</p>",
        "id": 273195308,
        "sender_full_name": "tm",
        "timestamp": 1645772700
    },
    {
        "content": "<p>yeah, i think it might be easiest to just skip optimization altogether if there are unsatisfiable predicates..</p>",
        "id": 273195884,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645773364
    },
    {
        "content": "<p>the example I gave in <a href=\"https://github.com/rust-lang/rust/issues/93008\">#93008</a> that doesn’t require trivial_bounds actually ICEs _during_ inlining, not after</p>",
        "id": 273196066,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645773581
    },
    {
        "content": "<p>this is because we erase regions while evaluating things during the inlining pass, and that plus ParamEnv being RevealAll causes the unsatisfiable predicate (that was parameterized over 'a) to look like it’s global (since it now references ReErased), and thus be evaluated with an empty ParamEnv</p>",
        "id": 273196121,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645773635
    },
    {
        "content": "<p>Maybe we should keep ICEing, but stop requesting optimized mir for functions that have unsatisfiable bounds, thus avoiding the ICE and the work</p>",
        "id": 273203270,
        "sender_full_name": "oli",
        "timestamp": 1645779505
    },
    {
        "content": "<p>Side question: is this all easier with chalk as it may emit a wf error?</p>",
        "id": 273203485,
        "sender_full_name": "oli",
        "timestamp": 1645779625
    }
]