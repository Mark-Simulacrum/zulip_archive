[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> : <a href=\"https://github.com/rust-lang/rust/issues/92804\">#92804</a> is actually not correct, it fails on</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// check-pass</span>\n\n<span class=\"cp\">#![warn(rust_2021_incompatible_closure_captures)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"n\">Bar</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Goo</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"p\">(</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">Goo</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">v</span>: <span class=\"nc\">Bar</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">)()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>To explain what is going on: The <code>adt_components</code> closure takes an ADT and returns the list of \"subtypes\" (not the type theory kind) that need to not have (possibly significant) drop glue in order for the ADT to not have significant drop glue. The returned types are basically either the fields (after a <code>.subst()</code> call) or the generic args. Importantly, in general we are allowed to do circular reasoning here. In the example above, the list of types that we look to prove don't need a significant drop changes like <code>[Bar] -&gt; [Vec&lt;Goo&gt;] -&gt; [Goo] -&gt; [Foo] -&gt; [Bar]</code>, at which point we should report that <code>Bar</code> does not need significant drop. The way this is implemented is via the <code>seen_tys</code> set, which stores all the types we've seen and can circularly assume will report that they don't need a drop, as long as everything else does too.</p>\n<p>In <a href=\"https://github.com/rust-lang/rust/issues/90845\">#90845</a> , the steps shown above were allowed to go through the query system which helped greatly with perf because we can cut that chain short if the question had already been answered for eg <code>Goo</code>. The problem is that blindly recursing through the query system is going to cause issues with cycles. The patch up in the PR right now doesn't actually address this correctly, it just fixes some of the cases. I can see two ways to resolve this:</p>\n<ol>\n<li>Get the query system to help out here. If there is some way for me to ask \"run this query, and if it would cause a query cycle report back and let me know\" that would be perfect.</li>\n<li>Revert <a href=\"https://github.com/rust-lang/rust/issues/90845\">#90845</a></li>\n</ol>",
        "id": 268217554,
        "sender_full_name": "Jake",
        "timestamp": 1642381784
    },
    {
        "content": "<p>Actually, I don't really see how to make option 1 work above. Maybe someone knows some query system tricks I don't, but if not then probably <a href=\"https://github.com/rust-lang/rust/issues/90845\">#90845</a> needs to be reverted</p>",
        "id": 268269122,
        "sender_full_name": "Jake",
        "timestamp": 1642425549
    },
    {
        "content": "<p>In option 1, I'm not sure that the information \"this call is cyclic\" can be used in any meaningful way, <em>except</em> if there is an obvious absorbing solution.  I mean: if cycle implies that <code>needs_drop</code> is true, then we can use the cycle information to propagate returning true.  If there is no such absorbing element, I fear that option 1 would only lead to bugs.</p>",
        "id": 268296449,
        "sender_full_name": "cjgillot",
        "timestamp": 1642439948
    },
    {
        "content": "<p>We could use an option 3: gather all the dependencies in anticipation of the computation, and look for queries at that stage.  This would require: (1) a function taking a <code>DefId</code> and returning the list of the <code>DefId</code>s for which it will evaluation <code>needs_drop(def_id)</code>, (2) to walk this graph looking for strongly connected components, (3) invoke the query normally for non-cyclic parts of the graph, (4) invoke a specific handler function for cycles.<br>\nThis seems quite a lot of heavy lifting, but I haven't found a simpler method yet.  I've got a WIP branch, I'll push it when once I get time to finish it.</p>",
        "id": 268296855,
        "sender_full_name": "cjgillot",
        "timestamp": 1642440227
    },
    {
        "content": "<p>Is gathering all the DefIds not likely to undo the performance benefits on its own? I'd imagine that the expensive part of the non-query cache enabled solution would be iterating the full dependency graph</p>",
        "id": 268330022,
        "sender_full_name": "Jake",
        "timestamp": 1642467258
    },
    {
        "content": "<p>The current implementation already walks the dependency graph using recursive calls and manual recursion handling.  This method would move this walking part to the query engine.  I'm not proposing to walk the whole crate at once, rather to build the fragments of graph when needed.</p>",
        "id": 268350402,
        "sender_full_name": "cjgillot",
        "timestamp": 1642489309
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Fixing.20.2392804/near/268350402\">said</a>:</p>\n<blockquote>\n<p>The current implementation already walks the dependency graph using recursive calls and manual recursion handling.  This method would move this walking part to the query engine.  I'm not proposing to walk the whole crate at once, rather to build the fragments of graph when needed.</p>\n</blockquote>\n<p>Hm, I must have misunderstood something. In the current implementation, with code like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"n\">Many</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Different</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Fields</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>calling <code>needs_drop(Foo)</code> and then <code>needs_drop(Bar)</code> does not touch <code>needs_drop(Many | Different | Fields)</code> again - in this sense that entire branch of the computation is pruned. Is this not changed by your step 1, where each of the fields will need to be visited by the proposed \"gather <code>DefId</code>s\" step?</p>",
        "id": 268351281,
        "sender_full_name": "Jake",
        "timestamp": 1642490050
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> I just realized there might be a much simpler solution: the code currently in master is correct for the general <code>needs_drop</code> code, it's only wrong for <code>needs_significant_drop</code>. I expect that the second case is much less common (does it get called at all in Edition 2021?) so how about just restricting the optimization in <a href=\"https://github.com/rust-lang/rust/issues/90845\">#90845</a> to that case?</p>",
        "id": 268628459,
        "sender_full_name": "Jake",
        "timestamp": 1642641721
    },
    {
        "content": "<p>The reason it's correct for <code>needs_drop</code> is because for ADTs, that always returns the fields, and so all sources of query cycles must have a pointer/reference in the way, which are trivially not drop and so our search stops there</p>",
        "id": 268628791,
        "sender_full_name": "Jake",
        "timestamp": 1642641989
    }
]