[
    {
        "content": "<p>I was contemplating an aggressive space optimization for enums in arenas. Imagine the enum <code>enum E { A(u64), B }</code>. The type size is 16 bytes.</p>\n<ul>\n<li>The <code>A</code> variant has a 1 byte discriminant, 7 bytes padding, 8 bytes for the <code>u64</code>.</li>\n<li>The <code>B</code> variant has a 1 byte discriminant, and 15 bytes of padding.<br>\nIf an instance of <code>E::B</code> is arena allocated, you could conceivably just allocate the 1 byte discriminant and then put other data immediately after it. (Assuming you know you aren't within 15 bytes of the end of the chunk.) When you read that <code>E::B</code> out of the arena you'd get 15 bytes from one or more other values, but only in the bytes of <code>E::B</code> that don't matter.<br>\nI don't think Rust exposes functionality to even achieve this easily, and I also wonder about whether overlapping types could result in UB. Still, interesting idea.</li>\n</ul>",
        "id": 269177958,
        "sender_full_name": "nnethercote",
        "timestamp": 1643061088
    },
    {
        "content": "<p>Basically, the idea is variable-length in-memory encoding of enums, reminds me a bit of Encodable/Decodable and the use of LEB128, etc.</p>",
        "id": 269178051,
        "sender_full_name": "nnethercote",
        "timestamp": 1643061133
    },
    {
        "content": "<p>And also how we have some types with a \"packed\" and \"unpacked\" version</p>",
        "id": 269178106,
        "sender_full_name": "nnethercote",
        "timestamp": 1643061154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> That could work for read-only things, but what happens if you overwrite the B with an A?</p>",
        "id": 269178564,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643061453
    },
    {
        "content": "<p>Yes, this would be read-only; all our arena-allocated things are read-only, I think. Certainly the interned types are</p>",
        "id": 269178590,
        "sender_full_name": "nnethercote",
        "timestamp": 1643061482
    },
    {
        "content": "<p>For things guaranteed to be read-only (<em>actually</em> read-only with no internal mutability), I don't see a reason you couldn't do that.</p>",
        "id": 269178928,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643061633
    },
    {
        "content": "<p>You would never take references into the arena (you'd always copy values out), right?</p>",
        "id": 269179644,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643062029
    },
    {
        "content": "<p>If so, then I think the compiler would never see overlapping types</p>",
        "id": 269179796,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643062105
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Have you considered slab allocation? It might be possible to have a slab of As, a slab of Bs, internally track types as one or the other (so that you don't actually store the discriminant next to the value), and then if you're copying things out you synthesize the full enum.</p>",
        "id": 269180017,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062219
    },
    {
        "content": "<p>Well, you need to have references into the arena in order to copy things out...</p>",
        "id": 269180031,
        "sender_full_name": "nnethercote",
        "timestamp": 1643062226
    },
    {
        "content": "<p>A reference already needs to point somewhere; what if the arena could go \"ah, the pointer is within the slab of As, so it's an A, and it points to the u64\", or \"Ah, the pointer is within the slab of Bs, so it's a B\".</p>",
        "id": 269180105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062279
    },
    {
        "content": "<p>(Depending on semantics, the internal type of B could be a ZST or it could be one byte so that the addresses are unique.)</p>",
        "id": 269180202,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062326
    },
    {
        "content": "<p>Definitely conceivable. This is basically a question of \"how to best compress data\". The thing about my original suggestion was that it could potentially nicely apply to every enum that gets read-only arena-allocated. These more fine-grained ideas are probably only going to happen on a per-type basis...</p>",
        "id": 269180247,
        "sender_full_name": "nnethercote",
        "timestamp": 1643062358
    },
    {
        "content": "<p>It seems <em>possible</em> to build a generalized \"enum slab arena\" that doesn't require unique code.</p>",
        "id": 269180299,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062401
    },
    {
        "content": "<p>Worst case, <code>#[derive(EnumSlabArena)]</code> and do code gen; best case, feed the variants into a generic with some clever type-level handling.</p>",
        "id": 269180373,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062438
    },
    {
        "content": "<p>Also, <em>this</em> case in particular seems equivalent to <code>Option&lt;u64&gt;</code>, and you could make arenas special-case Option.</p>",
        "id": 269180469,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062476
    },
    {
        "content": "<p>Yeah a proc macro is definitely an option</p>",
        "id": 269180538,
        "sender_full_name": "nnethercote",
        "timestamp": 1643062530
    },
    {
        "content": "<p>What's an example of a concrete type you would want to apply this to?</p>",
        "id": 269180556,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062547
    },
    {
        "content": "<p>My example was equivalent to <code>Option</code>, but the real types in question are more complex, things like <code>TyKind</code> and <code>PredicateKind</code></p>",
        "id": 269180566,
        "sender_full_name": "nnethercote",
        "timestamp": 1643062553
    },
    {
        "content": "<p>Ah.</p>",
        "id": 269180570,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062558
    },
    {
        "content": "<p>So you'd need quite a few slabs for the 10-20 variants, etc.</p>",
        "id": 269180637,
        "sender_full_name": "nnethercote",
        "timestamp": 1643062590
    },
    {
        "content": "<p>So this is all me just being a bit frustrated with large heterogenous enums <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 269180658,
        "sender_full_name": "nnethercote",
        "timestamp": 1643062611
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 269180665,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062617
    },
    {
        "content": "<p>I would <em>love</em> to see simple ways of doing these optimizations.</p>",
        "id": 269180671,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062623
    },
    {
        "content": "<p>Another optimization that'd be nice to have within the compiler: a generalized scheme for \"this can technically be any u64, but most values will actually be quite small and fit within a u16 or so, so reserve one value for 'oops, it's big' and store those separately or tweak the arena at runtime\".</p>",
        "id": 269180851,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062726
    },
    {
        "content": "<p>(e.g. many indexes inside the compiler)</p>",
        "id": 269180891,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062757
    },
    {
        "content": "<p>Effectively, a kind of runtime Huffman compression.</p>",
        "id": 269181027,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062827
    },
    {
        "content": "<p>Hmm, even unaligned reads out of such an arena could be weird since a read of an enum could read past the end of the arena, unless the population code is particularly careful.  And even writing it initially might be weird since you I think the rules mean you couldn't write into the trailing padding of an enum if you've given out a <code>&amp;</code> to it, even though it's padding that you don't care about.</p>\n<p>Definitely feels like it'd need a macro to generate <code>repr(packed)</code> and normal structs for the payloads of each of the enums, so the arena could have the packed form and the various APIs for the arena could translate appropriately between the different representations.</p>",
        "id": 269181035,
        "sender_full_name": "scottmcm",
        "timestamp": 1643062833
    },
    {
        "content": "<p>The challenge there is always \"how to find the auxiliary storage for the long cases\" <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 269181059,
        "sender_full_name": "nnethercote",
        "timestamp": 1643062852
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> I'm imagining the case where you reference the thing by pointer-into-arena anyway.</p>",
        "id": 269181085,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062875
    },
    {
        "content": "<p>If you're passing something around by value rather than by pointer, then most of these tricks don't work, unless the thing fits into 8 bytes.</p>",
        "id": 269181112,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062894
    },
    {
        "content": "<p>(Which is <em>also</em> an optimization I'd love to see: \"high bit set: magic encoding of this into the remaining 63 bits; high bit clear, pointer to the thing\".)</p>",
        "id": 269181148,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062914
    },
    {
        "content": "<p>This isn't quite the same thing, but there's been lots of talk of \"move-only\" fields where, like <code>repr(packed)</code>, using a field moves (or more often <code>Copy</code>s) out/in the field, giving an opportunity to run code, and avoiding the restrictions inherent in being able to get references (particularly mutable ones) to fields.</p>\n<p>I guess something like that could only help avoid the discriminant taking extra space, though, not handle the different variants fundamentally being different lengths.</p>",
        "id": 269181222,
        "sender_full_name": "scottmcm",
        "timestamp": 1643062940
    },
    {
        "content": "<p>Seems like we could generalize the hand-done \"box the big variants\" optimization into an automatic <code>#[PseudoBoxThingsThatDontFitIn63Bits]</code></p>",
        "id": 269181302,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643062996
    },
    {
        "content": "<p>Except that often in the compiler <code>Box</code> isn't really the appropriate thing, more arena-allocating is <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 269181519,
        "sender_full_name": "nnethercote",
        "timestamp": 1643063126
    },
    {
        "content": "<p>Back to my original example: maybe it's less interesting than I first thought. When interning is involved, <code>E::B</code> will only be stored once because it only has one value. But many <code>E::A(n)</code> values can be stored.</p>",
        "id": 269181570,
        "sender_full_name": "nnethercote",
        "timestamp": 1643063161
    },
    {
        "content": "<p>I'm about to measure this on <code>TyKind</code>, which is the most important of these types</p>",
        "id": 269181632,
        "sender_full_name": "nnethercote",
        "timestamp": 1643063176
    },
    {
        "content": "<p>in general: <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/tagged_ptr/index.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/tagged_ptr/index.html</a>, though it has limitations of course</p>",
        "id": 269186149,
        "sender_full_name": "simulacrum",
        "timestamp": 1643065895
    },
    {
        "content": "<p>I imagine with <code>union</code> of structures you could even implement some ability to take references too.</p>",
        "id": 269196824,
        "sender_full_name": "nagisa",
        "timestamp": 1643074268
    }
]