[
    {
        "content": "<p>One of the benefits of the query system is memoization - if we calculated someting once we keep the result and don't calculate it anymore.<br>\nThis applies to decoding something from other crates' metadata - we decode something once and then keep the result.</p>\n<p>Accesses to metadata (cstore) from <code>Resolver</code> during early compilation are basically identical to cstore accesses that happens later on from tcx through the query system, because anything in cstore is already compiled in advance and doesn't need to be built on the fly unlike the current crate's data.<br>\nHowever we don't currently have any centralized system for memoizing such metadata decoding work, so it may be performed multiple times early from resolver (which is kind of an early tcx at this point), and then once more from tcx later on. This may be costly for heavy queries like e.g. <code>all_trait_implementations</code> in <a href=\"https://github.com/rust-lang/rust/pull/88679\">https://github.com/rust-lang/rust/pull/88679</a>.</p>\n<p>What is the easiest way to add a query-like system to resolver (for cstore accesses only for a start)?<br>\nI can add a simple memoization scheme to <code>Resolver</code> only, but it would be good to somehow transfer the cache filled by this system to the later query system as well.<br>\nIt would also be better if it's compatible with plans for moving incremental compilation closer to compilation start, etc.</p>\n<p>cc <span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span></p>",
        "id": 253737343,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1631883400
    },
    {
        "content": "<p>I did rather move to a scheme where accessing crate metadata doesn't require a separate decoding step, but can directly operate on the encoded metadata. I understand that this is a lot harder though, but for example <a href=\"https://github.com/rust-lang/rust/issues/82183\">#82183</a> is already reducing the amount of decoding necessary.</p>",
        "id": 253738183,
        "sender_full_name": "bjorn3",
        "timestamp": 1631883736
    },
    {
        "content": "<blockquote>\n<p>What is the easiest way to add a query-like system to resolver (for cstore accesses only for a start)?</p>\n</blockquote>\n<p><code>OnceCell</code> maybe?</p>",
        "id": 253738252,
        "sender_full_name": "bjorn3",
        "timestamp": 1631883775
    },
    {
        "content": "<p>Yeah, something like <code>OnceCell</code> would work for a resolver-only cache, but I guess the main question is how to avoid duplicate work if we a calling a heavy query like <code>all_trait_implementations</code> from <em>both</em> resolver and tcx.</p>",
        "id": 253738855,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1631884019
    },
    {
        "content": "<p>It could be part of CStore. That still requires a clone between the CStore cache and TyCtxt query cache though.</p>",
        "id": 253739097,
        "sender_full_name": "bjorn3",
        "timestamp": 1631884112
    },
    {
        "content": "<p>IMHO, the query system is not the right tool if you are only interested in memoization. The main objective of the query system is depencency-tracking and avoiding recomputations. Using a special-purpose macro to generate a memoization system (with OnceCell) should be enough.</p>\n<p>OTOH, one of the aims of the end-to-end query program is to allow using the query system for crate metadata decoding. But this is a very long program.</p>",
        "id": 253762791,
        "sender_full_name": "cjgillot",
        "timestamp": 1631893750
    },
    {
        "content": "<p>I've implemented some memoization in <a href=\"https://github.com/rust-lang/rust/pull/89059\">https://github.com/rust-lang/rust/pull/89059</a>, it avoids decoding things multiple times, but still requires cloning them every time.</p>",
        "id": 253824444,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1631924671
    },
    {
        "content": "<p>Update: it turns out that arenas used by tcx are long living, so they can be passed to cstore as well.<br>\nSo tcx queries don't even need to copy the cached results, they can reuse them directly - the result is a pointer to the tcx arena.<br>\n(There are some issues with passing arenas through <code>BoxedResolver</code> due to lifetime parameters, which I worked around with hacks, but they are probably solvable.)</p>",
        "id": 254195997,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1632226183
    },
    {
        "content": "<p>For some reason it's still a regression for the <code>metadata_decode_entry_item_attrs</code> query (and a couple of similar queries), despite the difference being only a single <code>FsHashMap</code> lookup by <code>DefIndex</code>.</p>",
        "id": 254196969,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1632226667
    },
    {
        "content": "<p>I would like CStore to be reusable between different TyCtxt to make a compiler daemon possible that shares information that is most of the time unchanged like the CStore between multiple compilations.</p>",
        "id": 254206259,
        "sender_full_name": "bjorn3",
        "timestamp": 1632230813
    }
]