[
    {
        "content": "<p>Currently, generators never implement <code>Clone</code>, even if they could. I'm interested in doing the work necessary to fix this. I have some questions though:</p>\n<p>(a) If I were to implement this and it works, is it likely to get merged upstream? Or is this something that would need to go through an RFC first, or get the approval of whoever's in charge of this area of the language? I'm just a little worried about the possibility of putting a lot of time into this and then having to repeatedly rebase and rewrite it for a year while people who have other priorities decide whether they're even interested in it. So I want to make sure that there's a general consensus that this is simply a missing feature and there's no reason it shouldn't exist.</p>\n<p>(b) Who's the best person to talk to about this? Is there anyone who's familiar with this aspect of the compiler who'd be willing to mentor me while I work on it?</p>\n<p>(c) Where should I start? I can see that the <code>drop</code> and <code>resume</code> methods are generated in <code>rustc_mir_transform/src/generator.rs</code>. Would it make sense to add the <code>clone</code> method implementation there too? Where is the <code>clone</code> method for closures implemented so that I could use it as a reference? Also, how do I make the compiler emit a <code>Clone</code> impl for generator types and how do I hook that up to the actual generated method? The compiler is big and complicated, so any pointers people could give me would save me a lot of poking around and guesswork.</p>",
        "id": 274226898,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646465245
    },
    {
        "content": "<p>It looks like doing this for closures took an RFC: <a href=\"https://rust-lang.github.io/rfcs/2132-copy-closures.html\">https://rust-lang.github.io/rfcs/2132-copy-closures.html</a></p>\n<p>That might also give you links to some things that might point in useful directions.</p>",
        "id": 274228996,
        "sender_full_name": "scottmcm",
        "timestamp": 1646468225
    },
    {
        "content": "<p>For (a), you might want to contact the generators initiative <a href=\"https://github.com/rust-lang/lang-team/issues/137\">https://github.com/rust-lang/lang-team/issues/137</a></p>",
        "id": 274229069,
        "sender_full_name": "scottmcm",
        "timestamp": 1646468342
    },
    {
        "content": "<blockquote>\n<p>It looks like doing this for closures took an RFC: <a href=\"https://rust-lang.github.io/rfcs/2132-copy-closures.html\">https://rust-lang.github.io/rfcs/2132-copy-closures.html</a></p>\n</blockquote>\n<p>True, however given that generators aren't stable yet (eg. they don't even have an agreed-upon syntax) and that they're, in some sense, just generalized closures, would it be necessary to have an RFC for this? It seems weird to open an RFC for an extension to a feature that doesn't officially exist.</p>",
        "id": 274231250,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646471019
    },
    {
        "content": "<p>Generators indirectly are stable because async blocks desugar to them</p>",
        "id": 274236275,
        "sender_full_name": "oli",
        "timestamp": 1646477844
    },
    {
        "content": "<p>I think with the closure precedent a lang team MCP could suffice?</p>",
        "id": 274236287,
        "sender_full_name": "oli",
        "timestamp": 1646477876
    },
    {
        "content": "<p>It's a good first step - pointing to <a href=\"https://lang-team.rust-lang.org/design_notes/fn_type_trait_impls.html\">https://lang-team.rust-lang.org/design_notes/fn_type_trait_impls.html</a> for background would be a good idea. I think there's some level of regret about the Clone impls for closures</p>",
        "id": 274238986,
        "sender_full_name": "simulacrum",
        "timestamp": 1646481157
    },
    {
        "content": "<p>Something I've noticed looking through the code is that closures get treated as just being a tuple of their upvars, so a lot of code gets re-used between tuples and closures. It might be nice if we had anonymous enum types as well and then generators could just be de-sugared to those. However right now it seems generators store their upvars separately to their state (which stores their local variables). This seems a bit odd. It means if an upvar gets dropped its space doesn't get reclaimed until the entire generator is dropped. Wouldn't it make more sense to just make them a big enum and to store each upvar in every enum variant where it's live? Or would this make it hard to avoid unnecessary re-ordering of fields?</p>",
        "id": 274243673,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646487238
    },
    {
        "content": "<p>One thing that comes to mind about <code>Clone</code>ing generators is that it can't be done if the generator ever holds a reference to a local-to-the-generator over a suspension point.  That seems like it could very easily make things stop being <code>Clone</code> because of things that look like minor refactors.  I don't know how impactful that would be.  Certainly the capture set of closures is also non-obvious, so has similar problems.</p>\n<p>(Which gets to the \"some level of regret\" than <span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> mentioned.  I'm kinda nervous about <code>Clone</code> in general -- imagine a closure in an <code>unsafe</code> block that becomes <code>Copy</code> because it only uses pointers, for example, and specialization might make this even worse since it might not let you know whether the thing to which you're passing it will attempt to use the <code>Copy</code>.  It makes me wonder whether it should be restricted to things with an explicit capture set, or similar.  Not that such a feature exists today.)</p>",
        "id": 274263974,
        "sender_full_name": "scottmcm",
        "timestamp": 1646512893
    },
    {
        "content": "<p>See also <a href=\"https://github.com/rust-lang/rust/issues/57972\">#57972</a></p>",
        "id": 274264290,
        "sender_full_name": "cuviper",
        "timestamp": 1646513329
    },
    {
        "content": "<p>From some testing it seems that <code>Send + Sync</code> are automatically implemented <em>and visible</em> for futures returned by <code>async fn</code>s. Is the suggestion that the same thing would be done for <code>Clone</code>? Or that the user would have to write <code>fn asyncish() -&gt; impl Future + Clone</code>?</p>",
        "id": 274264304,
        "sender_full_name": "Jake",
        "timestamp": 1646513363
    },
    {
        "content": "<p>It would be automatic, but still need <code>-&gt; impl Future + Clone</code> if you want to return it. Only auto traits like <code>Send</code> and <code>Sync</code> leak out of <code>impl Trait</code>.</p>",
        "id": 274264507,
        "sender_full_name": "bjorn3",
        "timestamp": 1646513655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/131828-t-compiler/topic/.60Clone.60.20for.20generators/near/274264304\">said</a>:</p>\n<blockquote>\n<p>From some testing it seems that <code>Send + Sync</code> are automatically implemented <em>and visible</em> for futures returned by <code>async fn</code>s.</p>\n</blockquote>\n<p><code>auto trait</code>s are magical, which is part of why they'll likely never stabilize.</p>",
        "id": 274264859,
        "sender_full_name": "scottmcm",
        "timestamp": 1646514042
    },
    {
        "content": "<p>@scottmcm:</p>\n<blockquote>\n<p>That seems like it could very easily make things stop being <code>Clone</code> because of things that look like minor refactors.</p>\n</blockquote>\n<p>You'd get a compilation error though once you make the change. The error couldn't appear in a downstream crate because you'd have to opt-in to clonability using <code>impl Generator&lt;..&gt; + Clone</code>.</p>\n<blockquote>\n<p>I'm kinda nervous about <code>Clone</code> in general -- imagine a closure in an <code>unsafe</code> block that becomes <code>Copy</code> because it only uses pointers, for example,</p>\n</blockquote>\n<p>If I understand your concern correctly, you're imagining something like: someone creates a <code>FnOnce</code> which is only intended to be called once but which is inadvertently <code>Copy</code>. They then pass that closure to a function which takes an <code>impl FnOnce() + Copy</code> and that function calls the closure multiple times by copying it.</p>\n<p>While this is plausible I'm not sure it's very realistic. A function that wants to call a callback multiple times will generally take a <code>Fn</code> or <code>FnMut</code>. I suppose if keeping references around is a problem and you don't want to use <code>Arc</code>/<code>Rc</code> for some reason then you <em>might</em> write a function that takes a <code>Copy</code> closure, though it would still make sense to demand that the closure implements <code>Fn</code> rather than <code>FnOnce</code>. And on the caller's side you generally know if a function you're passing a callback to could potentially call that callback multiple times, since you presumably have some idea of what that function is doing and what your callback is supposed to do. Plus, this can only lead to UB in the presence of <code>unsafe</code>, in which case you do really need to make sure you know what you're doing.</p>\n<p>If we do decide that implicitly implementing <code>Clone</code> is too much of a foot-gun then I think we'd still want to make it possible explicitly. And so it would still make sense to have it implemented in the compiler, locked behind a feature-gate, until we figure out what the explicit syntax should look like.</p>",
        "id": 274290994,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646551697
    },
    {
        "content": "<p>I agree it's unlikely.  But our rule for soundness isn't \"doesn't trigger UB in normal uses\".</p>\n<p>That said, I agree that there's nothing here that needs to block implementing stuff unstable.</p>",
        "id": 274291230,
        "sender_full_name": "scottmcm",
        "timestamp": 1646552091
    },
    {
        "content": "<p>I've made a start on seeing how to implement this. The changes I've got so far are:</p>\n<ul>\n<li>In trait selection. Allow <code>Generator</code> and <code>GeneratorWitness</code> to implement <code>Clone</code> so long as the generator is <code>Movable</code>. Specifically, make <code>copy_clone_conditions</code> return <code>Some(Where(&lt;all upvars and locals impl Clone&gt;))</code> rather than returning <code>None</code>.</li>\n<li>In <code>resolve_associated_item</code> create an <code>InstanceDef::CloneShim</code> for <code>Generator</code> and <code>GeneratorWitness</code> like we do for copy types, closures and tuples.</li>\n<li>Add a <code>clone: Option&lt;BasicBlock&gt;</code> field to <code>TerminatorKind::Yield</code> along-side the <code>resume</code> and <code>drop</code> fields.</li>\n<li>Add a <code>generator_clone: Option&lt;Body&lt;'tcx&gt;&gt;</code> field to <code>GeneratorInfo</code> which is populated with <code>Some</code> in the generator state transform's <code>run_pass</code> when the generator is <code>Movable</code>.</li>\n</ul>\n<p>The next step would be to generate <code>Body</code> of the clone method in <code>run_pass</code> and assign it the <code>GeneratorInfo</code>. I don't know what else would need to be done after this (I'm just figuring this out as I go along), or if this is a completely wrong approach, or if I should be doing this at all. Any thoughts?</p>",
        "id": 274292492,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646554171
    },
    {
        "content": "<p>I've opened an MCP here: <a href=\"https://github.com/rust-lang/compiler-team/issues/494\">https://github.com/rust-lang/compiler-team/issues/494</a></p>",
        "id": 274292555,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646554258
    },
    {
        "content": "<p>What about async fn? There is no place in the signature to determine if it is Clone or not.</p>",
        "id": 274292981,
        "sender_full_name": "bjorn3",
        "timestamp": 1646554965
    },
    {
        "content": "<p>We already have that problem for <code>Send</code>/<code>Sync</code>.</p>\n<p>The workaround is to write a function as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">my_async_fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;..</span><span class=\"p\">.</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Though I agree that having better syntax for this is desirable.</p>",
        "id": 274293799,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646556160
    },
    {
        "content": "<p>Send and Sync also leak out of impl Trait. Clone doesn't.</p>",
        "id": 274294653,
        "sender_full_name": "bjorn3",
        "timestamp": 1646557353
    },
    {
        "content": "<p>Leaking Clone out of async fn would require adding a way for impl Trait to leak out Clone as async fn uses impl Trait internally.</p>",
        "id": 274294670,
        "sender_full_name": "bjorn3",
        "timestamp": 1646557407
    },
    {
        "content": "<p>Well, the way I'm imagining it, an <code>async fn</code> just wouldn't implement <code>Clone</code>. You'd have to use the workaround if you want your fn to implement <code>Clone</code>.</p>",
        "id": 274295282,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646558244
    },
    {
        "content": "<p>Or, rather, even though the anonymous generator type might implement <code>Clone</code> there'd be no way to access that implementation since you only have an <code>impl Future</code>, not an <code>impl Future + Clone</code>.</p>",
        "id": 274295360,
        "sender_full_name": "Andrew Cann",
        "timestamp": 1646558359
    }
]