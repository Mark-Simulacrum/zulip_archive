[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116114\">@Paul Faria</span>  Why do I need a <code>ReadOnlyBodyAndCache</code> to immutably visit a MIR body?</p>",
        "id": 191950494,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585257500
    },
    {
        "content": "<p>So there was work done for the parallelization effort to remove interior mutability since it would cause issues with parallelization. I had worked through this design with Oli (can't find his handle at the moment). Unfortunately the maintainable version required the cache and body to be independent, but still tracked together.</p>",
        "id": 191951999,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585258363
    },
    {
        "content": "<p>The cache lazily computes some cases on read, which is why it affects immutable Mir bodies.</p>",
        "id": 191952035,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585258390
    },
    {
        "content": "<p>At the moment, the cache holds only the predecessors of each basic block (reverse CFG). When would we need to access this when immutably visiting a MIR body?</p>",
        "id": 191952291,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585258553
    },
    {
        "content": "<p>Also, <code>ReadOnlyBodyAndCache</code> can't recompute anything lazily, since it just has a <code>&amp;Cache</code>.</p>",
        "id": 191952492,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585258677
    },
    {
        "content": "<p>My mistake, I made the comment without reviewing the code. In that case there are some usages where the visitors read the data from the cache, but it's guaranteed to have already been precomputed. This is the PR where this went in for reference: <a href=\"https://github.com/rust-lang/rust/pull/64736\" title=\"https://github.com/rust-lang/rust/pull/64736\">https://github.com/rust-lang/rust/pull/64736</a></p>",
        "id": 191952619,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585258748
    },
    {
        "content": "<p>I believe I tried making versions where the cache wasn't needed so &amp;Body could be passed through, but there were so many interdependencies that I could never get it to compile. There were other version proposed that didn't require these explicits types, but they were much more fragile in the sense that a change in one part of the compiler could inadvertently cause a panic in another (I believe this was when we experimented with manually clearing and recomputing the cache at certain points during compilation).</p>",
        "id": 191952921,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585258935
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  (not sure why, but couldn't link you in the earlier comment on Mobile)</p>",
        "id": 191952955,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585258950
    },
    {
        "content": "<p>If you're working on something I've got plenty of free time the next few days to pair if that would help.</p>",
        "id": 191953763,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585259515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116114\">@Paul Faria</span> Can you point me to a place in the code or a comment that illustrates why<code>visit_body</code> doesn't take <code>&amp;mir::Body</code>? If we need to always keep a reference to the predecessor cache with the body, why do we still pass a plain <code>mir::Body</code> anywhere?</p>",
        "id": 191954605,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585260114
    },
    {
        "content": "<p>My assumption was that <code>ReadOnlyBodyAndCache</code> would gradually replace <code>&amp;mir::Body</code> throughout the codebase and then be renamed to <code>BodyRef</code>, since having to choose whether each function takes <code>&amp;mir::Body</code> or <code>ReadOnlyBodyAndCache</code> is minorly annoying. Do you recall discussing this? Do you also find the status quo confusing or am I alone in this?</p>",
        "id": 191954953,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585260333
    },
    {
        "content": "<p>I agree with you that it is not easy to work with, there were easier proposals, but they made me very uncomfortable regarding the panics I mentioned above. I had some personal events occur that kept me from working on this for the last few months, so I'll have to review the code to see if/where there's a comment describing the behavior (I'll take care of that tomorrow since I'll be on and off tonight). I might have only changed Body to BodyAndCache where it was required simply because it touched so many pieces of the compiler, and I wanted to minimize the impact of the initial change.</p>",
        "id": 191958175,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585262424
    },
    {
        "content": "<p>I definitely hadn't intended to stop there, but the personal events took up all of my spare time for the last few months. As of earlier this week that all opened up so I'll have lots of free time to continue the work on this.</p>",
        "id": 191958218,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585262460
    },
    {
        "content": "<p>No worries. If you can't think of a reason not to, I'll have a go at changing the signature of <code>visit_body</code>.</p>",
        "id": 191958543,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585262731
    },
    {
        "content": "<p>As for broader changes, there's no rush, I just wanted to know if there's a longer-term plan in place.</p>",
        "id": 191958681,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585262829
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> already tried that in the <code>--bless</code> <code>mir-opt</code> PR and I think it works</p>",
        "id": 191960525,
        "sender_full_name": "eddyb",
        "timestamp": 1585264204
    },
    {
        "content": "<p>but I had him use a <code>TypeVisitor</code> instead for more correctness and smaller diff</p>",
        "id": 191960542,
        "sender_full_name": "eddyb",
        "timestamp": 1585264221
    },
    {
        "content": "<p>See  <a href=\"https://github.com/rust-lang/rust/issues/70449\" title=\"https://github.com/rust-lang/rust/issues/70449\">#70449</a>, which does the bare minimum. I could change some of the surrounding function signatures back as well, but it's not a high priority.</p>",
        "id": 191960859,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585264528
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> I like the change. Looks like it will be easier to use visitors.</p>",
        "id": 192015452,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585315326
    },
    {
        "content": "<p>So every time I create a <code>ReadOnlyBodyAndCache</code>, I have to populate the cache. This means that before <a href=\"https://github.com/rust-lang/rust/issues/70449\" title=\"https://github.com/rust-lang/rust/issues/70449\">#70449</a> every time I needed to call a <code>Visitor</code> impl, we had to compute the reverse CFG. Is this correct? This seems very wasteful.</p>",
        "id": 192196749,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585519921
    },
    {
        "content": "<p>(<a href=\"https://github.com/rust-lang/rust/issues/70449\" title=\"https://github.com/rust-lang/rust/issues/70449\">#70449</a> doesn't actually remove any uses of <code>ReadOnlyBodyAndCache</code>, so there's no perf benefits, but someone could go in now and remove them)</p>",
        "id": 192196867,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585520105
    },
    {
        "content": "<p>It just ensures that the cache is precomputed before you can create a <code>ReadOnlyBodyAndCache</code>.  If it was already computed before, then it's a no-op.</p>",
        "id": 192441093,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585684426
    },
    {
        "content": "<p>So if you create two <code>ReadOnlyBodyAndCache</code> from one <code>BodyAndCache</code>, the cache should only be computed once, not twice.</p>",
        "id": 192441200,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585684473
    },
    {
        "content": "<p>Said another way, what percentage of the times when I'm forced to create a <code>ReadOnlyBodyAndCache</code> to call <code>visit_body</code>do I actually use it to look at predecessors?</p>",
        "id": 192449696,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585688858
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"116114\">@Paul Faria</span>  I'd like to revert <a href=\"https://github.com/rust-lang/rust/issues/64736\" title=\"https://github.com/rust-lang/rust/issues/64736\">#64736</a> in favor of a <code>Mutex&lt;Option&lt;...&gt;&gt;</code> to hold the predecessors cache. With the current solution, each function which doesn't need mutable access to a given <code>Body</code> must encode whether any of its callees plan to compute the reverse CFG  into its type signature. This makes things like adding support for backward dataflow analyses to the current framework, which I am working on today, more difficult than it should be. Only backward dataflow analyses need access to the reverse CFG, but I am forced to either precompute the predecessor graph for <em>all</em> analyses (<code>ReadOnlyBodyAndCache</code>), or keep around a mutable reference to the body (<code>&amp;mut BodyAndCache</code>) so I can compute it on demand, despite the fact that dataflow does not actually mutate the MIR.</p>",
        "id": 192464372,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585695804
    },
    {
        "content": "<p>Invalidating the predecessor cache won't actually require taking the lock, since any operation that would invalidate the cache requires a unique reference (<code>&amp;mut</code>) to the MIR anyway. That means we only actually lock when calling <code>predecessors</code>, and I don't think it's worth the current complexity to avoid a few uncontended mutex operations.</p>",
        "id": 192464648,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585696025
    },
    {
        "content": "<p>The only other parts of the compiler that might be affected are in <code>librustc_codegen_ssa</code> and <code>librustc_mir/borrow_check</code>. I can't remember how it was all tied together at the moment, but do you think it would cause any issues with those parts of the compiler? It definitely sounds easier to use than what I came up with, and I think none of the stages will affect the same body simultaneously. I think <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> can speak best to that.</p>",
        "id": 192475910,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585706116
    },
    {
        "content": "<p>Hmm... While I do like the typed approach we have right now, it is a lot of complexity...</p>",
        "id": 192495291,
        "sender_full_name": "oli",
        "timestamp": 1585728653
    },
    {
        "content": "<p>Another alternative would be to just move the cache back into the body and force run the predecessor computation at the end of <code>optimized_mir</code></p>",
        "id": 192495425,
        "sender_full_name": "oli",
        "timestamp": 1585728753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span>  was that the version where we had to manually recompute the cache rather than it being computed on demand? I vaguely remember running into hidden panics because it wasn't always obvious where a part of the compiler might invalidate the cache. If so, I also remember worrying about future changes to the compiler possibly causing panics in areas of code unrelated to the changes. My concern was that would be even more complicated to debug because it wouldn't be obvious to anyone not familiar with the cache.</p>",
        "id": 192569634,
        "sender_full_name": "Paul Faria",
        "timestamp": 1585764521
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> Thoughts? We still need a solution for computing predecessors during borrow checking and the optimization pipeline. It would be much easier if this could be done without requiring <code>&amp;mut Body</code> in these places.</p>",
        "id": 192714725,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585856004
    },
    {
        "content": "<p>I suggested something at some point but I forget where</p>",
        "id": 192714913,
        "sender_full_name": "eddyb",
        "timestamp": 1585856102
    },
    {
        "content": "<p>which would handle terminators differently</p>",
        "id": 192714951,
        "sender_full_name": "eddyb",
        "timestamp": 1585856119
    },
    {
        "content": "<p>and replacing a terminator would automatically adjust predecessors, incrementally</p>",
        "id": 192714976,
        "sender_full_name": "eddyb",
        "timestamp": 1585856133
    },
    {
        "content": "<p>i.e. make MIR a managed (control-flow) graph</p>",
        "id": 192715006,
        "sender_full_name": "eddyb",
        "timestamp": 1585856146
    },
    {
        "content": "<p>instead of doing full recomptations after invalidations</p>",
        "id": 192715025,
        "sender_full_name": "eddyb",
        "timestamp": 1585856157
    },
    {
        "content": "<p>you could never get a <code>&amp;mut Terminator</code></p>",
        "id": 192715102,
        "sender_full_name": "eddyb",
        "timestamp": 1585856182
    },
    {
        "content": "<p>but instead you'd have e.g. <code>TerminatorMutRef&lt;'a&gt;</code> instead of <code>&amp;'a mut Terminator</code> or w/e, without being able to mutate the <code>BasicBlock</code> destinations</p>",
        "id": 192715164,
        "sender_full_name": "eddyb",
        "timestamp": 1585856223
    },
    {
        "content": "<p>That would be ideal. Since the predecessor graph would always be computed and up-to-date, <code>&amp;Body</code> could be used everywhere. However, it's going to be a lot of work to audit all existing callers of <code>basic_blocks_mut</code>, and I would like to find a stopgap solution.</p>",
        "id": 192716402,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585856839
    },
    {
        "content": "<p>well, you wouldn't audit, you'd just hammer them to fit the new API shape :P</p>",
        "id": 192716438,
        "sender_full_name": "eddyb",
        "timestamp": 1585856867
    },
    {
        "content": "<p>they don't have to cooperate to preserve correctness, they can be forced to use an API that does</p>",
        "id": 192716513,
        "sender_full_name": "eddyb",
        "timestamp": 1585856893
    },
    {
        "content": "<p>Replace audit with update then</p>",
        "id": 192716648,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1585856980
    },
    {
        "content": "<p>That sounds like work I might enjoy, if no one else gets to it</p>",
        "id": 192717009,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1585857153
    },
    {
        "content": "<p>I'm going to submit a PR replacing <code>BodyAndCache</code> with interior mutability on <code>Body</code>. Besides helping me finish backward dataflow, it will be easier to migrate to the incremental approach, which will also use only a single type.</p>",
        "id": 193670696,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586626315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> so basically we're reverting the BodyAndCache approach?</p>",
        "id": 193672414,
        "sender_full_name": "eddyb",
        "timestamp": 1586628826
    },
    {
        "content": "<p>oh I see by incremental you mean the \"managed CFG\" approach</p>",
        "id": 193672454,
        "sender_full_name": "eddyb",
        "timestamp": 1586628851
    },
    {
        "content": "<p>where you never get direct mutable access to <code>BasicBlock</code> targets in a <code>TerminatorKind</code></p>",
        "id": 193672460,
        "sender_full_name": "eddyb",
        "timestamp": 1586628860
    },
    {
        "content": "<p>Yeah,  and by \"incremental\" I meant the approach you proposed</p>",
        "id": 193672470,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586628898
    },
    {
        "content": "<p>why did we even go to <code>BodyAndCache</code>? the parallelism effort to remove locks?</p>",
        "id": 193672491,
        "sender_full_name": "eddyb",
        "timestamp": 1586628947
    },
    {
        "content": "<p>Correct. The choice was between <code>Mutex&lt;PredecessorCache&gt;</code> and the status quo.</p>",
        "id": 193672537,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586628980
    },
    {
        "content": "<p>well, not <code>Mutex</code></p>",
        "id": 193672540,
        "sender_full_name": "eddyb",
        "timestamp": 1586628991
    },
    {
        "content": "<p>Do we have a custom lock type?</p>",
        "id": 193672549,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586629014
    },
    {
        "content": "<p>there are special types that are <code>Cell</code>/<code>RefCell</code> when parallelism isn't enabled</p>",
        "id": 193672550,
        "sender_full_name": "eddyb",
        "timestamp": 1586629015
    },
    {
        "content": "<p>everything uses those</p>",
        "id": 193672556,
        "sender_full_name": "eddyb",
        "timestamp": 1586629024
    },
    {
        "content": "<p>IIRC the name might be <code>Lock</code> for what's needed here</p>",
        "id": 193672558,
        "sender_full_name": "eddyb",
        "timestamp": 1586629033
    },
    {
        "content": "<p>it wouldn't hurt to name them <code>CellOrAtomic</code>, <code>RefCellOrMutex</code> and <code>RefCellOrRwLock</code> :P</p>",
        "id": 193672568,
        "sender_full_name": "eddyb",
        "timestamp": 1586629061
    },
    {
        "content": "<p>also <code>Lrc</code> would be <code>RcOrArc</code></p>",
        "id": 193672637,
        "sender_full_name": "eddyb",
        "timestamp": 1586629104
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>  How about <code>Arrc&lt;T&gt;</code> <span aria-label=\"pirate\" class=\"emoji emoji-2620\" role=\"img\" title=\"pirate\">:pirate:</span>  ? ;)</p>",
        "id": 193672666,
        "sender_full_name": "centril",
        "timestamp": 1586629179
    },
    {
        "content": "<p>... the point is to be clear about what it is :P</p>",
        "id": 193672672,
        "sender_full_name": "eddyb",
        "timestamp": 1586629196
    },
    {
        "content": "<p>IIRC the L in <code>Lrc</code> doesn't really mean anything</p>",
        "id": 193672716,
        "sender_full_name": "eddyb",
        "timestamp": 1586629208
    },
    {
        "content": "<p>Doing a perf run on <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a> now.</p>",
        "id": 193680899,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586641094
    },
    {
        "content": "<p>I think perf uses the single-threaded compiler? So this will only give part of the picture.</p>",
        "id": 193680909,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586641135
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> any way I can help out? I started a new job recently, so I was unavailable the last few weeks. I should have time now, a couple hours before and after work (US EST timezone atm)</p>",
        "id": 194298586,
        "sender_full_name": "Paul Faria",
        "timestamp": 1587041658
    },
    {
        "content": "<p>If not I'll just help out rustc-dev-guide for the time being</p>",
        "id": 194299614,
        "sender_full_name": "Paul Faria",
        "timestamp": 1587042131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116114\">@Paul Faria</span> <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a> is a small regression in performance. Do you recall whether the original PR that replaced the <code>RefCell</code> had any perf impact? <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a> is equivalent to the <code>RefCell</code> approach for the single-threaded compiler, which I'm pretty sure what is used by <a href=\"http://perf.rust-lang.org\" title=\"http://perf.rust-lang.org\">perf.rust-lang.org</a></p>",
        "id": 194328804,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587053392
    },
    {
        "content": "<p>AFAICT, the regression is in <code>metadata_register_crate</code>, so it's encoding/decoding that's slow.</p>",
        "id": 194329100,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587053519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> I think we don't (or used to not) encode caches and we don't (or used to not) compute them on decoding</p>",
        "id": 194329515,
        "sender_full_name": "eddyb",
        "timestamp": 1587053703
    },
    {
        "content": "<p>Yeah <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a> includes the old no-op impls for encoding/decoding: <a href=\"https://github.com/rust-lang/rust/pull/71044/commits/b3922699b9744f0b894d8309f8d107859d1cfa83#diff-f3e3c79bda8c6a5aa3cd4fa1f57c002cR47\" title=\"https://github.com/rust-lang/rust/pull/71044/commits/b3922699b9744f0b894d8309f8d107859d1cfa83#diff-f3e3c79bda8c6a5aa3cd4fa1f57c002cR47\">https://github.com/rust-lang/rust/pull/71044/commits/b3922699b9744f0b894d8309f8d107859d1cfa83#diff-f3e3c79bda8c6a5aa3cd4fa1f57c002cR47</a></p>",
        "id": 194329722,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587053785
    },
    {
        "content": "<p>I also added some <code>#[inline]</code>, which helped a bit. I just found an <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/query/on_disk_cache.rs#L925\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/query/on_disk_cache.rs#L925\"><code>emit_unit</code></a> impl that is used cross-crate but not <code>#[inline]</code>. I'll fix that.</p>",
        "id": 194330390,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587054066
    },
    {
        "content": "<p>oh dear</p>",
        "id": 194330469,
        "sender_full_name": "eddyb",
        "timestamp": 1587054094
    },
    {
        "content": "<p>/me forgets about <code>#[inline]</code> all the time</p>",
        "id": 194330527,
        "sender_full_name": "eddyb",
        "timestamp": 1587054115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> These primitive impls would likely benefit from inlining as well right?<br>\n<a href=\"https://github.com/rust-lang/rust/blob/4e4d49d60fd696c4036d438292673a2d7fd34519/src/libserialize/serialize.rs#L391\" title=\"https://github.com/rust-lang/rust/blob/4e4d49d60fd696c4036d438292673a2d7fd34519/src/libserialize/serialize.rs#L391\">https://github.com/rust-lang/rust/blob/4e4d49d60fd696c4036d438292673a2d7fd34519/src/libserialize/serialize.rs#L391</a></p>",
        "id": 194331653,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587054580
    },
    {
        "content": "<p>but those get inlined already, don't they?</p>",
        "id": 194331693,
        "sender_full_name": "eddyb",
        "timestamp": 1587054599
    },
    {
        "content": "<p>the methods are generic</p>",
        "id": 194331724,
        "sender_full_name": "eddyb",
        "timestamp": 1587054603
    },
    {
        "content": "<p>Ah yes. My bad</p>",
        "id": 194331774,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587054612
    },
    {
        "content": "<p>it's only <code>emit_foo</code> in a non-generic <code>impl</code> that's the problem</p>",
        "id": 194331827,
        "sender_full_name": "eddyb",
        "timestamp": 1587054625
    },
    {
        "content": "<p>Oooh. I found a gem: <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/query/on_disk_cache.rs#L910\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/query/on_disk_cache.rs#L910\">https://github.com/rust-lang/rust/blob/master/src/librustc_middle/ty/query/on_disk_cache.rs#L910</a></p>",
        "id": 194332539,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587054957
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">macro_rules</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">encoder_methods</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$($name</span>:<span class=\"nc\">ident</span><span class=\"p\">(</span><span class=\"cp\">$ty</span>:<span class=\"nc\">ty</span><span class=\"p\">);)</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$(</span><span class=\"k\">fn</span> <span class=\"cp\">$name</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">value</span>: <span class=\"cp\">$ty</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Self</span>::<span class=\"n\">Error</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">encoder</span><span class=\"p\">.</span><span class=\"cp\">$name</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">})</span><span class=\"o\">*</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 194332652,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587054985
    },
    {
        "content": "<p>at least the first one's fast XD</p>",
        "id": 194333250,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587055267
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">ecstatic-morse</span> <a href=\"#narrow/stream/131828-t-compiler/topic/.60ReadOnlyBodyAndCache.60.20ergonomics/near/194328804\" title=\"#narrow/stream/131828-t-compiler/topic/.60ReadOnlyBodyAndCache.60.20ergonomics/near/194328804\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116114\">Paul Faria</span> <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a> is a small regression in performance. Do you recall whether the original PR that replaced the <code>RefCell</code> had any perf impact? <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a> is equivalent to the <code>RefCell</code> approach for the single-threaded compiler, which I'm pretty sure what is used by <a href=\"http://perf.rust-lang.org\" title=\"http://perf.rust-lang.org\">perf.rust-lang.org</a></p>\n</blockquote>\n<p>I remember doing a perf analysis with <span class=\"user-mention\" data-user-id=\"116266\">@Santiago Pastorino</span> months ago and we saw that there was no major changes in perf. I don't remember if this was before or after I addressed all of the comments though. There could have been other changes since then that maybe have a different impact now? I remember wanting to go back and review which fns needed to be marked inline, but never had time to take care of that.</p>",
        "id": 194388679,
        "sender_full_name": "Paul Faria",
        "timestamp": 1587088591
    },
    {
        "content": "<p>We had run it, but the results aren't available anymore: <a href=\"https://github.com/rust-lang/rust/pull/64736#issuecomment-548308975\" title=\"https://github.com/rust-lang/rust/pull/64736#issuecomment-548308975\">https://github.com/rust-lang/rust/pull/64736#issuecomment-548308975</a> .</p>",
        "id": 194388850,
        "sender_full_name": "Paul Faria",
        "timestamp": 1587088813
    },
    {
        "content": "<p>Old perf runs are deleted from the server occasionally.</p>",
        "id": 194395325,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587098126
    },
    {
        "content": "<p>Inlining <code>emit_unit</code> fixed the perf problem.</p>",
        "id": 194701056,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587400550
    },
    {
        "content": "<p>I have to say I'm not <em>super</em> psyched to see more mutexes back in, but I won't stand in the way for now</p>",
        "id": 194741048,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587421490
    },
    {
        "content": "<p>That said, I guess I should review the PR, I'd be happy if we can keep the mutex so that it only is held long enough to return an <code>Arc&lt;X&gt;</code> or something</p>",
        "id": 194741083,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587421520
    },
    {
        "content": "<p>as opposed to returning a mutex guard, which seems like it opens the door to deadlocks if you are manipulating two MIRs at once (granted, we rarely do that, and probably never access preds when we do, but still)</p>",
        "id": 194741113,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587421544
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 194741140,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587421557
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/131828-t-compiler/topic/.60ReadOnlyBodyAndCache.60.20ergonomics/near/194741083\" title=\"#narrow/stream/131828-t-compiler/topic/.60ReadOnlyBodyAndCache.60.20ergonomics/near/194741083\">said</a>:</p>\n<blockquote>\n<p>That said, I guess I should review the PR, I'd be happy if we can keep the mutex so that it only is held long enough to return an <code>Arc&lt;X&gt;</code> or something</p>\n</blockquote>\n<p>Since you can only mutate the MIR via unique ownership (<code>&amp;mut</code>), I believe we could use an <code>AtomicPtr&lt;PredecessorCache&gt;</code> instead of a <code>Lock&lt;PredecessorCache&gt;</code>. Because invalidating the predecessor cache requires unique ownership of the <code>AtomicPtr</code> as well as the MIR, the invalidator knows that they are responsible for freeing the predecessor cache if one exists. Those with shared ownership would compute the predecessor cache and then compare and swap the result into the <code>AtomicPtr</code>.</p>",
        "id": 194742820,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587422796
    },
    {
        "content": "<p>If a shared owner of the MIR loses a compare-and-swap, they throw away their copy of the predecessor cache and <code>load</code> the one that won the race.</p>",
        "id": 194743119,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587423039
    },
    {
        "content": "<p>Since we always know who is responsible for freeing the cache, there's no need for hazard pointers or epoch-based reclamation or other approaches.</p>",
        "id": 194743177,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587423107
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ^</p>",
        "id": 194743874,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587423691
    },
    {
        "content": "<p>I guess the single-threaded version of this is <code>Cell&lt;Option&lt;PredecessorCache&gt;&gt;</code> with <code>Cell::set</code>/<code>Cell::get_mut</code>.</p>",
        "id": 194746165,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587425941
    },
    {
        "content": "<p>Err, no. That doesn't quite work. You need to be able to go from a shared reference to the <code>Cell</code> to a shared reference to the predecessor cache.</p>",
        "id": 194746712,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587426471
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> sure, that's kind of a micro-optimization though. THe main thing I wanted was a <code>Mutex&lt;Arc&lt;PredecessorData&gt;&gt;</code> and an API like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">predecessor_map</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Arc</span><span class=\"o\">&lt;</span><span class=\"n\">PredecessorData</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* lazilly compute and return */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 194823545,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484728
    },
    {
        "content": "<p>it would <em>also</em> be ok to use a CAS, but I'm not very concerned</p>",
        "id": 194823570,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484739
    },
    {
        "content": "<p>I am surprised that the mutator always has <code>&amp;mut self</code>, maybe I don't understand what's going on</p>",
        "id": 194823598,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484751
    },
    {
        "content": "<p>the main thing I do <em>not</em> want is</p>",
        "id": 194823608,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484756
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">predecessor_map</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ReadGuard</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PredecessorData</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 194823644,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484772
    },
    {
        "content": "<p>I mean I guess it's not really possible to deadlock, since computing one set of predecessors can't in turn compute another set of predecessors</p>",
        "id": 194823751,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484803
    },
    {
        "content": "<p>but I still prefer the <code>Arc</code> setup because it's sort of <em>obvious</em> that it's fine...</p>",
        "id": 194823832,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484825
    },
    {
        "content": "<p>all that said, the biggest thing I want is clear docs on every mutex explaining </p>\n<ol>\n<li>Why it's there, who locks it and why</li>\n<li>Why it won't lead to deadlocks</li>\n</ol>\n<p>and further that every mutex is in a private field where one audit the accesses with relative ease</p>",
        "id": 194823919,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587484864
    },
    {
        "content": "<p>That's fine too. Do you want me to r- <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a>? I would prefer to let it land and then switch to <code>Mutex&lt;Arc&lt;PredecessorCache&gt;&gt;</code> in a follow-up PR since <a href=\"https://github.com/rust-lang/rust/issues/71044\" title=\"https://github.com/rust-lang/rust/issues/71044\">#71044</a> is liable to bitrot. AFAIK, we never actually access the predecessor cache for a MIR body concurrently from different threads, so deadlock won't be an issue in the interim.</p>",
        "id": 194825687,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587485595
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 194828217,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587486693
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> I am fine with follow-up PR</p>",
        "id": 194831488,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587488217
    },
    {
        "content": "<p>and yeah it's not that I think there is an <em>actual</em> bug</p>",
        "id": 194831510,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587488230
    },
    {
        "content": "<p>it's that, in terms of the parallel work (which is sorta stalled, but yeah) we were going for \"guarantee that things are documented and as easily verified as possible\"</p>",
        "id": 194831544,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587488249
    },
    {
        "content": "<p>if you want to open an issue to track the refactoring that might be nice</p>",
        "id": 194831587,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587488274
    },
    {
        "content": "<p>For sure. I'm in full agreement with eliminating all potential sources of deadlock.</p>",
        "id": 194831600,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587488280
    },
    {
        "content": "<p>I'm working on the follow-up now XD, so an issue won't be necessary unless you want one for other reasons.</p>",
        "id": 194831699,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587488321
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/71392\" title=\"https://github.com/rust-lang/rust/issues/71392\">#71392</a></p>",
        "id": 194837030,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1587490781
    }
]