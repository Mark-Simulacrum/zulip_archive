[
    {
        "content": "<p>Not sure who all to bug about this -- maybe <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> would know -- but it seems to me like for the most part, dropck should be able to not care about substituting concrete types in for generics. Currently, we do, which leads to problems like in <a href=\"https://github.com/rust-lang/rust/issues/4287\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/4287\">https://github.com/rust-lang/rust/issues/4287</a></p>",
        "id": 175960700,
        "sender_full_name": "simulacrum",
        "timestamp": 1568765877
    },
    {
        "content": "<p>AFAICT though</p>\n<div class=\"codehilite\"><pre><span></span>enum Perfect&lt;T&gt; {\n    Tip(T),\n    Fork(Box&lt;Perfect&lt;(T, T)&gt;&gt;),\n}\n</pre></div>\n\n\n<p>should either pass dropck or not independent of what T is, right?</p>",
        "id": 175960757,
        "sender_full_name": "simulacrum",
        "timestamp": 1568765916
    },
    {
        "content": "<p>In particular, the documentation in <a href=\"https://doc.rust-lang.org/nightly/nomicon/dropck.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nomicon/dropck.html\">the nomicon</a> talks about how if T here was <code>&amp;'a i32</code> or so that could lead to problems, but since Drop impls must be equivalent to the struct definition, that seems like it shouldn't be a problem, right? i.e., either all T's are fine or none are, since dropck is overly conservative and \"assumes\" it has a <code>'a</code> in the T or so</p>",
        "id": 175960909,
        "sender_full_name": "simulacrum",
        "timestamp": 1568766094
    },
    {
        "content": "<p>I thought The problem in 4287 was due to the enum definition itself (namely the non-uniform type-recursion)</p>",
        "id": 175971801,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568784430
    },
    {
        "content": "<p>I’ll have to review the thread.</p>",
        "id": 175974980,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568788529
    },
    {
        "content": "<p>But I could imagine an issue arising with the dropck <em>implementation</em> due to the cyclic structure causing the compiler to loop</p>",
        "id": 175975052,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568788599
    },
    {
        "content": "<p>The dropck is very imprecise, I don't think it can reason about this</p>",
        "id": 175979747,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568793060
    },
    {
        "content": "<p>The issue in the nomicon is when you have a <code>&amp;'a i32</code> in a <code>Drop</code> the compiler does not know if the value it points to outlives the reference</p>",
        "id": 175979784,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568793109
    },
    {
        "content": "<p>because that would mean it would need to outlive Drop::drop</p>",
        "id": 175979852,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568793154
    },
    {
        "content": "<p>AFAIK we just bail here and require an unsafe Drop impl</p>",
        "id": 175980071,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568793391
    },
    {
        "content": "<p>I'm still trying to understand the original issue being raised. Is the question about why dropck is only failing at the point where one has a <em>use</em> (i.e. instantiation) of <code>Perfect</code> ?</p>",
        "id": 175984479,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568797083
    },
    {
        "content": "<p>That's how I understood the question</p>",
        "id": 175985503,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568798013
    },
    {
        "content": "<p>A drop impl for perfect isn't bad per se, but depending on how it is used, the issue raised by the nomicon can appear - but that issue is essentially how the borrowck handles drop</p>",
        "id": 175985574,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568798083
    },
    {
        "content": "<p>hmm. I am under the impression that dropck would fail in any <code>fn</code> body that attempts to instantiate <code>Perfect</code> with concrete types, regardless of what they are. But that is not what is implied by <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> 's question as I read it.</p>",
        "id": 175986544,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568798896
    },
    {
        "content": "<p>but yes, currently the dropck works by analyzing concrete expressions, not abstract type definitions, and so by its nature you won't get these errors from the <code>enum</code> definition alone.</p>",
        "id": 175986576,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568798938
    },
    {
        "content": "<p>My question is basically can dropck work, in theory, on type definitions, not concrete instantiations?</p>",
        "id": 175989750,
        "sender_full_name": "simulacrum",
        "timestamp": 1568801628
    },
    {
        "content": "<p>the problem in this case, in theory, should be detected on the type definition</p>",
        "id": 175989959,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568801870
    },
    {
        "content": "<p>In particular, I would expect us to be able to not check Perfect recursively; my assertion is that dropck should pass for any T in Perfect, i.e. that for all types T, U, dropck(Perfect&lt;T&gt;) = dropck(Perfect&lt;U&gt;). I'm not sure if this is true today, to be clear, I'm just saying that it seems like a correct impl of dropck could satisfy this property</p>",
        "id": 175989967,
        "sender_full_name": "simulacrum",
        "timestamp": 1568801879
    },
    {
        "content": "<p>because its fundamentally a type definition that is going to cause subsequent analyses to infinite loop</p>",
        "id": 175990010,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568801888
    },
    {
        "content": "<p>but the assertion  I am making there is not about dropck; it is about the nature of polymorphic recursion</p>",
        "id": 175990037,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568801924
    },
    {
        "content": "<p>I personally wouldn't expect a dropck error on this type</p>",
        "id": 175990041,
        "sender_full_name": "simulacrum",
        "timestamp": 1568801932
    },
    {
        "content": "<p>If my understanding of how dropck could work is correct</p>",
        "id": 175990070,
        "sender_full_name": "simulacrum",
        "timestamp": 1568801959
    },
    {
        "content": "<p>I want to be clear here: dropck is not rejecting this code, AFAIK. It is causing the compiler to <em>infinite loop</em></p>",
        "id": 175990072,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568801962
    },
    {
        "content": "<p>and that is because our attempt to detect cycles on the fly within dropck is not smart enough to catch cases like this</p>",
        "id": 175990101,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568801998
    },
    {
        "content": "<p>Right, well, loop really slowly - it will terminate due to the type depth limit</p>",
        "id": 175990141,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802003
    },
    {
        "content": "<p>okay, sure.</p>",
        "id": 175990162,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802012
    },
    {
        "content": "<p>I don't consider that to be \"dropck is rejecting this code\"</p>",
        "id": 175990172,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802022
    },
    {
        "content": "<p>I consider that to be \"the type definition is causing the compiler to have fits\"</p>",
        "id": 175990197,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802043
    },
    {
        "content": "<p>I suppose it is a somewhat subtle/subjective judgement</p>",
        "id": 175990204,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802057
    },
    {
        "content": "<p>Okay, sure. But am I correct that dropck could work without any problems here, and in all cases, solely by analyzing the definition of Perfect?</p>",
        "id": 175990241,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802101
    },
    {
        "content": "<p>anyway, dropck, or at least part of it, is about analyzing how a concrete variable (of a given type) is used in a body of code. So no, you cannot do all of dropck solely by analyzing the type definition</p>",
        "id": 175990296,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802147
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> you keep mentioning this desired property that all types T, U, dropck(Perfect&lt;T&gt;) = dropck(Perfect&lt;U&gt;). But this confuses me, because, as far as I can tell, dropck <em>is</em> behaving the same here regardless of how you instantiate <code>Perfect</code>: it is infinite looping for any choice of <code>T</code>/<code>U</code>, (or rather hitting type depth limit), right?</p>",
        "id": 175990418,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802250
    },
    {
        "content": "<p>Kind of - I mention that because if it's true, then I would expect us to be able to avoid the looping by keeping the output of dropck generic</p>",
        "id": 175990485,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802318
    },
    {
        "content": "<p>My personal claim is that we could, and should, add an <em>extra</em> analysis (that would run long before <code>dropck</code>) of type definitions like that of <code>Perfect</code> that would reject them as exhibiting non-uniform recursion (aka polymorphic recursion)</p>",
        "id": 175990510,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802351
    },
    {
        "content": "<p>which is what <a href=\"https://github.com/rust-lang/rust/issues/4287\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/4287\">#4287</a> is about, or at least is my interpretation of it</p>",
        "id": 175990568,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802384
    },
    {
        "content": "<p>Why should we reject such types? Is it just \"we're not ready to handle them yet\"?</p>",
        "id": 175990578,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802395
    },
    {
        "content": "<p>I guess I was coming at this from the perspective that a good fix is to make this code compile, not fail with a nice error message</p>",
        "id": 175990627,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802444
    },
    {
        "content": "<p>well if any use of the type implies you need an infinite set of instantiations</p>",
        "id": 175990633,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802451
    },
    {
        "content": "<p>then you have a problem</p>",
        "id": 175990635,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802456
    },
    {
        "content": "<p>Languages that handle polymorphic recursion do it, as far as I know, by building method dictionaries at runtime</p>",
        "id": 175990689,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802484
    },
    {
        "content": "<p>but we use static monomorphization</p>",
        "id": 175990698,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802498
    },
    {
        "content": "<p>so you need to build all your vtables at compile time</p>",
        "id": 175990709,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802512
    },
    {
        "content": "<p>see e.g. <a href=\"https://github.com/rust-lang/rust/issues/4287#issuecomment-218304293\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/4287#issuecomment-218304293\">https://github.com/rust-lang/rust/issues/4287#issuecomment-218304293</a></p>",
        "id": 175990741,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802537
    },
    {
        "content": "<p>of course some people do point out that one might be able to handle some instances (via a form of type erasure, so that a single vtable would suffice for an infinite number of instantiations)</p>",
        "id": 175990792,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802571
    },
    {
        "content": "<p>Hm, okay, I think I understand now. So the action item here is to implement another type ck pass which will reject Perfect by indicating polymorphic recursion?</p>",
        "id": 175990797,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802573
    },
    {
        "content": "<p>Yes, that is what I believe the action item to be</p>",
        "id": 175990805,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802587
    },
    {
        "content": "<p>Okay, makes sense.</p>",
        "id": 175990910,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802654
    },
    {
        "content": "<p>I will take a look at an implementation then</p>",
        "id": 175990948,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802687
    },
    {
        "content": "<p>this is not a trivial analysis, though</p>",
        "id": 175990950,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802689
    },
    {
        "content": "<p>mainly because of cases where it arises due to mutual recursion between a set of distinct struct/enum definitions</p>",
        "id": 175990980,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802721
    },
    {
        "content": "<p>I don't think it's trivial, but I'm thinking that some sort of approach that avoids directly instantiating a T would work - basically, keeping track of loops at the non-subst applied type</p>",
        "id": 175991104,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802829
    },
    {
        "content": "<p>yes, we would definitely want a solution that works without needing to instantiate a <code>T</code>, I think.</p>",
        "id": 175991163,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802858
    },
    {
        "content": "<p>It seems like even a non-perfect pass would already be an improvement, too</p>",
        "id": 175991232,
        "sender_full_name": "simulacrum",
        "timestamp": 1568802918
    },
    {
        "content": "<p>sure</p>",
        "id": 175991274,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568802957
    },
    {
        "content": "<p>In theory I think once we have it the depth limits elsewhere could for the most part be raised/removed, too, right?</p>",
        "id": 175991421,
        "sender_full_name": "simulacrum",
        "timestamp": 1568803033
    },
    {
        "content": "<p>maybe</p>",
        "id": 175991430,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568803048
    },
    {
        "content": "<p>or</p>",
        "id": 175991434,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568803050
    },
    {
        "content": "<p>yes</p>",
        "id": 175991435,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568803052
    },
    {
        "content": "<p>probably</p>",
        "id": 175991441,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568803055
    },
    {
        "content": "<p>i don't know</p>",
        "id": 175991443,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568803057
    },
    {
        "content": "<p><span aria-label=\"smile\" class=\"emoji emoji-263a\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 175991446,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568803063
    },
    {
        "content": "<p>I guess they could still catch other cases - bugs in compiler, or so</p>",
        "id": 175991506,
        "sender_full_name": "simulacrum",
        "timestamp": 1568803097
    },
    {
        "content": "<p>Anyway, I need to run, thanks for clarifying things for me</p>",
        "id": 175991542,
        "sender_full_name": "simulacrum",
        "timestamp": 1568803149
    },
    {
        "content": "<p>dropck(Perfect&lt;T&gt;) is not really a thing</p>",
        "id": 175991829,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568803369
    },
    {
        "content": "<p>Depending on how an expression uses the type, the expression might be incorrect, e.g., because the type might be missing an <code>unsafe Drop</code> impl</p>",
        "id": 175991871,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568803419
    },
    {
        "content": "<p>We can't know that from looking at <code>Perfect&lt;T&gt;</code></p>",
        "id": 175991890,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568803441
    },
    {
        "content": "<p>So what dropck a looks at are expressions using <code>Perfect&lt;T&gt;</code></p>",
        "id": 175992071,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568803572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> my impression is that dropck for Perfect&lt;T&gt; at best would return \"perfect is good, also, check Box&lt;Perfect&lt;(T, T)&gt;&gt;</p>",
        "id": 175992337,
        "sender_full_name": "simulacrum",
        "timestamp": 1568803845
    },
    {
        "content": "<p>And T I guess</p>",
        "id": 175992350,
        "sender_full_name": "simulacrum",
        "timestamp": 1568803869
    },
    {
        "content": "<p>What would dropck check for a type ?</p>",
        "id": 175992354,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568803876
    },
    {
        "content": "<p>Hm, well, it could conclude for a type with Phantom Data that it's just fine</p>",
        "id": 175992410,
        "sender_full_name": "simulacrum",
        "timestamp": 1568803925
    },
    {
        "content": "<p>If I recall that bit correctly</p>",
        "id": 175992423,
        "sender_full_name": "simulacrum",
        "timestamp": 1568803942
    },
    {
        "content": "<p>PhantomData&lt;T&gt; just says, this type should look like it owns a T</p>",
        "id": 175992467,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804035
    },
    {
        "content": "<p>but whether it matters will depend on whether the type actually has a Drop impl or not</p>",
        "id": 175992551,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804096
    },
    {
        "content": "<p>and also about how the type is actually used</p>",
        "id": 175992589,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804137
    },
    {
        "content": "<p>the dropck will say for some function, that that function uses the type correctly</p>",
        "id": 175992595,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804153
    },
    {
        "content": "<p>but for a different one, that it uses it incorrectly</p>",
        "id": 175992597,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804160
    },
    {
        "content": "<p>Sure - there's two parts to dropck though afaict, the generic piece and the concrete piece</p>",
        "id": 175992704,
        "sender_full_name": "simulacrum",
        "timestamp": 1568804237
    },
    {
        "content": "<p>Oh, yeah, I remembered why we treated phantom specially, it's because it doesn't have fields</p>",
        "id": 175992720,
        "sender_full_name": "simulacrum",
        "timestamp": 1568804269
    },
    {
        "content": "<p>Not only, the phantomdata also says that this type has data of type T</p>",
        "id": 175992771,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804304
    },
    {
        "content": "<p>and that information is used when evaluating whether a Drop impl is correct or not</p>",
        "id": 175992785,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804322
    },
    {
        "content": "<p>See here (<a href=\"https://doc.rust-lang.org/nomicon/dropck.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nomicon/dropck.html\">https://doc.rust-lang.org/nomicon/dropck.html</a>):</p>\n<blockquote>\n<p>For a generic type to soundly implement drop, its generics arguments must strictly outlive it.</p>\n</blockquote>",
        "id": 175992812,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804369
    },
    {
        "content": "<p>If you are taking references, that's always the case if the reference is <code>'static</code>, but if you have a <code>&lt;'a&gt;</code>, then you can't know just by looking at the type</p>",
        "id": 175992878,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804413
    },
    {
        "content": "<p>Each time the type is used, a different lifetime is passed, and depending on what the code does, the value passed might or might not outlive the type</p>",
        "id": 175992904,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804446
    },
    {
        "content": "<p>(it also depends on <code>#[may_dangle]</code>, etc.)</p>",
        "id": 175993058,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804624
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/8bf776d5c2fc88624d2562e493aab0d324a3b7d8/src/librustc_typeck/check/dropck.rs#L236\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/8bf776d5c2fc88624d2562e493aab0d324a3b7d8/src/librustc_typeck/check/dropck.rs#L236\">https://github.com/rust-lang/rust/blob/8bf776d5c2fc88624d2562e493aab0d324a3b7d8/src/librustc_typeck/check/dropck.rs#L236</a></p>",
        "id": 175993259,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804864
    },
    {
        "content": "<p>The dropck is like the borrowck, it works on expressions</p>",
        "id": 175993324,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568804917
    },
    {
        "content": "<p>Right, but it seems like \"generic arguments must strictly outlive\" can be checked without recursing into the type, whereas the current implementation does recurse</p>",
        "id": 175994389,
        "sender_full_name": "simulacrum",
        "timestamp": 1568805894
    },
    {
        "content": "<p>Okay so its possible that part of my (our?) confusion in this conversation is arising because there are multiple things that one might say are computed as part of so-called \"dropck\"</p>",
        "id": 175995663,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568806859
    },
    {
        "content": "<p>There is are two main things I can think of, off the top of my head</p>",
        "id": 175995717,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568806904
    },
    {
        "content": "<p>1. the checking that a destructor doesn't run at a time where there may be a dangling pointer. This is fundamentally connecting to analyzing expressions</p>",
        "id": 175995742,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568806919
    },
    {
        "content": "<p>(and may be why <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> and I are both confused by the idea of doing dropck on the type declaration alone)</p>",
        "id": 175995807,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568806951
    },
    {
        "content": "<p>2. the implied outlives bounds (and maybe also \"strictly outlives\" stuff discussed in the dropck RFC) that arise on the type parameters of a type due to that type, or some type reachable via its fields, implementing <code>Drop</code></p>",
        "id": 175995874,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807003
    },
    {
        "content": "<p>Yes, I think the code I was talking about mostly looks at (2) -- in some sense, (1) is less interesting, as I would imagine it is sort of \"part\" of borrowck, in that it does very similar work</p>",
        "id": 175996074,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807137
    },
    {
        "content": "<p>that second thing sounds more like what <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> is saying they would expect to be derived from an analysis of the type definition alone.</p>",
        "id": 175996083,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807147
    },
    {
        "content": "<p>I guess I'm also saying that the first should be able to re-use information from the second, too</p>",
        "id": 175996204,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807223
    },
    {
        "content": "<p>i.e., we should not need to recursively visit fields when dropck-ing an expression, rather just query \"what types are needed to outlive for this to drop\"</p>",
        "id": 175996234,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807247
    },
    {
        "content": "<p>just catching up on the discussion: there seem like there are two issues here<br>\n- type definitions that require an infinite list of instantiations (e.g. <code>T1&lt;T2&lt;T1&lt;...</code>) through polymorphic recursion<br>\n- dropck not handling polymorphic recursion (even the finite kind) properly</p>",
        "id": 175996245,
        "sender_full_name": "varkor",
        "timestamp": 1568807258
    },
    {
        "content": "<p><code>Perfect</code>, for instance, doesn't seem to require an infinite list of instantiations, and looks fine in theory</p>",
        "id": 175996323,
        "sender_full_name": "varkor",
        "timestamp": 1568807286
    },
    {
        "content": "<p>so it seems like an implementation flaw more than a design flaw</p>",
        "id": 175996330,
        "sender_full_name": "varkor",
        "timestamp": 1568807290
    },
    {
        "content": "<p>FWIW, this type <code>struct&lt;'a&gt;(*mut &amp;'a T)</code> contains a type parameter, but no reference</p>",
        "id": 175996343,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807304
    },
    {
        "content": "<p>So one really needs to check whether any field actually stores a reference AFAICT (that does not mean that one needs to recurse forever to determine that for Perfect though)</p>",
        "id": 175996382,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807345
    },
    {
        "content": "<p>Yes, but the (2) pass could tell us that said type does not depend on T</p>",
        "id": 175996386,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807348
    },
    {
        "content": "<p>i.e. does not need to outlive T</p>",
        "id": 175996397,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807358
    },
    {
        "content": "<p>why is dropck something that's not part of the type system?</p>",
        "id": 175996407,
        "sender_full_name": "varkor",
        "timestamp": 1568807372
    },
    {
        "content": "<p>it seems we could have more details lifetimes</p>",
        "id": 175996416,
        "sender_full_name": "varkor",
        "timestamp": 1568807377
    },
    {
        "content": "<p>e.g. <code>'a.'b</code> for fine-grained ordering</p>",
        "id": 175996429,
        "sender_full_name": "varkor",
        "timestamp": 1568807390
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> I'm not sure we can compile <code>Perfect</code> today, even if we side-stepped dropck.</p>",
        "id": 175996460,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807403
    },
    {
        "content": "<p>one part should be part of borrowck, and the other of typeck</p>",
        "id": 175996466,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807403
    },
    {
        "content": "<p>which would then allow us to do the dropck analysis on the types rather than the expressions</p>",
        "id": 175996491,
        "sender_full_name": "varkor",
        "timestamp": 1568807407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span>: integrating with both typeck and borrowck</p>",
        "id": 175996562,
        "sender_full_name": "varkor",
        "timestamp": 1568807467
    },
    {
        "content": "<blockquote>\n<p>Perfect, for instance, doesn't seem to require an infinite list of instantiations, and looks fine in theory</p>\n</blockquote>\n<p>I was convinced this is not true by <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span>'s argument that we'd need to codegen methods for Perfect&lt;(i32, i32)&gt; and Perfect&lt;((i32, i32), (i32, i32))&gt; etc</p>",
        "id": 175996563,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807468
    },
    {
        "content": "<p>since, <em>i think</em>, compiling <code>{ let a: Perfect&lt;u32&gt;; ... }</code> would requiring emitting glue code to drop <code>Box&lt;Perfect&lt;(u32, u32)&gt;&gt;</code> ... and <code>Box&lt;Perfect&lt;((u32, u32), (u32, u32))&gt;&gt;</code>. etc</p>",
        "id": 175996575,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807489
    },
    {
        "content": "<p>this is why I brought up the need to create vtables at runtime.</p>",
        "id": 175996591,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807509
    },
    {
        "content": "<p>ah, I see</p>",
        "id": 175996594,
        "sender_full_name": "varkor",
        "timestamp": 1568807516
    },
    {
        "content": "<p>Languages that handle method-dispatch by passing along a dictionary can do this</p>",
        "id": 175996649,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807538
    },
    {
        "content": "<p>but doing that still does not require dropck to infinitely recurse right ?</p>",
        "id": 175996650,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807541
    },
    {
        "content": "<p>as in, maybe codegen fails later due to this</p>",
        "id": 175996659,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807552
    },
    {
        "content": "<p>but neither of dropck passes should fail</p>",
        "id": 175996675,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807567
    },
    {
        "content": "<p>(and I could imagine a new Rust calling ABI that would pass along a dictionary, and then dynamically create new ones when necessary)</p>",
        "id": 175996676,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807569
    },
    {
        "content": "<p>Yes, I think we agree that <em>dropck</em> should maybe not fail on this type (it seems to satisfy dropck requirements), but we should provide a good error regardless</p>",
        "id": 175996678,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> yes, I agree that the fact that dropck is infinitely recursing is a bug <em>somewhere</em></p>",
        "id": 175996697,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807588
    },
    {
        "content": "<p>maybe its worth it to consider these as separate bugs and fill them separately</p>",
        "id": 175996722,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807605
    },
    {
        "content": "<p>but my claim is that my ideal approach would be to detect the polymorphic recursion (at the point where the type is declared)</p>",
        "id": 175996723,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807607
    },
    {
        "content": "<p>and error on it</p>",
        "id": 175996726,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807610
    },
    {
        "content": "<p>the issue discussing Perfect is quite long</p>",
        "id": 175996728,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807613
    },
    {
        "content": "<p>rather than attempting to generalize dropck to handle cases that should not arise in the first place.</p>",
        "id": 175996737,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807625
    },
    {
        "content": "<p>ah, dunno</p>",
        "id": 175996744,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807639
    },
    {
        "content": "<p>Yes, I agree -- it seems like there's just the one bug here, we don't have a polymorphic recursion detector</p>",
        "id": 175996784,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807643
    },
    {
        "content": "<p>that's kind of a lang team thing</p>",
        "id": 175996788,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807645
    },
    {
        "content": "<p>is there no case of polymorphic recursion that we support ?</p>",
        "id": 175996807,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807659
    },
    {
        "content": "<p>I think it's just a matter of diagnostics?</p>",
        "id": 175996810,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807661
    },
    {
        "content": "<p>To my knowledge you can't polymorphically recurse today without leading to dropck problems</p>",
        "id": 175996830,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807676
    },
    {
        "content": "<p>I think the lack of polymorphic recursion is a compiler limitation, and choosing to forbid it is a lang decision</p>",
        "id": 175996843,
        "sender_full_name": "varkor",
        "timestamp": 1568807686
    },
    {
        "content": "<p>But we already forbid it today? Like, it would be a lang team decision to do the work to enable it, but we're talking about providing a better lint</p>",
        "id": 175996875,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807712
    },
    {
        "content": "<p>from a user's perspective, if there aren't special drop rules for <code>Perfect</code>, it doesn't really make sense that you can't define it</p>",
        "id": 175996877,
        "sender_full_name": "varkor",
        "timestamp": 1568807714
    },
    {
        "content": "<p>we don't forbid it – it just doesn't work</p>",
        "id": 175996892,
        "sender_full_name": "varkor",
        "timestamp": 1568807726
    },
    {
        "content": "<p>e.g. Perfect&lt;T: Foo&gt;  { one(T), Second(Perfect&lt;(T::Other, T::Other)&gt;) }</p>",
        "id": 175996900,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807731
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> the problem is that we don't today forbid the type declaration</p>",
        "id": 175996905,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807737
    },
    {
        "content": "<p>we just fail to handle uses of it</p>",
        "id": 175996919,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807750
    },
    {
        "content": "<p>Right, we could structure the lint to only error on invalid uses, in theory</p>",
        "id": 175996921,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807751
    },
    {
        "content": "<p>where at some point you get a tuple that implements Foo and Foo::Other = ! (and you keep recursing creating tuples of ! after that point, but that doesn't do anything)</p>",
        "id": 175996923,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807751
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> that seems like a harder case, but yes, in theory, although I'm not entirely sure we'd handle ((!, !), (!, !))... etc well either</p>",
        "id": 175997013,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807807
    },
    {
        "content": "<p>maybe just  `Perfect&lt;T: Foo&gt; { one(T), Second(T::Other) }  where T::Other could be Perfect&lt;..&gt; and at some point some T::Other is just () stopping recursion</p>",
        "id": 175997038,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807835
    },
    {
        "content": "<p>Sure, yeah. Given something like that we do need to check concrete instantiations</p>",
        "id": 175997059,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807861
    },
    {
        "content": "<p>that recursion is not infinite though</p>",
        "id": 175997070,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807876
    },
    {
        "content": "<p>But it does seem like we can detect the Perfect case as-is and error out rather than stalling</p>",
        "id": 175997076,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807880
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> wait, what was your example meant to show?</p>",
        "id": 175997081,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807882
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 175997121,
        "sender_full_name": "varkor",
        "timestamp": 1568807886
    },
    {
        "content": "<p>that its hard to detect the error in all cases? (without breaking valid code, that is)</p>",
        "id": 175997126,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807892
    },
    {
        "content": "<p>e.g. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=70084f5ad3f6ca8d931285551b1d465a\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=70084f5ad3f6ca8d931285551b1d465a\">this</a> compiles.</p>",
        "id": 175997142,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807905
    },
    {
        "content": "<p>and thus you wouldn't want to reject it.</p>",
        "id": 175997151,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807916
    },
    {
        "content": "<p>so how is that different than the original example ?</p>",
        "id": 175997206,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568807980
    },
    {
        "content": "<p>(note that this is <strong>not</strong> an re-encoding of the <code>Perfect</code> example we are discussing. in particular it changes associated type for the tuple to u32, thus avoiding infinite regress)</p>",
        "id": 175997207,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568807983
    },
    {
        "content": "<p>Sure, yes. Though I would argue that we should be able to detect that there's a difference between this and the original Perfect</p>",
        "id": 175997217,
        "sender_full_name": "simulacrum",
        "timestamp": 1568807988
    },
    {
        "content": "<p>ah yes</p>",
        "id": 175997330,
        "sender_full_name": "gnzlbg",
        "timestamp": 1568808042
    },
    {
        "content": "<p>(I should have alpha-renamed <code>Perfect</code> before sharing it)</p>",
        "id": 175997362,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808061
    },
    {
        "content": "<p>(I suspect that higher-kinded types, and how they are currently expressed via associated items, are going to be the big hurdle to overcome in an attempt to detect polymorphic recursion solely via analysis of the type declarations.)</p>",
        "id": 175997450,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808135
    },
    {
        "content": "<p>seems like, in theory, if we could express <code>T: !Drop</code>, then the recursion wouldn't be an issue?</p>",
        "id": 175997493,
        "sender_full_name": "varkor",
        "timestamp": 1568808180
    },
    {
        "content": "<p>I think our belief is that _even if_ dropck didn't error here, that wouldn't matter</p>",
        "id": 175997522,
        "sender_full_name": "simulacrum",
        "timestamp": 1568808213
    },
    {
        "content": "<p>we would error somewhere else</p>",
        "id": 175997528,
        "sender_full_name": "simulacrum",
        "timestamp": 1568808225
    },
    {
        "content": "<p>I mean in terms of generating infinite impls during monomorphisation</p>",
        "id": 175997531,
        "sender_full_name": "varkor",
        "timestamp": 1568808227
    },
    {
        "content": "<p>Well, even if T is not Drop, Box&lt;T&gt; is, so you need to codegen infinite impls for Box, right?</p>",
        "id": 175997584,
        "sender_full_name": "simulacrum",
        "timestamp": 1568808249
    },
    {
        "content": "<blockquote>\n<p>Sure, yes. Though I would argue that we should be able to detect that there's a difference between this and the original Perfect</p>\n</blockquote>\n<p>Yes, I do believe we should be able to catch infinitely-regressing polymorphic recursion as exemplified in the original <code>Perfect&lt;T&gt; { Tip(T), Fork(Box&lt;Perfect&lt;(T, T)&gt;&gt;) }</code> via some semi-straight-forward analysis.</p>",
        "id": 175997591,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808255
    },
    {
        "content": "<blockquote>\n<p>Well, even if T is not Drop, Box&lt;T&gt; is, so you need to codegen infinite impls for Box, right?</p>\n</blockquote>\n<p>I suppose anywhere we call a method on the generic parameter, it's going to start recursing...</p>",
        "id": 175997619,
        "sender_full_name": "varkor",
        "timestamp": 1568808288
    },
    {
        "content": "<p>yeah, I think it is safe to forbid types of the pattern <code>Perfect&lt;T&gt; { Tip(T), Fork(Box&lt;Perfect&lt;(T, T)&gt;&gt;) }</code> -- yes, there are similar-looking but not actually wrong patterns, but if we can avoid those then that's good</p>",
        "id": 175997670,
        "sender_full_name": "simulacrum",
        "timestamp": 1568808338
    },
    {
        "content": "<p>I actually think <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span>  has the right intuition</p>",
        "id": 175997797,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808438
    },
    {
        "content": "<p>in that, if you can get rid of the drop-glue</p>",
        "id": 175997810,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808455
    },
    {
        "content": "<p>then the problem does go away</p>",
        "id": 175997815,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808459
    },
    {
        "content": "<p>_for dropck_ yes, but not for arbitrary (recursive?) methods, right?</p>",
        "id": 175997956,
        "sender_full_name": "simulacrum",
        "timestamp": 1568808562
    },
    {
        "content": "<p>heh</p>",
        "id": 175998120,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808638
    },
    {
        "content": "<p>Though one could imagine that would be orthogonal, and for drop-glue of Box for example we have the #[may_dangle] on T so in theory there's just one impl (though that could be a lie, due to being compiler-implemented</p>",
        "id": 175998130,
        "sender_full_name": "simulacrum",
        "timestamp": 1568808650
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">enum</span> <span class=\"nc\">Perfect</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Tip</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Fork</span><span class=\"p\">(</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">Perfect</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Perfect</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// impl&lt;(T, T)&gt;</span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Perfect</span>::<span class=\"n\">Tip</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"k\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// impl&lt;u32&gt;</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 175998151,
        "sender_full_name": "varkor",
        "timestamp": 1568808671
    },
    {
        "content": "<p>something like this presents the problem even without dropck, I think</p>",
        "id": 175998169,
        "sender_full_name": "varkor",
        "timestamp": 1568808691
    },
    {
        "content": "<p>ah</p>",
        "id": 175998240,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808721
    },
    {
        "content": "<p>I was trying to make an examle</p>",
        "id": 175998283,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808726
    },
    {
        "content": "<p>but I was putting <code>#[derive(Debug)]</code> on <code>enum Perfect</code></p>",
        "id": 175998300,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808741
    },
    {
        "content": "<p>and that was a no-no</p>",
        "id": 175998313,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808745
    },
    {
        "content": "<p>or ..</p>",
        "id": 175998333,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808763
    },
    {
        "content": "<p>well never mind, let me wait until I actually get this example to work</p>",
        "id": 175998354,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568808778
    },
    {
        "content": "<p>okay this seems weird to me: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=cd7f7628072a2e14e0967a259150d4ca\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=cd7f7628072a2e14e0967a259150d4ca\">badness</a></p>",
        "id": 175998642,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809001
    },
    {
        "content": "<p>sorry, add a call to the <code>but_this_doesnt</code> from main to see the \"error\", if it can be called that (is it a timeout?)</p>",
        "id": 175998699,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809063
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d6026a8d14d2741dc9fb8b18c2bec3f5\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d6026a8d14d2741dc9fb8b18c2bec3f5\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d6026a8d14d2741dc9fb8b18c2bec3f5</a></p>",
        "id": 175998713,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809073
    },
    {
        "content": "<p>hm, yeah, it compiles locally</p>",
        "id": 175998813,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809134
    },
    {
        "content": "<p>so I suspect memory limit I think</p>",
        "id": 175998817,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809140
    },
    {
        "content": "<p>timeout usually gives a different error</p>",
        "id": 175998827,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809151
    },
    {
        "content": "<p>yikes</p>",
        "id": 175998836,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809159
    },
    {
        "content": "<p>(we give like 100MB or so on play, so that's not too surprising)</p>",
        "id": 175998861,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809182
    },
    {
        "content": "<p>113 MB at max used based on local testing</p>",
        "id": 175998965,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809220
    },
    {
        "content": "<p>so just over</p>",
        "id": 175998969,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809222
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=dc4224992e936c8bc1b4d1d2f884bf2a\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=dc4224992e936c8bc1b4d1d2f884bf2a\">this</a> is what I wanted to demo, in that it shows a value being constructed</p>",
        "id": 175998974,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809225
    },
    {
        "content": "<p>and then calling a method on it</p>",
        "id": 175998978,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809230
    },
    {
        "content": "<p>ah, release mode compiles in playpen</p>",
        "id": 175998999,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809246
    },
    {
        "content": "<p>that case compiles locally for me as well, yes, though it's worth noting that we would not consider this a problem from e.g. dropck due to the indirection</p>",
        "id": 175999048,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809314
    },
    {
        "content": "<p>and okay, you get problems if you try to call the generate fmt::Debug routine for the <code>Fork</code> variant's payload</p>",
        "id": 175999096,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809330
    },
    {
        "content": "<p>Right, you can't instantiate anything that treats this generically I'd guess and calls \"itself\"</p>",
        "id": 175999119,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809351
    },
    {
        "content": "<p>(<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=ca701faf47416b4c10479ee2296b0bbd\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=release&amp;edition=2018&amp;gist=ca701faf47416b4c10479ee2296b0bbd\">demo</a> of fmt::Debug infinite regress). Yes I agree with that</p>",
        "id": 175999156,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809384
    },
    {
        "content": "<blockquote>\n<p>though it's worth noting that we would not consider this a problem from e.g. dropck due to the indirection</p>\n</blockquote>\n<p>right; this is what I was trying to work my way towards when I said that I thought <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> had the right intuition about the problems here not arising if you're dealing with types that are <code>!Drop</code></p>",
        "id": 175999196,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809430
    },
    {
        "content": "<p>so that's an example where you <em>can</em> have polymorphic recursion today</p>",
        "id": 175999265,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809461
    },
    {
        "content": "<p>a lot of the standard stuff (like <code>derive(Debug)</code>) won't play well with it</p>",
        "id": 175999294,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809492
    },
    {
        "content": "<p>but that's not the same as \"not supported in the language.\"</p>",
        "id": 175999298,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809502
    },
    {
        "content": "<p>hm, sure, but you need to be sort of \"very careful\" and in fact, not actually have it</p>",
        "id": 175999308,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809507
    },
    {
        "content": "<p>i.e. if you attempt to use the fact you have it then it breaks :)</p>",
        "id": 175999319,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809519
    },
    {
        "content": "<p>why do you say \"not actually have it\" ?</p>",
        "id": 175999321,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809521
    },
    {
        "content": "<blockquote>\n<p>i.e. if you attempt to use the fact you have it then it breaks :)</p>\n</blockquote>\n<p>does that clarify?</p>",
        "id": 175999346,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809548
    },
    {
        "content": "<p>not sure yet</p>",
        "id": 175999354,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809554
    },
    {
        "content": "<p>my intuition is that the breakage I demoed there is more an artifact of how <code>derive</code> works</p>",
        "id": 175999412,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809575
    },
    {
        "content": "<p>let me try a manual impl to double check my own intuition</p>",
        "id": 175999416,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809585
    },
    {
        "content": "<p>well, I think it's because we're calling Debug::fmt on Perfect&lt;'a, X&gt;, which means we need to codegen impl for &amp;'a Perfect&lt;(X, X)&gt;</p>",
        "id": 175999443,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809633
    },
    {
        "content": "<p>and so on</p>",
        "id": 175999449,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809638
    },
    {
        "content": "<p>right, but that's just because of the derive code</p>",
        "id": 175999454,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809655
    },
    {
        "content": "<p>in theory, you don't <em>have</em> to use a statically generated series of calls to do the debug formatting</p>",
        "id": 175999465,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809667
    },
    {
        "content": "<p>I don't see how you could implement it differently? Like, there's no way to observe polymorphic recursion otherwise, right?</p>",
        "id": 175999467,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809674
    },
    {
        "content": "<p>unless you mean like passing in *mut () that magically knows how to deal with it by at runtime generating the impl.. but that seems ~impossible to get right without compiler knowledge</p>",
        "id": 175999534,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809720
    },
    {
        "content": "<p>sort of a #[may_dangle] for arbitrary impls, I guess, in some sense</p>",
        "id": 175999554,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809747
    },
    {
        "content": "<p>I guess I'm envisaging someone implementing their own dictionary passing</p>",
        "id": 175999590,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809787
    },
    {
        "content": "<p>which, okay, is at runtime generating the impl</p>",
        "id": 175999618,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809798
    },
    {
        "content": "<p>but I'm not so sure it needs compiler magic</p>",
        "id": 175999672,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568809810
    },
    {
        "content": "<p>You can't know the layout of the enum/struct/etc to be able to access the fields and recurse polymorphically, right?</p>",
        "id": 175999707,
        "sender_full_name": "simulacrum",
        "timestamp": 1568809853
    },
    {
        "content": "<p>i'm not being clear; I'm still not convinced you would need to resort to such low-level trickery</p>",
        "id": 176000037,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568810130
    },
    {
        "content": "<p>but I also have failed to make a working example</p>",
        "id": 176000042,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568810137
    },
    {
        "content": "<p>so I'll spend a few more minutes playing around, and if that goes nowhere, I'll abandon ship</p>",
        "id": 176000080,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568810163
    },
    {
        "content": "<p>hm, sounds good. I guess I don't see how you could avoid low-level trickery if you want to recursively visit or so</p>",
        "id": 176000201,
        "sender_full_name": "simulacrum",
        "timestamp": 1568810262
    },
    {
        "content": "<p>okay, its definitely not <em>simple</em>, since, as we've already covered, you cannot rely on the compiler to generate the infinite set of type instantiations for you at compile time</p>",
        "id": 176000211,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568810276
    },
    {
        "content": "<p>that's what I was trying to get at -- you'd need to do so at runtime (well, not infinite set, but the subset you \"need\") and in order to do so it seems like you need to know layout details for it to be useful</p>",
        "id": 176000440,
        "sender_full_name": "simulacrum",
        "timestamp": 1568810440
    },
    {
        "content": "<p>I suppose you _could_ generate a constant depth at compiletime and call those methods</p>",
        "id": 176000455,
        "sender_full_name": "simulacrum",
        "timestamp": 1568810456
    },
    {
        "content": "<p>that seems less useful though</p>",
        "id": 176000471,
        "sender_full_name": "simulacrum",
        "timestamp": 1568810475
    },
    {
        "content": "<p>anyway, I do think we can eke out a polymorphic recursion detector though maybe it won't be as pretty as I was envisioning since we need to be more concrete (due to not actually wanting to forbid the type itself, only instantiations of it), but that seems mostly fine</p>",
        "id": 176000565,
        "sender_full_name": "simulacrum",
        "timestamp": 1568810540
    },
    {
        "content": "<p>it's subtle if you want to detect instantiations, because they might be generated by <code>#[derive(Debug)]</code>, etc.</p>",
        "id": 176000796,
        "sender_full_name": "varkor",
        "timestamp": 1568810735
    },
    {
        "content": "<p>so the diagnostics are going to have to be quite clever</p>",
        "id": 176000812,
        "sender_full_name": "varkor",
        "timestamp": 1568810747
    },
    {
        "content": "<p>I bet you could still do quite well in analyzing the type itself and just looking for where you see mixing of drop with polymorphic recursion</p>",
        "id": 176002391,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568811800
    },
    {
        "content": "<p>basically focus on the cases where the drop-glue is going to be impossible to emit</p>",
        "id": 176002472,
        "sender_full_name": "pnkfelix",
        "timestamp": 1568811845
    },
    {
        "content": "<p>Indeed, it won't catch everything but that's probably okay</p>",
        "id": 176006882,
        "sender_full_name": "simulacrum",
        "timestamp": 1568814822
    }
]