[
    {
        "content": "<p>Hello, I'd like to gather opinions about adding new mingw-w64 targets (alongside <code>*-pc-windows-gnu</code>) but using purely LLVM tools instead of GCC+Binutils (<a href=\"https://github.com/rust-lang/rust/issues/72241\">#72241</a>).<br>\nThese targets are gaining popularity and Rust support is one of the missing pieces to make them fully viable.</p>\n<p>Some of the key differences between LLVM and GNU when targeting Windows with mingw-w64 as CRT:</p>\n<ul>\n<li>AArch64 support, LLVM unofficially supports it longer than it supports MSVC AArch64, GNU toolset doesn't support (and probably never will)</li>\n<li>LLVM libunwind and compiler-rt instead of libgcc, AFAIK their implementation differs internally and we don't want to mix two different unwind libraries</li>\n<li>proper and working native TLS instead of bugged emuTLS, this causes linking errors in C++ projects trying to mix Clang with GCC</li>\n<li>LLVM (and therefore LLD) uses modern short import lib format (just like MSVC) which is not supported properly by Binutils <code>ld.bfd</code></li>\n<li>sanitizers and profiling working OOTB</li>\n<li>UCRT instead of MSVCRT (again following MSVC), to be fair both toolchains can use either of them but GCC is often used with MSVCRT to avoid compatibility issues with existing libraries and most popular mingw-w64 + GNU toolchains</li>\n<li>better interop with Rust's LLVM backend (e.g. it doesn't require this hack: <a href=\"https://github.com/rust-lang/rust/issues/90782\">#90782</a>, already merged MSVC solution will work)</li>\n<li>small things other like working weak symbols in DLLs</li>\n</ul>\n<p>When it comes to target triple let's look at <code>*-windows-gnu</code> target. This is very clear since GNU (GCC + Binutils) tools can be used only with MinGW or mingw-w64 CRTs.<br>\nLLVM can use mingw-w64 or MSVC CRTs  so things like <code>*-windows-llvm</code> aren't good choice. Would really love some insight on how to name it.</p>\n<p>Projects providing LLVM mingw-w64 toolchains:<br>\n<a href=\"https://github.com/mstorsjo/llvm-mingw\">https://github.com/mstorsjo/llvm-mingw</a> - created and maintained by trusted LLVM developer<br>\n<a href=\"https://www.msys2.org/docs/environments/\">https://www.msys2.org/docs/environments/</a> - project providing prebuilt packages with <code>pacman</code> package manager</p>",
        "id": 267121778,
        "sender_full_name": "mati865",
        "timestamp": 1641506988
    },
    {
        "content": "<blockquote>\n<p>Would really love some insight on how to name it.</p>\n</blockquote>\n<p><code>*-mingw</code> should probably be somewhere in the name?<br>\nThe primary dichotomy with Windows targets is <code>*-msvc</code> vs <code>*-mingw</code>, target flavors inside these groups seems much closer to each other than to the other group.</p>\n<p>Not sure how all of this maps on <code>target_env</code>/<code>target_vendor</code>/<code>target_abi</code>/etc.<br>\nUWP targets currently follow the <code>x86_64-uwp-windows-gnu</code> naming with <code>uwp</code> in the vendor place - is it the right thing to do? Should the llvm-mingw based targets follow it?<br>\nI remember something like this was discussed somewhere last year or so, cc <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span></p>",
        "id": 267145388,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1641524001
    },
    {
        "content": "<p>I'm not sure if we have any other examples of targets that differ solely based on LLVM vs GCC. We certainly have the mingw vs MSVC targets.</p>",
        "id": 267145466,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641524082
    },
    {
        "content": "<p>I do think that we should avoid the use of meaningful vendor fields as much as possible.</p>",
        "id": 267145474,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641524104
    },
    {
        "content": "<p>I <em>think</em> the right answer might be something like <code>-windows-gnullvm</code> and <code>-windows-msvcllvm</code>.</p>",
        "id": 267145678,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641524388
    },
    {
        "content": "<p>Where <code>gnu</code> or <code>msvc</code> end up in the same place they currently do (so that existing code continues to detect the targets as expected) and the <code>llvm</code> bit perhaps ends up in <code>target_abi</code>.</p>",
        "id": 267146004,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1641524639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/131828-t-compiler/topic/LLVM.2Bmingw-w64.20Windows.20targets/near/267145388\">said</a>:</p>\n<blockquote>\n<p>UWP targets currently follow the <code>x86_64-uwp-windows-gnu</code> naming with <code>uwp</code> in the vendor place - is it the right thing to do? Should the llvm-mingw based targets follow it?</p>\n</blockquote>\n<p>I think it's right and LLVM also does it but this triple is unrelated to mingw-w64+GNU (I'm not sure if GNU even allows to create UWP application), in fact it's mingw-w64+LLVM based. So it should be moved under mingw-w64+LLVM family.</p>",
        "id": 267178913,
        "sender_full_name": "mati865",
        "timestamp": 1641555215
    },
    {
        "content": "<p>To wrap it up a bit: on Windows there are official CRT libraries from MS bundled with MSVC and open source unofficial MinGW and it's fork mingw-w64. Something like glibc vs musl except they are both \"wrappers\" to the same system libraries.<br>\nThen there are ABIs: MSVC (AFAIK LLVM msvc triple is as much as possible ABI compatible with it so we don't need <code>*-msvcllvm</code>), GNU and we could say mingw-w64+LLVM (to distinguish it from MSVC/MSVC+LLVM). mingw-w64+LLVM is pretty much GNU ABI (the way values are passed around, registers use, ...) with exception for AArch64 where there was no previous GNU ABI so something closer to MSVC is used, for x86_64 AFAIK the only big differences are native TLS vs emutls and builtins+unwind libraries.</p>",
        "id": 267179895,
        "sender_full_name": "mati865",
        "timestamp": 1641555942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/131828-t-compiler/topic/LLVM.2Bmingw-w64.20Windows.20targets/near/267145678\">said</a>:</p>\n<blockquote>\n<p>I <em>think</em> the right answer might be something like <code>-windows-gnullvm</code> and <code>-windows-msvcllvm</code>.</p>\n</blockquote>\n<p>I have considered it but it sounds weird to me given the fact x86_64 is based on GNU ABI (but not fully compatible) and AArch64 is basically new ABI based on MSVC and AFAIK Linux AArch64.</p>",
        "id": 267180427,
        "sender_full_name": "mati865",
        "timestamp": 1641556347
    },
    {
        "content": "<p>I'd like to move this forward, shall we discuss triple before I start working on PR?</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/131828-t-compiler/topic/LLVM.2Bmingw-w64.20Windows.20targets/near/267146004\">said</a>:</p>\n<blockquote>\n<p>Where <code>gnu</code> or <code>msvc</code> end up in the same place they currently do (so that existing code continues to detect the targets as expected) and the <code>llvm</code> bit perhaps ends up in <code>target_abi</code>.</p>\n</blockquote>\n<p>I searched for <code>windows-gnu</code> in cloned Rust repo and most of the time this target would do different thing than <code>windows-gnu</code>.</p>",
        "id": 268908714,
        "sender_full_name": "mati865",
        "timestamp": 1642802335
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119581\">@mati865</span> Can you give some examples?</p>",
        "id": 268925082,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642813371
    },
    {
        "content": "<p>This sounds like a lot of fun.</p>",
        "id": 268930484,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642818777
    },
    {
        "content": "<p>Ordering results by GitHub Code Search preview:</p>\n<ul>\n<li><code>library/unwind/build.rs</code> this one might need to stay depending if we want to link static and shared unwind similarly to windows-gnu</li>\n<li><code>src/bootstrap/dist.rs‎</code> I really hope we can avoid <code>rust-mingw</code> component mess here</li>\n<li><code>src/bootstrap/compile.rs‎</code> same</li>\n<li><code>‎compiler/rustc_codegen_llvm/src/back/archive.rs‎</code> same</li>\n</ul>\n<p>I avoided searching in <code>cfg</code>s which are used more often because they match env literally and IIUC env for this target would differ.</p>",
        "id": 268951223,
        "sender_full_name": "mati865",
        "timestamp": 1642848419
    },
    {
        "content": "<p>I was suggesting that <code>target_env</code> would be the same, but <code>target_abi</code> would be different.</p>",
        "id": 268969916,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642874789
    },
    {
        "content": "<p>Then I'm guessing probably 20%-30% of those cfg would need changing to distinguish LLVM toolchain.</p>",
        "id": 268972605,
        "sender_full_name": "mati865",
        "timestamp": 1642878473
    },
    {
        "content": "<p>semi-related, I just saw this change proposal for Fedora to add cross-toolchains for MinGW UCRT:<br>\n<a href=\"https://fedoraproject.org/wiki/Changes/F37MingwUCRT\">https://fedoraproject.org/wiki/Changes/F37MingwUCRT</a></p>",
        "id": 270063775,
        "sender_full_name": "cuviper",
        "timestamp": 1643647768
    },
    {
        "content": "<p>Took a while but with LLVM 14 merged I built both x86_64 and AArch64 host compilers without patching LLVM and they seem to work fine with few small examples.<br>\nOpened PR at: <a href=\"https://github.com/rust-lang/rust/pull/94872\">https://github.com/rust-lang/rust/pull/94872</a></p>\n<p>One thing I have no idea how to fix right now is tests ignoring. AFAIK writing <code># ignore-windows-gnu</code> will make it ignored on <code>*windows-gnu*</code> which doesn't seem ideal.</p>",
        "id": 275068138,
        "sender_full_name": "mati865",
        "timestamp": 1647046971
    }
]