[
    {
        "content": "<p>Hi all—I’m not actually terribly experienced with Rust, but I’m quite intimately familiar with hygienic macros (primarily in the context of Racket), and I’ve wanted to better understand Rust’s procedural macro story for a while now (and ideally I’d like to eventually understand it well enough to somehow pitch in). As an outsider, it’s been a bit tricky for me to gather what exactly the current state of things is, but <a href=\"https://twitter.com/samth/status/1457349045010280449\">Sam Tobin-Hochstadt recently opined to me</a> that there isn’t currently anyone in the Rust compiler community who really knows hygiene, so I am hopeful my knowledge on the subject might be of use to someone with actual rustc expertise. :)</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/samth/status/1457349045010280449\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/48a46aa3a5c9c26175cfb5ecee1ad744d0e50afd/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3337383830303030303734303135313431392f63633039633866356336326630356531623062616138663238323432303237645f6e6f726d616c2e6a706567\"></a><p><a href=\"https://twitter.com/lexi_lambda\">@lexi_lambda</a> <a href=\"https://twitter.com/wcrichton\">@wcrichton</a> My sense is that it's being slowly worked on (I think mixed_site was stabilized recently) but doesn't get a lot of attention, partly because there isn't anyone who really knows hygiene in the Rust compiler community.</p><span>- Sam Tobin-Hochstadt (@samth)</span></div></div>",
        "id": 260693259,
        "sender_full_name": "Alexis King",
        "timestamp": 1636393784
    },
    {
        "content": "<p>Hi!  There are a few people still around who know hygiene pretty well. petrochenkov is probably the foremost expert and is still active. dtolnay is also an expert on working with macros.  </p>\n<p>I think <a href=\"https://github.com/rust-lang/rust/issues/54727\">https://github.com/rust-lang/rust/issues/54727</a> is still the central tracking issue with the most information, though you can search for other issues with <a href=\"https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+macro+hygiene\">https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+macro+hygiene</a>.   I'm not sure if you're familiar with <a href=\"https://github.com/rust-lang/rust/issues/39412\">macros 2.0</a>, but there is still some hygiene work to be done with those, too.</p>\n<p>The rustc-dev-guide has a chapter on the existing hygiene which I think is relatively up-to-date (though maybe a little bare): <a href=\"https://rustc-dev-guide.rust-lang.org/macro-expansion.html?highlight=hygiene#hygiene-and-hierarchies\">https://rustc-dev-guide.rust-lang.org/macro-expansion.html?highlight=hygiene#hygiene-and-hierarchies</a>.  It doesn't discuss edition hygiene or various other things.</p>",
        "id": 260697290,
        "sender_full_name": "Eric Huss",
        "timestamp": 1636395412
    },
    {
        "content": "<p>Thanks, that’s helpful—I think I’ve come across most of that while searching around, but I definitely haven’t read all of it in detail (there’s a lot of information and it’s sometimes tricky to figure out what subset is current!). I think, at this point, I’m most interested in better understanding what people generally agree is desirable but has no concrete design/implementation plan and what the current obstacles are. The <a href=\"https://github.com/rust-lang/rfcs/pull/2320\">eager macro expansion RFC</a> seems like one of the better examples of that I’ve come across so far, but it would be great to talk to someone more familiar with the current system about what the open questions/challenges are that led to it being deferred.</p>",
        "id": 260698125,
        "sender_full_name": "Alexis King",
        "timestamp": 1636395801
    },
    {
        "content": "<p>It would also be helpful for me to better understanding the different flavors of hygiene as they currently exist in Rust in such a way that I can relate them back to concepts that exist in the macro literature… even if certain details don’t match <em>any</em> system in the literature, since I imagine those differences would be quite interesting and would elucidate what Rust’s particular choices and challenges are. Currently I gather there are at least two hygiene models, namely <code>macro_rules!</code> hygiene and <code>macro</code> hygiene, but it isn’t immediately clear to me (a) what distinguishes the two and (b) what the underlying, more general model is that can express them both. The docs you link suggest it’s at least superficially related to the Dybvig marks-and-renamings model, but I don’t know how deep that comparison holds!</p>",
        "id": 260698993,
        "sender_full_name": "Alexis King",
        "timestamp": 1636396174
    },
    {
        "content": "<p>You may also want to turn your attention to the <a href=\"#narrow/stream/305296-rustc-reading-club\">rustc-reading-club</a> which has recently formed to spread more knowledge of compiler internals. I believe the first subject was name resolution which is important to know for macro hygiene. I believe the event isn't recorded though...</p>",
        "id": 260699072,
        "sender_full_name": "rylev",
        "timestamp": 1636396206
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456123\">@Alexis King</span> just to avoid confusion - <code>macro_rules!</code> is \"declarative\", not \"proc\" macros; proc macros aren't hygienic, declarative <a href=\"https://veykril.github.io/tlborm/syntax-extensions/hygiene.html\">mostly</a> are</p>",
        "id": 260699572,
        "sender_full_name": "Anatol Ulrich",
        "timestamp": 1636396456
    },
    {
        "content": "<p>and <code>macro</code> is probably \"decl macro 2.0\"</p>",
        "id": 260699589,
        "sender_full_name": "Anatol Ulrich",
        "timestamp": 1636396471
    },
    {
        "content": "<p>ok actually, <a href=\"https://veykril.github.io/tlborm/proc-macros/hygiene.html\">more on proc macro hygiene</a></p>",
        "id": 260699647,
        "sender_full_name": "Anatol Ulrich",
        "timestamp": 1636396504
    },
    {
        "content": "<p>bit of a conflict with <a href=\"https://doc.rust-lang.org/reference/procedural-macros.html\">this statement</a> elsewhere</p>",
        "id": 260699738,
        "sender_full_name": "Anatol Ulrich",
        "timestamp": 1636396559
    },
    {
        "content": "<p>Yes, I’m aware of that… my primary interest is certainly proc macros, but understanding the MBE hygiene models still seems relevant to that, given my understanding is that it is considered desirable to give proc macros access to those hygiene models.</p>",
        "id": 260699792,
        "sender_full_name": "Alexis King",
        "timestamp": 1636396568
    },
    {
        "content": "<p>From a Racket perspective (and also a Scheme perspective given <code>syntax-case</code>), MBE is really just a library implemented in terms of the underlying proc macros system, and some things I’ve seen while reading around appear to suggest that in Rust that is also philosophically/morally/ideally considered the case (though it’s unclear to me how much it is true in practice as of today).</p>",
        "id": 260700105,
        "sender_full_name": "Alexis King",
        "timestamp": 1636396730
    },
    {
        "content": "<p>\"<code>macro_rules!</code> is just a built-in proc macro\" seems like the right model to me, yeah - not sure if it's actually implemented in <code>rustc_builtin_macros</code>, but I don't see any reason why it couldn't</p>",
        "id": 260700443,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636396886
    },
    {
        "content": "<p>hmm not sure how that interacts with hygiene though</p>",
        "id": 260700553,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636396925
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"158561\">@Daniel Henry-Mantilla</span> is also pretty experienced with hygiene from the user side, he's written some crazy stuff like <a href=\"https://github.com/danielhenrymantilla/with_builtin_macros.rs\">https://github.com/danielhenrymantilla/with_builtin_macros.rs</a> which emulates eager expansion</p>",
        "id": 260700756,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636397038
    },
    {
        "content": "<p>My perspective coming from a Racket background is probably one of wide-eyed naïvety—I could perhaps blusteringly say “oh, hygiene for proc macros is a solved problem, you just implement ‘Bindings as Sets of Scopes’ and call it a day,” which of course would not be very helpful. :) So one way of phrasing what I want to understand is that I’d like to know in no uncertain detail why one <em>can’t</em> simply do that in Rust… presumably there are important design constraints that exist in Rust but not in Racket/Scheme that I do not yet know about, and I would like to know about them! (Of course, on the other hand, if it’s not clear that it isn’t “just” a matter of implementation difficulty, that would be useful information, too.)</p>",
        "id": 260701062,
        "sender_full_name": "Alexis King",
        "timestamp": 1636397165
    },
    {
        "content": "<p>And yes, there is a storied history of people doing similarly exciting things with <code>syntax-rules</code>… the most infamous of which is probably <a href=\"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.367.9251&amp;rep=rep1&amp;type=pdf\">Oleg’s trick to use it to write unhygienic macros</a>.</p>",
        "id": 260701456,
        "sender_full_name": "Alexis King",
        "timestamp": 1636397393
    },
    {
        "content": "<p>All macros, whether procedural or declarative (<code>macro_rules</code>, <code>macro</code>) can use the same 2 basic kinds of hygiene - def-site and call-site (plus one hybrid - mixed-site, which is either def-site or call-site depending on context).</p>",
        "id": 260755584,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636435902
    },
    {
        "content": "<p>I don't know how exactly the current system in rustc relates to what is used in Racket, I tried to read papers like \"Macros that Work Together\" and Sets of Scopes, but didn't understand anything due to alien notation and my lack of the necessary formal CS background.</p>",
        "id": 260755723,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636436051
    },
    {
        "content": "<p>The current system in rustc is implemented by <a href=\"https://github.com/jseyfried\">https://github.com/jseyfried</a>, who is no longer active.<br>\nIt is based on Sets of Scopes, as far as I know.<br>\nI knew the implementation in rustc pretty well a couple of years ago, but largely forgot the details due to not touching it for long time.</p>",
        "id": 260755772,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636436152
    },
    {
        "content": "<p>The system is based on hacks in at least some places, so it certainly may be buggy in cases of complex macro nesting.<br>\nIt would be good to gradually refactor it into something more principled and documented.</p>",
        "id": 260756249,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636436626
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span>, that’s all helpful. I have a handful of questions about fairly specific details of the current system, and it sounds like there may or may not be anyone currently able to answer them, but I’ll at least ask them, and if anyone knows something, they can chime in.</p>",
        "id": 260813068,
        "sender_full_name": "Alexis King",
        "timestamp": 1636471229
    },
    {
        "content": "<p>A lot of my immediate questions are about how name resolution interacts with hygiene. The necessity of <code>$crate</code>, for example, seems a bit odd to me. Why is it needed? Shouldn’t all macro-introduced identifiers be looked up in the context of the macro’s definition site, not its use site?</p>",
        "id": 260813846,
        "sender_full_name": "Alexis King",
        "timestamp": 1636471517
    },
    {
        "content": "<p>Oh hmm I wonder if this is at all related to <a href=\"https://github.com/rust-lang/rust/pull/90489#issuecomment-963224698\">https://github.com/rust-lang/rust/pull/90489#issuecomment-963224698</a> (tl;dr crate loading doesn't seem to be hygenic)</p>",
        "id": 260815027,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636471969
    },
    {
        "content": "<p>Some of the other questions I have are essentially about staging and code loading, which seems like it’s probably at least sort of related to the name resolution questions, but isn’t exactly the same thing. For example, how are exported MBE macro definitions serialized and loaded? The staging story for proc macros seems pretty austere—it sounds like they simply can’t ever be used in the same crate in which they’re defined—but is there some reason the restriction has to be so extreme? Why can’t a proc macro be used in a different module of the same crate in which it’s defined?</p>",
        "id": 260815926,
        "sender_full_name": "Alexis King",
        "timestamp": 1636472401
    },
    {
        "content": "<p>My understanding is that proc_macros are dynamically loaded into the compiler process itself, so they need to be compiled before the rest of the crate so rustc can create a .so shared object. And in Rust the whole crate is the compilation unit.</p>",
        "id": 260817190,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636473052
    },
    {
        "content": "<p><code>macro_rules!</code> uses mixed-site hygiene by default, which is roughly that items are looked up with call-site hygiene, but variables with def-site hygiene. This is why <code>$crate</code> is necessary.</p>",
        "id": 260817211,
        "sender_full_name": "bjorn3",
        "timestamp": 1636473058
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/260817190\">said</a>:</p>\n<blockquote>\n<p>My understanding is that proc_macros are dynamically loaded into the compiler process itself, so they need to be compiled before the rest of the crate so rustc can create a .so shared object. And in Rust the whole crate is the compilation unit.</p>\n</blockquote>\n<p>Correct</p>",
        "id": 260817416,
        "sender_full_name": "bjorn3",
        "timestamp": 1636473134
    },
    {
        "content": "<p>I don't know how MBE macros are serialized, but judging by the AST types I would expect it to just be the serialized tokens: <a href=\"https://doc.rust-lang.org/beta/nightly-rustc/rustc_metadata/rmeta/enum.EntryKind.html#variant.MacroDef\">https://doc.rust-lang.org/beta/nightly-rustc/rustc_metadata/rmeta/enum.EntryKind.html#variant.MacroDef</a></p>",
        "id": 260817949,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636473304
    },
    {
        "content": "<p>Looks like it.</p>",
        "id": 260818147,
        "sender_full_name": "bjorn3",
        "timestamp": 1636473364
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/260817190\">said</a>:</p>\n<blockquote>\n<p>And in Rust the whole crate is the compilation unit.</p>\n</blockquote>\n<p>Aha, that was the piece of information I was missing. That’s interesting! I didn’t know that.</p>",
        "id": 260819076,
        "sender_full_name": "Alexis King",
        "timestamp": 1636473666
    },
    {
        "content": "<p>TBH, staging in Scheme is a bit surprising too <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 260819610,
        "sender_full_name": "Laurențiu",
        "timestamp": 1636473853
    },
    {
        "content": "<p>Yes… much less so in Racket, but that adds a lot of implementation complexity.</p>",
        "id": 260819656,
        "sender_full_name": "Alexis King",
        "timestamp": 1636473879
    },
    {
        "content": "<p>I need to step away for a bit, but so far I’ve mostly just been reading through the source code, and while there are some bits I definitely do not understand, a lot of it does seem pretty recognizable. The <code>Transparency</code> concept seems novel, though, and I haven’t yet quite figured out how all the pieces interact. It seems like transparency is essentially a property of a scope (which the implementation calls a mark), and it seems like scopes’ transparency inform some sort of scope-pruning operation? That’s something I’d definitely like to better understand, if anyone has any pointers!</p>",
        "id": 260821042,
        "sender_full_name": "Alexis King",
        "timestamp": 1636474435
    },
    {
        "content": "<p>I'll be able to answer all the questions above tomorrow (right now it's midnight here and I need to go).</p>",
        "id": 260822314,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636474997
    },
    {
        "content": "<p>Yes, of course, no rush. :)</p>",
        "id": 260822852,
        "sender_full_name": "Alexis King",
        "timestamp": 1636475314
    },
    {
        "content": "<p>By the way, <span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu</span>, since you reacted with <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span> to my message above in reference to staging in Racket, the relevant paper is pretty readable if you’re interested (and is hardly new technology, as it’s almost 20 years old!) <a href=\"https://www.cs.utah.edu/plt/publications/macromod.pdf\">https://www.cs.utah.edu/plt/publications/macromod.pdf</a></p>",
        "id": 260852746,
        "sender_full_name": "Alexis King",
        "timestamp": 1636488164
    },
    {
        "content": "<p>(however, to be clear, I wouldn’t actually advocate implementing something like that in Rust, at least not for the foreseeable future—it’d be pretty tricky to slot into Rust’s compilation model, and I don’t think it’s nearly as important for Rust as it is for Racket, given the way macros are actually used)</p>",
        "id": 260853458,
        "sender_full_name": "Alexis King",
        "timestamp": 1636488496
    },
    {
        "content": "<p>(I've written a bit of ..PLT was it? Scheme before and read about its macros, but I don't think I've read that article so thanks for the refresher)</p>",
        "id": 260854155,
        "sender_full_name": "Laurențiu",
        "timestamp": 1636488869
    },
    {
        "content": "<p>Yes, PLT Scheme was the old name. I am sort of sad how essentially nobody seems familiar with the Racket phase system, given it is, imo, the “obviously” correct approach for predictable compilation/dependency tracking for staged programming… but it’s only worth implementing if you already care about being able to mix code from multiple stages in the same compilation unit, which Rust at least currently does not</p>",
        "id": 260854618,
        "sender_full_name": "Alexis King",
        "timestamp": 1636489084
    },
    {
        "content": "<p>(but Template Haskell, for example, does care about doing this, and it pays the price for not implementing anything similar in a number of different ways)</p>",
        "id": 260854715,
        "sender_full_name": "Alexis King",
        "timestamp": 1636489134
    },
    {
        "content": "<p>I do think Miri seems interesting as a potential route to loosen some of the staging restrictions in Rust at least a little bit without having to run the whole codegen/code loading pipeline, though, if that were ever deemed desirable enough to be worth the effort</p>",
        "id": 260855182,
        "sender_full_name": "Alexis King",
        "timestamp": 1636489327
    },
    {
        "content": "<p>miri is quite slow though</p>",
        "id": 260855228,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636489348
    },
    {
        "content": "<p>and proc-macros are already kind of slow :/</p>",
        "id": 260855248,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636489357
    },
    {
        "content": "<p>Yes, I’m definitely not suggesting doing this anytime soon. :) But fwiw, it’s okay for the interpreter to be a little slow, because you only use it to execute small fragments of compile-time code in the current compilation unit, and you load compiled code for everything else (which is the bulk of the actual execution). I don’t know if miri as it currently exists could do that kind of hybrid evaluation, though</p>",
        "id": 260855552,
        "sender_full_name": "Alexis King",
        "timestamp": 1636489490
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> would be the one to ask about that</p>",
        "id": 260855600,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636489513
    },
    {
        "content": "<p>Miri requires MIR. To generate MIR you need HIR. The HIR is by definition immutable and thus can only be generated after macro expansion.</p>",
        "id": 260855726,
        "sender_full_name": "bjorn3",
        "timestamp": 1636489565
    },
    {
        "content": "<p>Given the current way HIR and the query system work you would likely have to run multiple compilation sessions inside the same process, with each compiling macros and then using the result to macro expand in the next session or something like that.</p>",
        "id": 260855901,
        "sender_full_name": "bjorn3",
        "timestamp": 1636489674
    },
    {
        "content": "<p>Yes, but everything I am talking about in that direction is fundamentally dependent upon changing the way macroexpansion works to divide it into multiple phases to loosen that requirement. :) However, I should be very clear that I’m really just spitballing here… this would all be super far-off if I were to ever seriously consider trying to implement it in Rust. I’ve just thought about it a little more concretely in the context of GHC, where GHCi is already more amenable to this sort of thing</p>",
        "id": 260856010,
        "sender_full_name": "Alexis King",
        "timestamp": 1636489703
    },
    {
        "content": "<p>and fwiw, “running multiple compilation sessions inside the same process” is more or less what Racket does to implement phases, albeit in a more lightweight fashion to reduce the overhead</p>",
        "id": 260856230,
        "sender_full_name": "Alexis King",
        "timestamp": 1636489813
    },
    {
        "content": "<p>If we do something like that how should something like <code>#[cfg(unix)]</code> work when cross compiling from say linux to windows? The proc-macro would need it to be enabled, but the final code would need it to be disabled.</p>",
        "id": 260856303,
        "sender_full_name": "bjorn3",
        "timestamp": 1636489853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> presumably the proc macro module would have its own session with its own cfgs</p>",
        "id": 260856365,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636489892
    },
    {
        "content": "<p>The nice thing about phasing is that it makes very explicit what code is a compile-time dependency and what code is a runtime dependency, so you can reliably cross-compile the runtime code but compile the compile-time code on the host rather than the target</p>",
        "id": 260856409,
        "sender_full_name": "Alexis King",
        "timestamp": 1636489916
    },
    {
        "content": "<p>Not sure how the compiler would know ahead of time which modules have proc-macros though</p>",
        "id": 260856452,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636489924
    },
    {
        "content": "<p>It can't really without macro expansion. A macro may expand to <code>#[proc_macro] fn ...</code></p>",
        "id": 260856539,
        "sender_full_name": "bjorn3",
        "timestamp": 1636489972
    },
    {
        "content": "<p>Name resolution has enough cycles due to macro expansion as is IMHO.</p>",
        "id": 260856584,
        "sender_full_name": "bjorn3",
        "timestamp": 1636490000
    },
    {
        "content": "<p>Yes, in a phased system you have to, to some extent, interleave compilation of each phase, but it’s important to note that this isn’t actually cyclical, because while you can have an arbitrarily large number of phases, there is a strict ordering on how phases interact (namely that higher phases generate code for lower phases, and the code in each phase is strictly separate in a given compilation unit)</p>",
        "id": 260856709,
        "sender_full_name": "Alexis King",
        "timestamp": 1636490055
    },
    {
        "content": "<p>it does, however, add a lot of complexity to the system, which is why I wouldn’t seriously advocate implementing anything even remotely like this in rustc</p>",
        "id": 260856782,
        "sender_full_name": "Alexis King",
        "timestamp": 1636490091
    },
    {
        "content": "<p>FWIW my only experience with \"macros generating macros that generate macros\" has been <code>rustc_query_system</code> and that is a nightmarish hellscape to try and understand</p>",
        "id": 260856997,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636490186
    },
    {
        "content": "<p>it even confuses rustdoc, the <code>[src]</code> links are all broken <a href=\"https://doc.rust-lang.org/stable/nightly-rustc/src/rustc_middle/ty/query.rs.html#263\">https://doc.rust-lang.org/stable/nightly-rustc/src/rustc_middle/ty/query.rs.html#263</a></p>",
        "id": 260857048,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636490216
    },
    {
        "content": "<p>yeah, even in Racket (which basically implements everything in the language as a tower of macros), most modules only explicitly make use of two phases (runtime and expansion-time for runtime), and it’s extraordinarily rare to ever have a module that spans more than three phases</p>",
        "id": 260857111,
        "sender_full_name": "Alexis King",
        "timestamp": 1636490260
    },
    {
        "content": "<p>the main advantage of the phase system, though, is that you can write macros that effectively “cooperate” by creating macros that expand to local, compile-time bindings that are then consumed by other macros, which for example allows you to attach compile-time metadata to a binding and use that to guide code generation at a downstream use site</p>",
        "id": 260857316,
        "sender_full_name": "Alexis King",
        "timestamp": 1636490370
    },
    {
        "content": "<p>that is a much more common actual use case than what most people think of when they hear “macro-generating macros,” even though it requires basically the same technology from the macro system’s POV</p>",
        "id": 260857450,
        "sender_full_name": "Alexis King",
        "timestamp": 1636490424
    },
    {
        "content": "<p>Regardless… that’s all thoroughly unrelated to anything I’d actually like to do in the context of Rust. Really, I think the only things I’d like to attempt to figure out in the short term are how the current system works and what needs to be done to pin down what <code>def_site</code> means and what it would take to stabilize and usefully document it</p>",
        "id": 260857790,
        "sender_full_name": "Alexis King",
        "timestamp": 1636490582
    },
    {
        "content": "<p>I’d also like to better understand how macros interact with incremental compilation and whether or not the status quo actually causes any compile-time performance problems in practice (and whether anything could be done to improve that)</p>",
        "id": 260858078,
        "sender_full_name": "Alexis King",
        "timestamp": 1636490715
    },
    {
        "content": "<p>Macros can expand to <code>macro_rules!</code>. In the <code>rustc_query_system</code> crate as described by <span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span>  does this.</p>",
        "id": 260858940,
        "sender_full_name": "bjorn3",
        "timestamp": 1636491137
    },
    {
        "content": "<p>Macros are currently expanded before the incremental compilation system kicks in. The HIR is the input to the incremental compilation system. Everything before it is done every compilation. Some proc macros also can't be cached as they eg read from files or query a database for the database schema.</p>",
        "id": 260859110,
        "sender_full_name": "bjorn3",
        "timestamp": 1636491237
    },
    {
        "content": "<p>yes, sorry… what I meant when I said “macro-generating macros” was really “macros that expand to proc macros definitions, where those definitions can then be immediately used in the same file,” so you have to have code from multiple stages mingling in the same compilation unit (and that’s where the “running multiple compilation sessions inside the same process” comes into play… but again, I think that’s all out of scope for Rust, anyway)</p>",
        "id": 260859372,
        "sender_full_name": "Alexis King",
        "timestamp": 1636491358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/260859110\">said</a>:</p>\n<blockquote>\n<p>Macros are currently expanded before the incremental compilation system kicks in. The HIR is the input to the incremental compilation system. Everything before it is done every compilation. Some proc macros also can't be cached as they eg read from files or query a database for the database schema.</p>\n</blockquote>\n<p>Yes, this was the impression I’d gotten from reading around, thanks. Do you know if this causes meaningful compile-time perf issues in real programs?</p>",
        "id": 260859556,
        "sender_full_name": "Alexis King",
        "timestamp": 1636491431
    },
    {
        "content": "<p>i.e. would it be worth it to make it possible for macroexpansion to be more incremental, or is it a non-issue and therefore not worth the effort</p>",
        "id": 260859703,
        "sender_full_name": "Alexis King",
        "timestamp": 1636491489
    },
    {
        "content": "<p>FYI, there's documentation about the query system <a href=\"https://rustc-dev-guide.rust-lang.org/overview.html#queries\">here</a> and <a href=\"https://rustc-dev-guide.rust-lang.org/query.html\">here</a>.</p>",
        "id": 260860359,
        "sender_full_name": "Noah Lev",
        "timestamp": 1636491628
    },
    {
        "content": "<blockquote>\n<p>and proc-macros are already kind of slow :/<br>\nI've been wondering why this is the case. Anyone know?</p>\n</blockquote>",
        "id": 260877033,
        "sender_full_name": "nnethercote",
        "timestamp": 1636499825
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Take a look at this thread’s performance-oriented offshoot: <a href=\"#narrow/stream/247081-t-compiler.2Fperformance/topic/proc.20macro.20perf/near/260859556\">https://rust-lang.zulipchat.com/#narrow/stream/247081-t-compiler.2Fperformance/topic/proc.20macro.20perf/near/260859556</a></p>",
        "id": 260877555,
        "sender_full_name": "Alexis King",
        "timestamp": 1636500182
    },
    {
        "content": "<p>Thanks! I just saw that it was moved</p>",
        "id": 260877918,
        "sender_full_name": "nnethercote",
        "timestamp": 1636500514
    },
    {
        "content": "<blockquote>\n<p>The necessity of <code>$crate</code>, for example, seems a bit odd to me.<br>\nWhy is it needed?<br>\nShouldn’t all macro-introduced identifiers be looked up in the context of the macro’s definition site, not its use site?</p>\n</blockquote>\n<p><code>$crate</code> is a very old feature (2014-2015), it predates all the macro 2.0 work, in the world with available def-site (definition site) hygiene <code>$crate</code> is mostly legacy.<br>\n<code>$crate</code> is simply a <code>crate</code> with def-site hygiene (<code>crate</code> resolved at the macro's definition site).<br>\n<code>macro_rules!</code> use call-site hygiene (aka use site, aka no hygiene), for most of their output including <code>crate</code>, so they added a special syntax for <code>crate</code> with def-site hygiene specifically, because it's such an important use case.</p>\n<blockquote>\n<p>how are exported MBE macro definitions serialized and loaded?</p>\n</blockquote>\n<p>An MBE is both encoded and decoded as a token stream, e.g. a sequence of tokens having their token kinds and spans, which include hygiene data.<br>\nSearch for <code>fn encode_info_for_item</code> and <code>fn load_macro_untracked</code>.</p>\n<blockquote>\n<p>The staging story for proc macros seems pretty austere—it sounds like they simply can’t ever be used in the same crate in which they’re defined—but is there some reason the restriction has to be so extreme?<br>\nWhy can’t a proc macro be used in a different module of the same crate in which it’s defined?</p>\n</blockquote>\n<p>The proc macro code must run at compile time, and the rest of the code must run at run time.<br>\nIn the cross-compilation case that means that proc macros and regular code must be built for different targets (e.g. x86 and arm).<br>\nBut the unit of compilation for rustc is a crate as it was mentioned above, it cannot currently build different parts of the crate for different targets.<br>\nIt would be good to have such ability for other cases as well, e.g. producing GPU shader code and host code from the same Rust crate, but it's a large work that may take years.</p>\n<blockquote>\n<p>a scope (which the implementation calls a mark)</p>\n</blockquote>\n<p>The term \"mark\" comes from the old pre-jseyfried hygiene system in rustc, that was based on \"Macros that Work Together\".</p>\n<blockquote>\n<p>The Transparency concept seems novel, though, and I haven’t yet quite figured out how all the pieces interact.<br>\nIt seems like transparency is essentially a property of a scope (which the implementation calls a mark), and it seems like scopes’ transparency inform some sort of scope-pruning operation?</p>\n</blockquote>\n<p><a href=\"https://rustc-dev-guide.rust-lang.org/macro-expansion.html#the-macro-definition-hierarchy\">https://rustc-dev-guide.rust-lang.org/macro-expansion.html#the-macro-definition-hierarchy</a> has some docs about this.<br>\n<code>SyntaxContext(Data)</code> is a chain of macro definitions.<br>\nIf all the macros in the chain are opaque (hygienic, using def-site hygiene), then you are resolving a name by walking this chain and trying to resolve the name at the scope of every macro definition in the chain (I guess why it's called a set of scopes elsewhere).<br>\nIf some macros in the chain a transparent (unhygienic, using call-site hygiene), then we should not lookup anything at their definition site, currently this logic is implemented through the \"context transplantation hack\" (<a href=\"https://github.com/rust-lang/rust/pull/51762#issuecomment-401400732\">https://github.com/rust-lang/rust/pull/51762#issuecomment-401400732</a>).<br>\nSome minor additional complexity is that a single macro can produce both tokens with def-site hygiene, and tokens with call-site hygiene, so these chains exist at per-token granularity, rather than at per-macro granularity.</p>",
        "id": 260950061,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636525026
    },
    {
        "content": "<p>(ahhhh it's Alexis King ahhhhh<br>\num pardon me just a fan passing by not an expert for anything<br>\nto awkwardly make this remotely on topic, the async trait / GAT progress which is exposed as a proc macro right now often makes me think about the eff work Alexis did for Haskell</p>",
        "id": 260961295,
        "sender_full_name": "Yufan Lou",
        "timestamp": 1636534897
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span>, that’s all very helpful.</p>\n<blockquote>\n<p>The term \"mark\" comes from the old pre-jseyfried hygiene system in rustc, that was based on \"Macros that Work Together\".</p>\n</blockquote>\n<p>Yes, that makes sense. In the macros literature, the term “mark” originates from the <code>syntax-case</code> system by Kent Dybvig, also known as “marks and renamings”. A “scope” in the sets-of-scopes model is somewhat similar to a mark in the marks-and-renamings model, but it is a little different, marks are used in the marks-and-renamings model to guide renamings, whereas sets-of-scopes dispenses with renamings altogether.</p>\n<blockquote>\n<p><a href=\"https://rustc-dev-guide.rust-lang.org/macro-expansion.html#the-macro-definition-hierarchy\">https://rustc-dev-guide.rust-lang.org/macro-expansion.html#the-macro-definition-hierarchy</a> has some docs about this.<br>\n<code>SyntaxContext(Data)</code> is a chain of macro definitions.<br>\nIf all the macros in the chain are opaque (hygienic, using def-site hygiene), then you are resolving a name by walking this chain and trying to resolve the name at the scope of every macro definition in the chain (I guess why it's called a set of scopes elsewhere).<br>\nIf some macros in the chain a transparent (unhygienic, using call-site hygiene), then we should not lookup anything at their definition site, currently this logic is implemented through the \"context transplantation hack\" (<a href=\"https://github.com/rust-lang/rust/pull/51762#issuecomment-401400732\">https://github.com/rust-lang/rust/pull/51762#issuecomment-401400732</a>).<br>\nSome minor additional complexity is that a single macro can produce both tokens with def-site hygiene, and tokens with call-site hygiene, so these chains exist at per-token granularity, rather than at per-macro granularity.</p>\n</blockquote>\n<p>This all mostly makes sense to me, I think, although several aspects of it seem meaningfully different from all the hygiene systems I am aware of. In particular, the fact that scopes form an ordered chain—and that names are resolved by walking through it—is somewhat suspect to me. From a high level, my understanding of hygiene models is as follows:</p>\n<ul>\n<li>\n<p>Under marks-and-renamings, marks are opaque labels used to track which identifiers came from the input to a macro versus from the macro definition itself. When a macro is expanded, identifiers that came from the macro definition are alpha-renamed to ensure they are distinct from identifiers at the macro’s use site. This renaming process is completely independent from the actual lexical context at both the use- and definition-sites, it only uses the marks to guide which renamings should be performed and which should be skipped.</p>\n</li>\n<li>\n<p>Under sets-of-scopes, scopes are opaque labels that represent a lexical region of a program. No alpha renaming is performed under the sets-of-scopes system: instead, an identifier’s binding is determined by finding the binding with the same symbolic name <em>and</em> the largest scope subset—that is, the opaque labels on the binding identifier must be a subset of the labels on the use-site identifier, and when there are multiple such bindings, the largest subset wins.</p>\n</li>\n</ul>\n<p>In both of these models, marks/scopes are really just opaque labels attached to identifiers, and they don’t contain any binding information themselves. Rather, a single, global binding table is maintained separately. Under marks-and-renamings, the binding table is a simple mapping from symbolic names to binding information, and identifiers are renamed as necessary to ensure the symbolic names are distinct. Under sets-of-scopes, the binding table is a mapping from (symbol, scope set) pairs to binding information, and a binding is looked up using the scope subset operation described above.</p>\n<p>However, while this accurately describes the semantics of both systems, efficient implementations use cleverer implementation techniques. In particular, under sets-of-scopes, binding tables can be stored inside scopes themselves: when a new binding is created, it is stored in the binding table inside the most recently created scope in the binding identifier’s scope set. When an identifier’s binding is looked up, it searches for candidate bindings in each scope’s binding table. This is superficially similar to the chain of <code>SyntaxContext</code> values present in the Rust expander, as scopes have a sort of ordering, but it is still quite different: the slow path for looking up a binding still requires consulting all the binding tables and disambiguating based on the greatest subset operation.</p>\n<p>Storing bindings inside the most recently created scope is primarily beneficial because scopes created later usually correspond to “more nested” scopes (such as, for example, a more-nested <code>let</code>), and bindings in that scope often also include a common prefix of scopes that correspond to the enclosing “less nested” scopes. When this occurs, binding lookup can use a fast path that skips searching through the less-nested scopes altogether, because the more-nested scope is guaranteed to be most specific. This is an extremely common case, so this optimization saves a lot of time. The Racket expander also implements a resolver cache that allows many lookups to avoid searching through binding tables altogether.</p>\n<p>The way the Rust expander works at present seems completely different from this to me, as it sounds like it’s doing something quite distinct: a <code>SyntaxContext</code> represents some richer/more specific notion of a “lexical context”, and it’s still a little unclear to me how exactly <code>SyntaxContext</code>s and <code>ExpnId</code>s relate to binding tables at all.</p>",
        "id": 260993383,
        "sender_full_name": "Alexis King",
        "timestamp": 1636553254
    },
    {
        "content": "<p>In <a href=\"https://github.com/rust-lang/rust/pull/51762#issuecomment-401400732\">this GH comment</a>, <span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> says:</p>\n<blockquote>\n<p>I want to find some other representation for hygiene data so that the hygiene algorithm could work directly on def-site and call-site hierarchies without doing the transplantation.</p>\n</blockquote>\n<p>I believe this capability is provided by both the marks-and-renamings models and the sets-of-scopes model. “Definition site” hygiene is the default, but “call site” hygiene can be achieved by using the “lexical context” from the input syntax for all quoted output syntax. In the sets-of-scopes model, this just means using the scope set from the input syntax everywhere in the output syntax, rather than using the scope set present at the macro’s definition site.</p>\n<p>This doesn’t require anything like “transparency” because a scope set isn’t a linear chain of macro invocations, it’s an unordered set of opaque labels, and a “transparent” call omits the label corresponding to the macro-introduction scope. This makes me wonder: in the current implementation, what is the difference between a mark with a transparency of <code>Transparent</code> versus not adding a new mark at all? Is there any?</p>",
        "id": 261045313,
        "sender_full_name": "Alexis King",
        "timestamp": 1636574110
    },
    {
        "content": "<p>I think a mark with transparent transparency will still show up in error messages as context how the erroring code was expanded.</p>",
        "id": 261050974,
        "sender_full_name": "bjorn3",
        "timestamp": 1636576530
    },
    {
        "content": "<p>I think marks-and-renamings models wouldn't work with rust as any identifier may be matched as a literal by a macro and thus may potentially not be renamable.</p>",
        "id": 261051198,
        "sender_full_name": "bjorn3",
        "timestamp": 1636576654
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261051198\">said</a>:</p>\n<blockquote>\n<p>I think marks-and-renamings models wouldn't work with rust as any identifier may be matched as a literal by a macro and thus may potentially not be renamable.</p>\n</blockquote>\n<p>The marks-and-renamings model supports doing that just fine, because it provides a notion of identifier equality (usually called <code>free-identifier=?</code>) that is stable even in the presence of renamings. But I think sets-of-scopes is a nicer model, anyway, so it’s immaterial.</p>",
        "id": 261069833,
        "sender_full_name": "Alexis King",
        "timestamp": 1636586001
    },
    {
        "content": "<p>Transparent marks are also used for \"edition hygiene\"</p>",
        "id": 261071128,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1636586785
    },
    {
        "content": "<p>the output of a macro will be parsed on the edition of the crate it was defined in</p>",
        "id": 261071217,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1636586849
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456123\">@Alexis King</span>, tangentially (performance related) - have you seen <a href=\"https://github.com/dtolnay/watt\">watt</a>?</p>",
        "id": 261091883,
        "sender_full_name": "Anatol Ulrich",
        "timestamp": 1636604596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116118\">Matthew Jasper</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261071128\">said</a>:</p>\n<blockquote>\n<p>Transparent marks are also used for \"edition hygiene\"</p>\n</blockquote>\n<p>And for avoiding reporting lints for code from transparent macros, and for macro backtraces.</p>",
        "id": 261092744,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636605685
    },
    {
        "content": "<p>Okay, but aren’t all these things sort of orthogonal to the question of what binding an identifier has/what scope it belongs to? That is, even if you have a macro that wants to generate code with call-site scoping, you still probably want it to have the edition of the definition site. I guess that’s exactly the point of transparent marks, but it seems like it would be easier to express that via a different field rather than using marks to do it.</p>",
        "id": 261142014,
        "sender_full_name": "Alexis King",
        "timestamp": 1636641874
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"278740\">@Anatol Ulrich</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261091883\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span>, tangentially (performance related) - have you seen <a href=\"https://github.com/dtolnay/watt\">watt</a>?</p>\n</blockquote>\n<p>I’ll be honest, I don’t really understand the purpose of this at all… why is it worth precompiling proc macros but not other packages? What makes proc macros special here? (I guess one answer is “you don’t need to ship proc macro code, so you don’t need to compile it to the target architecture, so you can just ship platform-independent bytecode,” but that seems like a remarkably specific microoptimization to me.)</p>",
        "id": 261142648,
        "sender_full_name": "Alexis King",
        "timestamp": 1636642223
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456123\">@Alexis King</span> for context about watt, there are some very <del>cursed</del> <em>ambitious</em> proc macros out there <a href=\"https://github.com/launchbadge/sqlx\">https://github.com/launchbadge/sqlx</a></p>",
        "id": 261142784,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636642308
    },
    {
        "content": "<p>i.e. I suspect \"isolation\" was the initial motivation and not performance</p>",
        "id": 261142848,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636642327
    },
    {
        "content": "<p>I suppose that’s fair, but I think isolation of this sort is usually misguided, given you’re linking reams of unaudited code into your final executable anyway, which you’re then going to run on your machine (and sometimes the ability to do things like read files at compile-time is actually useful).</p>",
        "id": 261143074,
        "sender_full_name": "Alexis King",
        "timestamp": 1636642455
    },
    {
        "content": "<p>Though, admittedly, it can be helpful to prevent compile-time code from launching the missiles as a usability benefit (i.e. to prevent people from accidentally shooting themselves in the foot) rather than as a security measure. Racket does something like this—by default, compile-time code is executed in a sandbox when expanded in the background as part of IDE tooling, but by default it isn’t sandboxed when compiling an actual binary.</p>",
        "id": 261143427,
        "sender_full_name": "Alexis King",
        "timestamp": 1636642669
    },
    {
        "content": "<p>IDEs is a big point here, rust-analyzer currently runs proc-macros by default when checking out a project, so just viewing source is already a vulnerability in theory</p>",
        "id": 261143879,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1636642849
    },
    {
        "content": "<p>Yeah, that’s a situation where it is legitimately very useful to sandbox things, especially if you are actively developing compile-time code, since if you <em>are</em> working on a proc macro that, say, interacts with the file system, you don’t want your IDE tooling executing your half-written code and clobbering a bunch of files.</p>",
        "id": 261144080,
        "sender_full_name": "Alexis King",
        "timestamp": 1636642932
    },
    {
        "content": "<p>However, this seems significantly much more difficult to achieve in Rust… Racket implements this sandboxing by having hooks in various places in the runtime (e.g. in the I/O layer, thread scheduler, etc.) that allow code to be executed in a sandboxed mode where those operations will throw exceptions. But Rust’s runtime is vastly more lightweight than Racket’s is.</p>",
        "id": 261144394,
        "sender_full_name": "Alexis King",
        "timestamp": 1636643068
    },
    {
        "content": "<p>I guess it could be achieved by linking compile-time code against different implementations of various operations and disallowing unsafe blocks in the sandboxed mode outside of a whitelisted set of packages. But that would be tricky to get right.</p>",
        "id": 261144939,
        "sender_full_name": "Alexis King",
        "timestamp": 1636643326
    },
    {
        "content": "<p>I think one answer to \"What makes proc macros special here?\" for the performance aspect is that they don't end up in the compiled binary, so you _can_ just compile them to any binary format you like that you can execute during compilation. Precompiled binaries for other libraries would also be desirable for compilation performance, but aren't as easy to make compatible across compiler versions.<br>\nAnother answer, that I'm not sure how much it really weighs, is that compiling proc macros blocks compilation of all downstream crates using them, while other crates can be codegened while their downstream already compiles in parallel</p>",
        "id": 261145233,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636643480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261145233\">said</a>:</p>\n<blockquote>\n<p>I think one answer to \"What makes proc macros special here?\" for the performance aspect is that they don't end up in the compiled binary, so you _can_ just compile them to any binary format you like that you can execute during compilation. Precompiled binaries for other libraries would also be desirable for compilation performance, but aren't as easy to make compatible across compiler versions.</p>\n</blockquote>\n<p>Yes, that’s exactly what I meant by my “I guess one answer is…” parenthetical. :)</p>\n<blockquote>\n<p>Another answer, that I'm not sure how much it really weighs, is that compiling proc macros blocks compilation of all downstream crates using them, while other crates can be codegened while their downstream already compiles in parallel</p>\n</blockquote>\n<p>Yes, that sort of makes sense, though I still think this seems like a pretty extreme solution to that particular problem.</p>",
        "id": 261145459,
        "sender_full_name": "Alexis King",
        "timestamp": 1636643593
    },
    {
        "content": "<p>proc macro compilation can take up a significant part of compilation time because they often pull in a full Rust parser, so it's not as small an optimization as you might expect from Racket. I do think the performance aspect is more of a bonus on top of having isolation and determinism though</p>",
        "id": 261146378,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636644016
    },
    {
        "content": "<p>Yes, they shouldn’t have to pull in a full Rust parser, because the parsers used for <code>expr</code>, <code>ty</code>, etc. in MBE patterns should be accessible to proc macros.</p>",
        "id": 261146675,
        "sender_full_name": "Alexis King",
        "timestamp": 1636644146
    },
    {
        "content": "<p>that would be nice</p>",
        "id": 261147049,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1636644336
    },
    {
        "content": "<p>IIUC, the main obstacles in place at the moment are the fact that the compiler uses a different type for token streams internally and the fact that it would be tricky to extract some of that logic into the <code>proc_macros</code> crate, but I think both of those issues are probably solvable.</p>",
        "id": 261147508,
        "sender_full_name": "Alexis King",
        "timestamp": 1636644544
    },
    {
        "content": "<p>In MBE patterns <code>expr</code>, <code>ty</code> etc are opaque matches. It isn't possible to extract any information about them. Syn on the other hand gives you a full AST.</p>",
        "id": 261147814,
        "sender_full_name": "bjorn3",
        "timestamp": 1636644695
    },
    {
        "content": "<p>Yes, but the logic for parsing token trees into an AST ultimately exists in the compiler, so there’s no reason it shouldn’t be exposed to procedural macros directly in some fashion, rather than needing to reimplement it in an external crate (which makes it all-too-easy for the parsers to disagree in edge cases, and makes it much harder for them to adapt automatically to different editions/features/etc.).</p>",
        "id": 261148256,
        "sender_full_name": "Alexis King",
        "timestamp": 1636644905
    },
    {
        "content": "<p>Obviously doing this is work, I’m not saying it isn’t. :) I’m not trying to say “someone else should do this,” I’m saying “I would be interested in attempting to do this.”</p>",
        "id": 261148463,
        "sender_full_name": "Alexis King",
        "timestamp": 1636644994
    },
    {
        "content": "<p>I do have one question that is unrelated from all the conversation so far. The rustc-dev-guide blurb on procedural macros says this:</p>\n<blockquote>\n<p>It's worth noting that the token stream type used by proc macros is stable, so rustc does not use it internally (since our internal data structures are unstable). The compiler's token stream is <code>rustc_ast::tokenstream::TokenStream</code>, as previously. This is converted into the stable <code>proc_macro::TokenStream</code> and back in <code>rustc_expand::proc_macro</code> and <code>rustc_expand::proc_macro_server</code>. <strong>Because the Rust ABI is unstable, we use the C ABI for this conversion.</strong></p>\n</blockquote>\n<p>Emphasis mine. Why does the Rust ABI being unstable matter? Do you not have to recompile your dependencies with each new version of the compiler, anyway?</p>",
        "id": 261149388,
        "sender_full_name": "Alexis King",
        "timestamp": 1636645478
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456123\">@Alexis King</span> the stage1 compiler has to be able to compile stage2. But stage2 uses proc macros. So the ABI for proc-macros between stage 1 and 2 has to match.</p>",
        "id": 261149782,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636645694
    },
    {
        "content": "<p>this is <code>proc_macro::bridge</code>, which <span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> wrote</p>",
        "id": 261149808,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636645710
    },
    {
        "content": "<p>Aha, that makes sense.</p>",
        "id": 261149819,
        "sender_full_name": "Alexis King",
        "timestamp": 1636645715
    },
    {
        "content": "<p>There's also a stability issue, the standard library cannot make breaking changes.<br>\nSo the idea was to expose only the most minimal necessary functionality from it, and delegate everything else to third-party libraries which can use semantic versioning and make breaking changes if necessary.</p>",
        "id": 261152838,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1636647106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261152838\">said</a>:</p>\n<blockquote>\n<p>There's also a stability issue, the standard library cannot make breaking changes.<br>\nSo the idea was to expose only the most minimal necessary functionality from it, and delegate everything else to third-party libraries which can use semantic versioning and make breaking changes if necessary.</p>\n</blockquote>\n<p>I think this makes sense for most things, but I don’t think it makes sense for things like parsing Rust expressions, because if the external library ever goes out of sync with the compiler’s implementation, that’s a bug. You’re not gaining much from reimplementing that by hand. One alternative, though, would be to expose some logic for parsing Rust code via a separate, semver-versioned crate that wraps unstable compiler-provided APIs.</p>",
        "id": 261156915,
        "sender_full_name": "Alexis King",
        "timestamp": 1636649074
    },
    {
        "content": "<blockquote>\n<p>I don’t think it makes sense for things like parsing Rust expressions, because if the external library ever goes out of sync with the compiler’s implementation, that’s a bug</p>\n</blockquote>\n<p>I'm not sure if that's true though - rustdoc for instance has two ASTs, one it uses internally with breaking changes, and one that's user-facing and only changes slowly and intentionally</p>",
        "id": 261159040,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650102
    },
    {
        "content": "<p>and as long as you can rewrite the one to the other they don't need to be exactly the same</p>",
        "id": 261159089,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650123
    },
    {
        "content": "<p>(rustdoc's use case is it wants to switch more things from being stored in memory to being computed on-demand as time goes on: <a href=\"https://github.com/rust-lang/rust/issues/76382\">https://github.com/rust-lang/rust/issues/76382</a>)</p>",
        "id": 261159152,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650144
    },
    {
        "content": "<blockquote>\n<p>I don’t think it makes sense for things like parsing Rust expressions, because if the external library ever goes out of sync with the compiler’s implementation, that’s a bug</p>\n</blockquote>\n<p>If the compiler needs to make a breaking change to the AST, that will break everyone. If an external library goes out of sync with the compiler, it will just accept a bit less code than rustc would, which is much less worse.</p>",
        "id": 261159557,
        "sender_full_name": "bjorn3",
        "timestamp": 1636650349
    },
    {
        "content": "<p>What I mean is that if the library-defined parser parses actual Rust expressions in a semantically-different way from how the compiler does, that’s a bug, not that the ASTs need to remain the same. (The latter would be silly.)</p>",
        "id": 261159562,
        "sender_full_name": "Alexis King",
        "timestamp": 1636650353
    },
    {
        "content": "<blockquote>\n<p>not that the ASTs need to remain the same. (The latter would be silly.)</p>\n</blockquote>\n<p>this is essentially what \"combine <code>syn</code> and <code>proc_macro</code>\" is saying though, that the ASTs should match and be part of the stability guarentee</p>",
        "id": 261159652,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650391
    },
    {
        "content": "<p>Syn probably won't parse rust expressions differently from rustc. It will just give a parse error when rustc wouldn't if new syntax is added.</p>",
        "id": 261159665,
        "sender_full_name": "bjorn3",
        "timestamp": 1636650397
    },
    {
        "content": "<blockquote>\n<p>this is essentially what \"combine <code>syn</code> and <code>proc_macro</code>\" is saying though, that the ASTs should match and be part of the stability guarantee</p>\n</blockquote>\n<p>Surely not—if the compiler-provided AST is unstable, then it can break at will, and if you have a separate semver-versioned crate that wraps the unstable API using its own AST types and smooths over the differences between the two as much as possible, then you can have a more stable (but not standard-library-stable) interface for that functionality, right?</p>",
        "id": 261159976,
        "sender_full_name": "Alexis King",
        "timestamp": 1636650536
    },
    {
        "content": "<p>oh I see what you mean - yes, proc_macro can be the \"slow and intentional\" AST. But that still prevents you from <em>ever</em> making changes to what's valid to parse</p>",
        "id": 261160091,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650597
    },
    {
        "content": "<p>I guess you could slap a ton of <code>#[non_exhaustive]</code> on everything</p>",
        "id": 261160183,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650616
    },
    {
        "content": "<p>I’m still not sure I understand what you mean… must the wrapper crate necessarily have the same stability guarantees as the standard library? Why can’t it have the same stability guarantees as <code>syn</code>?</p>",
        "id": 261160287,
        "sender_full_name": "Alexis King",
        "timestamp": 1636650664
    },
    {
        "content": "<p>because it's part of the standard library. It's distributed with the rust toolchain</p>",
        "id": 261160450,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650725
    },
    {
        "content": "<p>if you want it to <em>not</em> be part of the standard library you end up with <code>syn</code></p>",
        "id": 261160495,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650737
    },
    {
        "content": "<p>or with all the features being unstable, which means in practice that people will use syn</p>",
        "id": 261160592,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636650787
    },
    {
        "content": "<p>Well, the only difference between what I’m saying versus the status quo would just be moving the actual parsing logic out of <code>syn</code> and into an unstable, compiler-provided API. So there’s still no duplication in logic, but yes, the general interface is still <code>syn</code>. That seems better than the status quo to me… but maybe not meaningfully enough to make an impact on <code>syn</code>’s compile times, I guess I’m not sure.</p>",
        "id": 261160717,
        "sender_full_name": "Alexis King",
        "timestamp": 1636650843
    },
    {
        "content": "<blockquote>\n<p>and into an unstable, compiler-provided API</p>\n</blockquote>\n<p>Then <code>syn</code> can't use it. You can't use unstable API's on stable rustc, only on nightly.</p>",
        "id": 261161322,
        "sender_full_name": "bjorn3",
        "timestamp": 1636651137
    },
    {
        "content": "<p>you could separate the logic into a library used by both syn and the compiler maybe, but that's not actually saving you compile time, just code duplication</p>",
        "id": 261161493,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636651204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261161322\">said</a>:</p>\n<blockquote>\n<p>Then <code>syn</code> can't use it. You can't use unstable API's on stable rustc, only on nightly.</p>\n</blockquote>\n<p>Ah, that is the detail I was missing. That is a very strong guarantee… but I suppose it makes sense, given Rust’s particular choices around stability. I’ll have to think about this a little more.</p>",
        "id": 261164856,
        "sender_full_name": "Alexis King",
        "timestamp": 1636652874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/260950061\">said</a>:</p>\n<blockquote>\n<p>$crate is a very old feature (2014-2015), it predates all the macro 2.0 work, in the world with available def-site (definition site) hygiene $crate is mostly legacy.</p>\n</blockquote>\n<p>What is the macros-2.0 replacement for <code>$crate</code>? IME it's still required, but I'd love to know what the alternative is, since I want to dogfood them in rustc</p>",
        "id": 261166815,
        "sender_full_name": "bstrie",
        "timestamp": 1636653943
    },
    {
        "content": "<p>IIUC, if you’re using definition-site hygiene you can just reference things in the current crate in the usual, lexical way, without any qualification.</p>",
        "id": 261167054,
        "sender_full_name": "Alexis King",
        "timestamp": 1636654086
    },
    {
        "content": "<p>If you have an example where that doesn’t work, I’d be interested in seeing it!</p>",
        "id": 261167094,
        "sender_full_name": "Alexis King",
        "timestamp": 1636654115
    },
    {
        "content": "<p><code>crate</code> can also work as a more direct replacement.</p>",
        "id": 261167122,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1636654131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"456123\">Alexis King</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/261167094\">said</a>:</p>\n<blockquote>\n<p>If you have an example where that doesn’t work, I’d be interested in seeing it!</p>\n</blockquote>\n<p>ah, I think I figured out what the current limitation is. In particular I recently ported these three macros to macros 2.0: <a href=\"https://github.com/rust-lang/rust/blob/d71ba74f0d51459ef10f2b73400c013c7a12d828/compiler/rustc_arena/src/lib.rs#L613-L722\">https://github.com/rust-lang/rust/blob/d71ba74f0d51459ef10f2b73400c013c7a12d828/compiler/rustc_arena/src/lib.rs#L613-L722</a> , and when I tried removing the <code>$crate</code>s I got errors and didn't bother to investigate further, but trying it again actually it appears that the first two macros don't need <code>$crate</code>, only the last one does, presumably because I had to mark it with the <code>rustc_macro_transparency</code> attribute (which also took me a while to realize at the time... this isn't really well-documented, and certainly isn't intended to be the proper solution for a stable macros 2.0). presumably by marking it as semitransparent the <code>$crate</code> now again has semantic distinction (<code>macro_rules!</code> is equivalent to <code>transparent</code>, AFAIK)</p>",
        "id": 261169704,
        "sender_full_name": "bstrie",
        "timestamp": 1636655639
    },
    {
        "content": "<p><code>macro_rules!</code> is <code>semitransparent</code> AFAIK.</p>",
        "id": 261170593,
        "sender_full_name": "bjorn3",
        "timestamp": 1636656152
    },
    {
        "content": "<p>my favorite quote by petrochenkov remains \"allowing <code>pub</code> on <code>macro_rules!</code> appears to be ... negative work?\" <a href=\"https://github.com/rust-lang/rust/pull/78166\">https://github.com/rust-lang/rust/pull/78166</a></p>",
        "id": 261171185,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636656520
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"456123\">@Alexis King</span> you might find <a href=\"https://rust-analyzer.github.io/blog/2021/11/21/ides-and-macros.html\">https://rust-analyzer.github.io/blog/2021/11/21/ides-and-macros.html</a> interesting</p>",
        "id": 262299716,
        "sender_full_name": "Laurențiu",
        "timestamp": 1637575621
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu</span>—someone actually linked me to that on twitter a couple days ago, and I only just noticed your ping here, but I appreciate it all the same. :) I do find it interesting.</p>",
        "id": 262461587,
        "sender_full_name": "Alexis King",
        "timestamp": 1637677306
    },
    {
        "content": "<p>I of course have various thoughts about it. One of my initial ones is that doing name resolution before macroexpansion seems like probably the wrong idea to me… from my perspective, a hygienic macroexpansion model basically <em>is</em> only a little more than a fancy name resolution algorithm. Racket avoids the sort of problem that the blog post gives as an example by having two constraints: Racket forbids mutually-recursive modules altogether (and you have to use a secondary feature to explicitly opt into that sort of recursive linking), and in Racket, files are compilation units.</p>\n<p>It seems like that set of tradeoffs isn’t really viable for Rust, which is reasonable, but it does indeed mean that making macros efficient is tricky. It’s an interesting design problem, and one I have various thoughts on, but none of them are very fleshed out, and I’d need to learn more about Rust before really pursuing any of them.</p>",
        "id": 262462322,
        "sender_full_name": "Alexis King",
        "timestamp": 1637677630
    },
    {
        "content": "<p>On the subject of “mapping back” information for use by IDEs, I think the approach used in Racket actually probably <em>would</em> work perfectly fine in Rust. In Racket, the expander annotates code with metadata about its provenance as the program is expanded (e.g. what code came from what macros, which bindings were synthesized from other ones, which bindings were inspected by a macro, etc.), and Racket’s IDE tools consume that information to understand the structure of the program. Doing that is fairly lightweight, and it’s basically the only workable approach to let IDEs handle macros, since it’s simply impossible to build an understanding of every macro into an IDE tool in the way you can (theoretically) build in an understanding of every language construct.</p>",
        "id": 262462768,
        "sender_full_name": "Alexis King",
        "timestamp": 1637677833
    },
    {
        "content": "<p>Yes, I feel it's too late to change the language. But if untangling this in an IDE sounds like your idea of fun, please join the stream over there <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>.</p>",
        "id": 262462805,
        "sender_full_name": "Laurențiu",
        "timestamp": 1637677852
    },
    {
        "content": "<p>Aha, yes, I see it—I’ll write my thoughts over there instead of here. :)</p>",
        "id": 262463045,
        "sender_full_name": "Alexis King",
        "timestamp": 1637677944
    },
    {
        "content": "<p>(It was mentioned or at least implied in the post, but rust-analyzer is not sharing too much code with the compiler)</p>",
        "id": 262463151,
        "sender_full_name": "Laurențiu",
        "timestamp": 1637678006
    },
    {
        "content": "<blockquote>\n<p>It seems like that set of tradeoffs isn’t really viable for Rust, which is reasonable</p>\n</blockquote>\n<p>wait, isn’t the first constraint relatively easy to meet if you interpret Rust crates as mapping to Racket modules? (I guess you can have <em>some</em> kinds of crates can be set up to have mutual dependencies (namely <code>extern fn</code>’s)  that are resolved at link time, but that seems like a separate concern from what macros are trying to do)</p>",
        "id": 262538503,
        "sender_full_name": "pnkfelix",
        "timestamp": 1637719178
    },
    {
        "content": "<p>I guess if your goal is to be able to define a proc macro in the same crate that it is used, then you cannot take the approach I am thinking of.</p>",
        "id": 262538664,
        "sender_full_name": "pnkfelix",
        "timestamp": 1637719310
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/131828-t-compiler/topic/The.20state.20of.20proc.20macros/near/262538503\">said</a>:</p>\n<blockquote>\n<p>wait, isn’t the first constraint relatively easy to meet if you interpret Rust crates as mapping to Racket modules?</p>\n</blockquote>\n<p>Yes, the problem is just that the resulting compilation units are too big to be practical. (And, for what it’s worth, Racket allows you to define and use a macro in the same compilation unit, so that part isn’t the obstacle.)</p>",
        "id": 262598953,
        "sender_full_name": "Alexis King",
        "timestamp": 1637765800
    }
]