[
    {
        "content": "<p>When does inlining happen? Is it a MIR transformation? LLVM? Something else?</p>",
        "id": 264973822,
        "sender_full_name": "nnethercote",
        "timestamp": 1639553696
    },
    {
        "content": "<p>There's a MIR inliner, but it's off by default.  Turning it on is <a href=\"https://github.com/rust-lang/rust/issues/81567\">#81567</a>.</p>\n<p>Otherwise it's LLVM that does it.  And IIRC it's always bottom-up, for better or worse.</p>",
        "id": 264974665,
        "sender_full_name": "scottmcm",
        "timestamp": 1639554498
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 265073531,
        "sender_full_name": "nnethercote",
        "timestamp": 1639601585
    },
    {
        "content": "<p>some discussion of when it's <em>not</em> bottom-up: <a href=\"https://reviews.llvm.org/D115497\">https://reviews.llvm.org/D115497</a></p>",
        "id": 265074932,
        "sender_full_name": "cuviper",
        "timestamp": 1639602312
    },
    {
        "content": "<blockquote>\n<p>LLVM uses a bottom-up inliner, and the fact that functions are processed bottom-up is not just a question of optimality -- it is a critically imporant requirement to prevent runaway inlining. </p>\n</blockquote>\n<p>Odd. Afaik java's incremental inliner manages to inline in the middle of the call-graph without runaway inlining. They iterate inline-optimize-inline-... as long as the function stays within some size limit (+ some recursion budget for pathological cases).</p>",
        "id": 265077218,
        "sender_full_name": "The 8472",
        "timestamp": 1639603591
    },
    {
        "content": "<p>Oh, interesting.  Thanks, @â€‹<strong>cuviper</strong></p>",
        "id": 265084163,
        "sender_full_name": "scottmcm",
        "timestamp": 1639606680
    },
    {
        "content": "<p>I've been thinking that some of the best MIR inlining opportunities would be top-down, actually.  Like <code>&lt;&amp;A: PartialOrd&lt;&amp;B&gt;&gt;</code>, for example, where the derefs are likely free in the caller, and much better than inlining another copy of the actual comparison logic.</p>",
        "id": 265084373,
        "sender_full_name": "scottmcm",
        "timestamp": 1639606808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> Doing top-down inlining is fine, you just can't do it with a bottom-up cost model.</p>",
        "id": 265211673,
        "sender_full_name": "Nikita Popov",
        "timestamp": 1639684956
    },
    {
        "content": "<p>Somewhat tangential: I'd also love to be able to <em>suggest</em> top-down inlining for certain functions.  Like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[inline(top_down)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">do_stuff</span><span class=\"p\">(</span><span class=\"n\">i</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert!</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"w\"> </span><span class=\"o\">!=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// This one intentionally not marked `#[inline]`</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">inner</span><span class=\"p\">(</span><span class=\"n\">i</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Because it's pretty common for precondition checks to be able to be removed in callers, but they never can at the top of non-inlined functions.</p>",
        "id": 265224546,
        "sender_full_name": "scottmcm",
        "timestamp": 1639691424
    },
    {
        "content": "<p><code>#[inline(callees)]</code>? <em>bikeshed</em></p>",
        "id": 265234317,
        "sender_full_name": "Jubilee",
        "timestamp": 1639697025
    },
    {
        "content": "<p>That sounds like it would inline child functions, not tell the parent to inline the annotated one before considering its children</p>",
        "id": 265234446,
        "sender_full_name": "The 8472",
        "timestamp": 1639697092
    },
    {
        "content": "<p>Hm.</p>",
        "id": 265234906,
        "sender_full_name": "Jubilee",
        "timestamp": 1639697415
    },
    {
        "content": "<p><code>#[inline(shallow)]</code> might work</p>",
        "id": 265240476,
        "sender_full_name": "Jacob Pratt",
        "timestamp": 1639701645
    },
    {
        "content": "<p>Oh yeah you're right, I was mentally mis-modeling it.</p>",
        "id": 265240596,
        "sender_full_name": "Jubilee",
        "timestamp": 1639701740
    },
    {
        "content": "<p>And yeah, I agree re: <code>#[inline(top_down)]</code> annotation would be nice. I would definitely like to use it on certain <code>std::simd</code> functions that do various kinds of bounds-masking stuff to make the interface safe, because if the bounds mask is repetitive or handled by the user already then it <strong>really</strong> needs to be optimized away. The alternative is using much more grisly <code>unsafe</code> interfaces.</p>",
        "id": 265361320,
        "sender_full_name": "Jubilee",
        "timestamp": 1639775653
    }
]