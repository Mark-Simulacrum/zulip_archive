[
    {
        "content": "<p>If <code>-Z codegen-backend</code> will ever be stabilized (<a href=\"https://github.com/rust-lang/rust/issues/77933\">https://github.com/rust-lang/rust/issues/77933</a>), does that mean that we will<br>\nget some rustc_private crates that can compile on stable? I dont see how codegen-backend being stable can do anything if compiling the codegens requires nightly. Will this restriction ever be lifted?</p>",
        "id": 257983844,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634539325
    },
    {
        "content": "<p>I think it would benefit a lot of projects if codegen crates are able to compile on stable, however, that kind of breaks stable guarantees if the codegens are not updated alongside stable releases. But then that also causes more issues because do you update according to nightly or according to stable? doing one or the other precludes the other.</p>",
        "id": 257984023,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634539497
    },
    {
        "content": "<p>I don't think we'd ever want to stabilize \"here's a path to a shared library for a codegen backend\". I think we'd want to stabilize \"here's the name of a stable codegen backend\", so that people can say \"I want to build using cg_gcc\" or \"I want to build using cg_cranelift\".</p>",
        "id": 257989353,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634543140
    },
    {
        "content": "<p>(As well as allowing targets to have a default codegen backend, so that targets only supported by cg_gcc can default to cg_gcc.)</p>",
        "id": 257989430,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634543166
    },
    {
        "content": "<p>Yeah that makes sense</p>",
        "id": 258058279,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634574814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Stable.20custom.20codegens/near/257989353\">said</a>:</p>\n<blockquote>\n<p>I don't think we'd ever want to stabilize \"here's a path to a shared library for a codegen backend\". I think we'd want to stabilize \"here's the name of a stable codegen backend\", so that people can say \"I want to build using cg_gcc\" or \"I want to build using cg_cranelift\".</p>\n</blockquote>\n<p>I'd agree with this, especially stabilizing it in $RUSTC interface, instead of for rustc in particular (for which the line between is currently fairly grey). Though I would want the names of stable codegen backends to be <code>rustc</code> specific (compiler specific in general) as well anyways. After all, good luck convicing gcc-rs to provide cg_llvm (also, I may end up avoiding llvm myself).</p>",
        "id": 258115341,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634598167
    },
    {
        "content": "<p>i dont see how gcc-rs applies in this case at all since its a frontend not a backend</p>",
        "id": 258117104,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634599190
    },
    {
        "content": "<p>that frontend may want to support the same stable set of <code>-C</code> options, insofar as they make sense</p>",
        "id": 258117697,
        "sender_full_name": "cuviper",
        "timestamp": 1634599563
    },
    {
        "content": "<p>but gcc-rs probably wouldn't support this, nor <code>-Cllvm-args</code> etc.</p>",
        "id": 258117727,
        "sender_full_name": "cuviper",
        "timestamp": 1634599575
    },
    {
        "content": "<p>I think being able to control the codegen used and its arguments in Cargo.toml will go a long way to having better support for custom codegens]</p>",
        "id": 258117907,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634599688
    },
    {
        "content": "<p>For example, rust-gpu (and a project im working on that compiles for cuda) needs a <a href=\"http://build.rs\">build.rs</a> because the arguments needed by rustc are fairly complex and there isnt great support for running custom codegens overall</p>",
        "id": 258117969,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634599742
    },
    {
        "content": "<p>this <a href=\"http://build.rs\">build.rs</a> approach is full of issues, things like not having an accurate progress view for compiling the crate, warnings being silently ignored, etc</p>",
        "id": 258118012,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634599772
    },
    {
        "content": "<p>Yeah, I was wondering about <code>-C llvm-args</code> myself. But in general, as I mentioned, the line between \"stable for rustc\" and part of the stable interface presented by <code>$RUSTC</code> (which is any rust compiler that also matches the CLI expected for use with cargo among others) is very thin and it's not clear where it sits. <br>\nThe ability to specify a custom codegen from Cargo.toml seems like a great idea on paper, but it runs into issues when you consider that not every frontend with the same interface will have or want to have the same codegens, or most definately the same interface. There is zero way that  a custom codegen written for rustc will work with lccc, or take your pick of any other frontend that is being developed or will be developed. They have  completely different internals, which is the advantage of having multiple frontends, rather than \"rustc, rustc, rustc\".  The ability to specify in Cargo.toml would likely place it in the \"stable for the $RUSTC interface\" collum, which means that it has to be supported, whether it is reasonable or not, if a frontend wishes to support cargo.</p>\n<p>Obviously, some method of selecting a stable codegen would be useful, but that list would have to be compiler-specific by design. Likewise any mechanism for selecting a custom codegen.</p>",
        "id": 258120818,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634601624
    },
    {
        "content": "<p>honestly i dont think its worth it to gut good custom codegen support just because new frontends will exist in the future, at least not for now. If a project needs a custom codegen, and the frontend is not able to deliver/emulate it, then the project will simply not build with that compiler. I do want to note im firmly against having multiply frontends currently, partly for this exact reason</p>",
        "id": 258121204,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634601885
    },
    {
        "content": "<p>I would agree with that, but I would want it to be in a location other than Cargo.toml, which presents what I would call the definitive stable interface to the frontend CLI.  Or, otherwise the portability, or lack thereof, of using it should be made clear.</p>",
        "id": 258121454,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634602072
    },
    {
        "content": "<p>I believe custom codegens are one of the most exciting things about rustc for the future. We have a backend for fast compilation with cranelift, a backend for gcc, a backend for shader code, and soon a backend for general gpu computing. Some of these things are fundamentally impossible to have with multiple frontends unless somehow the frontends agree on a common interface for custom codegens, which we all know will never happen</p>",
        "id": 258121461,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634602078
    },
    {
        "content": "<p>Custom codegens are already ambitious for a language that is nowhere near complete and does not have any form of a specification. Adding multiple frontends to the mix is a recipe for disaster</p>",
        "id": 258121713,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634602252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Stable.20custom.20codegens/near/258121204\">said</a>:</p>\n<blockquote>\n<p>honestly i dont think its worth it to gut good custom codegen support just because new frontends will exist in the future, at least not for now. If a project needs a custom codegen, and the frontend is not able to deliver/emulate it, then the project will simply not build with that compiler. I do want to note im firmly against having multiply frontends currently, partly for this exact reason</p>\n</blockquote>\n<p>Acknowleding my own opposed bias in the matter, there are considerable uses for different frontends, including handling hosts where rustc is unreasonable or impossible to use, or supporting targets that are fundamentally unsupportable by the design of existing ones. Also reguardless of whether or not there are arguments for or against them, they will exist, and in my opinion, Rust should not actively seek to make it difficult to mitigate the damage that will occur when they do.</p>",
        "id": 258122161,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634602557
    },
    {
        "content": "<p>Rustc doing this would hurt frontends which won't be used by a significant amount of people for probably decades to come, but it would greatly help a good majority of users interested in using a custom codegen backend for things like GPU work (which is not an uncommon task). So i think the damage done is perfectly fine</p>",
        "id": 258122321,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634602675
    },
    {
        "content": "<p>I think it makes sense for cargo to support providing many different kinds of options to the rust compiler. Depending on the options you specify, you may end up only working on a compiler that supports those options. That doesn't mean you only work on the rust compiler, because another compiler could theoretically implement those options. That's a lot more likely for something like strip, or linker options. It's a lot less likely for the name of a specific code generation back end, so if you specify such an option, that's going to inherently make your crate less portable.</p>",
        "id": 258174098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634640521
    },
    {
        "content": "<p>That seems reasonable, since if your crate is written specifically for something like rust-gpu, you're unlikely to work with anything else anyway.</p>",
        "id": 258174146,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634640548
    },
    {
        "content": "<p>Normally, I think most crates would want to use the default backend for a given architecture (e.g llvm for mainstream architectures, gcc for architectures llvm doesn't support). If a crate is going out of its way to specify a specific backend, it wants that backend. If it can also handle different backends, it might make sense to have different profiles for that.</p>",
        "id": 258174352,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634640652
    },
    {
        "content": "<p>As one possible example, perhaps one backend generate substantially better code for a specific target, either in terms of size or in terms of performance.</p>",
        "id": 258174418,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634640701
    },
    {
        "content": "<p>Dependencies can't specify which codegen backend to use, just like they can't specify eg their opt level. Only the root workspace can specify it.</p>",
        "id": 258176157,
        "sender_full_name": "bjorn3",
        "timestamp": 1634641650
    },
    {
        "content": "<p>At the same time, though, a user may have a way to have a crate build wth !rustc (likely involving writing a similar backend for a compiler that itself has pluggable backends). Although if it's only specified by the top-level crates and can be overriden by the end user, that may be reasonable to avoid the issues I described.</p>",
        "id": 258177826,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634642546
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> True, though artifact dependencies may specify an architecture that necessitates a specific backend.</p>",
        "id": 258185540,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634646513
    },
    {
        "content": "<p>And we may eventually need a way for artifact dependencies to control a bit more of their compilation (with the ability of the top-level package to override).</p>",
        "id": 258185602,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634646550
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Stable.20custom.20codegens/near/258185540\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> True, though artifact dependencies may specify an architecture that necessitates a specific backend.</p>\n</blockquote>\n<p>That seems harder to override at a user level, though.</p>",
        "id": 258186054,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634646755
    },
    {
        "content": "<p>If you're compiling to, say, cuda, you don't specifically need the nvvm rustc backend, you just need a backend that generates nvptx code. The nvvm rustc backend may be a reasonable default to achieve that, it may not forever be the only way, and it should be reasonable for the user to say \"I know what I'm doing, use this backend\".</p>",
        "id": 258186330,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634646902
    },
    {
        "content": "<p>Sure, but there should be a default. If you specify that you want to compile to a vulkan shader, there should be a default, probably rust-gpu. We might one day have more than one backend that can support that target, but we should still have a default.</p>",
        "id": 258191916,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634649272
    },
    {
        "content": "<p>(Rather than, for instance, defaulting to a backend that doesn't support the target and then emitting an error.)</p>",
        "id": 258191959,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634649290
    },
    {
        "content": "<p>The default should be in rustc and not cargo. Cargo should have as little target specific knowledge beyond what rustc tells it using <code>--print</code> IMHO.</p>",
        "id": 258196085,
        "sender_full_name": "bjorn3",
        "timestamp": 1634650869
    },
    {
        "content": "<p>Complete agreement there.</p>",
        "id": 258198116,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634651645
    },
    {
        "content": "<p>Cargo should default to <em>not</em> telling Rust what backend to use, just telling it what target to use.</p>",
        "id": 258198153,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634651662
    },
    {
        "content": "<blockquote>\n<p>If you're compiling to, say, cuda, you don't specifically need the nvvm rustc backend, you just need a backend that generates nvptx code. The nvvm rustc backend may be a reasonable default to achieve that, it may not forever be the only way, and it should be reasonable for the user to say \"I know what I'm doing, use this backend\".</p>\n</blockquote>\n<p>I agree, but at the same time, my libnvvm backend is the only thing that can reliably generate PTX code, both because it uses the library that NVCC itself uses, and because it fixes up some things that gpu code needs/doesnt need. And i dont see cg_llvm and the llvm ptx backend ever being on that level unless they refactor to basically become my codegen. So i think it is perfectly fine to have <code>nvptx-nvidia-cuda</code> and <code>nvptx64-nvidia-cuda</code> use that backend by default. While giving the user the option to say \"please use cg_llvm with the nvptx target\". Its all about sensible defaults</p>",
        "id": 258234884,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634663450
    },
    {
        "content": "<p>the bad thing is that the LLVM PTX backend is not going to emit a nice error, it will either:</p>\n<ul>\n<li>Throw a linker error if you try using any of the fundamental nvvm intrinsics (like thread idx)</li>\n<li>Work but generate completely invalid PTX which fails to load or produces unwanted results</li>\n</ul>",
        "id": 258235133,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634663533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Stable.20custom.20codegens/near/258198153\">said</a>:</p>\n<blockquote>\n<p>Cargo should default to <em>not</em> telling Rust what backend to use, just telling it what target to use.</p>\n</blockquote>\n<p>Yes, but cargo also needs a way to override whatever rustc chooses with another codegen backend, like if for example, somebody wants to use cg_llvm with a target that is handled by default by another backend</p>",
        "id": 258236651,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634664062
    },
    {
        "content": "<p><code>-Zcodegen-backend</code> should always override the default backend for a target.</p>",
        "id": 258236878,
        "sender_full_name": "bjorn3",
        "timestamp": 1634664132
    },
    {
        "content": "<p>But that won't be stable, i mean for already-stabilized codegens inside rustc</p>",
        "id": 258236968,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634664164
    },
    {
        "content": "<p><code>-Zcodegen-backend</code> may become stable as <code>-Ccodegen-backends</code> for builtin codegen backends.</p>",
        "id": 258237365,
        "sender_full_name": "bjorn3",
        "timestamp": 1634664297
    },
    {
        "content": "<p>Yeah that may be a good option</p>",
        "id": 258237427,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634664314
    },
    {
        "content": "<p>if for example, someone wants to use cg_llvm over cg_nvvm they can just use <code>-C codegen-backend=llvm</code> or something like that</p>",
        "id": 258237841,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634664465
    },
    {
        "content": "<p>it would also probably need a method for codegen backends for \"fetch me the supported targets\"</p>",
        "id": 258237983,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634664504
    },
    {
        "content": "<p>so that rustc can issue an early error for trying to use an invalid backend for a target</p>",
        "id": 258238034,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634664524
    },
    {
        "content": "<p>codegen backends have an init method that can error out.</p>",
        "id": 258244188,
        "sender_full_name": "bjorn3",
        "timestamp": 1634666548
    },
    {
        "content": "<p>Right but wouldn't it be better to have rustc handle the \"this is what targets this codegen supports, you chose this codegen but it does not support &lt;target&gt;\"?</p>",
        "id": 258244687,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634666730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Stable.20custom.20codegens/near/258234884\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>If you're compiling to, say, cuda, you don't specifically need the nvvm rustc backend, you just need a backend that generates nvptx code. The nvvm rustc backend may be a reasonable default to achieve that, it may not forever be the only way, and it should be reasonable for the user to say \"I know what I'm doing, use this backend\".</p>\n</blockquote>\n<p>I agree, but at the same time, my libnvvm backend is the only thing that can reliably generate PTX code, both because it uses the library that NVCC itself uses, and because it fixes up some things that gpu code needs/doesnt need. And i dont see cg_llvm and the llvm ptx backend ever being on that level unless they refactor to basically become my codegen. So i think it is perfectly fine to have <code>nvptx-nvidia-cuda</code> and <code>nvptx64-nvidia-cuda</code> use that backend by default. While giving the user the option to say \"please use cg_llvm with the nvptx target\". Its all about sensible defaults</p>\n</blockquote>\n<p>May be true of rustc and currently. May not always be true of all <code>$RUSTC</code>s.</p>",
        "id": 258246091,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634667258
    },
    {
        "content": "<p>I'm not disputing it's a good default, but an override must exist, especially if it would be specified in <code>Cargo.toml</code>.</p>",
        "id": 258246550,
        "sender_full_name": "Connor Horman",
        "timestamp": 1634667425
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276242\">@Riccardo D'Ambrosio</span> (regarding defaults, it doesn't seem likely that a backend that isn't upstream and can't be upstream would be the default.)</p>",
        "id": 258267932,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634675945
    },
    {
        "content": "<p>Thats a discussion for another time</p>",
        "id": 258270021,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634676768
    },
    {
        "content": "<p>i dont quite see how libnvvm's case is much different from libgccjit's case</p>",
        "id": 258270164,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634676840
    },
    {
        "content": "<p>One is open, the other is not. But yes, that's a discussion for another time.</p>",
        "id": 258315433,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634708600
    },
    {
        "content": "<p>libnvvm is arguably more permissive than libgccjit, you can redistribute it freely in your tools and you can use it in proprietary closed source tools just fine</p>",
        "id": 258315695,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1634708810
    }
]