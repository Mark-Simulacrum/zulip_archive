[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I see you are working on to refactor the support for consts in patterns. I left a comment on your PR that adds some <code>StructuralEq</code> impls. The weirdness around bounds is explicitly documented <a href=\"https://doc.rust-lang.org/std/marker/trait.StructuralEq.html\" title=\"https://doc.rust-lang.org/std/marker/trait.StructuralEq.html\">in the trait docs</a>. Basically we have to use a type visitor to recurse through all the members of a type in question to determine whether it is \"always\" structurally matchable (e.g., <code>usize</code>, <code>(usize, usize)</code>, <code>enum X { A(uszie), B(usize) }</code>) or only \"sometimes\" structurally matchable (e.g. <code>Option&lt;T&gt;</code>). For the sometimes types, we will do structural qualification like we do for <code>NeedsDrop</code> and <code>HasMutInterior</code>.</p>",
        "id": 192927648,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586035374
    },
    {
        "content": "<p>we could also add a method to <code>StructuralEq</code> and make miri interpret it for a specific constant</p>",
        "id": 193014142,
        "sender_full_name": "oli",
        "timestamp": 1586164257
    },
    {
        "content": "<p>that way we need no visitor :D</p>",
        "id": 193014148,
        "sender_full_name": "oli",
        "timestamp": 1586164261
    },
    {
        "content": "<p>(but we need a hack that allows us to define associated const functions)</p>",
        "id": 193014167,
        "sender_full_name": "oli",
        "timestamp": 1586164276
    },
    {
        "content": "<p>oh... maybe we can do it with an assoc const?</p>",
        "id": 193014185,
        "sender_full_name": "oli",
        "timestamp": 1586164287
    },
    {
        "content": "<p>ah no</p>",
        "id": 193014191,
        "sender_full_name": "oli",
        "timestamp": 1586164290
    },
    {
        "content": "<p>we need the value as input</p>",
        "id": 193014197,
        "sender_full_name": "oli",
        "timestamp": 1586164294
    },
    {
        "content": "<p>also that example in the docs is weird. I don't get how function pointers can be StructuralEq at all</p>",
        "id": 193014784,
        "sender_full_name": "oli",
        "timestamp": 1586164643
    },
    {
        "content": "<p>function pointers to the same function can be different if they were created in different crates</p>",
        "id": 193014803,
        "sender_full_name": "oli",
        "timestamp": 1586164659
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> wasn't there a discussion with... you and <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span>, maybe? where we decided const generics + structural eq has really terrible edge cases around pointer equality?</p>",
        "id": 193032424,
        "sender_full_name": "eddyb",
        "timestamp": 1586175573
    },
    {
        "content": "<p>all builtin types have implicit <code>StructuralEq</code> instead of whitelisting the ones that make sense :(</p>",
        "id": 193032536,
        "sender_full_name": "eddyb",
        "timestamp": 1586175647
    },
    {
        "content": "<p>e.g. <code>==</code>/<code>!=</code> on the <code>ConstValue</code> should be sound to rely on in pattern-matching</p>",
        "id": 193032672,
        "sender_full_name": "eddyb",
        "timestamp": 1586175723
    },
    {
        "content": "<p>for leaves, references being the only indirection traversed automatically <em>before</em> that</p>",
        "id": 193032718,
        "sender_full_name": "eddyb",
        "timestamp": 1586175752
    },
    {
        "content": "<p>seems unsound to have any kind of <em>address</em> in this system</p>",
        "id": 193032750,
        "sender_full_name": "eddyb",
        "timestamp": 1586175778
    },
    {
        "content": "<p>the only non-ZST leaves should be pure integers</p>",
        "id": 193032780,
        "sender_full_name": "eddyb",
        "timestamp": 1586175800
    },
    {
        "content": "<p>like <code>&amp;str</code> would compare the actual UTF-8 bytes which are integers</p>",
        "id": 193032794,
        "sender_full_name": "eddyb",
        "timestamp": 1586175812
    },
    {
        "content": "<p>so I guess both pattern-matching and <code>const</code> generics need us to ban code that compiles on stable :/</p>",
        "id": 193032895,
        "sender_full_name": "eddyb",
        "timestamp": 1586175849
    },
    {
        "content": "<p>is there an issue about this?</p>",
        "id": 193032900,
        "sender_full_name": "eddyb",
        "timestamp": 1586175853
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> who might not have seen previous discussions we had (elsewhere? Discord maybe? I forget)</p>",
        "id": 193032995,
        "sender_full_name": "eddyb",
        "timestamp": 1586175897
    },
    {
        "content": "<p>but also those previous discussions didn't focus on how pattern-matching may interact with non-integers</p>",
        "id": 193033022,
        "sender_full_name": "eddyb",
        "timestamp": 1586175916
    },
    {
        "content": "<p>you can't traverse references automatically, since you can manually implement <code>PartialEq</code> for <code>&amp;T</code> where <code>T: !StructPartialEq</code></p>",
        "id": 193033126,
        "sender_full_name": "oli",
        "timestamp": 1586175964
    },
    {
        "content": "<p>I'm talking about <code>StructuralEq</code> references</p>",
        "id": 193033191,
        "sender_full_name": "eddyb",
        "timestamp": 1586176004
    },
    {
        "content": "<p>any others are just banned</p>",
        "id": 193033196,
        "sender_full_name": "eddyb",
        "timestamp": 1586176007
    },
    {
        "content": "<p>i thought others just default to <code>==</code>?</p>",
        "id": 193033211,
        "sender_full_name": "oli",
        "timestamp": 1586176020
    },
    {
        "content": "<p>for backcompat</p>",
        "id": 193033232,
        "sender_full_name": "oli",
        "timestamp": 1586176032
    },
    {
        "content": "<p>and don't get any exhaustiveness or other fancy checks</p>",
        "id": 193033264,
        "sender_full_name": "oli",
        "timestamp": 1586176050
    },
    {
        "content": "<p>sure but that's not relevant to soundness and <code>const</code> generics</p>",
        "id": 193033265,
        "sender_full_name": "eddyb",
        "timestamp": 1586176051
    },
    {
        "content": "<p><em>because</em> they don't factor into exhaustiveness and whatnot</p>",
        "id": 193033297,
        "sender_full_name": "eddyb",
        "timestamp": 1586176070
    },
    {
        "content": "<p>and <code>const</code> generics would just ban them</p>",
        "id": 193033359,
        "sender_full_name": "eddyb",
        "timestamp": 1586176085
    },
    {
        "content": "<p>oh, you mean the breaking change is that they are relevant for exhaustivness right now?</p>",
        "id": 193033371,
        "sender_full_name": "oli",
        "timestamp": 1586176097
    },
    {
        "content": "<p>the problem is <code>StructuralEq</code> raw/<code>fn</code> <em>pointers</em></p>",
        "id": 193033380,
        "sender_full_name": "eddyb",
        "timestamp": 1586176102
    },
    {
        "content": "<p>compared by <em>abstract address</em></p>",
        "id": 193033387,
        "sender_full_name": "eddyb",
        "timestamp": 1586176110
    },
    {
        "content": "<p>yea</p>",
        "id": 193033400,
        "sender_full_name": "oli",
        "timestamp": 1586176121
    },
    {
        "content": "<p>references are fine <em>because</em> they're like a <code>(T,)</code> to the structural eq property</p>",
        "id": 193033435,
        "sender_full_name": "eddyb",
        "timestamp": 1586176149
    },
    {
        "content": "<p>but any other kind of indirection is not</p>",
        "id": 193033463,
        "sender_full_name": "eddyb",
        "timestamp": 1586176161
    },
    {
        "content": "<p>boxes?</p>",
        "id": 193033481,
        "sender_full_name": "oli",
        "timestamp": 1586176169
    },
    {
        "content": "<p>not a thing AFAIK, you have to use <code>box</code> patterns</p>",
        "id": 193033520,
        "sender_full_name": "eddyb",
        "timestamp": 1586176190
    },
    {
        "content": "<p>yes</p>",
        "id": 193033542,
        "sender_full_name": "oli",
        "timestamp": 1586176201
    },
    {
        "content": "<p>so unstable -&gt; let's ignore</p>",
        "id": 193033601,
        "sender_full_name": "oli",
        "timestamp": 1586176208
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> if there isn't an issue already about non-integral leaves, can you open one? I'm already doing several things at once</p>",
        "id": 193033610,
        "sender_full_name": "eddyb",
        "timestamp": 1586176212
    },
    {
        "content": "<p>or maybe I should, it's not clear I got my point across Q_Q</p>",
        "id": 193033631,
        "sender_full_name": "eddyb",
        "timestamp": 1586176226
    },
    {
        "content": "<p>you didn't</p>",
        "id": 193033639,
        "sender_full_name": "oli",
        "timestamp": 1586176232
    },
    {
        "content": "<p>and I don't have the time to invent examples</p>",
        "id": 193033646,
        "sender_full_name": "eddyb",
        "timestamp": 1586176235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> so, <code>!StructuralEq</code> types are sound by definition since <em>we don't trust them</em></p>",
        "id": 193033683,
        "sender_full_name": "eddyb",
        "timestamp": 1586176257
    },
    {
        "content": "<p>but there are <em>untrustworthy primitives</em> that nevertheless we implemented <code>StructuralEq</code> for</p>",
        "id": 193033736,
        "sender_full_name": "eddyb",
        "timestamp": 1586176283
    },
    {
        "content": "<p>because we <em>assumed</em> that only custom <code>impl</code>s could be untrustworthy</p>",
        "id": 193033758,
        "sender_full_name": "eddyb",
        "timestamp": 1586176294
    },
    {
        "content": "<p>but that's just wrong</p>",
        "id": 193033770,
        "sender_full_name": "eddyb",
        "timestamp": 1586176299
    },
    {
        "content": "<p>but what if we just stopped doing that? would we break anything? you can't exhaustively match function pointers or even raw pointers for that matter</p>",
        "id": 193033845,
        "sender_full_name": "oli",
        "timestamp": 1586176323
    },
    {
        "content": "<p>okay yeah I'm suggesting to try breaking them</p>",
        "id": 193033876,
        "sender_full_name": "eddyb",
        "timestamp": 1586176339
    },
    {
        "content": "<p>we'd stop detecting unreachable arms, but <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 193033894,
        "sender_full_name": "oli",
        "timestamp": 1586176351
    },
    {
        "content": "<p>and the hard part would be finding an example showing they're unsound</p>",
        "id": 193033896,
        "sender_full_name": "eddyb",
        "timestamp": 1586176351
    },
    {
        "content": "<p>ok, with that info I can work, I'll play a bit and open an issue</p>",
        "id": 193033941,
        "sender_full_name": "oli",
        "timestamp": 1586176365
    },
    {
        "content": "<p>maybe we can use <code>const</code> generics to craft an example? but idk if it even enforces <code>StructuralEq</code> yet</p>",
        "id": 193034010,
        "sender_full_name": "eddyb",
        "timestamp": 1586176400
    },
    {
        "content": "<p>it doesn't</p>",
        "id": 193034202,
        "sender_full_name": "oli",
        "timestamp": 1586176481
    },
    {
        "content": "<p>I guess we can't because the value is never computed at runtime</p>",
        "id": 193034208,
        "sender_full_name": "eddyb",
        "timestamp": 1586176483
    },
    {
        "content": "<p>so it's just <em>weird</em> right now</p>",
        "id": 193034242,
        "sender_full_name": "eddyb",
        "timestamp": 1586176509
    },
    {
        "content": "<p>ah... now I get what <span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> is talking about. We can use a constant in pattern matching if its value does not contain any <code>!StructuralEq</code> values</p>",
        "id": 193034367,
        "sender_full_name": "oli",
        "timestamp": 1586176572
    },
    {
        "content": "<p>yeah</p>",
        "id": 193034415,
        "sender_full_name": "eddyb",
        "timestamp": 1586176596
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd3fca6a9c204a1579448e465461f28b\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd3fca6a9c204a1579448e465461f28b\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd3fca6a9c204a1579448e465461f28b</a></p>",
        "id": 193034951,
        "sender_full_name": "eddyb",
        "timestamp": 1586176912
    },
    {
        "content": "<p>this is a fun example</p>",
        "id": 193034961,
        "sender_full_name": "eddyb",
        "timestamp": 1586176917
    },
    {
        "content": "<p>compare output from debug vs release</p>",
        "id": 193035009,
        "sender_full_name": "eddyb",
        "timestamp": 1586176923
    },
    {
        "content": "<p>it doesn't show anything <em>egregious</em></p>",
        "id": 193035118,
        "sender_full_name": "eddyb",
        "timestamp": 1586177001
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> and this is what happens if you make <code>fn</code> pointers non-<code>StructuralEq</code> <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=801477c9fcfad4074c0daa3683ff00e3\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=801477c9fcfad4074c0daa3683ff00e3\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=801477c9fcfad4074c0daa3683ff00e3</a></p>",
        "id": 193035340,
        "sender_full_name": "eddyb",
        "timestamp": 1586177114
    },
    {
        "content": "<p>doesn't fall back to <code>==</code></p>",
        "id": 193035376,
        "sender_full_name": "eddyb",
        "timestamp": 1586177137
    },
    {
        "content": "<p>but we could avoid any breaking changes by falling back to <code>==</code></p>",
        "id": 193036505,
        "sender_full_name": "oli",
        "timestamp": 1586177647
    },
    {
        "content": "<p>eeeeeeeh</p>",
        "id": 193036587,
        "sender_full_name": "eddyb",
        "timestamp": 1586177695
    },
    {
        "content": "<p>you'd first have to figure out why we broke things in the past (e.g. floats) <em>without</em> doing that</p>",
        "id": 193036623,
        "sender_full_name": "eddyb",
        "timestamp": 1586177712
    },
    {
        "content": "<p>I think it's hard to keep things sound when you have nested patterns</p>",
        "id": 193036657,
        "sender_full_name": "eddyb",
        "timestamp": 1586177729
    },
    {
        "content": "<p>probably have to treat it like <code>x if x == CONST</code></p>",
        "id": 193036684,
        "sender_full_name": "eddyb",
        "timestamp": 1586177743
    },
    {
        "content": "<p>but we don't have that today</p>",
        "id": 193036702,
        "sender_full_name": "eddyb",
        "timestamp": 1586177751
    },
    {
        "content": "<p>so it'd have to be like <code>ref x</code> that can still fail to match</p>",
        "id": 193036822,
        "sender_full_name": "eddyb",
        "timestamp": 1586177799
    },
    {
        "content": "<blockquote>\n<p>but idk if it even enforces StructuralEq yet</p>\n</blockquote>\n<p>const generics do enforce <code>structural_match</code> now</p>",
        "id": 193038102,
        "sender_full_name": "varkor",
        "timestamp": 1586178339
    },
    {
        "content": "<blockquote>\n<p>but what if we just stopped doing that? would we break anything?</p>\n</blockquote>\n<p>we would break using constants of those types in patterns</p>",
        "id": 193038371,
        "sender_full_name": "varkor",
        "timestamp": 1586178461
    },
    {
        "content": "<p>ah, I see that was pointed out above</p>",
        "id": 193038556,
        "sender_full_name": "varkor",
        "timestamp": 1586178552
    },
    {
        "content": "<p>I wonder how much fallout we would get if we just banned pointers <em>without</em> adding a <code>==</code> fallback</p>",
        "id": 193038640,
        "sender_full_name": "varkor",
        "timestamp": 1586178600
    },
    {
        "content": "<p>how many people can really be relying on explicit pointer matching? :/</p>",
        "id": 193038698,
        "sender_full_name": "varkor",
        "timestamp": 1586178612
    },
    {
        "content": "<p>note that I'm not 100% sure how type-based it can be, I'm talking about pointer <em>values</em>, which could potentially be hidden in integers (I hope not?)</p>",
        "id": 193039077,
        "sender_full_name": "eddyb",
        "timestamp": 1586178799
    },
    {
        "content": "<p>and <code>*mut T</code> with an integer <em>value</em> would be a perfectly fine pattern :P</p>",
        "id": 193039103,
        "sender_full_name": "eddyb",
        "timestamp": 1586178812
    },
    {
        "content": "<p>we are forbidding <code>usize</code> constants from having relocation value</p>",
        "id": 193039540,
        "sender_full_name": "oli",
        "timestamp": 1586179003
    },
    {
        "content": "<p>okay so at least that shouldn't cause issues</p>",
        "id": 193039599,
        "sender_full_name": "eddyb",
        "timestamp": 1586179034
    },
    {
        "content": "<p>we surely don't want to make the structural match property depend on <em>values</em>?</p>",
        "id": 193039657,
        "sender_full_name": "varkor",
        "timestamp": 1586179063
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d60d7ca1fd1a804026813a88b3e5fca9\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d60d7ca1fd1a804026813a88b3e5fca9\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=d60d7ca1fd1a804026813a88b3e5fca9</a></p>",
        "id": 193039678,
        "sender_full_name": "oli",
        "timestamp": 1586179072
    },
    {
        "content": "<p>we may have to, but I'd prefer not to either</p>",
        "id": 193039749,
        "sender_full_name": "oli",
        "timestamp": 1586179093
    },
    {
        "content": "<p>my brain breaks enough with the value based things for <code>UnsafeCell</code></p>",
        "id": 193039789,
        "sender_full_name": "oli",
        "timestamp": 1586179117
    },
    {
        "content": "<p>if we can avoid it I'll be happy</p>",
        "id": 193039798,
        "sender_full_name": "eddyb",
        "timestamp": 1586179120
    },
    {
        "content": "<p>what's the issue with trying to disable structural match for pointer types and then if users store addresses in other types, that's on them?</p>",
        "id": 193039924,
        "sender_full_name": "varkor",
        "timestamp": 1586179192
    },
    {
        "content": "<p>no it's fine, as long as we ban addresses in other types early</p>",
        "id": 193040030,
        "sender_full_name": "eddyb",
        "timestamp": 1586179222
    },
    {
        "content": "<p>we do</p>",
        "id": 193040042,
        "sender_full_name": "oli",
        "timestamp": 1586179228
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I also don't understand why <code>StructuralEq</code> needs to exist after reading its documentation, perhaps <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> could inform us?</p>",
        "id": 193071646,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586192861
    },
    {
        "content": "<p>I think it's for floats basically. Floats are <code>!StructuralEq</code> but they are <code>StructuralPartialEq</code> because of NaNs</p>",
        "id": 193071814,
        "sender_full_name": "oli",
        "timestamp": 1586192929
    },
    {
        "content": "<p>The documentation explicitly calls out function pointers not implementing <code>PartialEq</code> and <code>Eq</code>, but I thought they did?</p>",
        "id": 193071984,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193071814\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193071814\">said</a>:</p>\n<blockquote>\n<p>I think it's for floats basically. Floats are <code>!StructuralEq</code> but they are <code>StructuralPartialEq</code> because of NaNs</p>\n</blockquote>\n<p>Hm, but then we could just check for <code>Eq</code>. We wouldn't need a separate structural version.</p>",
        "id": 193072093,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193076
    },
    {
        "content": "<p>Can't you impl <code>Eq</code> manually for a type that is <code>StructuralPartialEq</code>?</p>",
        "id": 193072338,
        "sender_full_name": "oli",
        "timestamp": 1586193173
    },
    {
        "content": "<p>or or is an <code>Eq</code> derive also required for <code>StructuralPartialEq</code>?</p>",
        "id": 193072381,
        "sender_full_name": "oli",
        "timestamp": 1586193197
    },
    {
        "content": "<p>In any case, I'll be working on using the <code>Qualif</code> machinery for determining structural match. One of the difficulties I had was that pattern lowering was a bit messy, so I'm very happy to see it get refactored.</p>",
        "id": 193072388,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193199
    },
    {
        "content": "<p>Do we really need such a value based analysis?</p>",
        "id": 193072462,
        "sender_full_name": "oli",
        "timestamp": 1586193230
    },
    {
        "content": "<p>The goal would be to fix some longstanding bugs where we accidentally allow some non structural match constants in patterns.</p>",
        "id": 193072565,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193266
    },
    {
        "content": "<p><code>StructuralPartialEq</code>+<code>StructuralEq</code> is the replacement for <code>#[structural_match]</code></p>",
        "id": 193072598,
        "sender_full_name": "eddyb",
        "timestamp": 1586193281
    },
    {
        "content": "<p>right, but the alternative solution is to just allow them and treat them as opaque</p>",
        "id": 193072604,
        "sender_full_name": "oli",
        "timestamp": 1586193283
    },
    {
        "content": "<p>It's not to allow new things</p>",
        "id": 193072607,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193284
    },
    {
        "content": "<p>which was too fragile</p>",
        "id": 193072612,
        "sender_full_name": "eddyb",
        "timestamp": 1586193286
    },
    {
        "content": "<p>(and also problematic to have, since it detected <em>two</em> derives at once)</p>",
        "id": 193072659,
        "sender_full_name": "eddyb",
        "timestamp": 1586193311
    },
    {
        "content": "<p>/me goes to look up some issue numbers</p>",
        "id": 193072676,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193322
    },
    {
        "content": "<p>the traits are just there to detect a property</p>",
        "id": 193072712,
        "sender_full_name": "eddyb",
        "timestamp": 1586193342
    },
    {
        "content": "<p>i.e. that <code>#[derive(PartialEq, Eq)]</code> was used</p>",
        "id": 193072724,
        "sender_full_name": "eddyb",
        "timestamp": 1586193355
    },
    {
        "content": "<p>each trait is meaningless on its own</p>",
        "id": 193072773,
        "sender_full_name": "eddyb",
        "timestamp": 1586193364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> I'm still unclear why we need both a <code>StructuralPartialEq</code> and a <code>StructuralEq</code>. Here's the docs for <code>StructuralEq</code>:</p>\n<blockquote>\n<p>In a more ideal world, we could check that requirement by just checking that the given type implements both (1.) the StructuralPartialEq trait and (2.) the Eq trait. However, you can have ADTs that do derive(PartialEq, Eq), and be a case that we want the compiler to accept, and yet the constant's type fails to implement Eq.</p>\n<p>Namely, a case like this:</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[derive(PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Wrap</span><span class=\"o\">&lt;</span><span class=\"n\">X</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">higher_order</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">CFN</span>: <span class=\"nc\">Wrap</span><span class=\"o\">&lt;</span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">())</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wrap</span><span class=\"p\">(</span><span class=\"n\">higher_order</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">CFN</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">CFN</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<blockquote>\n<p>(The problem in the above code is that Wrap&lt;fn(&amp;())&gt; does not implement PartialEq, nor Eq, because for&lt;'a&gt; fn(&amp;'a _) does not implement those traits.)</p>\n<p>Therefore, we cannot rely on naive check for StructuralPartialEq and mere Eq.</p>\n</blockquote>",
        "id": 193072894,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193467
    },
    {
        "content": "<p>what</p>",
        "id": 193072967,
        "sender_full_name": "eddyb",
        "timestamp": 1586193495
    },
    {
        "content": "<p>the reason for two traits is because that's the only way to do this</p>",
        "id": 193072984,
        "sender_full_name": "eddyb",
        "timestamp": 1586193506
    },
    {
        "content": "<p>am I missing something?</p>",
        "id": 193073032,
        "sender_full_name": "eddyb",
        "timestamp": 1586193536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">ecstatic-morse</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193071984\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193071984\">said</a>:</p>\n<blockquote>\n<p>The documentation explicitly calls out function pointers not implementing <code>PartialEq</code> and <code>Eq</code>, but I thought they did?</p>\n</blockquote>\n<p><code>for &lt;'a&gt; fn(&amp;'a _)</code> does not, I think...</p>",
        "id": 193073054,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586193553
    },
    {
        "content": "<p><code>#[derive(PartialEq)]</code> + manual <code>Eq</code> impl is the thing we want to guard against</p>",
        "id": 193073058,
        "sender_full_name": "eddyb",
        "timestamp": 1586193555
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193073054\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193073054\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118594\">ecstatic-morse</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193071984\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193071984\">said</a>:</p>\n<blockquote>\n<p>The documentation explicitly calls out function pointers not implementing <code>PartialEq</code> and <code>Eq</code>, but I thought they did?</p>\n</blockquote>\n<p><code>for &lt;'a&gt; fn(&amp;'a _)</code> does not, I think...</p>\n</blockquote>\n<p>can't we \"just\" fix that? More compiler magic or sth</p>",
        "id": 193073108,
        "sender_full_name": "oli",
        "timestamp": 1586193589
    },
    {
        "content": "<p>also I thought all builtin impls were just automatically <code>StructuralEq</code> which is the reason we have the bug where pointers are considered <code>StructuralEq</code></p>",
        "id": 193073114,
        "sender_full_name": "eddyb",
        "timestamp": 1586193595
    },
    {
        "content": "<p>or was that only the case with the old <code>#[structural_match]</code>?</p>",
        "id": 193073170,
        "sender_full_name": "eddyb",
        "timestamp": 1586193607
    },
    {
        "content": "<p>it's all very confusing :D</p>",
        "id": 193073187,
        "sender_full_name": "oli",
        "timestamp": 1586193616
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/62614\" title=\"https://github.com/rust-lang/rust/issues/62614\">#62614</a> is the main one. <a href=\"https://github.com/rust-lang/rust/issues/65466\" title=\"https://github.com/rust-lang/rust/issues/65466\">#65466</a> is related, but I think  a value-based strategy is not necessary  to resolve it.</p>",
        "id": 193073202,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193621
    },
    {
        "content": "<p>I haven't found any impls for primitives in libcore</p>",
        "id": 193073212,
        "sender_full_name": "oli",
        "timestamp": 1586193626
    },
    {
        "content": "<p>my opinion was that we're missing a whitelist in the compiler: not all primitives should be considered structurally matchable, IMO</p>",
        "id": 193073268,
        "sender_full_name": "eddyb",
        "timestamp": 1586193655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193073058\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193073058\">said</a>:</p>\n<blockquote>\n<p><code>#[derive(PartialEq)]</code> + manual <code>Eq</code> impl is the thing we want to guard against</p>\n</blockquote>\n<p>(or a manual <code>PartialEq</code> and a <code>#[derive(Eq)]</code>, right?)</p>",
        "id": 193073303,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586193670
    },
    {
        "content": "<p>sure yeah</p>",
        "id": 193073327,
        "sender_full_name": "eddyb",
        "timestamp": 1586193683
    },
    {
        "content": "<p>each trait corresponds to <em>one</em> <code>#[derive(...)]</code></p>",
        "id": 193073354,
        "sender_full_name": "eddyb",
        "timestamp": 1586193699
    },
    {
        "content": "<p>there's two because there's two <code>#[derive(...)]</code>s we need to check the conjunction of</p>",
        "id": 193073376,
        "sender_full_name": "eddyb",
        "timestamp": 1586193720
    },
    {
        "content": "<p>right, because that was the simplest way to handle the injection via <code>derive</code></p>",
        "id": 193073436,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586193729
    },
    {
        "content": "<p>(s/simplest/only/, if you like)</p>",
        "id": 193073460,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586193744
    },
    {
        "content": "<p>this used to be done in the implementation of those derives, by injecting<code>#[structural_match]</code> when both were present</p>",
        "id": 193073475,
        "sender_full_name": "eddyb",
        "timestamp": 1586193754
    },
    {
        "content": "<p>but that's not something the proc macro system is meant to support, hence the traits</p>",
        "id": 193073504,
        "sender_full_name": "eddyb",
        "timestamp": 1586193769
    },
    {
        "content": "<p>(or <em>can</em> fully support)</p>",
        "id": 193073519,
        "sender_full_name": "eddyb",
        "timestamp": 1586193777
    },
    {
        "content": "<p>I'm not really sure primites implement <code>StructuralEq</code></p>",
        "id": 193073564,
        "sender_full_name": "oli",
        "timestamp": 1586193798
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> most primitives are currently handled by a <a href=\"https://github.com/rust-lang/rust/blob/bd18bc9a4c142100a7230e1fd1cfe6be08214693/src/librustc_trait_selection/traits/structural_match.rs#L140\" title=\"https://github.com/rust-lang/rust/blob/bd18bc9a4c142100a7230e1fd1cfe6be08214693/src/librustc_trait_selection/traits/structural_match.rs#L140\"><code>TypeVisitor</code></a>, that's why those impls aren't needed for things to work.</p>",
        "id": 193073581,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193807
    },
    {
        "content": "<p>maybe the traits are poorly named</p>",
        "id": 193073591,
        "sender_full_name": "eddyb",
        "timestamp": 1586193810
    },
    {
        "content": "<p>nothing in the <code>type_marked_structural</code> implementation mentions primitives</p>",
        "id": 193073608,
        "sender_full_name": "oli",
        "timestamp": 1586193823
    },
    {
        "content": "<p><code>AutoDerivedPartialEq</code> and <code>AutoDerivedEq</code> may have been better</p>",
        "id": 193073644,
        "sender_full_name": "eddyb",
        "timestamp": 1586193841
    },
    {
        "content": "<p>because that's <em>all</em> they are</p>",
        "id": 193073696,
        "sender_full_name": "eddyb",
        "timestamp": 1586193848
    },
    {
        "content": "<p>does anything else manually implement <del>it</del> them?</p>",
        "id": 193073724,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586193865
    },
    {
        "content": "<p>Err, well I guess just pointers</p>",
        "id": 193073727,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193866
    },
    {
        "content": "<p>Hmm</p>",
        "id": 193073736,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586193874
    },
    {
        "content": "<p>ahh. yea, <code>typed_marked_structural</code> does not recurse</p>",
        "id": 193073831,
        "sender_full_name": "oli",
        "timestamp": 1586193915
    },
    {
        "content": "<p>I think maybe the names confused people and led to incorrect changes?</p>",
        "id": 193073836,
        "sender_full_name": "eddyb",
        "timestamp": 1586193919
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> because \"marked\" just means the old <code>#[structural_match]</code> attribute check</p>",
        "id": 193073874,
        "sender_full_name": "eddyb",
        "timestamp": 1586193937
    },
    {
        "content": "<p>yea <span aria-label=\"confused\" class=\"emoji emoji-1f615\" role=\"img\" title=\"confused\">:confused:</span></p>",
        "id": 193073887,
        "sender_full_name": "oli",
        "timestamp": 1586193943
    },
    {
        "content": "<p>it means it's \"transparent\"</p>",
        "id": 193073902,
        "sender_full_name": "eddyb",
        "timestamp": 1586193951
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193073724\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193073724\">said</a>:</p>\n<blockquote>\n<p>does anything else manually implement <del>it</del> them?</p>\n</blockquote>\n<p>ah <code>PhantomData</code> does, I think</p>",
        "id": 193073999,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586193977
    },
    {
        "content": "<p>if the derives also put the requirement on its bounds that would work</p>",
        "id": 193074001,
        "sender_full_name": "oli",
        "timestamp": 1586193980
    },
    {
        "content": "<p>that explains why <a href=\"https://github.com/rust-lang/rust/pull/70759\" title=\"https://github.com/rust-lang/rust/pull/70759\">https://github.com/rust-lang/rust/pull/70759</a> doesn't change anything</p>",
        "id": 193074055,
        "sender_full_name": "oli",
        "timestamp": 1586194011
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193074001\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193074001\">said</a>:</p>\n<blockquote>\n<p>if the derives also put the requirement on its bounds that would work</p>\n</blockquote>\n<p>which requirement? <code>StructuralPartialEq</code> and <code>StructuralEq</code>? I think there was a specific reason we didn't do that</p>",
        "id": 193074129,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586194054
    },
    {
        "content": "<p>the traits <em>are badly named</em></p>",
        "id": 193074246,
        "sender_full_name": "eddyb",
        "timestamp": 1586194095
    },
    {
        "content": "<p>so if we made the derives put bounds on generic parameters <em>and</em> fixed <code>for&lt;'a&gt; fn(&amp;'a T)</code> so it'd implement <code>StructuralPartialEq</code>, then we'd have a recursive <code>type_marked_structural</code></p>",
        "id": 193074254,
        "sender_full_name": "oli",
        "timestamp": 1586194099
    },
    {
        "content": "<p>there's no reason to have bounds on them because they're just an attribute</p>",
        "id": 193074262,
        "sender_full_name": "eddyb",
        "timestamp": 1586194103
    },
    {
        "content": "<p>they can't be an attribute because derives can't modify the original item</p>",
        "id": 193074291,
        "sender_full_name": "eddyb",
        "timestamp": 1586194119
    },
    {
        "content": "<p>(AFAIK)</p>",
        "id": 193074297,
        "sender_full_name": "eddyb",
        "timestamp": 1586194125
    },
    {
        "content": "<p>they can't</p>",
        "id": 193074321,
        "sender_full_name": "oli",
        "timestamp": 1586194134
    },
    {
        "content": "<p>a hypothetical <code>StructuralMatch</code> would have to require <code>AutoDerivedPartialEq + AutoDerivedEq</code> <em>at every level</em></p>",
        "id": 193074459,
        "sender_full_name": "eddyb",
        "timestamp": 1586194200
    },
    {
        "content": "<p>But what I'm saying the whole time is that it would be nice to have them be a real trait, because then we could a) move a lot of the logic to libcore instead of doing weird things in the compiler and b) we could add a const method that does the logic that <span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> is trying to implement as a Qualif</p>",
        "id": 193074525,
        "sender_full_name": "oli",
        "timestamp": 1586194206
    },
    {
        "content": "<p>why add a <code>const</code> method?</p>",
        "id": 193074554,
        "sender_full_name": "eddyb",
        "timestamp": 1586194219
    },
    {
        "content": "<p>if you have a <code>const fn value_is_structural_match(&amp;self) -&gt; bool</code> then you could make sure that an <code>Option::None</code> is always <code>structural_match</code></p>",
        "id": 193074656,
        "sender_full_name": "oli",
        "timestamp": 1586194262
    },
    {
        "content": "<p>also IIUC the entire thing is value based, but on the HIR?</p>",
        "id": 193074669,
        "sender_full_name": "eddyb",
        "timestamp": 1586194267
    },
    {
        "content": "<p>for the matching logic</p>",
        "id": 193074675,
        "sender_full_name": "oli",
        "timestamp": 1586194270
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> If you bound on generic parameters, how does <code>const NONE: Option&lt;NonStructuralEqTy&gt; = None</code> get handled.</p>",
        "id": 193074676,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586194270
    },
    {
        "content": "<p>and the whole point with the qualif stuff is that we move the HIR analysis to MIR</p>",
        "id": 193074699,
        "sender_full_name": "eddyb",
        "timestamp": 1586194283
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> ah I highly disapprove of letting the library configure that</p>",
        "id": 193074714,
        "sender_full_name": "eddyb",
        "timestamp": 1586194298
    },
    {
        "content": "<p>yes and I want to move it to const eval and having it defined in source instead of in the compiler</p>",
        "id": 193074717,
        "sender_full_name": "oli",
        "timestamp": 1586194301
    },
    {
        "content": "<p>well... it's auto-derived</p>",
        "id": 193074728,
        "sender_full_name": "oli",
        "timestamp": 1586194311
    },
    {
        "content": "<p>you don't write this as a user</p>",
        "id": 193074736,
        "sender_full_name": "oli",
        "timestamp": 1586194316
    },
    {
        "content": "<p>never, that makes no sense</p>",
        "id": 193074739,
        "sender_full_name": "oli",
        "timestamp": 1586194319
    },
    {
        "content": "<p>just like you don't write <code>StructuralEq</code> impls</p>",
        "id": 193074797,
        "sender_full_name": "oli",
        "timestamp": 1586194336
    },
    {
        "content": "<p>ok, as a first step we can change <code>StructuralEq</code> to <code>AutoDerivedEq</code></p>",
        "id": 193074830,
        "sender_full_name": "oli",
        "timestamp": 1586194352
    },
    {
        "content": "<p>it's trivial to make that correct in the compiler - since we already have this analysis for other purposes</p>",
        "id": 193074832,
        "sender_full_name": "eddyb",
        "timestamp": 1586194353
    },
    {
        "content": "<p>but if you're doing CTFE to find out an answer... that's <em>really</em> scary</p>",
        "id": 193074863,
        "sender_full_name": "eddyb",
        "timestamp": 1586194376
    },
    {
        "content": "<p>I love it</p>",
        "id": 193074873,
        "sender_full_name": "oli",
        "timestamp": 1586194382
    },
    {
        "content": "<p>I hate it</p>",
        "id": 193074883,
        "sender_full_name": "eddyb",
        "timestamp": 1586194387
    },
    {
        "content": "<p><span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 193074891,
        "sender_full_name": "oli",
        "timestamp": 1586194390
    },
    {
        "content": "<p>especially since <em>a sound analysis is what const generics need</em></p>",
        "id": 193074897,
        "sender_full_name": "eddyb",
        "timestamp": 1586194394
    },
    {
        "content": "<p>introducing CTFE as an extra step seems wholly unnecessary</p>",
        "id": 193075009,
        "sender_full_name": "eddyb",
        "timestamp": 1586194443
    },
    {
        "content": "<p>the important thing to me is that we start whitelisting primitives and try to remove the pointers from the whitelist</p>",
        "id": 193075055,
        "sender_full_name": "eddyb",
        "timestamp": 1586194461
    },
    {
        "content": "<p>instead of allowing any built-in types by default</p>",
        "id": 193075091,
        "sender_full_name": "eddyb",
        "timestamp": 1586194475
    },
    {
        "content": "<p>ok</p>",
        "id": 193075106,
        "sender_full_name": "oli",
        "timestamp": 1586194482
    },
    {
        "content": "<p>still, <a href=\"https://github.com/rust-lang/rust/pull/70759\" title=\"https://github.com/rust-lang/rust/pull/70759\">https://github.com/rust-lang/rust/pull/70759</a> makes sense even if we assume that <code>StructuralEq</code> is called <code>AutoDerivedEq</code>, because we can't autoderive <code>Eq</code> for slice types</p>",
        "id": 193075321,
        "sender_full_name": "oli",
        "timestamp": 1586194570
    },
    {
        "content": "<p>slices are built-in</p>",
        "id": 193075335,
        "sender_full_name": "eddyb",
        "timestamp": 1586194580
    },
    {
        "content": "<p>the traits are for <em>literally</em> <code>#[derive(PartialEq, Eq)]</code> <em>written by users</em></p>",
        "id": 193075409,
        "sender_full_name": "eddyb",
        "timestamp": 1586194618
    },
    {
        "content": "<p>I was just thinking that it would make more sense to define these things in libcore instead of in rustc</p>",
        "id": 193075488,
        "sender_full_name": "oli",
        "timestamp": 1586194657
    },
    {
        "content": "<p>so you prefer a whitelist in rustc over writing things like <code>impl StructuralEq for u8</code> (assuming a new trait <code>StructuralEq</code> in contrast to the soon renamed one that is <code>AutoDerivedEq</code>)</p>",
        "id": 193075802,
        "sender_full_name": "oli",
        "timestamp": 1586194806
    },
    {
        "content": "<p>specifically I prefer the value check to be in the compiler instead of a <code>const fn</code> method in a trait</p>",
        "id": 193076973,
        "sender_full_name": "eddyb",
        "timestamp": 1586195298
    },
    {
        "content": "<p>so IMO priorities:</p>\n<ol>\n<li>rename the traits</li>\n<li>add a whitelist for builtin/primitive types instead of \"everything goes\"</li>\n<li>finish the move of the value-oriented analysis to MIR const-qualif</li>\n</ol>",
        "id": 193078626,
        "sender_full_name": "eddyb",
        "timestamp": 1586196018
    },
    {
        "content": "<p>^ <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I put my opinion on how to make progress on this in here</p>",
        "id": 193079918,
        "sender_full_name": "eddyb",
        "timestamp": 1586196630
    },
    {
        "content": "<p>/me needs to grab a snack, low blood sugar after getting dragged into all of this</p>",
        "id": 193079996,
        "sender_full_name": "eddyb",
        "timestamp": 1586196672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> also, in case you missed it, the scary bit for <code>const</code> generics (and kind of pattern-matching too) is that we can't trust pointers</p>",
        "id": 193080057,
        "sender_full_name": "eddyb",
        "timestamp": 1586196701
    },
    {
        "content": "<p>my example was <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd3fca6a9c204a1579448e465461f28b\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd3fca6a9c204a1579448e465461f28b\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=bd3fca6a9c204a1579448e465461f28b</a> and how it changes between debug and release mode</p>",
        "id": 193080183,
        "sender_full_name": "eddyb",
        "timestamp": 1586196744
    },
    {
        "content": "<p>hmm oh dear</p>",
        "id": 193105674,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209264
    },
    {
        "content": "<p>does this imply we should simply issue a breaking change and disallow matching on <code>fn</code> pointers (and other pointer types in general)? Or is this a compiler bug we might expect to be able to fix?</p>",
        "id": 193105829,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209335
    },
    {
        "content": "<p>/me is reminded of the debates in the Scheme community about the behavior of <code>eq?</code>/<code>eqv?</code>/<code>equal?</code> on procedure values.</p>",
        "id": 193105967,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209404
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> the former but we should measure the impact before we think too much about it. I guess I should try to induce this breaking change and we can do a crater check-only run?</p>",
        "id": 193105977,
        "sender_full_name": "eddyb",
        "timestamp": 1586209407
    },
    {
        "content": "<p>not 100% sure I can cleanly do it but I can try</p>",
        "id": 193105998,
        "sender_full_name": "eddyb",
        "timestamp": 1586209421
    },
    {
        "content": "<p>Certainly there are test cases in the compiler itself that were relying on being able to match <code>fn</code> pointers</p>",
        "id": 193106012,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209429
    },
    {
        "content": "<p>that were based on bugs filed when we broke it</p>",
        "id": 193106029,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209440
    },
    {
        "content": "<p>I wasn't too surprised to see <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> note that this could break in the cross-crate case, but I am a little surprised to see it break here</p>",
        "id": 193106135,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209479
    },
    {
        "content": "<p>it's due to deduplication instead of duplication</p>",
        "id": 193106171,
        "sender_full_name": "eddyb",
        "timestamp": 1586209501
    },
    {
        "content": "<p>though I shouldn't be, given my experience with compilers doing stuff with duplicating and de-duplicating function definitions</p>",
        "id": 193106184,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209506
    },
    {
        "content": "<p>duplication is hard to test because you have to somehow get the two constants into the same <code>match</code></p>",
        "id": 193106202,
        "sender_full_name": "eddyb",
        "timestamp": 1586209515
    },
    {
        "content": "<p>yeah I figured it was something like that</p>",
        "id": 193106210,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209520
    },
    {
        "content": "<p>but we have <code>mergefunc</code> now</p>",
        "id": 193106213,
        "sender_full_name": "eddyb",
        "timestamp": 1586209523
    },
    {
        "content": "<p>so deduplication is trivial to trigger :P</p>",
        "id": 193106227,
        "sender_full_name": "eddyb",
        "timestamp": 1586209532
    },
    {
        "content": "<p>(in fact it makes using godbolt a pain at times because identical functions are collapsed and godbolt doesn't seem to show aliases by default...)</p>",
        "id": 193106257,
        "sender_full_name": "eddyb",
        "timestamp": 1586209551
    },
    {
        "content": "<p>on the other hand, maybe we can just go with \"its an underspecified corner of the language\"</p>",
        "id": 193106259,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209554
    },
    {
        "content": "<p>i.e. presumably two procedures with <em>different</em> behavior would have to have different pointer values</p>",
        "id": 193106359,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209590
    },
    {
        "content": "<p>the <code>match</code> behavior may be sound, assuming it doesn't get optimized weirdly, but I'd rather not <code>const</code> generics end up allowing these</p>",
        "id": 193106382,
        "sender_full_name": "eddyb",
        "timestamp": 1586209607
    },
    {
        "content": "<p>and therefore the deduplication case is only going to fire for procedures with identical behavior</p>",
        "id": 193106390,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209613
    },
    {
        "content": "<p>but yeah, I tend to agree with you: Better to force people to change their code</p>",
        "id": 193106415,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209631
    },
    {
        "content": "<p>probably the best thing to do is to force <code>const</code> generics <em>types</em> to be stricter while still using the \"structural match\" information for user ADTs</p>",
        "id": 193106418,
        "sender_full_name": "eddyb",
        "timestamp": 1586209633
    },
    {
        "content": "<p>if we can't change patterns themselves</p>",
        "id": 193106438,
        "sender_full_name": "eddyb",
        "timestamp": 1586209645
    },
    {
        "content": "<p>is there already a bug filed regarding this example you just shared with me?</p>",
        "id": 193106462,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209668
    },
    {
        "content": "<p>if not I'll make one; I want to make sure we keep track of this detail</p>",
        "id": 193106473,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209680
    },
    {
        "content": "<p>not sure, I should've done some filing myself, idk what <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> has done</p>",
        "id": 193106515,
        "sender_full_name": "eddyb",
        "timestamp": 1586209685
    },
    {
        "content": "<p>its okay, I'll look into it. Thanks for exploring this.</p>",
        "id": 193106538,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586209697
    },
    {
        "content": "<p>(<code>const</code> generics args that aren't equivalent to a tree of integer values are impossible to represent in symbol mangling AFAIK. and also unification probably becomes a nightmare)</p>",
        "id": 193106594,
        "sender_full_name": "eddyb",
        "timestamp": 1586209735
    },
    {
        "content": "<p>ironically raw pointers to <code>static</code>s are probably the easiest to handle since they can be described nominally without being wrong (due to them having unique address)</p>",
        "id": 193106678,
        "sender_full_name": "eddyb",
        "timestamp": 1586209800
    },
    {
        "content": "<p>but anything else is a minefield</p>",
        "id": 193106752,
        "sender_full_name": "eddyb",
        "timestamp": 1586209826
    },
    {
        "content": "<p>this reminds me, I need to ping the Rust v0 demangling GCC patch again, argh, nobody seems to be replying to it</p>",
        "id": 193106822,
        "sender_full_name": "eddyb",
        "timestamp": 1586209867
    },
    {
        "content": "<p>and at some point I should go ahead and implement full hierarchical const value mangling support (abusing the <code>const_field</code> query is probably the best way to do this heh)</p>",
        "id": 193106964,
        "sender_full_name": "eddyb",
        "timestamp": 1586209951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> wait what, <code>fn recur</code> in <code>const_to_pat.rs</code> doesn't handle reference types at all?!</p>",
        "id": 193116543,
        "sender_full_name": "eddyb",
        "timestamp": 1586216627
    },
    {
        "content": "<p>they're not banned, so... what happens?!</p>",
        "id": 193116607,
        "sender_full_name": "eddyb",
        "timestamp": 1586216654
    },
    {
        "content": "<p>a <code>PatKind::Constant</code> of reference type, does it get \"lazily unpacked\" or something?</p>",
        "id": 193116639,
        "sender_full_name": "eddyb",
        "timestamp": 1586216683
    },
    {
        "content": "<p>anyway I'm happy to find <a href=\"https://github.com/rust-lang/rust/issues/70861#issuecomment-610093666\" title=\"https://github.com/rust-lang/rust/issues/70861#issuecomment-610093666\">https://github.com/rust-lang/rust/issues/70861#issuecomment-610093666</a></p>",
        "id": 193116779,
        "sender_full_name": "eddyb",
        "timestamp": 1586216796
    },
    {
        "content": "<p>don't we end up calling <code>PartialEq::eq</code> for those cases?</p>",
        "id": 193123525,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586223821
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> that seems weird to me, references should be structural...</p>",
        "id": 193123600,
        "sender_full_name": "eddyb",
        "timestamp": 1586223860
    },
    {
        "content": "<p>also we don't seem to call <code>PartialEq::eq</code> for non-structural ADTs, we just error</p>",
        "id": 193123612,
        "sender_full_name": "eddyb",
        "timestamp": 1586223891
    },
    {
        "content": "<p>its certainly cases <em>like</em> that that end up calling out to the method. Maybe I'm thinking of <code>&amp;[T]</code> ...</p>",
        "id": 193123615,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586223896
    },
    {
        "content": "<p>it's all very obtuse to navigate</p>",
        "id": 193123617,
        "sender_full_name": "eddyb",
        "timestamp": 1586223899
    },
    {
        "content": "<p>anyway I've opened <a href=\"https://github.com/rust-lang/rust/pull/70872\" title=\"https://github.com/rust-lang/rust/pull/70872\">https://github.com/rust-lang/rust/pull/70872</a></p>",
        "id": 193123625,
        "sender_full_name": "eddyb",
        "timestamp": 1586223912
    },
    {
        "content": "<p>now I can stop thinking about this for at least two-three days :P</p>",
        "id": 193123631,
        "sender_full_name": "eddyb",
        "timestamp": 1586223927
    },
    {
        "content": "<p>(because of crater being slow)</p>",
        "id": 193123632,
        "sender_full_name": "eddyb",
        "timestamp": 1586223931
    },
    {
        "content": "<p>Like, this is what motivated <a href=\"https://github.com/rust-lang/rust/issues/62411\" title=\"https://github.com/rust-lang/rust/issues/62411\">#62411</a></p>",
        "id": 193123695,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586223985
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> but there's nothing that does unpacking for something like <code>&amp;(1, 2, 3)</code></p>",
        "id": 193123715,
        "sender_full_name": "eddyb",
        "timestamp": 1586224042
    },
    {
        "content": "<p>it just stops</p>",
        "id": 193123718,
        "sender_full_name": "eddyb",
        "timestamp": 1586224048
    },
    {
        "content": "<p>and something later sees a leaf pattern with a <code>&amp;...</code> constant in it</p>",
        "id": 193123722,
        "sender_full_name": "eddyb",
        "timestamp": 1586224062
    },
    {
        "content": "<p>I'm not even sure how good the lint is if you add enough <code>&amp;</code>s</p>",
        "id": 193123767,
        "sender_full_name": "eddyb",
        "timestamp": 1586224091
    },
    {
        "content": "<p>only the type check can catch anything <em>not</em> the const value check</p>",
        "id": 193123774,
        "sender_full_name": "eddyb",
        "timestamp": 1586224104
    },
    {
        "content": "<p>maybe I'm misunderstanding your questions</p>",
        "id": 193123777,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224108
    },
    {
        "content": "<p>some of the code in <code>const_to_pat</code> is in charge of the code-gen (in order to implement the desired dynamic semantics)</p>",
        "id": 193123788,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224130
    },
    {
        "content": "<p>there is a hole in the Const -&gt; Pat conversion code</p>",
        "id": 193123791,
        "sender_full_name": "eddyb",
        "timestamp": 1586224140
    },
    {
        "content": "<p>but, (unfortunately?) some of the code also in <code>const_to_pat</code> is trying to handle the static semantics (rejecting non-structural-match)</p>",
        "id": 193123794,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224154
    },
    {
        "content": "<p>of the size of a large <code>&amp;</code> truck</p>",
        "id": 193123795,
        "sender_full_name": "eddyb",
        "timestamp": 1586224154
    },
    {
        "content": "<p>I wonder if I can show the deficiencies at play here with exhaustiveness checks hmm</p>",
        "id": 193123857,
        "sender_full_name": "eddyb",
        "timestamp": 1586224218
    },
    {
        "content": "<p>so we've been trying to add the necessary static checks. And I'm trying to understand if you are describing known deficiencies in the static check</p>",
        "id": 193123879,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224260
    },
    {
        "content": "<p>(unrelatedly) wow, <a href=\"https://crater.rust-lang.org/ex/pr-70452\" title=\"https://crater.rust-lang.org/ex/pr-70452\">https://crater.rust-lang.org/ex/pr-70452</a> has slowed down a lot, I wonder what the rate of jobs per hour looks like (as a graph. but maybe I've seen enough graph to last me the whole year...)</p>",
        "id": 193123883,
        "sender_full_name": "eddyb",
        "timestamp": 1586224262
    },
    {
        "content": "<p>or if you are describing deficiencies in the dynamic semantics</p>",
        "id": 193123892,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> not sure, because the code is just not handling references <em>at all</em> except in the very special case of a reference to an ADT (which isn't turned into a pattern even, it just triggers an error)</p>",
        "id": 193123900,
        "sender_full_name": "eddyb",
        "timestamp": 1586224287
    },
    {
        "content": "<p>all sorts of things can happen as a result</p>",
        "id": 193123910,
        "sender_full_name": "eddyb",
        "timestamp": 1586224317
    },
    {
        "content": "<p>well in principle dispatching to <code>PartialEq::eq</code> is \"fine\" if everyone is structural-match</p>",
        "id": 193123958,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224343
    },
    {
        "content": "<p>but how do we check the patterns?</p>",
        "id": 193123963,
        "sender_full_name": "eddyb",
        "timestamp": 1586224352
    },
    {
        "content": "<p>this is the problem</p>",
        "id": 193123967,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224363
    },
    {
        "content": "<p>like, fully structural patterns. there's no code in the expected place to handle references</p>",
        "id": 193123972,
        "sender_full_name": "eddyb",
        "timestamp": 1586224383
    },
    {
        "content": "<p>so if they work they are either buggy or very limited</p>",
        "id": 193123976,
        "sender_full_name": "eddyb",
        "timestamp": 1586224390
    },
    {
        "content": "<p>or very hacky :P</p>",
        "id": 193123979,
        "sender_full_name": "eddyb",
        "timestamp": 1586224403
    },
    {
        "content": "<p>unfortunately I do not think I have time to have this conversation right now</p>",
        "id": 193123983,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224414
    },
    {
        "content": "<p>I really do wish you could at least use words like \"dynamic\" and/or \"static\"</p>",
        "id": 193123988,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224428
    },
    {
        "content": "<p>so that I could have a better idea about what you are saying is buggy</p>",
        "id": 193123991,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224436
    },
    {
        "content": "<p>I don't know which of those are affected</p>",
        "id": 193123992,
        "sender_full_name": "eddyb",
        "timestamp": 1586224440
    },
    {
        "content": "<p>because the code isn't handling references. so it could be both or either</p>",
        "id": 193124050,
        "sender_full_name": "eddyb",
        "timestamp": 1586224457
    },
    {
        "content": "<p>downstream code has to somehow make up for it if anything is to work</p>",
        "id": 193124056,
        "sender_full_name": "eddyb",
        "timestamp": 1586224470
    },
    {
        "content": "<p>my belief is that these are known bugs in the desired static semantics</p>",
        "id": 193124057,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224473
    },
    {
        "content": "<p>that occasional leads to ICE's that arise due to attempts to emit invocations of <code>PartialEq::eq</code> on non-existant impl's.</p>",
        "id": 193124080,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224503
    },
    {
        "content": "<p>it's just broken <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=21e1b92935c02e6c6a7ed8f55620eddb\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=21e1b92935c02e6c6a7ed8f55620eddb\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=21e1b92935c02e6c6a7ed8f55620eddb</a></p>",
        "id": 193124088,
        "sender_full_name": "eddyb",
        "timestamp": 1586224512
    },
    {
        "content": "<p>(lead to ICE's when trying to encode the dynamic semantics, that is)</p>",
        "id": 193124093,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224523
    },
    {
        "content": "<p>ugh</p>",
        "id": 193124094,
        "sender_full_name": "eddyb",
        "timestamp": 1586224523
    },
    {
        "content": "<p>the exhaustiveness checking is another kettle of fish entirelyh</p>",
        "id": 193124111,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224550
    },
    {
        "content": "<p>maybe I should point out that non-structural examples don't matter, they're just blanket-caught by the type-based check</p>",
        "id": 193124154,
        "sender_full_name": "eddyb",
        "timestamp": 1586224565
    },
    {
        "content": "<p>which I guess you did reference up above, but I did not think that was your focus here.</p>",
        "id": 193124155,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224565
    },
    {
        "content": "<p>which you might be meaning by \"static\" checks</p>",
        "id": 193124159,
        "sender_full_name": "eddyb",
        "timestamp": 1586224574
    },
    {
        "content": "<p>I mean, it matters maybe in terms of <em>precision</em> of diagnostics, but they'd be caught anyway</p>",
        "id": 193124168,
        "sender_full_name": "eddyb",
        "timestamp": 1586224589
    },
    {
        "content": "<p>the problem is the code isn't <em>transparent</em> wrt references. it's like they're raw pointers</p>",
        "id": 193124173,
        "sender_full_name": "eddyb",
        "timestamp": 1586224606
    },
    {
        "content": "<p>had you read the examples on <a href=\"https://github.com/rust-lang/rust/issues/62411\" title=\"https://github.com/rust-lang/rust/issues/62411\">#62411</a> ?</p>",
        "id": 193124189,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224648
    },
    {
        "content": "<p>such as <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b9aeae13dc490474e1e45f294ac31e5e\" title=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b9aeae13dc490474e1e45f294ac31e5e\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b9aeae13dc490474e1e45f294ac31e5e</a> ?</p>",
        "id": 193124194,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224660
    },
    {
        "content": "<p>I'm talking about <em>structural</em> things only</p>",
        "id": 193124199,
        "sender_full_name": "eddyb",
        "timestamp": 1586224671
    },
    {
        "content": "<p>I'm tired too, I should've been clearer from the start</p>",
        "id": 193124248,
        "sender_full_name": "eddyb",
        "timestamp": 1586224695
    },
    {
        "content": "<p>so you're talking about cases where everything <em>does</em> implement <code>StructuralPartialEq</code> ?</p>",
        "id": 193124252,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224699
    },
    {
        "content": "<p>yes</p>",
        "id": 193124255,
        "sender_full_name": "eddyb",
        "timestamp": 1586224702
    },
    {
        "content": "<p>that was not clear to me. I was not aware of any bugs there</p>",
        "id": 193124260,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224712
    },
    {
        "content": "<p>for those cases, references aren't handled the same way tuples or arrays are</p>",
        "id": 193124263,
        "sender_full_name": "eddyb",
        "timestamp": 1586224720
    },
    {
        "content": "<p>right, but the whole point is that they don't need to be?</p>",
        "id": 193124265,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224730
    },
    {
        "content": "<p>but why do tuples and arrays?</p>",
        "id": 193124272,
        "sender_full_name": "eddyb",
        "timestamp": 1586224740
    },
    {
        "content": "<p>since dispatching to <code>PartialEq::eq</code> will work for them?</p>",
        "id": 193124278,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224745
    },
    {
        "content": "<p>like, what's the difference?</p>",
        "id": 193124286,
        "sender_full_name": "eddyb",
        "timestamp": 1586224762
    },
    {
        "content": "<p>heh, are you asking <em>why</em> the compiler has ended up in this state?</p>",
        "id": 193124296,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224776
    },
    {
        "content": "<p><code>&amp;</code> is no more than a constructor in patterns</p>",
        "id": 193124297,
        "sender_full_name": "eddyb",
        "timestamp": 1586224778
    },
    {
        "content": "<p>the unequal treatment looks <em>very</em> suspicious</p>",
        "id": 193124300,
        "sender_full_name": "eddyb",
        "timestamp": 1586224789
    },
    {
        "content": "<p>I'm just trying to say that the observable dynamic semantics should be the same</p>",
        "id": 193124306,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224801
    },
    {
        "content": "<p>for cases where the whole recursive structure is structural-match</p>",
        "id": 193124368,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224815
    },
    {
        "content": "<p>so <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> was suggesting earlier today that we should use <code>==</code> for non-structural cases</p>",
        "id": 193124375,
        "sender_full_name": "eddyb",
        "timestamp": 1586224834
    },
    {
        "content": "<p>and for some reason I expected we're doing that already because I thought  I had seen something about <code>==</code></p>",
        "id": 193124388,
        "sender_full_name": "eddyb",
        "timestamp": 1586224853
    },
    {
        "content": "<p>somehow I blanked out on the fact that we use <code>==</code> <em>for</em> structural cases and treat them as opaque</p>",
        "id": 193124404,
        "sender_full_name": "eddyb",
        "timestamp": 1586224869
    },
    {
        "content": "<p>yeah years ago niko and I talked about just throwing in the towel and doing that</p>",
        "id": 193124405,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224871
    },
    {
        "content": "<p>(just using <code>==</code>, that is)</p>",
        "id": 193124411,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224882
    },
    {
        "content": "<p>which begs the natural question: why do this ever for <em>structural</em> cases, where you can always decompose a known value?</p>",
        "id": 193124427,
        "sender_full_name": "eddyb",
        "timestamp": 1586224918
    },
    {
        "content": "<p>but there was a fear that this would be confusing, since manually inlining the RHS of the const-item into a pattern could then have a different semantics.</p>",
        "id": 193124429,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224920
    },
    {
        "content": "<p>are you asking \"why ever dispatch to <code>PartialEq::eq</code> ?</p>",
        "id": 193124476,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224940
    },
    {
        "content": "<p>pretty much, I guess</p>",
        "id": 193124478,
        "sender_full_name": "eddyb",
        "timestamp": 1586224948
    },
    {
        "content": "<p>well, you'd probably have to do some archealogy to answer that question</p>",
        "id": 193124485,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224969
    },
    {
        "content": "<p>it seems unnecessary <em>unless</em> you can't evaluate the constant</p>",
        "id": 193124488,
        "sender_full_name": "eddyb",
        "timestamp": 1586224976
    },
    {
        "content": "<p>maybe someone was worried about code size blow up</p>",
        "id": 193124493,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586224986
    },
    {
        "content": "<p>i.e. cheaper to store one copy of the const value in static storage and dispatch to <code>PartialEq::eq</code> rather than inline the pattern matching code for it at each pattern?</p>",
        "id": 193124506,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586225017
    },
    {
        "content": "<p>but now I'm just guessing</p>",
        "id": 193124511,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586225029
    },
    {
        "content": "<p>that feels like it should be a mode or something</p>",
        "id": 193124512,
        "sender_full_name": "eddyb",
        "timestamp": 1586225030
    },
    {
        "content": "<p>anyway I really do have to go. I'm tired too and its not even 2am where I am.</p>",
        "id": 193124553,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586225048
    },
    {
        "content": "<p>or wait, 4 am? Yikes</p>",
        "id": 193124572,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586225059
    },
    {
        "content": "<p>where MIR matching building keeps consts opaque</p>",
        "id": 193124575,
        "sender_full_name": "eddyb",
        "timestamp": 1586225063
    },
    {
        "content": "<p>(it's 5am here)</p>",
        "id": 193124577,
        "sender_full_name": "eddyb",
        "timestamp": 1586225071
    },
    {
        "content": "<p>while match <em>checking</em> fully expands consts</p>",
        "id": 193124582,
        "sender_full_name": "eddyb",
        "timestamp": 1586225083
    },
    {
        "content": "<p>the way it's setup right now <em>everyone gets the worst of both worlds</em></p>",
        "id": 193124590,
        "sender_full_name": "eddyb",
        "timestamp": 1586225096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I've found so many bugs recently just by looking for places that handled Ty but not ty::Const (showing up in a type/predicate/etc.), so I guess that also makes me more suspicious than usual of asymmetries</p>",
        "id": 193124676,
        "sender_full_name": "eddyb",
        "timestamp": 1586225175
    },
    {
        "content": "<p>but also I vaguely recall <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> asking a question about eagerly expanding const patterns, that might be related to what I'm staring at</p>",
        "id": 193124690,
        "sender_full_name": "eddyb",
        "timestamp": 1586225192
    },
    {
        "content": "<p>whatever, we can sort it out after the crater run. I have enough hacks in it that should gracefully handle most legitimate cases and is only slightly conservative</p>",
        "id": 193124722,
        "sender_full_name": "eddyb",
        "timestamp": 1586225275
    },
    {
        "content": "<p>because exhaustiveness checking doesn't seem to be able to see behind references in general, I suspect most people don't use patterns like that anyway</p>",
        "id": 193124769,
        "sender_full_name": "eddyb",
        "timestamp": 1586225301
    },
    {
        "content": "<p>hopefully we'll need to care less if we start using a value-based analysis on the MIR - even unevaluated consts could be considered fully structural</p>",
        "id": 193125128,
        "sender_full_name": "eddyb",
        "timestamp": 1586225775
    },
    {
        "content": "<p>(like an associated <code>const NONE: Option&lt;T&gt; = None;</code>)</p>",
        "id": 193125142,
        "sender_full_name": "eddyb",
        "timestamp": 1586225803
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/65466\" title=\"https://github.com/rust-lang/rust/issues/65466\">#65466</a> seems relevant to this discussion. In it, we eagerly emit a call to <code>&lt;[O&lt;B&gt;] as PartialEq&gt;::eq</code> despite the fact that <code>PartialEq</code> is not satisfied when building the MIR for <code>main</code>. This issue is somewhat orthogonal to using dataflow to check for structural match violations, since <code>O::None</code> should always be valid for structural matching.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[derive(PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">O</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"c1\">// Can also use PhantomData&lt;T&gt;</span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">B</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"n\">O</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"n\">O</span>::<span class=\"nb\">None</span><span class=\"p\">];</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">O</span>::<span class=\"nb\">None</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">][..]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 193126703,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586227928
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/67088\" title=\"https://github.com/rust-lang/rust/issues/67088\">#67088</a>, the expr walking structural match PR, fixed this by rejecting the code entirely. This is fine as a stopgap measure, but is that what we want in the long-term? I suppose rejecting this is necessary to preserve the ability to choose between semantic and structural equality.</p>",
        "id": 193126904,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586228279
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@ecstatic-morse</span> fascinating, so even for MIR match lowering (not sure what to call that part of MIR building tbh), we <em>must</em> descend through constants of types that <em>do not</em> implement <code>PartialEq</code></p>",
        "id": 193162871,
        "sender_full_name": "eddyb",
        "timestamp": 1586253150
    },
    {
        "content": "<p>and we can't just allow unevaluated generic consts on the sole basis on \"const-qualif vetted them\"</p>",
        "id": 193162941,
        "sender_full_name": "eddyb",
        "timestamp": 1586253212
    },
    {
        "content": "<p>e.g. <code>None::&lt;String&gt;</code> is fine, <code>None::&lt;Uncomparable&gt;</code> is not</p>",
        "id": 193162966,
        "sender_full_name": "eddyb",
        "timestamp": 1586253236
    },
    {
        "content": "<p>which is kind of sad but impossible to reconcidence without us building patterns from promotable-like MIR or something, which still limitates you compared to non-generic constants</p>",
        "id": 193163226,
        "sender_full_name": "eddyb",
        "timestamp": 1586253376
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> good news for people using raw/fn pointers in patterns: due to <a href=\"https://github.com/rust-lang/rust/issues/70889\" title=\"https://github.com/rust-lang/rust/issues/70889\">#70889</a>, we might need to do a completely separate check for const generics <em>anyway</em></p>",
        "id": 193201306,
        "sender_full_name": "eddyb",
        "timestamp": 1586271911
    },
    {
        "content": "<p>so while we could lint it or whatever, it might be as harmless as using <code>==</code> <em>shrug</em></p>",
        "id": 193201398,
        "sender_full_name": "eddyb",
        "timestamp": 1586271948
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I am not happy to keep finding aspects of Rust or parts of the compiler that break const generics in one way or another, but it's probably for the better to bite the bullet and do in-depth \"constant in type\" WF checks</p>",
        "id": 193201817,
        "sender_full_name": "eddyb",
        "timestamp": 1586272110
    },
    {
        "content": "<p>ofc the usual WF-deficient culprits (type aliases and default types, AFAIK) might cause problems here, idk what to do about them</p>",
        "id": 193201890,
        "sender_full_name": "eddyb",
        "timestamp": 1586272146
    },
    {
        "content": "<p>other than \"hopefully it gets caught at use site</p>",
        "id": 193201914,
        "sender_full_name": "eddyb",
        "timestamp": 1586272159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193201398\" title=\"#narrow/stream/131828-t-compiler/topic/Structural.20match.20marker.20traits/near/193201398\">said</a>:</p>\n<blockquote>\n<p>so while we could lint it or whatever, it might be as harmless as using <code>==</code> <em>shrug</em></p>\n</blockquote>\n<p>I am not sure what \"harmless\" is meant to mean here.</p>",
        "id": 193201966,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586272170
    },
    {
        "content": "<p>it's not like the raw/<code>fn</code> pointers are <code>enum</code> discriminants</p>",
        "id": 193202043,
        "sender_full_name": "eddyb",
        "timestamp": 1586272197
    },
    {
        "content": "<p>I don't think they can break the soundness of pattern-matching</p>",
        "id": 193202108,
        "sender_full_name": "eddyb",
        "timestamp": 1586272208
    },
    {
        "content": "<p>they might just be surprising, that's all</p>",
        "id": 193202145,
        "sender_full_name": "eddyb",
        "timestamp": 1586272222
    },
    {
        "content": "<p>oh, okay. Yes, to my knowledge this has never been a soundness concern</p>",
        "id": 193202162,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586272228
    },
    {
        "content": "<p>(same as with using <code>==</code>)</p>",
        "id": 193202173,
        "sender_full_name": "eddyb",
        "timestamp": 1586272232
    },
    {
        "content": "<p>more a question of, as you said, violating a principle of least surprise</p>",
        "id": 193202218,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586272254
    },
    {
        "content": "<p>my motivation and why I was so scared was const generics, but even there I think it would just ICE or cause link errors</p>",
        "id": 193202298,
        "sender_full_name": "eddyb",
        "timestamp": 1586272291
    },
    {
        "content": "<p>and also a dash of \"we don't want to commit to structural nor semantic match by accident\"</p>",
        "id": 193202317,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586272297
    },
    {
        "content": "<p>or like <a href=\"https://github.com/rust-lang/rust/issues/70889\" title=\"https://github.com/rust-lang/rust/issues/70889\">#70889</a> shows, cause two equal things to appear unequal</p>",
        "id": 193202437,
        "sender_full_name": "eddyb",
        "timestamp": 1586272334
    },
    {
        "content": "<p>yes okay. Now I think I am grokking why you were getting so worked up about this last night.</p>",
        "id": 193202454,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586272338
    },
    {
        "content": "<p>I was hoping I could break pattern-matching in a way which would show why letting non-integral values in was scary but I wasn't able to</p>",
        "id": 193202520,
        "sender_full_name": "eddyb",
        "timestamp": 1586272376
    },
    {
        "content": "<p>and I guess from there on I was a walking talking ongoing failure to communicate</p>",
        "id": 193202851,
        "sender_full_name": "eddyb",
        "timestamp": 1586272503
    },
    {
        "content": "<p>welcome to my life</p>",
        "id": 193203231,
        "sender_full_name": "pnkfelix",
        "timestamp": 1586272660
    },
    {
        "content": "<p>I'm really sorry, I'm getting flashbacks of the associated type soundness bug period which lasted a year or two IIRC, and seeing similar things happening around const generics, and getting emotional about it. I really shouldn't</p>",
        "id": 193203510,
        "sender_full_name": "eddyb",
        "timestamp": 1586272730
    },
    {
        "content": "<p>at least const generics won't be stable any time soon so I should relax</p>",
        "id": 193203853,
        "sender_full_name": "eddyb",
        "timestamp": 1586272816
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/67343\" title=\"https://github.com/rust-lang/rust/issues/67343\">#67343</a> is ready to review. It still needs a test for cross-crate constants as match patterns, however.</p>",
        "id": 193236448,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1586287833
    },
    {
        "content": "<p>\"auxiliary\" is the keyword for multi-crate tests</p>",
        "id": 193237879,
        "sender_full_name": "eddyb",
        "timestamp": 1586288547
    },
    {
        "content": "<p>I love how simple the const-qualif impl of that is &lt;3</p>",
        "id": 193238307,
        "sender_full_name": "eddyb",
        "timestamp": 1586288769
    }
]