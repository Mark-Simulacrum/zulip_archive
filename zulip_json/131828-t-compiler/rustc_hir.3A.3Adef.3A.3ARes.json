[
    {
        "content": "<p><code>rustc_hir::def::Res</code> is allocated frequently in arenas, within the <code>rustc_hir::Path</code> and <code>rustc_hir::PathSegment</code> types. <code>Res</code> is 24 bytes in size, but if the <code>Ref::SelfTy</code> variant was removed it would be 12 bytes.</p>",
        "id": 269070440,
        "sender_full_name": "nnethercote",
        "timestamp": 1643011707
    },
    {
        "content": "<p>I want to shrink it, not quite sure how to do it yet.</p>",
        "id": 269070462,
        "sender_full_name": "nnethercote",
        "timestamp": 1643011720
    },
    {
        "content": "<p>I could just <code>Box</code> it, but really the inner type should be hir-arena-allocated too, like <code>Res</code> itself, I guess</p>",
        "id": 269070539,
        "sender_full_name": "nnethercote",
        "timestamp": 1643011775
    },
    {
        "content": "<p><code>PathSegment</code> is also pretty awful, 56 bytes, lots of optional stuff, very clunky, but also not obvious how to shrink it (other than by shrinking <code>Res</code>)</p>",
        "id": 269070638,
        "sender_full_name": "nnethercote",
        "timestamp": 1643011826
    },
    {
        "content": "<p>How often do users of Res need to access the trait, rather than the impl?</p>",
        "id": 269168923,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643056506
    },
    {
        "content": "<p>And how easy is it to get from an impl to the trait it's impl-ing?</p>",
        "id": 269168950,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643056516
    },
    {
        "content": "<p>What if you dropped the first member of the tuple, and let callers go find it via the impl if they need it?</p>",
        "id": 269169012,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643056541
    },
    {
        "content": "<p>Or, correction:</p>",
        "id": 269169194,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643056614
    },
    {
        "content": "<p>It's possible to have a SelfTy with the first field Some and the second None, because the Self could appear <em>in</em> the trait definition rather than an impl. But do you ever need <em>both</em>, or could the <code>(Option, Option)</code> become an enum covering the case of \"in trait\" and \"in impl\" and never need the trait if it has the impl?</p>",
        "id": 269169274,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643056673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> I'm digging through every reference to <code>SelfTy</code> in the compiler, and it <em>looks</em> like there's a concrete set of valid states that the compiler expects and cares about. (Diagnostics cover more cases, but diagnostics can take slow-paths tracking things down.)</p>",
        "id": 269169963,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643057028
    },
    {
        "content": "<p>(It does look like it'd be a pain to untangle, though.)</p>",
        "id": 269170110,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643057103
    },
    {
        "content": "<p>Also, the <code>bool</code> seems like it could get folded into an enum variant to take up no space. (Ideally it could get folded into the <code>Res</code> discriminant so that the variants of SelfTy take up no space, but that'd be more of a pain given all the things referencing SelfTy.)</p>",
        "id": 269170287,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643057179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I'm certainly prepared to split up SelfTy into multiple variants. At first I thought that a <code>(Some,Some)</code> pairing was impossible, but <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_resolve/src/late.rs#L1305\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_resolve/src/late.rs#L1305</a> suggests otherwise. Indeed, that file has all four combinations of the <code>(Option,Option)</code></p>",
        "id": 269175230,
        "sender_full_name": "nnethercote",
        "timestamp": 1643059628
    },
    {
        "content": "<p>I admit I don't understand well the two Options; I find the comment on <code>SelfTy</code>a bit unclear</p>",
        "id": 269175624,
        "sender_full_name": "nnethercote",
        "timestamp": 1643059819
    },
    {
        "content": "<p>I did see that file, when I was looking. But it <em>seemed</em> to me that when the <code>(Some, Some)</code> case is <em>processed</em> (rather than generated), it was promptly checked for consistency.</p>",
        "id": 269175746,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643059898
    },
    {
        "content": "<p>I guess the first example is the <code>Some,None</code> pairing, the second example is the <code>None,Some</code> pairing, and the third example is the <code>Some,Some</code> pairing. (And the <code>None,None</code> pairing is used in the code seemingly for an error case)</p>",
        "id": 269175760,
        "sender_full_name": "nnethercote",
        "timestamp": 1643059903
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> sorry, what does \"consistency\" mean here?</p>",
        "id": 269175891,
        "sender_full_name": "nnethercote",
        "timestamp": 1643059959
    },
    {
        "content": "<p>I wasn't following it completely, but it <em>seemed</em> like in cases where both fields were Some, they were required to be a trait and an impl of that same trait.</p>",
        "id": 269175948,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643059990
    },
    {
        "content": "<p>Which would <em>suggest</em> that it might be OK to assume that the trait was findable from the impl.</p>",
        "id": 269175978,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643060008
    },
    {
        "content": "<p>I think it <em>might</em> be sufficient to have four cases: SelfDummyTy for <code>(None, None)</code>, SelfTraitTy for <code>(Some, None)</code>, SelfImplTy for <code>(_, Some(_, false))</code>, and SelfImplForbidGenericsTy for <code>(_, Some(_, true))</code>. Those seemed like the cases that got unique handling.</p>",
        "id": 269177414,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643060769
    },
    {
        "content": "<p>I'm not <em>sure</em> how much SelfDummyTy is actually needed except for diagnostics, but that may become obvious when trying to translate that.</p>",
        "id": 269177451,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643060797
    },
    {
        "content": "<p>Right, but the latter two are still the same size as <code>SelfTy</code></p>",
        "id": 269489835,
        "sender_full_name": "nnethercote",
        "timestamp": 1643234758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/131828-t-compiler/topic/rustc_hir.3A.3Adef.3A.3ARes/near/269168950\">said</a>:</p>\n<blockquote>\n<p>And how easy is it to get from an impl to the trait it's impl-ing?</p>\n</blockquote>\n<p>It's trivial: the query <code>tcx.impl_trait_ref</code> does it.</p>\n<p>I'm not sure that we need to keep a full <code>DefId</code> in the <code>SelfTy</code>. This variant should not appear in metadata (to be verified).</p>",
        "id": 271748812,
        "sender_full_name": "cjgillot",
        "timestamp": 1644762699
    }
]