[
    {
        "content": "<p>I recently realized that the <code>Ident</code> impl of <code>PartialEq</code> ignores the span location: <a href=\"https://github.com/rust-lang/rust/blob/237949b6c8e5b387e0a9d1e7a22e0397c95fe488/compiler/rustc_span/src/symbol.rs#L1576-L1580\">https://github.com/rust-lang/rust/blob/237949b6c8e5b387e0a9d1e7a22e0397c95fe488/compiler/rustc_span/src/symbol.rs#L1576-L1580</a></p>\n<p>This violates the contract of <code>HashStable</code>, since the <code>HashStable</code> implementation hashes the full span (including the location).</p>\n<p>Unfortunately, the <code>PartialEq</code> impl for <code>Ident</code> is very widely used in the codebase. In particular, it's often used as a map key when we want to perform a hygienic match (which should take the <code>SyntaxContext</code> into account, but not the source location).</p>\n<p>I'm not sure what the best way to resolve this is. cc <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> <span class=\"user-group-mention\" data-user-group-id=\"3282\">@wg-incr-comp</span></p>",
        "id": 268637584,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642650388
    },
    {
        "content": "<blockquote>\n<p>This violates the contract of <code>HashStable</code>, since the <code>HashStable</code> implementation hashes the full span (including the location).</p>\n</blockquote>\n<p>Is the implementation of <code>PartialEq</code> ever used together with <code>HashStable</code>?<br>\nIf it were, things would be broken entirely, but apparently everything mostly works now.</p>",
        "id": 268641740,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1642654646
    },
    {
        "content": "<p><code>PartialEq</code> is often used with regular <code>Hash</code>, and that's where comparison and hashing of <code>Ident</code> behave in compatible way.</p>",
        "id": 268641838,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1642654751
    },
    {
        "content": "<blockquote>\n<p>I'm not sure what the best way to resolve this is</p>\n</blockquote>\n<p>See <code>struct MacroRulesNormalizedIdent</code> for one possibility.<br>\nIt's equivalent for macro 2.0 normalization would take care of majority of maps storing <code>Ident</code>s as keys.<br>\nIt's just kind of annoying and inconvenient.</p>",
        "id": 268642091,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1642654941
    },
    {
        "content": "<p>That struct won't help, since we'd still be comparing the file location inside the <code>Span</code></p>",
        "id": 268643180,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642655891
    },
    {
        "content": "<p>See <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/stable_hasher/trait.HashStable.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/stable_hasher/trait.HashStable.html</a> - I'm not actually sure where in the compiler we rely on the PartialEq/HashStable correspondence</p>",
        "id": 268643253,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642655960
    },
    {
        "content": "<p>What could go wrong if we changed HashStable here to also ignore the location? It seems like the intention is that such “distinct” Idents are meant to be treated as the Same thing in all contexts…?</p>",
        "id": 268683989,
        "sender_full_name": "pnkfelix",
        "timestamp": 1642681692
    },
    {
        "content": "<p>(I mean solely in the context of Ident, of course; not that HashStable should ignore the location for all Spans)</p>",
        "id": 268684038,
        "sender_full_name": "pnkfelix",
        "timestamp": 1642681724
    },
    {
        "content": "<blockquote>\n<p>This violates the contract of HashStable, since the HashStable implementation hashes the full span (including the location).</p>\n</blockquote>\n<p>IIUC, the contract is that <code>a == b</code> implies <code>hash(a) == hash(b)</code>, but not the converse. I don't think there is any breach of contract from the partial eq being actually partial.<br>\nWhat <code>HashStable</code>is interested in is tracking information flow. Having HashStable more complete than PartialEq is not really a cause for concern.</p>\n<p>Nevertheless, having <code>Ident</code>implement <code>Eq</code>is a bit surprising.</p>",
        "id": 268685606,
        "sender_full_name": "cjgillot",
        "timestamp": 1642682636
    },
    {
        "content": "<p>If we have two idents that only differ in the span location, then we have <code>a == b</code> and <code>hash_stable(a) != hash_stable(b)</code>, which violates the contract</p>",
        "id": 268686554,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642683135
    },
    {
        "content": "<p>Also, we get the requirement that \"<code>hash_stable(a) == hash_stable(b)</code> implies <code>a == b</code>\" from the contrapositive of the second requirement</p>",
        "id": 268686753,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642683240
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> The location can get used when emitting diagnostics, so we could re-use a diagnostic with a stale location</p>",
        "id": 268687094,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642683389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/268643180\">said</a>:</p>\n<blockquote>\n<p>That struct won't help, since we'd still be comparing the file location inside the <code>Span</code></p>\n</blockquote>\n<p>I mean the \"normalized\" ident structures would implement <code>PartialEq</code> and regular <code>Hash</code> ignoring locations, but not <code>StableHash</code>.<br>\nThen <code>PartialEq</code> and <code>Hash</code> impls would be removed from regular <code>Ident</code> while keeping its <code>StableHash</code> impl including the location.</p>",
        "id": 268693215,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1642686296
    },
    {
        "content": "<p>One issue I ran into is that Ident is embedded inside other structures that are themselves used as keys (e.g. hir::{ParamName, LifetimeName})</p>",
        "id": 268702540,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642690143
    },
    {
        "content": "<p>so I either need to duplicate those structures or make them generic with a defaulted parameter</p>",
        "id": 268702643,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642690195
    },
    {
        "content": "<p>This is a situation where it would be nice to be able to specify a custom hash and eq function for a HashMap for use with non hash/eq keys</p>",
        "id": 268734068,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642702304
    },
    {
        "content": "<p>That would allow us to adjust the various places relying on using Ident inside a key, without needing to write PartialEq/Hash impls that are available to other code</p>",
        "id": 268734233,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642702364
    },
    {
        "content": "<p>I think hashbrown's raw api comes close to allowing that by taking in the hash as an argument, but it still requires the key to implement Eq</p>",
        "id": 268734718,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642702581
    },
    {
        "content": "<p>Oh, wait, you can actually provide a closure: <a href=\"https://docs.rs/hashbrown/latest/hashbrown/hash_map/struct.RawEntryBuilderMut.html#method.from_hash\">https://docs.rs/hashbrown/latest/hashbrown/hash_map/struct.RawEntryBuilderMut.html#method.from_hash</a></p>",
        "id": 268734841,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642702649
    },
    {
        "content": "<p>I think that approach might actually work</p>",
        "id": 268734882,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642702674
    },
    {
        "content": "<p>This way, we can remove the Eq and Hash impls from structs like ParamName (keeping the HashStable implementation), and still use them as a HashMap key that ignores the span location</p>",
        "id": 268735265,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642702829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/268734068\">said</a>:</p>\n<blockquote>\n<p>This is a situation where it would be nice to be able to specify a custom hash and eq function for a HashMap for use with non hash/eq keys</p>\n</blockquote>\n<p>There was a bit of a conversation along these lines on IRLO recently, <a href=\"https://internals.rust-lang.org/t/pre-rfc-add-comparator-api-for-ordered-collections/15889/21?u=scottmcm\">https://internals.rust-lang.org/t/pre-rfc-add-comparator-api-for-ordered-collections/15889/21?u=scottmcm</a></p>",
        "id": 268737961,
        "sender_full_name": "scottmcm",
        "timestamp": 1642703893
    },
    {
        "content": "<p>About the use of <code>&lt;Ident as PartialEq&gt;</code> for ParamName and LifetimeName, I'm planning to drop them once I finish <a href=\"https://github.com/rust-lang/rust/issues/91557\">#91557</a>.</p>",
        "id": 268739780,
        "sender_full_name": "cjgillot",
        "timestamp": 1642704650
    },
    {
        "content": "<p>A side effect of the current behavior of the <code>PartialEq</code> and <code>Hash</code> impls is that any query keys containing <code>Ident</code> may unexpectedly re-use the cached value</p>",
        "id": 268938952,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642829918
    },
    {
        "content": "<p>e.g. <code>type_param_predicate</code> has an <code>Ident</code> in the key, so two query inputs that only different in the ident location will re-use the same cached query result</p>",
        "id": 268938962,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642829958
    },
    {
        "content": "<p>By the way, where do we actually rely on the correspondence between <code>HashStable</code> and <code>PartialEq</code> ?</p>",
        "id": 268939035,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642830060
    },
    {
        "content": "<p>I don't think we rely on it anywhere.</p>",
        "id": 268951297,
        "sender_full_name": "cjgillot",
        "timestamp": 1642848554
    },
    {
        "content": "<p>Could we 'just' remove the requirement from the docs, and keep the <code>Ident</code> impls the same?</p>",
        "id": 268980439,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1642888167
    },
    {
        "content": "<p>I don’t know, even if its possible to remove the requirement, it seems like a natural one for a developer to <em>expect</em>, and violations of it strike me as a “code smell\"</p>",
        "id": 269112656,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643034360
    },
    {
        "content": "<p>(“natural to expect” apart from the information theoretic problem with it not actually being possible to impelement in general…)</p>",
        "id": 269112733,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643034394
    },
    {
        "content": "<p>probabilities lower than random bitflips are generally considered sufficient.</p>",
        "id": 269112821,
        "sender_full_name": "The 8472",
        "timestamp": 1643034448
    },
    {
        "content": "<p>also, it's actually quite surprising to see the requirement on a non-cryptographic hash function, not expected at all.</p>",
        "id": 269112965,
        "sender_full_name": "The 8472",
        "timestamp": 1643034513
    },
    {
        "content": "<p>Its true, I often come back to that basic probabilistic argument that is used here. Except that I’m not sure how good a job we do of confirming that our implementation comes close to meeting those expectations. (I’ve been wondering if it could make sense to do something analogous to a <a href=\"https://en.wikipedia.org/wiki/Spectral_test\">Spectral test</a> to try to evaluation how well the StableHash method is distributing its outputs...</p>",
        "id": 269113551,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643034815
    },
    {
        "content": "<p>(though that wiki article specifically says that the spectrual test cannot be applied to PRNGs besides LCGs)</p>",
        "id": 269113676,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643034870
    },
    {
        "content": "<p>We have to separate two properties here. That programmers feed distinct inputs to the hash function for distinct values and that siphash doesn't have excess collisions (barring cryptographic attacks). Maybe someone already did the work for the latter part.</p>",
        "id": 269114047,
        "sender_full_name": "The 8472",
        "timestamp": 1643035055
    },
    {
        "content": "<p>hmm, I’ll have to think about that. I <em>think</em> what I’m concerned about is the “feed distinct inputs to the hash function for distinct values”, but that might be just because that’s the part that doesn’t already have a firm theoretical foundation.</p>",
        "id": 269115237,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643035533
    },
    {
        "content": "<p>The concern is that the theory is wrong? It does seem pretty straight-forward to me. It's a series of functions applied to sets. We handwave the hashfunction itself to be bijective by saying collisions don't matter in practice. And we require the struct value -&gt; hash-input to be bijective by API contract. Chaining two bijections is a bijection. Which means distinct inputs will have distinct outputs, which is what the contract says.</p>",
        "id": 269120776,
        "sender_full_name": "The 8472",
        "timestamp": 1643037694
    },
    {
        "content": "<p>I’m not saying the theory is wrong. I’m saying that I’m not sure we have a good way to validate that we are maintaining the “feed distinct inputs to the hash function for distinct values” (and analogously, \"feed same inputs to hash function for ‘same’ (congruent? what is good word here) values” )</p>",
        "id": 269123343,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643038671
    },
    {
        "content": "<p>We currently have internal consistency checks that catch us when we outright fail</p>",
        "id": 269123423,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643038689
    },
    {
        "content": "<p>but I’m wondering if there are other tests that might predict that we are doing a bad job</p>",
        "id": 269123454,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643038707
    },
    {
        "content": "<p>We could extend partialeq implementations to check hash equality in debug mode or something like that</p>",
        "id": 269125706,
        "sender_full_name": "The 8472",
        "timestamp": 1643039686
    },
    {
        "content": "<p>One thing I’ve been idly wondering is if there’s some way to compare the hash method behavior in a way that will detect <em>risk</em> well before ouright <em>collision</em>. But I’m having trouble expressing exactly what I mean here. I guess what I’m thinking is something like: if hash(<code>struct S(X,Y);</code>) != hash(<code>struct S(A,B);</code>), it would be cool if there were some way to observe behavior that would predict that hash(<code>struct S(X,Y);</code>) == hash(<code>struct S(X,B);</code>); i..e, that the second component ends up being ignored by the hash method...</p>",
        "id": 269154284,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643051145
    },
    {
        "content": "<p>(but also: Maybe you don’t need much sophistication here. Some well-directed fuzzing might suffice to catch 80% of the cases that we care about…)</p>",
        "id": 269155022,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643051443
    },
    {
        "content": "<p>Regarding hash function quality: I've been using the data from the smhasher test suite as guidance: <a href=\"https://github.com/rurban/smhasher#readme\">https://github.com/rurban/smhasher#readme</a>. It was the most thorough source of that I could find.</p>",
        "id": 269415612,
        "sender_full_name": "mw",
        "timestamp": 1643205857
    },
    {
        "content": "<p>I think that <code>HashStable</code> should behave the same as <code>Eq</code>. The main reason <code>HashStable</code> exists is to enable equality comparisons of values (query keys and query results) without the actual value being available (e.g. because they are only available in serialized form or are not contained in the cache at all). So I think it would be surprising and very hard to reason about if <code>hash_stable(x) == hash_stable(y)</code> did not imply <code>x.eq(y)</code> and vice versa. I suspect that trying to lift that invariant would cause lots of subtle bugs.</p>\n<p>Maybe we can improve the naming and documentation around this. For example, the term \"hash\" might evoke the wrong assumptions (e.g. that this hash is used for hash maps and thus collisions would only have performance implications). I think the term \"Fingerprint\" captures pretty well what the intended use case for \"stable hashes\" is. Wikipedia puts it like [this](<a href=\"https://en.wikipedia.org/wiki/Fingerprint_(computing)\">https://en.wikipedia.org/wiki/Fingerprint_(computing)</a>:</p>\n<blockquote>\n<p>In computer science, a fingerprinting algorithm is a procedure that maps an arbitrarily large data item (such as a computer file) to a much shorter bit string, its fingerprint, that uniquely identifies the original data for all practical purposes</p>\n</blockquote>\n<blockquote>\n<p>Fingerprint functions may be seen as high-performance hash functions used to uniquely identify substantial blocks of data where cryptographic hash functions may be unnecessary.</p>\n</blockquote>",
        "id": 269548775,
        "sender_full_name": "mw",
        "timestamp": 1643277729
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/268683989\">said</a>:</p>\n<blockquote>\n<p>What could go wrong if we changed HashStable here to also ignore the location? It seems like the intention is that such “distinct” Idents are meant to be treated as the Same thing in all contexts…?</p>\n</blockquote>\n<p>HashStable needs to capture any aspect of a value that can influence decisions. Query providers must be deterministic, that is, given the same inputs it must produce the same outputs. So, if we had two query invocations with an Ident as input, we would consider it them same if their input has the same stable hash, but if the stable hash does not include the span and then the query implementation does things differently dependent on that span, the output would not be deterministic anymore. IIUC, the same is true if PartialEq ignores some fields because we always look up the query key in a HashMap to see if the result is already cached in memory. Consequently we would get a different result depending on which invocation came first.</p>",
        "id": 269550654,
        "sender_full_name": "mw",
        "timestamp": 1643278742
    },
    {
        "content": "<p>So is the real bug here that Ident is ignoring its Location, and there should be a different predicate for that relationship?</p>",
        "id": 269603765,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643303145
    },
    {
        "content": "<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>",
        "id": 269629758,
        "sender_full_name": "cjgillot",
        "timestamp": 1643313764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758\">said</a>:</p>\n<blockquote>\n<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>\n</blockquote>\n<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>",
        "id": 269711784,
        "sender_full_name": "mw",
        "timestamp": 1643363927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269711784\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758\">said</a>:</p>\n<blockquote>\n<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>\n</blockquote>\n<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>\n</blockquote>\n<p>Which is the setup that we had before <del>maybe 2017</del> 2018.<br>\nIdentifiers very much need spans though, that's why it was changed.</p>",
        "id": 269712701,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1643364421
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/49154\">https://github.com/rust-lang/rust/pull/49154</a></p>",
        "id": 269713021,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1643364582
    },
    {
        "content": "<p>So the spans are used for diagnostics a lot?</p>",
        "id": 269713343,
        "sender_full_name": "mw",
        "timestamp": 1643364764
    },
    {
        "content": "<p>If the span data is needed as part of Ident then I think both HashStable and PartialEq should take it into account.</p>",
        "id": 269713644,
        "sender_full_name": "mw",
        "timestamp": 1643364953
    },
    {
        "content": "<p>(Thinking out loud here, this is not a thought-through proposal)</p>\n<p>Maybe we could introduce a <code>QueryValue</code> trait that must be implement by all types that show up in query keys and values. That trait would have its own, stronger version of <code>Eq</code> and replace <code>HashStable</code>. And then the hashmaps in the query system would use the stronger form of <code>Eq</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">QueryValue</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Feed this value into a fingerprinter</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">update_fingerprint</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">context</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">FingerprintingContext</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fingerprinter</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Fingerprinter</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Same as Eq, but with the additional guarantee that no part of the value is ignored.</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">is_equal_to</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269724370,
        "sender_full_name": "mw",
        "timestamp": 1643370979
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> mentioned the other day that Salsa faces a similar problem with regular <code>Eq</code> not actually being strong enough in all cases.</p>",
        "id": 269724651,
        "sender_full_name": "mw",
        "timestamp": 1643371161
    },
    {
        "content": "<p>Putting fingerprinting and strong equality into a single trait might make it easier to uphold the condition that the two have to behave equivalently.</p>",
        "id": 269725079,
        "sender_full_name": "mw",
        "timestamp": 1643371359
    },
    {
        "content": "<p>(I added an <code>unsafe</code> to the trait in the sample above, which might help enforce that any impl not generated by <code>#[derive(QueryValue)]</code> needs to be done with a great deal of care)</p>",
        "id": 269725589,
        "sender_full_name": "mw",
        "timestamp": 1643371631
    },
    {
        "content": "<p>Isn't it a common problem that we want a type to have extra data for diagnostics that shouldn't be hashed? We could have two different structs for these cases and a trait to convert one way.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">IntoQueryValue</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Ident</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">QueryValue</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">RawIdent</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 269753713,
        "sender_full_name": "Cameron Steffen",
        "timestamp": 1643383880
    },
    {
        "content": "<p>Unfortunately, I think that would lead to a similar situation as we have today, where it is easy to think that part of the data is \"just for diagnostics\" but it breaks the query system's invariants in subtle ways that are hard to debug.</p>",
        "id": 269756572,
        "sender_full_name": "mw",
        "timestamp": 1643385038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269711784\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758\">said</a>:</p>\n<blockquote>\n<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>\n</blockquote>\n<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>\n</blockquote>\n<p>Like Vadim Petrochenkov says, we actually need the span in Ident.  I'd rather do the opposite: keep <code>Ident</code> with symbol+span, and remove the PartialEq impl.  When the PartialEq impl is required (for instance for name resolution), use a specific <code>struct HygienicSymbol { name: Symbol, ctxt: SyntaxContext }</code>.</p>",
        "id": 269761337,
        "sender_full_name": "cjgillot",
        "timestamp": 1643386990
    },
    {
        "content": "<p>I think adding the additional trait sounds like a great idea</p>",
        "id": 269767438,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643389510
    },
    {
        "content": "<p>It would also allow us to make Idents behave properly in query keys</p>",
        "id": 269767505,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643389536
    },
    {
        "content": "<p>Right now, we'll use the same in-memory cache key for two Idents that only differ in the location</p>",
        "id": 269767659,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643389591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> I tried removing the PartialEq impl, but it ended causing a large amount of churn, and worse ergonomics</p>",
        "id": 269767777,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643389649
    },
    {
        "content": "<p>Additionally, there are places where we have an Ident behind several structs (e.g. hir::LifetimeName) which need a PartialEq impl</p>",
        "id": 269767884,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643389686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269756572\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, I think that would lead to a similar situation as we have today, where it is easy to think that part of the data is \"just for diagnostics\" but it breaks the query system's invariants in subtle ways that are hard to debug.</p>\n</blockquote>\n<p>Maybe the diagnostic-only info could be hidden inside a nested struct to make it clear that it shouldn't be used for anything else? If you're calling <code>diagnostic_info()</code> on a non-diagnostic path that'd make it more obvious.</p>",
        "id": 269769290,
        "sender_full_name": "The 8472",
        "timestamp": 1643390262
    },
    {
        "content": "<p>The issue is that diagnostic-related information still matters for incremental compilation</p>",
        "id": 269776300,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643392846
    },
    {
        "content": "<p>For example, we capture and store the diagnostic emitted during a query invocation, so that we can replay them if we load the result from disk in the next compilation session</p>",
        "id": 269776363,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643392874
    },
    {
        "content": "<p>any information that goes into the diagnostic (e.g. ident spans) needs to be properly tracked, so that we don't re-use a stale diagnostic</p>",
        "id": 269776429,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643392904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> Do you think we could just add <code>is_equal_to</code> to the existing <code>HashStable</code> trait? AFAIK, we already use <code>HashStable</code>to indicate types that can be used in query keys/values</p>",
        "id": 269776663,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643392974
    },
    {
        "content": "<p>On further thought, I think we would want a trait <code>HashStableEq: HashStable</code> that has an <code>is_equal_to</code> method. There are types that have no need for any kind of equality impl (e.g. <code>mir::Body</code>), but that show up in query values</p>",
        "id": 269807964,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643406823
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269807964\">said</a>:</p>\n<blockquote>\n<p>On further thought, I think we would want a trait <code>HashStableEq: HashStable</code> that has an <code>is_equal_to</code> method. There are types that have no need for any kind of equality impl (e.g. <code>mir::Body</code>), but that show up in query values</p>\n</blockquote>\n<p>That's an interesting observation! Yes, <code>is_equal_to</code> might only be needed for things that show up in query keys. I'll think about it some more.</p>",
        "id": 269997396,
        "sender_full_name": "mw",
        "timestamp": 1643619075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269761337\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269711784\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269629758\">said</a>:</p>\n<blockquote>\n<p>I'd rather say that the real bug is that Ident conflates two distinct abstractions: it's a symbol with both hygiene and location, which behaves like a symbol with only hygiene.</p>\n</blockquote>\n<p>Yes, that sounds right to me (with my limited knowledge of hygiene). It would be great if we could make <code>Ident</code> retain the needed hygiene information but get rid of the span field.</p>\n</blockquote>\n<p>Like Vadim Petrochenkov says, we actually need the span in Ident.  I'd rather do the opposite: keep <code>Ident</code> with symbol+span, and remove the PartialEq impl.  When the PartialEq impl is required (for instance for name resolution), use a specific <code>struct HygienicSymbol { name: Symbol, ctxt: SyntaxContext }</code>.</p>\n</blockquote>\n<p>If we don't use PartialEq for query key comparison anymore (as suggested above) then it should be fine for PartialEq to behave however needed in other usage contexts, I'd say.</p>",
        "id": 269998021,
        "sender_full_name": "mw",
        "timestamp": 1643619378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269769290\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269756572\">said</a>:</p>\n<blockquote>\n<p>Unfortunately, I think that would lead to a similar situation as we have today, where it is easy to think that part of the data is \"just for diagnostics\" but it breaks the query system's invariants in subtle ways that are hard to debug.</p>\n</blockquote>\n<p>Maybe the diagnostic-only info could be hidden inside a nested struct to make it clear that it shouldn't be used for anything else? If you're calling <code>diagnostic_info()</code> on a non-diagnostic path that'd make it more obvious.</p>\n</blockquote>\n<p>I think another issue is that it is just deviously hard to implement this correctly and then keep it correct while the codebase keeps evolving. No one really has global knowledge of the codebase anymore. I think it is safe to say that virtually all cases where we tried to be clever about ignoring parts of values in the query system have ended in subtle, hard to find, and often hard to fix, bugs.</p>",
        "id": 269998673,
        "sender_full_name": "mw",
        "timestamp": 1643619710
    },
    {
        "content": "<p>I opened <a href=\"https://github.com/rust-lang/rust/pull/93467\">https://github.com/rust-lang/rust/pull/93467</a> to add HashStableEq</p>",
        "id": 270056817,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643645353
    },
    {
        "content": "<p>There are some perf regressions, so I might try adding some <code>#[inline]</code>s</p>",
        "id": 270056896,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1643645376
    },
    {
        "content": "<p>One thing I realized: Interners must also use HashStableEq -- at least for things that end up in query keys. When we intern something and then doing equality checking by comparing pointer values, we are essentially caching the equality check done when the value was initially interned. So if the interner uses Eq then HashStableEq would be forced to do a deep equality check on such values. </p>\n<p>I personally think that it is preferably for interning to use a complete equality check in any case, independent of incr. comp., because anything else seems like a footgun (similar to e.g. having a RefCell in an interned value).</p>\n<p>In general, I would prefer it if PartialEq and Eq impls always take the entire value into account because that's the most predictable. And then, when a specialized, limited form of equality checking is need in a particular case, introduce a new-type that implements that (as <span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> suggested <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269761337\">above</a>). The question is whether that is properly enforceable throughout the  entire codebase. I doubt that we can, unless we can automate it via a lint for example.</p>\n<p>Having <code>HashStableEq</code> seems like the next best approach. We just have to be careful that we actually use it in all the places that require it.</p>",
        "id": 270180876,
        "sender_full_name": "mw",
        "timestamp": 1643709902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/270056896\">said</a>:</p>\n<blockquote>\n<p>There are some perf regressions, so I might try adding some <code>#[inline]</code>s</p>\n</blockquote>\n<p>I'm wondering where those come from. In theory the current Eq implementation should already do the same amount of work, except for minor cases like <code>Ident</code>.</p>",
        "id": 270181479,
        "sender_full_name": "mw",
        "timestamp": 1643710090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/270180876\">said</a>:</p>\n<blockquote>\n<p>In general, I would prefer it if PartialEq and Eq impls always take the entire value into account because that's the most predictable. And then, when a specialized, limited form of equality checking is need in a particular case, introduce a new-type that implements that (as <span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> suggested <a href=\"#narrow/stream/131828-t-compiler/topic/Ident.20and.20.60PartialEq.60.20.2F.20.60HashStable.60/near/269761337\">above</a>). The question is whether that is properly enforceable throughout the  entire codebase. I doubt that we can, unless we can automate it via a lint for example.</p>\n</blockquote>\n<p>I would prefer this as well. I think an internal lint could be worth investigating...</p>",
        "id": 270232070,
        "sender_full_name": "pnkfelix",
        "timestamp": 1643730196
    }
]