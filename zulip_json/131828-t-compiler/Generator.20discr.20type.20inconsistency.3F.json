[
    {
        "content": "<p>Hi, while working on async fn debuginfo I stumbled across something that I can't quite make sense of: Currently debuginfo assumes that generator discriminants are always <code>u32</code>,  as specified in <a href=\"https://github.com/rust-lang/rust/blob/902e59057ee723dd6fda6e757b408d487a388139/compiler/rustc_middle/src/ty/sty.rs#L691-L695\">GeneratorSubsts::discr_ty</a>, but when extracting the tag from the layout, it usually is something smaller. The layout code does indeed use the smallest possible integer type it seems: <a href=\"https://github.com/rust-lang/rust/blob/902e59057ee723dd6fda6e757b408d487a388139/compiler/rustc_middle/src/ty/layout.rs#L1588\">https://github.com/rust-lang/rust/blob/902e59057ee723dd6fda6e757b408d487a388139/compiler/rustc_middle/src/ty/layout.rs#L1588</a></p>\n<p>Is this just a bug or am I misunderstanding something here? Both versions seemed to be used in various placed.</p>\n<p>Maybe <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> would know what's going on?</p>",
        "id": 271822292,
        "sender_full_name": "mw",
        "timestamp": 1644843624
    },
    {
        "content": "<p>There is a difference between the discriminant and tag. A tag is one possible encoding of a discriminant. Niche filling is another.</p>",
        "id": 271823758,
        "sender_full_name": "bjorn3",
        "timestamp": 1644844405
    },
    {
        "content": "<p>Which of the two describes how many bytes the discriminant actually takes up in memory (inside of an enum or a generator)?</p>",
        "id": 271826749,
        "sender_full_name": "mw",
        "timestamp": 1644846004
    },
    {
        "content": "<p>The tag. The tag is the actual encoding of the discriminant in memory if a tagged layout is chosen.</p>",
        "id": 271828031,
        "sender_full_name": "bjorn3",
        "timestamp": 1644846650
    },
    {
        "content": "<p>Thanks!</p>",
        "id": 271837572,
        "sender_full_name": "mw",
        "timestamp": 1644850858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/131828-t-compiler/topic/Generator.20discr.20type.20inconsistency.3F/near/271828031\">said</a>:</p>\n<blockquote>\n<p>... if a tagged layout is chosen.</p>\n</blockquote>\n<p>That sounds like it might be different for niche layout enums. Is that true? Currently, the debuginfo code uses <a href=\"https://github.com/rust-lang/rust/blob/b321742c6c27494897a88cd5ac17ac20aa3469a1/compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs#L2194-L2205\">the following code</a> for determining the right integer type for the discriminant:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Variants</span>::<span class=\"n\">Multiple</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">tag_encoding</span>: <span class=\"nc\">TagEncoding</span>::<span class=\"n\">Niche</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tag_field</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// Find the integer type of the correct size.</span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">align</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">align</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tag_type</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">tag</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Int</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">F32</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Integer</span>::<span class=\"n\">I32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">F64</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Integer</span>::<span class=\"n\">I64</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Pointer</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">data_layout</span><span class=\"p\">().</span><span class=\"n\">ptr_sized_integer</span><span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">.</span><span class=\"n\">to_ty</span><span class=\"p\">(</span><span class=\"n\">cx</span><span class=\"p\">.</span><span class=\"n\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// other cases omitted</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271840117,
        "sender_full_name": "mw",
        "timestamp": 1644851854
    },
    {
        "content": "<p>That is, it also looks at the tag (and nothing else)</p>",
        "id": 271840335,
        "sender_full_name": "mw",
        "timestamp": 1644851936
    },
    {
        "content": "<p>IIRC there are 4 possible layouts:</p>\n<ul>\n<li>Uninhabited: There is no layout for uninhabited types because they cannot exist at runtime</li>\n<li>Univariant: If there is only one variant there is no need to store a tag because we always know which variant is active. If there is any data in the variant, the layout corresponds to the layout of that data, otherwise we are a ZST.</li>\n<li>Directly tagged: There is tag field and the value of the discriminant (which is different than the <code>VariantIdx</code>) is used as the tag. </li>\n<li>Niche: There is a specific place to store the tag but the tag does not match the discriminants. Therefore, the type of the tag and the type of the discriminant can be (and often are) different.</li>\n</ul>\n<p>From what I've seen, the debuginfo code doesn't consistently use the terms \"tag\" and \"discriminant\" correctly.</p>",
        "id": 271842440,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1644852802
    },
    {
        "content": "<p>So of these \"directly tagged\" and \"niche\" are both still \"tagged\" in the sense a tag does exist in memory. For the other two layouts, there are no tags.</p>",
        "id": 271842500,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1644852834
    }
]