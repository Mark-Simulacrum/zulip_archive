[
    {
        "content": "<p>So I'm happy to take on any of the extra work remaining for <a href=\"https://github.com/rust-lang/rust/issues/44109\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/44109\">#44109</a>.</p>",
        "id": 130096458,
        "sender_full_name": "davidtwco",
        "timestamp": 1532263289
    },
    {
        "content": "<p>looks like that is mostly enum variant implementation?</p>",
        "id": 130096588,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1532263464
    },
    {
        "content": "<p>That's all I think.</p>",
        "id": 130096589,
        "sender_full_name": "davidtwco",
        "timestamp": 1532263475
    },
    {
        "content": "<p>that is pretty out of cache for me but doesn't seem <em>super</em> hard</p>",
        "id": 130096590,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1532263475
    },
    {
        "content": "<p>Do you think you'd be able to throw together some high level pointers? Only if you've got the time of course.</p>",
        "id": 130170694,
        "sender_full_name": "davidtwco",
        "timestamp": 1532376185
    },
    {
        "content": "<p>yep adding to my list for today</p>",
        "id": 130188960,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1532404912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Think you'd be able to put something together here before next week? I know you're not going to be around next week much so it'd be nice to have something to start with. If you don't have time though, don't worry about it.</p>",
        "id": 130347986,
        "sender_full_name": "davidtwco",
        "timestamp": 1532616099
    },
    {
        "content": "<p>whoops forgot -- I had some illegal thing on my to do list, maybe this was it :)</p>",
        "id": 130348811,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1532616694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@David Wood</span> do <a href=\"https://github.com/rust-lang/rust/issues/44109#issuecomment-408127667\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/44109#issuecomment-408127667\">these notes make sense to you</a>?</p>",
        "id": 130349816,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1532617343
    },
    {
        "content": "<p>Yeah, that's great.</p>",
        "id": 130350549,
        "sender_full_name": "davidtwco",
        "timestamp": 1532617817
    },
    {
        "content": "<p>Submitted <a href=\"https://github.com/rust-lang/rust/issues/52775\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/52775\">#52775</a> for it.</p>",
        "id": 130406738,
        "sender_full_name": "davidtwco",
        "timestamp": 1532694257
    },
    {
        "content": "<p>A small update here on my progress on this after <a href=\"https://github.com/rust-lang/rust/issues/52775\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/52775\">#52775</a> (given that I'm interested in seeing the whole RFC implemented) - I'm probably going to attempt to do the prereqs for an actual RFC 2008 variants implementation this week - I have no idea how to do that, so I'll just mess around and see if I can come up with something.</p>",
        "id": 130572320,
        "sender_full_name": "davidtwco",
        "timestamp": 1532950846
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@David Wood</span> are you interested in doing that refactoring that <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> mentioned? (to separate the def-ids for variants and structs?)</p>",
        "id": 130622022,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533013302
    },
    {
        "content": "<p>Yeah, definitely <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>.</p>",
        "id": 130626544,
        "sender_full_name": "davidtwco",
        "timestamp": 1533021346
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> did you ever take a stab at that? want some tips for how to do it?</p>",
        "id": 130975614,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533558715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I ended up not having time, just got back from a short holiday. I'm still happy to do it, would appreciate any tips.</p>",
        "id": 130975778,
        "sender_full_name": "davidtwco",
        "timestamp": 1533558940
    },
    {
        "content": "<p>ok hmm I could try to take a look -- this is one of those cases where I guess you make the split and then try to get everything building again, as much as anything =)</p>",
        "id": 130978380,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533561933
    },
    {
        "content": "<p>but It hink what I would do is to look at the \"struct ctor\" cases</p>",
        "id": 130978382,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533561943
    },
    {
        "content": "<p>it will probalby cleanup the code a bunch, or could potentially do so</p>",
        "id": 130978386,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533561949
    },
    {
        "content": "<p>since my guess would be there are a number of cases there are special-casing \"enums vs tuple structs\" now that could hopefully be unified</p>",
        "id": 130978431,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533561963
    },
    {
        "content": "<p>So, I've not messed around with this that much, but I'm getting nowhere. I can find a bunch of places where struct ctors are registered and all sorts of things like that, but I can't quite work out where it is actually given its id.</p>",
        "id": 131236978,
        "sender_full_name": "davidtwco",
        "timestamp": 1533907512
    },
    {
        "content": "<p>the goal here was to separate out the ID of the variant from its constructor?</p>",
        "id": 131237354,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533907982
    },
    {
        "content": "<p>/me tries to remember</p>",
        "id": 131237357,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1533907984
    },
    {
        "content": "<p>Yes.</p>",
        "id": 131237363,
        "sender_full_name": "davidtwco",
        "timestamp": 1533907997
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I've mostly been looking at this recently and I'm still making very little progress. I understand where the ids are being assigned for structs/variants and what ids are being assigned and used. I've then managed to introduce another id for variants that I intend to identify the ctor separately from the variant. But as soon as I get that compiling I end up with assertions failing here or there that I struggle to track down the root cause of.</p>",
        "id": 132654969,
        "sender_full_name": "davidtwco",
        "timestamp": 1535050801
    },
    {
        "content": "<p>hmm why would you need separate ctor vs variant?</p>",
        "id": 132660080,
        "sender_full_name": "eddyb",
        "timestamp": 1535057545
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> was suggesting this because they want to assign a distinct privacy</p>",
        "id": 132660387,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535057928
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> sorry, I've been playing constant catch up here :(</p>",
        "id": 132660403,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535057945
    },
    {
        "content": "<p>oh, <code>#[non_exhaustive]</code> relies on privacy?</p>",
        "id": 132660420,
        "sender_full_name": "eddyb",
        "timestamp": 1535057954
    },
    {
        "content": "<p>just like adding an extra private field?</p>",
        "id": 132660430,
        "sender_full_name": "eddyb",
        "timestamp": 1535057968
    },
    {
        "content": "<p>(except enums don't have private fields)</p>",
        "id": 132660439,
        "sender_full_name": "eddyb",
        "timestamp": 1535057981
    },
    {
        "content": "<p>it seems hard to separate constructors from the variants pattern-matching works</p>",
        "id": 132660448,
        "sender_full_name": "eddyb",
        "timestamp": 1535057995
    },
    {
        "content": "<p>like idk if I could get it right the first few times, I don't know where I would start ripping out the floorboards from</p>",
        "id": 132660507,
        "sender_full_name": "eddyb",
        "timestamp": 1535058013
    },
    {
        "content": "<p>and I would be <em>very</em> suspicious if anything actually worked too well</p>",
        "id": 132660520,
        "sender_full_name": "eddyb",
        "timestamp": 1535058032
    },
    {
        "content": "<p>Also, it seems risky because it wouldn't be imported in one of the namespaces, potentially</p>",
        "id": 132660611,
        "sender_full_name": "eddyb",
        "timestamp": 1535058155
    },
    {
        "content": "<p>I would prefer it if they weren't split but privacy wasn't used</p>",
        "id": 132660623,
        "sender_full_name": "eddyb",
        "timestamp": 1535058180
    },
    {
        "content": "<p>or it was checked differently? is it really not possible to do without splitting variants from their constructors?</p>",
        "id": 132660649,
        "sender_full_name": "eddyb",
        "timestamp": 1535058216
    },
    {
        "content": "<blockquote>\n<p>oh, <code>#[non_exhaustive]</code> relies on privacy?</p>\n</blockquote>\n<p>well, in the case of a tuple struct/variant, it makes the ctor \"crate private\" I think?</p>",
        "id": 132660822,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058398
    },
    {
        "content": "<blockquote>\n<p>or it was checked differently? is it really not possible to do without splitting variants from their constructors?</p>\n</blockquote>\n<p>I think it is possible</p>",
        "id": 132660836,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058429
    },
    {
        "content": "<p>I'm not sure what corner cases must be considered, though.</p>",
        "id": 132660838,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058436
    },
    {
        "content": "<p>see also <a href=\"https://github.com/rust-lang/rust/pull/52775#issuecomment-408644451\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/52775#issuecomment-408644451\">@**Vadim Petrochenkov**'s comment</a>, here</p>",
        "id": 132660849,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058470
    },
    {
        "content": "<p>so, like, when type-checking the path to access it in an expression</p>",
        "id": 132660850,
        "sender_full_name": "eddyb",
        "timestamp": 1535058470
    },
    {
        "content": "<p>we could \"just\" check that we're in the same crate, if it's marked with the attribute, right?</p>",
        "id": 132660897,
        "sender_full_name": "eddyb",
        "timestamp": 1535058500
    },
    {
        "content": "<p>I mean, it <em>would</em> be a valid stop-gap?</p>",
        "id": 132660899,
        "sender_full_name": "eddyb",
        "timestamp": 1535058509
    },
    {
        "content": "<p>presumably yes we could sort of special case this</p>",
        "id": 132660902,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058511
    },
    {
        "content": "<p>or name resolution could too, I guess</p>",
        "id": 132660908,
        "sender_full_name": "eddyb",
        "timestamp": 1535058531
    },
    {
        "content": "<p>wait, so are the semantics that you have to use <code>Enum::Variant(..)</code> in a pattern, i.e. can't rely on <em>any</em> fields being there?</p>",
        "id": 132660918,
        "sender_full_name": "eddyb",
        "timestamp": 1535058553
    },
    {
        "content": "<p>no, just that you must include <code>..</code> basically</p>",
        "id": 132660982,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058635
    },
    {
        "content": "<p>i.e., new fields may be added</p>",
        "id": 132660985,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058638
    },
    {
        "content": "<p>I believe that is the semantics, anyway</p>",
        "id": 132660990,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058646
    },
    {
        "content": "<p>at the end?</p>",
        "id": 132660993,
        "sender_full_name": "eddyb",
        "timestamp": 1535058649
    },
    {
        "content": "<p>right</p>",
        "id": 132660995,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058654
    },
    {
        "content": "<p>one could also imagine changing privacy so that -- for any given def-id -- we have multiple privacy values</p>",
        "id": 132661002,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058664
    },
    {
        "content": "<p>e.g., separate type/value privacy</p>",
        "id": 132661010,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058675
    },
    {
        "content": "<p>I'm not really sure how that stuff all works anymore</p>",
        "id": 132661012,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058680
    },
    {
        "content": "<p>the PR that <span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> wrote already handled the pattern stuff — or at least some of it</p>",
        "id": 132661023,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058697
    },
    {
        "content": "<p>but not the expression position</p>",
        "id": 132661030,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058705
    },
    {
        "content": "<p>why do we want to use privacy? it's not like the attribute disappears?</p>",
        "id": 132661031,
        "sender_full_name": "eddyb",
        "timestamp": 1535058706
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> just thought it was an elegant way to achieve the end</p>",
        "id": 132661076,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058724
    },
    {
        "content": "<p>I'm a bit confused because the interactions seem <em>subtle</em></p>",
        "id": 132661079,
        "sender_full_name": "eddyb",
        "timestamp": 1535058727
    },
    {
        "content": "<p>if the constructor doesn't get imported... can I shadow it?</p>",
        "id": 132661083,
        "sender_full_name": "eddyb",
        "timestamp": 1535058740
    },
    {
        "content": "<p>presumably yes</p>",
        "id": 132661088,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058754
    },
    {
        "content": "<p>does pattern-matching a tuple variant work <em>without</em> it being in the value namespace?</p>",
        "id": 132661089,
        "sender_full_name": "eddyb",
        "timestamp": 1535058759
    },
    {
        "content": "<p>this seems <em>very scary</em> to me</p>",
        "id": 132661093,
        "sender_full_name": "eddyb",
        "timestamp": 1535058766
    },
    {
        "content": "<p>/me wishes we didn't even have tuple structs most of the time</p>",
        "id": 132661095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058773
    },
    {
        "content": "<p>hmm yes <em>that</em> is a good question</p>",
        "id": 132661100,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058784
    },
    {
        "content": "<p>I want to keep namespaces filled, just in case</p>",
        "id": 132661108,
        "sender_full_name": "eddyb",
        "timestamp": 1535058796
    },
    {
        "content": "<p>so I don't think privacy is the answer tbqh</p>",
        "id": 132661110,
        "sender_full_name": "eddyb",
        "timestamp": 1535058807
    },
    {
        "content": "<p>interesting. it always seemed a bit surprising to me</p>",
        "id": 132661113,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058818
    },
    {
        "content": "<p>tuple structs seem even more predisposed to shenanigans</p>",
        "id": 132661115,
        "sender_full_name": "eddyb",
        "timestamp": 1535058820
    },
    {
        "content": "<p>but I hadn't thought about it very hard</p>",
        "id": 132661116,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058821
    },
    {
        "content": "<p>it just seemed like a bit of a \"clever hack\"</p>",
        "id": 132661123,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058838
    },
    {
        "content": "<p>I would prefer it for non-braced pattern-matching to have the entry in the value namespace</p>",
        "id": 132661133,
        "sender_full_name": "eddyb",
        "timestamp": 1535058842
    },
    {
        "content": "<p>vs directly expressing the idea</p>",
        "id": 132661161,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058844
    },
    {
        "content": "<p>otherwise we might get some weird results in the future</p>",
        "id": 132661166,
        "sender_full_name": "eddyb",
        "timestamp": 1535058860
    },
    {
        "content": "<p>and tbqh I expect you to be matching the constructor, not the type</p>",
        "id": 132661171,
        "sender_full_name": "eddyb",
        "timestamp": 1535058872
    },
    {
        "content": "<p>unless you use braces and numbers in which case... welll</p>",
        "id": 132661176,
        "sender_full_name": "eddyb",
        "timestamp": 1535058892
    },
    {
        "content": "<p>(that said, it's weird that struct ctors have a distinct def-id, but not enum variants)</p>",
        "id": 132661177,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058896
    },
    {
        "content": "<p>what's up with that</p>",
        "id": 132661182,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058903
    },
    {
        "content": "<p>/me still wants <code>fn foo { a: T, b: U } -&gt; V { ... } foo { a, b }</code></p>",
        "id": 132661185,
        "sender_full_name": "eddyb",
        "timestamp": 1535058909
    },
    {
        "content": "<p>As I remember it, when matching against a struct (not unit), enum or variant (not unit), we require that <code>..</code> (or <code>_</code> in a match) be included as new fields can be added (where previously if you specified all fields then the compiler wouldn't require a wildcard - now you always require one). And then we lower the visibility of the constructors for those since you can't add new fields if those constructors are being used, since suddenly that fails to compile as not all fields are set.</p>",
        "id": 132661187,
        "sender_full_name": "davidtwco",
        "timestamp": 1535058912
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> struct ctors never worked without separate identity IIRC</p>",
        "id": 132661190,
        "sender_full_name": "eddyb",
        "timestamp": 1535058934
    },
    {
        "content": "<p>yes, I know, I just can't remember why</p>",
        "id": 132661195,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058942
    },
    {
        "content": "<p>it was a hack from the very beginning, and I think it's because they're types</p>",
        "id": 132661200,
        "sender_full_name": "eddyb",
        "timestamp": 1535058950
    },
    {
        "content": "<p>variants aren't types</p>",
        "id": 132661205,
        "sender_full_name": "eddyb",
        "timestamp": 1535058953
    },
    {
        "content": "<p>so you couldn't have <code>typeof Foo</code> be <code>fn(...) -&gt; Foo</code></p>",
        "id": 132661248,
        "sender_full_name": "eddyb",
        "timestamp": 1535058969
    },
    {
        "content": "<p>and <code>Foo</code> being a type</p>",
        "id": 132661249,
        "sender_full_name": "eddyb",
        "timestamp": 1535058973
    },
    {
        "content": "<p>yeah. that makes sense. feels sort of like the wrong hack.</p>",
        "id": 132661254,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058991
    },
    {
        "content": "<p>the same <code>DefId</code> could not lead to both a function type and the tuple struct type itself</p>",
        "id": 132661257,
        "sender_full_name": "eddyb",
        "timestamp": 1535058992
    },
    {
        "content": "<p>like, we should have two type-of queries</p>",
        "id": 132661258,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535058996
    },
    {
        "content": "<p>nowadays we have <code>fn_sig</code> which could maybe handle this, idk</p>",
        "id": 132661259,
        "sender_full_name": "eddyb",
        "timestamp": 1535059002
    },
    {
        "content": "<p>/me shrugs</p>",
        "id": 132661266,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535059007
    },
    {
        "content": "<p>it's always weird that for variants you have to like pull out the return type</p>",
        "id": 132661268,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535059016
    },
    {
        "content": "<p>and handle the leaf case</p>",
        "id": 132661269,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535059018
    },
    {
        "content": "<p><code>type_of</code> and <code>type_decl</code>?</p>",
        "id": 132661270,
        "sender_full_name": "eddyb",
        "timestamp": 1535059018
    },
    {
        "content": "<p>w/r/t the ids, both enums and structs have an id as part of <code>Item</code> that identifies them, and then each of those have a <code>VariantDef</code> with a single id - for structs, that is used as the ctor (since a id isn't needed to identify the variant, there's only ever one), and for variants it is used to both identify the variant and as the ctor. So for variants, a new id needs to be added here to separate the variant and it's ctor. At least, that's what I've figured out from digging around.</p>",
        "id": 132661280,
        "sender_full_name": "davidtwco",
        "timestamp": 1535059040
    },
    {
        "content": "<p>btw I want to rename a bunch of things and take back \"def\" and \"decl\" and do cool things with them. or maybe just \"def\" not \"decl\"</p>",
        "id": 132661290,
        "sender_full_name": "eddyb",
        "timestamp": 1535059070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> I'm unconvinced privacy is the right way to implement this</p>",
        "id": 132661332,
        "sender_full_name": "eddyb",
        "timestamp": 1535059083
    },
    {
        "content": "<p>it seems to create more hazards than problems it solves</p>",
        "id": 132661336,
        "sender_full_name": "eddyb",
        "timestamp": 1535059093
    },
    {
        "content": "<p>I'm open to any potential route to implement this, privacy is just the approach that I was advised to take initially and what I've been trying to continue with.</p>",
        "id": 132661356,
        "sender_full_name": "davidtwco",
        "timestamp": 1535059142
    },
    {
        "content": "<p>IMO the correct approach is that you can't assign a type to an expression that references  a constructor from another crate that has <code>#[non_exhaustive]</code> on it</p>",
        "id": 132661374,
        "sender_full_name": "eddyb",
        "timestamp": 1535059169
    },
    {
        "content": "<p>this should be like a dozen lines of code in <code>rustc_typeck</code>, and handle both tuple structs and tuple variants</p>",
        "id": 132661437,
        "sender_full_name": "eddyb",
        "timestamp": 1535059214
    },
    {
        "content": "<p>and not require rewriting half the compiler</p>",
        "id": 132661449,
        "sender_full_name": "eddyb",
        "timestamp": 1535059232
    },
    {
        "content": "<p>unless the condition is more subtle than that? is macro hygiene relevant here?</p>",
        "id": 132661463,
        "sender_full_name": "eddyb",
        "timestamp": 1535059262
    },
    {
        "content": "<p>I'm not sure.</p>",
        "id": 132661478,
        "sender_full_name": "davidtwco",
        "timestamp": 1535059281
    },
    {
        "content": "<p>(if so you can maybe traverse the hygiene information, if it's not destroyed in the HIR)</p>",
        "id": 132661481,
        "sender_full_name": "eddyb",
        "timestamp": 1535059285
    },
    {
        "content": "<p>worst case you do this check in HIR lowering, because that still has the AST</p>",
        "id": 132661487,
        "sender_full_name": "eddyb",
        "timestamp": 1535059297
    },
    {
        "content": "<p>or maybe even in <code>rustc_resolve</code> itself</p>",
        "id": 132661491,
        "sender_full_name": "eddyb",
        "timestamp": 1535059303
    },
    {
        "content": "<p>but not when importing the constructor, when resolving an expression to it</p>",
        "id": 132661497,
        "sender_full_name": "eddyb",
        "timestamp": 1535059313
    },
    {
        "content": "<p>w/r/t what I've been trying to do (whether that is still relevant or the approach we'll take, I don't know), I <a href=\"https://gist.github.com/davidtwco/2cc240f7a34d7065428fb67e34ea6b09\" target=\"_blank\" title=\"https://gist.github.com/davidtwco/2cc240f7a34d7065428fb67e34ea6b09\">have these notes</a> when I was digging around trying to work out what was happening. And the last attempt I made replaced the <code>NodeId</code> in <code>VariantDef</code> with a enum that had a single <code>NodeId</code> if it was a struct and two if it was an enum - I just assigned the correct one when building the <code>VariantDef</code> (starting in the ast with a <code>NodeId</code> then lowering in the HIR). I added some helper functions to access the <code>ctor_id</code> and <code>variant_id</code> and then removed the <code>id</code> function that was there. That meant that I was made aware via compile errors where the <code>id</code> was used previously so I could dig around in all those locations and try update relevant code. I got that compiling but I ended up with issues in <code>AdtDef::variant_with_id</code>.</p>",
        "id": 132661659,
        "sender_full_name": "davidtwco",
        "timestamp": 1535059495
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/lib.rs#L535\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/lib.rs#L535\">https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/lib.rs#L535</a></p>",
        "id": 132661677,
        "sender_full_name": "eddyb",
        "timestamp": 1535059528
    },
    {
        "content": "<p>basically this case <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/lib.rs#L555-L556\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/lib.rs#L555-L556\">https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/lib.rs#L555-L556</a></p>",
        "id": 132661684,
        "sender_full_name": "eddyb",
        "timestamp": 1535059547
    },
    {
        "content": "<p>I think all you have to do is pass something to it so it can... oh hmm</p>",
        "id": 132661750,
        "sender_full_name": "eddyb",
        "timestamp": 1535059605
    },
    {
        "content": "<p>you might have to do this in <code>rustc_typeck</code> to properly get access to cross-crate attributes</p>",
        "id": 132661760,
        "sender_full_name": "eddyb",
        "timestamp": 1535059622
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> you can try to add a check here: <a href=\"https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/check/mod.rs#L3821\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/check/mod.rs#L3821\">https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/check/mod.rs#L3821</a></p>",
        "id": 132661833,
        "sender_full_name": "eddyb",
        "timestamp": 1535059714
    },
    {
        "content": "<p>just above that line</p>",
        "id": 132661835,
        "sender_full_name": "eddyb",
        "timestamp": 1535059719
    },
    {
        "content": "<p>it should work on top of master, without touching any other part of the codebase</p>",
        "id": 132661841,
        "sender_full_name": "eddyb",
        "timestamp": 1535059733
    },
    {
        "content": "<p>IMO that seems vastly preferably to touching privacy</p>",
        "id": 132661849,
        "sender_full_name": "eddyb",
        "timestamp": 1535059745
    },
    {
        "content": "<p>ofc <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> might have some really good reasons and I'm sorry if I should've read something before saying all this</p>",
        "id": 132661872,
        "sender_full_name": "eddyb",
        "timestamp": 1535059776
    },
    {
        "content": "<p>(but without more information, a specific check at one location seems ideal)</p>",
        "id": 132661938,
        "sender_full_name": "eddyb",
        "timestamp": 1535059822
    },
    {
        "content": "<p>Of course I have really good reasons :)</p>",
        "id": 132662023,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535059931
    },
    {
        "content": "<p>oh hey!</p>",
        "id": 132662025,
        "sender_full_name": "eddyb",
        "timestamp": 1535059942
    },
    {
        "content": "<p>That's exactly the point to make the constructor effectively non-existent for other crates.</p>",
        "id": 132662031,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535059970
    },
    {
        "content": "<p>I'm curious if you prefer being able to shadow the constructors because of separate privacy and how you think patterns should work</p>",
        "id": 132662032,
        "sender_full_name": "eddyb",
        "timestamp": 1535059974
    },
    {
        "content": "<p>because IMO <code>Foo(..)</code> working in a pattern without <code>Foo</code> in the value namespace just seems scary</p>",
        "id": 132662043,
        "sender_full_name": "eddyb",
        "timestamp": 1535060005
    },
    {
        "content": "<p>... like this is done now for tuple structs with private fields.</p>",
        "id": 132662044,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060007
    },
    {
        "content": "<p>hmm</p>",
        "id": 132662049,
        "sender_full_name": "eddyb",
        "timestamp": 1535060015
    },
    {
        "content": "<p><del>but you can't pattern-match on those, right?</del> wait, no, you probably can?</p>",
        "id": 132662052,
        "sender_full_name": "eddyb",
        "timestamp": 1535060024
    },
    {
        "content": "<p>So nobody on the internet knows you are a ~dog~ tuple struct.</p>",
        "id": 132662096,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060045
    },
    {
        "content": "<p>No, you can't match and you can't use them as expressions.</p>",
        "id": 132662103,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060065
    },
    {
        "content": "<p>okay that seems... consistent</p>",
        "id": 132662108,
        "sender_full_name": "eddyb",
        "timestamp": 1535060072
    },
    {
        "content": "<p>what about <code>#[non_exhaustive]</code>, wouldn't that want to allow pattern-matching?</p>",
        "id": 132662114,
        "sender_full_name": "eddyb",
        "timestamp": 1535060085
    },
    {
        "content": "<p>Unit structs are the best example here.</p>",
        "id": 132662117,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060092
    },
    {
        "content": "<p>if we don't want patterns to work then privacy makes more sense to me</p>",
        "id": 132662118,
        "sender_full_name": "eddyb",
        "timestamp": 1535060096
    },
    {
        "content": "<p>but <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> was saying something about adding fields at the end of a tuple struct</p>",
        "id": 132662134,
        "sender_full_name": "eddyb",
        "timestamp": 1535060119
    },
    {
        "content": "<p>non_exhaustive unit structs are unit only for convenience of the current crate.</p>",
        "id": 132662135,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060119
    },
    {
        "content": "<p>okay that's really nice :D</p>",
        "id": 132662137,
        "sender_full_name": "eddyb",
        "timestamp": 1535060127
    },
    {
        "content": "<p>no more <code>pub  struct Foo(());</code></p>",
        "id": 132662143,
        "sender_full_name": "eddyb",
        "timestamp": 1535060139
    },
    {
        "content": "<p>Other crates cannot use <code>let u = U;</code> using the constructor, because that's kind of... exhaustive.</p>",
        "id": 132662150,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060161
    },
    {
        "content": "<p>so far so good (although it would still possible to check this in <code>rustc_typeck</code> or w/e, but I agree privacy works better than I initially expected</p>",
        "id": 132662209,
        "sender_full_name": "eddyb",
        "timestamp": 1535060194
    },
    {
        "content": "<p>so was <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> wrong when he said you could pattern-match non-exhaustive tuple-like things with <code>Foo(a, b, ..)</code>? Specifically, that <code>..</code> at the end being mendatory</p>",
        "id": 132662220,
        "sender_full_name": "eddyb",
        "timestamp": 1535060229
    },
    {
        "content": "<p>should you not be able to write <code>Foo(..)</code> at all?</p>",
        "id": 132662225,
        "sender_full_name": "eddyb",
        "timestamp": 1535060244
    },
    {
        "content": "<blockquote>\n<p>eddyb: it was a hack from the very beginning, and I think it's because they're types<br>\neddyb: variants aren't types</p>\n</blockquote>",
        "id": 132662229,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060264
    },
    {
        "content": "<p>maybe only <code>Foo {..}</code>, if that works with unit/tuple/brace the same</p>",
        "id": 132662231,
        "sender_full_name": "eddyb",
        "timestamp": 1535060268
    },
    {
        "content": "<p>Regarding this ^^, I assumed that variants-as-types will happen sooner or later, so variants will need separate def-ids anyway.</p>",
        "id": 132662279,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060304
    },
    {
        "content": "<p>I disagree, but that depends on what we do to structs</p>",
        "id": 132662283,
        "sender_full_name": "eddyb",
        "timestamp": 1535060320
    },
    {
        "content": "<p>I think <em>originally</em>, tuple struct separate constructor ID was a dirty hack, to avoid having a separate type vs value \"type of DefId\"</p>",
        "id": 132662299,
        "sender_full_name": "eddyb",
        "timestamp": 1535060345
    },
    {
        "content": "<p>I agree that if you already have separate DefId's, it makes some things simpler/lazier</p>",
        "id": 132662344,
        "sender_full_name": "eddyb",
        "timestamp": 1535060402
    },
    {
        "content": "<p>So what are the intended semantics of <code>#[non_exhaustive]</code> on tuple things? not allow pattern-matching at all?</p>",
        "id": 132662379,
        "sender_full_name": "eddyb",
        "timestamp": 1535060440
    },
    {
        "content": "<p>Yes, for tuple structs/variants <code>Foo(..)</code> doesn't works since nobody knows it's a tuple, but <code>Foo  { .. }</code> works.<br>\nThat's how it's specified in the RFC (full disclosure: under my influence).</p>",
        "id": 132662382,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060445
    },
    {
        "content": "<p>oh okay so <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> was just confused :P</p>",
        "id": 132662388,
        "sender_full_name": "eddyb",
        "timestamp": 1535060459
    },
    {
        "content": "<blockquote>\n<p>So what are the intended semantics of #[non_exhaustive] on tuple things?</p>\n</blockquote>",
        "id": 132662398,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060469
    },
    {
        "content": "<p>It pretty much doesn't work, yeah.</p>",
        "id": 132662403,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060483
    },
    {
        "content": "<p>okay then I agree we don't have much of a choice but treat bracey things as part of the type namespace</p>",
        "id": 132662409,
        "sender_full_name": "eddyb",
        "timestamp": 1535060502
    },
    {
        "content": "<p>which is pretty consistent already</p>",
        "id": 132662414,
        "sender_full_name": "eddyb",
        "timestamp": 1535060509
    },
    {
        "content": "<p>so a DefId split for privacy is fine, just a lot of work</p>",
        "id": 132662429,
        "sender_full_name": "eddyb",
        "timestamp": 1535060519
    },
    {
        "content": "<p>The only possible thing to work is <code>Foo(..)</code> because partial matches still prevent addition of arbitrary new fields.<br>\nBut for <code>Foo(..)</code> we have <code>Foo { .. }</code> too, so it's not critical.</p>",
        "id": 132662480,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535060552
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> Do you have any tips for how I'd go about making this separation in a managable way? I'm eager to see RFC 2008's implementation through and this is a good opportunity to get some familiarity with parts of the compiler that aren't the MIR.</p>",
        "id": 132662774,
        "sender_full_name": "davidtwco",
        "timestamp": 1535060895
    },
    {
        "content": "<blockquote>\n<p>oh okay so <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> was just confused :P</p>\n</blockquote>\n<p>sounds like it, seems fine</p>",
        "id": 132662883,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535061078
    },
    {
        "content": "<p>known to happen on occasion :)</p>",
        "id": 132662893,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535061101
    },
    {
        "content": "<p>I'm glad I was scared for no reason, at least</p>",
        "id": 132662936,
        "sender_full_name": "eddyb",
        "timestamp": 1535061136
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> Do you have any tips for how I'd go about making this separation in a managable way? I'm eager to see RFC 2008's implementation through and this is a good opportunity to get some familiarity with parts of the compiler that aren't the MIR.</p>\n</blockquote>\n<p>No, sorry, can't say more than \"separate them and try to make compiler to work again\".<br>\nI tried to do this about three years ago and couldn't.</p>",
        "id": 132663039,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535061295
    },
    {
        "content": "<p>if it's edition-relevant I could try to step in</p>",
        "id": 132663054,
        "sender_full_name": "eddyb",
        "timestamp": 1535061310
    },
    {
        "content": "<p>otherwise, probably not</p>",
        "id": 132663058,
        "sender_full_name": "eddyb",
        "timestamp": 1535061315
    },
    {
        "content": "<p>Now the stuff around def-ids is much cleaner though, so it may be simpler.</p>",
        "id": 132663060,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1535061320
    },
    {
        "content": "<p>That's... encouraging? I guess I'll just keep at it and see how much it breaks my soul.</p>",
        "id": 132663135,
        "sender_full_name": "davidtwco",
        "timestamp": 1535061452
    },
    {
        "content": "<p>heh</p>",
        "id": 132663140,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1535061474
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I've submitted <a href=\"https://github.com/rust-lang/rust/issues/59376\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/59376\">#59376</a> with an attempt at RFC 2008 for enum variants. It's probably my biggest PR yet, so I'm sure there are plenty of things I could have done better, happy as always to make any requested changes - there are definitely some parts that could be better. This time it separates the <code>DefId</code> of enum variants and their constructors so should have implemented the RFC properly.</p>",
        "id": 161501641,
        "sender_full_name": "davidtwco",
        "timestamp": 1553307490
    },
    {
        "content": "<p>Have there been any updates on this? Is the only thing left updating docs before it can be considered for stabilization?</p>",
        "id": 164493533,
        "sender_full_name": "Erich Gubler",
        "timestamp": 1556576119
    },
    {
        "content": "<p>I've been intending to finish it off with any documentation that's needed after it had some time to bake in nightly.</p>",
        "id": 164494087,
        "sender_full_name": "davidtwco",
        "timestamp": 1556576681
    },
    {
        "content": "<p>(if you wish to make a PR with documentation or anything like that, please feel free to, but if you don't, I'll eventually get around to it, probably soon-ish now you've reminded me)</p>",
        "id": 164494126,
        "sender_full_name": "davidtwco",
        "timestamp": 1556576727
    },
    {
        "content": "<p>Ah, yeah, that'd be a nice thing to finish up.</p>",
        "id": 164571881,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1556654739
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I'm not sure about <code>#[non_exhaustive]</code> as concrete syntax; the suggestion <code>..</code> from the RFC was imo not considered sufficiently and I know some other people in the team like <code>..</code> also. But it seems like a good discussion item for a meeting.</p>",
        "id": 164598532,
        "sender_full_name": "centril",
        "timestamp": 1556683882
    },
    {
        "content": "<p>As I noted to <span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span>, it would be nice to also extend the tests re. <code>#[non_exhaustive]</code> to ensure that e.g. <code>#[non_exhaustive] struct A(!);</code> isn't considered uninhabited outside of the crate.</p>",
        "id": 164598594,
        "sender_full_name": "centril",
        "timestamp": 1556683932
    },
    {
        "content": "<p>(since I have plans for <code>#[non_exhaustive]</code> + inhabitedness)</p>",
        "id": 164598597,
        "sender_full_name": "centril",
        "timestamp": 1556683951
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> I'd be fine with discussing the syntax some more</p>",
        "id": 164622191,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1556716510
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> <a href=\"https://github.com/rust-lang/rust/issues/60529\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/60529\">#60529</a></p>",
        "id": 164841152,
        "sender_full_name": "davidtwco",
        "timestamp": 1556929641
    },
    {
        "content": "<p>/me looks</p>",
        "id": 164841202,
        "sender_full_name": "centril",
        "timestamp": 1556929696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> to clarify, you want functions like these added:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">cannot_empty_match_on_empty_struct_to_anything</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">UninhabitedStruct</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR non-exhaustive patterns</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">cannot_empty_match_on_empty_tuple_struct_to_anything</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">UninhabitedTupleStruct</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR non-exhaustive patterns</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">cannot_empty_match_on_enum_with_empty_variants_struct_to_anything</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">UninhabitedVariants</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">//~ ERROR non-exhaustive patterns</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>with these errors:</p>\n<div class=\"codehilite\"><pre><span></span>error[E0004]: non-exhaustive patterns: pattern `UninhabitedStruct` of type `uninhabited::UninhabitedStruct` is not handled\n  --&gt; /home/david/projects/rust/rust2/src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.rs:23:11\n   |\nLL |     match x {} //~ ERROR non-exhaustive patterns\n   |           ^\n   |\n   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n\nerror[E0004]: non-exhaustive patterns: pattern `UninhabitedTupleStruct` of type `uninhabited::UninhabitedTupleStruct` is not handled\n  --&gt; /home/david/projects/rust/rust2/src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.rs:27:11\n   |\nLL |     match x {} //~ ERROR non-exhaustive patterns\n   |           ^\n   |\n   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n\nerror[E0004]: non-exhaustive patterns: multiple patterns of type `uninhabited::UninhabitedVariants` are not handled\n  --&gt; /home/david/projects/rust/rust2/src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.rs:31:11\n   |\nLL |     match x {} //~ ERROR non-exhaustive patterns\n   |           ^\n   |\n   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n</pre></div>",
        "id": 164862931,
        "sender_full_name": "davidtwco",
        "timestamp": 1556967132
    },
    {
        "content": "<p>That will also fail in the <code>_same_crate</code> variant of the test?</p>",
        "id": 164862940,
        "sender_full_name": "davidtwco",
        "timestamp": 1556967152
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> that looks right, with the caveat that if you enable <code>#![feature(exhaustive_patterns)]</code> then <code>_same_crate</code> should work for the structs.</p>",
        "id": 164862967,
        "sender_full_name": "centril",
        "timestamp": 1556967211
    },
    {
        "content": "<p>Alright.</p>",
        "id": 164862972,
        "sender_full_name": "davidtwco",
        "timestamp": 1556967224
    },
    {
        "content": "<p>since that enables the structural behavior for product types</p>",
        "id": 164862973,
        "sender_full_name": "centril",
        "timestamp": 1556967226
    },
    {
        "content": "<p>(but with <code>#![feature(exhaustive_patterns)]</code> and <em>cross crate</em> then <code>UninhabitedMyProduct</code> should still fail)</p>",
        "id": 164863053,
        "sender_full_name": "centril",
        "timestamp": 1556967358
    },
    {
        "content": "<p>That matches what I'm seeing.</p>",
        "id": 164863110,
        "sender_full_name": "davidtwco",
        "timestamp": 1556967415
    },
    {
        "content": "<p>Great <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 164863122,
        "sender_full_name": "centril",
        "timestamp": 1556967436
    },
    {
        "content": "<p>And you also wanted tests with a level of indirection? like in this example from your comment:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#![feature(exhaustive_patterns)]</span><span class=\"w\"></span>\n\n<span class=\"k\">enum</span> <span class=\"nc\">V</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">A</span><span class=\"p\">(</span><span class=\"n\">V</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">A</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">String</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 164863129,
        "sender_full_name": "davidtwco",
        "timestamp": 1556967478
    },
    {
        "content": "<p>Added a bunch of tests to the PR.</p>",
        "id": 164863473,
        "sender_full_name": "davidtwco",
        "timestamp": 1556968080
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> Let's call it an unintentional want ;)</p>",
        "id": 164863638,
        "sender_full_name": "centril",
        "timestamp": 1556968351
    },
    {
        "content": "<p>Would be great to have it but it was mainly for explanatory purposes ^^</p>",
        "id": 164863650,
        "sender_full_name": "centril",
        "timestamp": 1556968394
    },
    {
        "content": "<p>I added them.</p>",
        "id": 164863654,
        "sender_full_name": "davidtwco",
        "timestamp": 1556968409
    },
    {
        "content": "<p>Awesome</p>",
        "id": 164863657,
        "sender_full_name": "centril",
        "timestamp": 1556968431
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> <code>indirect_match_same_crate.rs</code> looks strange; shouldn't it be without <code> #![feature(non_exhaustive)]</code> -- also you say \"will compile\" but it doesn't seem so?</p>",
        "id": 164864222,
        "sender_full_name": "centril",
        "timestamp": 1556969513
    },
    {
        "content": "<p>if it is without <code>#![feature(non_exhaustive)]</code> then not compiling on some stuff seems expected</p>",
        "id": 164864271,
        "sender_full_name": "centril",
        "timestamp": 1556969554
    },
    {
        "content": "<p>(being more conservative than my expectation is fine if that is what happens)</p>",
        "id": 164864331,
        "sender_full_name": "centril",
        "timestamp": 1556969679
    },
    {
        "content": "<p>aah sorry, mixed up feature gates!</p>",
        "id": 164864388,
        "sender_full_name": "centril",
        "timestamp": 1556969786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> I think I just mixed up the comment in that test, fixed now.</p>",
        "id": 164865115,
        "sender_full_name": "davidtwco",
        "timestamp": 1556971227
    },
    {
        "content": "<p>yep</p>",
        "id": 164865195,
        "sender_full_name": "centril",
        "timestamp": 1556971360
    }
]