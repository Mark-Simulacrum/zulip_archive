[
    {
        "content": "<p>The backtrace crate makes up the vast majority of the file size of simple programs in release mode. When using LTO, panic=abort, and -Z build-std, an empty executable weighs 231kb after stripping. If you apply the following patch to libstd before building, the resulting executable weighs 52kb:</p>\n<div class=\"codehilite\"><pre><span></span><code>diff --git a/library/std/src/panicking.rs b/library/std/src/panicking.rs\nindex 7de70091bec..5cf4be6d721 100644\n--- a/library/std/src/panicking.rs\n+++ b/library/std/src/panicking.rs\n@@ -182,11 +182,7 @@ pub fn take_hook() -&gt; Box&lt;dyn Fn(&amp;PanicInfo&lt;&#39;_&gt;) + &#39;static + Sync + Send&gt; {\n fn default_hook(info: &amp;PanicInfo&lt;&#39;_&gt;) {\n     // If this is a double panic, make sure that we print a backtrace\n     // for this panic. Otherwise only print it if logging is enabled.\n-    let backtrace_env = if panic_count::get_count() &gt;= 2 {\n-        RustBacktrace::Print(crate::backtrace_rs::PrintFmt::Full)\n-    } else {\n-        backtrace::rust_backtrace_env()\n-    };\n+    let backtrace_env = RustBacktrace::Disabled;\n\n     // The current implementation always returns `Some`.\n     let location = info.location().unwrap();\n</code></pre></div>\n<p>Would it be possible to make backtraces optional at compile time? I could imagine a property similar to panic=abort. E.g. backtraces=false in cargo. I assume many people would be interested in removing backtracing functionality from their binaries if it allows them to reduce the file size significantly.</p>",
        "id": 250068783,
        "sender_full_name": "James Monroe",
        "timestamp": 1629423886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"353460\">@James Monroe</span> I know the standard library already supports <code>panic_immediate_abort</code> if you build it from source, I can imagine this being behind a cargo feature too</p>",
        "id": 250069310,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424553
    },
    {
        "content": "<p>Especially since the patch is so simple, you could basically do your patch there behind a cfg</p>",
        "id": 250069353,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424569
    },
    {
        "content": "<p>This is a question for T-libs, not T-compiler, though</p>",
        "id": 250069361,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424586
    },
    {
        "content": "<p>Using a cfg requires build-std. I was thinking about switching the backtrace crate without having to recompile everything. E.g. having two crates backtrace_std and backtrace_dummy, one of which is chosen at compile time. Similar to panic_unwind and panic_abort. Is this still T-libs?</p>",
        "id": 250069397,
        "sender_full_name": "James Monroe",
        "timestamp": 1629424674
    },
    {
        "content": "<p>The standard library is compiled ahead of time. You can't change what it does unless you compile it from source.</p>",
        "id": 250069459,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424722
    },
    {
        "content": "<p>You're saying \"compile time\" to mean \"when a user's crate is compiled\", but the only way for this to be possible is for it to mean \"when the standard library is compiled\"</p>",
        "id": 250069479,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424761
    },
    {
        "content": "<p>I do not see why this would be so. Why does switching the panic crate work but not switching the backtrace crate?</p>",
        "id": 250069567,
        "sender_full_name": "James Monroe",
        "timestamp": 1629424813
    },
    {
        "content": "<p>Unless you're suggested that rustup distribute many different versions of the standard library, which is a much larger can of worms</p>",
        "id": 250069573,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424815
    },
    {
        "content": "<p>What do you mean by \"the panic crate\"? I'm pretty sure the standard library decides at runtime whether to unwind or abort</p>",
        "id": 250069659,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424866
    },
    {
        "content": "<p>No, the stdlib calls an <code>extern \"Rust\"</code> function which is a lang item that exists once in panic_unwind and once in panic_abort.</p>",
        "id": 250069701,
        "sender_full_name": "James Monroe",
        "timestamp": 1629424917
    },
    {
        "content": "<p>Oh huh, TIL</p>",
        "id": 250069746,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424952
    },
    {
        "content": "<p>I guess that could work for backtraces too</p>",
        "id": 250069753,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629424962
    },
    {
        "content": "<p>How does that work with panic=abort? I'm confused how this can be controlled when compiling a user crate</p>",
        "id": 250069859,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629425098
    },
    {
        "content": "<p>What I wrote above is not quite right. It's actually</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[rustc_std_internal_symbol]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C-unwind\"</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">__rust_start_panic</span><span class=\"p\">(</span><span class=\"n\">_payload</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">BoxMeUp</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But basically what I said above. This function is once in panic_unwind and once in panic_abort.</p>",
        "id": 250069881,
        "sender_full_name": "James Monroe",
        "timestamp": 1629425125
    },
    {
        "content": "<p>Right sure, but don't both versions have to be compiled in for you to be able to choose between them?</p>",
        "id": 250069948,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629425183
    },
    {
        "content": "<p>Both versions are distributed as an rlib with the standard library I believe. I assume that rustc automatically adds one of them as a dependency when compiling.</p>",
        "id": 250069977,
        "sender_full_name": "James Monroe",
        "timestamp": 1629425229
    },
    {
        "content": "<p>There is probably some magic going on.</p>",
        "id": 250069988,
        "sender_full_name": "James Monroe",
        "timestamp": 1629425247
    },
    {
        "content": "<p>rlib doesn't include the dependencies, so we'll just need to decide which one to link</p>",
        "id": 250072321,
        "sender_full_name": "Gary Guo",
        "timestamp": 1629428249
    },
    {
        "content": "<p>yeah it's easy to tell the linker that one or the other is included in the linking</p>",
        "id": 250121220,
        "sender_full_name": "Lokathor",
        "timestamp": 1629468085
    },
    {
        "content": "<p>What would be the steps to make this happen?</p>",
        "id": 250333476,
        "sender_full_name": "James Monroe",
        "timestamp": 1629714599
    }
]