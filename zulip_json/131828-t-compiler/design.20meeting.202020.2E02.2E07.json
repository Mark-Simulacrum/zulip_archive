[
    {
        "content": "<p>Hey <span class=\"user-group-mention\" data-user-group-id=\"897\">@T-compiler/meeting</span> -- reminder that we have a <strong>design meeting</strong> today in 1.5 hours. We'll be discussing <a href=\"https://github.com/rust-lang/compiler-team/issues/237\" target=\"_blank\" title=\"https://github.com/rust-lang/compiler-team/issues/237\">compiler-team#237</a> (\"parser librar-yification\"). From the issue:</p>\n<blockquote>\n<p>The goal of the meeting is twofold:</p>\n<ul>\n<li>\n<p>share general experience with IDE-flavored parsing/trees in rust-analzyer (<a href=\"https://hackmd.io/XoQrzR8GRLa64jpjylQ7Bw\" target=\"_blank\" title=\"https://hackmd.io/XoQrzR8GRLa64jpjylQ7Bw\">writeup</a>)<br>\n *get feedback on a semi concrete plan for the first steps of parser library-ification (<a href=\"https://hackmd.io/ifjST_Y4R-SQ0AWiEcU6FQ\" target=\"_blank\" title=\"https://hackmd.io/ifjST_Y4R-SQ0AWiEcU6FQ\">writeup</a>)</p>\n</li>\n<li>\n<p>form consensus on what the next steps should be (and if we need this work in the first place)</p>\n</li>\n</ul>\n</blockquote>\n<p>In particular, the hope is that we can discuss some of the complications that would arise and how they might be handled.</p>",
        "id": 187638839,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581082265
    },
    {
        "content": "<p>Hello <span class=\"user-group-mention\" data-user-group-id=\"897\">@T-compiler/meeting</span> , shall we start? Please say <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> if you are here :-)</p>",
        "id": 187646129,
        "sender_full_name": "matklad",
        "timestamp": 1581087686
    },
    {
        "content": "<p>also, cc <span class=\"user-group-mention\" data-user-group-id=\"1060\">@WG-rls2.0</span></p>",
        "id": 187646256,
        "sender_full_name": "matklad",
        "timestamp": 1581087762
    },
    {
        "content": "<p>Let's maybe start with discussing what we have in rust-analyzer?</p>\n<p>Did people have a chance to read the write up? </p>\n<p>Are there any specific questions about that?</p>",
        "id": 187646392,
        "sender_full_name": "matklad",
        "timestamp": 1581087847
    },
    {
        "content": "<p>(Hey, sorry, was running a few minute late, thanks for picking up the ball <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> =)</p>",
        "id": 187646574,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581087965
    },
    {
        "content": "<p>I read the write-up; I have one or two questions</p>",
        "id": 187646608,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581087994
    },
    {
        "content": "<p>Some thoughts while reading the write-ups (adding more over time...):</p>\n<ul>\n<li>The general notes about optimizations of the tree weren't all that important for structuring the parser. I think we should mostly focus on the interface the parser uses.</li>\n<li>Unless there are strong reason to go with <code>token![]</code> I would like to retain the current <code>token::Colon</code>, etc.</li>\n</ul>",
        "id": 187646623,
        "sender_full_name": "centril",
        "timestamp": 1581088007
    },
    {
        "content": "<p>First off, which parts of rust-analyzer work directly from the underlying, untagged \"green\" syntax trees?</p>",
        "id": 187646624,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088007
    },
    {
        "content": "<blockquote>\n<p>To deal with precedence in cases like $expr * 1, we use special invisible parenthesis, which are explicitelly handled by the parser</p>\n</blockquote>\n<p>I believe that's the case today.</p>",
        "id": 187646672,
        "sender_full_name": "centril",
        "timestamp": 1581088049
    },
    {
        "content": "<blockquote>\n<p>Parsing is resilient (even if the input is invalid, parser tries to see as much syntax tree fragments in the input as it can).</p>\n</blockquote>\n<p>It seems like the write-up is claiming that the current parser doesn't do this, but I don't think that's the case. The parser does a whole lot of recovery.</p>",
        "id": 187646785,
        "sender_full_name": "centril",
        "timestamp": 1581088113
    },
    {
        "content": "<blockquote>\n<p>which parts of rust-analyzer work directly from the underlying, untagged \"green\" syntax trees?</p>\n</blockquote>\n<p>So, green and untagged are not the same</p>",
        "id": 187646803,
        "sender_full_name": "matklad",
        "timestamp": 1581088128
    },
    {
        "content": "<p>green trees are untagged</p>",
        "id": 187646811,
        "sender_full_name": "matklad",
        "timestamp": 1581088136
    },
    {
        "content": "<p>however, there's also <code>SyntaxNode</code> layer above green trees, whcih is also untagged (but, unlike G, has parent pointers)</p>",
        "id": 187646851,
        "sender_full_name": "matklad",
        "timestamp": 1581088165
    },
    {
        "content": "<p>It's more or less true that nothing in rust-analyzer works directly with green trees (the only thing that touches green trees is the code that builds syntax tree in the first place)</p>",
        "id": 187646931,
        "sender_full_name": "matklad",
        "timestamp": 1581088211
    },
    {
        "content": "<p><em>Some</em> code in rust-analyzer works with untagged representation with parent pointers. That is mostly the code close to the IDE</p>",
        "id": 187646962,
        "sender_full_name": "matklad",
        "timestamp": 1581088242
    },
    {
        "content": "<p>For example, \"flip two things around the <code>,</code>\" assist is implemented in terms of untagged SyntaxNodes</p>",
        "id": 187647007,
        "sender_full_name": "matklad",
        "timestamp": 1581088268
    },
    {
        "content": "<p>Yes, OK, that makes sense.</p>",
        "id": 187647021,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088275
    },
    {
        "content": "<p>As well as a pretty important layer which takes a raw offset into a file and figures out what semantic element exists at that position</p>",
        "id": 187647059,
        "sender_full_name": "matklad",
        "timestamp": 1581088303
    },
    {
        "content": "<p>That code climbs untagged tree up from the cursor position to find an item, and than finds a semantic repr for that item</p>",
        "id": 187647150,
        "sender_full_name": "matklad",
        "timestamp": 1581088328
    },
    {
        "content": "<p>Other notes:</p>\n<blockquote>\n<p>If possible, errors are not reported during parsing and are postponed for a separate validation step. For example, parser accepts visibility modifiers on trait methods, but then a separate tree traversal flags all such visibilites as erroneous.</p>\n</blockquote>\n<ul>\n<li>\n<p>It's important that no new syntax be accepted <em>pre-expansion</em> unless with the express approval of the language team. Could you elaborate on \"separate validation step\"... does it run before or after expansion?</p>\n</li>\n<li>\n<p>Similarly, the current parser needs to collect a set of spans for pre-expansion gating. How would we deal with that in the new model?</p>\n</li>\n</ul>",
        "id": 187647178,
        "sender_full_name": "centril",
        "timestamp": 1581088347
    },
    {
        "content": "<blockquote>\n<p>does it run before or after expansion?</p>\n</blockquote>\n<p>Before expansion. From the point of view of highler-level layers, it is indivisible from the <code>parse</code> phase. That is, it is an impl detail of parsing</p>",
        "id": 187647411,
        "sender_full_name": "matklad",
        "timestamp": 1581088463
    },
    {
        "content": "<p>Regarding:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TokenSource</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">current</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Token</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">lookahead_nth</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Token</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">is_keyword</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">kw</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bump</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<ul>\n<li>I assume we can (and <em>will</em>) encode higher level operations on this such as e.g. <code>eat_keyword(..)</code> and whatnot.</li>\n<li>Can we replace <code>kw: &amp;str</code> with <code>kw: Symbol</code>?</li>\n</ul>",
        "id": 187647430,
        "sender_full_name": "centril",
        "timestamp": 1581088472
    },
    {
        "content": "<blockquote>\n<p>How would we deal with that in the new model?</p>\n</blockquote>\n<p>I think this also belongs to the validation phase</p>",
        "id": 187647462,
        "sender_full_name": "matklad",
        "timestamp": 1581088492
    },
    {
        "content": "<p>I'm feeling a bit lost, I have to admit, but I do think it's good to turn towards the parser integration</p>",
        "id": 187647567,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088544
    },
    {
        "content": "<p>/me pulls up the document</p>",
        "id": 187647679,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088594
    },
    {
        "content": "<p>I guess I'd love it if someone (<span class=\"user-mention\" data-user-id=\"126931\">@centril</span>?) wanted to try and compare/contrast the \"current\" and \"new\" model</p>",
        "id": 187647749,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088646
    },
    {
        "content": "<blockquote>\n<p>I assume we can (and will) encode higher level operations on this such as e.g. eat_keyword(..) and whatnot.</p>\n</blockquote>\n<p>Correct, but not as a part of this interface. Rather, that would be utility methods on the parser.</p>\n<blockquote>\n<p>can we replace kw: &amp;str with kw: Symbol?</p>\n</blockquote>\n<p>I'd rather not to: if we do, we'd have to make the set of keywords a part of the interface. But maybe I am not exactly understanding what is Symbol</p>",
        "id": 187647759,
        "sender_full_name": "matklad",
        "timestamp": 1581088653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> it's an interned string representation with some things declared upfront, <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/symbol/struct.Symbol.html</a></p>",
        "id": 187647868,
        "sender_full_name": "centril",
        "timestamp": 1581088700
    },
    {
        "content": "<p>(I also think details about the specifics of the API seem a bit \"lower level\", unless they map to some higher-level distinctions -- e.g., I could see that <code>&amp;str</code> vs <code>Symbol</code> represents something important)</p>",
        "id": 187647872,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088702
    },
    {
        "content": "<blockquote>\n<p>Correct, but not as a part of this interface. Rather, that would be utility methods on the parser.</p>\n</blockquote>\n<p>That's all good.</p>",
        "id": 187647923,
        "sender_full_name": "centril",
        "timestamp": 1581088722
    },
    {
        "content": "<p>Agree that we should probably aim at teasing apart the high-level constraints here.</p>\n<p>In particular, one constraint I have in mind is that the parser should not care about interning</p>",
        "id": 187648004,
        "sender_full_name": "matklad",
        "timestamp": 1581088781
    },
    {
        "content": "<p>Maybe let's start with how existing parser and expansion intertwine? e.g., <span class=\"user-mention\" data-user-id=\"126931\">@centril</span> noted that the precise set of things parser accepts \"pre-expansion\" is part of the language definition, maybe we can sketch that out a bit more</p>",
        "id": 187648007,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088783
    },
    {
        "content": "<p>I would be happy with e.g. <code>const Const: &amp;str = \"const\"</code> instead</p>",
        "id": 187648010,
        "sender_full_name": "centril",
        "timestamp": 1581088786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> so <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> is the resident expansion expert</p>",
        "id": 187648098,
        "sender_full_name": "centril",
        "timestamp": 1581088818
    },
    {
        "content": "<p>I think if we had a kind of \"idealized\" model of how parser-expansion etc are interacting, it might be clearer how to express matklad's proposal as a diff on that</p>",
        "id": 187648102,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088819
    },
    {
        "content": "<p>(sorry, didn't have time to do a write-up to compare, had the fever yesterday &amp; today)</p>",
        "id": 187648138,
        "sender_full_name": "centril",
        "timestamp": 1581088841
    },
    {
        "content": "<p>No doubt, but they're not present, still I don't think we need the details of name resolution at the moment</p>",
        "id": 187648144,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088843
    },
    {
        "content": "<p>I could try to skech a view and you can correct it :)</p>",
        "id": 187648196,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088873
    },
    {
        "content": "<p>So to give a quick overview of pre-expansion gating...</p>",
        "id": 187648223,
        "sender_full_name": "centril",
        "timestamp": 1581088887
    },
    {
        "content": "<p>from what I undestand, the biggest diff would be that the current model very much builds on top of specific AST</p>",
        "id": 187648235,
        "sender_full_name": "matklad",
        "timestamp": 1581088895
    },
    {
        "content": "<p>(I am taking notes in <a href=\"https://hackmd.io/MR4bSmcpSlOPhz6aSebpXQ\" target=\"_blank\" title=\"https://hackmd.io/MR4bSmcpSlOPhz6aSebpXQ\">this hackmd</a>, fyi)</p>",
        "id": 187648251,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088904
    },
    {
        "content": "<p>The parser collects a set of spans into a sink: <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html</a></p>",
        "id": 187648270,
        "sender_full_name": "centril",
        "timestamp": 1581088921
    },
    {
        "content": "<p>mainly using <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html#method.gate\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html#method.gate\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_session/parse/struct.GatedSpans.html#method.gate</a></p>",
        "id": 187648323,
        "sender_full_name": "centril",
        "timestamp": 1581088930
    },
    {
        "content": "<p>Let's back up one more step :)</p>",
        "id": 187648384,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088973
    },
    {
        "content": "<p>The ida here is that we introduce feature-gated syntax</p>",
        "id": 187648397,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088981
    },
    {
        "content": "<p>when dealing with macros, which call into the black-box parsers, the sink is snapshotted, emptied, and then on a successful macro arm the gated spans are merged</p>",
        "id": 187648407,
        "sender_full_name": "centril",
        "timestamp": 1581088986
    },
    {
        "content": "<p>e.g., <code>async fn</code> (at one point)</p>",
        "id": 187648413,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581088989
    },
    {
        "content": "<p>and the parser accepts it, but records the span where it occurred</p>",
        "id": 187648429,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089002
    },
    {
        "content": "<p>or take <code>|</code> or-patterns today</p>",
        "id": 187648435,
        "sender_full_name": "centril",
        "timestamp": 1581089005
    },
    {
        "content": "<p>then -- after parsing -- we check the set of feature gates to make sure that the syntax was enabled</p>",
        "id": 187648449,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089014
    },
    {
        "content": "<p>we do this in part because macro-rules has things like <code>$e:expr</code> -- and the idea is that <code>$e</code> if matches this syntax without the feature gate, but we then remove that syntactic form, then we have changed the behavior of stable programs</p>",
        "id": 187648523,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089050
    },
    {
        "content": "<p>(correct?)</p>",
        "id": 187648526,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089053
    },
    {
        "content": "<p>yep</p>",
        "id": 187648543,
        "sender_full_name": "centril",
        "timestamp": 1581089063
    },
    {
        "content": "<p>(here's the or-pattern example, <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_parse/parser/pat.rs.html#120\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_parse/parser/pat.rs.html#120\">https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_parse/parser/pat.rs.html#120</a> )</p>",
        "id": 187648558,
        "sender_full_name": "centril",
        "timestamp": 1581089074
    },
    {
        "content": "<p>note that fragments feature gated may not be manifest in the AST itself</p>",
        "id": 187648616,
        "sender_full_name": "centril",
        "timestamp": 1581089119
    },
    {
        "content": "<p>One implication -- and this is somewhat contentious -- of the current setup is that you can only use <code>cfg</code> to include \"unstable\" syntax by embedding that syntax into a separate file</p>",
        "id": 187648620,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089120
    },
    {
        "content": "<p>Is collection of spans more powerful than  building a concrete syntax tree, and then sanitizing the tree?</p>",
        "id": 187648622,
        "sender_full_name": "matklad",
        "timestamp": 1581089123
    },
    {
        "content": "<p>e.g., <code>#[cfg(false)] mod foo;</code> works no matter that <code>foo.rs</code> contains, because it never parses <code>foo.rs</code> -- but maybe it's worth talking about the flow of how that comes about?</p>",
        "id": 187648647,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089144
    },
    {
        "content": "<p>it implies that the parsing of files is entwined with cfg expansion</p>",
        "id": 187648664,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089158
    },
    {
        "content": "<p>For example <code>let | p = 0;</code> gates <code>|</code> despite not being in the AST</p>",
        "id": 187648679,
        "sender_full_name": "centril",
        "timestamp": 1581089162
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> that's <a href=\"https://github.com/rust-lang/rust/issues/64197\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64197\">https://github.com/rust-lang/rust/issues/64197</a>, a bug that should be fixed in either case</p>",
        "id": 187648734,
        "sender_full_name": "centril",
        "timestamp": 1581089192
    },
    {
        "content": "<blockquote>\n<p>Is collection of spans more powerful than  building a concrete syntax tree, and then sanitizing the tree?</p>\n</blockquote>\n<p>this is a good question, <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>, I don't think so</p>",
        "id": 187648767,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089221
    },
    {
        "content": "<p>it is if the CST does not have the thing gated manifest in the CST</p>",
        "id": 187648808,
        "sender_full_name": "centril",
        "timestamp": 1581089245
    },
    {
        "content": "<p>So, <span class=\"user-mention\" data-user-id=\"126931\">@centril</span>, the point of <a href=\"https://github.com/rust-lang/rust/issues/64197\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64197\">#64197</a> is that presently \"cfg expansion\" is duplicated between parser and expansion?</p>",
        "id": 187648823,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089260
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> what happens is that the parser drives conditional compilation when it comes to modules</p>",
        "id": 187648923,
        "sender_full_name": "centril",
        "timestamp": 1581089294
    },
    {
        "content": "<blockquote>\n<p>it is if the CST does not have the thing gated manifest in the CST</p>\n</blockquote>\n<p>where CST is \"concrete syntax tree\" ? But shouldn't that by definition ...</p>",
        "id": 187648931,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581089302
    },
    {
        "content": "<p>and <code>config.rs</code> lives in the parser</p>",
        "id": 187648937,
        "sender_full_name": "centril",
        "timestamp": 1581089305
    },
    {
        "content": "<p>i.e., the parser has a loop that is kind of like</p>\n<ul>\n<li>parse module file <code>foo.rs</code></li>\n<li>identify <code>mod bar;</code> declarations in there and determine if they are cfg'd out</li>\n<li>if not, then parse them</li>\n</ul>",
        "id": 187648939,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089307
    },
    {
        "content": "<p>(did you write CST in one instance where you meant to write AST?)</p>",
        "id": 187648948,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581089315
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> no; CST is somewhat ambiguous</p>",
        "id": 187648993,
        "sender_full_name": "centril",
        "timestamp": 1581089348
    },
    {
        "content": "<p>(\"the real AST is HIR\")</p>",
        "id": 187649002,
        "sender_full_name": "centril",
        "timestamp": 1581089353
    },
    {
        "content": "<p>or are you referring indeed to cases like <code>mod bar;</code> where the concrete syntax itself does not have the contents of <a href=\"http://bar.rs\" target=\"_blank\" title=\"http://bar.rs\">bar.rs</a> ?</p>",
        "id": 187649020,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581089369
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I'm referring to whether the leading  <code>|</code> in <code>let | p = 0;</code> is in the tree or not</p>",
        "id": 187649047,
        "sender_full_name": "centril",
        "timestamp": 1581089396
    },
    {
        "content": "<p>it's not in the current \"AST\"</p>",
        "id": 187649054,
        "sender_full_name": "centril",
        "timestamp": 1581089401
    },
    {
        "content": "<p>before we go too deep, can we confirm that <a href=\"#narrow/stream/131828-t-compiler/topic/design.20meeting.202020.2E02.2E07/near/187648939\" title=\"#narrow/stream/131828-t-compiler/topic/design.20meeting.202020.2E02.2E07/near/187648939\">my summary here</a> is correct?</p>",
        "id": 187649106,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089409
    },
    {
        "content": "<p>(after that, I think it'd clearly be good to define our terms like CST/AST/HIR and make sure we're all using them to refer to the same things)</p>",
        "id": 187649129,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089427
    },
    {
        "content": "<p>Okay.  I am under impression that in matklad's proposal, it might be included (if only as part of \"trivia\" ?)</p>",
        "id": 187649132,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581089429
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> high level idea is correct, but I think you're getting into the weeds</p>",
        "id": 187649165,
        "sender_full_name": "centril",
        "timestamp": 1581089455
    },
    {
        "content": "<p>I'm sure both old and new parser can deal with it</p>",
        "id": 187649188,
        "sender_full_name": "centril",
        "timestamp": 1581089469
    },
    {
        "content": "<p>Correct, I specifically use CST as a tree that, when printed, is guaranteed to yield exactly the source text. So which contains all tokens, and all trivia</p>",
        "id": 187649211,
        "sender_full_name": "matklad",
        "timestamp": 1581089480
    },
    {
        "content": "<p>More specifically, the parser would do less, and leave things to conditional compilation later</p>",
        "id": 187649221,
        "sender_full_name": "centril",
        "timestamp": 1581089493
    },
    {
        "content": "<p>The model we hope to move towards is one where that loop moves to the expander</p>",
        "id": 187649333,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089561
    },
    {
        "content": "<p>and the parser itself is basically just a function that parses a single file</p>",
        "id": 187649350,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089574
    },
    {
        "content": "<p>(Confirm/deny?)</p>",
        "id": 187649353,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089577
    },
    {
        "content": "<p>confirm</p>",
        "id": 187649356,
        "sender_full_name": "centril",
        "timestamp": 1581089580
    },
    {
        "content": "<p>Confirm</p>",
        "id": 187649360,
        "sender_full_name": "matklad",
        "timestamp": 1581089583
    },
    {
        "content": "<p>OK <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 187649372,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089595
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I don't think there's any disagreement here btw; it seems everyone agrees that this is a bug that should be fixed</p>",
        "id": 187649383,
        "sender_full_name": "centril",
        "timestamp": 1581089611
    },
    {
        "content": "<p>only engineering hours has prevented fixing it</p>",
        "id": 187649391,
        "sender_full_name": "centril",
        "timestamp": 1581089619
    },
    {
        "content": "<p>The reason I'm kind of going through this is</p>",
        "id": 187649411,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089639
    },
    {
        "content": "<p>I want to kind of create a \"high level picture\" of how this process works, and clearly identify which bits are the responsibility of which</p>",
        "id": 187649466,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089653
    },
    {
        "content": "<p>Anyway, that's as deep as I want to go on that topic, but I wanted to try and add now the pre-expansion gating in this picture a bit ...</p>",
        "id": 187649501,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089678
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> but assuming we store details like leading <code>|</code> then I agree in principle there's no problem with preexp gating</p>",
        "id": 187649533,
        "sender_full_name": "centril",
        "timestamp": 1581089712
    },
    {
        "content": "<p>I have some more questions about pre-expansion gating</p>",
        "id": 187649715,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089834
    },
    {
        "content": "<p>It seems relevant, but I'm also happy to take some notes and pursue them later</p>",
        "id": 187649724,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089841
    },
    {
        "content": "<p>I guess, on the highest-possible level the current state is (module <code>mod foo;</code> bug fixed) is this:</p>\n<ul>\n<li>parser takes as an input the stream of spanned tokens and some state</li>\n<li>the parser produces an AST data structure, and record auxilary information into the state along the way (like the gated spans)</li>\n</ul>",
        "id": 187649729,
        "sender_full_name": "matklad",
        "timestamp": 1581089844
    },
    {
        "content": "<p>(One thing I'm curious to dig a bit more into is recovery and prediction, for example)</p>",
        "id": 187649759,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089858
    },
    {
        "content": "<blockquote>\n<p>(One thing I'm curious to dig a bit more into is recovery and prediction, for example)</p>\n</blockquote>\n<p>I acutaly think that this is a well understood and boring bit. Like, you just write that code, it works.</p>",
        "id": 187649831,
        "sender_full_name": "matklad",
        "timestamp": 1581089898
    },
    {
        "content": "<p>I was going to write some bullets very much like that <span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>; I think what you're proposing could be seen as splitting that \"parser: tokens -&gt; ast\" interace so that there are more intermediate steps?</p>",
        "id": 187649834,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581089900
    },
    {
        "content": "<p>Oh, well, depending on which part of the recovery you are talking about</p>",
        "id": 187649868,
        "sender_full_name": "matklad",
        "timestamp": 1581089929
    },
    {
        "content": "<p>tweaking parser to recover is easy</p>",
        "id": 187649880,
        "sender_full_name": "matklad",
        "timestamp": 1581089937
    },
    {
        "content": "<p>My understanding is that we move to something more like syn, except for spans, we don't use spans</p>",
        "id": 187649886,
        "sender_full_name": "centril",
        "timestamp": 1581089939
    },
    {
        "content": "<blockquote>\n<p>tweaking parser to recover is easy</p>\n</blockquote>\n<p>And to be clear, I think the current parser does  a shit tonne of this</p>",
        "id": 187649918,
        "sender_full_name": "centril",
        "timestamp": 1581089960
    },
    {
        "content": "<p>tweaking syntax trees to incorporate incomplete syntax is hard, and is, in some sence, the core of teh proposal</p>",
        "id": 187649922,
        "sender_full_name": "matklad",
        "timestamp": 1581089962
    },
    {
        "content": "<blockquote>\n<p>And to be clear, I think the current parser does a shit tonne of this</p>\n</blockquote>\n<p>I haven't looked into this recently, but the last time I did (around original libsytnax2 RFC) the recovery wasn't quite the one needed for IDEs</p>",
        "id": 187650060,
        "sender_full_name": "matklad",
        "timestamp": 1581090037
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> speaking of recovery; I think it's important that we be able to retain e.g. higher level combinators like <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html#method.parse_delim_comma_seq\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html#method.parse_delim_comma_seq\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html#method.parse_delim_comma_seq</a></p>",
        "id": 187650071,
        "sender_full_name": "centril",
        "timestamp": 1581090046
    },
    {
        "content": "<p>But I do belive that these are detains</p>",
        "id": 187650076,
        "sender_full_name": "matklad",
        "timestamp": 1581090049
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> but could you briefly elaborate on what sort of recovery you think was missing?</p>",
        "id": 187650134,
        "sender_full_name": "centril",
        "timestamp": 1581090098
    },
    {
        "content": "<p>(I think most of the current parser code is actually recovery...)</p>",
        "id": 187650148,
        "sender_full_name": "centril",
        "timestamp": 1581090113
    },
    {
        "content": "<p>can we come back to this core parser interface? it seems like the details kind of matter.</p>\n<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> said earlier (I believe) that the current model for the parser is that it takes as input:</p>\n<ul>\n<li>the same tokens proc-macro specifies (which are fairly open-ended)</li>\n</ul>\n<p>and produces  as output</p>\n<ul>\n<li>an AST plus some auxiliary stuff (e.g., information about where unstable syntax was used in parsing that AST).</li>\n</ul>\n<p>I think that the question is whether we can refactor the parser to have two phases:</p>\n<ul>\n<li>parse-to-events: takes in tokens, produces some kind of event stream or other more \"neutral\" data structure</li>\n<li>events-to-AST: something that constructs the AST from that?</li>\n</ul>\n<p>Is this correct?</p>\n<p>EDIT: To elaborate, part of why I brought up recovery, is I wanted to understand whether recovery would like in parse-to-events or events-to-AST, I think probably the former...</p>",
        "id": 187650254,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090174
    },
    {
        "content": "<p>(Sorry, I was typing that while <span class=\"user-mention\" data-user-id=\"126931\">@centril</span> was asking their question, feel free to answer that first :)</p>",
        "id": 187650269,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> here's example where rustc doesn't even produce an ast: <a href=\"https://gist.github.com/matklad/5725e97192363c973c985e3d765d7fbf\" target=\"_blank\" title=\"https://gist.github.com/matklad/5725e97192363c973c985e3d765d7fbf\">https://gist.github.com/matklad/5725e97192363c973c985e3d765d7fbf</a></p>",
        "id": 187650279,
        "sender_full_name": "matklad",
        "timestamp": 1581090197
    },
    {
        "content": "<p>(not 100% sure about that, but <code>-Z ast-json</code> should show AST if rustc got to that phase?)</p>",
        "id": 187650306,
        "sender_full_name": "matklad",
        "timestamp": 1581090221
    },
    {
        "content": "<p>rust-analyzer produces the tree, and recognizes the <code>main</code> function</p>",
        "id": 187650323,
        "sender_full_name": "matklad",
        "timestamp": 1581090241
    },
    {
        "content": "<p>the example is</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">use</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 187650367,
        "sender_full_name": "matklad",
        "timestamp": 1581090253
    },
    {
        "content": "<p>And that is exactly the code the IDE sees when a user adds a new <code>use</code></p>",
        "id": 187650377,
        "sender_full_name": "matklad",
        "timestamp": 1581090266
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> correct, yes; the current parser would return <code>Err(...)</code> and fail unless there's more elaborate recovery</p>",
        "id": 187650400,
        "sender_full_name": "centril",
        "timestamp": 1581090292
    },
    {
        "content": "<p>what the current parser does a lot of is semantic recovery</p>",
        "id": 187650407,
        "sender_full_name": "centril",
        "timestamp": 1581090301
    },
    {
        "content": "<p>e.g. <code>auto x = 0;</code> we will recognize</p>",
        "id": 187650421,
        "sender_full_name": "centril",
        "timestamp": 1581090311
    },
    {
        "content": "<p>Yeah, and this is not the kind of recovery that is needed for ide use case. I suggest tabling recovery disucssion at this :)</p>",
        "id": 187650443,
        "sender_full_name": "matklad",
        "timestamp": 1581090336
    },
    {
        "content": "<p>sure</p>",
        "id": 187650447,
        "sender_full_name": "centril",
        "timestamp": 1581090343
    },
    {
        "content": "<blockquote>\n<p>To elaborate, part of why I brought up recovery, is I wanted to understand whether recovery would like in parse-to-events or events-to-AST, I think probably the former...</p>\n</blockquote>\n<p>I think ide recovery belongs to the former, and semantic recovery kind of belongs to both</p>",
        "id": 187650519,
        "sender_full_name": "matklad",
        "timestamp": 1581090383
    },
    {
        "content": "<p>Does that imply my summary of the split is correct?</p>",
        "id": 187650539,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090402
    },
    {
        "content": "<p>Like, semantic recovery would insert explicit \"missing expression\" nodes into places where there isn't any code at all</p>",
        "id": 187650550,
        "sender_full_name": "matklad",
        "timestamp": 1581090411
    },
    {
        "content": "<p>Yes, I belive the summary is correct</p>",
        "id": 187650561,
        "sender_full_name": "matklad",
        "timestamp": 1581090421
    },
    {
        "content": "<p>(Although I think I remember us discussing, specifically, whether we really want to have a \"generate events\" step, or whether we want a parser that can produce <em>both</em> AST and events, depdnding on configuration)</p>",
        "id": 187650571,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090429
    },
    {
        "content": "<p>The main (only?) sticking point for me is:</p>\n<blockquote>\n<p>The tree is untyped. Each node has a “type tag”, SyntaxKind.</p>\n<p>Syntax trees are simple value type. It is possible to create trees for a syntax without any external context.</p>\n</blockquote>\n<p>Making the parser untyped comes with all of the problems that untypedness entails. It's a great property of the current parser that I can simply make some change to the AST and then the compiler will yell at me regarding all the places that I need to change... and ofc typedness prevents bugs... So I'm not a fan of:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">// test box_pat</span>\n<span class=\"c1\">// fn main() {</span>\n<span class=\"c1\">//     let box i = ();</span>\n<span class=\"c1\">//     let box Outer { box i, j: box Inner(box &amp;x) } = ();</span>\n<span class=\"c1\">//     let box ref mut i = ();</span>\n<span class=\"c1\">// }</span>\n<span class=\"k\">fn</span> <span class=\"nf\">box_pat</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Parser</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">CompletedMarker</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">assert</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">at</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"k\">box</span><span class=\"p\">]));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">bump</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"k\">box</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pattern</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">complete</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">BOX_PAT</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 187650591,
        "sender_full_name": "centril",
        "timestamp": 1581090447
    },
    {
        "content": "<p>i want to add though, that I think an important part of \"neutral\"ity is being untagged</p>",
        "id": 187650593,
        "sender_full_name": "matklad",
        "timestamp": 1581090451
    },
    {
        "content": "<p>I would much prefer to e.g. have an interface based on associated types, which RA can dispatch to untyped things whereas rustc dispatches to typed things</p>",
        "id": 187650680,
        "sender_full_name": "centril",
        "timestamp": 1581090495
    },
    {
        "content": "<p>e.g. <code>type Pat;</code></p>",
        "id": 187650694,
        "sender_full_name": "centril",
        "timestamp": 1581090511
    },
    {
        "content": "<p>and <code>type Expr;</code></p>",
        "id": 187650698,
        "sender_full_name": "centril",
        "timestamp": 1581090514
    },
    {
        "content": "<p>Yeah, this is the core  question!</p>",
        "id": 187650723,
        "sender_full_name": "matklad",
        "timestamp": 1581090533
    },
    {
        "content": "<p>so what are the main benefits of being untagged?</p>",
        "id": 187650747,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581090552
    },
    {
        "content": "<p>I agree that typedness has benefits, but I also think that this is a tradeoff</p>",
        "id": 187650750,
        "sender_full_name": "matklad",
        "timestamp": 1581090553
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> can I make sure I understand your point? Are you saying that you like having the parser produce a \"typed AST\" (i.e., a set of enums that are tied very closely to rust's syntax) because it helps you ensure that the parser is \"in sync\". i.e., if I edit the AST to add a new field to some kind of expression, then I will get errors until I adjust the parser to supply values for that field?</p>",
        "id": 187650788,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090584
    },
    {
        "content": "<blockquote>\n<p>so what are the main benefits of being untagged?</p>\n</blockquote>\n<p>(or of <strong>supporting</strong> untaggedness)</p>",
        "id": 187650790,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581090587
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <code>enum</code>s are what we have today</p>",
        "id": 187650858,
        "sender_full_name": "centril",
        "timestamp": 1581090614
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> in terms of untagged <em>trees</em>, they are much better at representing incomplete trees and triva nodes</p>",
        "id": 187650886,
        "sender_full_name": "matklad",
        "timestamp": 1581090637
    },
    {
        "content": "<p>what I'm suggesting is that we move from an initial (tagged) encoding with <code>enum</code>s to a final tagless encoding based on associated types</p>",
        "id": 187650896,
        "sender_full_name": "centril",
        "timestamp": 1581090650
    },
    {
        "content": "<p>Typed trees by definition exclude certain impossible states, but with broken code any state is possible</p>",
        "id": 187650902,
        "sender_full_name": "matklad",
        "timestamp": 1581090658
    },
    {
        "content": "<p>I can believe this; i.e. I can believe they handle the <code>use fn main() { }</code> case better.</p>",
        "id": 187650907,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581090664
    },
    {
        "content": "<p>In terms of untagged parser, it <strong>massively</strong> simplies the interface.</p>",
        "id": 187650914,
        "sender_full_name": "matklad",
        "timestamp": 1581090672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> you didn't really answer my question though, did I understand you correctly as to the benefits?</p>",
        "id": 187650917,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090675
    },
    {
        "content": "<p>(I believe similar benefits could be obtained in other ways, as I think you are now suggesting)</p>",
        "id": 187650936,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090694
    },
    {
        "content": "<p>Like, its a \"trait with handful of methods\" vs \"trait with hundreds of associated types\"</p>",
        "id": 187650940,
        "sender_full_name": "matklad",
        "timestamp": 1581090697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> yes, but also typedness generally prevents bugs. I cannot put something of the wrong type where it doesn't belong</p>",
        "id": 187650953,
        "sender_full_name": "centril",
        "timestamp": 1581090706
    },
    {
        "content": "<p>It seems to me that there may be some interaction with pre-expansion gating, as well. In particular, if we have untyped trees, we might be able to represent things like \"a function whose body is not yet parsed\"</p>",
        "id": 187651055,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090745
    },
    {
        "content": "<blockquote>\n<p>In terms of untagged parser, it <strong>massively</strong> simplies the interface.</p>\n</blockquote>\n<p>this is a distinct feature of untagged-ness, and unless I misunderstand, it is at direct odds with <span class=\"user-mention\" data-user-id=\"126931\">@centril</span>'s desire for static checking, right?</p>",
        "id": 187651065,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581090755
    },
    {
        "content": "<p>(and which is ultimately stripped before it becomes necessary to parse it)</p>",
        "id": 187651069,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090757
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> I think you are overestimating how many types there are in <a href=\"http://ast.rs\" target=\"_blank\" title=\"http://ast.rs\">ast.rs</a></p>",
        "id": 187651074,
        "sender_full_name": "centril",
        "timestamp": 1581090762
    },
    {
        "content": "<blockquote>\n<p>this is a distinct feature of untagged-ness, and unless I misunderstand, it is at direct odds with @centril's desire for static checking, right?</p>\n</blockquote>\n<p>Right</p>",
        "id": 187651096,
        "sender_full_name": "matklad",
        "timestamp": 1581090782
    },
    {
        "content": "<p>(time check: 52 minutes; velocity check: I'm feeling a bit overwhelmed by how many threads of discussion are happening at once, apologies for adding to them :)</p>",
        "id": 187651113,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090800
    },
    {
        "content": "<p>/me will try to capture some of what's been said in last few minutes into <a href=\"https://hackmd.io/MR4bSmcpSlOPhz6aSebpXQ\" target=\"_blank\" title=\"https://hackmd.io/MR4bSmcpSlOPhz6aSebpXQ\">doc</a></p>",
        "id": 187651138,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581090819
    },
    {
        "content": "<p>There are <strong>246</strong> syntax kinds in rust-analyzer</p>",
        "id": 187651147,
        "sender_full_name": "matklad",
        "timestamp": 1581090824
    },
    {
        "content": "<p>can you link to that list?</p>",
        "id": 187651198,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581090843
    },
    {
        "content": "<p>rustc's ast is simpler, because it is an AST and not a CST, so it can elide details</p>",
        "id": 187651229,
        "sender_full_name": "matklad",
        "timestamp": 1581090849
    },
    {
        "content": "<p>ugh... that's a whole heck of a lot more than in <a href=\"http://ast.rs\" target=\"_blank\" title=\"http://ast.rs\">ast.rs</a></p>",
        "id": 187651248,
        "sender_full_name": "centril",
        "timestamp": 1581090858
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/1996762b1f2b9cb196cc879f0ce26d28a3c450c8/crates/ra_parser/src/syntax_kind/generated.rs#L12-L245\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/blob/1996762b1f2b9cb196cc879f0ce26d28a3c450c8/crates/ra_parser/src/syntax_kind/generated.rs#L12-L245\">https://github.com/rust-analyzer/rust-analyzer/blob/1996762b1f2b9cb196cc879f0ce26d28a3c450c8/crates/ra_parser/src/syntax_kind/generated.rs#L12-L245</a></p>",
        "id": 187651274,
        "sender_full_name": "matklad",
        "timestamp": 1581090874
    },
    {
        "content": "<p>specific to parser, the typedness also facilitates knowing what the actual grammar is</p>",
        "id": 187651331,
        "sender_full_name": "centril",
        "timestamp": 1581090921
    },
    {
        "content": "<p>It also includes tokens, so I think we may save a 100 by not making type disticntions between tokens</p>",
        "id": 187651333,
        "sender_full_name": "matklad",
        "timestamp": 1581090922
    },
    {
        "content": "<p>but then we lose some type safety</p>",
        "id": 187651344,
        "sender_full_name": "matklad",
        "timestamp": 1581090930
    },
    {
        "content": "<p>I think the tradeoff from a rustc centric POV clearly speaks in favor of being typed</p>",
        "id": 187651370,
        "sender_full_name": "centril",
        "timestamp": 1581090952
    },
    {
        "content": "<p>I can imagine there is a middle ground here, where we use associated types solely for the types already identified by <a href=\"http://ast.rs\" target=\"_blank\" title=\"http://ast.rs\">ast.rs</a></p>",
        "id": 187651443,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581090989
    },
    {
        "content": "<p>For incomplete things we also have <code>ExprKind::Err</code> btw</p>",
        "id": 187651465,
        "sender_full_name": "centril",
        "timestamp": 1581091002
    },
    {
        "content": "<p>I also don't think that typing <em>parsing</em> code is that important</p>",
        "id": 187651481,
        "sender_full_name": "matklad",
        "timestamp": 1581091013
    },
    {
        "content": "<p>What is important, is having a fuzzable formal grammar, which you can check against the parser</p>",
        "id": 187651523,
        "sender_full_name": "matklad",
        "timestamp": 1581091041
    },
    {
        "content": "<p>Like, parser bugs are extremely easy and cheap to fix</p>",
        "id": 187651541,
        "sender_full_name": "matklad",
        "timestamp": 1581091061
    },
    {
        "content": "<p>I don't agree, especially not when we have stability to contend with</p>",
        "id": 187651559,
        "sender_full_name": "centril",
        "timestamp": 1581091078
    },
    {
        "content": "<p>well ... I don't know about that</p>",
        "id": 187651562,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581091081
    },
    {
        "content": "<p>(about being easy and cheap to fix, that is. especially when it comes to how recovery is implemented)</p>",
        "id": 187651622,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581091099
    },
    {
        "content": "<p>If RA accepts syntax it shouldn't, that doesn't have stability implications; for rustc it does</p>",
        "id": 187651656,
        "sender_full_name": "centril",
        "timestamp": 1581091125
    },
    {
        "content": "<p>I guess the comment was meant for correct code, not recovered code</p>",
        "id": 187651661,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1581091129
    },
    {
        "content": "<p>I don't think I had a lot of parser bugs in rust-anlayzer, which could have be prevented by typeing.</p>\n<p>Like, the today's bug is that we mixed up the order of <code>async</code> and <code>unsafe</code>.</p>",
        "id": 187651695,
        "sender_full_name": "matklad",
        "timestamp": 1581091155
    },
    {
        "content": "<blockquote>\n<p>What is important, is having a fuzzable formal grammar, which you can check against the parser</p>\n</blockquote>\n<p>We also don't have this</p>",
        "id": 187651699,
        "sender_full_name": "centril",
        "timestamp": 1581091156
    },
    {
        "content": "<p>My gut feeling is that most parser bugs are like that</p>",
        "id": 187651711,
        "sender_full_name": "matklad",
        "timestamp": 1581091165
    },
    {
        "content": "<p>this is hard to answer definitively but it does feel like there may be a structure that gives some of the benefits of both</p>",
        "id": 187651807,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581091215
    },
    {
        "content": "<p>that said, it's been one hour</p>",
        "id": 187651823,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581091224
    },
    {
        "content": "<p>yeah I gotta go</p>",
        "id": 187651838,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581091229
    },
    {
        "content": "<p>(despite being late in  the first place)</p>",
        "id": 187651846,
        "sender_full_name": "pnkfelix",
        "timestamp": 1581091239
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> btw, did you consider the question re. <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html#method.parse_delim_comma_seq\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html#method.parse_delim_comma_seq\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_parse/parser/struct.Parser.html#method.parse_delim_comma_seq</a> and whether we can do similar things in the new model?</p>",
        "id": 187651854,
        "sender_full_name": "centril",
        "timestamp": 1581091241
    },
    {
        "content": "<p>these higher order combinators were important for recent cleanups to the parser</p>",
        "id": 187651876,
        "sender_full_name": "centril",
        "timestamp": 1581091256
    },
    {
        "content": "<p>things were quite messy before, and I would like not to get back into that situation</p>",
        "id": 187651890,
        "sender_full_name": "centril",
        "timestamp": 1581091270
    },
    {
        "content": "<p>And not that we don't have parser bugs in rustc: <a href=\"https://github.com/rust-lang/rust/pull/37278\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/37278\">https://github.com/rust-lang/rust/pull/37278</a></p>",
        "id": 187651892,
        "sender_full_name": "matklad",
        "timestamp": 1581091270
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126931\">@centril</span> high order combinations are combatible with event-based untagged parser I belive</p>",
        "id": 187651927,
        "sender_full_name": "matklad",
        "timestamp": 1581091301
    },
    {
        "content": "<p>I've done my best to <a href=\"https://hackmd.io/MR4bSmcpSlOPhz6aSebpXQ\" target=\"_blank\" title=\"https://hackmd.io/MR4bSmcpSlOPhz6aSebpXQ\">make notes here</a>, I'd appreciate it if folks took a look and made changes/additions/corrections. I think it's great to keep discussing btw, but maybe try to include notes in that doc? I think I have to step away for a bit too.</p>",
        "id": 187651935,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581091304
    },
    {
        "content": "<p>rust-analyzer's parsers started that way</p>",
        "id": 187651946,
        "sender_full_name": "matklad",
        "timestamp": 1581091309
    },
    {
        "content": "<p>Thanks <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> !</p>",
        "id": 187652014,
        "sender_full_name": "matklad",
        "timestamp": 1581091338
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>  yes sure, having fixed many bugs myself, I know that rustc also has parser bugs. They often come as a result of recovery, especially recovery encoded in ad-hoc ways</p>",
        "id": 187652019,
        "sender_full_name": "centril",
        "timestamp": 1581091341
    },
    {
        "content": "<p>That said, before I go, I want to ask one question. I wrote this:</p>\n<ul>\n<li>Proposal is to split the \"parsing function\" into two steps:<ul>\n<li>parse-to-events: takes in tokens, produces some kind of event stream or other more \"neutral\" data structure (\"untagged trees\")</li>\n<li>events-to-AST: something that constructs the AST from that?</li>\n</ul>\n</li>\n</ul>\n<p>but I feel a bit of disconnect about this. Is \"parse-to-events\" accurate, or is it \"parse-to-CST\"?</p>",
        "id": 187652025,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581091349
    },
    {
        "content": "<p>We can do both</p>",
        "id": 187652058,
        "sender_full_name": "matklad",
        "timestamp": 1581091375
    },
    {
        "content": "<p>those are not mutually exclusive?</p>",
        "id": 187652060,
        "sender_full_name": "centril",
        "timestamp": 1581091377
    },
    {
        "content": "<p>parse-to-events is easier to agree upon, as events are simpler than CST</p>",
        "id": 187652081,
        "sender_full_name": "matklad",
        "timestamp": 1581091393
    },
    {
        "content": "<p>I just feel like we didn't talk much about what these events would look like</p>",
        "id": 187652111,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581091412
    },
    {
        "content": "<p>But we can also decide that a specific CST format is reasonable, and parse directly to that</p>",
        "id": 187652123,
        "sender_full_name": "matklad",
        "timestamp": 1581091419
    },
    {
        "content": "<p>But yes I agree not necessarily mutually exclusive. I'll follow-up later.</p>",
        "id": 187652135,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581091435
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span>  btw, if you don't have to run, quick question... <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> often fancies using backtracking (e.g. cloning the parser state and then swapping it back) for better recovery</p>",
        "id": 187652185,
        "sender_full_name": "centril",
        "timestamp": 1581091444
    },
    {
        "content": "<p>can RA deal with this?</p>",
        "id": 187652189,
        "sender_full_name": "centril",
        "timestamp": 1581091450
    },
    {
        "content": "<p>It doesn't do backtracking, but I don't see why it can't be added</p>",
        "id": 187652267,
        "sender_full_name": "matklad",
        "timestamp": 1581091506
    },
    {
        "content": "<p>Especially given that the parser state is relatively simpler</p>",
        "id": 187652307,
        "sender_full_name": "matklad",
        "timestamp": 1581091532
    },
    {
        "content": "<blockquote>\n<p>I just feel like we didn't talk much about what these events would look like</p>\n</blockquote>\n<p>The interface rust-analyzer is using is literally this:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TreeSink</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">token</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">kind</span>: <span class=\"nc\">SyntaxKind</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n_tokens</span>: <span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">start_node</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">kind</span>: <span class=\"nc\">SyntaxKind</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">finish_node</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">error</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">error</span>: <span class=\"nc\">ParseError</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 187652393,
        "sender_full_name": "matklad",
        "timestamp": 1581091568
    },
    {
        "content": "<p>That is, for untyped events case</p>",
        "id": 187652414,
        "sender_full_name": "matklad",
        "timestamp": 1581091585
    },
    {
        "content": "<p>btw, <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> wasn't here, but it would be good to hear from them before we make changes</p>",
        "id": 187652803,
        "sender_full_name": "centril",
        "timestamp": 1581091839
    },
    {
        "content": "<blockquote>\n<p>But we can also decide that a specific CST format is reasonable</p>\n</blockquote>\n<p>This is actually an interesting point. I do think that the <code>Green</code> node layer from rust-analyzer is actually a pretty good CST in a sense that I don't think one can have a simpler interface, and that the impl of the interface does not seem outrageously ineffective.</p>\n<p>So, if we are OK with</p>\n<ul>\n<li>CST being untagged</li>\n<li>CST itself not storing hygiene information/global spans</li>\n</ul>\n<p>Than forgoing events and producing a green tree might be anintersting alternative</p>",
        "id": 187653277,
        "sender_full_name": "matklad",
        "timestamp": 1581092118
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> btw; how are we going to handle editions if we don't have spans in the parser?</p>",
        "id": 187899966,
        "sender_full_name": "centril",
        "timestamp": 1581417207
    },
    {
        "content": "<p>Why do you need spans for that?  We don't handle editions in ra yet, but I think they could be handled nicely by passing an <code>edition</code> argument to the <code>parse</code> function, such that the parser can appropriately parse/reject edition-dependent constructs.</p>\n<p>For edition lints, like \"use <code>dyn Trait</code>\", I think the same infra validation infra (post processing of CST) would work nicely.</p>",
        "id": 187900456,
        "sender_full_name": "matklad",
        "timestamp": 1581417583
    },
    {
        "content": "<p>Would passing an edition argument work with macro calls between different editions work?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"c1\">//edition 2015</span>\n<span class=\"n\">macro_rules</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">my_macro</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"o\">@</span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"cp\">$a</span>:<span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cp\">$a</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$($a</span>:<span class=\"nc\">tt</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">try</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"n\">my_macro</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"o\">@</span><span class=\"n\">expr</span><span class=\"w\"> </span><span class=\"cp\">$($a</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">//edition 2018</span>\n<span class=\"n\">my_macro</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">try</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>should work I think, as the macro body is parsed as 2015 edition, while I think the <code>try { a }</code> is parsed as 2018 edition when passed to <code>my_macro!(@expr $($a)*));</code>.</p>",
        "id": 187901520,
        "sender_full_name": "bjorn3",
        "timestamp": 1581418490
    },
    {
        "content": "<p>When deciding on what to parse when it comes to e.g. <code>.await</code> we check the span on the current token, e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">span</span><span class=\"p\">.</span><span class=\"n\">rust_2018</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">&amp;&amp;</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">eat_keyword</span><span class=\"p\">(</span><span class=\"n\">kw</span>::<span class=\"n\">Await</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">mk_await_expr</span><span class=\"p\">(</span><span class=\"n\">self_arg</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">lo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Changing this to a system based on \"pass in the edition in <code>parse</code>\" I am not sure how that would work out with edition hygiene (interactions with macros).<br>\nI think you'll need to check with <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> to see if we can change systems here.</p>",
        "id": 187901529,
        "sender_full_name": "centril",
        "timestamp": 1581418501
    },
    {
        "content": "<blockquote>\n<p>For edition lints, like \"use dyn Trait\", I think the same infra validation infra (post processing of CST) would work nicely.</p>\n</blockquote>\n<p>(We don't make parsing decisions wrt. <code>dyn Trait</code> based on the edition; that's done later.)</p>",
        "id": 187901555,
        "sender_full_name": "centril",
        "timestamp": 1581418531
    },
    {
        "content": "<p>Hmm... actually; come to think of it, doesn't the current setup of the rustc parser wrt. editions make it context sensitive? -- actually probably not...</p>",
        "id": 187901632,
        "sender_full_name": "centril",
        "timestamp": 1581418582
    },
    {
        "content": "<p>Wow, this does seem like an unfortunate interaction....</p>\n<p>So, this is for cases where we pass a 2018 edition expression to 2015 edition macro?</p>\n<p>Something like <code>log::info!(\"{}\", my_future.await)</code>, where the intermediate result can also go via <code>$tt</code> phase...</p>\n<p>That makes invisible delimiters model harder to make nice and self-contained :-(</p>",
        "id": 187901837,
        "sender_full_name": "matklad",
        "timestamp": 1581418775
    },
    {
        "content": "<p>I don't recall exactly, but there are some tests I'm sure you could look at</p>",
        "id": 187901988,
        "sender_full_name": "centril",
        "timestamp": 1581418890
    },
    {
        "content": "<p>I guess this is surmountable: when the parser consumes an invisible delimiter, the TokenSource also informs the parser about the currently active edition. But it does add complexity to the interface.</p>",
        "id": 187902127,
        "sender_full_name": "matklad",
        "timestamp": 1581419009
    },
    {
        "content": "<p>That might work. Seems preferable as a matter of specification as compared to spans + editions</p>",
        "id": 187902279,
        "sender_full_name": "centril",
        "timestamp": 1581419158
    },
    {
        "content": "<p>What about <code>macro_rules! m { ($a:tt) =&gt; { future.$a } }</code> in 2015 edition crate and then <code>m!(await)</code> in 2018 edition crate. I assume there is no invisible delimiter in that case.</p>",
        "id": 187902473,
        "sender_full_name": "bjorn3",
        "timestamp": 1581419316
    }
]