[
    {
        "content": "<p>I took a little break from .next to work on one of the simpler tasks I mentioned <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20Hackathon.202021-07-30/near/247609442\">prior to the resumption of Polonius sprints</a>, speeding up move/inits by taking advantage of basic blocks.</p>\n<p>I wrote up an experience report as part of <a href=\"https://github.com/rust-lang/polonius/issues/182\">rust-lang/polonius#182</a>, but it's quite long for such a simple idea, so don't feel obligated to read the whole thing. It's targeted more at neophytes. However, it does discuss some shortcomings in Soufflé (not sure if they're in DDLog) that we'll encounter if we try to use more basic-block aware analyses as well as some workarounds I found. These don't really apply to <code>datafrog</code>, where we have total control over the underlying queries.</p>",
        "id": 260462029,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636144945
    },
    {
        "content": "<p>that is a lovely write-up (shame about the soufflé shortcomings tho)</p>",
        "id": 260469320,
        "sender_full_name": "lqd",
        "timestamp": 1636149272
    },
    {
        "content": "<p>(this exploration into the \"everything is horn clauses\" mantra also reminded me of a paper arguing for the use of Horn clauses as the compiler IR)</p>",
        "id": 260469417,
        "sender_full_name": "lqd",
        "timestamp": 1636149361
    },
    {
        "content": "<p>I was also expecting that a solution to the move/init inefficiencies would be to use the MIR dataflow framework (or possibly even the correct  <code>Analysis</code>directly) — and was also maybe contemplating this for liveness</p>",
        "id": 260470636,
        "sender_full_name": "lqd",
        "timestamp": 1636150104
    },
    {
        "content": "<p>(depending on exactly how the split would be chosen, it could e.g. have meant having a shared library of types/traits close to fact gen, either in the same shared type library that chalk has, or one in the same spirit)</p>",
        "id": 260470955,
        "sender_full_name": "lqd",
        "timestamp": 1636150311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Basic-blocks.20and.20move.2Finit/near/260470636\">said</a>:</p>\n<blockquote>\n<p>I was also expecting that a solution to the move/init inefficiencies would be to use the MIR dataflow framework (or possibly even the correct  <code>Analysis</code>directly) — and was also maybe contemplating this for liveness</p>\n</blockquote>\n<p>Yeah, this would also work. Both Souffle and DDLog allow you to call arbitrary functions in rule bodies as constraints, as does <code>datafrog</code>. Unfortunately, doing this in Souffle would require C++ bindings to the dataflow framework, which is huge bummer.</p>",
        "id": 260474594,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636153153
    },
    {
        "content": "<p>(that was a very enjoyable read, you should post it to your blog :)</p>",
        "id": 260476637,
        "sender_full_name": "lqd",
        "timestamp": 1636154802
    },
    {
        "content": "<div class=\"message_inline_image\"><a href=\"https://imgs.xkcd.com/comics/superlative.png\"><img src=\"https://uploads.zulipusercontent.net/fae6361411ff8b7811c40eb28681fd24846cbcdb/68747470733a2f2f696d67732e786b63642e636f6d2f636f6d6963732f73757065726c61746976652e706e67\"></a></div><p>\"His blog has four posts, all apologies for not posting more\"</p>",
        "id": 260476766,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636154903
    },
    {
        "content": "<p>:D</p>",
        "id": 260476903,
        "sender_full_name": "lqd",
        "timestamp": 1636155010
    },
    {
        "content": "<p>I'll also say, just so I don't forget, that it's not quite as simple as hooking up datalog with a dataflow cursor. Cursors are only efficient if you visit statements in dataflow order (backwards for liveness), in random order each seek is worst-case linear in the number of statements per block. This can be problematic when you have something that propagates forward but also needs to check liveness. One option is to cache liveness data within a basic block, since we should be generating many facts for the same basic block in a row.</p>",
        "id": 260477460,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636155539
    },
    {
        "content": "<p>and you could use a more advanced caching strategy if that's not enough.</p>",
        "id": 260477565,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636155656
    },
    {
        "content": "<p>one thing I am very curious about:</p>",
        "id": 260673073,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385687
    },
    {
        "content": "<p>whether a top-down approach (vs bottom-up) would be a winner</p>",
        "id": 260673099,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385699
    },
    {
        "content": "<p>for example, for MIR, when we compute liveness, we do it per-variable</p>",
        "id": 260673118,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385705
    },
    {
        "content": "<p>we don't use bit sets</p>",
        "id": 260673120,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385707
    },
    {
        "content": "<p>I found that to be quite a bit faster</p>",
        "id": 260673134,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385713
    },
    {
        "content": "<p>that's not really <em>top down</em> but it does show that sometimes tracing through the IR for one particular thing is better than not</p>",
        "id": 260673184,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385736
    },
    {
        "content": "<p>I could imagine that, e.g., looking at each use of a variable and just checking whether it's initiailized, borrowed, etc might actually be faster, particularly if we added in some kind of incremental approach ala DD Log</p>",
        "id": 260673224,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385762
    },
    {
        "content": "<p>well, the incremental isn't really needed per se</p>",
        "id": 260673298,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385783
    },
    {
        "content": "<p>I'm just saying if we cache the results from a particular point</p>",
        "id": 260673320,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385789
    },
    {
        "content": "<p>this could work <em>particularly</em> well combined with a naive analysis to highlight potential errors</p>",
        "id": 260673341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385802
    },
    {
        "content": "<p>particularly well compared to the current move/init or to rustc’s move/init analysis ? (I’m still personally a tad skeptical about using datalog for move/init tbh)</p>",
        "id": 260716299,
        "sender_full_name": "lqd",
        "timestamp": 1636404313
    },
    {
        "content": "<p>either, imo</p>",
        "id": 260729496,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636411264
    },
    {
        "content": "<p>I'm not sure whether <em>datalog</em> is the way to go</p>",
        "id": 260729505,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636411270
    },
    {
        "content": "<p>though I still want to have some kind of crystal clear reference rules</p>",
        "id": 260729522,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636411287
    },
    {
        "content": "<p>but I think that having \"coarse-grained\" analysis to uncover trouble points and then analyzing those specific trouble points seems like a win</p>",
        "id": 260729553,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636411310
    },
    {
        "content": "<p>we certainly have problems in rustc with propagating tons of bits being slow, too</p>",
        "id": 260729609,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636411324
    },
    {
        "content": "<p>the idea has potential (and it sounds to me like there'd be a tipping point where one of the 2 approaches is better than the other) and we should surely try it at the very least</p>",
        "id": 260784758,
        "sender_full_name": "lqd",
        "timestamp": 1636457606
    }
]