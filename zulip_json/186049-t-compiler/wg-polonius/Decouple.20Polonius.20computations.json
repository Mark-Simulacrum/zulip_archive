[
    {
        "content": "<p>I looked into ways of making <code>move_errors</code> optional last night. I decided that I want move away from the current ad-hoc approach to data dependencies, timing, and comparative testing (i.e. naive vs opt vs hybrid) to a more principled one. Basically, Polonius would be split into discrete units (<code>inits</code>, <code>liveness</code>, etc.) with inputs and outputs, users could specify which sequence of units to run, and we could verify ahead of time that the sequence is a valid one (all intermediate relations like <code>origin_live_on_entry</code> are computed before they are needed as inputs). Comparative testing would happen automatically whenever two units declared the same output.</p>\n<p>I like this because it allows us to plug in different implementations for each unit and choose between them dynamically. Part of the reason I'm so down on my Souffle PR is that it's not integrated into Polonius; it's just \"bolted on\". My approach would make it much easier to experiment with alternative implementations (Souffle, DDLog, or something top-down).</p>\n<p>I've done some prototyping already and it seems alright so far. <span class=\"user-mention\" data-user-id=\"116113\">@lqd</span> is this something you've considered before? Would you take a different approach?</p>",
        "id": 265043378,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1639588828
    },
    {
        "content": "<p>the separation into discrete units is an architecture we've mentioned before (and tried to move towards with the current approach), however the rest of the things you describe we didn't (I don't think) sounds very interesting. The pluggability sounds nice, as well as the improvements to testing we could have for the alternatives.</p>\n<p>I'd love to see how your prototype looks</p>",
        "id": 265053888,
        "sender_full_name": "lqd",
        "timestamp": 1639593011
    },
    {
        "content": "<p>Okay, I'll keep plugging away.</p>",
        "id": 265054267,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1639593170
    },
    {
        "content": "<p>so in our case we'd have rustc choose whether to add move/init as a step to run in the analysis for example ? (be it via an option, or a parameter in the API Vytautas and Will Crichton added)</p>",
        "id": 265055421,
        "sender_full_name": "lqd",
        "timestamp": 1639593669
    },
    {
        "content": "<p>Currently, the way the system works is that there's a big \"Db\" object which can store all the relations we might care about. The caller would seed the database with the data they have, then specify the list of units they want to run as well as the outputs they expect. We check that each unit will have its inputs available and will emit those outputs (maybe at compile-time via horrible const hacks, but probably at runtime with decent error messages).</p>\n<p>I'm imagining wrapping a few well-known pipelines in a public utility function, but still allowing enfranchised users to specify their own pipelines if they want to seed later units with data or something.</p>",
        "id": 265056798,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1639594306
    },
    {
        "content": "<p>yeah, sounds like it would be very flexible, both for our couple different use-cases and unexpected ones from flowistry or prusti</p>",
        "id": 265065938,
        "sender_full_name": "lqd",
        "timestamp": 1639598076
    },
    {
        "content": "<p>I'm planning to work on this some more to start the year (I just got back from vacation). It's pretty dull work, unfortunately, and will be very difficult to review. I still think it's worth it though.</p>",
        "id": 266983186,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1641412780
    },
    {
        "content": "<p>I posted an implementation of this as <a href=\"https://github.com/rust-lang/polonius/issues/183\">rust-lang/polonius#183</a>. It's compatible with the exising <code>polonius-engine</code> interface, although exposing the set of internal relations (as <code>Output</code> does) is somewhat against the spirit of this decoupling.</p>\n<p>Unfortunately it's a 2kloc PR (a lot of moving to be fair) that doesn't add any new features and requires GATs. I can't really ask anyone to review it in a good conscience. Not sure what the path forward is.</p>",
        "id": 268324912,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1642461994
    },
    {
        "content": "<p>I’ve read it this weekend already (although not thoroughly reviewed as it’s … not small :). The rationale for not using nightly was easier integration into rustc, by depending on stable features and avoiding the bootstrap dance that can sometimes require (and which may be more complicated out-of-tree I’m not sure) and the belief that it can make for a more approachable environment for contribution. So I’m not sure it’s a hard requirement per se.</p>\n<p>If you feel that not exposing the internal Output relations could simplify things if it goes against the grain of the new API, by all means don’t feel obliged to keep that: their goal was simply testing and validation, so as long as we can test and debug the individual computations that would be fine. </p>\n<p>The compat machinery seemed useful while doing the refactoring IIUC but that’s not something you wanted to keep ? (Removing it could also simplify at the very least reviews :) Of course in that case, seeing how rustc would then call into polonius-engine would be useful, or, say, prusti (and having Vytautas’ opinion on the increased flexibility and new API would be nice as well).</p>\n<p>I don’t think we need the pipeline macro, and wish we could avoid the input/output macros: even at the cost of more boilerplate, it would keep the io structs explicit/clearer (something that felt obscured by e.g. the single output relation special case and snake_case to PascalCase renaming). And if it turns out the boilerplate is too much friction, we can of course add similar macros in the future. </p>\n<p>(For the record I’ve also not read through the complex dyn Computation machinery in detail)</p>\n<p>I forget if the early return in the Hybrid algorithm is still present in this refactoring (when there’s no location-insensitive errors), but it seems we’d still be able to have that, and also share potential errors and the involved subsets between the location insensitive and sensitive variants (as well as being able to potentially decouple subset errors from borrowck errors in both location sensitivity variants, as IIRC that’s the entry point chalk integration could require).</p>\n<p>As this would also be a not-insignificant increase in complexity, it would be good to have Niko’s opinion on the result (that is, not necessarily the details of the implementation) as he mentioned before that he wished for a different organization/architecture.</p>\n<p>(And although unrelated to the PR, the datafrog usage in these computation units would also be slightly simpler and cleaned up by <a href=\"https://github.com/rust-lang/datafrog/pull/48\">https://github.com/rust-lang/datafrog/pull/48</a> so that’s something to look forward to as well)</p>",
        "id": 268341987,
        "sender_full_name": "lqd",
        "timestamp": 1642479864
    },
    {
        "content": "<p>And it’s also super cool that it unblocks avoiding MoveInit to fix the issues seen in flowistry and in another open issue, offers more flexibility to others including prusti, helps with the alternative Soufflé backend, etc</p>",
        "id": 268344615,
        "sender_full_name": "lqd",
        "timestamp": 1642482989
    },
    {
        "content": "<blockquote>\n<p>and which may be more complicated out-of-tree I’m not sure</p>\n</blockquote>\n<p>Yeah, I don't know how we handle these cases. I assume <code>RUSTC_BOOTSTRAP</code> is set even when compiling dependencies.</p>\n<blockquote>\n<p>the belief that it can make for a more approachable environment for contribution.</p>\n</blockquote>\n<p>It basically just needs GATs (which are on the road to stabilization, maybe?).<code>const_type_id</code> could be removed at a relatively small cost.</p>\n<blockquote>\n<p>If you feel that not exposing the internal Output relations could simplify things if it goes against the grain of the new API, by all means don’t feel obliged to keep that: their goal was simply testing and validation, so as long as we can test and debug the individual computations that would be fine. </p>\n</blockquote>\n<p>It's more that it's subsumed by the <code>Dump</code> infrastructure. Keeping <code>Output</code> doesn't add any complexity, just boilerplate. I kept it because I didn't want to rewrite the testing harnesses RN. That PR is massive enough. In the long term, the fact loading parts of <code>rustc</code> should look at the set of input relations required by the specified <code>Pipeline</code>, and load only those.</p>\n<blockquote>\n<p>I don’t think we need the pipeline macro (nor the design by contract macros, and have to be deliberate in adding dependencies to polonius-engine in general as these would be subject to t-compiler approval), and wish we could avoid the input/output macros: even at the cost of more boilerplate, it would keep the io structs explicit/clearer (something that felt obscured by e.g. the single output relation special case and snake_case to PascalCase renaming). And if it turns out the boilerplate is too much friction, we can of course add similar macros in the future.</p>\n</blockquote>\n<p><code>contracts</code> can be removed, it just helps me iterate faster, and it's what I'm used to using outside <code>rustc</code>. I disagree with the rest of the paragraph (macros are good, actually), but accept that it's a matter of taste.</p>\n<blockquote>\n<p>I forget if the early return in the Hybrid algorithm is still present in this refactoring.</p>\n</blockquote>\n<p>I think I forgot it. <code>Hybrid</code> would have to depend on <code>potential{_subset,}_errors</code> in addition to the borrowck stuff, return early if they're empty, and delegate to <code>BorrowckOpt</code> if they weren't.</p>\n<blockquote>\n<p>As this would also be a not-insignificant increase in complexity, it would be good to have Niko’s opinion on the result.</p>\n</blockquote>\n<p><span aria-label=\"thumbs up\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"thumbs up\">:thumbs_up:</span></p>\n<blockquote>\n<p>offers more flexibility to others including prusti, </p>\n</blockquote>\n<p>One shortcoming of this PR is that it hardcodes the set of relations allowed in a <code>Db</code>. I had planned to use type-erased storage for them, but it's probably not necessary for an MVP. A flexible <code>Db</code>, along with the existing user-defined pipelines would allow external crates to depend on one anothers results and/or use them as input to the canonical <code>Borrowck</code> analyses, all without having to modify <code>polonius-engine</code>. That seemed cool to me, but also maybe not practically useful? I dunno.</p>",
        "id": 268345954,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1642484635
    }
]