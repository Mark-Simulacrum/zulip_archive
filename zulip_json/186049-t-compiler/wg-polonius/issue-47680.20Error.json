[
    {
        "content": "<p>Subsets that arise at <code>b</code> <em>without</em> the <code>None</code> branch (no error):</p>\n<div class=\"codehilite\"><pre><span></span><code>subset(&#39;L_Thing, &#39;t0)\nsubset(&#39;L_Thing, &#39;temp)\nsubset(&#39;L_Thing, &#39;v)\nsubset(&#39;t0, &#39;temp)\nsubset(&#39;t0, &#39;v)\nsubset(&#39;v, &#39;temp)\n</code></pre></div>\n<p>Subsets that arise at <code>b</code> <em>without</em> the <code>Some</code> branch (no error):</p>\n<div class=\"codehilite\"><pre><span></span><code>subset(&#39;L_*temp, &#39;t0)\nsubset(&#39;L_*temp, &#39;v)\nsubset(&#39;L_Thing, &#39;L_*temp)\nsubset(&#39;L_Thing, &#39;t0)\nsubset(&#39;L_Thing, &#39;temp)\nsubset(&#39;L_Thing, &#39;v)\nsubset(&#39;t0, &#39;v)\nsubset(&#39;temp, &#39;L_*temp)\nsubset(&#39;temp, &#39;t0)\nsubset(&#39;temp, &#39;v)\n</code></pre></div>",
        "id": 257732213,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634317919
    },
    {
        "content": "<p>(making a new topic for this)</p>",
        "id": 257732276,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634317929
    },
    {
        "content": "<p>So the <code>None</code> branch has <code>'L_*temp -&gt; 't0</code> and the <code>Some</code> branch has <code>'v -&gt; 'temp</code>, and both have <code>'t0 -&gt; 'v</code></p>",
        "id": 257733323,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634318348
    },
    {
        "content": "<p>What is missing is a notion about this not being able to happen at the same time</p>",
        "id": 257733655,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634318501
    },
    {
        "content": "<p>observation: if you remove the backedge (but keep the unrolled loop), you do not get an error</p>",
        "id": 257733662,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634318503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/issue-47680.20Error/near/257733662\">said</a>:</p>\n<blockquote>\n<p>observation: if you remove the backedge (but keep the unrolled loop), you do not get an error</p>\n</blockquote>\n<p>I think it needs 2 iterations (so 3 total), because the access and the invalidation are in the same node (<code>b</code>)</p>",
        "id": 257733931,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634318604
    },
    {
        "content": "<p>Yes</p>",
        "id": 257734285,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634318733
    },
    {
        "content": "<p>Do you think the merging the subset constraints can ever be okay, or do we need to track multiple sets of subset constraints if a node has multiple predecessors?</p>",
        "id": 257734447,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634318798
    },
    {
        "content": "<p>Could we have something like <code>subset_from_pred(O1, O2, AtNode, Pred)</code>, and only compute transitive closure on that with subsets from the same predecessors, then lower that to the regular <code>subset</code>?</p>",
        "id": 257736596,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634319713
    },
    {
        "content": "<p>I don't know! I'm pondering it. =) I think that the \"delete subsets if values are dead\" in the old polonius could certainly be added here, I have this feeling like it's a kind of \"hack\" of some kind.</p>",
        "id": 257736827,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634319824
    },
    {
        "content": "<p>But maybe an effective one :)</p>",
        "id": 257736902,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634319843
    },
    {
        "content": "<p>It also seems relevant that the <code>L_*temp</code> on one side is \"not the same\" as the <code>L_*temp</code> on the other; not sure how to think about that right now.</p>",
        "id": 257737015,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634319898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"337115\">Domenic Quirl</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/issue-47680.20Error/near/257736596\">said</a>:</p>\n<blockquote>\n<p>Could we have something like <code>subset_from_pred(O1, O2, AtNode, Pred)</code>, and only compute transitive closure on that with subsets from the same predecessors, then lower that to the regular <code>subset</code>?</p>\n</blockquote>\n<p>(I don't think this really works, btw, it seems like at some point we have to combine facts)</p>",
        "id": 257738259,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634320403
    },
    {
        "content": "<p>Yeah, I already realized that this alone just delays the merge by 1 step <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 257738398,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634320452
    },
    {
        "content": "<p>I'm currently thinking about: when would expect an <em>error</em>?</p>",
        "id": 257741131,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321590
    },
    {
        "content": "<p>hmm, just realized something</p>",
        "id": 257741331,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321681
    },
    {
        "content": "<p>the idea of the new analysis is to track what aliases what and what can be used without an error</p>",
        "id": 257741391,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321706
    },
    {
        "content": "<p>the old analysis \"knew the future\" (what was to come); that seems to really help here, because we can delete some edges since we know <code>v</code> is not used again</p>",
        "id": 257741434,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321724
    },
    {
        "content": "<p>so I guess I would say (a) if we want to add some form of liveness, I think we could do so; but also</p>",
        "id": 257741482,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321748
    },
    {
        "content": "<p>maybe the answer is that, at the control flow merge, we need to do something more than \"union\"; i.e., it actually <em>would</em> be some kind of error, I think, if <code>v</code> were used again at the control-flow merge point</p>",
        "id": 257741602,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321784
    },
    {
        "content": "<p>or temp were etc</p>",
        "id": 257741628,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321794
    },
    {
        "content": "<p>so i.e. the merge could conceivably move some regions to invalidated</p>",
        "id": 257741731,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321845
    },
    {
        "content": "<p>but .. I think I might prefer having some kind of clears inserted them things become dead; or if we it more \"checked\", having a \"make live\" and \"make dead\" nodes that get inserted (and it's some kind of error to involve an origin that is not live)</p>",
        "id": 257741865,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321889
    },
    {
        "content": "<p>even though that was something I was trying not to have :)</p>",
        "id": 257741919,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634321918
    },
    {
        "content": "<p>is .next + some liveness still interesting ? esp compared to the current formulation</p>",
        "id": 257742154,
        "sender_full_name": "lqd",
        "timestamp": 1634322012
    },
    {
        "content": "<p>would it maybe help with expressiveness, or avoid emitting some unnecessary errors that we'd emit with today's version ?</p>",
        "id": 257742463,
        "sender_full_name": "lqd",
        "timestamp": 1634322130
    },
    {
        "content": "<p>Good question... I feel like it's overall simpler? But I'm not sure.</p>",
        "id": 257742944,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322327
    },
    {
        "content": "<p>it is currently simpler yeah</p>",
        "id": 257743178,
        "sender_full_name": "lqd",
        "timestamp": 1634322425
    },
    {
        "content": "<p>its simplicity made it possible for us to remove loans, simplifying it further</p>",
        "id": 257743265,
        "sender_full_name": "lqd",
        "timestamp": 1634322467
    },
    {
        "content": "<p>(but that can probably be achieved on today's version :)</p>",
        "id": 257743337,
        "sender_full_name": "lqd",
        "timestamp": 1634322484
    },
    {
        "content": "<p>(in turn it's probably easier to some day make it \"production ready\" I presume)</p>",
        "id": 257743540,
        "sender_full_name": "lqd",
        "timestamp": 1634322580
    },
    {
        "content": "<p>I think the forward way of thinking is generally simpler</p>",
        "id": 257743583,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322596
    },
    {
        "content": "<p>if you frame liveness as 'allocate' and 'deallocate'</p>",
        "id": 257743675,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322615
    },
    {
        "content": "<p>that is still very \"operational\", which I like</p>",
        "id": 257743714,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322629
    },
    {
        "content": "<p>i.e., you can kind of \"trace forward\" to see what happens</p>",
        "id": 257743739,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322636
    },
    {
        "content": "<p>I guess I feel the current analysis is not doing the <em>wrong</em> thing, because I think there are things the user could do at the point of control-flow join where those edges make sense</p>",
        "id": 257743795,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322659
    },
    {
        "content": "<p>well, I take that back, in theory there is probably a way for it to recognize an error state</p>",
        "id": 257743902,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322701
    },
    {
        "content": "<p>that might be moving past datalog though :)</p>",
        "id": 257743919,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322708
    },
    {
        "content": "<p>Ok, so</p>",
        "id": 257744096,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634322774
    },
    {
        "content": "<p>this is combinatorically terrible</p>",
        "id": 257744107,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634322780
    },
    {
        "content": "<p>but including the derivation path of subsets in the relation seems to at least <em>work</em></p>",
        "id": 257744159,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634322807
    },
    {
        "content": "<p>push it to a branch? :)</p>",
        "id": 257744314,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322873
    },
    {
        "content": "<p>I am going to stop thinking about this for a bit, have to chew on it in the background I think</p>",
        "id": 257744341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1634322888
    },
    {
        "content": "<p><a href=\"https://github.com/domenicquirl/polonius.next/blob/5eeadf1f58490c19694c9377a7cf0fb31fc54a14/src/polonius.dl#L76\">https://github.com/domenicquirl/polonius.next/blob/5eeadf1f58490c19694c9377a7cf0fb31fc54a14/src/polonius.dl#L76</a></p>",
        "id": 257744689,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323051
    },
    {
        "content": "<p>I really need to clean up the tests so I don't need to manually check the output on every example</p>",
        "id": 257744800,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323090
    },
    {
        "content": "<p>guaranteed to make a mistake sooner rather than later</p>",
        "id": 257744818,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323099
    },
    {
        "content": "<p>What would be better than a full path would be some way to detect and mark exactly the case of multiple predecessors</p>",
        "id": 257744872,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323131
    },
    {
        "content": "<p>Essentially a way to say \"either do this, or do that, but not both\"</p>",
        "id": 257744894,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323143
    },
    {
        "content": "<p>still somewhat of a nightmare in terms of performance probably</p>",
        "id": 257744929,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323158
    },
    {
        "content": "<p>I'll stop for today now as well and do the clean ups tomorrow</p>",
        "id": 257744995,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323192
    },
    {
        "content": "<p>Bye <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 257745004,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634323199
    },
    {
        "content": "<p>I updated the test branch to do 2 loop iterations (because those were previously required to produce the error), and that holds up.</p>",
        "id": 257822767,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634382065
    },
    {
        "content": "<p>I've also been thinking about how to not need to model execution paths, but I'm getting hung up on the fact that there might be cases where new stuff does happen if a specific combination of branches is taken.</p>",
        "id": 257822773,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634382069
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">random_n</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Guaranteed to be random</span>\n<span class=\"w\">    </span><span class=\"mi\">4</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">   </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">random_n</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">c</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">           </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 257822795,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634382097
    },
    {
        "content": "<p>This makes NLL cry quite a lot (though, amusingly, only about the <code>0</code> and <code>1</code> case, and not <code>2</code>), but currently checks with <code>-Zpolonius</code></p>",
        "id": 257822892,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634382178
    },
    {
        "content": "<p>but if you take the branches in order, you get <code>a -&gt; b -&gt; c -&gt; d</code></p>",
        "id": 257822921,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634382209
    },
    {
        "content": "<p>I've been discussing this with some DDLog folks on Discord, but so far there is no specific solution. It was brought up, though, that a version of purely-forward that merges the subsets as before could be used as a pre-pass (like the location insensitive variant) if it accepts more programs than that/NLL (conservatively, that is, correctly)</p>",
        "id": 257823170,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634382479
    },
    {
        "content": "<p>that will be interesting to think about if we can't make it work with some forward simili liveness;  the idea of keeping it as a pre-pass (which likely would also require its own location-insensitive variant) in addition to the existing liveness-based ones seems to undermine the idea that this formulation is simpler, though</p>",
        "id": 257855593,
        "sender_full_name": "lqd",
        "timestamp": 1634413115
    },
    {
        "content": "<p>Well, it still <strong>is</strong> simpler, even if it ends up still being overly conservative. It would definitely be preferable if we can just get this to work fully, but I thought the comment was interesting enough to not get lost</p>",
        "id": 257863593,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634420497
    },
    {
        "content": "<p>if we still need the liveness based variants that we have today, to handle the cases it doesn't handle like 47680, then the whole is not simpler</p>",
        "id": 257863810,
        "sender_full_name": "lqd",
        "timestamp": 1634420720
    },
    {
        "content": "<p>Hm, my angle on this is slightly different. Sure, if I tell you \"you need to run this, plus a pre-pass before, plus a more complex set of rules after\", then that's more confusing and complicated than just \"you need to run this\". But the thing is, you don't. There will be one version that is correct and complete in the end, however complex that may be, and if you want the exact definition of borrow checking you only need to consider that version. So I think it's fair to compare the rulesets individually.</p>",
        "id": 257864987,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634421774
    },
    {
        "content": "<p>That said, I definitely see your point that a lot of the benefit that we hope to get here is lost in case this version should actually end up as a pre-pass at most</p>",
        "id": 257865036,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634421829
    },
    {
        "content": "<p>Instead of the pathed subsets (which I think get intractable quite quickly), I've been looking at carefully adding a little bit of liveness info. The rules and facts at <a href=\"https://github.com/domenicquirl/polonius.next/tree/liveness-subsets\">https://github.com/domenicquirl/polonius.next/tree/liveness-subsets</a> also solve <code>issue-47680</code>, while leaving other things like <code>self-invalidation-loop</code> intact.</p>",
        "id": 258338174,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634722384
    },
    {
        "content": "<p>The idea there is to stop propagating subset information for origins in variables that stop being live, yet do propagate transitive subset relations that may arise from the possibly dead intermediate. So e.g. moving a variable with an origin through an assignment will yield a relationship between origins that have flown into the variable's origins and those in the assignment target, but anything that explicitly mentions the variable's origins will not be propagated further</p>",
        "id": 258338469,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634722549
    },
    {
        "content": "<p>This means that, for <code>self-invalidation-loop</code>, we retain the transitive relationship between the borrow of <code>x</code> and the <code>v: Vec</code>, which are both outside the loop and alive. But for <code>issue-47680</code>, the two branches are no longer merged.</p>",
        "id": 258339059,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1634722858
    },
    {
        "content": "<p>I spent some time digging into <code>issue-47680</code> today. It seems like the root cause is that the creation of <code>&amp;'L_*temp</code> in node <code>b</code> both accesses <code>'temp</code> <em>and</em> invalidates it. However, unlike my self-invalidation example, the loan being created is not the same as the one being invalidated, and so it takes us a while to propagate the <code>invalidate_origin('L_*temp)</code> fact across the subset graph until it results in <code>origin_invalidated('temp)</code>. By the time that happens, we've lost the connection between the access and the invalidation.</p>\n<p>What if we remembered the context in which an origin was invalidated? Specifically, when propagating <code>origin_invalidated</code>, remember the loan (or equivalently the point in the CFG when that loan was created) as well. If the invalidation does not occur during the creation of a loan, use some dummy value instead. Then we amend <code>invalidated_origin_accessed</code> to ignore accesses if the accessed origin was invalidated at that same point.</p>\n<div class=\"codehilite\" data-code-language=\"Prolog\"><pre><span></span><code><span class=\"p\">.</span><span class=\"s s-Atom\">decl</span> <span class=\"nf\">origin_invalidated</span><span class=\"p\">(</span><span class=\"nn\">origin</span><span class=\"p\">:</span> <span class=\"nv\">Origin</span><span class=\"p\">,</span> <span class=\"nn\">at</span><span class=\"p\">:</span> <span class=\"nv\">Node</span><span class=\"p\">,</span> <span class=\"nn\">source</span><span class=\"p\">:</span> <span class=\"nv\">Node</span><span class=\"p\">)</span>\n\n<span class=\"nf\">invalidated_origin_accessed</span><span class=\"p\">(</span><span class=\"s s-Atom\">o</span><span class=\"p\">,</span> <span class=\"s s-Atom\">n</span><span class=\"p\">)</span> <span class=\"p\">:-</span>\n    <span class=\"nf\">access_origin</span><span class=\"p\">(</span><span class=\"s s-Atom\">o</span><span class=\"p\">,</span> <span class=\"s s-Atom\">n</span><span class=\"p\">),</span>\n    <span class=\"nf\">origin_invalidated</span><span class=\"p\">(</span><span class=\"s s-Atom\">o</span><span class=\"p\">,</span> <span class=\"s s-Atom\">n</span><span class=\"p\">,</span> <span class=\"s s-Atom\">source</span><span class=\"p\">),</span>\n    <span class=\"s s-Atom\">source</span> <span class=\"p\">!</span><span class=\"o\">=</span> <span class=\"s s-Atom\">n</span><span class=\"p\">.</span>\n</code></pre></div>",
        "id": 258636147,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1634860560
    },
    {
        "content": "<p>I'll try prototyping this to see if it's viable. Let me know if you see something obviously wrong.</p>",
        "id": 258636389,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1634860719
    },
    {
        "content": "<p>This makes the error go away, but Im not convinced yet.</p>",
        "id": 258672093,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1634886549
    },
    {
        "content": "<p>I've been thinking about this for a while, but I feel like I lack understanding of how exactly the lowering to MIR treats things. Consider this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">(){</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\">  </span><span class=\"c1\">// subset('L_2, 'x)</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// subset('L_*x, 'y), subset('x, 'L_*x) by unrolling</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\">         </span><span class=\"c1\">// Read of `*x` invalidates 'L_*x invalidates 'y</span>\n<span class=\"w\">                           </span><span class=\"c1\">// Write to `y` accesses 'y</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In surface Rust, e.g. the compiler error, this error is on the same statement. But from what I can tell looking at non-erroneous MIR (swapping the last line), the deref and the assignment would be split into two statements by lowering? If that is the case, I don't <em>think</em> we can have access and invalidation on the same node at the moment.</p>",
        "id": 258930500,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1635151196
    },
    {
        "content": "<p>(at the very least the current rules would not catch it, because it takes one edge for the invalidation to take effect)</p>",
        "id": 258930565,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1635151222
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/issue-47680.20Error/near/258672093\">said</a>:</p>\n<blockquote>\n<p>This makes the error go away, but Im not convinced yet.</p>\n</blockquote>\n<p>It does make me feel uneasy, which I think is mostly because I cannot explain why the rule is correct - that is, why is it OK to ignore illegal access errors that happen within one (potentially repeated) node? To me, this is very much less intuitive than the version which \"filters out\" origins of dead variables.</p>",
        "id": 258931154,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1635151579
    },
    {
        "content": "<p>That's not to say your source-tracking version might not be better in the end - it's at least the minimally invasive fix so far</p>",
        "id": 258931265,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1635151666
    },
    {
        "content": "<p>But it'd make me feel better to understand more why it works</p>",
        "id": 258931319,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1635151689
    },
    {
        "content": "<p>I share the slight \"unease\" about using only the location here, rather than some liveness and kill-rules (which feels more principled), in that unrelated changes in rustc's desugaring/lowering, or some change in the user's code that would look semantically identical (e.g. introducing some temporaries), could change between being valid and invalid</p>",
        "id": 258944850,
        "sender_full_name": "lqd",
        "timestamp": 1635160687
    },
    {
        "content": "<p>That's a really good point also!</p>",
        "id": 258950439,
        "sender_full_name": "Domenic Quirl",
        "timestamp": 1635164327
    }
]