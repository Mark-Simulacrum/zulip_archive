[
    {
        "content": "<p>Hi everyone! We're working on figuring out a plan for adding borrow-checking to gccrs. What we think would be the best approach would be to use polonius as a borrow-checking engine, and make it a mandatory pass of code generation using gccrs. Facts would be generated during one of the gcc intermediate representation pass, and given to polonius for analysis. We'd actually like to know what you think of the plan! We know that polonius does not implement all features of rustc's borrow checking yet, which is why we'd also like to add that we're more than willing to contribute to the project in order to help.</p>\n<p>We looked into how polonius works and figured out there would be two ways to utilize it:<br>\n1/ As a binary, where gccrs would just emit a facts directory for each function, similarly to <code>rustc -Znll-facts</code>.<br>\n2/ As a library, similarly to what <code>rustc</code> is doing: By amassing facts in an <code>AllFacts</code> structure. We could write a small interface in rust in order to bridge the gap between our C++ types and the <code>FactTypes</code> trait.</p>\n<p>As a sidenote, we still cannot compile the standard library or any of the dependencies that polonius relies on. So this thread is really more for discussion and ideas rather than entirely figuring out a strategy.</p>\n<p>We just thought we'd come by and ask what you think!</p>\n<p>We believe that we cannot ship a complete rust compiler without a borrow-checker, which is why we're starting to look into how to achieve that. I'd also like to emphasize once again on the contributing part: We are really interested in the polonius project, and would love to help wherever we can!</p>",
        "id": 273956074,
        "sender_full_name": "Arthur Cohen",
        "timestamp": 1646305303
    },
    {
        "content": "<p>First of all, <span aria-label=\"hearts\" class=\"emoji emoji-2665\" role=\"img\" title=\"hearts\">:hearts:</span>Ô∏è for \"We believe that we cannot ship a complete rust compiler without a borrow-checker\"; thank you for that.</p>",
        "id": 274029608,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646337248
    },
    {
        "content": "<p>Unless there's a strong reason to do otherwise, in general a library seems like it has substantial advantages, in processing data via memory and handing it back to the compiler that way. A separate binary would have invocation overhead, and intermediate-file overhead.</p>",
        "id": 274030135,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646337467
    },
    {
        "content": "<p>Yup, this is also what we were thinking. But wondering about whether or not one of those two might be preferred in the future :) if possible, it would be much better to simply have a small rust compatibility layer to talk with polonius-engine from gccrs</p>",
        "id": 274045002,
        "sender_full_name": "Arthur Cohen",
        "timestamp": 1646343976
    },
    {
        "content": "<p>Hopefully niko will also add some thoughts, but until then, yes: doing it like rustc with interned facts in memory is absolutely to be preferred. </p>\n<p>I have to say that it wouldn't be easy (but could become easi<em>er</em> -- still not easy -- in the future depending on where fact generation happens): both the model and implementation depend on a lot of code and assumptions and things that are baked and tested in rustc, in the earlier parts of the pipeline. The good news is there's an effort to make more independent libraries, formalism efforts, and a possible team dedicated to that in future. But polonius is not really in a state where it can be reliably used in rustc itself, let alone other compilers/tools. </p>\n<p>So with all this, it's probably good that it's not a pressing concern for you yet, and more of a plan for the future. When/if, or how that future will look though, I cannot say.</p>",
        "id": 274049253,
        "sender_full_name": "lqd",
        "timestamp": 1646346204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/polonius.20for.20gccrs/near/274049253\">said</a>:</p>\n<blockquote>\n<p>things that are baked and tested in rustc, in the earlier parts of the pipeline.</p>\n</blockquote>\n<p>Do you have more info on those early parts of the pipeline used in fact generation? Files or passes that I can look into?</p>\n<p>I saw facts being generated from the MIR during the borrow-checking phase. We're using gcc's tree language, which is also a CFG, and to which we can add passes such as fact generation. I'm trying to understand the scope of this objective to see how doable it is. </p>\n<p>Thanks a lot for the insight!</p>",
        "id": 274372438,
        "sender_full_name": "Arthur Cohen",
        "timestamp": 1646648728
    },
    {
        "content": "<p>The ir from which the facts are derived needs to distinguish between reference, mutable references and pointers. It needs to have type lifetimes (which are erased during monomorphization), it needs to happen before mononorphization for non-instantiated functions to be borrow checked and it needs to happen before drop elaboration (which happens before monomorphization). I believe someone said that in the future when/if polonius becomes the default borrowck it may be possible to move fact generation from MIR to THIR which is not a CFG like MIR but a typed version of HIR. Something like that may be the best place for gccrs if no generic MIR data structure is introduced. I think neither tree, nor gimple are suitable for the reasons I mentioned.</p>",
        "id": 274377713,
        "sender_full_name": "bjorn3",
        "timestamp": 1646652096
    },
    {
        "content": "<p>Can someone else with more understanding of polonius please confirm my above message is correct.</p>",
        "id": 274377810,
        "sender_full_name": "bjorn3",
        "timestamp": 1646652135
    },
    {
        "content": "<p>yeah, its place in the pipeline makes it depend on anything computed upstream, dataflow and NLL constraints, how MIR is typecked, how MIR is constructed complete with false edges and all, the various desugarings that go into that, etc</p>\n<p>note that mutabah is also starting work on a borrowck for mrustc (in C++ IIUC), so maybe it's worth keeping an eye on that/collaborating/etc</p>",
        "id": 274380273,
        "sender_full_name": "lqd",
        "timestamp": 1646653667
    },
    {
        "content": "<p>Thanks a lot for the detailed explanations!</p>\n<p>Yes, Mutabah is also working on a borrow-checker, but I haven't looked into how easy it would be to integrate it to gccrs, or rather, decouple it from mrustc. One of the advantages of polonius is also that it is a standalone library.</p>",
        "id": 274398076,
        "sender_full_name": "Arthur Cohen",
        "timestamp": 1646663099
    }
]