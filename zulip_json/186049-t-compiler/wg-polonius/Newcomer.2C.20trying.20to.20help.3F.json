[
    {
        "content": "<p>Hi, I'm fresh new and interested in this project. I have been reading the Polonius book and the current implementation, and trying to find if there is somewhere that I can help.</p>\n<p>I'd like to start with the Polonius book, as I found there are some chapters (the initialization analysis and the liveness analysis) are not written yet, and as a newcomer, it may help me to understand how Polonius works too.</p>",
        "id": 268546689,
        "sender_full_name": "Frank King",
        "timestamp": 1642602445
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"449849\">Frank King</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Newcomer.2C.20trying.20to.20help.3F/near/268546689\">said</a>:</p>\n<blockquote>\n<p>Hi, I'm fresh new and interested in this project. I have been reading the Polonius book and the current implementation, and trying to find if there is somewhere that I can help.</p>\n<p>I'd like to start with the Polonius book, as I found there are some chapters (the initialization analysis and the liveness analysis) are not written yet, and as a newcomer, it may help me to understand how Polonius works too.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"449849\">@Frank King</span> I think that's a good place to start. One of the things I experimented with in my Souffle branch was automatically generating documentation for each analysis <a href=\"https://github.com/rust-lang/polonius/pull/179/files?file-filters%5B%5D=.dl&amp;file-filters%5B%5D=.py\">directly from Datalog files</a>. Would you be interested in splitting that part out (and rewriting the markdown generator in Rust instead of my throwaway Python)? Although we wouldn't be able to execute the rules themselves yet, I think it would be good to have a version checked in that's written in some dialect of Datalog. WDYT <span class=\"user-mention\" data-user-id=\"116113\">@lqd</span>?</p>\n<p>There's also <a href=\"https://github.com/rust-lang-nursery/polonius/issues/175\">polonius#175</a> about documenting the optimized variant. It's more advanced, since you'll need to understand the Naive rules first. The location insensitive variant could also use documentation, and there's some outstanding design work about how to use its results to speed up a more precise variant if the location insensitive one can't rule out <em>all</em> errors.</p>",
        "id": 268605465,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1642627504
    },
    {
        "content": "<p>I was having network issues but tried to type this: That's a great idea and a good starting point. More documentation there would be a very welcome addition, and I expect it would provide an interesting introduction to these missing chapters' topics for you.</p>",
        "id": 268606435,
        "sender_full_name": "lqd",
        "timestamp": 1642628006
    },
    {
        "content": "<p>The 2 points Dylan mentions are also great entry points / follow-up ideas, to help keep documentation up to date, make it easier to edit and to write, and more. (Although currently the documentation in the book and the documentation in the actual rules themselves may need to be checked to ensure one isn't missing content from the other: I expect that they would be somewhat separate at the moment.)</p>",
        "id": 268606655,
        "sender_full_name": "lqd",
        "timestamp": 1642628108
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span> <span class=\"user-mention\" data-user-id=\"116113\">@lqd</span>  Thank you for your informations! <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>\n<p>I'd like to pick up the automatic documentation generator first and rewrite it in Rust, which seem straight-forward enough for me to get start.</p>\n<p>Then try writing the missing docs when I have a better understanding of the naive and optimized rules.</p>",
        "id": 268633566,
        "sender_full_name": "Frank King",
        "timestamp": 1642646691
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span>  I have started the work of rewriting the doc generator in Rust at <a href=\"https://github.com/rust-lang-nursery/polonius/issues/184\">polonius#184</a>, and it's a draft yet.</p>",
        "id": 268710524,
        "sender_full_name": "Frank King",
        "timestamp": 1642692993
    },
    {
        "content": "<p>While doing this work, I found the Souffle's version of rules are kind of incompatible with which is described in the Datafrog's version. </p>\n<p>For atoms, all of the paths, loans, and points are defined as <code>unsigned</code> in Souffle. It might be misleading for the rustc's point of view. I thinks these details should be hidden.  </p>\n<p>Perhaps it is better to generate only the analyses part, and leave the atoms written by hand?</p>",
        "id": 268715594,
        "sender_full_name": "Frank King",
        "timestamp": 1642694819
    },
    {
        "content": "<p>(to clarify: both the polonius test runner and rustc use polonius-engine with atoms being u32s basically)</p>",
        "id": 268729485,
        "sender_full_name": "lqd",
        "timestamp": 1642700422
    },
    {
        "content": "<p>Basically I agree with you. But I have two concerns:</p>\n<ol>\n<li>Atoms in Souffle are defined as, <code>.type Path &lt;: unsigned</code>, etc. Some people (from C/C++) know <code>unsigned</code> is <code>u32</code>, but others might not. We might need to explain why it is <code>unsigned</code> but not <code>u32</code> here.</li>\n<li><code>.type Path &lt;: unsigned</code> means <code>Path</code> is a subtype of <code>unsigned</code>. However, in Rust type system, we don't regard <code>struct Path { index: u32 }</code> as a subtype of <code>u32</code>. It's not a big problem, but technically they are different, IMO.</li>\n</ol>\n<p>Hope what I said is not too verbose <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 268839925,
        "sender_full_name": "Frank King",
        "timestamp": 1642770718
    },
    {
        "content": "<p>I wouldn't worry too much about that :) We can document these differences if it would alleviate your concerns. But as you've said before, in the documentation the rules are themselves more important than the relations' declarations, which are bound to be different in different languages, bindings, engines, and so on.</p>",
        "id": 268855706,
        "sender_full_name": "lqd",
        "timestamp": 1642778056
    },
    {
        "content": "<p>I was struggling with the naive rules for a week, and have some questions related to some details of the liveness analysis.</p>\n<ol>\n<li>\n<p>The relation between <code>path_assigned_at</code>, <code>path_accessed_at</code>, <code>path_moved_at</code> and <code>var_used_at</code>, <code>var_dropped_at</code>, <code>var_defined_at</code>. <br>\nMy naive question is: since there are already <code>path_assigned_at</code>, <code>path_accessed_at</code>,  and <code>path_moved_at</code>, we can associate each <code>Path</code> with its corresponding <code>Var</code>, why it is still necessary to input <code>var_used_at</code>, <code>var_dropped</code>, <code>var_defined_at</code>?<br>\nAfter some experiments with dumping MIR and NLL-facts, I found some differences among the <code>Var</code>-related and <code>Path</code>-related input facts. Please correct me if I was wrong.</p>\n<ol>\n<li>\n<p><code>path_assigned_at</code> v.s. <code>var_defined_at</code>:</p>\n<ul>\n<li>In each MIR statement, <code>var_defined_at</code> always take place in <code>Mid</code> of the CFG node; However, <code>path_assigned_at</code> may take place either in the <code>Mid</code> of the CFG node, or the <code>Start</code> of the next CFG node, dependent by whether there is a <code>unwind</code> exit of the current basic block.</li>\n<li><code>var_defined_at</code> also includes <code>StorageLive</code> and <code>StorageDead</code>.</li>\n<li><code>path_assigned_at</code> also includes the initialization of the function arguments at the function's entry point.</li>\n</ul>\n</li>\n<li>\n<p><code>path_accessed_at</code> v.s. <code>var_used_at</code>:</p>\n<ul>\n<li><code>var_used_at</code> includes all of <code>path_accessed_at</code> plus the access of the returned value of the function.</li>\n</ul>\n</li>\n<li>\n<p><code>path_moved_at</code> v.s. <code>var_dropped_at</code>:</p>\n<ul>\n<li><code>path_moved_at</code> only tracks the assignments and moves, but variables will be dropped when they are out of scope. These cannot be inferred from <code>path_moved_at</code>.</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>\n<p>Why do both <code>StorageLive</code> and <code>StorageDead</code> issue a fact <code>var_defined_at</code>?<br>\nI can understand the former, since the variable is only live after <code>StorageLive</code>, but why <code>StorageDead</code>, which seems to destroy the variable instead of defining it?</p>\n</li>\n<li>\n<p>Why should we differentiate <code>var_drop_live_on_entry</code> and <code>drop_of_var_derefs_origin</code> from <code>var_live_on_entry</code> and <code>use_of_var_derefs_origin</code>?<br>\nAFAIK, <code>var_live_on_entry</code> relation tracks from each <code>var_used_at</code> point, along the inverted CFG edges, until where it is defined at <code>var_defined_at</code> point. At all of these points, the <code>Var</code> is regarded <em>live</em> as the relation means.<br>\nFrom the rules, the only difference between <code>var_drop_live_on_entry</code> and <code>var_live_on_entry</code> is the start point. The former starts from the <code>var_used_at</code> point, but the latter starts from the <code>var_dropped_at</code> or the <code>var_maybe_partly_initialized_on_exit</code> point.<br>\nI have two questions related to this:</p>\n<p>1. Why should we consider the <code>var_drop_live_on_entry</code> separately?  It let me think of <a href=\"https://github.com/rust-lang/rfcs/issues/1327\">rfc#1327</a>,  but I'm not sure if it is the reason of the special treat with <code>drop</code>.<br>\n  2. Why <code>var_maybe_partly_initialized_on_exit</code> is also included in <code>var_drop_live_on_entry</code>? From the initialization analysis I know it stores where the variables are partly moved (saying partly initialized), but why should it be taken into account when considering the <code>drop</code> of variables?</p>\n</li>\n</ol>",
        "id": 269922707,
        "sender_full_name": "Frank King",
        "timestamp": 1643535410
    },
    {
        "content": "<ol>\n<li>\n<p>Move/init is field sensitive, so it works on move paths, while the borrow checker is not. You could compute some subset of the <code>var</code> facts from the <code>path</code> ones, but the goal is to make move/init optional, so they would have to remain anyways.<br>\n  1.1.1 This is because functions calls do not initialize their return place if they unwind. Presumably the borrow checker doesn't care about when this happens.<br>\n  1.1.2. ?<br>\n  1.2.3. I'm not quite sure what this is asking. <code>path_moved_at</code> includes drops of the parent variable, since a move and a drop are the same as far as initialization is concerned.</p>\n</li>\n<li>\n<p>Variables cannot be accessed outside the range in which they are storage live. That means it's wasteful to store liveness data outside that range. Killing (\"defined_at\") a variable at <code>StorageLive</code> makes sure that it is not recorded as live in places it is never accessed (liveness flows backwards. Killing a variable at <code>StorageDead</code> isn't really necessary AFAIK, but I think of it as overwriting a variable with garbage/uninit and it doesn't cost anything.</p>\n</li>\n</ol>\n<p>3.1.1 Yes it's because of <a href=\"https://github.com/dropck/rfc/issues/1327\">dropck/rfc#1327</a>. <code>use_of_var_derefs_origin</code> and <code>drop_of_var_derefs_origin</code> may differ for the same variable.<br>\n3.1.2 The MIR still has <code>Drop</code> terminators for variables that are known to be moved out of when they go out of scope. These drops are filtered out manually in the in-tree borrow-checker and in Polonius. I think it's a bit silly to do things this way, and that we should remove them in a preprocessing step (before fact generation). There are other analysis passes that want to ignore these \"frivolous\" drops.</p>",
        "id": 269951260,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1643571111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span>  Thank you very much for your answer, really helpful for me! (I was on vacation last week and just have time to read it carefully)</p>\n<p>Could I summarize as following (based on my understanding)?</p>\n<ol>\n<li>Initialization analysis is field sensitive so it uses path-related facts, but liveliness analysis and loan-analysis are variable sensitive instead of field sensitive, so they prefer variable-related facts.</li>\n<li>Liveliness analysis and loan analysis do not care about whether a function call will <code>panic</code> or not, so there is no need for <code>var_defined_at</code> to differentiate the <code>return</code> and the <code>unwind</code> branch at an MIR assignment. (I think I still need further exploration about why <code>panic</code> does not affect the liveliness of variables.)</li>\n<li><code>StorageLive</code> and <code>StorageDead</code> are the actual places where a variable becomes live or dead. Issuing a <code>var_defined_at</code> at <code>StrorageLive</code> prevents the <code>var_live_on_entry</code> to contain any unnecessary <code>Point</code>s before <code>StorageLive</code>. It seems not necessary to issue a <code>var_defined_at</code> at <code>StorageDead</code> because there is definitely no access after <code>StorageDead</code> and thus no <code>var_live_on_entry</code> will be yielded.</li>\n<li>For objects that borrow from other variables, (take <a href=\"https://github.com/rust-lang/polonius/blob/master/inputs/drop-no-may-dangle/drop-no-may-dangle.rs\">drop-no-may-dangle</a> and <a href=\"https://github.com/rust-lang/polonius/blob/master/inputs/drop-may-dangle/drop-may-dangle.rs\">drop-may-dangle</a> for example), the <code>drop_of_var_derefs_origin</code> makes sure it is \"live\" until dropped, even after the last access of the referee. But because of <a href=\"https://github.com/rust-lang/rfcs/issues/1327\">rfc#1327</a>, <code>#[may_dangle]</code> can prevent issuing <code>drop_of_var_derefs_origin</code> of certain types while dropping, thus <code>use_of_var_derefs_origin</code> and <code>drop_of_var_derefs_origin</code> may differ for the same variable.</li>\n<li>The MIR always has a <code>drop</code> statement at the variables exiting their scopes, even if some variables are known to be moved out. In Polonius these drops are filtered out. But for partly-moved variables, they are drop-live since part of their fields are moved out, and there are no such <code>var_dropped_at</code> facts issued. Therefore, <code>var_maybe_partly_initialized_on_exit</code> are needed to include this situation.</li>\n</ol>",
        "id": 270891177,
        "sender_full_name": "Frank King",
        "timestamp": 1644155701
    },
    {
        "content": "<p>Regarding (2), it's not correct to say that they don't care about whether a function will <code>panic</code> or not. It's that they don't care about whether the <em>return place for that function is initialized when it panics</em>. Presumably this is because we ensure during MIR building that the return place is uninitialized, so it will either never be accessed or will be killed again at some predecessor where it is moved from and not accessed in-between.</p>",
        "id": 270920360,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1644193673
    },
    {
        "content": "<p>As you can tell, I'm a little fuzzy on this myself. The rest is correct as far as I know.</p>",
        "id": 270920404,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1644193696
    },
    {
        "content": "<p>Could this explain (partially) why liveness analysis and loan analysis don't care whether the return place for a function is initialized when it panics?</p>\n<p>From the MIR's point of view, when a statement (e.g. <code>_3 = may_panic() [return -&gt; bb1; unwind -&gt; bb2]</code>) panics, it goes to <code>bb2</code> and drops the initialized values (<code>_3</code> is regarded as uninitialized according to the <code>path_assigned_at</code> facts).  Even when <code>may_panic()</code> panics, there is presumably no more accesses of <code>_3</code> on the unwinding branch (i.e. no <code>var_used_at</code> will be issued), so no <code>var_live_on_entry</code>s will be issued either, and thus it doesn't matter where a <code>var_defined_at</code> is issued.</p>\n<p>However, I'm not sure how it will affect the <code>var_drop_live_on_entry</code> facts. <code>_3</code> might be dropped (i.e. <code>var_dropped_at</code> or <code>var_maybe_partly_initialized</code> might exist) along <code>bb2</code>, the unwinding branch. I need to do more experiments to verify this.</p>",
        "id": 270930345,
        "sender_full_name": "Frank King",
        "timestamp": 1644206879
    },
    {
        "content": "<p>Hey folks! I opened the issue 181 on polonius (<a href=\"https://github.com/rust-lang/polonius/issues/181\">https://github.com/rust-lang/polonius/issues/181</a>). It's about a crate that is virtually impossible to compile with the current polonius because it explodes in space and time as well. The other day I got an idea, probably stupid - since I have zero knowledge about how polonius actually works - but here it is: would it be possible to enable polonius just on some specific functions (with a built-in macro, probably)? That way most of the time rustc's current borrow checker could do its job and polonius could help out on some corner cases.</p>",
        "id": 272851238,
        "sender_full_name": "Allegretto",
        "timestamp": 1645556592
    },
    {
        "content": "<p>hello :) </p>\n<p>this idea has been brought up before, is interesting, but of course we'd prefer not people have to do that, and that things just work out of the box without explosions of any kind. </p>\n<p>The cases where this happens are known, at least most of them, we believe, but this hasn't been a focus of investigation yet: we had been trying to focus first on correctness, having a good set of rules that allow more expressiveness, limit false positives, etc. </p>\n<p>When that happens we plan on looking at performance, where these issues occur. We generally know how to fix some of these exploding cases: it's not exactly easy in all cases, and what we've lacked is mostly time to tackle them. There are in-progress refactors that could help, reverting some work that caused some of these issues (as we're not fully taking advantage of features they added just yet) as a bunch of those didn't happen previously, for example.</p>",
        "id": 272862388,
        "sender_full_name": "lqd",
        "timestamp": 1645561918
    },
    {
        "content": "<p>I have read the naive and the opt rules, but found it kind of difficult to fully understand every details of the opt rules (I could only simply think that it is in order to reduce the unnecessary subset propagation). So I'm afraid I'm not able to write docs for opt rules yet now.</p>\n<p>But I found <a href=\"https://github.com/rust-lang-nursery/polonius/issues/26\">polonius#26</a> and <a href=\"https://github.com/rust-lang-nursery/polonius/issues/61\">polonius#61</a> the open issues about the front end implementation. Are there something remained to do yet (since the issues are still open)?</p>\n<p>Maybe doing some tests with this front end could help me to understand how the opt rules work. (I sometimes find it difficult to read the the facts generated by rustc).</p>",
        "id": 272948816,
        "sender_full_name": "Frank King",
        "timestamp": 1645623404
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang-nursery/polonius/issues/61\">polonius#61</a> mentioned <code>region_lived_at</code>, but I didn't found it in <code>AllFacts</code>. I think it is replaced with <code>origin_live_on_entry</code>, which is computed by the liveness analysis, right?</p>",
        "id": 272952359,
        "sender_full_name": "Frank King",
        "timestamp": 1645625031
    },
    {
        "content": "<p>absolutely, the <code>region_live_at</code> relation was removed <a href=\"https://github.com/rust-lang/polonius/commit/54628a3c4ddd4f25f871133003fa73870f36fdb4\">in this commit</a> from the input facts, becoming an output of the liveness computation <a href=\"https://github.com/rust-lang/polonius/commit/bebcde34a867761f43a5e85361ba15dc8292bcd6\">in this commit</a>, and ultimately renamed <code>origin_live_on_entry</code> <a href=\"https://github.com/rust-lang/polonius/commit/804452d6300c54f3a7448d2d188b297311c0eb56\">in this commit</a>.</p>\n<p>what was missing at the time were ways to provide inputs to these early computations (move/init, and liveness) to be able to test them independently, in-repo, without absolutely requiring the rustc UI tests.</p>\n<p>and this is clearer (but it's pretty bare and has not much more than what I said) in <a href=\"https://github.com/rust-lang/polonius/issues/138\">this issue</a> which partially subsumes others.</p>\n<p>niko had a hackmd wishlist for frontend features (but can't find it rn, I'll look harder later), that was also a mix between new features, their old testing abilities <a href=\"https://github.com/nikomatsakis/borrowck\">https://github.com/nikomatsakis/borrowck</a>, the current ones, and arguably the ones in <a href=\"https://github.com/nikomatsakis/polonius.next\">https://github.com/nikomatsakis/polonius.next</a></p>\n<p>even though move/init and liveness are currently computed, there's the possibility that rustc could still keep computing them in some cases. at the very least until more bugs and issues are solved (both for correctness and performance concerns), so it'd still be super valuable to have better testing of these two analyses. in particular it'd help narrow down some of the known move/init correctness issues</p>",
        "id": 273951666,
        "sender_full_name": "lqd",
        "timestamp": 1646302953
    }
]