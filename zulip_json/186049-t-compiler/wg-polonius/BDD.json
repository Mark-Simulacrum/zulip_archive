[
    {
        "content": "<p>Currently polonius suffer from:</p>\n<ol>\n<li>Huge memory print</li>\n<li>Slow in some cases</li>\n</ol>\n<p>I accidently notice binary decision diagram helps solve them.<br>\nAFAIK, no discussion about bdd and polonius before.<br>\nI pick bddbddb, a java program.<br>\nI feed the nll-facts and polonius rules into bddbddb, it solves them automatically.<br>\n<a href=\"https://github.com/lengyijun/nll2bdd\">https://github.com/lengyijun/nll2bdd</a></p>\n<p>Test on naive algorithm:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>datafrog</th>\n<th>bddbddb</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>issue-29466.rs </code></td>\n<td>&gt;30min</td>\n<td>60s</td>\n</tr>\n<tr>\n<td><code>issue-29540.rs </code></td>\n<td>?</td>\n<td>?</td>\n</tr>\n<tr>\n<td><code>issue-74564-if-expr-stack-overflow.rs</code></td>\n<td>&gt;1h</td>\n<td>&gt;1h</td>\n</tr>\n<tr>\n<td>clap</td>\n<td>?</td>\n<td>1h</td>\n</tr>\n</tbody>\n</table>\n<h1>Why bddbddb works well with polonius</h1>\n<p>Redundant relation in point, which can be compressed by bdd.</p>\n<h1>How to make bddbddb work even faster on polonius?</h1>\n<ol>\n<li>parallel</li>\n<li>\n<p>the variable order(NP problem), relation order<br>\nA lot of experiments</p>\n</li>\n<li>\n<p>some features in bddbddb: relation split </p>\n</li>\n</ol>\n<h1>Future work</h1>\n<ol>\n<li>fix <code>issue-74564-if-expr-stack-overflow.rs </code></li>\n<li>Test on other algorithm</li>\n<li>Rewrite bddbddb in Rust</li>\n</ol>\n<h2>Reference:</h2>\n<p>bddbddb: <a href=\"http://bddbddb.sourceforge.net/\">http://bddbddb.sourceforge.net/</a></p>",
        "id": 248982046,
        "sender_full_name": "lengyijun",
        "timestamp": 1628603808
    },
    {
        "content": "<p>cool! we did mention BDD in the context of NLLs to have a more compressed representation back then</p>",
        "id": 248984254,
        "sender_full_name": "lqd",
        "timestamp": 1628604681
    },
    {
        "content": "<p>(though to be clear the current state of things is far from production ready, both in cpu time or memory usage. what consequences making it so will that have in the future is currently unclear)</p>",
        "id": 248984411,
        "sender_full_name": "lqd",
        "timestamp": 1628604758
    },
    {
        "content": "<p>the naive algorithm isn't particularly representative either, as its name suggest. the more realistic (with the caveat about production-readiness) variant is the hybrid variant: it starts with a quick location-insensitive pre-pass to locate potential errors to be validated later by the datafrogopt variant (a more optimized version than the naive rules), only if necessary</p>",
        "id": 248984770,
        "sender_full_name": "lqd",
        "timestamp": 1628604912
    },
    {
        "content": "<p>but if you want the datafrog stats on clap (which I assume is the single function whose facts are in the repo, and not the actual clap crate), naive takes around 9s and opt around 4</p>",
        "id": 248984958,
        "sender_full_name": "lqd",
        "timestamp": 1628604988
    },
    {
        "content": "<p>and to illustrate my point above, clap passes the location-insensitive pre-pass filter in 20ms or so</p>",
        "id": 248985089,
        "sender_full_name": "lqd",
        "timestamp": 1628605040
    },
    {
        "content": "<p>(so there is no need to run the other variants taking 4 to 9 seconds)</p>",
        "id": 248985179,
        "sender_full_name": "lqd",
        "timestamp": 1628605083
    },
    {
        "content": "<p>the timings above are for the actual pass, that doesn't count all the setup before: rustc including fact generation, move/init, liveness, etc</p>",
        "id": 248985343,
        "sender_full_name": "lqd",
        "timestamp": 1628605159
    },
    {
        "content": "<p>I'm surprised but the 30 mins for issue-29466, as I don't remember seeing that while testing my recent PR. I may have missed that.</p>",
        "id": 248985690,
        "sender_full_name": "lqd",
        "timestamp": 1628605298
    },
    {
        "content": "<blockquote>\n<p>I'm surprised but the 30 mins for issue-29466, as I don't remember seeing that while testing my recent PR. I may have missed that.</p>\n</blockquote>\n<p><code>polonius -a naive --show-tuples -v /path/to/nll-facts</code><br>\n30min includes move,init,liveness.</p>",
        "id": 248985933,
        "sender_full_name": "lengyijun",
        "timestamp": 1628605405
    },
    {
        "content": "<p>(but a lot of the slowness I noticed then in the UI tests was related to the impact of the Location:All issue -- which needs fixing, and is somewhat in-progress -- and move/init and liveness)</p>",
        "id": 248986023,
        "sender_full_name": "lqd",
        "timestamp": 1628605443
    },
    {
        "content": "<p>yeah it's nice to have these as reference implementations and documentation etc but it seems unlikely they'll be used as-is for actual production (not to mention rustc already does them, and they're way more efficient)</p>",
        "id": 248986430,
        "sender_full_name": "lqd",
        "timestamp": 1628605587
    },
    {
        "content": "<p>mostly: until our rules are fully decided (something to which I believe we are very close, modulo the HRTB/universe ones) and we achieve our correctness goal, we have deliberately tried to avoid performance work (but we can't really help it sometimes :)</p>",
        "id": 248986819,
        "sender_full_name": "lqd",
        "timestamp": 1628605740
    },
    {
        "content": "<p><a href=\"http://issue-29466.rs\">issue-29466.rs</a> takes 1 minute for me, most of it in initialization analysis, and it passes the location insensitive pre-pass in 2ms:</p>\n<div class=\"codehilite\"><pre><span></span><code>INFO polonius_engine::output::initialization - initialization phase 1 completed: 110.7Âµs\nINFO polonius_engine::output::initialization - initialization phase 2: 0 move errors in 90.400914s\nINFO polonius_engine::output::liveness - compute_live_origins() completed: 184 tuples, 3.4076469s\nINFO polonius_engine::output::location_insensitive - analysis done: 0 `potential_errors` tuples, 0 `potential_subset_errors` tuples, 1.7539ms\n</code></pre></div>\n<p>Similarly, <code>Naive</code> takes 50ms: </p>\n<div class=\"codehilite\"><pre><span></span><code>INFO polonius_engine::output::naive - analysis done: 0 `errors` tuples, 0 `subset_errors` tuples, 50.2949ms\n</code></pre></div>\n<p>Unless there are some deep issues with either of our facts, and we're not measuring the same things, this is surprising.</p>\n<p><span class=\"user-mention\" data-user-id=\"389101\">@lengyijun</span> I'd like to reproduce your results, can you share how you gathered the stats above and how you are launching the executable ?</p>",
        "id": 248988872,
        "sender_full_name": "lqd",
        "timestamp": 1628606676
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>~/rust-polonius/build/x86_64-unknown-linux-gnu/stage1/bin/rustc -Znll-facts ~/rust-polonius/src/test/ui/issues/issue-29466.rs\ncd nll-facts/main\nexport PATH=$PATH:~/polonius/target/release\npolonius -a naive  -v . &gt; log\n</code></pre></div>",
        "id": 248989870,
        "sender_full_name": "lengyijun",
        "timestamp": 1628607207
    },
    {
        "content": "<p>the <code>-v</code> triggers verbose mode which copies a lot of intermediate data for debugging purposes</p>",
        "id": 248990062,
        "sender_full_name": "lqd",
        "timestamp": 1628607308
    },
    {
        "content": "<p>(and if you have built your own rustc just to emit the facts, you could use <code>-Zpolonius</code> to compile that test and make your life easier: it'll avoid writing and reading the facts from disk)</p>",
        "id": 248991282,
        "sender_full_name": "lqd",
        "timestamp": 1628607814
    }
]