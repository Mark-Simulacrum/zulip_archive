[
    {
        "content": "<p>Hey team. I'm using the recently added <a href=\"https://github.com/rust-lang/rust/pull/86977#issuecomment-902129360\"><code>get_body_with_borrowck_facts</code></a> to extract outlives-constraints for my <a href=\"https://github.com/willcrichton/flowistry\">program slicer</a>. However, this is causing serious performance issues.</p>\n<p>To run <code>get_body_with_borrowck_facts</code>, I have to enable <code>-Z polonius</code>. This, I assume, replaces the standard borrow checker with polonius in all cases, even though I only need polonius for a small set of functions of interest. The issue is that Polonius is <em>slow</em>. For example, if I run <code>cargo check</code> on <a href=\"https://github.com/rg3dengine/rg3d\">rg3d</a>, this takes 3sec on the main crate. If I run with <code>-Z polonius</code>, this takes <strong>30sec</strong>! So my plugin has to wait 30sec before even starting to compute / return an answer to the user.</p>\n<p>Do y'all have any recommendations for how to address this? Barring Polonius getting substantially faster, is there a way for me to call Polonius without having it be the default borrow checker?</p>",
        "id": 251301631,
        "sender_full_name": "Will Crichton",
        "timestamp": 1630360852
    },
    {
        "content": "<p>There is currently no way to have facts and call polonius without it being the default borrow checker.</p>",
        "id": 251335857,
        "sender_full_name": "lqd",
        "timestamp": 1630389459
    },
    {
        "content": "<p>What is likely slow though is the move/init analysis, so there’s an experiment you could do if you have a locally compiled rustc</p>",
        "id": 251335944,
        "sender_full_name": "lqd",
        "timestamp": 1630389521
    },
    {
        "content": "<p>Add an override to rustc Cargo.toml to use a local polonius. There, inhibit the move errors computation by commenting <a href=\"https://github.com/rust-lang/polonius/blob/0cbbb7c6b2f9dd713266b77c0c13903ac16e1679/polonius-engine/src/output/initialization.rs#L229\">https://github.com/rust-lang/polonius/blob/0cbbb7c6b2f9dd713266b77c0c13903ac16e1679/polonius-engine/src/output/initialization.rs#L229</a> and the rules that compute this relation</p>",
        "id": 251336244,
        "sender_full_name": "lqd",
        "timestamp": 1630389737
    },
    {
        "content": "<p>(The var_maybe_partly_initialized_on_exit relation is used in the following steps so don’t comment this one out) if you run tests only the ones dealing with move errors should fail then</p>",
        "id": 251336364,
        "sender_full_name": "lqd",
        "timestamp": 1630389844
    },
    {
        "content": "<p>In some cases this is enough to have acceptable speeds, like on the in-tree benchmarks. But sometimes it isn’t enough, and if that’s the case then it’s going to be a bit harder (with more modifications in rustc to avoid this analysis altogether, or a way for polonius to use rustc’s dataflow framework) or wait until we do it</p>",
        "id": 251336779,
        "sender_full_name": "lqd",
        "timestamp": 1630390135
    },
    {
        "content": "<p>It would be interesting to see which functions in that crate are slow, and which parts of the polonius pipeline are slow on these functions</p>",
        "id": 251336900,
        "sender_full_name": "lqd",
        "timestamp": 1630390240
    },
    {
        "content": "<p>Especially as it could also be generating the facts themselves that is slow on e.g. big functions, or another of the pipeline steps, rather than move/init analysis.</p>",
        "id": 251337005,
        "sender_full_name": "lqd",
        "timestamp": 1630390325
    },
    {
        "content": "<p>Ok re: the concerns here. I did some perf analysis of polonius but saw nothing obvious I could help with (barring a deep dive into datafrog internals that I know nothing about).</p>\n<p>Would there be any objections to just changing the policy so <code>body_with_borrowck_facts</code> can be used even if <code>-Z polonius</code> is not enabled? Here's what that would look like: <a href=\"https://github.com/rust-lang/rust/compare/master...willcrichton:allow-single-polonius-call?expand=1\">https://github.com/rust-lang/rust/compare/master...willcrichton:allow-single-polonius-call?expand=1</a></p>",
        "id": 253336333,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631660064
    },
    {
        "content": "<p>did you also try what I suggested above ? that would be interesting information for us to have</p>",
        "id": 253374538,
        "sender_full_name": "lqd",
        "timestamp": 1631691601
    },
    {
        "content": "<p>in general, it'd be nice to avoid expanding this unstable API too much, as our hopes/plans are to eventually change all these internal details, but at the same time it doesn't really hurt for <code>body_with_borrowck_facts</code> to have this kind of control</p>",
        "id": 253374933,
        "sender_full_name": "lqd",
        "timestamp": 1631691850
    },
    {
        "content": "<p>I tried compiling against a local polonius, but I get this error:</p>\n<div class=\"codehilite\"><pre><span></span><code>   Compiling rustc_borrowck v0.0.0 (/raid/wcrichto/rust.slicer/compiler/rustc_borrowck)\nerror[E0277]: the trait bound `rustc_middle::ty::RegionVid: Atom` is not satisfied\n   --&gt; compiler/rustc_borrowck/src/facts.rs:19:5\n    |\n19  |     type Origin = RegionVid;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Atom` is not implemented for `rustc_middle::ty::RegionVid`\n    |\nnote: required by a bound in `polonius_engine::FactTypes::Origin`\n   --&gt; /raid/wcrichto/polonius/polonius-engine/src/facts.rs:124:18\n    |\n124 |     type Origin: Atom;\n    |                  ^^^^ required by this bound in `polonius_engine::FactTypes::Origin`\n</code></pre></div>\n<p>I got this with both polonius master and the polonius-engine-v0.13.0 branch. Any suggestions?</p>",
        "id": 253454694,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631726777
    },
    {
        "content": "<p>All  index types (<code>BorrowIndex</code>, <code>Local</code>, etc.) should have <code>Atom</code> impls, which is just Polonius' version of an <code>Index</code> trait. Not sure how that one got lost though? Maybe the <code>rustc_mir</code> split?</p>",
        "id": 253455156,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1631726990
    },
    {
        "content": "<p>ah it may be because a lot of crates were changed recently</p>",
        "id": 253455163,
        "sender_full_name": "lqd",
        "timestamp": 1631726995
    },
    {
        "content": "<p>(the split being <a href=\"https://github.com/rust-lang/rust/pull/80522\">https://github.com/rust-lang/rust/pull/80522</a>)</p>",
        "id": 253455616,
        "sender_full_name": "lqd",
        "timestamp": 1631727172
    },
    {
        "content": "<p>maybe some stale incremental state ? as you can see <code>RegionVid</code> does implement <code>Atom</code> <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.RegionVid.html#impl-Atom\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.RegionVid.html#impl-Atom</a></p>",
        "id": 253455933,
        "sender_full_name": "lqd",
        "timestamp": 1631727309
    },
    {
        "content": "<p>Oh I see, I only patched <code>rustc_borrowck</code> but not other crates that depended on <code>polonius-engine</code>, so it was a version mismatch error. Should work now, I'll report back.</p>",
        "id": 253456857,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631727664
    },
    {
        "content": "<p>Also, I filed a PR for my proposed change: <a href=\"https://github.com/rust-lang/rust/pull/88983\">https://github.com/rust-lang/rust/pull/88983</a></p>",
        "id": 253456942,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631727695
    },
    {
        "content": "<p>though if you're only using the outlives constraints in your tool, it doesn't seem like you'd be interested in calling polonius at all ?</p>",
        "id": 253460416,
        "sender_full_name": "lqd",
        "timestamp": 1631728902
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"265377\">Will Crichton</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20performance.20in.20a.20rustc.20plugin/near/253456857\">said</a>:</p>\n<blockquote>\n<p>I only patched <code>rustc_borrowck</code> but not other crates that depended on <code>polonius-engine</code></p>\n</blockquote>\n<p>IIRC you don't need to patch all crates using <code>polonius-engine</code> to point to your local fork but only add a <a href=\"http://crates.io\">crates.io</a> override to the root Cargo.toml</p>",
        "id": 253460729,
        "sender_full_name": "lqd",
        "timestamp": 1631729026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20performance.20in.20a.20rustc.20plugin/near/253460416\">said</a>:</p>\n<blockquote>\n<p>though if you're only using the outlives constraints in your tool, it doesn't seem like you'd be interested in calling polonius at all ?</p>\n</blockquote>\n<p>(especially since you mentioned it was slow for your use case, calling it to compute analyses you don't need seems unfortunate)</p>",
        "id": 253462200,
        "sender_full_name": "lqd",
        "timestamp": 1631729608
    },
    {
        "content": "<p>highfive is defo sleeping on the job tho</p>",
        "id": 253463518,
        "sender_full_name": "lqd",
        "timestamp": 1631730147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20performance.20in.20a.20rustc.20plugin/near/253460416\">said</a>:</p>\n<blockquote>\n<p>though if you're only using the outlives constraints in your tool, it doesn't seem like you'd be interested in calling polonius at all ?</p>\n</blockquote>\n<p>So generally, I'm interested in computing the points-to set for lifetimes. My initial implementation used the outlives-constraints graph (specifically the <code>ConstraintSccGraph</code> generated during <code>mir_borrowck</code>), on which I did a simple flow-insensitive algorithm. Something like: <code>&amp;'n place =&gt; place \\in points-to('n)</code> and <code>'a :&gt; 'b =&gt; points-to('b) \\subseteq points-to('a)</code>.</p>\n<p>If Polonius is computing a similar kind of points-to set, then I would just use that directly.</p>",
        "id": 253463671,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631730222
    },
    {
        "content": "<p>I suspect that <code>origin_contains_loan_at</code>, or maybe <code>origin_contains_loan_anywhere</code>, or <code>known_contains</code> all might be related to what I want?</p>",
        "id": 253464017,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631730369
    },
    {
        "content": "<p>related yes, maybe not in a straigthforward way to get back to the spans you probably need in you slices but yeah</p>",
        "id": 253464517,
        "sender_full_name": "lqd",
        "timestamp": 1631730589
    },
    {
        "content": "<p>That's ok, I just need MIR places. I do all the span computations separately. Are these fields documented anywhere?</p>",
        "id": 253464823,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631730690
    },
    {
        "content": "<p>ok I think I understand, you may now want to change your initial approach if polonius helped you achieve your goal, and the PR above was more specifically that you'd want to say interactively slice parts of a function at a time, while -Z polonius applies to the whole crate/dependency tree ?</p>",
        "id": 253464862,
        "sender_full_name": "lqd",
        "timestamp": 1631730702
    },
    {
        "content": "<p>the last relation is an input and is documented in the facts</p>",
        "id": 253465103,
        "sender_full_name": "lqd",
        "timestamp": 1631730792
    },
    {
        "content": "<p>while the other two are one of the results of the loan analyses (naive/opt, and location insensitive, respectively)</p>",
        "id": 253465267,
        "sender_full_name": "lqd",
        "timestamp": 1631730857
    },
    {
        "content": "<p>Generally, I still only want to slice one function at a time, so the PR is still relevant. I'm building a VSCode extension that you would interactively call as you develop in a Rust workspace. This requires running essentially <code>rustc --profile check</code> on the current crate. I need that step to be as fast as possible, and _then_ I call into Polonius for the specific function I'm slicing.</p>",
        "id": 253465428,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631730932
    },
    {
        "content": "<p>understood (I hope). to be clear I meant that if you still only used the SCCs to do your slicing then polonius wouldn't be useful to you, but I seem to understand you're now kind of prototyping whether it would actually be useful compared to your previous approach, and that is still TBD</p>",
        "id": 253465876,
        "sender_full_name": "lqd",
        "timestamp": 1631731122
    },
    {
        "content": "<p>the PR above making your prototyping/evaluation at the very least possible or less painful</p>",
        "id": 253465952,
        "sender_full_name": "lqd",
        "timestamp": 1631731161
    },
    {
        "content": "<p>Btw I'm running into an issue where the <code>Output</code> from <code>body_with_borrowck_facts</code> is empty -- any obvious reason why that might happen? The input facts are populated, but output facts are not.</p>",
        "id": 253479339,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631736520
    },
    {
        "content": "<p>are all output relations empty ?</p>",
        "id": 253479416,
        "sender_full_name": "lqd",
        "timestamp": 1631736552
    },
    {
        "content": "<p>Yes</p>",
        "id": 253479589,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631736608
    },
    {
        "content": "<p>as a sanity check, could you try polonius on the same inputs ?</p>",
        "id": 253479764,
        "sender_full_name": "lqd",
        "timestamp": 1631736689
    },
    {
        "content": "<p>(the binary, not via rustc)</p>",
        "id": 253479800,
        "sender_full_name": "lqd",
        "timestamp": 1631736701
    },
    {
        "content": "<p>is there a document for how to do that? like i assume i need to dump the facts then pass them to the polonius binary</p>",
        "id": 253480028,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631736781
    },
    {
        "content": "<p>the readme does explain it yes <a href=\"https://github.com/rust-lang/polonius\">https://github.com/rust-lang/polonius</a></p>",
        "id": 253480115,
        "sender_full_name": "lqd",
        "timestamp": 1631736820
    },
    {
        "content": "<p>but basically, you <code>-Znll-facts</code> to get the facts (probably with<code>-Zborrowck=mir</code> as well, in case full NLLs are not enabled) and run polonius on that</p>",
        "id": 253480238,
        "sender_full_name": "lqd",
        "timestamp": 1631736860
    },
    {
        "content": "<p>oh actually it seems like output is generally only populated if <code>dump_enabled</code> is true, and right now it's set to false</p>",
        "id": 253480638,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631737006
    },
    {
        "content": "<p>that's why I asked if all relations were empty</p>",
        "id": 253480788,
        "sender_full_name": "lqd",
        "timestamp": 1631737056
    },
    {
        "content": "<p>only some of them require <code>dump_enabled</code> to be filled</p>",
        "id": 253480839,
        "sender_full_name": "lqd",
        "timestamp": 1631737080
    },
    {
        "content": "<p>ah so maybe that's not it then</p>",
        "id": 253480892,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631737089
    },
    {
        "content": "<p>as they're mostly used for debugging purposes</p>",
        "id": 253480913,
        "sender_full_name": "lqd",
        "timestamp": 1631737098
    },
    {
        "content": "<p>which relation would be non-empty for a valid program?</p>",
        "id": 253480963,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631737119
    },
    {
        "content": "<p>let's try it instead with an invalid program and check for errors :3</p>",
        "id": 253481016,
        "sender_full_name": "lqd",
        "timestamp": 1631737144
    },
    {
        "content": "<p>our goal is to emit errors so it may not be set up right for the opposite use case heh</p>",
        "id": 253481185,
        "sender_full_name": "lqd",
        "timestamp": 1631737210
    },
    {
        "content": "<p>ok after setting dump enabled to true and recompiling i'm getting the output i expected</p>",
        "id": 253482633,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631737886
    },
    {
        "content": "<p>...i suppose i should file another PR that sets <code>dump_enabled</code> to true only when <code>body_with_borrowck_facts</code> is called, since that's the only time the extra info would be relevant</p>",
        "id": 253482688,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631737920
    },
    {
        "content": "<p>maybe check with <span class=\"user-mention\" data-user-id=\"116109\">@Vytautas Astrauskas [he/him]</span> if that's also a use-case they have</p>",
        "id": 253482900,
        "sender_full_name": "lqd",
        "timestamp": 1631738001
    },
    {
        "content": "<p>it may be the case that they wouldn't need/want that, in case it also hurts performance to add too much debug output, say</p>",
        "id": 253483091,
        "sender_full_name": "lqd",
        "timestamp": 1631738045
    },
    {
        "content": "<p>right, maybe what would make more sense is gathering <code>AllFacts</code> from the call, and then implementing my analysis in polonius</p>",
        "id": 253483714,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631738245
    },
    {
        "content": "<p>but if you're still in the prototyping phase, maybe have <code>dump_enabled</code> always true locally, so that you're not blocked by it, and then when you know whether it's a viable option for you, you can open PRs in coordination with him so that both your use-cases are taken care of ?</p>",
        "id": 253483783,
        "sender_full_name": "lqd",
        "timestamp": 1631738275
    },
    {
        "content": "<p>yeah, although since my tool is user-facing it's important to have nightly compatibility if I want people to test it out</p>",
        "id": 253483894,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631738302
    },
    {
        "content": "<p>so i'm trying hard to not fork rustc</p>",
        "id": 253483909,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631738308
    },
    {
        "content": "<p>sure, understandable</p>",
        "id": 253483966,
        "sender_full_name": "lqd",
        "timestamp": 1631738331
    },
    {
        "content": "<p>but yes i'll coordinate with vytautas</p>",
        "id": 253483967,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631738331
    },
    {
        "content": "<p>great :)</p>",
        "id": 253484252,
        "sender_full_name": "lqd",
        "timestamp": 1631738455
    },
    {
        "content": "<p>thank you for all the help <span class=\"user-mention\" data-user-id=\"116113\">@lqd</span> !</p>",
        "id": 253484281,
        "sender_full_name": "Will Crichton",
        "timestamp": 1631738469
    },
    {
        "content": "<p>I think they mentioned the relation they were interested in the PR introducing this mechanism, let me look it up</p>",
        "id": 253484331,
        "sender_full_name": "lqd",
        "timestamp": 1631738495
    },
    {
        "content": "<p>sure, no problem, happy to help</p>",
        "id": 253484340,
        "sender_full_name": "lqd",
        "timestamp": 1631738501
    },
    {
        "content": "<p>(it may have been here <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20Hackathon.202021-07-30/near/247716245\">https://rust-lang.zulipchat.com/#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20Hackathon.202021-07-30/near/247716245</a> — they'll tell us eventually :)</p>",
        "id": 253484969,
        "sender_full_name": "lqd",
        "timestamp": 1631738771
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20performance.20in.20a.20rustc.20plugin/near/253482900\">said</a>:</p>\n<blockquote>\n<p>maybe check with <span class=\"user-mention silent\" data-user-id=\"116109\">Vytautas Astrauskas [he/him]</span> if that's also a use-case they have</p>\n</blockquote>\n<p>Sounds like our use case. (I am currently a bit buried. I will check later.)</p>",
        "id": 253489711,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1631740773
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"265377\">Will Crichton</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20performance.20in.20a.20rustc.20plugin/near/253480638\">said</a>:</p>\n<blockquote>\n<p>oh actually it seems like output is generally only populated if <code>dump_enabled</code> is true, and right now it's set to false</p>\n</blockquote>\n<p>In Prusti, we are currently not using the Polonius output facts from the compiler. We call Polonius ourselves with <code>dump_enabled</code>.</p>",
        "id": 253846670,
        "sender_full_name": "Vytautas Astrauskas [he/him]",
        "timestamp": 1631948925
    },
    {
        "content": "<p>I thought <code>get_body_with_borrowck_facts</code> called polonius ?</p>",
        "id": 253892062,
        "sender_full_name": "lqd",
        "timestamp": 1631997200
    },
    {
        "content": "<p>(but just getting the input facts and calling it directly could also be an interesting alternative I presume, so that the variant, <code>dump_enabled</code>, etc can be more easily controlled by the caller without complicating rustc's API)</p>",
        "id": 253892154,
        "sender_full_name": "lqd",
        "timestamp": 1631997325
    },
    {
        "content": "<p>(this was the comment from Vytautas I couldn't find, and to which I was referring earlier, about the facts that prusti was interested in <a href=\"https://github.com/rust-lang/datafrog/pull/40#issuecomment-904902526\">https://github.com/rust-lang/datafrog/pull/40#issuecomment-904902526</a> it was in the datafrog repository)</p>",
        "id": 254721572,
        "sender_full_name": "lqd",
        "timestamp": 1632496939
    },
    {
        "content": "<p>btw just to bump this, polonius is still the <a href=\"https://github.com/rust-lang/rust/issues/1\">#1</a> bottleneck in my plugin... i'm seeing times up to 2 minutes to analyze a single (large) function. if anyone is working on polonius performance, I would be happy to work with you / contribute to making things faster, although idk where to start</p>",
        "id": 261833667,
        "sender_full_name": "Will Crichton",
        "timestamp": 1637176557
    },
    {
        "content": "<p>I remember asking before about your timings but don’t remember details: which parts of the pipeline are slow, fact gen, move/init, liveness, loan analysis, all of them ? What numbers are you seeing for each of these parts ?</p>\n<p>I think we mentioned a workaround last time if the slowness was in computing move errors: they can be manually commented out, while making sure the other relation is still computed for liveness; but that’s unlikely to be super helpful in other situations than during development.</p>\n<p>if it’s the 2 first two analyses that take a while, then there is a simple but controversial fix: removing move/init analysis and liveness computation — or being able to bypass them, say (eg with a different flag value) that’s likely less controversial — and go back to using rustc computed liveness. One could imagine adding the liveness relation back in rustc, and in polonius jumping straight to loan analysis if the relation is filled.</p>",
        "id": 261836845,
        "sender_full_name": "lqd",
        "timestamp": 1637178038
    },
    {
        "content": "<p>(I don't know about controversial, it seems like an option we should provide at least)</p>",
        "id": 261842613,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1637180331
    },
    {
        "content": "<p>I also think we probably should, we'll know more on how pressing it is when we see Will's numbers. Until we finalize the rules, ensure they're correct and expressive enough, etc, working on performance (although fun) may be a bit premature but at least this should help fix this issue here, and be relatively easy to do (so it wouldn't be a whole bunch of wasted work if we later change the rules)</p>",
        "id": 261860900,
        "sender_full_name": "lqd",
        "timestamp": 1637188607
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116113\">lqd</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Polonius.20performance.20in.20a.20rustc.20plugin/near/261836845\">said</a>:</p>\n<blockquote>\n<p>I remember asking before about your timings but don’t remember details: which parts of the pipeline are slow, fact gen, move/init, liveness, loan analysis, all of them ? What numbers are you seeing for each of these parts ?</p>\n</blockquote>\n<p>Happy to run a benchmark, but is there an easy way to profile polonius and distinguish parts of the pipeline without modifying the compiler?</p>",
        "id": 261879477,
        "sender_full_name": "Will Crichton",
        "timestamp": 1637203286
    },
    {
        "content": "<p>yes, very easily (in addition to regular profiling tools): </p>\n<ul>\n<li>fact generation (and the global polonius analysis) already have dedicated events in rustc's self-profiler, so just trying out <a href=\"https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html\">https://blog.rust-lang.org/inside-rust/2020/02/25/intro-rustc-self-profile.html</a> on your function will give numbers for that (depending on the function, and some very specific patterns, this can be big and slow sometimes -- As a reference for others reading this, this is where <code>Locations::All</code> comes in, in addition to the huge, often generated, CFGs with tens of thousands of lifetimes we see in benchmarks)</li>\n<li>the \"polonius-engine\" (the crate rustc uses) can be run out of tree, the repo contains a polonius binary, which loads facts via files on disk (while rustc doesn't serialize them) and runs the engine. rustc can emit these files (via <code>-Znll-facts</code>, there are more details in the readme) so that makes profiling easy as well. but just for ballpark numbers you can also run this binary with logging via <code>RUST_LOG</code>, and each step of the engine pipeline should log partial results, and the time it took to compute them</li>\n</ul>",
        "id": 261915078,
        "sender_full_name": "lqd",
        "timestamp": 1637235012
    }
]