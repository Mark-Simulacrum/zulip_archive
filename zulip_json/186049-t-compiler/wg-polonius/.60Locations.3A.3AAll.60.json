[
    {
        "content": "<p>Following up on <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/Placeholder.20liveness.20aside/near/250961160\">this comment</a>, I found these situations where <code>Locations::All</code> is used:</p>\n<ul>\n<li>Returns </li>\n<li><a href=\"https://github.com/rust-lang/rust/blob/5fa94f3c57e27a339bc73336cd260cd875026bd1/compiler/rustc_borrowck/src/type_check/input_output.rs#L113-L115\">Generator yields</a> (What's up with that span BTW?)</li>\n<li>Type annotations<br>\n    -  <a href=\"https://github.com/rust-lang/rust/blob/5fa94f3c57e27a339bc73336cd260cd875026bd1/compiler/rustc_borrowck/src/type_check/input_output.rs#L113-L115\">(on statements)</a><br>\n     - <a href=\"https://github.com/rust-lang/rust/blob/5fa94f3c57e27a339bc73336cd260cd875026bd1/compiler/rustc_borrowck/src/type_check/mod.rs#L491-L496\">(on variables/args)</a></li>\n</ul>\n<p>All but the last have have an obvious location in the MIR (<code>Return</code> terminators, <code>Yield</code> terminators, the statement with the type annotation, and (for function args) the entry to the function (where it should propagate since function arguments are live to start)). However, for type annotations on variable declarations, I think we would need to emit the outlives constraint at all locations where the variable is assigned? This would be a bit of a pain.</p>\n<p>We could also switch to a <code>subset_everywhere</code> relation for <code>Locations::All</code> outlives constraints and either use disjunction or seed <code>subset_base</code> with <code>subset_everywhere</code> when both origins are live (or, for the optimized variant, one becomes live). This would fix the cases where we have several GBs of <code>subset</code> tuples, many of which are ignored since the origin (e.g. the return place) is not live.</p>",
        "id": 260610389,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636340094
    },
    {
        "content": "<p>On the other hand, I wonder if some of the places where <code>Locations::All</code> is used don't actually generate constraints: the variable type case is part of <a href=\"https://github.com/rust-lang/rust/blob/5fa94f3c57e27a339bc73336cd260cd875026bd1/compiler/rustc_borrowck/src/type_check/mod.rs#L330-L336\"><code>TypeVerifier</code></a>, which claims to be solely a sanity check.</p>",
        "id": 260611623,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636341810
    },
    {
        "content": "<p>No. It looks like <code>TypeVerifier</code> is responsible for generating constraints.</p>",
        "id": 260613420,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636344421
    },
    {
        "content": "<p>(splitting the outlives relations into two Ã  la <code>subset_everywhere</code> was the approach I prototyped in <a href=\"https://github.com/lqd/borrow-check/commits/fix_oom\">https://github.com/lqd/borrow-check/commits/fix_oom</a> (as you've seen a rustc branch generating these facts is simple, but <a href=\"https://github.com/lqd/rust/tree/fix_oom\">here it was</a>). Since it impacted rules subtly, in order to not miss subsets while also not just moving the materializations from rustc to polonius, niko preferred prototyping changing fact gen in rustc, in their own different branch)</p>",
        "id": 260648022,
        "sender_full_name": "lqd",
        "timestamp": 1636373140
    },
    {
        "content": "<p>I think I had a similar analysis, <span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span>, some time back.</p>",
        "id": 260672368,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385408
    },
    {
        "content": "<p>I'm wondering: if we change (say) return types or member constraints</p>",
        "id": 260672394,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385419
    },
    {
        "content": "<p>I think perhaps we permit some weirdness in code that doesn't return ?</p>",
        "id": 260672422,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385430
    },
    {
        "content": "<p>maybe not</p>",
        "id": 260672429,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385433
    },
    {
        "content": "<p>regarding type annotations, I'm curious</p>",
        "id": 260672462,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385446
    },
    {
        "content": "<p>I think we may ultimately want to move to a set of facts that more closely matches the MIR, and in particular not to include (e.g.) <code>clear_origin</code> but more like <code>var_assigned(X, N)</code> and <code>type_of_var(X, T)</code> and <code>origin_in_type(T, O)</code>, from which we can deducate <code>clear_origin(X, O, N)</code>.</p>",
        "id": 260672597,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385494
    },
    {
        "content": "<p>in this case, could we also readily deduce \"inserting\" the required subset relations at each point that the var is assigned?</p>",
        "id": 260672635,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636385508
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/.60Locations.3A.3AAll.60/near/260672635\">said</a>:</p>\n<blockquote>\n<p>in this case, could we also readily deduce \"inserting\" the required subset relations at each point that the var is assigned?</p>\n</blockquote>\n<p>Thinking adversarially, what if we had a local that is only initialized via a raw pointer? (This is outside the realm of well-defined Rust, but I don't think it's UB at the moment):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">addr_of_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>x</code> is never defined, so I'm worried that this would type check (because the type checker would see that <code>x</code> has the same type as the return place) and also borrow check (since without a definition we would never associate the existential region variable for <code>x</code>'s local with <code>'a</code>).</p>",
        "id": 260692318,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636393396
    },
    {
        "content": "<p>Surprisingly, <code>addr_of</code> causes an error because <code>x</code> is uninitialized. I think this is a bug in <code>addr_of</code>. Part of the reason it exists is to create pointers to uninitialized data.</p>",
        "id": 260692556,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1636393504
    },
    {
        "content": "<p>yes, we've often discussed whether that is allowed</p>",
        "id": 260697620,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636395566
    },
    {
        "content": "<p>I'm not sure I agree that this is an error</p>",
        "id": 260697668,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636395592
    },
    {
        "content": "<p>I think locals are different than other forms of storage</p>",
        "id": 260697674,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636395598
    },
    {
        "content": "<p>I suspect we also want, for example, the freedom to reuse storage once it has been \"moved out\" from</p>",
        "id": 260697749,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636395616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/.60Locations.3A.3AAll.60/near/260697668\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I agree that this is an error</p>\n</blockquote>\n<p>er, I mean that it should be considered \"ok\"</p>",
        "id": 260697803,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636395645
    },
    {
        "content": "<p>still, good question</p>",
        "id": 260697823,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1636395663
    }
]