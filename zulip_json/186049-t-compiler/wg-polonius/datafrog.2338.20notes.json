[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"320917\">@regexident</span> there's a trivial way to express the <a href=\"https://github.com/rust-lang/datafrog/issues/38#issuecomment-904060973\">motivating example</a> from <a href=\"https://github.com/rust-lang/datafrog/issues/38\">datafrog#38</a> in datafrog. Basically, a <code>ValueFilter</code> can remove tuples from the output of a join (in contrast to a <code>PrefixFilter</code>, which can remove certain <em>keys</em> from the <em>input</em> of a join, sometimes eliminating the need to do the join at all). So to express that placeholder origins are live everywhere, all you to do is write a <code>ValueFilter</code> that returns <code>true</code> iff the origin is in <code>placeholder_origin</code> <strong>or</strong> is in <code>origin_live_at</code> at the relevant point in the CFG.</p>\n<p>This is a bit unsatisfying to me, since it becomes the user's responsibility to do caching. Due to the ordering of fields in <code>subset</code>, we will generate a lot of intermediate results with the same <code>origin</code> all in a row, and it would be nice to take advantage of that somehow. I'm not sure what the best way would be to expose a <code>ValueFilter</code> that is backed by a relation (or multiple relations), however.</p>",
        "id": 253124035,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1631552399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> has marked this topic as resolved.</p>",
        "id": 253124109,
        "sender_full_name": "Notification Bot",
        "timestamp": 1631552407
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> has marked this topic as unresolved.</p>",
        "id": 253124132,
        "sender_full_name": "Notification Bot",
        "timestamp": 1631552412
    },
    {
        "content": "<p>I would probably start by making a new <code>ValueFilterWith</code> leaper that wraps a <code>Relation</code> and takes a function to map from the <code>(Key, Value)</code> of the leapjoin to the element type of the underlying <code>Relation</code>. It's easy to write a cached implementation of <code>Leaper</code> for such a type, and also pretty easy to write a new leaper that wraps two <code>ValueFilterWith</code>s and allows for disjunction.</p>",
        "id": 253135635,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1631557170
    },
    {
        "content": "<p>That does seem a bit heavyweight though. I wonder if there's a more elegant solution?</p>",
        "id": 253135825,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1631557242
    },
    {
        "content": "<p>This is the problem with modifying a Godel award winner's code: it always feels like you're messing up some beautiful underlying idea. I had the same problem when working on with Peter Shor's emacs plugins <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 253136134,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1631557371
    },
    {
        "content": "<p>BTW <span class=\"user-mention\" data-user-id=\"320917\">@regexident</span>, you should read Frank's <a href=\"https://github.com/frankmcsherry/blog/blob/master/posts/2018-05-19.md\">blog post</a> on what became datafrog if you haven't already. It helps clarify the <code>Leaper</code> interface.</p>",
        "id": 253136540,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1631557531
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> <a href=\"#narrow/stream/186049-t-compiler.2Fwg-polonius/topic/datafrog.2338.20notes/near/253136134\">said</a>:</p>\n<blockquote>\n<p>This is the problem with modifying a Godel award winner's code: it always feels like you're messing up some beautiful underlying idea. I had the same problem when working on with Peter Shor's emacs plugins <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>\n</blockquote>\n<p><span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span></p>",
        "id": 253138268,
        "sender_full_name": "lqd",
        "timestamp": 1631558253
    },
    {
        "content": "<p>(I remember Frank completing datafrog over a weekend, though you could feel the timely/differential dataflow influence in its API. And the <code>Leaper</code>s were added the next weekend :)</p>",
        "id": 253139367,
        "sender_full_name": "lqd",
        "timestamp": 1631558696
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"118594\">@Dylan MacKenzie (ecstatic-morse)</span>  I read the blog post a couple of years ago (and even had the pleasure of attending a talk on differential privacy by Frank here in Berlin <span aria-label=\"blush\" class=\"emoji emoji-1f60a\" role=\"img\" title=\"blush\">:blush:</span>), but definitely will give it another thorough read now!</p>",
        "id": 253143569,
        "sender_full_name": "regexident",
        "timestamp": 1631560355
    }
]