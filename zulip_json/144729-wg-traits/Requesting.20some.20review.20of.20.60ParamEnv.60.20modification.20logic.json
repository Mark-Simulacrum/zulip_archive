[
    {
        "content": "<p>I'd like to request some additional review of the logic I'm adding in PR <a href=\"https://github.com/rust-lang/rust/pull/92044\">https://github.com/rust-lang/rust/pull/92044</a></p>\n<p>The idea is: if the predicate we're evaluating doesn't contain any free regions, then any 'purely region-related' bounds in the <code>ParamEnv</code> don't matter. For example, <code>T: MyTrait</code>, <code>for&lt;'a&gt; &amp;'a u8: OtherTrait&lt;'a&gt;</code> do not use any information from a <code>where</code> clause like <code>fn foo&lt;'a, T&gt;() where T: 'a</code></p>\n<p>There are two exceptions: bounds like <code>T: 'static</code>, any anything involving higher-ranked lifetime (late-bound regions). For example, we could have <code>fn foo&lt;T: 'static&gt;() {}</code>, and need to evaluate <code>T as MyTrait</code>. If we find an impl like <code>impl&lt;T: 'static&gt; MyTrait for T {}</code>, then it's important that we preserved the <code>T: 'static</code> bound in the <code>ParamEnv</code>.</p>\n<p>The other case is late-bound regions. It's possible to write an impossible-to-satisfy <code>where</code> clause like <code>fn foo&lt;'a&gt;(val: &amp;'a bool) where for&lt;'b&gt; &amp;'b u8: 'a </code>. As far as I can tell, you can't actually make use of that <code>where</code> clause in the body of the function, even though you can with an 'impossible-to-satisfy' trait bound. For example, I can copy a <code>Vec&lt;u8&gt;</code> in a function with a bound <code>where Vec&lt;u8&gt;: Copy</code> (this is sound because I can never actually call that function). However, I can't pass a reference to a local variable to a function expecting a <code>&amp;'static</code> reference, no matter what <code>where</code> clause I write.</p>\n<p>As a result, my PR always keeps <code>ParamEnv</code> bounds involving late-bound regions, as well as any bound of the form <code>SomeType&lt;'maybe_regions&gt;: 'static</code>. I believe this is sufficient to make my change sound (though it's possibly overly conservatively)</p>",
        "id": 265590395,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640020194
    },
    {
        "content": "<p>However, I'm concerned that I may have missed something. Are there any other ways for a predicate involving no free regions (e.g. <code>SomeType&lt;Vec&lt;u8&gt;&gt;: SomeOtherTrait</code> to depend on <code>RegionOutlives</code> or <code>TypeOutlives</code> predicates from the environment? Could inference variables complicate things?</p>",
        "id": 265590629,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640020307
    },
    {
        "content": "<p>Inference vars would be caught by the <code>is_global</code> check. I don't think we ever have inference vars in a ParamEnv, mostly because I'm not sure how they could end up in there. That would probably break any non-canonical query anyway, so I think we're good?</p>",
        "id": 265616527,
        "sender_full_name": "oli",
        "timestamp": 1640034746
    },
    {
        "content": "<p>What I'm wondering is whether we could ramp your change up to 11 by substituting early bound lifetimes in ways that allows caching of bounds that include lifetimes of the current environment. But let's stash that idea for a follow up PR</p>",
        "id": 265616797,
        "sender_full_name": "oli",
        "timestamp": 1640034946
    },
    {
        "content": "<p>Back to inference vars: add a debug assert checking that there are none in the param env</p>",
        "id": 265616883,
        "sender_full_name": "oli",
        "timestamp": 1640034992
    },
    {
        "content": "<p>You can have inference variables in a ParamEnv - it occurs when you invoke a canonicalized query</p>",
        "id": 265618103,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640035881
    },
    {
        "content": "<p>The query implementation will instantiate the canonicalized input (including the <code>ParamEnv</code>), creating inference variables</p>",
        "id": 265618148,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640035919
    },
    {
        "content": "<p>I didn't realize that until I investigated the perf issue that lead to this PR</p>",
        "id": 265618206,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640035934
    },
    {
        "content": "<p>Also, I'm only checking for free regions, not using <code>is_global</code>. That allows me to still discard bounds for things like <code>T as MyTrait</code></p>",
        "id": 265618272,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640035988
    },
    {
        "content": "<p>which might have some minor perf benefit</p>",
        "id": 265618299,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640036016
    },
    {
        "content": "<p>Ah right, the inside of canonicalized queries</p>",
        "id": 265623249,
        "sender_full_name": "oli",
        "timestamp": 1640039185
    },
    {
        "content": "<p>You do check if the predicate is global, so the predicate has no inference vars. I wonder if this means that you can throw away any parts of the param env that mention inference vars?</p>",
        "id": 265623320,
        "sender_full_name": "oli",
        "timestamp": 1640039267
    },
    {
        "content": "<p>Couldn't something end up getting unified with one of the bounds in the ParamEnv?</p>",
        "id": 265625237,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640040639
    },
    {
        "content": "<p>I confused myself early - I check if the <em>predicate</em> is global, and if the <code>ParamEnv</code> has any free regions (so that we avoid re-constructing it if there's nothing to actually discard)</p>",
        "id": 265641949,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640055421
    },
    {
        "content": "<p>I'm now even less confident about this optimization. If we have <code>MyType: ?0</code> in the <code>ParamEnv</code>, what prevents us from unifiying <code>?0 = 'static</code> during evaluation? Couldn't we end up in a situation where that unifications is necessary in order for <code>impl&lt;T: 'static&gt; MyTrait for T {}</code> to successfully match?</p>",
        "id": 265736333,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640122137
    },
    {
        "content": "<p>I think the safest form of this would be to only discard <code>RegionOutlives</code> predicate involving inference variables (and no bound regions) when our predicate has no free regions. Additionally, we can try to make sure that canonicalization doesn't canonicalize <code>'static</code>, so that we can avoid ending up with <code>MyTrait: ?0</code> in our <code>ParamEnv</code> to begin with in more cases</p>",
        "id": 265736516,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640122264
    },
    {
        "content": "<p>Of course, we could have <code>MyType: ?0</code> and <code>?0: ?1</code> in our <code>ParamEnv</code>, and then later unify <code>?0 = 'a</code> and <code>?1 = 'static</code></p>",
        "id": 265737475,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640122628
    },
    {
        "content": "<p>which would allow us to conclude that <code>MyType: 'static</code> ...</p>",
        "id": 265737499,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640122650
    }
]