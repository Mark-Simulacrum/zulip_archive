[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> opening a topic for future discussions</p>",
        "id": 264056025,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638904252
    },
    {
        "content": "<p>I've been talking over DMs with you both, let's discuss things here maybe better</p>",
        "id": 264056076,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638904270
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 264056083,
        "sender_full_name": "oli",
        "timestamp": 1638904273
    },
    {
        "content": "<p>gonna paste last message from Camile and we can continue from there</p>",
        "id": 264056187,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638904318
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/pm-with/116266,248906-pm/near/264055884\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>To go back to your lowering step 1 &amp; 2:<br>\nHIR path segments contain a <code>Res</code> field, which contains the resolution for this segment. When we have <code>foo&lt;'a, T&gt;</code>, all mentions of <code>T</code> will have a <code>Res::Def(DefKind::TyParam, &lt;T's DefId&gt;)</code>.</p>\n</blockquote>\n<p>Continuing: now, if you have <code>fn foo&lt;'a, T&gt;() -&gt; impl Borrow&lt;T&gt;</code>, AST resolution will say that the T inside Borrow&lt;T&gt; resolves to foo's generic. But in HIR, you will have <code>type foo#Ty&lt;'a, T2&gt; = impl Borrow&lt;T2&gt;</code>, with AST telling you the T2 inside Borrow&lt;&gt; still resolves to foo's T. So you need to fix <code>T2</code>'s resolution to hve <code>foo#Ty</code>'s T2 DefId instead.</p>\n</blockquote>",
        "id": 264056188,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638904319
    },
    {
        "content": "<p>yea, this makes sense. Do we have a HIR &amp;mut visitor that we can use here?</p>",
        "id": 264056476,
        "sender_full_name": "oli",
        "timestamp": 1638904449
    },
    {
        "content": "<p>nope, doesn't look like it</p>",
        "id": 264056537,
        "sender_full_name": "oli",
        "timestamp": 1638904497
    },
    {
        "content": "<p>in that case, we may need to do some ad-hoc patching during the HIR lowering instead of fixing it up after the fact?</p>",
        "id": 264056602,
        "sender_full_name": "oli",
        "timestamp": 1638904528
    },
    {
        "content": "<p>or implement a MutVisitor</p>",
        "id": 264056622,
        "sender_full_name": "oli",
        "timestamp": 1638904544
    },
    {
        "content": "<p>HIR can't be mutated, on purpose. It uses <code>&amp;</code> references allocated on an arena, so MutVisitor would be very unsafe.</p>",
        "id": 264056741,
        "sender_full_name": "cjgillot",
        "timestamp": 1638904585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> <a href=\"#narrow/stream/144729-wg-traits/topic/rpit.20refactor/near/264056602\">said</a>:</p>\n<blockquote>\n<p>in that case, we may need to do some ad-hoc patching during the HIR lowering instead of fixing it up after the fact?</p>\n</blockquote>\n<p>right patching during lowering seems like the way to go then?</p>",
        "id": 264057047,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638904712
    },
    {
        "content": "<p>generic params can appear everywhere from expressions to types, so we'd have to be able to modify what a generic param lowers throughout the entire HIR lowering infra</p>",
        "id": 264057051,
        "sender_full_name": "oli",
        "timestamp": 1638904713
    },
    {
        "content": "<p>Illustration I sent in PM:<br>\nAST:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn foo&lt;T&gt;() -&gt; impl Borrow&lt;T&gt; {}\n       ^     resolution    |\n       +-------------------+\n</code></pre></div>\n<p>HIR</p>\n<div class=\"codehilite\"><pre><span></span><code>fn foo&lt;T&gt;() -&gt; foo#Ty&lt;T&gt; {\n       ^              |\n       +--------------+\n\n    type foo#Ty&lt;T2&gt; = impl Borrow&lt;T2&gt;;\n                ^^                ||\n                ++----------------++\n}\n</code></pre></div>",
        "id": 264057054,
        "sender_full_name": "cjgillot",
        "timestamp": 1638904713
    },
    {
        "content": "<p>in a bit I'm going to try to summarize all the things that we've been talking about somehow</p>",
        "id": 264058041,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638905131
    },
    {
        "content": "<p>Another solution would be to re-implement resolution on the HIR, like lifetime resolution works. But this is a very large amount of work.</p>",
        "id": 264058275,
        "sender_full_name": "cjgillot",
        "timestamp": 1638905243
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span>, Niko was sharing with me some ideas about how to handle this and asked me to check with you both to see if you see some issues related to it</p>",
        "id": 264154773,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638970348
    },
    {
        "content": "<p><a href=\"#narrow/stream/144729-wg-traits/topic/rpit.20refactor\">How to manage this</a></p>\n<ol>\n<li>Parsing into AST</li>\n<li>Name resolution on the AST (produces some kind of map from AST paths to definitions)</li>\n<li>AST lowering into HIR<br>\n    4. reads the name resolution results and produces a <code>Res</code> in the HIR that maps to a <code>DefId</code></li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nb\">Ord</span>\n<span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// want to produce</span>\n\n<span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T1</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T1</span>: <span class=\"nb\">Ord</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nb\">Ord</span>\n<span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>For example:</p>\n<ul>\n<li>There will be some AST nodes that represent <code>where T: Ord</code><br>\n    * the AST node for <code>T</code> will have a \"name resolution result\" that maps to <code>T</code> on <code>foo</code></li>\n<li>Conceptually, you can model this as:<br>\n    * <code>AstNameResolution: Map&lt;AstNode, DefId&gt;</code> 'more or less'</li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">lower_ast_to_hir</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">path</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">ast</span>::<span class=\"n\">Path</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">hir</span>::<span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">ast_name_resolution</span><span class=\"p\">[</span><span class=\"n\">path</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">SomeVariant</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Res</span>::<span class=\"n\">DefId</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">hir</span>::<span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>What we want to do, in terms of that example:</p>\n<ul>\n<li>Produce the same HIR we did before (<code>where T: Ord</code>) for use within <code>foo</code> function</li>\n<li>Produce the HIR for the <code>Foo</code> TAIT, which is <em>almost</em> the same but any reference to <code>T</code> now is mapped to <code>T1</code><br>\n    * <code>where T1: Ord</code></li>\n</ul>\n<h3>Option 1.</h3>\n<p>Lower the AST twice, and have a mapping at that time.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* AST for some function that returns impl trait */</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f_wc_hir</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lower_ast_to_hir</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">where_clauses</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;-- old code, nothing changed</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tait</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* new def id */</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tait_generics</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">copy_of</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">generics</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">generics</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">tait</span><span class=\"p\">.</span><span class=\"n\">generics</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tait_wc_hir</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lower_ast_to_hir</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">where_clauses</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;-- old code, nothing changed</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">lower_ast_to_hir</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">path</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">ast</span>::<span class=\"n\">Path</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">map_fn</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"n\">Res</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Res</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">hir</span>::<span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">ast_name_resolution</span><span class=\"p\">[</span><span class=\"n\">path</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">SomeVariant</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">Res</span>::<span class=\"n\">DefId</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">map_fn</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">hir</span>::<span class=\"n\">Path</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">res</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<h3>Option 2.</h3>\n<p>Lower the AST to HIR, then clone the HIR and apply a mapping as we do so.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* AST for some function that returns impl trait */</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f_wc_hir</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">lower_ast_to_hir</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">where_clauses</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;-- old code, nothing changed</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tait</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* new def id */</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tait_generics</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">copy_of</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">generics</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">generics</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">tait</span><span class=\"p\">.</span><span class=\"n\">generics</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">tait_wc_hir</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">clone_hir</span><span class=\"p\">(</span><span class=\"n\">f_wc_hir</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">map</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">]);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 264154779,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638970351
    },
    {
        "content": "<p>those are his ideas <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span></p>",
        "id": 264154805,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638970365
    },
    {
        "content": "<p>as discussed earlier, cloning is not really an option. The infrastructure needed for that would be enormous. It may be worth it if we can re-use it for other things, but doing it on the fly seems like the better option, but it may cause perf regressions in cases that don't use RPIT, so we need to see</p>",
        "id": 264155512,
        "sender_full_name": "oli",
        "timestamp": 1638970679
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 264155621,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638970713
    },
    {
        "content": "<p>but this is more or less what you also had in mind?</p>",
        "id": 264155675,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638970741
    },
    {
        "content": "<p>yea, pretty much</p>",
        "id": 264155728,
        "sender_full_name": "oli",
        "timestamp": 1638970760
    },
    {
        "content": "<p>tho I'm not sold on threading a mapping closure through all of HIR lowering</p>",
        "id": 264155801,
        "sender_full_name": "oli",
        "timestamp": 1638970796
    },
    {
        "content": "<p>may want to start out with a field on the lowering context that is a boxed closure</p>",
        "id": 264155911,
        "sender_full_name": "oli",
        "timestamp": 1638970836
    },
    {
        "content": "<p>yeah, we can check these kind of details as we go</p>",
        "id": 264156079,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638970920
    },
    {
        "content": "<p>I really have very strong doubts about this approach. For my understanding, what are the difficulties of using <code>generics_of</code> as previously suggested?</p>",
        "id": 264196120,
        "sender_full_name": "cjgillot",
        "timestamp": 1638987063
    },
    {
        "content": "<p>I don't think there are huge difficulties from what I've seen in my code</p>",
        "id": 264211332,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638993442
    },
    {
        "content": "<p>although I clearly see how with this new approach all the different variants of return position impl trait behave similar</p>",
        "id": 264211393,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638993465
    },
    {
        "content": "<p>I was told that this approach may not interact well with <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>'s new lazy taits, but I'm not sure because I don't know what are exactly the changes there</p>",
        "id": 264211635,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638993553
    },
    {
        "content": "<p>also ... you only want to catch lifetimes that show up in the bounds, so I guess the current solution does some kind of a hack to hide the ones that you want to discard, (is that the <code>'static</code> thing that <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> mentioned me?)</p>",
        "id": 264211815,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638993616
    },
    {
        "content": "<p>I'm not 100% sure of all the things involved to be honest</p>",
        "id": 264211864,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638993628
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span></p>",
        "id": 264211896,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1638993638
    },
    {
        "content": "<blockquote>\n<p>also ... you only want to catch lifetimes that show up in the bounds, so I guess the current solution does some kind of a hack to hide the ones that you want to discard, (is that the <code>'static</code> thing that <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span> mentioned me?)</p>\n</blockquote>\n<p>Yes. In the current code, all lifetimes from the function are inherited in the RPIT. In order to avoid capturing those we don't want, astconv replaces them with <code>'static</code>.</p>",
        "id": 264229373,
        "sender_full_name": "cjgillot",
        "timestamp": 1639001950
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> I have a question about something that we've talked already but I do not really understand</p>",
        "id": 265310115,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754735
    },
    {
        "content": "<p>we've said that <code>def_collector</code> runs before macro expansion</p>",
        "id": 265310145,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754754
    },
    {
        "content": "<p>which yeah, I see :)</p>",
        "id": 265310203,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754766
    },
    {
        "content": "<p>but then, given that we've also said ...</p>",
        "id": 265310217,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754775
    },
    {
        "content": "<p>so ... we can’t have a list of all generic parameters bound by a function on <code>def_collector</code></p>",
        "id": 265310244,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754792
    },
    {
        "content": "<p>that phrase seems to imply that macro resolution is the thing that will make accessible the generic parameters</p>",
        "id": 265310335,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754839
    },
    {
        "content": "<p>is that what we mean? how? can any of you explain a bit better?</p>",
        "id": 265310380,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754865
    },
    {
        "content": "<p>we were talking about this with <span class=\"user-mention\" data-user-id=\"116113\">@lqd</span> too</p>",
        "id": 265310420,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639754880
    },
    {
        "content": "<p>Macros haven't been expanded yet, so we don't know yet if macros will expand into additional generic parameters. It's not about macro resolution, it's about having the information available.</p>",
        "id": 265331526,
        "sender_full_name": "cjgillot",
        "timestamp": 1639762432
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> <a href=\"#narrow/stream/144729-wg-traits/topic/rpit.20refactor/near/264196120\">said</a>:</p>\n<blockquote>\n<p>I really have very strong doubts about this approach. For my understanding, what are the difficulties of using <code>generics_of</code> as previously suggested?</p>\n</blockquote>\n<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span></p>",
        "id": 265425893,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1639843668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 265818997,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1640187988
    },
    {
        "content": "<p>can you ask your question here so <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> can see it too?</p>",
        "id": 265819020,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1640188005
    },
    {
        "content": "<p>I don't have a broad enough view of the current opaque type infrastructure, so I think I need a reminder of the end goal and long view here. This refactoring we have been working on: Which technical debt / complexity are we trying to remove ? Which feature does it prevent us to implement correctly ?</p>",
        "id": 265819473,
        "sender_full_name": "cjgillot",
        "timestamp": 1640188243
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> -- sorry for being unresponsive, I've been snowed under lately.</p>",
        "id": 265921320,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269762
    },
    {
        "content": "<p>here is my position</p>",
        "id": 265921333,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269769
    },
    {
        "content": "<p>(A) I would like to have a simple \"mini Rust\" that we know how to reason about</p>",
        "id": 265921347,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269781
    },
    {
        "content": "<p>(B) I would like rustc to lower to something that faithfully represents this mini Rust</p>",
        "id": 265921358,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269791
    },
    {
        "content": "<p>(C) If there's going to be complexity, I want it to be pushed more into the \"lowering\" and \"desugaring\" logic than the \"subtle bits\"</p>",
        "id": 265921425,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269816
    },
    {
        "content": "<p>I think that the correct model for \"mini rust\" (let's call it Patina) is going to include opaque types, which I'll represent with this syntax:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">P0</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"n\">Pn</span><span class=\"o\">&gt;</span>: <span class=\"nc\">TraitBound</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Notably this is the same as an associated type, but at the module level. (I think we should actually have this syntax in full rust, too)</p>",
        "id": 265921489,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269874
    },
    {
        "content": "<p>So something like <code>type Foo = (impl Trait1, impl Trait2)</code> would desugar to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo1</span>: <span class=\"nc\">Trait1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">type</span> <span class=\"nc\">Foo2</span>: <span class=\"nc\">Trait2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">Foo1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Foo2</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265921510,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269898
    },
    {
        "content": "<p>In any case, Patina wouldn't include \"nested\" items that inherit type parameters from the surrounding item, so I don't want to include that in the compiler's internal model either.</p>",
        "id": 265921582,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269933
    },
    {
        "content": "<p>I don't think that inheriting type parameters is particularly <em>elegant</em>, anyhow, because of the \"incomplete capture\" properties of impl Trait -- having to \"add back\" lifetime parameters and then add \"dummy\" lifetimes means we need a lot of the same machinery either way.</p>",
        "id": 265921623,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640269975
    },
    {
        "content": "<p>In Patina, I would expect that the \"opaque type\" definition would be cheked for well-formedness in the obvious way. This means that it would be important to inherit the where cluases from the surrounding function. Consider something like this:</p>",
        "id": 265921662,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270007
    },
    {
        "content": "<p>(Actually, the <code>type Foo: Trait</code> syntax is incomplete. The full Patina syntax would be <code>type Foo: Trait = HiddenType;</code>, sorry)</p>",
        "id": 265921686,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270031
    },
    {
        "content": "<p>Given a rust program like</p>",
        "id": 265921694,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270040
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Debug)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">RequiresOrd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Ord</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span>:\n\n<span class=\"nc\">fn</span><span class=\"w\"> </span><span class=\"n\">returns_ord</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Ord</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">RequiresOrd</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265921785,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270093
    },
    {
        "content": "<p>the resulting patina program would be</p>",
        "id": 265921792,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270097
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>: <span class=\"nc\">Debug</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">RequiresOrd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nb\">Ord</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">returns_ord</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Ord</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">RequiresOrd</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265921829,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270131
    },
    {
        "content": "<p>we would then check <code>RequiresOrd&lt;T&gt;</code> for well-formedness against the where clauses declared on <code>Foo</code> -- which would require that we know <code>T: Ord</code></p>",
        "id": 265921907,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270170
    },
    {
        "content": "<p>Now consider a case with lifetimes...</p>",
        "id": 265921917,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270177
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">SomeTrait</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(Debug)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Wrapper</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">SomeTrait</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span>:\n\n<span class=\"nc\">fn</span><span class=\"w\"> </span><span class=\"n\">returns_ord</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">SomeTrait</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Wrapper</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265921990,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270237
    },
    {
        "content": "<p>desugared:</p>",
        "id": 265922001,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270246
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">ReturnsOrd</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span>: <span class=\"nc\">Debug</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">T</span>: <span class=\"nc\">SomeTrait</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">returns_ord</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">SomeTrait</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ReturnsOrd</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265922095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270290
    },
    {
        "content": "<p>but if we use the 'inherited' technique</p>",
        "id": 265922101,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270294
    },
    {
        "content": "<p>the desugaring is <em>more like</em> this</p>",
        "id": 265922114,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270306
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">returns_ord</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">SomeTrait</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">ReturnsOrd</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">ReturnsOrd</span><span class=\"o\">&lt;..</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span>: <span class=\"nc\">Debug</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"n\">T</span>: <span class=\"nc\">SomeTrait</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where the <code>.., 'a</code> indicates that it inherits its generics from the surrounding item.</p>",
        "id": 265922221,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270398
    },
    {
        "content": "<p>Note that we <em>still</em> had to clone the where clause <code>T: SomeTrait&lt;'a&gt;</code> and the lifetime parameter <code>'a</code></p>",
        "id": 265922288,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270418
    },
    {
        "content": "<p>So, we're still cloning, and thus requiring all the machinery, but we're <em>not</em> getting the simplicity</p>",
        "id": 265922309,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270435
    },
    {
        "content": "<p>fin :)</p>",
        "id": 265922324,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270447
    },
    {
        "content": "<p>also, cloning seems very simple to me :)</p>",
        "id": 265922355,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270467
    },
    {
        "content": "<p>it's a bit of code but that's mostly because HIR lowering is in need of a good refactoring and cleanup, conceptually it's very simple</p>",
        "id": 265922380,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270485
    },
    {
        "content": "<p>as we lean heavier on desugaring, we should make cloning easy and convenient, we're going to want it more and more often imo</p>",
        "id": 265922407,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640270499
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>, thank you for your answer.<br>\nI understand that the aim is to make HIR the simplified pseudo-language that you call Priroda. I agree with this objective.</p>\n<p>However, I think the current HIR is not the right tool for that. This is fixable, but we will need to define precise objectives for what we want and how we want it.</p>\n<p>Current HIR is very close to the AST. HIR mostly departs from the AST by:</p>\n<ul>\n<li>making HirIds local to each item;</li>\n<li>being indexed;</li>\n<li>a few desugarings (loops, async, in-band lifetimes, nested APIT and RPIT...).</li>\n</ul>\n<p>The main property, which will need to redesign is the indexing:</p>\n<ul>\n<li>HIR has node identity semantics: each node has a HirId, which is globally unique in the HIR, and can be used to query the HIR node;</li>\n<li>HIR also has tree semantics: from a node, there exists a query for its parent.</li>\n</ul>\n<p>If we simply clone a HIR sub-tree into another sub-tree, the current setup will ICE all over the place since it won't be able to build an HirId -&gt; Node mapping. If we mention a DefId twice in HIR (this will happen if we lower the same AST fragment twice), indexing will need to know which edge defines the right \"parent\". We cannot simply act as if the AST was written twice, since even a trait can embed arbitrary code and define functions.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}}]</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(I even think that having two copies of <code>bar</code> could create a type mismatch in some cases, but I don't have an example yet.)</p>\n<p>If we want to enable subtree sharing inside HIR, we would need:</p>\n<ul>\n<li>to define how we want to find the parent of a HIR node: only inside a Body? across items? how do we handle AnonConsts?</li>\n<li>to define whether we want to lower stuff twice or to insert more opaque references: do we want to have two pointers to the same <code>hir::Ty</code> (and have some code elsewhere to do the typechecking twice), or do we want a more destructured HIR where we store a <code>TyId</code> twice and have a side map <code>TyId -&gt; hir::Ty</code>?</li>\n<li>what is the lowering granularity: whole-crate? per item-like?</li>\n</ul>\n<p>I would suggest using a lower-level representation than the current HIR. For example: HIR where types have been canonicalized by astconv. Some kind of global THIR (different by the local THIR which is used for MIR building)? Built by gathering item signatures before wf-check?</p>",
        "id": 266117538,
        "sender_full_name": "cjgillot",
        "timestamp": 1640537977
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"248906\">@cjgillot</span> thanks! I hadn't considered constants, that does indeed introduce some additional complications. I'll have to read this a bit more carefully-- one other thing to keep in mind is that we're talking not only about HIR but also the results of the <code>generics_of</code> query and the like, and I definitely think that those queries are meant to map to this \"simplified language\" I am referring to.</p>",
        "id": 266940661,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1641392402
    },
    {
        "content": "<blockquote>\n<p>If we simply clone a HIR sub-tree into another sub-tree, </p>\n</blockquote>\n<p>This isn't what I'm proposing, though. What I'm proposing is rather that we lower the AST twice, with some tweaks to remap name resolution results and the like. I agree that it may be a bit more complex than I was giving credit too, but I don't think fundamentally more complex.</p>",
        "id": 266940848,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1641392500
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"248906\">cjgillot</span> thanks! I hadn't considered constants, that does indeed introduce some additional complications. I'll have to read this a bit more carefully-- one other thing to keep in mind is that we're talking not only about HIR but also the results of the <code>generics_of</code> query and the like, and I definitely think that those queries are meant to map to this \"simplified language\" I am referring to.</p>\n</blockquote>\n<p>Making the information in those queries an actual formalized language would greatly benefit the logic behind typeck. That's a great idea!</p>",
        "id": 267252326,
        "sender_full_name": "cjgillot",
        "timestamp": 1641595176
    },
    {
        "content": "<p>Actually, Priroda could be the language of queries: we would specify a set of properties for a definition (visibility, generics, bounds, type...), and this set of properties would define a simplified and uniform language for typeck &amp; borrowck purposes.</p>",
        "id": 267252676,
        "sender_full_name": "cjgillot",
        "timestamp": 1641595393
    },
    {
        "content": "<p>Did I understand your project correctly?</p>",
        "id": 267252693,
        "sender_full_name": "cjgillot",
        "timestamp": 1641595412
    },
    {
        "content": "<p>Oh no, who co-opted the priroda name <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span> it's already the name of my ui frontend for miri xD</p>",
        "id": 267306782,
        "sender_full_name": "oli",
        "timestamp": 1641663875
    },
    {
        "content": "<p>My bad, I got confused between priroda and patina. That's why it sounded familiar.</p>",
        "id": 267307017,
        "sender_full_name": "cjgillot",
        "timestamp": 1641664264
    },
    {
        "content": "<blockquote>\n<p>(I even think that having two copies of bar could create a type mismatch in some cases, but I don't have an example yet.)</p>\n</blockquote>\n<p>that could only be a problem if the array length used a generic parameter, otherwise the constant is evaluated instead of the expression getting compared</p>",
        "id": 268278291,
        "sender_full_name": "oli",
        "timestamp": 1642430171
    },
    {
        "content": "<p>This topic was moved to <a class=\"stream-topic\" data-stream-id=\"315482\" href=\"/#narrow/stream/315482-t-compiler.2Fetc.2Fopaque-types/topic/rpit.20refactor\">#t-compiler/etc/opaque-types &gt; rpit refactor</a> by <span class=\"user-mention silent\" data-user-id=\"124288\">oli</span>.</p>",
        "id": 271859418,
        "sender_full_name": "Notification Bot",
        "timestamp": 1644859572
    }
]