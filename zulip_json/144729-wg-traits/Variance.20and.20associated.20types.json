[
    {
        "content": "<p>Okay, so while trying to figure out why the <code>rustc_type_ir</code> changes don't work (see <a href=\"#narrow/stream/144729-wg-traits/topic/Moving.20.60TyEncodable.60.2F.60TyDecodable.60.20to.20.60rustc_typeir.60\">https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/Moving.20.60TyEncodable.60.2F.60TyDecodable.60.20to.20.60rustc_typeir.60</a>), I basically figured out that changing <code>enum TyKind&lt;'tcx&gt; { ... }</code> to <code>enum TyKind&lt;I: Interner&gt; { ... }</code> <em>won't</em> work currently</p>",
        "id": 250510905,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629822789
    },
    {
        "content": "<p>Namely, you can imagine you might have a variant <code>Slice(&amp;'tcx TyKind&lt;'tcx&gt;)</code> which turns into <code>Slice(I::Ty)</code></p>",
        "id": 250511070,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629822852
    },
    {
        "content": "<p>(I'm simplifying by leaving out <code>Ty</code> and <code>TyS</code>, but the principle holds)</p>",
        "id": 250511115,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629822877
    },
    {
        "content": "<p>An important distinction here is that the former allows <code>TyKind</code> to be <em>covariant</em> over <code>'tcx</code>, whereas the latter requires that <code>TyKind</code> be <em>invariant</em> over <code>I</code></p>",
        "id": 250511223,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629822939
    },
    {
        "content": "<p>See <a href=\"https://github.com/rust-lang/rust/issues/21726\">#21726</a> for why this was changes. Tldr, if you have <code>A &lt;: B</code>, you can't necessarily assume that <code>A::Ty</code> &lt;: <code>B::Ty</code></p>",
        "id": 250511378,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823008
    },
    {
        "content": "<p>I was thinking about what the best way to \"fix\" this</p>",
        "id": 250511439,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823043
    },
    {
        "content": "<p>I do want to quickly note a workaround: <code>enum TyKind&lt;I: Interner, ITy = &lt;I as Interner&gt;::Ty&gt; where &lt;I as Interner&gt;::Ty = ITy { ... }</code></p>",
        "id": 250511624,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823109
    },
    {
        "content": "<p>But that quickly falls apart once you add cycles (even though they are broken through references and such)</p>",
        "id": 250511695,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823139
    },
    {
        "content": "<p>Now, one way to fix this (and was briefly mentioned in <a href=\"https://github.com/rust-lang/rust/issues/21726\">#21726</a>), would be to have some way to mark the variances on associated types on a trait. And impls would have to abide by that. This probably works, but isn't particularly ideal. You would have to have something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"cp\">#[variance(covariant, covariant, covariant)]</span><span class=\"w\"> </span><span class=\"c1\">// Self, A, B</span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or some form. Workable but ugly.</p>",
        "id": 250512082,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823302
    },
    {
        "content": "<p>I was musing about something better</p>",
        "id": 250512114,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823314
    },
    {
        "content": "<p>So, looking back at the workaround from above, this <em>works</em> because we extract out <code>I::Ty</code> into a separate parameter, which we can then be covariant.</p>",
        "id": 250512330,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823396
    },
    {
        "content": "<p>I thought a little bit about this, how we could conceivably \"automate\" that, etc., but then I realized: what if we change the way we approach this</p>",
        "id": 250512513,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823463
    },
    {
        "content": "<p>So, sort of the key limitation here is that we relate types (particularly here adts) by the required variances of their <em>generics</em></p>",
        "id": 250512672,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823538
    },
    {
        "content": "<p>And these really are calculated <em>a priori</em> by the fields of adts</p>",
        "id": 250512742,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823564
    },
    {
        "content": "<p>Now, imagine we <em>didn't</em> calculate them ahead of time</p>",
        "id": 250512877,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823616
    },
    {
        "content": "<p>Anytime we wanted to relate two types (again, here just using adts), we would just relate each individual <em>field</em></p>",
        "id": 250513139,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823715
    },
    {
        "content": "<p>So say we had <code>struct Foo&lt;A&gt; { a: A }</code>. To relate <code>Foo&lt;X&gt; &lt;: Foo&lt;Y&gt;</code>, we would relate <code>X &lt;: Y</code>.</p>",
        "id": 250513296,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823784
    },
    {
        "content": "<p>Now, why can't we do this when we use associated types in fields. If instead we had <code>struct Foo&lt;I: Interner&gt; { ty: I::Ty }</code>, to relate <code>Foo&lt;X&gt; &lt;: Foo&lt;Y&gt;</code>, we just create the goal <code>X::Ty &lt;: Y::Ty</code>. Importantly, we don't have to \"think\" about the variance on <code>I</code> itself.</p>",
        "id": 250513754,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629823960
    },
    {
        "content": "<p>Where I'm less sure about is the way we currently compute the variances. Because these are calculated ahead of time, they are able to run to a fixed-state. Theoretically, the trait solver does the same thing (runs to a fixed-state).</p>",
        "id": 250513995,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629824051
    },
    {
        "content": "<p>Also, I'm not sure if not directly related <code>X</code> and <code>Y</code> would cause us not to be able to solve some goals we otherwise would have</p>",
        "id": 250514101,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629824091
    },
    {
        "content": "<p>But that's where I'm at in my thoughts.</p>",
        "id": 250514125,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629824100
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> for thoughts :)</p>",
        "id": 250514137,
        "sender_full_name": "Jack Huey",
        "timestamp": 1629824106
    },
    {
        "content": "<p>Wow, I have never thought about variance in regards to associated types, the use of invariance is surprising but makes sense as a default with some thought, fascinating!</p>",
        "id": 250559371,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1629844870
    },
    {
        "content": "<p>I don't think that works</p>",
        "id": 251410713,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1630425781
    },
    {
        "content": "<p>Well, hold on, maybe I don't totally understand what you are proposing</p>",
        "id": 251410841,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1630425826
    },
    {
        "content": "<p>I'm not exactly sure what I'm proposing</p>",
        "id": 251414953,
        "sender_full_name": "Jack Huey",
        "timestamp": 1630427495
    },
    {
        "content": "<p>Right now, to relate to adts, we relate their substs based on the variance of each that we've precalculated. But theoretically, we could relate the fields themselves? (Importantly, we could relate <em>projections</em> built from the substs)</p>",
        "id": 251415286,
        "sender_full_name": "Jack Huey",
        "timestamp": 1630427635
    }
]