[
    {
        "content": "<p>I was trying to find a cleaner and fastest to stabilize way to implement Default for all array sized including the exotic case for <code>[T; 0]</code> where <code>T</code> doesn't implement <code>Default</code>.</p>\n<p>So, long story short the following code doesn't compile with an error </p>\n<div class=\"codehilite\"><pre><span></span><code>the const parameter `TY` is not constrained by the impl trait, self type, or predicates\n  --&gt; &lt;source&gt;:29:31\n   |\n29 | impl&lt;T, const N: usize, const TY: ArrayType&gt; DefaultLike for [T; N]\n   |                                                      ^^ unconstrained const parameter\n   |\n   = note: expressions using a const parameter must map each value to a distinct output value\n   = note: proving the result of expressions other than the parameter are unique is not supported\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>#![allow(incomplete_features)]\n#![feature(adt_const_params)]\n\n#[derive(PartialEq, Eq)]\nenum ArrayType {\n    ZeroLength,\n    Normal\n}\n\ntrait ArrayDefault&lt;const TY: ArrayType&gt; {\n    fn hack() -&gt; Self;\n}\n\nimpl&lt;T&gt; ArrayDefault&lt;{ArrayType::ZeroLength}&gt; for [T; 0] {\n    fn hack() -&gt; Self {\n        []\n    }\n}\nimpl&lt;T: Default, const N: usize&gt; ArrayDefault&lt;{ArrayType::Normal}&gt; for [T; N] {\n    fn hack() -&gt; Self {\n        [(); N].map(|_| T::default())\n    }\n}\n\ntrait DefaultLike {\n    fn tester() -&gt; Self;\n}\n\nimpl&lt;T, const N: usize, const TY: ArrayType&gt; DefaultLike for [T; N]\n    where\n        [T; N]: ArrayDefault&lt;TY&gt;,\n{\n    fn tester() -&gt; Self {\n        &lt;[T; N] as ArrayDefault&lt;TY&gt;&gt;::hack()\n    }\n}\n</code></pre></div>\n<p>Same would happen without any features and using just <code>const B: bool</code> in trait parameters.</p>\n<p>I'd expect that an ability to separate in a specialization-like manner some default-like implementation and \"more specialized\" ones would be handy even if a type of const generic parameter in the implementation would be quite constrained (may require enum/bool only, ordering on the enum, etc).</p>\n<p>Is it something that would be desired or this is just over the roof and may be solved easier or \"for free\" by any other features being worked on. If it's desired I'd like to help with how to implement it if I get some guidance</p>",
        "id": 252541920,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1631139261
    },
    {
        "content": "<p>My though is largely based on a fact that it's much easier to pick one implementation to use from the already ordered priority set for the same type(!) then e.g. between more generic <code>T: Debug</code> and concrete <code>String</code></p>",
        "id": 252542240,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1631139420
    },
    {
        "content": "<p>needing to constrain generic params still has to be done with const generics.<br>\nwhat would this print out if we allowed it? :</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Foo</span>::<span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 252546777,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1631141988
    },
    {
        "content": "<p>My message is not about a particular error, but a potential feature that may be useful. One can change a syntax to make it more like higher rank trait bound with a meaning that “for all TY …”, but the idea is to simulate some kind of specialization or implementation priority resolution using ordering of some generic constant. It may be indeed good to require a completely different syntax there (to express a different meaning), but my question is about fundamental use</p>",
        "id": 252551792,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1631145593
    },
    {
        "content": "<p>So what you're proposing is to add a new type of generic which selects the smallest value that satistfy the other bounds? I feel like this would just have all the soundness problems that specialization has, but with an even weirder user interface.</p>",
        "id": 252593277,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1631178125
    },
    {
        "content": "<p>What I propose is roughly another kind of HRTB that will have a semantics of something like a marker or a priority ordering: so the same type that potentially implements a trait for different values of much generic a method dispatch and trait resolution will always pick the implementation with the “smallest” (from the point of Ord) value of such marker. It should not have the problems that specialization does: specialization has to choose between implementations for a different types and you have to “order” the types that is more difficult then to order the values of the same type, and the latter has a unique solution</p>",
        "id": 252601384,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1631182379
    },
    {
        "content": "<p>The problem with specialization is not choosing the implementation but that rather that it allows unsound code.</p>",
        "id": 252625600,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1631194233
    }
]