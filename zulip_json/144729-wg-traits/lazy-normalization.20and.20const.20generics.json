[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>: I'm interested in working on lazy normalization. Is that currently blocked on further chalk integration, or are things at the point where it would be reasonable to start working on it?</p>",
        "id": 174403808,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567028612
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> a good question. I've been thinking that it would make sense to try and push it forward pre-Chalk. That was something I had planned to investigate tomorrow.</p>",
        "id": 174496794,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567116440
    },
    {
        "content": "<p>I was going to try and look for a \"coding partner\" to work on PRs; maybe that could be you? :)</p>",
        "id": 174496807,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567116457
    },
    {
        "content": "<p>Sounds good to me :)</p>",
        "id": 174504897,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567124890
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span>  and <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>. I'm trying to jump in on const generics generally.</p>\n<p>I'm just getting up to speed with, well, everything, but it sounds like lazy normalization is part of the real near-term solution for some const generics bugs. I want to keep on top of work around lazy normalization, but don't want to step on anyone's toes.</p>\n<p>If there's a way I can at least follow along with the lazy normalization development (and help out if desired), it would really help me contribute time effectively!</p>",
        "id": 174682752,
        "sender_full_name": "ranweiler",
        "timestamp": 1567383592
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"132179\">@ranweiler</span> and <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> -- so I spent some time investigating \"lazy norm\" but also const generics recently. I'll try to leave some notes here.</p>",
        "id": 174824800,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567541498
    },
    {
        "content": "<p>OK, so, I've done some digging, though I also got distracted by some other things.</p>",
        "id": 174833266,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567547859
    },
    {
        "content": "<p>One thing I've been doing is that I <a href=\"https://github.com/nikomatsakis/rust/tree/lazy-norm-anon-const\" target=\"_blank\" title=\"https://github.com/nikomatsakis/rust/tree/lazy-norm-anon-const\">created a branch</a> that \"fixes\" the generics of constants so that they properly inherit generics from their parents. This is currently ICEing with an assertion failure, and I'm trying to figure out why -- I have been doing some edits to dump more info because the current debug rules don't give enough.</p>",
        "id": 174833397,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567547973
    },
    {
        "content": "<p>The idea here is that this change is the one that is theoretically blocked by lazy norm, and I'd like to udnerstand why.  I suspect we can use the existing \"eager norm\" strategy here as well and it should work \"at least as well\" as it does for associated types today, but I'm not entirely sure.</p>",
        "id": 174833464,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567548006
    },
    {
        "content": "<p>(That's why I'd like to reproduce the problem)</p>",
        "id": 174833483,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567548018
    },
    {
        "content": "<p>Separately, I think what I'd like to do is to try integrating lazy norm into the compilation in a branch and just see what problems we hit. I spent a bit of time thinking about what that would mean -- but didn't get too far. I'm debating about how to get started, basically. One problem is that the existing code manually invokes normalization in all kinds of places ('eager norm'). I suppose it would suffice to insert some logic into unification to normalize-if-needed and then to remove some of those eager normalization locations -- we don't necessarily have to remove <em>all</em> of them.</p>",
        "id": 174833639,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567548140
    },
    {
        "content": "<p>Still, there are also some questions about the strategy that chalk is using right now -- so I spent some time thinking over alternatives there. I should leave some notes in <a href=\"https://github.com/rust-lang-nursery/chalk/issues/234\" target=\"_blank\" title=\"https://github.com/rust-lang-nursery/chalk/issues/234\">chalk#234</a>, but I have to run at the moment.</p>",
        "id": 174833704,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567548204
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> is there anything I can help with at the moment? Should I take a look at that branch, and see if I can figure out the root cause of the assertion failure?</p>",
        "id": 174842970,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567558619
    },
    {
        "content": "<p>Hello folks! I've been told that you, <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>, are the one to ask about anything relating to lazy-normalization, so I'm asking here: I've got a good amount of free time and would love to help get lazy normalization functional with const generics. Alas, opengl knowledge doesn't exactly help with contributing to rustc, or compilers in general, so I'm completely out of my waters and am bassically complete beginner wrt rustc. That stated, are there any problems suitable for first-time contributors that I could work on that would help you get this closer to being up and running?</p>",
        "id": 174844102,
        "sender_full_name": "Hal Gentz",
        "timestamp": 1567560404
    },
    {
        "content": "<blockquote>\n<p>is there anything I can help with at the moment? Should I take a look at that branch, and see if I can figure out the root cause of the assertion failure?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> yeah, sorry, those comments didn't arrive at an actionable state. Indeed if you wanted to look into the source of that assertion failure, it could be useful. </p>\n<p>What i've found is that the error is basically \"legit\" -- we are being asked to evaluate a predicate like this:</p>\n<div class=\"codehilite\"><pre><span></span>Binder(TraitPredicate(&lt;[u8; Const { ty: usize, val: Unevaluated(DefId(0:29231 ~ core[db27]::str[0]::pattern[0]::CharSearcher[0]::utf8_encoded[0]::{{constant}}[0]), [ReLateBound(DebruijnIndex(1), BrAnon(0))]) }] as marker::Sized&gt;))\n</pre></div>\n\n\n<p>this is rather hard to read but the key bit is the <code>ReLateBound(DebruijnIndex(1), BrAnon(0))</code> -- this basically says there is some region with debruijn index 1, but we only have 1 level of binder in scope here, so we would not expect a region with index &gt; 0. Now the question is where this type came from.</p>\n<p>I think it has something to do with the <code>core::Searcher</code> trait (which actually is a common source of assertion failures of this kind). I think it's arising when compiling this snippet:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Pattern</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">char</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Searcher</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">CharSearcher</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">into_searcher</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">haystack</span>: <span class=\"kp\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Searcher</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">utf8_encoded</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">utf8_size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">encode_utf8</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">utf8_encoded</span><span class=\"p\">).</span><span class=\"n\">len</span><span class=\"p\">();</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>My guess is that somewhere relatively early on we are somehow miscounting the depth or otherwise mishandling the <code>'a</code> that appears in there. I'm not quite sure. I guess maybe trying to minimize down the hunk of libcore that encouters the problem might be a start, i've done that in the past.</p>",
        "id": 174924824,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1567632610
    },
    {
        "content": "<p>I'm ending up with a different error message when I try to build your branch:</p>\n<div class=\"codehilite\"><pre><span></span>DEBUG 2019-09-05T21:04:30Z: rustc::traits::project: normalize_with_depth(depth=0, value=ImplHeader { impl_def_id: DefId(0:27284 ~ core[21ad]::array[0]::{{impl}}[61]), self_ty: [_; _], trait_ref: Some(&lt;[_; _] as default::Default&gt;), predicates: [Binder(TraitPredicate(&lt;_ as marker::Sized&gt;)), Binder(TraitPredicate(&lt;_ as default::Default&gt;))] })\nDEBUG 2019-09-05T21:04:30Z: rustc::traits::codegen: subst_and_normalize_erasing_regions(param_substs=[_], value=usize, param_env=ParamEnv { caller_bounds: [], reveal: All, def_id: None })\nDEBUG 2019-09-05T21:04:30Z: rustc::traits::query::normalize_erasing_regions: normalize_erasing_regions::&lt;&amp;rustc::ty::TyS&gt;(value=usize, param_env=ParamEnv { caller_bounds: [], reveal: All, def_id: None })\nerror: internal compiler error: src/librustc/ich/impls_ty.rs:213: ty::TyKind::hash_stable() - can&#39;t hash a TyVid _#1t.\n</pre></div>\n\n\n<p>I haven't been able to minimize it - however, it looks like an inference variable is still in a constant expression after rustc has expected it to be replaced</p>",
        "id": 175016023,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567718535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ^</p>\n<p>I think it might be caused by the fact that I'm using incremental compilation (<code>./x.py build -i</code>) - that stack trace involves hashing a type when a query is run</p>",
        "id": 175016046,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567718579
    },
    {
        "content": "<p>Minimized: <a href=\"https://gist.github.com/Aaron1011/8b69db43800e11a76a1c50d93fa91581\" target=\"_blank\" title=\"https://gist.github.com/Aaron1011/8b69db43800e11a76a1c50d93fa91581\">https://gist.github.com/Aaron1011/8b69db43800e11a76a1c50d93fa91581</a></p>",
        "id": 175016684,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567719060
    },
    {
        "content": "<p>This seems like a legitimate error - we're trying to run the const_eval query on a type that still has inference variables,, and we don't know how to hash that type for the query key.</p>\n<p>How should lazy normalization interact with incremental compilation? I would assume that we would want to skip caching any queries involving inference variables - but we'd probably want some way of marking which queries expect inference variables, to prevent any regressions</p>",
        "id": 175018416,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567720428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>: I made some progress on your lazy normalization branch here: <a href=\"https://github.com/Aaron1011/rust/tree/lazy-norm-anon-const\" target=\"_blank\" title=\"https://github.com/Aaron1011/rust/tree/lazy-norm-anon-const\">https://github.com/Aaron1011/rust/tree/lazy-norm-anon-const</a></p>\n<p>I found two main issues, which I (maybe) fixed on that branch:<br>\n1. Trait selection needs to have constants evaluated, since this can affect trait selection (e.g. <code>impl MyTrait for MyStruct&lt;{1 + 1}&gt;</code><br>\n2. The <code>const_eval</code> query was receiving types with inference variables in them. This is a more general problem, affecting any queries that attempt to do any sort of trait selection on types they receieve (e.g. <code>is_sized_raw</code>). When we canonicalize the predicate we're trying to select, we attempt to resolve any region inference variables found in the predicate. However, when we cross a query boundary, we create a new InferCtxt. This means that we end up trying to resolve inference variables from one InferCtxt in a completely different InferCtxt.<br>\nThe workaround I came up with was to replace all ReVars with ReErased when running const eval. However, this might be completely wrong - my goal was just to see how far the compiler could get.</p>\n<p>After applying those workaround, the compiler was able to build libcore, libstd, and several other crates. However, I wasn't able to fully bootstrap the stage1 compiler, due to a legitimate cycle error. Running const_eval eventually ended up needing to run <code>param_env</code> - since <code>param_env</code> does normalization, it needed to be able to const-eval the same type.</p>\n<p>Based on that, I don't think it's going to be possible to get further with 'const only' lazy normalization, - we'll need lazy normalization of associated types as well</p>",
        "id": 175200545,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1567978314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> cool! let me read a bit. that cycle error is precisely the one I want to uncover. I <em>suspect</em> though we can solve it the same way we solve normalization for associated types</p>",
        "id": 175263313,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568049844
    },
    {
        "content": "<p>I think the correct solution for inference variables might be 'serialize' part of the inferctxt state, and 'deserialize' it on the other side if the query boundary</p>",
        "id": 175263743,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568050145
    },
    {
        "content": "<p>That is, if we have <code>_#3r: _#2r </code> in the ParamEnv we pass to a query, we want to create new inference variables in the fresh InferCtxt such that <code>_#1r: _#0r</code>.</p>",
        "id": 175263910,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568050236
    },
    {
        "content": "<p>Since those regions constraints could affect trait selection run against the paramenv (e.g <code>impl&lt;'a, 'b: 'a&gt; MyTrait&lt;'a, 'b&gt; for MyType&lt;'a, 'b&gt;</code></p>",
        "id": 175264074,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568050334
    },
    {
        "content": "<blockquote>\n<p>I think the correct solution for inference variables might be 'serialize' part of the inferctxt state, and 'deserialize' it on the other side if the query boundary</p>\n</blockquote>\n<p>this is what canonicalization does</p>",
        "id": 175266469,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568051887
    },
    {
        "content": "<p>have you seen the <a href=\"https://rust-lang.github.io/rustc-guide/traits/canonical-queries.html\" target=\"_blank\" title=\"https://rust-lang.github.io/rustc-guide/traits/canonical-queries.html\">rustc-guide chapter</a> on that, btw?</p>",
        "id": 175266490,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568051905
    },
    {
        "content": "<p>well, it's not exactly what canonicalization does, but that's on purpose</p>",
        "id": 175266538,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568051930
    },
    {
        "content": "<p>It is similar - however, I think canonicicalization replaces <em>all</em> region variables.<br>\nFor the purposes of the query system, I think we only need to care about ReVar. For example, <code>MyType: MyTrait&lt;'static&gt;</code> is fine</p>",
        "id": 175267204,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568052191
    },
    {
        "content": "<p>I think early bound regions are fine too - e.g. <code>MyType: MyTrait&lt;'a&gt;</code>.<br>\nThe only problem is ReVar, because it references state that's encoded in the InferCtxt.</p>",
        "id": 175267282,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568052237
    },
    {
        "content": "<p>I'm working under the assumption that in general, queries might want to do things with the ParamEnv other than passing it to a SelectionCtxt.<br>\nThat is, we want to provide them with as much information as possible.</p>",
        "id": 175267435,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568052349
    },
    {
        "content": "<p>Would it make sense to introduce a weaker kind of canonicalization, which only deals with ReVar? We could change all queries taking <code>ParamEvn</code> to take a <code>WeakCanonicalized&lt;ParamEnv&gt;</code>, and remove the <code>Key</code> impl for <code>ParamEnv</code></p>",
        "id": 175269495,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568053707
    },
    {
        "content": "<p><code>WeakCanonicalized&lt;T&gt;</code> would have one method: <code>instantiate(infcx: &amp;InferCtxt)</code>, which would return a <code>T </code> with freshly created inference variables from the <code>InferCtxt</code></p>",
        "id": 175269585,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568053785
    },
    {
        "content": "<blockquote>\n<p>It is similar - however, I think canonicicalization replaces <em>all</em> region variables.<br>\nFor the purposes of the query system, I think we only need to care about ReVar. For example, <code>MyType: MyTrait&lt;'static&gt;</code> is fine</p>\n</blockquote>\n<p>It's better to replace all, it creates a more canonical result, and they don't impact the result in any way.</p>",
        "id": 175272273,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568055581
    },
    {
        "content": "<blockquote>\n<p>I'm working under the assumption that in general, queries might want to do things with the ParamEnv other than passing it to a SelectionCtxt.<br>\nThat is, we want to provide them with as much information as possible.</p>\n</blockquote>\n<p>Well, we'll see, but the current canonicalization system is designed in part to <em>restrict</em> what queries can do -- basically, I want to execute the query once and then be able to re-use the results for all possible lifetimes later</p>",
        "id": 175272378,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568055632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>: Does const-evaluation only use the ParamEnv for trait selection, then? Or does it only use it in ways where the specific lifetimes don't matter?</p>",
        "id": 175272614,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568055801
    },
    {
        "content": "<p>My concern was that some part of const evaluation might actually want to distinguish between <code>MyType: MyTrait&lt;_#0r&gt;</code> and <code>MyType: MyTrait&lt;'static&gt;</code>, but maybe that's never the case.</p>",
        "id": 175272720,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568055848
    },
    {
        "content": "<p>that should never be the case</p>",
        "id": 175273067,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568056098
    },
    {
        "content": "<blockquote>\n<p>Does const-evaluation only use the ParamEnv for trait selection, then? Or does it only use it in ways where the specific lifetimes don't matter?</p>\n</blockquote>\n<p>I think only for trait selection, correct</p>",
        "id": 175273119,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568056147
    },
    {
        "content": "<p>sounds reasonable. Should I take a shot at switching all queries that take a ParamEnv (<code>is_freeze_raw</code>, `const_eval, etc) to take a canonicalized ParamEnv?</p>",
        "id": 175273773,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568056575
    },
    {
        "content": "<p>I think that such a change could actually be landed independently of lazy normalization stuff. I don't think we would ever want region inference variables to move across a query boundary.</p>",
        "id": 175273909,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568056693
    },
    {
        "content": "<blockquote>\n<p>sounds reasonable. Should I take a shot at switching all queries that take a ParamEnv (<code>is_freeze_raw</code>, `const_eval, etc) to take a canonicalized ParamEnv?</p>\n</blockquote>\n<p>sounds great! keep me updated</p>",
        "id": 175273977,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568056794
    },
    {
        "content": "<p>I still haven't had time to dig into your commits btw, I hope to do so before end of day</p>",
        "id": 175274021,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1568056803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> After experimenting locally, I'm not sure that canonicalizing the ParamEnv is the best idea. Since it replaces <em>all</em> regions variables with inference variables, we end up with a lot of region variables in places where we wouldn't otherwise have them.</p>\n<p>The end result was the canonicalization was fairly 'infectious' - I had to start modifying a bunch of other places to handle canonicalizaiton and instantiating ParamEnvs. It's still not at the point where I can fully bootstrap the compiler</p>",
        "id": 175660127,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568405601
    },
    {
        "content": "<p>I'm starting to wonder if it might be easier to ban inference variables entirely in queries, and work backwards to see if we can find and eliminate them from where they creep in from lazy normalization (of constants)</p>",
        "id": 175660210,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568405660
    },
    {
        "content": "<p>I ran into <a href=\"https://github.com/rust-lang/rust/issues/64494\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64494\">https://github.com/rust-lang/rust/issues/64494</a> when working on this.</p>",
        "id": 175761122,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1568573461
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> argh, I thought I wrote you back, but it appears I didn't..? </p>\n<p>Anyway, the whole point of canon is to eliminate inference variables from queries, at least in a literal sense. </p>\n<p>I'm pretty sure that canonicalizing is the right approach, but maybe you can point me at your branch?</p>",
        "id": 176227642,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569011200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> After digging further, it turns out that some (maybe all?) of the need to canonicalize was coming from coherence checking. I ended up opening an issue regarding that: <a href=\"https://github.com/rust-lang/rust/issues/64494\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/64494\">https://github.com/rust-lang/rust/issues/64494</a></p>\n<p>I think we'll be able to sidestep this entire issue, and simultaneously get the proper coherence behavior, by adopting one of the two approaches I described in that issue.</p>",
        "id": 176228147,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1569011614
    },
    {
        "content": "<p>Either forbidding const expression in 'where' clauses from depending on generic parameters, or doing a deliberate overapproximation with respect to coherence.</p>\n<p>In either case, there shouldn't be any inference variables to worry about in const eval. Either there are no generic parameters (and therefore nothing to worry about replacing), or we treat the impl as 'potentially always applying' (in which case there is no need to actually do const eval during coherence checking)</p>",
        "id": 176228265,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1569011717
    },
    {
        "content": "<p>Oops - I think I replied to the wrong thread</p>",
        "id": 176228291,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1569011745
    },
    {
        "content": "<p>no, seems right</p>",
        "id": 176228353,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1569011791
    },
    {
        "content": "<p>Still trying to figure out how zulup works ;P</p>",
        "id": 176228390,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1569011830
    },
    {
        "content": "<p>I think I'll take a shot at implementing the conservative restriction suggested by <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span>, where we forbid arbitrary const expression in <code>where</code> clauses. That will allow us to skip const evaluation in where claues, and instead perform a direct comparison between const parameters when doing coherence checking.</p>\n<p>If we ever expand which kinds of const expressions are allowed in 'where' claues, we could just modify the coherence check to take that into account.</p>",
        "id": 176229173,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1569012514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> so I started reading your branch</p>",
        "id": 177369570,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570215815
    },
    {
        "content": "<p>I am trying to remember</p>",
        "id": 177369596,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570215840
    },
    {
        "content": "<p>Do we have a canonical example yet of what \"goes wrong\"</p>",
        "id": 177369668,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570215880
    },
    {
        "content": "<p>in the absence of lazy norm</p>",
        "id": 177369676,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570215888
    },
    {
        "content": "<p>I've asked <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> and <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> about this before ..</p>",
        "id": 177369705,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570215909
    },
    {
        "content": "<p>/me goes back to do some more experiments</p>",
        "id": 177369736,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570215948
    },
    {
        "content": "<p>OK so</p>",
        "id": 177376237,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570220940
    },
    {
        "content": "<p>I returned to my original branch <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span></p>",
        "id": 177376245,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570220949
    },
    {
        "content": "<p>fixed a bug in the type folding code for constants</p>",
        "id": 177376255,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570220957
    },
    {
        "content": "<p>that is what was causing the ICE -- not sure if you told me that already :)</p>",
        "id": 177376260,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570220965
    },
    {
        "content": "<p>now i'm seeing this</p>",
        "id": 177376263,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570220968
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>error[E0391]: cycle detected when processing `x86_64::sse2::&lt;impl at /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:524:1: 544:2&gt;::{{constant}}#0`\n   --&gt; /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:526:27\n    |\n526 |     Self: MultiLane&lt;[u32; 4]&gt;,\n    |                           ^\n    |\nnote: ...which requires processing `x86_64::sse2::&lt;impl at /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:524:1: 544:2&gt;::{{constant}}#0`...\n   --&gt; /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:526:27\n    |\n526 |     Self: MultiLane&lt;[u32; 4]&gt;,\n    |                           ^\nnote: ...which requires const-evaluating + checking `x86_64::sse2::&lt;impl at /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:524:1: 544:2&gt;::{{constant}}#0`\\\n...\n   --&gt; /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:526:27\n    |\n526 |     Self: MultiLane&lt;[u32; 4]&gt;,\n    |                           ^\nnote: ...which requires const-evaluating + checking `x86_64::sse2::&lt;impl at /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:524:1: 544:2&gt;::{{constant}}#0`\\\n...\n   --&gt; /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:526:27\n    |\n526 |     Self: MultiLane&lt;[u32; 4]&gt;,\n    |                           ^\nnote: ...which requires const-evaluating `x86_64::sse2::&lt;impl at /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:524:1: 544:2&gt;::{{constant}}#0`...\n   --&gt; /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:526:27\n    |\n526 |     Self: MultiLane&lt;[u32; 4]&gt;,\n    |                           ^\n    = note: ...which again requires processing `x86_64::sse2::&lt;impl at /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:524:1: 544:2&gt;::{{constant}}#0`, com\\\npleting the cycle\nnote: cycle used when const-evaluating `x86_64::sse2::&lt;impl at /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:524:1: 544:2&gt;::{{constant}}#0`\n   --&gt; /home/nmatsakis/.cargo/registry/src/github.com-1ecc6299db9ec823/ppv-lite86-0.2.5/src/x86_64/sse2.rs:526:27\n    |\n526 |     Self: MultiLane&lt;[u32; 4]&gt;,\n    |                           ^\n</pre></div>",
        "id": 177376265,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570220975
    },
    {
        "content": "<p>which I think is the cycle error I've been looking for</p>",
        "id": 177376277,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570220986
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>query stack during panic:\n#0 [const_eval_raw] const-evaluating `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#1 [const_eval] const-evaluating + checking `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#2 [const_eval] const-evaluating + checking `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#3 [param_env] processing `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#4 [typeck_tables_of] processing `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#5 [const_eval_raw] const-evaluating `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#6 [const_eval] const-evaluating + checking `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#7 [const_eval] const-evaluating + checking `&lt;x86_64::sse2::u32x4_sse2&lt;S3, x86_64::YesS4, NI&gt; as types::types::Vec4&lt;u32&gt;&gt;::{{constant}}#0`\n#8 [specialization_graph_of] processing `types::types::Vec4`\n#9 [coherent_trait] coherence checking all impls of trait `types::types::Vec4`\n#10 [analysis] running analysis passes on this crate\nend of query stack\n</pre></div>",
        "id": 177379835,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570223820
    },
    {
        "content": "<p>OK, I'm catching up now to the cycle you were talking about <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> . I'll read that issue then leave some thoughts.</p>",
        "id": 177380759,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570224567
    },
    {
        "content": "<p>OK, I've been doing more exploration. <a href=\"https://hackmd.io/S8cE-e-ORtCqjJzyOU5cLQ\" target=\"_blank\" title=\"https://hackmd.io/S8cE-e-ORtCqjJzyOU5cLQ\">Here is a doc with my current thoughts</a></p>",
        "id": 177566312,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1570486762
    },
    {
        "content": "<p>Hello, I'm interested in having a look around and experimenting with this. The current branch that I'm working on is here: <a href=\"https://github.com/skinny121/rust/tree/lazy-norm-anon-const\" target=\"_blank\" title=\"https://github.com/skinny121/rust/tree/lazy-norm-anon-const\">https://github.com/skinny121/rust/tree/lazy-norm-anon-const</a>, I started off by building on top of both <span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> and <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> branches and then started to implement the <code>ConstEquate</code> obligations outlined in the above doc. </p>\n<p>The current problem I have is demonstrated with the following:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>When it computs if these two impls overlap, It tries to equate the two constants, but with my current code, it can't due to type variables appearing within the <code>substs</code> of the unevaluated consts. The error message with -Z verbose is:<br>\n'conflicting implementations of trait <code>A</code> for type <code>[_#0t; Const { ty: usize, val: Unevaluated(DefId(0:6 ~ main[317d]::{{impl}}[0]::{{constant}}[0]), [_#0t]) }]</code>'.</p>\n<p>Should we somehow filter the <code>subsets</code> so that they only contain the substitutions that are actually being used within the const?</p>",
        "id": 180404702,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1573459321
    },
    {
        "content": "<p>did anything happen here <span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span>, <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>? I'm keen for this to move forward!</p>",
        "id": 180777864,
        "sender_full_name": "varkor",
        "timestamp": 1573767459
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> No I haven't done anything more since that comment.</p>",
        "id": 180794448,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1573781371
    },
    {
        "content": "<p>Argh, <span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span> sorry for not getting back to you. I've had your comment starred for some time.</p>",
        "id": 180906783,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573900024
    },
    {
        "content": "<p>Well, since Nov 11 :)</p>",
        "id": 180906786,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573900027
    },
    {
        "content": "<p>I think the nswer is that we ned to canonicalize those substs, but let me check out your branch itself. BTW, if you have time to press on this, maybe we should consider setting up a regular meeting time <span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span> ? I'd like to actually answer you in a timely fashion.</p>",
        "id": 180906840,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1573900109
    },
    {
        "content": "<p>I do have some time to dedicate to this, though my timezone is UTC +13, which might make it a little difficult.</p>",
        "id": 180948427,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1573978830
    },
    {
        "content": "<p>BTW as a workaround, I used <code>self.selcx.infcx().freshen(substs)</code> to remove the inference variables which worked but canonicalizing it should better.</p>",
        "id": 180948654,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1573979353
    },
    {
        "content": "<p>OK, well, <span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span>, I'm back now and trying to get up to speed. Do you have more updates on that branch? I suppose I will schedule <em>myself</em> some time to review your branch and try to provide you with feedback to start (and/or help to push things along).</p>",
        "id": 183006256,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1575929978
    },
    {
        "content": "<p>I'm at UTC-05:00, so that is indeed a formidable time difference. =)</p>",
        "id": 183006337,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1575930011
    },
    {
        "content": "<p>Since my last comment, I have managed to get the standard library compiling and most of the tests passing. I did discover that my workaround above isn't sufficient and we do need to turn <code>const_eval</code> queries into canonical queries. For preparation for that, I opened <a href=\"https://github.com/rust-lang/rust/pull/66877\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/66877\">https://github.com/rust-lang/rust/pull/66877</a> to reduce the number of places that invoking the underlying query.</p>\n<p>Some other problems are:</p>\n<ul>\n<li>Constants can't be evaluated when they are printed as it causes cycles. This is the cause of most of the remaining failing tests.</li>\n<li><code>let p: &amp;[[u8; 2]] = unsafe {&amp;*(p as *const [[u8; 2]])};</code>Here, the <code>CastCheck</code> doesn't quite work correctly, it passes <code>try_coercion_cast</code> though it shouldn't as it has a <code>ConstEquate</code> obligations which will not be satisfied.</li>\n</ul>",
        "id": 183037320,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1575964864
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span> great! I didn't get time to look into that today, I'm doing other reviewing now, but I'll try to earmark some time for tomorrow</p>",
        "id": 183107305,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576015153
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span> do you plan to to turn constants into canonical queries (which I definitely agree is a good step) before the other changes on that branch? I'm reviewing the code there but there's a lot of diffs atm so I've not quite figured out if it's doing what I expected or not yet :)</p>",
        "id": 183662794,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576598923
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Yes  that's the plan, I have a branch with it mostly done(<a href=\"https://github.com/rust-lang/rust/compare/master...skinny121:canonicalize-const-eval?expand=1\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/compare/master...skinny121:canonicalize-const-eval?expand=1\">https://github.com/rust-lang/rust/compare/master...skinny121:canonicalize-const-eval?expand=1</a>). I just need to figure out a couple of small issues first before I create a PR for it.</p>",
        "id": 183915700,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1576828646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span> great, maybe I'll take a look at that branch first then</p>",
        "id": 183926073,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576839600
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Do you think it would be a good idea for me to create a PR with my initial lazy normization work, but hide it behind a <code>-Z lazy-normalization</code> flag?</p>",
        "id": 184562367,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1577821636
    },
    {
        "content": "<p>That would mean that the work can be broken down into multiple PRs to avoid having one massive PR. Also would allow it to be experimented with by others before we enable it by default.</p>",
        "id": 184562531,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1577821865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224180\">@Ben Lewis</span> I think you did so, right? seems good. I'm hoping to finish reviewing your first one today.</p>",
        "id": 184935046,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1578337053
    },
    {
        "content": "<p>Yes, I went ahead and implemented it.</p>",
        "id": 184986164,
        "sender_full_name": "Ben Lewis",
        "timestamp": 1578379048
    }
]