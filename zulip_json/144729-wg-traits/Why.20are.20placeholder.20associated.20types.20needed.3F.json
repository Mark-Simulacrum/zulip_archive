[
    {
        "content": "<p>What's exactly the purpose of the \"placeholder associated types\" in chalk/rustc? </p>\n<p>It seems to me they can always be replaced with type variables, like this for example: </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&gt;</span>::<span class=\"n\">Assoc</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">Trait</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"o\">-</span>-&gt;\n\n<span class=\"nc\">fn</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">Trait</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&gt;</span>::<span class=\"n\">Assoc</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ProjectionEq(&lt;T as Trait&gt;::Assoc = U)</span>\n</code></pre></div>",
        "id": 275008182,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647020758
    },
    {
        "content": "<p>like, never have <code>&lt;T as Trait&gt;::Assoc</code> as a <em>type</em>, just as <em>constraints</em> on types, what Chalk calls <code>ProjectionEq</code></p>",
        "id": 275008344,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647020830
    },
    {
        "content": "<p>this would get rid of the ambiguity of <a href=\"https://github.com/rust-lang/chalk/issues/234\">chalk#234</a>, wouldn't it?</p>",
        "id": 275008386,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647020852
    },
    {
        "content": "<p>This is actually a really good question</p>",
        "id": 275010831,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647021875
    },
    {
        "content": "<p>So, let's start with Chalk</p>",
        "id": 275010917,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647021914
    },
    {
        "content": "<p>First, there are two \"forms\" of associated types. Either a <a href=\"https://github.com/rust-lang/chalk/blob/f470f2f493203f58d493c7221863bca2ce1a6dad/chalk-ir/src/lib.rs#L651\"><code>AliasTy::Projection</code></a> or as an <a href=\"https://github.com/rust-lang/chalk/blob/f470f2f493203f58d493c7221863bca2ce1a6dad/chalk-ir/src/lib.rs#L585\">associated type placeholder</a></p>",
        "id": 275011168,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022032
    },
    {
        "content": "<p>The former is \"unnormalized\", whereas the latter is somewhat of a \"fallback\" when there isn't enough info to normalize</p>",
        "id": 275011277,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022081
    },
    {
        "content": "<p>Somewhat interestingly, we do something like you suggest above when we <em>relate</em> alias types</p>",
        "id": 275011452,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022158
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/chalk/blob/f470f2f493203f58d493c7221863bca2ce1a6dad/chalk-solve/src/infer/unify.rs#L455\">https://github.com/rust-lang/chalk/blob/f470f2f493203f58d493c7221863bca2ce1a6dad/chalk-solve/src/infer/unify.rs#L455</a></p>",
        "id": 275011461,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022163
    },
    {
        "content": "<p>I think when I was playing around with <a href=\"https://github.com/rust-lang/chalk/issues/234\">chalk#234</a> a while ago, I <em>did</em> try to essentially do something to this effect, where we sort of \"always\" treat associated types as \"inference variables\" of sort</p>",
        "id": 275011674,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022252
    },
    {
        "content": "<p>The issue I ran into, IIRC, was we still want to give some kind of meaningful answer when all we know is <code>&lt;T as Trait&gt;::Assoc</code></p>",
        "id": 275011780,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022315
    },
    {
        "content": "<p>Now, let's switch to rustc for a second.</p>",
        "id": 275011863,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022345
    },
    {
        "content": "<p>Now, rustc <em>doesn't</em> have the associated type placeholder, only the equivalent of <code>AliasTy::Projection</code></p>",
        "id": 275011907,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022369
    },
    {
        "content": "<p>when normalizing it either 1) fully normalizes or 2) Creates a <code>ProjectionEq</code> obligation and returns that inference var</p>",
        "id": 275011984,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022413
    },
    {
        "content": "<p>Well <em>or</em> it just doesn't do anything (this was pretty recent and only in fulfill)</p>",
        "id": 275012032,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022434
    },
    {
        "content": "<p>But, sort of importantly, when relating types, rustc doesn't know what to do with \"unnormalized\" projections</p>",
        "id": 275012136,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022474
    },
    {
        "content": "<p>Now, it's quite interesting. Because <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> and I just had a short chat the other day about this. His revelation was \"what if we never actually normalize\" - of course a bit more nuanced</p>",
        "id": 275012271,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022540
    },
    {
        "content": "<p>Noting that this is sort of how <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>'s TAIT work does things</p>",
        "id": 275012410,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022601
    },
    {
        "content": "<p>Imo, this <em>is</em> eventually going to be the right path</p>",
        "id": 275012454,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022619
    },
    {
        "content": "<p>But there is a bit of nuance to it</p>",
        "id": 275012468,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022627
    },
    {
        "content": "<p>Once case Niko brought up is</p>\n<div class=\"codehilite\"><pre><span></span><code>trait Mirror&lt;&#39;a&gt; { type Me = Self; }\nexists&lt;T&gt; { forall&lt;&#39;a&gt; { &lt;i32 as Mirror&lt;&#39;a&gt;&gt;::Me = T } }\n</code></pre></div>",
        "id": 275012685,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022711
    },
    {
        "content": "<p>Does that help any? It doesn't necessarily answer your question (mostly because I don't have an answer). But it does give some background.</p>",
        "id": 275012919,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647022824
    },
    {
        "content": "<p>I.. don't know, that's a lot to take in <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 275013244,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647022981
    },
    {
        "content": "<p>so, it could work?</p>",
        "id": 275013482,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023111
    },
    {
        "content": "<p>Maybe :)</p>",
        "id": 275013562,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647023140
    },
    {
        "content": "<p>one issue is, in my example above, if rustc asks \"what is U\" chalk will answer \"I don't know\", but rustc wants \"I know, it's &lt;T as Trait&gt;::Assoc\"?</p>",
        "id": 275013678,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023180
    },
    {
        "content": "<p>Correct</p>",
        "id": 275013761,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647023224
    },
    {
        "content": "<p>but that's due to how rustc is implemented <em>today</em> isn't it?</p>",
        "id": 275013817,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023263
    },
    {
        "content": "<p>like, if this \"lower projection to inference vars\" was done much earlier, in rustc instead of chalk, this wouldn't be an issue?</p>",
        "id": 275013909,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023296
    },
    {
        "content": "<p>Mmm, not necessarily</p>",
        "id": 275013910,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647023296
    },
    {
        "content": "<p>But maybe</p>",
        "id": 275013973,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647023327
    },
    {
        "content": "<p>I guess it depends on what is being solved</p>",
        "id": 275014162,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647023407
    },
    {
        "content": "<p>maybe chalk could do the \"lower into inference var\", then solve, then if it can't infer what U is, check whether it managed to prove <code>ProjectionEq(&lt;T as Trait&gt;::Assoc = U)</code> then \"reverse engineer\" that back into \"I know, U is  &lt;T as Trait&gt;::Assoc\"?</p>",
        "id": 275014515,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023577
    },
    {
        "content": "<p>seems like a hack</p>",
        "id": 275014539,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023589
    },
    {
        "content": "<p>like, make placeholder associated types not exist at all during solving. They would only exist after this final step that \"nicely packages up\" learned knowledge to feed back into rustc...?</p>",
        "id": 275014949,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023765
    },
    {
        "content": "<p>Hmm</p>",
        "id": 275015204,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647023899
    },
    {
        "content": "<p>or alternatively, allow chalk to feed back learned obligations into rustc, like it currently does with lifetime constraints. No idea how that'd work though</p>",
        "id": 275015355,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647023998
    },
    {
        "content": "<p>well, there won't be any \"learned obligations\"</p>",
        "id": 275015446,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647024048
    },
    {
        "content": "<p>Really, with both, the entrypoint is one obligation with an enviroment</p>",
        "id": 275015526,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647024098
    },
    {
        "content": "<p>And the exit is a \"yes\", \"no\", or \"yes, with these constraints\"</p>",
        "id": 275015554,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647024114
    },
    {
        "content": "<p>\"learned constraint\" then?</p>",
        "id": 275015615,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647024135
    },
    {
        "content": "<p>Maybe</p>",
        "id": 275024169,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647027796
    },
    {
        "content": "<p>so, just to confirm my understanding. Given this program:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Struct</span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275032592,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647032106
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>?- exists&lt;T&gt; { T = &lt;Struct as Trait&gt;::Assoc }\nAmbiguous; no inference guidance\n</code></pre></div>\n<p>we want this to return \"Unique, T = u8\"</p>",
        "id": 275032628,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647032135
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>?- exists&lt;T, U&gt; { T = &lt;U as Trait&gt;::Assoc }\nAmbiguous; no inference guidance\n</code></pre></div>\n<p>we want this to return \"Ambig(Definite), T = &lt;U as Trait&gt;::Assoc\"</p>",
        "id": 275032751,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647032210
    },
    {
        "content": "<p>is that right?</p>",
        "id": 275032761,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647032216
    },
    {
        "content": "<p>(edited the 2nd, had mixed up forall vs exists)</p>",
        "id": 275033792,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647032825
    },
    {
        "content": "<p>I think so</p>",
        "id": 275034045,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647032995
    },
    {
        "content": "<p>so, I completely removed TyKind::AssociatedType. That makes the first work, but the second break</p>",
        "id": 275034346,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647033151
    },
    {
        "content": "<p>I want to make the solver return \"Unique; T=T, U=U with the constraint <code>AliasEq(&lt;U as Trait&gt;::Assoc = T)</code>\"</p>",
        "id": 275035082,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647033581
    },
    {
        "content": "<p>And then transform that into \"Unique; T=&lt;U as Trait&gt;::Assoc, U=U\" as some \"post-processing\" step</p>",
        "id": 275035197,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647033633
    },
    {
        "content": "<p>kinda like the anti-unifier..??</p>",
        "id": 275035331,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647033716
    },
    {
        "content": "<p>Hehe</p>",
        "id": 275035396,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647033731
    },
    {
        "content": "<p>So for SLG, the delayed subgoals <em>might</em> be a decent way to handle this</p>",
        "id": 275035442,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647033759
    },
    {
        "content": "<p>is there already some way to tell the solver \"you can give me back these goals as constraints if you need to\"?</p>",
        "id": 275035636,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647033875
    },
    {
        "content": "<p>no</p>",
        "id": 275035812,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647033966
    },
    {
        "content": "<p>only lifetime constraints</p>",
        "id": 275035827,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647033976
    },
    {
        "content": "<p>But SLG does have these \"delayed subgoals\"</p>",
        "id": 275035862,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647033994
    },
    {
        "content": "<p>hmm I'll read to see how the lifetime constraints are handled<br>\nthese feel very similar to what we want here</p>",
        "id": 275035885,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1647034007
    },
    {
        "content": "<p>But I don't really think they would work</p>",
        "id": 275035891,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647034009
    },
    {
        "content": "<p>But they might</p>",
        "id": 275035893,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647034012
    },
    {
        "content": "<p>I think more likely, we need a way to be able to \"bind\" an inference variable to multiple types</p>",
        "id": 275035949,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647034052
    }
]