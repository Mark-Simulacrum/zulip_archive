[
    {
        "content": "<p>I've tried to look into the Chalk and while some things are quite intuitive other are not (or may look like a bug).</p>\n<p>Going into one of the issues I've found in a list of pushed clauses a line like<br>\n<code>for&lt;type, type&gt; WellFormed(^0.0: Combine&lt;^0.1&gt;) :- ForAll&lt;&gt; { WellFormed(^1.1: HList) }, Implemented(^0.0: Combine&lt;^0.1&gt;)</code></p>\n<p>There are other clauses like this for which I do not see any problem, like <code>for&lt;type, type&gt; AliasEq(&lt;&lt;Exact&lt;Uint(Usize)&gt; as FilterBase&gt;::Extract as Tuple&gt;::HList = ^0.0) :- AliasEq(&lt;^0.1 as Tuple&gt;::HList = ^0.0), AliasEq(&lt;Exact&lt;Uint(Usize)&gt; as FilterBase&gt;::Extract = ^0.1)</code> or similar that form a closure over <code>0.0</code>, <code>0.1</code>, an potentially other variables. If I get it right then it reads something like: <code>^0.0</code> is some <code>HList</code> for chain of traits and associated types iff there exists some type <code>0.1</code> when considered as <code>Tuple</code> gives it's <code>HList</code> as <code>^0.0</code>, and if out initial chain of traits and associated types can be stopped in a middle and this type is some <code>0.1</code>. </p>\n<p>On the other side <code>for&lt;type, type&gt; WellFormed(^0.0: Combine&lt;^0.1&gt;) :- ForAll&lt;&gt; { WellFormed(^1.1: HList) }, Implemented(^0.0: Combine&lt;^0.1&gt;)</code> doesn't form a closure - it biases the fact that <code>0.0</code> is well-formed <code>Combine&lt;0.1&gt;</code> on some  I believe unrelated fact that some other type <code>1.1</code> is well-formed <code>HList</code>. Should I read it like that <code>there should exist an implementation of HList</code>, or is it a plain bug?</p>\n<p>Based on definition</p>\n<div class=\"codehilite\"><pre><span></span><code>            trait Combine&lt;T&gt;\n            where\n              T: HList\n            {\n              type Output: HList;\n            }\n</code></pre></div>\n<p>I think it should be <code>for&lt;type, type&gt; WellFormed(^0.0: Combine&lt;^0.1&gt;) :- ForAll&lt;&gt; { WellFormed(^0.1: HList) }, Implemented(^0.0: Combine&lt;^0.1&gt;)</code> (note <code>1.1</code> -&gt; <code>0.1</code> change in <code>WellFormed(^0.1: HList) </code></p>",
        "id": 275165440,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1647192459
    },
    {
        "content": "<p>There's a <code>ForAll&lt;&gt;</code> wrapped around that <code>WellFormed</code> goal. So it is indeed <code>^1.1</code>, since it refers to the second type in <code>for&lt;type, type&gt;</code></p>",
        "id": 275165671,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647192742
    },
    {
        "content": "<p>Is there any doc on indexing of <code>for&lt;type, type&gt;</code> and how <code>0.0</code>, <code>0.1</code> and <code>1.x</code> related? This one I couldn't figure out yet to be completely sure in my inderstanding</p>",
        "id": 275165758,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1647192882
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/chalk/book/glossary.html\">https://rust-lang.github.io/chalk/book/glossary.html</a></p>",
        "id": 275165824,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647192969
    },
    {
        "content": "<p>The \"De Bruijn Index\" section specifically</p>",
        "id": 275165833,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647192991
    },
    {
        "content": "<p>Ok, so basically <code>for&lt;type, type&gt; WellFormed(^0.0: Combine&lt;^0.1&gt;) :- ForAll&lt;&gt; { WellFormed(^1.1: HList) }, Implemented(^0.0: Combine&lt;^0.1&gt;)</code> means that type <code>0</code> in scope 0 is <code>Combine</code> over type <code>1</code> in scope <code>0</code> iff for all types <code>1</code> in some other scope <code>1</code> the type is <code>HList</code>?</p>",
        "id": 275166367,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1647193801
    },
    {
        "content": "<p>the <code>^1.1</code> is referring to the same type as the <code>^0.1</code>s. The first number basically how many binders (<code>ForAll</code> or <code>for</code> or <code>Exists</code>) you're skipping to find the one you're referring to, so when you 'enter' the <code>ForAll</code> anything that would previously have been <code>^0.x</code> is now <code>^1.x</code>, and so on. DeBruijn indices can be a bit confusing at first, but the nice thing is that they're kind of 'local' (you can just take parts of an expression and they make sense)</p>",
        "id": 275170388,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1647199267
    },
    {
        "content": "<p>I think it's what I've meant. Most likely i've found a problem for the issue I'm investigating, now trying to find out how to fix it</p>",
        "id": 275170471,
        "sender_full_name": "Alex Vlasov",
        "timestamp": 1647199338
    },
    {
        "content": "<p>also, the <code>ForAll&lt;&gt;</code> is basically a noop since it doesn't introduce any new bound variables. The example could also be written <code>for&lt;type, type&gt; WellFormed(^0.0: Combine&lt;^0.1&gt;) :- WellFormed(^0.1: HList), Implemented(^0.0: Combine&lt;^0.1&gt;)</code>, this is probably just an artifact of how the clauses are generated</p>",
        "id": 275170505,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1647199397
    }
]