[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Self</span>: <span class=\"nc\">Functor</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">map</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"bp\">Self</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249419826,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892311
    },
    {
        "content": "<p>That looks about right</p>",
        "id": 249419866,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892334
    },
    {
        "content": "<p>My apologies- it appears renaming a topic breaks it apart. I can try to rename it back? I turned it into <a class=\"stream-topic\" data-stream-id=\"144729\" href=\"/#narrow/stream/144729-wg-traits/topic/Self-update.20syntax.20and.20HKT.20via.20GATs\">#wg-traits &gt; Self-update syntax and HKT via GATs</a></p>",
        "id": 249420114,
        "sender_full_name": "Zoey",
        "timestamp": 1628892491
    },
    {
        "content": "<p>I think I can fix</p>",
        "id": 249420204,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892569
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"398288\">@Zoey</span> any thoughts on the above</p>",
        "id": 249420400,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892705
    },
    {
        "content": "<p>Interestingly, there's actually no GATs</p>",
        "id": 249420461,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892729
    },
    {
        "content": "<p>I feel like <code>Self::New</code> may be more conceptually appropriate naming in this case, but that isn't reserved. Is <code>Self::Self</code> currently illegal?</p>\n<p><code>Self::Self</code> feels redundant to me, and it makes the syntax for supertrait updates even more verbose and potentially confusing: <code>&lt;Self as MySuperTrait&gt;::Self&lt;overrides...&gt;</code></p>\n<p>Also, I realize now that GATs are not strictly necessary to resolve this if it's a built-in, but - without GATs - the actual associated type, whatever its name, cannot actually be represented in Rust without GATs, so - without them - it becomes more than a syntactic sugar.</p>",
        "id": 249420725,
        "sender_full_name": "Zoey",
        "timestamp": 1628892899
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 249420965,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628893077
    },
    {
        "content": "<p>Hmm, I don't think this can be represented with GATs</p>",
        "id": 249421018,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628893106
    },
    {
        "content": "<p>And I was only using the Self associated type about a point for \"desugaring\"</p>",
        "id": 249421032,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628893128
    },
    {
        "content": "<p>I think just the <code>Self&lt;Item=U&gt;</code> sugar is \"better\"</p>",
        "id": 249421063,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628893171
    },
    {
        "content": "<p>I’ve only skimmed the discussion but you might be interested in looking at my own attempt at encoding Monads in Rust a while ago:</p>\n<p><a href=\"https://users.rust-lang.org/t/monads-in-rust-with-gats/50487\">https://users.rust-lang.org/t/monads-in-rust-with-gats/50487</a></p>\n<p>(make sure to click the playground link for the details; and perhaps ignore the stuff around <code>Clone1</code> if you want to focus on the <code>Monad</code> side of things)</p>",
        "id": 249429316,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1628901824
    },
    {
        "content": "<p>In particular, it contains some approaches to make sure that nonsensical implementations that change around the types aren’t allowed. You implement <code>Monad</code> on a dummy type that acts as a stand-in for the type constructor (that type implements <code>TyCon</code>, then you <del>can</del> <em>have to</em> link that dummy type to the actual type with another trait (<code>HasTyCon</code>) but that trait has constraints that the type constructor applied to the right parameter <em>must</em> indeed create the right type again.</p>",
        "id": 249429481,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1628902020
    },
    {
        "content": "<p>Then, you can get method syntax and IIRC halfways decent interaction with type inference…</p>\n<p>I think from my short exploration there, it’s also clear that it’s not trivial how best to address Rust’s ownership model for functional traits like <code>Monad</code> and <del>polymorphic</del> generic functions involving them.</p>",
        "id": 249429749,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1628902403
    },
    {
        "content": "<p>Hello <span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span> !<br>\nI just read through and played with your implementation for a while; it seems to have the same fundamental limitations as my <code>Id</code> trait mechanism in the opening post:</p>\n<ul>\n<li>Only one type can be passed to the type constructor, so multi-parameter typeclasses are still unavailable without variadic generics support </li>\n<li>The implementation can lie- in this case, <code>TyCon</code> itself is the point where a lie may occur.</li>\n</ul>\n<p>I see these additional disadvantages:</p>\n<ul>\n<li>Significant boilerplate, macro invocations required for concise usage at the implementations rather than just the definitions</li>\n<li>Passing around actual values as witnesses- probably not a runtime concern, as they're ZSTs, but it complicates things significantly</li>\n</ul>\n<p>And this possible advantage:</p>\n<ul>\n<li>MonadVal indicates a potential hole in my evaluation for typeclass categories - I was primarily considering immutable semantics, not mutation</li>\n<li><code>do</code> computations - I'm not sure how my style would work with these- and I'm curious if we can convert this behaviour - not to the Id trait - but to a <code>Self</code>-update syntax backing</li>\n</ul>",
        "id": 249432958,
        "sender_full_name": "Zoey",
        "timestamp": 1628906486
    },
    {
        "content": "<p>This was my implementation a while ago:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FunctorFamily</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">fmap</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">ApplicativeFamily</span>: <span class=\"nc\">FunctorFamily</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">pure</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">inner</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">apply</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MonadFamily</span>: <span class=\"nc\">ApplicativeFamily</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bind</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">OptionType</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">FunctorFamily</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">OptionType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">fmap</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">ApplicativeFamily</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">OptionType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">pure</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">inner</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">inner</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">apply</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">zip</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MonadFamily</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">OptionType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bind</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">and_then</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249436850,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628910801
    },
    {
        "content": "<p>I'm not sure whether this link is usable, but the whole post is here: <a href=\"https://zhuanlan.zhihu.com/p/369302538\">https://zhuanlan.zhihu.com/p/369302538</a></p>",
        "id": 249436856,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628910828
    },
    {
        "content": "<p>This implementation exhibits the unlawful implementation issue and the enforcement falls down to the implementation rather than the definition.</p>\n<p>I will say it's pretty concise for what was available prior to GATs, at least. I believe they are an incremental improvement, followed by the proposed Self-update syntax.</p>",
        "id": 249437228,
        "sender_full_name": "Zoey",
        "timestamp": 1628911083
    },
    {
        "content": "<p>By \"unlawful implementation\" did you mean the implementation of, say \"bind\" is not correct in principle, or did you mean the function signatures could be incorrect? If the later, I can't see how...</p>",
        "id": 249438532,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628912804
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">FunctorFamily</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">OptionType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"nb\">static</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">fmap</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">ok_or</span><span class=\"p\">(</span><span class=\"s\">\"UwU\"</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Edit:<br>\nOh wait- I see! The type being bound there prevents it but now we're talking about results the whole time. Okay, how do you propose passing around the OptionType type; what does an invocation site look like?</p>",
        "id": 249438614,
        "sender_full_name": "Zoey",
        "timestamp": 1628912900
    },
    {
        "content": "<p>I think a big question that should be answered here: <em>why</em> are implementations like this discouraged?</p>",
        "id": 249438621,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628912944
    },
    {
        "content": "<p>Sure, then <code>OptionType</code> corresponds to <code>Result</code> despite its name. I think this is not incorrect?</p>",
        "id": 249438626,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628912962
    },
    {
        "content": "<p>In current rust, it will be  <code>OptionType::fmap(..., ...)</code>, but this might be covered by <code>arbitrary-self-types</code> in the future, if it's worth it, i think?</p>",
        "id": 249438714,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628913035
    },
    {
        "content": "<p>Arbitrary self types are hard</p>",
        "id": 249438723,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913064
    },
    {
        "content": "<p>Indeed!</p>",
        "id": 249438727,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628913071
    },
    {
        "content": "<p>I wouldn't bet on something like this working</p>",
        "id": 249438731,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913093
    },
    {
        "content": "<p>(For arbitrary self types)</p>",
        "id": 249438737,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913103
    },
    {
        "content": "<p>But, I could be wrong</p>",
        "id": 249438785,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913147
    },
    {
        "content": "<p>I think a benefit of this approach compared to <code>Id</code> is that you don't have to match the self type with the associated type</p>",
        "id": 249438801,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913220
    },
    {
        "content": "<blockquote>\n<p>Sure, then OptionType corresponds to Result despite its name</p>\n</blockquote>\n<p>Responded inline with an edit; kept my prior example up for clarification of my mistake in understanding.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Self-update.20syntax.20and.20HKT.20via.20GATs/near/249438621\">said</a>:</p>\n<blockquote>\n<p>I think a big question that should be answered here: <em>why</em> are implementations like this discouraged?</p>\n</blockquote>\n<p>Because they describe a morphism between one category and another- but that is fundamentally not an endomorphism, leading to this not being a Functor.</p>\n<p>This is legally representable via another syntax in the above proposal, but doesn't allow the illegal implementations to \"lie\".</p>\n<p>The reason this matters:<br>\nSometimes you want to act on a Functor of Functors- but if you can't guarantee they are returning the same type they currently are, you can't actually operate on their contents abstractly. We end up back in the area of specialization, and lose out on the benefits of defining categories.</p>",
        "id": 249438803,
        "sender_full_name": "Zoey",
        "timestamp": 1628913221
    },
    {
        "content": "<p>I think I would try to pinpoint more exact code requirements</p>",
        "id": 249438861,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913302
    },
    {
        "content": "<p>I ... Am unclear where the requirements are not clear? This allows enforcing an invariant which is currently unenforceable, and reduces boilerplate in the process.</p>",
        "id": 249438961,
        "sender_full_name": "Zoey",
        "timestamp": 1628913397
    },
    {
        "content": "<p>You'll have to forgive me, I'm not super familiar with Haskell or a lot of functional terminology (though I have some basic understanding).</p>\n<p>I would steer away from making \"this isn't exactly what a Functor is\" and more so \"when you allow what should be a Functor trait to return a different self type, this is no longer possible\"</p>",
        "id": 249438978,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913468
    },
    {
        "content": "<p>I personally think Rust generally discourages highly-abstracted API designs without strong motivation. Maybe that's because that will make crate API documentations quite hard to write :) </p>\n<p>All type-system expressiveness here serves for API design, i think:)</p>",
        "id": 249439053,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628913595
    },
    {
        "content": "<p>Fundamentally, if you define a typeclass, you don't want people to be able to accidentally lie in the implementation. If categories cannot be soundly represented, you cannot use categories. This is fundamentally _why_ we have to implement .iter() separately for every type.</p>\n<blockquote>\n<p>Maybe that's because that will make crate API documentations quite hard to write :) </p>\n</blockquote>\n<p>Allowing dishonesty in implementations limits reuse and composition, and requires documentation to clarify exactly when/how/why that is done, or conventions to encourage not doing them (which will sometimes be disobeyed and need documented).</p>\n<p>As for code which demonstrates why this matters, see <code>mapM/traverse</code> in this article, which shows the limitation's implications: <a href=\"https://www.fpcomplete.com/blog/monads-gats-nightly-rust/#mapm-traverse\">https://www.fpcomplete.com/blog/monads-gats-nightly-rust/#mapm-traverse</a></p>",
        "id": 249439166,
        "sender_full_name": "Zoey",
        "timestamp": 1628913646
    },
    {
        "content": "<p>For example, at the trait level, how does creating the invariant that the Self type doesn't change affect usage? It's not like the trait would know what that concrete type would be. And if you need certain functionality, you could have trait bounds on the associated type.</p>",
        "id": 249439176,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913670
    },
    {
        "content": "<p>I'll have to look more into the article tomorrow. I see there's a snippet of code that doesn't compile. I think it would be helpful to see what it would look like with the Self-change update syntax. (And presumably show that it <em>would</em> compile)</p>",
        "id": 249439396,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628913962
    },
    {
        "content": "<p>I will attempt to represent all of his code using my <code>Id</code> trait, which was designed to prove that invariant specifically for his example, then - with it compiling - rewrite it into Self-update syntax.</p>\n<p>In the meantime, I've also linked the author of that article to this thread. Maybe he'll be able to word the importance of this invariant.</p>",
        "id": 249439459,
        "sender_full_name": "Zoey",
        "timestamp": 1628914058
    },
    {
        "content": "<p>Well, I mean, the big thing I'd like to see is what is possible with Self-update syntax but not <code>Id</code></p>",
        "id": 249439516,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628914116
    },
    {
        "content": "<p>Bifunctor is not possible with <code>Id</code>, and <code>Id</code> cannot be trusted because it requires manual implementation (and is therein technically <code>unsafe impl</code> but not in memory terms).</p>\n<p>I will write that up and show some attempted workarounds using Variadic Generics, but those are also not available.</p>",
        "id": 249439541,
        "sender_full_name": "Zoey",
        "timestamp": 1628914154
    },
    {
        "content": "<p>Generally i think type families is a very useful pattern :)  If you always project from a single family representative type like <code>OptionType</code> above, the result can always be trusted.</p>",
        "id": 249439647,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628914301
    },
    {
        "content": "<p>Yes, what about to ask about that design</p>",
        "id": 249439691,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628914334
    },
    {
        "content": "<p>I can definitely see the pros and cons of the different approaches. Just trying to flesh them out a bit :)</p>",
        "id": 249439694,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628914359
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Self-update.20syntax.20and.20HKT.20via.20GATs/near/249439647\">said</a>:</p>\n<blockquote>\n<p>Generally i think type families is a very useful pattern :)  If you always project from a single family representative type like <code>OptionType</code> above, the result can always be trusted.</p>\n</blockquote>\n<p>Families are not compositional (Composable?)- you can't derive TypeFamily for Option without knowing it's an Option concretely.</p>\n<p>In some sense, this is the higher-order logic difference between \"methods\" and \"trait methods\", or \"functions\" and \"typeclasses\". Imagine if you needed to concretely say which trait implementation you were talking about in order to use traits (instead of being able to use them generically).</p>",
        "id": 249439697,
        "sender_full_name": "Zoey",
        "timestamp": 1628914371
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TypeEq</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TypeEq</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">type</span> <span class=\"nc\">New</span><span class=\"o\">&lt;</span><span class=\"n\">Ego</span><span class=\"o\">&gt;</span>: <span class=\"nc\">TypeEq</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249440320,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628915291
    },
    {
        "content": "<p>I ... don't really know how well this will work. Maybe it will mean you'll repeat the obvious where bound a lot, at many different places.</p>",
        "id": 249440337,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628915356
    },
    {
        "content": "<p>But in principle this will give you the bound you want, i think?</p>",
        "id": 249440343,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628915384
    },
    {
        "content": "<p>That doesn't allow reaching \"into\" the type, so you have to rely on type families again. It's close, though. I think this is fundamentally unrepresentable in current rust without the chance of illegal implementations.</p>",
        "id": 249440344,
        "sender_full_name": "Zoey",
        "timestamp": 1628915384
    },
    {
        "content": "<p>Did you mean something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"k\">type</span> <span class=\"nc\">New</span><span class=\"o\">&lt;</span><span class=\"n\">Ego</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">Ego</span>: <span class=\"nc\">TypeEq</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249440574,
        "sender_full_name": "Charles Lew",
        "timestamp": 1628915715
    },
    {
        "content": "<p>Neither of these appear to enforce that the <code>Id</code> implementation is truthful- and... <code>Ego</code> is the contents, not the <code>Self</code> type. It strictly must not be limited to only the current type- as it is how we bridge to other types in the same family.</p>",
        "id": 249441008,
        "sender_full_name": "Zoey",
        "timestamp": 1628916359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"398288\">@Zoey</span> <a href=\"https://meet.jit.si/683914435248316\">Click to join video call</a></p>\n<p><span class=\"user-mention silent\" data-user-id=\"398288\">Zoey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Self-update.20syntax.20and.20HKT.20via.20GATs/near/249432958\">said</a>:</p>\n<blockquote>\n<p>I see these additional disadvantages:</p>\n<ul>\n<li>Significant boilerplate, macro invocations required for concise usage at the implementations rather than just the definitions</li>\n<li>Passing around actual values as witnesses- probably not a runtime concern, as they're ZSTs, but it complicates things significantly</li>\n</ul>\n</blockquote>\n<p>While the usage of the macro or its expansion is not strictly necessary (one could use <code>M::Of&lt;T&gt;</code> for the arguments), the approach with the generic <code>impl HasTyCon</code> arguments allows for functions to be called without explicitly specifying the <code>M</code> type argument. Otherwise, the boilerplate is real, yeah. </p>\n<p>There are no values passed around of types like <code>Vec_</code>, in fact using an uninhabited type like <code>enum Vec_ {}</code> works, too.</p>",
        "id": 249447790,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1628928155
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> I've worked with a</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TypeEqual</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">To</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TypeEqual</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">To</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>a few times which more strictly enforce the types involved being equal in a way that (with some boilerplate overhead) can actually be used to somewhat gain back the knowledge that the types are actually equal. (If you want to see an example of what that means, ask me, I can give more details later.)</p>\n<p>The bound to use it is <code>T: TypeEqual&lt;To=U&gt;</code> in order to state that <code>T == U</code>.</p>",
        "id": 249447988,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1628928497
    }
]