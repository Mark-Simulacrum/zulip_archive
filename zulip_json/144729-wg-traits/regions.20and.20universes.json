[
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"116118\">@Matthew Jasper</span></p>",
        "id": 183685875,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613040
    },
    {
        "content": "<p>Hi</p>",
        "id": 183685923,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576613048
    },
    {
        "content": "<p>I'm trying to decide where to start</p>",
        "id": 183685971,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613078
    },
    {
        "content": "<p>I guess let me start with <a href=\"https://github.com/rust-lang/rust/issues/65232\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/65232\">#65232</a></p>",
        "id": 183685996,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613097
    },
    {
        "content": "<p>I'd like to land that PR but I have a few concerns</p>",
        "id": 183686005,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613104
    },
    {
        "content": "<ul>\n<li>it's a breaking change w/r/t coherence; this is maybe ok but I feel like there may be some procedural steps first</li>\n</ul>",
        "id": 183686031,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613126
    },
    {
        "content": "<p>(e.g., maybe a warning period)</p>",
        "id": 183686046,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613135
    },
    {
        "content": "<p>in my ideal world, we would have an RFC that kind of lays out \"the plan\" for how to handle this stuff</p>",
        "id": 183686059,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613148
    },
    {
        "content": "<p>specifically I mean how to handle regions, higher-ranked subtyping, trait solving, and the interactions there</p>",
        "id": 183686130,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613166
    },
    {
        "content": "<p>I think it would actually be plausible to do a warning period</p>",
        "id": 183686159,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613189
    },
    {
        "content": "<p>or to preserve the existing region behavior</p>",
        "id": 183686167,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613195
    },
    {
        "content": "<p>by adding a check to cherence</p>",
        "id": 183686174,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613199
    },
    {
        "content": "<p>right now, the coherence test basially just ignores all the region constraints</p>",
        "id": 183686188,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613206
    },
    {
        "content": "<p>but we could instead try to solve them, or at least look for \"cross-universe\" constraints that are not solveable</p>",
        "id": 183686217,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613228
    },
    {
        "content": "<p>do you know the coherence interaction I am referring to?</p>",
        "id": 183686234,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613240
    },
    {
        "content": "<p>I know what the change in behaviour is. I don't really know how the coherence check works.</p>",
        "id": 183686327,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576613287
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/94fe66d3df05a5f6329bae64e02dfe5ba09eb71a/src/test/ui/coherence/coherence-subtyping.rs\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/blob/94fe66d3df05a5f6329bae64e02dfe5ba09eb71a/src/test/ui/coherence/coherence-subtyping.rs\">the test</a></p>",
        "id": 183686396,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613332
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TheTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">TheTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"p\">,</span><span class=\"na\">&#39;b</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"na\">&#39;b</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">TheTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 183686408,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613342
    },
    {
        "content": "<p>I think the way to think about this is that</p>",
        "id": 183686448,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613371
    },
    {
        "content": "<p>you have the operation <code>TypeEqual(T1, T2)</code> which, in the compiler anyway, returns a set of region constraints <code>RC</code></p>",
        "id": 183686483,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613392
    },
    {
        "content": "<p>(or errors)</p>",
        "id": 183686541,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613405
    },
    {
        "content": "<p>i.e., the types are equal if  <code>RC</code> are satisfiable</p>",
        "id": 183686552,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613414
    },
    {
        "content": "<p>and the coherence code basically just ignores those constraints and considers things to potentially overlap, assuming <code>RC</code> is satisfiable</p>",
        "id": 183686566,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613424
    },
    {
        "content": "<p>we could probalby just <em>run</em> the region inference code and it'd be ok, though most of the regions would wind up being inferred to <code>'empty</code> or something</p>",
        "id": 183686630,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613467
    },
    {
        "content": "<p>because there are no real constraints</p>",
        "id": 183686635,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613470
    },
    {
        "content": "<p>that is, you have a bunch of variables, and they have to outlive one another, but there is nothing that forces them to be anything other than <code>'empty</code></p>",
        "id": 183686656,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613488
    },
    {
        "content": "<p><em>except</em> for universe placeholders, in this PR</p>",
        "id": 183686669,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613500
    },
    {
        "content": "<p>so e.g. here I think you would find that we can't infer a single <code>'a</code> that outlives <code>'!a</code> and <code>'!b</code> and yet is outlived by <code>'!a</code></p>",
        "id": 183686734,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613539
    },
    {
        "content": "<p>(does that make sense?)</p>",
        "id": 183686737,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613544
    },
    {
        "content": "<p>Yes.</p>",
        "id": 183686765,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576613584
    },
    {
        "content": "<p>I feel like .. 90% sure that this would be \"more or less\" equivalent to today's code, modulo those cases where today's code is wrong</p>",
        "id": 183686785,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613599
    },
    {
        "content": "<p>Where the types really are the same.</p>",
        "id": 183686807,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576613620
    },
    {
        "content": "<p>e.g., presumably </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">TheTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TheTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>would probably overlap, because there is at least one lifetime (<code>'empty</code>) where those types are the same</p>",
        "id": 183686843,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613641
    },
    {
        "content": "<p>similarly</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">TheTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;b</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"na\">&#39;b</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TheTrait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>which is equivalent in the case where <code>'a</code> is <code>'static</code></p>",
        "id": 183686913,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613680
    },
    {
        "content": "<p>I could certainly try implementing that, it'd be easy enough</p>",
        "id": 183687003,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613761
    },
    {
        "content": "<p>let me pivot slightly, to talk about the idea I had for how to handle regions in chalk</p>",
        "id": 183687062,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613779
    },
    {
        "content": "<p>which is related to this in some sense</p>",
        "id": 183687070,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613787
    },
    {
        "content": "<blockquote>\n<p>but we could instead try to solve them, or at least look for \"cross-universe\" constraints that are not solveable</p>\n</blockquote>\n<p>Implementing this?</p>",
        "id": 183687074,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576613791
    },
    {
        "content": "<p>right, I think I just have to add one or two lines of code</p>",
        "id": 183687083,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613801
    },
    {
        "content": "<p>well, before I pivot, let me add one last thing --</p>",
        "id": 183687099,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613815
    },
    {
        "content": "<p>I was debating at some point whether it would be possible to get away with the branch the way it is now (i.e., causing all those cases to overlap, even when the constraints are unsolveable)</p>",
        "id": 183687130,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613844
    },
    {
        "content": "<p>in part because I was hoping that could make it so that the first round of type-checking could <em>completely erase</em> regons, even erasing their binding locations</p>",
        "id": 183687160,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613867
    },
    {
        "content": "<p>this would basically change Rust's type system into a flat system w/o subtyping</p>",
        "id": 183687177,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613878
    },
    {
        "content": "<p>(I think?)</p>",
        "id": 183687225,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613885
    },
    {
        "content": "<p>which would be efficient</p>",
        "id": 183687235,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613900
    },
    {
        "content": "<p>and most users I've talked (even sophisticated ones) are surprised to learn that an impl for <code>fn(&amp;u8)</code> and an impl for <code>fn(&amp;'a u8)</code> are both permitted, etc</p>",
        "id": 183687251,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613922
    },
    {
        "content": "<p>(well, that specific example wouldn't be, but you know what I mean)</p>",
        "id": 183687255,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613926
    },
    {
        "content": "<p><em>however</em> I am not sure about that vision, and anyway I have to face the backwards compatibility facts -- i.e., I can't come up with a kind of compelling reason to justify rejecting some of these cases that are currently accepted</p>",
        "id": 183687303,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576613976
    },
    {
        "content": "<p>(except for the cases where there is legit overlap)</p>",
        "id": 183687366,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614013
    },
    {
        "content": "<p>but I guess there'd always be room to move to a future compatibility warning <em>later</em></p>",
        "id": 183687385,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614038
    },
    {
        "content": "<p>after all, it's been literally this way since 1.0</p>",
        "id": 183687388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614046
    },
    {
        "content": "<p>(the truth is that even with my change, the branch will be rejecting all the impls I know of that take advantage of distinguishing binding locations)</p>",
        "id": 183687435,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614091
    },
    {
        "content": "<p>(so I guess I need a warning anyway)</p>",
        "id": 183687439,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614095
    },
    {
        "content": "<p>(or at least we might consider one)</p>",
        "id": 183687448,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614102
    },
    {
        "content": "<p>anyway, let me spell out my idea for chalk I guess?</p>",
        "id": 183687462,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614115
    },
    {
        "content": "<p>/me pauses</p>",
        "id": 183687464,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614117
    },
    {
        "content": "<p>Go ahead</p>",
        "id": 183687531,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576614152
    },
    {
        "content": "<p>ok so</p>",
        "id": 183687571,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614192
    },
    {
        "content": "<p>the idea was roughly this</p>",
        "id": 183687577,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614196
    },
    {
        "content": "<p>the idea was to consider <code>Outlives('a: 'b)</code> a predicate that must be \"proven\" like any other logical predicate</p>",
        "id": 183687605,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614231
    },
    {
        "content": "<p>(whereas today, chalk just kind of \"records\" them as constraints and never tries to solve them)</p>",
        "id": 183687661,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614244
    },
    {
        "content": "<p>there would be a few base rules that we supply for doing that</p>",
        "id": 183687678,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614256
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>forall&lt;&#39;x&gt; { Outlives(&#39;static: &#39;x) }\n</pre></div>",
        "id": 183687689,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614266
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>forall&lt;&#39;a, &#39;b, &#39;c&gt; {\n    Outlives(&#39;a: &#39;c) :-\n      Outlives(&#39;a: &#39;b),\n      Outlives(&#39;b: &#39;c)\n}\n</pre></div>",
        "id": 183687717,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614292
    },
    {
        "content": "<p>and the last rule, which is important</p>",
        "id": 183687735,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614300
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>Outlives(&#39;a: &#39;b) :- RecordOutlives(&#39;a: &#39;b)\n</pre></div>",
        "id": 183687751,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614309
    },
    {
        "content": "<p>so what is this \"record outlives\"?</p>",
        "id": 183687761,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614315
    },
    {
        "content": "<p>this is kind of a built-in thing that \"records\" the constraint for NLL (or polonius...) to solve, but it can only be done if <code>'a</code> and <code>'b</code> are in the root universe</p>",
        "id": 183687800,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614350
    },
    {
        "content": "<p>the intution here being that if I have a query to prove like</p>\n<div class=\"codehilite\"><pre><span></span>TypeEqual(&amp;&#39;a u8 = &amp;&#39;b u8)\n</pre></div>",
        "id": 183687853,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614375
    },
    {
        "content": "<p>where <code>'a</code> and <code>'b</code> are kind of \"free\" lifetimes, maybe I put them in the root universe (bear with me on that, I'm going to be hand-wavy for a second about the \"root universe\" I guess)</p>",
        "id": 183687880,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614400
    },
    {
        "content": "<p>in that case I would be forced to prove <code>Outlives('a: 'b)</code> and <code>Outlives('b: 'a)</code>, both of which I can prove by recording</p>",
        "id": 183687903,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614417
    },
    {
        "content": "<p>so I get back those two things as region constraints that must be solved later</p>",
        "id": 183687921,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614429
    },
    {
        "content": "<p>however, if I have something like</p>\n<div class=\"codehilite\"><pre><span></span>for&lt;&#39;a&gt; fn(&amp;&#39;a u8) &lt;: fn(&amp;&#39;b u8)\n</pre></div>",
        "id": 183687944,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614446
    },
    {
        "content": "<p>now I would wind up having to prove something like <code>'b: '!a</code> for some placeholer <code>'!a</code> that is not in the root universe</p>",
        "id": 183687968,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614478
    },
    {
        "content": "<p>I can't \"record\" that one, so I have to justify it some other way</p>",
        "id": 183688014,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614488
    },
    {
        "content": "<p>for example, I could see that <code>'static: '!a</code> (base rule) and that we could prove <code>Outlives('b: 'static)</code> by recording (both <code>'b</code> and <code>'static</code> are in root universe) and hence by transitivity we're done</p>",
        "id": 183688058,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614529
    },
    {
        "content": "<p>i.e., we wind up recording that this is true if <code>'b: 'static</code></p>",
        "id": 183688079,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614543
    },
    {
        "content": "<p>/me wonders if he got that right</p>",
        "id": 183688083,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614546
    },
    {
        "content": "<p>I guess so :)</p>",
        "id": 183688092,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614556
    },
    {
        "content": "<p>this is basically the same behavior that our region solver is doing in that PR, of course</p>",
        "id": 183688103,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614565
    },
    {
        "content": "<p>No, <code>'a</code> becomes an inference variable.</p>",
        "id": 183688106,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576614566
    },
    {
        "content": "<p>yeah, ok, well, you get the idea :P</p>",
        "id": 183688115,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614573
    },
    {
        "content": "<p>:P</p>",
        "id": 183688123,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576614583
    },
    {
        "content": "<p>(maybe)</p>",
        "id": 183688130,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614588
    },
    {
        "content": "<blockquote>\n<p>No, <code>'a</code> becomes an inference variable.</p>\n</blockquote>\n<p>glad you saw that, because it seemed like what I was saying made no sense when I ported it back to the original types</p>",
        "id": 183688207,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614613
    },
    {
        "content": "<p>ok, change the example to</p>",
        "id": 183688212,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614616
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>fn() -&gt; &amp;&#39;b u8 &lt;: for&lt;&#39;a&gt; fn() -&gt; &amp;&#39;a u8\n</pre></div>",
        "id": 183688235,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614629
    },
    {
        "content": "<p>(man that's hard to parse)</p>",
        "id": 183688272,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614653
    },
    {
        "content": "<p>That looks better...</p>",
        "id": 183688284,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576614663
    },
    {
        "content": "<p>but at least it makes sense that <code>'b = 'static</code> is a solution :)</p>",
        "id": 183688302,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614671
    },
    {
        "content": "<p>anyway what's neat about this is that (e.g.) polonius doesn't have to care about anything higher-ranked or higher-order or whatever</p>",
        "id": 183688326,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614697
    },
    {
        "content": "<p>plus it fits with some other things I'd like to do</p>",
        "id": 183688330,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614703
    },
    {
        "content": "<p>e.g., I'd like to be able to do</p>",
        "id": 183688337,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614705
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>forall&lt;&#39;a, &#39;b&gt; { if (&#39;a: &#39;b, &#39;b: &#39;a) { &amp;&#39;a u8 = &amp;&#39;b u8 } }\n</pre></div>",
        "id": 183688345,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614719
    },
    {
        "content": "<p>this could plausibly be solved by chalk all by itself</p>",
        "id": 183688388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614726
    },
    {
        "content": "<p>more importantly, perhaps</p>",
        "id": 183688394,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614733
    },
    {
        "content": "<p>consider a type like </p>\n<div class=\"codehilite\"><pre><span></span>for&lt;&#39;a, &#39;b&gt; fn(Foo&lt;&#39;a, &#39;b&gt;)\n</pre></div>",
        "id": 183688417,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614751
    },
    {
        "content": "<p>where <code>struct Foo&lt;'a, 'b: 'a&gt;</code></p>",
        "id": 183688431,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614760
    },
    {
        "content": "<p>here, although we don't yet know what <code>'a</code> and <code>'b</code> are, we do know that you should pick choices that make <code>Foo&lt;'a, 'b&gt;</code> WF</p>",
        "id": 183688481,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614803
    },
    {
        "content": "<p>(the current compiler's handling of this is not sound, which is a longstanding bug, thoughh I can't find the issue number just now)</p>",
        "id": 183688507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614836
    },
    {
        "content": "<p>but also we sometimes hit cases where we are far too conservative today</p>",
        "id": 183688562,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614847
    },
    {
        "content": "<p>I've seen it</p>",
        "id": 183688569,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576614850
    },
    {
        "content": "<p>however, with this setup, we could do things like</p>\n<div class=\"codehilite\"><pre><span></span>forall&lt;&#39;a, &#39;b&gt; {\n    if (WF(Foo&lt;&#39;a, &#39;b&gt;)) {\n        ...\n</pre></div>",
        "id": 183688584,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614871
    },
    {
        "content": "<p>and use the implied bounds setup to figure out that this means that <code>'a: 'b</code></p>",
        "id": 183688593,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614881
    },
    {
        "content": "<p>(I'm not sure how familiar you are with the chalk notation etc, so I'm assuming you'll ask me questions etc)</p>",
        "id": 183688606,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614897
    },
    {
        "content": "<p>there is one \"fly in the ointment\", so to speak, but that's the basic idea</p>",
        "id": 183688629,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614908
    },
    {
        "content": "<p>sorry, I should give a bit more context</p>",
        "id": 183688643,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614920
    },
    {
        "content": "<p>I kind of wanted to \"reinterpret\" the WF rules on <code>fn</code> types</p>",
        "id": 183688662,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614928
    },
    {
        "content": "<p>right now, we basically just <em>don't</em> validate the WF for things inside binders at all</p>",
        "id": 183688673,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614937
    },
    {
        "content": "<p>and if you were just kind of naive then <code>for&lt;'a, 'b&gt; fn(Foo&lt;'a, 'b&gt;)</code> would not be WF because we don't have any constraints on <code>'a</code> and <code>'b</code></p>",
        "id": 183688735,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614964
    },
    {
        "content": "<p>but if we use an \"implied bounds\" setup, then we might say that there is an <em>implied</em> set of where clauses for <code>fn</code> types</p>",
        "id": 183688763,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614982
    },
    {
        "content": "<p>that require all their argument types (and return type) to be WF</p>",
        "id": 183688772,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576614992
    },
    {
        "content": "<p>then you can extend fn subtyping to say that those bounds (now made explicit) must subsume one another</p>",
        "id": 183688793,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615011
    },
    {
        "content": "<p>so e.g. <code>for&lt;'a&gt; fn</code> is really short (internally) for <code>for&lt;...&gt; if(C) fn(...)</code></p>",
        "id": 183688806,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615022
    },
    {
        "content": "<p>and hence when you have <code>for&lt;..&gt; if(C) fn(...) &lt;: for&lt;...&gt; if(D) fn(..)</code></p>",
        "id": 183688829,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615040
    },
    {
        "content": "<p>there must be some relationship between <code>C</code> and <code>D</code></p>",
        "id": 183688835,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615044
    },
    {
        "content": "<p>i.e., assuming <code>D</code>, you can prove <code>C</code>, or maybe vice versa :P</p>",
        "id": 183688847,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615053
    },
    {
        "content": "<p>/me thinks for a second :)</p>",
        "id": 183688853,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615059
    },
    {
        "content": "<p>I thnk that's right... the caller will only have to prove D, so that should imply C</p>",
        "id": 183688925,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615085
    },
    {
        "content": "<p>anyway, there <em>is</em> a fly in the ointment, as I said, but that's the big picture I was kind of shooting for</p>",
        "id": 183688960,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615119
    },
    {
        "content": "<p>the fly is basically that the rules I gave will result in a lot of possible solutions</p>",
        "id": 183688986,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615133
    },
    {
        "content": "<p>I'm not 100% sure how to handle that :)</p>",
        "id": 183689004,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615145
    },
    {
        "content": "<p>i.e., left to its own devices, chalk would kind of try to enumerate way too many possibilities</p>",
        "id": 183689017,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615158
    },
    {
        "content": "<p>I think though we can tweak the way we express the rules to be a bit less redundant --</p>",
        "id": 183689036,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615179
    },
    {
        "content": "<p>and no matter what way you slice it, there is a separate thing, that we're going to have to add some notion of \"or\" into the cosntraints, so that you get back a variety of possible constraints</p>",
        "id": 183689056,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615195
    },
    {
        "content": "<p>which we can then simplify, in some cases, though in the limit we might just have multiple possibilities we have to check</p>",
        "id": 183689111,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615210
    },
    {
        "content": "<p>see e.g. <a href=\"https://github.com/rust-lang/rust/issues/21974\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/21974\">https://github.com/rust-lang/rust/issues/21974</a></p>",
        "id": 183689128,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615219
    },
    {
        "content": "<p>but I think that's an orthogonal problem</p>",
        "id": 183689132,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615223
    },
    {
        "content": "<p>Hopefully.</p>",
        "id": 183689160,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576615247
    },
    {
        "content": "<p>my plan for now was that chalk would produce <code>C || D</code> constraints, but that the solver would sort do <em>something</em>, e.g. maybe conver them to <code>C &amp;&amp; D</code> at worst</p>",
        "id": 183689166,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615254
    },
    {
        "content": "<p>it seems like step 1 would be producing the correct constraints</p>",
        "id": 183689179,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615267
    },
    {
        "content": "<p>then we have to think about how to solve them...</p>",
        "id": 183689188,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615271
    },
    {
        "content": "<p>We do that for closures.</p>",
        "id": 183689193,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576615274
    },
    {
        "content": "<p>right</p>",
        "id": 183689197,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615278
    },
    {
        "content": "<p>another interesting thought experiment: solve all possible sets of cosntraints, but use some kind of incremental dataflow to try and avoid redoing work :)</p>",
        "id": 183689216,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615294
    },
    {
        "content": "<p>that is so far down the line it might as well be outer space</p>",
        "id": 183689226,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615303
    },
    {
        "content": "<p>unfortunately, I have to run and go shovel the walk :)</p>",
        "id": 183689244,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615318
    },
    {
        "content": "<p>but I'll come back in a bit, hopefully that made some sense to you, I'd be curious to know if you see any obvious flaws (either today or at some later point)</p>",
        "id": 183689304,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615340
    },
    {
        "content": "<p>ah there was one last thing I didn't mention...</p>",
        "id": 183689321,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615360
    },
    {
        "content": "<p>having to do how, in polonius, regions can really be \"sets\" of lifetimes</p>",
        "id": 183689356,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615379
    },
    {
        "content": "<p>which I think is neat and useful but there is some interaction here for complex cases</p>",
        "id": 183689369,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615390
    },
    {
        "content": "<p>e.g. if you had <code>if ('a: 'b, 'a: 'c)</code>, and you had to prove <code>exists&lt;'x&gt; { 'x: 'a</code> and <code>'x: 'b }</code></p>",
        "id": 183689403,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615421
    },
    {
        "content": "<p>I think that chalk would be forced to say <code>'x = 'a</code></p>",
        "id": 183689407,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615428
    },
    {
        "content": "<p>but polonius might say <code>'x = union('a, 'b)</code></p>",
        "id": 183689422,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615439
    },
    {
        "content": "<p>I don't actually know that this matters much in <em>some</em> sense</p>",
        "id": 183689472,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615454
    },
    {
        "content": "<p>like I think the same set of constraints are solveable</p>",
        "id": 183689495,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615481
    },
    {
        "content": "<p>it's just a matter of how \"precise\" the solutions are</p>",
        "id": 183689499,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615485
    },
    {
        "content": "<blockquote>\n<p>having to do how, in polonius, regions can really be \"sets\" of lifetimes</p>\n</blockquote>\n<p>I think this could be useful for <code>impl Trait</code> and capture clausees</p>",
        "id": 183689525,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615509
    },
    {
        "content": "<p>ok, have to go now <span aria-label=\"snowflake\" class=\"emoji emoji-2744\" role=\"img\" title=\"snowflake\">:snowflake:</span></p>",
        "id": 183689541,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1576615521
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 183689545,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576615529
    },
    {
        "content": "<blockquote>\n<p>it's just a matter of how \"precise\" the solutions are</p>\n</blockquote>\n<p>I was going to say that it matters for cases like this: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=169cdb4aaa19abce2baa2b45e876f797\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=169cdb4aaa19abce2baa2b45e876f797\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=169cdb4aaa19abce2baa2b45e876f797</a>. But that causes the compiler to ICE...</p>",
        "id": 184023505,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576958041
    },
    {
        "content": "<p>In cases like the above I guess we could preemptively add another region for <code>union('d, 'e)</code> so that we have something for the region to be inferred to.</p>",
        "id": 184025135,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1576961049
    },
    {
        "content": "<p>That case is hurting my head =)</p>",
        "id": 184098152,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1577100024
    },
    {
        "content": "<p>(Note though that <code>union</code> in polonius terms is more like intersection in lifetimes, in case that's relevant)</p>",
        "id": 184098291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1577100202
    },
    {
        "content": "<p>Let me try to break that example into relations :)</p>",
        "id": 184098299,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1577100210
    },
    {
        "content": "<ul>\n<li><code>for&lt;'c&gt; fn(fn(&amp;'c fn(&amp;'c))) &lt;: fn(fn(&amp;'a fn(&amp;'d)))</code></li>\n<li><code>fn(&amp;'a fn(&amp;'d)) &lt;: fn(&amp;'?c fn(&amp;'?c))</code></li>\n<li><code>&amp;'?c fn(&amp;'?c) &lt;: &amp;'a fn(&amp;'d)</code> =&gt; <code>'?c: 'a</code></li>\n<li><code>fn(&amp;'?c) &lt;: fn(&amp;'d)</code></li>\n<li><code>&amp;'d &lt;: &amp;'?c</code> =&gt; <code>'d: '?c</code> (etc)</li>\n</ul>\n<p>So put that all together and you get</p>\n<ul>\n<li><code>'?c: 'a</code></li>\n<li><code>'?c: 'b</code></li>\n<li><code>'d: '?c</code></li>\n<li><code>'e: '?c</code></li>\n</ul>\n<p>and we know from implied bounds that :</p>\n<ul>\n<li><code>'d: 'a</code>, </li>\n<li><code>'e: 'a</code>, </li>\n<li><code>'d: 'b</code>, </li>\n<li><code>'e: 'b</code>.</li>\n</ul>\n<p>So yeah that's a case where we can't grow to d, e, or static -- not sure why I thought that couldn't arise, seems like exactly the sort of constraints that you would be looking for. =) </p>\n<p>In any case, yes, I think the fallback would be to augment the solver either by introducing <code>union</code> or by making the value of a region equal to a set, but I'm not sure what that latter change would do <em>precisely</em>.</p>",
        "id": 184098775,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1577100853
    }
]