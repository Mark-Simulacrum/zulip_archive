[
    {
        "content": "<p>The kind of code I'm thinking of is, roughly, \"code passing around raw pointers opaquely\".</p>",
        "id": 265360003,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775004
    },
    {
        "content": "<p>As well as code building data structures out of raw pointers.</p>",
        "id": 265360024,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775013
    },
    {
        "content": "<p>I think those should generally be <code>*const T</code> where <code>T: Sized</code></p>",
        "id": 265360074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775041
    },
    {
        "content": "<p>so long as you keep the pointer as <code>*const T</code> and have <code>T: ?Sized</code> everywhere, that works just as before</p>",
        "id": 265360135,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775052
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265360074\">said</a>:</p>\n<blockquote>\n<p>I think those should generally be <code>*const T</code> where <code>T: Sized</code></p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265360135\">said</a>:</p>\n<blockquote>\n<p>so long as you keep the pointer as <code>*const T</code> and have <code>T: ?Sized</code> everywhere, that works just as before</p>\n</blockquote>\n<p><code>Sized</code> or <code>?Sized</code>?</p>",
        "id": 265360190,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775077
    },
    {
        "content": "<p>well, depends on what set of raw pointers you want to pass around, I suppose?</p>",
        "id": 265360229,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775102
    },
    {
        "content": "<p>(i.e., do you want to include <code>*const dyn Trait</code>, <code>*const [T]</code>)</p>",
        "id": 265360269,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775122
    },
    {
        "content": "<p>Both statements are true. You should consciously opt in to <code>T: ?Sized</code>, but it shouldn't present any problems if you just pass it around opaquely</p>",
        "id": 265360298,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775139
    },
    {
        "content": "<p>the Sized-ness doesn't really matter if you're working solely with <code>*const</code>, and not trying to e.g. stash it in a usize or similar.</p>",
        "id": 265360324,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775152
    },
    {
        "content": "<p>I think I'd be rather surprised, and problematically so, if saying that <em>T</em> wasn't sized makes the <em>pointer</em> to it change size.</p>",
        "id": 265360391,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775167
    },
    {
        "content": "<p>that's already (on stable, observably) the case today.</p>",
        "id": 265360424,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265360424\">said</a>:</p>\n<blockquote>\n<p>that's already (on stable, observably) the case today.</p>\n</blockquote>\n<p>I acknowledge that. And my reaction to that is roughly <a href=\"https://twitter.com/infinite_scream\">https://twitter.com/infinite_scream</a> :)</p>",
        "id": 265360480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775213
    },
    {
        "content": "<p>That should be one of the layout decisions discussed early in the rust book</p>",
        "id": 265360489,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775218
    },
    {
        "content": "<p>it feels pretty baked in at this point</p>",
        "id": 265360513,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775229
    },
    {
        "content": "<p>Which is to say \"gah, how do we make this not utterly suck for people who thought they understood what <code>*</code> meant\".</p>",
        "id": 265360531,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775239
    },
    {
        "content": "<p>I thought \"if you thought you understood pointers before, you were wrong\" is rust's subtitle</p>",
        "id": 265360591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775273
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265360531\">said</a>:</p>\n<blockquote>\n<p>Which is to say \"gah, how do we make this not utterly suck for people who thought they understood what <code>*</code> meant\".</p>\n</blockquote>\n<p>it seems like the \"this\" there is just raw pointer to unsized, has nothing really to do with dyn upcasting?</p>",
        "id": 265360685,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775311
    },
    {
        "content": "<p>An explanation I've both given and seen given <em>many</em> times is roughly \"<code>&amp;</code> is a pointer that's always valid and has a lifetime making sure it can't outlive what it points to; <code>*</code> is a raw pointer that can be null or garbage as long as you don't dereference it, and it acts exactly like the pointers you're used to from C\".</p>",
        "id": 265360768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775367
    },
    {
        "content": "<p>I've seen almost exactly the same explanation given, and it's been my mental model up until very recently</p>",
        "id": 265360833,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639775401
    },
    {
        "content": "<p>This is a rather massive \"except\" clause to append to that. And I'm acknowledging that that \"except\" exists on stable and can to some extent be observed. It's still a massive \"except\" that throws a wrench in the conception of \"raw pointer\".</p>",
        "id": 265360956,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775449
    },
    {
        "content": "<p>\"This\" is doing some work there: it seems like a larger problem/question than this specific dyn-upcasting topic, and seems useful if possible to decouple.</p>",
        "id": 265361029,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775493
    },
    {
        "content": "<p>The things I would put on that description to make it more complete is that \"exactly like the pointers you are used to from C\" is limited to <code>*mut T</code> for <code>T: Sized</code>, and the rule used to make sense of <code>*const T</code> for other types is \"<code>&amp;T</code> and <code>*const T</code> are always layout compatible\"</p>",
        "id": 265361055,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775511
    },
    {
        "content": "<p>(I'm trying to understand whether we are aligned on the decoupling there)</p>",
        "id": 265361057,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265361029\">said</a>:</p>\n<blockquote>\n<p>\"This\" is doing some work there: it seems like a larger problem/question than this specific dyn-upcasting topic, and seems useful if possible to decouple.</p>\n</blockquote>\n<p>I'd be happy to split out this sub-discussion from dyn upcasting, though I think it still has relevance if introducing a new validity invariant that wasn't necessarily the case before.</p>",
        "id": 265361110,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775537
    },
    {
        "content": "<p>By the way, what's the reasoning behind our current requirement that the metadata of a raw pointer be non-null?</p>",
        "id": 265361130,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639775549
    },
    {
        "content": "<p>Is it so that we can emit <code>nonnnull</code> to llvm for better optimizations?</p>",
        "id": 265361145,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639775563
    },
    {
        "content": "<p>well, in general, the unstable suite of functions we have for accessing raw pointer metadata mostly assume fairly significant validity (e.g., it is safe to access roughly size_of_val for <code>*const dyn T</code>))</p>",
        "id": 265361315,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775649
    },
    {
        "content": "<p>(I just attempted to roughly split the digression in this topic off into a separate topic.)</p>",
        "id": 265361344,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775667
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265361315\">said</a>:</p>\n<blockquote>\n<p>well, in general, the unstable suite of functions we have for accessing raw pointer metadata mostly assume fairly significant validity (e.g., it is safe to access roughly size_of_val for <code>*const dyn T</code>))</p>\n</blockquote>\n<p>Right, but those functions are unstable, and until they're stable, we don't have those validity expectations.</p>",
        "id": 265361423,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775696
    },
    {
        "content": "<p>er, I guess, at least safety invariant: validity is a separate question.</p>",
        "id": 265361458,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775709
    },
    {
        "content": "<p>From my perspective, operations on raw wide pointers are a fairly niche use-case. Do we gain anything by making things like non-null-ness and vtable validity part of the safety invariant? What would happen if we were to just make them safety conditions on the relevant <code>unsafe</code> functions?</p>",
        "id": 265361657,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639775805
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265361423\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265361315\">said</a>:</p>\n<blockquote>\n<p>well, in general, the unstable suite of functions we have for accessing raw pointer metadata mostly assume fairly significant validity (e.g., it is safe to access roughly size_of_val for <code>*const dyn T</code>))</p>\n</blockquote>\n<p>Right, but those functions are unstable, and until they're stable, we don't have those validity expectations.</p>\n</blockquote>\n<p>I think validity expectations are insta-stable, since UB in unstable code is UB for everyone</p>",
        "id": 265361658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775806
    },
    {
        "content": "<p>Only if the standard library uses and exposes it via a stable interface.</p>",
        "id": 265361709,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775840
    },
    {
        "content": "<p>Otherwise, you'd have to be building with a nightly compiler and using a crate that uses nightly features.</p>",
        "id": 265361743,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775856
    },
    {
        "content": "<p>e.g. safe code couldn't do anything with a garbage raw pointer, and calling <code>size_of_val_raw</code> requires that the metadata be 'correct' in some specific sense (e.g the vtable is fully correct, or at least the 'size' field)</p>",
        "id": 265361773,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639775880
    },
    {
        "content": "<p>Validity invariants are exposed to LLVM codegen, they exist transparently throughout all rust code. You don't get to opt in or out of it</p>",
        "id": 265361820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265361820\">said</a>:</p>\n<blockquote>\n<p>Validity invariants are exposed to LLVM codegen, they exist transparently throughout all rust code. You don't get to opt in or out of it</p>\n</blockquote>\n<p>It's entirely possible for the validity invariant to be <em>wrong</em>, and that's not the problem of stable rust code.</p>",
        "id": 265361868,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775909
    },
    {
        "content": "<p>You mean wrong in the sense of we shouldn't have that invariant?</p>",
        "id": 265361899,
        "sender_full_name": "simulacrum",
        "timestamp": 1639775930
    },
    {
        "content": "<p>Also, I don't think LLVM is aware of <em>all</em> of our validity invariants</p>",
        "id": 265361901,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639775931
    },
    {
        "content": "<p>If the validity invariant is wrong, then rustc will miscompile code</p>",
        "id": 265361904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639775935
    },
    {
        "content": "<p>for example, I think LLVM is generally fine with uninitialized values (except if you try to branch on them)</p>",
        "id": 265361942,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639775955
    },
    {
        "content": "<p>Or to say that another way: when we agreed to add the raw pointer APIs unstably, I don't recall there being any discussion of any insta-stable assumptions about validity, and if those APIs are making validity assumptions, and stable Rust is not matching those assumptions, that's the problem of those APIs and not of the stable Rust code.</p>",
        "id": 265361958,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639775965
    },
    {
        "content": "<p>yes, I misspoke: those are only about safety invariants, and so can be unstable until we stabilize them.</p>",
        "id": 265362031,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776001
    },
    {
        "content": "<p>The raw pointer APIs make no statement on these validity invariants one way or another</p>",
        "id": 265362110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776011
    },
    {
        "content": "<p>but the validity invariant of nonnull does seem true today (i.e., in the \"we tell LLVM about it\" sense).</p>",
        "id": 265362115,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776014
    },
    {
        "content": "<p>They do take a stance on safety invariants, which constrain the validity invariants via safe -&gt; valid</p>",
        "id": 265362225,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776090
    },
    {
        "content": "<p>I think at a minimum it's reasonable to argue that we can't stabilize those APIs until we stabilize the assumptions those APIs make, and to the best of my knowledge (which I may well be misremembering given the length of time these APIs have iterated and been discussed) those assumptions have not yet been stabilized.</p>",
        "id": 265362334,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639776155
    },
    {
        "content": "<p>I think they're all <code>unsafe</code> functions, so they're not necessarily taking a stand on safety invariants, right?</p>",
        "id": 265362335,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776155
    },
    {
        "content": "<p>std::ptr::metadata and functions on DynMetadata are currently all safe.</p>",
        "id": 265362367,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776177
    },
    {
        "content": "<p>That is, you could expose a garbage wide raw pointer to safe code, and everything would be fine, since it can't actually call those functions</p>",
        "id": 265362375,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776182
    },
    {
        "content": "<p>ah, I forgot about DynMetadata</p>",
        "id": 265362386,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776188
    },
    {
        "content": "<p>So for instance if there was a safe <code>fn mk_dyn(*const (), *const ()) -&gt; *const dyn T</code> that would be a problem, but that seems extremely unlikely</p>",
        "id": 265362396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265362367\">said</a>:</p>\n<blockquote>\n<p>std::ptr::metadata and functions on DynMetadata are currently all safe.</p>\n</blockquote>\n<p>Suppose, hypothetically, we made that function unsafe, and effectively said \"it's the caller's responsibility to not pass NULL or a garbage pointer here\".</p>",
        "id": 265362538,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639776251
    },
    {
        "content": "<p>I think that would make things significantly less ergonomic for the wide reference case</p>",
        "id": 265362554,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776271
    },
    {
        "content": "<p>Marking that <code>unsafe</code> would be consistent with our stance elsewhere, which is \"it's not unsafe to make and store a bad raw pointer, only to dereference one\". Today, there's a fair bit of code out there that assumes it's not unsafe/unsound to return a raw pointer and not check it.</p>",
        "id": 265362572,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639776281
    },
    {
        "content": "<p>e.g. <code>&amp;dyn MyTrait</code>, where <code>std::ptr::metadata</code> and <code>DynMetadata</code> methods should really all be safe</p>",
        "id": 265362596,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776295
    },
    {
        "content": "<p>The only current danger I see in the DynMetadata API is that a <code>&lt;dyn T&gt;::Metadata</code> might have a lifetime associated with it for e.g. jitted code</p>",
        "id": 265362606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776301
    },
    {
        "content": "<p>we could duplicate the APIs for references and raw pointers (e.g. <code>std::ptr::metadata_ref</code>, <code>DynMetadataRef</code>, but that seems far from ideal</p>",
        "id": 265362647,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776332
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265362596\">said</a>:</p>\n<blockquote>\n<p>e.g. <code>&amp;dyn MyTrait</code>, where <code>std::ptr::metadata</code> and <code>DynMetadata</code> methods should really all be safe</p>\n</blockquote>\n<p>I think it'd <em>absolutely</em> be valid to have a safe API on references, and an unsafe one on raw pointers.</p>",
        "id": 265362662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639776343
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265362572\">said</a>:</p>\n<blockquote>\n<p>That would be consistent with our stance elsewhere, which is \"it's not unsafe to make and store a bad raw pointer, only to dereference one\".</p>\n</blockquote>\n<p><a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#metadata-and-field-offsets\">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#metadata-and-field-offsets</a> suggests that we need at least alignment reading to be part of the validity invariant, I think</p>",
        "id": 265362667,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776346
    },
    {
        "content": "<p>that's only if we want to allow coercions involving raw pointers, right?</p>",
        "id": 265362754,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776377
    },
    {
        "content": "<p>well, that code is a stable coercion, I think -- but not 100% sure</p>",
        "id": 265362785,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776393
    },
    {
        "content": "<p>since it's <code>*const u32 -&gt; *const dyn Debug</code>, which you can do on stable already.</p>",
        "id": 265362809,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776405
    },
    {
        "content": "<p>that example seems to rely on the existence of a <code>CoerceUnsized</code> impl, which is unstable</p>",
        "id": 265362853,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776434
    },
    {
        "content": "<p>because otherwise, you can't coerce through a custom <code>RefCounted</code> struct</p>",
        "id": 265362884,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776454
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265362785\">said</a>:</p>\n<blockquote>\n<p>well, that code is a stable coercion, I think -- but not 100% sure</p>\n</blockquote>\n<p>(This is another aside, but if that's allowed without an <code>as</code>...argh.)</p>",
        "id": 265362900,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639776466
    },
    {
        "content": "<p>I'm fairly certain that there are no stable safe coercions that would require alignment reading to be part of the validity invariant</p>",
        "id": 265362999,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776517
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=826dfd2519dedc2f082f400736452802\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=826dfd2519dedc2f082f400736452802</a></p>\n<div class=\"codehilite\"><pre><span></span><code>use std::rc::Rc;\nfn foo(v: *const Rc&lt;u32&gt;) -&gt; *const Rc&lt;dyn std::fmt::Debug&gt; {\n    v as *const Rc&lt;dyn std::fmt::Debug&gt;\n}\n</code></pre></div>",
        "id": 265363000,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776517
    },
    {
        "content": "<p>that's just wrong though</p>",
        "id": 265363035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776551
    },
    {
        "content": "<p>That doesn't have the same problem as the example, I think. <code>Rc</code> doesn't expose its fields, so you can't actually \"see\" how it affects the alignment</p>",
        "id": 265363046,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776560
    },
    {
        "content": "<p>that's not an upsize coercion, both of those are sized types</p>",
        "id": 265363067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776570
    },
    {
        "content": "<p>/me is remembering a discussion we had about optimizing <code>Rc</code> that involved ratifying an assumption there; trying to find it...</p>",
        "id": 265363072,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639776574
    },
    {
        "content": "<p>that is just a <code>ptr::cast</code>, and an incorrect one too</p>",
        "id": 265363104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776599
    },
    {
        "content": "<p>I think all of the stdlib types with <code>CoerceUnsized</code> impls have private fields, so <a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#metadata-and-field-offsets\">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#metadata-and-field-offsets</a> doesn't apply</p>",
        "id": 265363106,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776599
    },
    {
        "content": "<p>you can't use <code>raw_addr!</code> to do anything weird</p>",
        "id": 265363184,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776616
    },
    {
        "content": "<p>yeah, I suppose -- <a href=\"https://doc.rust-lang.org/nightly/core/mem/fn.align_of_val_raw.html\">https://doc.rust-lang.org/nightly/core/mem/fn.align_of_val_raw.html</a> is unsafe.</p>",
        "id": 265363223,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776636
    },
    {
        "content": "<p>(which is in conflict with the safe std::ptr::metadata APIs, but that's another story).</p>",
        "id": 265363254,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776653
    },
    {
        "content": "<p>Ignoring <code>std::ptr::metadata</code> for the moment, I think it would be possible for all of the raw pointer metadata functions (like <code>align_of_val_raw</code> to just state their requirements upfront, without imposing any requirements on the validity of safety invariants</p>",
        "id": 265363313,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265363104\">said</a>:</p>\n<blockquote>\n<p>that is just a <code>ptr::cast</code>, and an incorrect one too</p>\n</blockquote>\n<p>not sure I follow this -- the above function unsizes, it's not just a pointer cast</p>",
        "id": 265363314,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776714
    },
    {
        "content": "<p>e.g. the <code>Safety</code> section states that the vtable pointer needs to be valid, the vtable memory needs to be set up right, etc</p>",
        "id": 265363374,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776740
    },
    {
        "content": "<p>Considering <code>std::ptr::metadata</code>, I think we would need to duplicate the APIs for references + raw pointers in order to avoid any validity and safety requirements on metadata</p>",
        "id": 265363454,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639776783
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> you casted from a thin pointer to an Rc to a thin pointer to a fat Rc; dereferencing the result would cause UB</p>",
        "id": 265363482,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776803
    },
    {
        "content": "<p>the fat part of the pointer isn't stored in the rc</p>",
        "id": 265363513,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776820
    },
    {
        "content": "<p><code>Rc&lt;dyn std::fmt::Debug&gt;</code> has size 16, <code>*const Rc&lt;dyn std::fmt::Debug&gt;</code> has size 8</p>",
        "id": 265363603,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776848
    },
    {
        "content": "<p>ah, hm</p>",
        "id": 265363647,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776881
    },
    {
        "content": "<p>I would have expected that to work fine (maybe Rc is weird here?)</p>",
        "id": 265363668,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776897
    },
    {
        "content": "<p>This is working as intended, I think - <code>Rc&lt;dyn debug&gt;</code> is a fat pointer just like <code>&amp;dyn Debug</code> or <code>Box&lt;dyn Debug&gt;</code></p>",
        "id": 265363754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776948
    },
    {
        "content": "<p>the extra <code>*const</code> makes it a thin pointer to a fat pointer</p>",
        "id": 265363821,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639776966
    },
    {
        "content": "<p>ah, right</p>",
        "id": 265363847,
        "sender_full_name": "simulacrum",
        "timestamp": 1639776991
    },
    {
        "content": "<p>Wait, how does an Rc fat pointer fit in 16 bytes? Where's the refcount?</p>",
        "id": 265363880,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777014
    },
    {
        "content": "<p>The payload of <code>Rc&lt;T&gt;</code> is a <code>NonNull&lt;RcImpl&lt;T&gt;&gt;</code></p>",
        "id": 265363921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639777037
    },
    {
        "content": "<p>Better example would've been:</p>\n<div class=\"codehilite\"><pre><span></span><code>use std::cell::Cell;\nfn foo(v: *const Cell&lt;u32&gt;) -&gt; *const Cell&lt;dyn std::fmt::Debug&gt; {\n    v\n}\n</code></pre></div>",
        "id": 265363928,
        "sender_full_name": "simulacrum",
        "timestamp": 1639777044
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Ah.</p>",
        "id": 265363951,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777058
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> The example you linked to involving <code>RefCounted</code> seems evocative, and it seems like it has something in common with \"object safety\". I'm wondering if there's some kind of generalized rule here, involving the use of generics <em>inside</em> a dyn, to specify when you need a valid vtable to know the layout of an object. Because it seems valid that you can't get the raw pointer offset to that field without knowing the types involved (which would involve having valid information about the type), while you <em>should</em> be able to get a similar raw pointer offset for a non-generic struct.</p>",
        "id": 265364214,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777221
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265363928\">said</a>:</p>\n<blockquote>\n<p>Better example would've been:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>use std::cell::Cell;\nfn foo(v: *const Cell&lt;u32&gt;) -&gt; *const Cell&lt;dyn std::fmt::Debug&gt; {\n    v\n}\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ow. Not a single <code>as</code> in that. That feels very much more like C than Rust sensibilities, insofar as allowing a coercion there without a cast.</p>",
        "id": 265364298,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777282
    },
    {
        "content": "<p>(Leaving aside the thin-vs-fat pointer question.)</p>",
        "id": 265364332,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777307
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265364214\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> The example you linked to involving <code>RefCounted</code> seems evocative, and it seems like it has something in common with \"object safety\". I'm wondering if there's some kind of generalized rule here, involving the use of generics <em>inside</em> a dyn, to specify when you need a valid vtable to know the layout of an object. Because it seems valid that you can't get the raw pointer offset to that field without knowing the types involved (which would involve having valid information about the type), while you <em>should</em> be able to get a similar raw pointer offset for a non-generic struct.</p>\n</blockquote>\n<p>I think the important thing to note here is that a <code>CoerceUnsize</code> impl needs to be written for this to work. As the mutliple soundness issues with <code>Pin</code> have shown, <code>CoerceUnsize</code> can be quite complicated</p>",
        "id": 265364422,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639777351
    },
    {
        "content": "<p>and there's probably a lot of work that would need to be done in order to stabilize <code>CoerceUnsized</code>, and allow users towrite their own impls of it</p>",
        "id": 265364451,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639777378
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265364298\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265363928\">said</a>:</p>\n<blockquote>\n<p>Better example would've been:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>use std::cell::Cell;\nfn foo(v: *const Cell&lt;u32&gt;) -&gt; *const Cell&lt;dyn std::fmt::Debug&gt; {\n    v\n}\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Ow. Not a single <code>as</code> in that. That feels very much more like C than Rust sensibilities, insofar as allowing a coercion there without a cast.</p>\n</blockquote>\n<p>This seems like another case of conflicting principles. It makes sense that you can pass an object type where a trait implemented by that object was expected. But separately, it seems like <code>*T</code> should never silently coerce to <code>*U</code> if T is not <em>exactly</em> U.</p>",
        "id": 265364484,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777403
    },
    {
        "content": "<p>Anyway, that digression can wait for Rust 2024, and/or whenever we get around to trying to eliminate both <code>as</code> and potentially some coercions. :)</p>",
        "id": 265364583,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265363928\">said</a>:</p>\n<blockquote>\n<p>Better example would've been:</p>\n<p><div class=\"codehilite\"><pre><span></span><code>use std::cell::Cell;\nfn foo(v: *const Cell&lt;u32&gt;) -&gt; *const Cell&lt;dyn std::fmt::Debug&gt; {\n    v\n}\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>In this example, is Rust using magic knowledge about Cell here, or is this generating an invalid pointer from a valid one?</p>",
        "id": 265364725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777524
    },
    {
        "content": "<p>/me checks struct sizes.</p>",
        "id": 265364737,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777537
    },
    {
        "content": "<p>It's using the <code>CoerceUnized</code> impl</p>",
        "id": 265364741,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639777540
    },
    {
        "content": "<p>implementing it requires that <code>Cell</code> just has one non-ZST field</p>",
        "id": 265364761,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639777554
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> Aaaaah. Got it.</p>",
        "id": 265364817,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777565
    },
    {
        "content": "<p>though I had only ever seen it used for references before</p>",
        "id": 265364901,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639777592
    },
    {
        "content": "<p>So <code>CoerceUnsized</code> <em>is</em> the \"magic knowledge about <code>Cell</code>\" I was wondering about, then. \"This thing contains only one pointer, and Rust can turn it from a thin pointer into a fat pointer\".</p>",
        "id": 265364941,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777624
    },
    {
        "content": "<p>Regarding pointers to unsized, I <em>also</em> didn't realize that <code>* [T]</code> was a fat pointer. I had thought it was a thin pointer to a thing that had a size in it.</p>",
        "id": 265365374,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777835
    },
    {
        "content": "<p>But sure enough, <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=7e5e1d58e1a952845f34d241f0042b6d\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=7e5e1d58e1a952845f34d241f0042b6d</a></p>",
        "id": 265365439,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777886
    },
    {
        "content": "<p>I believe that <code>&amp;T, &amp;mut T, *const T, *mut T</code> always have the same representation in memory</p>",
        "id": 265365544,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639777942
    },
    {
        "content": "<p>/me has the feeling of retroactively having a rug pulled out from under him.</p>",
        "id": 265365618,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639777999
    },
    {
        "content": "<p>/me tries to recalibrate for how raw unsized pointers have apparently worked, and apply that to the question of validity invariants.</p>",
        "id": 265366052,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639778299
    },
    {
        "content": "<p>I'd have to think about it a bit more, but this is roughly leading me towards \"these things already didn't act at all like other raw pointers, so having them act even less like raw pointers might not make things any <em>worse</em>?\". :)</p>",
        "id": 265366115,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639778343
    },
    {
        "content": "<p>The \"think about it a bit more\" likely amounts to \"is there any way to make them <em>more</em> like raw pointers in a useful way, or should I give up on that line of thinking\".</p>",
        "id": 265366163,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639778374
    },
    {
        "content": "<p>I don't see the value of having the metadata of fat raw pointers be raw, TBH.</p>",
        "id": 265375637,
        "sender_full_name": "Gary Guo",
        "timestamp": 1639783525
    },
    {
        "content": "<p>Since C don't have fat pointers, C FFI wouldn't be a concern; this is pretty much a Rust-only concept. All other types interacting with unsized types all expect valid metadata.</p>",
        "id": 265375736,
        "sender_full_name": "Gary Guo",
        "timestamp": 1639783607
    },
    {
        "content": "<p>And arbitrary self types, trait upcasting and metadata API as currently implemented all expect the metadata to be valid.</p>",
        "id": 265376103,
        "sender_full_name": "Gary Guo",
        "timestamp": 1639783911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/raw.20pointers.20to.20dyn.20T.2C.20size.2C.20layout.2C.20and.20expectations/near/265365544\">said</a>:</p>\n<blockquote>\n<p>I believe that <code>&amp;T, &amp;mut T, *const T, *mut T</code> always have the same representation in memory</p>\n</blockquote>\n<p>Raw fat pointers are not ffi safe though, there are lints about this already if you try to use or return such types in an extern C function or repr(C) struct</p>",
        "id": 265407815,
        "sender_full_name": "marmeladema",
        "timestamp": 1639819014
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/boxed/index.html\">https://doc.rust-lang.org/std/boxed/index.html</a></p>\n<p>Is the place where those things are documented, though it through Box, it does talk about about raw pointers to Sized Vs DST</p>",
        "id": 265407886,
        "sender_full_name": "marmeladema",
        "timestamp": 1639819148
    }
]