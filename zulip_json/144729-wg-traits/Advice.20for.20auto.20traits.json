[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span><br>\nIt seems like the hard part of getting auto traits to work is checking whether a user-given impl exists.<br>\nI looked into \"impl_provided_for\" to see how this works for ADTs but I think the current approach does not really work.</p>\n<p>Consider for example this program:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[auto] trait A {}\nstruct S&lt;T&gt; {}\nstruct E {}\nstruct B {}\nimpl !A for S&lt;E&gt; {}\n</code></pre></div>\n\n\n<p>In theory <code>S&lt;B&gt;: A</code> should hold as there is no negative impl for it.<br>\nBut the current impl_provided_for sees an impl for S&lt;_&gt; and understands that as an impl for S&lt;B&gt;. (as only the AdtId is compared)</p>\n<p>I think whats really necessary here is to ask the solver whether <code>S&lt;B&gt;: A</code> or <code>S&lt;B&gt;: !A</code> has an implementation \"without applying the auto rules\",<br>\nand if there is none, _then_ we should add our own auto-implementation.</p>\n<p>Do you agree?</p>",
        "id": 210227292,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600239450
    },
    {
        "content": "<p>In this particular case we could just extend impl_provided_for to also check whether the generic parameters match.<br>\nBut for more complex examples (like the following) we need to call the solver I think</p>\n<div class=\"codehilite\"><pre><span></span><code>#[auto] trait A {}\nstruct S&lt;T&gt; {}\nstruct E {}\nstruct B {}\n\ntrait Condition {}\nimpl Condition for E {}\n\nimpl&lt;T: Condition&gt; !A for S&lt;T&gt; {} // not valid chalk, but you get the idea\n</code></pre></div>",
        "id": 210227535,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600239680
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"335294\">memoryleak47</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210227292\">said</a>:</p>\n<blockquote>\n<p>I think whats really necessary here is to ask the solver whether <code>S&lt;B&gt;: A</code> or <code>S&lt;B&gt;: !A</code> has an implementation \"without applying the auto rules\",<br>\nand if there is none, _then_ we should add our own auto-implementation.</p>\n</blockquote>\n<p>note: that is what rustc does, it first checks for impl candidates for <code>S&lt;B&gt;</code> (with both polarities), and if there is no impl candidates (or any other candidates, for that matter), only then adds auto trait candidates</p>",
        "id": 210235843,
        "sender_full_name": "Areredify",
        "timestamp": 1600246189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"335294\">@memoryleak47</span> this is incorrect, <code>impl !A for S&lt;E&gt;</code> <em>does</em> suppress the auto trait</p>",
        "id": 210241179,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250320
    },
    {
        "content": "<p>The idea is that we add an impl if you haven't said anything</p>",
        "id": 210241193,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250337
    },
    {
        "content": "<p>Otherwise, if you think about it, there would be no way to say that a struct is <em>not</em> <code>Send</code> (that would otherwise be Send)</p>",
        "id": 210241205,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250351
    },
    {
        "content": "<p>i.e., imagine you have <code>struct Foo;</code> and you want to declare that this is a marker type that is not meant to be send -- you kind of couldn't do it :)</p>",
        "id": 210241218,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250377
    },
    {
        "content": "<p>note that this design does cause a lot of surprise and is in fact still unstable in rustc, so it is not universally agreed that it should work this way; but I personally still think it's right, and in any case we ought to match rustc for now</p>",
        "id": 210241296,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250424
    },
    {
        "content": "<p>One thing that we were planning to add to rustc was to make it illegal to add negative impls that are conditional, which also helps to avoid the situation. That's never been done though.</p>",
        "id": 210241359,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250480
    },
    {
        "content": "<p>(One of the partial motivations here is that I wouldn't want to have to make the rules say \"use the auto trait but only if no user-given trait applies...\". That is kind of what happens with normalizing projects and it's trouble enough :) there is some precedent for handling it, I've read up a bit on some of the techniques folks use in the past -- but it's definitely an added complication that I don't Rust needs)</p>",
        "id": 210241510,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250601
    },
    {
        "content": "<p>(Although specialization also does something similar, but it doesn't introduce negation into the mix)</p>",
        "id": 210241532,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600250622
    },
    {
        "content": "<p>Ah, interesting.<br>\nSo just to be sure <code>impl !A for S&lt;E&gt;</code>suppresses the auto trait for all <code>S&lt;_&gt;</code>, right?<br>\nBut considering your example - I don't understand why <code>impl !Send for Foo {}</code> would not work in that scenario.</p>",
        "id": 210251946,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600258317
    },
    {
        "content": "<p>Currently <code>impl !A for S&lt;E&gt;</code> suppresses the auto trait for <code>S&lt;_&gt;</code> (with an inference variable) but not for <code>S&lt;F&gt;</code> where <code>F</code> is some type that does not unify with <code>E</code>, which is pretty unintuitive.</p>",
        "id": 210278608,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1600270017
    },
    {
        "content": "<p>hm... but given <code>impl !A for S&lt;E&gt; {}</code>, wouldn't then <code>A: S&lt;B&gt;</code> still hold in my example above?<br>\nBecause if I understood correctly, niko disagreed to this.</p>",
        "id": 210279472,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600270369
    },
    {
        "content": "<p>Given <a href=\"https://github.com/rust-lang/chalk/blob/3ea88b7cc10de78b632962881e8b150dc5285281/chalk-solve/src/clauses.rs#L73\">this</a> code (and <a href=\"https://github.com/rust-lang/rust/blob/5fae56971d8487088c0099c82c0a5ce1638b5f62/compiler/rustc_traits/src/chalk/db.rs#L327\">this</a> somewhat, <em>any</em> impl for <code>S</code> suppresses the auto impl generation for all <code>S</code></p>",
        "id": 210285069,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600272886
    },
    {
        "content": "<p>But, I think this behavior is different between rustc and Chalk atm</p>",
        "id": 210285689,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600273198
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b7f6c29e04a85a66d8b677b55a7f2d5e\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=b7f6c29e04a85a66d8b677b55a7f2d5e</a></p>",
        "id": 210285808,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600273228
    },
    {
        "content": "<p>For builtin types, what's the tricky part here?</p>",
        "id": 210286016,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600273324
    },
    {
        "content": "<p>I guess implementing the rustc-like behaviour is somewhat tricky, but if the chalk-version was desired after all, then it shouldn't be too tricky.</p>",
        "id": 210290310,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600275443
    },
    {
        "content": "<p>I think for now, it's okay to follow the Chalk logic of \"any impl causes no auto impls at all\"</p>",
        "id": 210291059,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600275827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span><br>\nI implemented the auto trait handling for a few built-in types now. (see <a href=\"https://github.com/rust-lang/chalk/pull/612\">https://github.com/rust-lang/chalk/pull/612</a>)<br>\nMaybe you can have a look, in order to check whether it goes into the right direction. (:</p>",
        "id": 210548132,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600448665
    },
    {
        "content": "<p>let me look</p>",
        "id": 210550240,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600449815
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"335294\">@memoryleak47</span> made a couple comments</p>",
        "id": 210563351,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600456401
    },
    {
        "content": "<p>So, I implemented the chalk behavior as \"the behavior I think rustc is meant to have\"</p>",
        "id": 210564707,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600457086
    },
    {
        "content": "<p>but rustc is a bit behind</p>",
        "id": 210564724,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600457097
    },
    {
        "content": "<p>what I meant <span class=\"user-mention\" data-user-id=\"335294\">@memoryleak47</span> about <code>impl !Send for Foo</code> is I guess this, trying to explain as best I can:</p>\n<p>We can imagine that \"auto traits\" and \"negative impls\" lower into fundamental chalk rules. Under the current setup, negative impls don't actually create any kind of \"program clause\" at the chalk level -- they just <em>suppress</em> the creation of program clauses. So you never get a <code>Implemented(Foo: Send)</code> rule at all.</p>\n<p>If we wanted to say that we <em>always</em> add a <code>Implemented(Foo: Send)</code> rule for every struct <code>Foo</code> (plus all the generics; e.g., <code>forall&lt;T&gt; Implemented(Foo&lt;T&gt;: Send)</code> for a <code>struct Foo&lt;T&gt;</code>, etc., then we have to say that the negative impls lowers to a kind of \"negative program clause\" (e.g., <code>!Implemented</code>). This starts to get into what is called <em>defeasible</em> logics, because you can say that the negative program clause \"defeats\" the positive one.</p>\n<p>To some extent, we already have a kind of defeasible logic, because specialization allows one to set defaults that get overridden, but those defaults are limited in some ways. For example, you are not allowed to \"unimplement\" something that was already implemented by a base impl, and you also can only override associated types that are marked as default -- and those \"defeasible\" associated types (which are marked as default) cannot be normalized during normal type-checking (by design). The reason we don't permit them to normalize is precisely so that we don't have to worry about having one rule that permits a conclusion and another rule that \"defeats\" that conclusion.  So that limits the points where we have to worry about defeasability (but only somewhat; we still have to be able to resolve to the correct result during code generation, so it may not be that useful).</p>\n<p>(Note that the way I planned to implement the specialization logic is not to extend chalk with a first-class notion of defeasible rules but rather to incorporate negative goals, i.e., you can normalize a <code>default</code> associated type if you can show that no more specialized impls apply. This is basically an internal \"lowering\" step from a defeasible logic to a more limited one.)</p>\n<p>Anyway, we could potentially in the future extend auto traits in this way. For now, negative impls are unstable, and I'd probably want to keep them that way until we finish implementing stabilization in chalk and have worked through some of those implications. (Or perhaps stabilize them but limited to cases where they apply to <em>all</em> instances of a type, so that we sidestep it.)</p>\n<p>I guess that from an <em>expectations</em> point of view, I personally find this code rather unclear:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>I think it's rather unclear whether <code>Foo&lt;i32&gt;</code> is meant to be <code>Send</code> or not!</p>\n<p>Anyway, that's how I see it right now.</p>",
        "id": 210565581,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600457624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210565581\">said</a>:</p>\n<blockquote>\n<p>I guess that from an <em>expectations</em> point of view, I personally find this code rather unclear:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>I think it's rather unclear whether <code>Foo&lt;i32&gt;</code> is meant to be <code>Send</code> or not!</p>\n</blockquote>\n<p>To expand, and so I think I might prefer to err on the side of \"no\". On the other hand, people ask this question a lot, so maybe I'm just unique in finding it kind of unclear. I think what surprises me is that I <em>see</em> the <code>!Send</code> impl but I don't see the <code>impl Send</code> that is implicitly added, and so I feel like it's harder for me to know the full set of impls that exist, I could forget that the compiler is added a default one.</p>\n<p>In contrast, when there is <em>no user-written impl at all</em>, it feels like \"oh of course I have to remember the ones that the compiler added\".</p>",
        "id": 210565813,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600457736
    },
    {
        "content": "<p>I guess I should probably move this text somewhere more permanent.</p>",
        "id": 210565912,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600457793
    },
    {
        "content": "<p>I think the takeaway from this is that auto traits are <em>wierd</em></p>",
        "id": 210566191,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600457968
    },
    {
        "content": "<p>At least, more weird than they seem at first glance</p>",
        "id": 210566204,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600457977
    },
    {
        "content": "<p>Yeah, more complex than you might think at least!</p>",
        "id": 210566386,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458069
    },
    {
        "content": "<p>I wonder if I would have proposed them if I'd fully understood what extra pain they add :P</p>",
        "id": 210566408,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458085
    },
    {
        "content": "<p>on the other hand, I think that they still feel right from the usability perspective to me most of the time....</p>",
        "id": 210566424,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458099
    },
    {
        "content": "<p>though I don't know how much people get burned by the \"implicit semver guarantee of send-ness\"</p>",
        "id": 210566450,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458118
    },
    {
        "content": "<p>it basically never affects me in my daily life</p>",
        "id": 210566473,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458123
    },
    {
        "content": "<p>but I don't develop libraries that have to maintain strict semver etc</p>",
        "id": 210566506,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458132
    },
    {
        "content": "<p>Well, it definitely starts to get even more hairy once you start thinking about opaque types and such</p>",
        "id": 210566536,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458151
    },
    {
        "content": "<p>like <code>fn foo() -&gt; impl Trait</code> could or could not be <code>Send</code></p>",
        "id": 210566580,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458178
    },
    {
        "content": "<p>yes. though that's definitely another case where the feature would be so much less usable...</p>",
        "id": 210566760,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458263
    },
    {
        "content": "<p>put another way, that's kind of the same as any struct I guess :)</p>",
        "id": 210566769,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458274
    },
    {
        "content": "<p>Hmm, true. I guess with a struct, I just assume that the onus for <code>Send</code>/<code>!Send</code> is on the <em>struct</em>, whereas with <code>impl Trait</code>, it's instead on the <em>function</em></p>",
        "id": 210567028,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458414
    },
    {
        "content": "<p>Additionally, docs here sort of change how these are viewed too</p>",
        "id": 210567224,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458511
    },
    {
        "content": "<p>With a struct, you can go in rustdoc and see if that auto impls <code>Send</code>, with an <code>impl Trait</code> return you can't</p>",
        "id": 210567259,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458532
    },
    {
        "content": "<p>(you could also write a static assert that a struct is <code>Send</code> whereas <code>impl Trait</code> no)</p>",
        "id": 210567372,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458594
    },
    {
        "content": "<p>(we can fix that in the docs, but yes)</p>",
        "id": 210567691,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600458734
    },
    {
        "content": "<p>imo, the proper solution is that you can't rely on <code>impl Trait</code> being <code>Send</code> unless you add <code>impl Trait + Send</code></p>",
        "id": 210567742,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458777
    },
    {
        "content": "<p>But...that has it's own problems</p>",
        "id": 210567758,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458788
    },
    {
        "content": "<p>and isn't backwards compat anyways</p>",
        "id": 210567768,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458793
    },
    {
        "content": "<p>maybe an <code>impl Trait + !Send</code> or <code>impl Trait + ?Send</code> would be better?</p>",
        "id": 210567900,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458862
    },
    {
        "content": "<p>idk</p>",
        "id": 210567902,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600458862
    },
    {
        "content": "<p>not relitigating this :)</p>",
        "id": 210568225,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1600459034
    },
    {
        "content": "<p>oops lol</p>",
        "id": 210568331,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600459083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210565581\">said</a>:</p>\n<blockquote>\n<p>what I meant <span class=\"user-mention silent\" data-user-id=\"335294\">memoryleak47</span> about <code>impl !Send for Foo</code> is I guess this, trying to explain as best I can:</p>\n</blockquote>\n<p>Thanks for the explanation! :D</p>",
        "id": 210570262,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600460051
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span><br>\nI just implemented the note from <span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> (which drastically simplified the code <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> ) and made your requested changes somewhat obsolete, as the underlying code is just gone.<br>\nSo you may want to re-review it.</p>",
        "id": 210570611,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600460272
    },
    {
        "content": "<p>Looks much better</p>",
        "id": 210570958,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600460465
    },
    {
        "content": "<p>I wonder about closures a bit.<br>\nThe captured variables live in <code>closure_upvars</code> apparently.<br>\nIs is true that it gives me <code>Binders&lt;Ty&gt;</code> because of potential lifetimes to the stack (i.e. the Binders will only have VariableKind::Lifetime)?<br>\nBecause this would imply that I am free to do <code>.skip_binders()</code>, I believe.</p>",
        "id": 210606873,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600508460
    },
    {
        "content": "<p>Hm... but then there would still be unbound variables returned which would cause trouble.<br>\nI could insert the 'static lifetime possibly, but it feels kind of dangerous.</p>",
        "id": 210606947,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600508599
    },
    {
        "content": "<p>In addition to that I wonder how I should work with opaque / associated types.<br>\nI'd think that we just don't generate any impls for them, or should we try to normalize them?</p>",
        "id": 210607408,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600509386
    },
    {
        "content": "<p>Now we're getting to the harder bit :)</p>",
        "id": 210608011,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600510657
    },
    {
        "content": "<p>So for closures, upvars give a tuple of types, not lifetimes IIRC, and those should be the constituent types.</p>",
        "id": 210608091,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600510747
    },
    {
        "content": "<p>Hm.. in the docs it says that one should not assume anything about the type, though</p>",
        "id": 210608109,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600510794
    },
    {
        "content": "<p>So, opaque and associated types, I'll have to check how rustc does it</p>",
        "id": 210608112,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600510801
    },
    {
        "content": "<p>Where?</p>",
        "id": 210608156,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600510811
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"335294\">memoryleak47</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210608109\">said</a>:</p>\n<blockquote>\n<p>Hm.. in the docs it says that one should not assume anything about the type, though</p>\n</blockquote>\n<p>There are no restrictions on the type of upvars.<br>\n<a href=\"https://rust-lang.github.io/chalk/chalk_solve/trait.RustIrDatabase.html#tymethod.closure_upvars\">https://rust-lang.github.io/chalk/chalk_solve/trait.RustIrDatabase.html#tymethod.closure_upvars</a></p>",
        "id": 210608160,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600510826
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210608112\">said</a>:</p>\n<blockquote>\n<p>So, opaque and associated types, I'll have to check how rustc does it</p>\n</blockquote>\n<p>Ah, I can do that too. But I'd require a starting point, didn't find anything relevant by myself.</p>",
        "id": 210608249,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600510947
    },
    {
        "content": "<p>Also, I wonder whats the semantical difference of <code>TyData::Apply(ApplicationTy { name: TypeName::Opaque, ..})</code> vs. <code>TyData::Alias(AliasTy::Opaque(...))</code></p>",
        "id": 210608324,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511097
    },
    {
        "content": "<p>Oops, for upvars, I think we can only care about the types</p>",
        "id": 210608487,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210608091\">said</a>:</p>\n<blockquote>\n<p>So for closures, upvars give a tuple of types, not lifetimes IIRC, and those should be the constituent types.</p>\n</blockquote>\n<p>I'm asking what the <code>Binders&lt;_&gt;</code> does, not the <code>Ty</code> inside.</p>",
        "id": 210608489,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511308
    },
    {
        "content": "<p>I can try to get you a link in rustc</p>",
        "id": 210608492,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511315
    },
    {
        "content": "<p>So, the Binders are late bound vars</p>",
        "id": 210608500,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511333
    },
    {
        "content": "<p>I think it should only be lifetimes</p>",
        "id": 210608511,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511344
    },
    {
        "content": "<p>So, you would do forall</p>",
        "id": 210608520,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511364
    },
    {
        "content": "<p>Sorry, on mobile currently so can't be super precise.</p>",
        "id": 210608534,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511397
    },
    {
        "content": "<p>You mean <code>for&lt;&gt; ...</code>?</p>",
        "id": 210608582,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511409
    },
    {
        "content": "<p>err, sorry - like this <code>for&lt;'a&gt; Fn(&amp;'a i32)</code>?</p>",
        "id": 210608638,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511521
    },
    {
        "content": "<p>Right, so one of the conditions would be <code>forall&lt;'a,...&gt; &lt;tuple&gt;: AutoTrait</code></p>",
        "id": 210608757,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511676
    },
    {
        "content": "<p>Btw I'm also cool if you want to finish up the PR for the next simple cases already covered</p>",
        "id": 210608778,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511739
    },
    {
        "content": "<p>And the do a followup PR for the more complicated ones</p>",
        "id": 210608779,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511752
    },
    {
        "content": "<p>Yeah, maybe thats better (:</p>",
        "id": 210608816,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511771
    },
    {
        "content": "<p>Yeah, I probably prefer that tbh</p>",
        "id": 210608879,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511894
    },
    {
        "content": "<p>Like I said, these are the harder bits</p>",
        "id": 210608881,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511912
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210608757\">said</a>:</p>\n<blockquote>\n<p>Right, so one of the conditions would be <code>forall&lt;'a,...&gt; &lt;tuple&gt;: AutoTrait</code></p>\n</blockquote>\n<p>Ah, you mean using a chalk <code>forall&lt;'a&gt; { ... }</code> clause and not the <code>for&lt;&gt;</code>syntax. That makes a lot of sense. :)<br>\nI think I can sneak this in, and then make the PR ready for merging!</p>",
        "id": 210608883,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511920
    },
    {
        "content": "<p>Awesome!</p>",
        "id": 210608889,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511938
    },
    {
        "content": "<p>I think the big things left for the PR are tests</p>",
        "id": 210608895,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600511959
    },
    {
        "content": "<p>Ah, right.</p>",
        "id": 210608897,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511968
    },
    {
        "content": "<p>and I guess I need to update the book</p>",
        "id": 210608902,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600511979
    },
    {
        "content": "<p>That too</p>",
        "id": 210608947,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600512017
    },
    {
        "content": "<p>Well.. how do I actually compile the book?</p>",
        "id": 210610204,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600514426
    },
    {
        "content": "<p>If you look at <code>ci.yml</code>, it's doing <code>cd book &amp;&amp; ./mdbook build</code></p>",
        "id": 210611212,
        "sender_full_name": "detrumi",
        "timestamp": 1600516073
    },
    {
        "content": "<p>But <code>cargo install mdbook</code> might be easier than the curl stuff that CI is doing</p>",
        "id": 210611258,
        "sender_full_name": "detrumi",
        "timestamp": 1600516104
    },
    {
        "content": "<p>Thanks (:</p>",
        "id": 210611271,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600516159
    },
    {
        "content": "<p>Though if you have an editor with markdown preview, you can just use that and rely on CI to catch mistakes</p>",
        "id": 210611272,
        "sender_full_name": "detrumi",
        "timestamp": 1600516161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> ready to review <a href=\"https://github.com/rust-lang/chalk/pull/612\">https://github.com/rust-lang/chalk/pull/612</a></p>",
        "id": 210611762,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600517035
    },
    {
        "content": "<p>Ah, I forgot about this <code>// TODO record app_ty</code>-thingy from <code>logging_db.rs</code>.<br>\nShould I add another enum-variant for that or should I just ignore it?</p>",
        "id": 210612153,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600517620
    },
    {
        "content": "<p>I mean, I imagine you only need to record adts still?</p>",
        "id": 210619524,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600527876
    },
    {
        "content": "<p>Ok, gimme a second</p>",
        "id": 210619601,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600527978
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span></p>\n<blockquote>\n<p>PhantomData&lt;T&gt; should have T as a constituent type</p>\n</blockquote>\n<p>Interesting, whats the rationale on this?</p>",
        "id": 210620156,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600528779
    },
    {
        "content": "<p>the point of phantom data is to pretend you own data of type T</p>",
        "id": 210620221,
        "sender_full_name": "Areredify",
        "timestamp": 1600528833
    },
    {
        "content": "<p>Beat me</p>",
        "id": 210620224,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600528839
    },
    {
        "content": "<p>But yes</p>",
        "id": 210620226,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600528843
    },
    {
        "content": "<p>Haha, okay ^^</p>",
        "id": 210620230,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600528853
    },
    {
        "content": "<p>also you should consult with rustc when implementing these sorts of things</p>",
        "id": 210620235,
        "sender_full_name": "Areredify",
        "timestamp": 1600528869
    },
    {
        "content": "<p>Should I read out flags.phantom_data?</p>",
        "id": 210620237,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600528870
    },
    {
        "content": "<p>yes</p>",
        "id": 210620239,
        "sender_full_name": "Areredify",
        "timestamp": 1600528874
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/c10ad0d888df19e7185e15f811fdb011278f3c20/compiler/rustc_trait_selection/src/traits/select/mod.rs#L1698\">constituent types in rustc</a></p>",
        "id": 210620258,
        "sender_full_name": "Areredify",
        "timestamp": 1600528907
    },
    {
        "content": "<p>Ah, thanks for the pointer!</p>",
        "id": 210620322,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600528966
    },
    {
        "content": "<p>Alright, I guess the PR is ready for the next iteration of review ^^</p>",
        "id": 210621951,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600531277
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> <span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span></p>",
        "id": 210621957,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600531290
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/chalk/pull/612\">https://github.com/rust-lang/chalk/pull/612</a></p>",
        "id": 210621961,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600531303
    },
    {
        "content": "<p>Reviewed :)</p>",
        "id": 210622667,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600532254
    },
    {
        "content": "<p>I moved the Foreign-check.<br>\nDoesn't feel so nice to return an Option for this one special case, I think.</p>",
        "id": 210624637,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600534966
    },
    {
        "content": "<p>So, I'll need some guidance for opaque / assoc. types.<br>\nMy first guess would be to build a \"my_opaque_type :- hidden_type\" clause.<br>\nBut I don't know whether a hidden type is generally determined at this point in the compilation.</p>\n<p>Also, I'm not sure how ApplicationTy::Opaque and TyData::Alias(Opaque) differ in semantics.</p>",
        "id": 210731109,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600689708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"335294\">memoryleak47</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210731109\">said</a>:</p>\n<blockquote>\n<p>But I don't know whether a hidden type is generally determined at this point in the compilation.</p>\n</blockquote>\n<p>That's what <code>if (Reveal) { .. }</code> checks are for</p>",
        "id": 210731976,
        "sender_full_name": "detrumi",
        "timestamp": 1600690320
    },
    {
        "content": "<p>I thought opaque types don't get auto traits</p>",
        "id": 210734230,
        "sender_full_name": "Areredify",
        "timestamp": 1600691745
    },
    {
        "content": "<p>hmm, apparently they do</p>",
        "id": 210734609,
        "sender_full_name": "Areredify",
        "timestamp": 1600691956
    },
    {
        "content": "<p>huh?</p>",
        "id": 210734985,
        "sender_full_name": "Areredify",
        "timestamp": 1600692127
    },
    {
        "content": "<p>I find this behavior highly surprising</p>",
        "id": 210735163,
        "sender_full_name": "Areredify",
        "timestamp": 1600692242
    },
    {
        "content": "<p>I imagine opaque types only get auto traits from their bounds, not from the hidden type, right?</p>",
        "id": 210735300,
        "sender_full_name": "detrumi",
        "timestamp": 1600692323
    },
    {
        "content": "<p>thats why I am surprised, they don't</p>",
        "id": 210735324,
        "sender_full_name": "Areredify",
        "timestamp": 1600692341
    },
    {
        "content": "<p>You mean they don't get auto traits at all?</p>",
        "id": 210735394,
        "sender_full_name": "detrumi",
        "timestamp": 1600692368
    },
    {
        "content": "<p>no they get auto traits from the hidden type</p>",
        "id": 210735419,
        "sender_full_name": "Areredify",
        "timestamp": 1600692385
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=82081298b6189eba6ba8f8a44041384c\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=82081298b6189eba6ba8f8a44041384c</a></p>",
        "id": 210735423,
        "sender_full_name": "Areredify",
        "timestamp": 1600692387
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=0d1a6b3865bdd5bda0b2848d24ef3c2d\">expanded example</a></p>",
        "id": 210735847,
        "sender_full_name": "Areredify",
        "timestamp": 1600692620
    },
    {
        "content": "<p>surely there is an issue for this</p>",
        "id": 210735900,
        "sender_full_name": "Areredify",
        "timestamp": 1600692648
    },
    {
        "content": "<p>Oh right, that was in the <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md#semantics\">impl trait RFC</a>:</p>\n<blockquote>\n<p>Because OIBITS like Send and Sync will leak through an abstract return type, there will be some additional complexity in the compiler due to some non-local type checking becoming necessary.</p>\n</blockquote>",
        "id": 210735974,
        "sender_full_name": "detrumi",
        "timestamp": 1600692689
    },
    {
        "content": "<p>There's even a <a href=\"https://stackoverflow.com/questions/59037266/why-does-an-impl-trait-return-value-implement-send-while-boxdyn-trait-does\">stackoverflow question</a> about this</p>",
        "id": 210736208,
        "sender_full_name": "detrumi",
        "timestamp": 1600692810
    },
    {
        "content": "<p>We should document this in the chalk book</p>",
        "id": 210736385,
        "sender_full_name": "detrumi",
        "timestamp": 1600692902
    },
    {
        "content": "<p>bless shepmaster</p>",
        "id": 210736406,
        "sender_full_name": "Areredify",
        "timestamp": 1600692910
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125131\">detrumi</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210736385\">said</a>:</p>\n<blockquote>\n<p>We should document this in the chalk book</p>\n</blockquote>\n<p>yeah probably</p>",
        "id": 210736844,
        "sender_full_name": "Areredify",
        "timestamp": 1600693161
    },
    {
        "content": "<p>btw Niko and I discussed this literally just Friday lol: <a href=\"#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210566536\">https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/Advice.20for.20auto.20traits/near/210566536</a></p>",
        "id": 210737566,
        "sender_full_name": "Jack Huey",
        "timestamp": 1600693476
    },
    {
        "content": "<p>oh</p>",
        "id": 210737594,
        "sender_full_name": "Areredify",
        "timestamp": 1600693497
    },
    {
        "content": "<p>I read nikos big message and skipped the rest <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 210737640,
        "sender_full_name": "Areredify",
        "timestamp": 1600693516
    },
    {
        "content": "<p>deserved, I guess</p>",
        "id": 210737688,
        "sender_full_name": "Areredify",
        "timestamp": 1600693545
    },
    {
        "content": "<p>There is already a function <code>fn push_auto_trait_impls_opaque</code> which generates <code>opaque: Trait :- hidden: Trait</code>, but its only called for TyData::Alias(Opaque) and not for the ApplicationTy so far.<br>\nAgain, I'm not aware of the semantical difference between the two, but if their difference is not relevant to auto traits, then I could simply call this function from <code>push_auto_trait_impls</code>.</p>",
        "id": 210757837,
        "sender_full_name": "memoryleak47",
        "timestamp": 1600702123
    }
]