[
    {
        "content": "<p>bit of an open ended question- I was wondering how much work it would be to make <code>fn foo(_: impl for&lt;T&gt; Fn(T))</code> work? I would assume that it be rather easy other than the fact that we'd likely also want <code>impl for&lt;T: Trait&gt; Fn(T)</code> which im guessing is not so easy considering the ~3 or so open soundness holes that would be fixes by where clauses on binders have been open for ages</p>",
        "id": 277978323,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649224520
    },
    {
        "content": "<p>somewhat relatedly are GAT bounds like <code>T: Trait&lt;for&lt;U&gt; Assoc&lt;U&gt; = U&gt;</code> and <code>for&lt;U&gt; &lt;T as Trait&gt;::Assoc&lt;U&gt;: OtherTrait</code> the same<span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> thing impl wise as this and mean we would likely eventually get both at the same time?</p>",
        "id": 277978401,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649224606
    },
    {
        "content": "<p>Yea. If we fix the soundness bug for lifetimes, expanding the scope to types should be much easier, but I think there still are a few gotchas</p>",
        "id": 277985795,
        "sender_full_name": "oli",
        "timestamp": 1649230897
    },
    {
        "content": "<p>The debrujn (or what their name is) indices (offsets to declare which binder a lifetime belongs to) would have to be revamped or also implemented for types</p>",
        "id": 277985915,
        "sender_full_name": "oli",
        "timestamp": 1649230967
    },
    {
        "content": "<p><code>Tykind::Bound</code> already exists</p>",
        "id": 277985989,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649231018
    },
    {
        "content": "<p>(the docs on it even mention solving a <code>for&lt;T&gt;</code> trait bound) <a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/enum.TyKind.html#variant.Bound\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/sty/enum.TyKind.html#variant.Bound</a></p>",
        "id": 277986067,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649231048
    },
    {
        "content": "<p>Hmm... gotta check how we use those</p>",
        "id": 277986171,
        "sender_full_name": "oli",
        "timestamp": 1649231118
    },
    {
        "content": "<p>it sounds like we can already solve <code>for&lt;T&gt;</code> obligatons they just only arrise from canonicalizing inference vars which is why i was thinking that it wouldnt be very hard to make <code>U: for&lt;T&gt; Trait&lt;T&gt;</code> work</p>",
        "id": 277986252,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649231164
    },
    {
        "content": "<p>I think the GATs RFC mentions them in passing?  It does seem like a type-GAT is very similar to a <code>for&lt;T&gt;</code>.</p>\n<p>And FWIW, <a href=\"https://doc.rust-lang.org/nightly/std/ops/trait.Residual.html\">https://doc.rust-lang.org/nightly/std/ops/trait.Residual.html</a> is intentionally <em>not</em> a GAT, to work with more-restricted types, but I bet code would love to be able to write <code>for&lt;T&gt; Residual&lt;T&gt;</code> sometimes, instead of listing the <code>Continue</code> types it might ever need.</p>",
        "id": 277994199,
        "sender_full_name": "scottmcm",
        "timestamp": 1649235499
    },
    {
        "content": "<p>yeah gats mentions <code>For&lt;T&gt;</code> but only in \"we arent adding this in the gats feature\"</p>",
        "id": 277995435,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649236192
    },
    {
        "content": "<p>for&lt;'a&gt; is not all that ergonomic as you only get a single chance at applying it I believe. typechecking of higher ranked types is undecidable.</p>",
        "id": 277996634,
        "sender_full_name": "bjorn3",
        "timestamp": 1649236874
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/144729-wg-traits/topic/how.20hard.20is.20.60impl.20for.3CT.3E.20Fn.28T.29.60/near/277994199\">said</a>:</p>\n<blockquote>\n<p>I think the GATs RFC mentions them in passing?  It does seem like a type-GAT is very similar to a <code>for&lt;T&gt;</code>.</p>\n<p>And FWIW, <a href=\"https://doc.rust-lang.org/nightly/std/ops/trait.Residual.html\">https://doc.rust-lang.org/nightly/std/ops/trait.Residual.html</a> is intentionally <em>not</em> a GAT, to work with more-restricted types, but I bet code would love to be able to write <code>for&lt;T&gt; Residual&lt;T&gt;</code> sometimes, instead of listing the <code>Continue</code> types it might ever need.</p>\n</blockquote>\n<p>oh thats actually a pretty interesting case, I guess <code>trait Foo&lt;T&gt;</code> is more powerful than <code>trait Foo { type Assoc&lt;T&gt;</code> in some ways because you can decide whether to implement it for _all_ <code>T</code> or just some <code>T</code>... and in a world where <code>U: for&lt;T&gt; Foo&lt;T&gt;</code> worked that would actually be perfectly fine since you could accept only the types that are implemented for all of them...</p>",
        "id": 277996691,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649236918
    },
    {
        "content": "<p>You could emulate <code>for&lt;T&gt; fn(T)</code> using <code>trait GatFn { type Fn&lt;T&gt;: Fn(T); }</code> I think. Or does it not support the bound depending on the generic?</p>",
        "id": 277996806,
        "sender_full_name": "bjorn3",
        "timestamp": 1649236971
    },
    {
        "content": "<p>not sure what you would write for the trait impl</p>",
        "id": 277996866,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649237008
    },
    {
        "content": "<p><code>trait GatFn { const FN&lt;T&gt;: fn(T) }</code> i can imagine making work <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 277996963,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649237053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/144729-wg-traits/topic/how.20hard.20is.20.60impl.20for.3CT.3E.20Fn.28T.29.60/near/277996691\">said</a>:</p>\n<blockquote>\n<p>oh thats actually a pretty interesting case, I guess <code>trait Foo&lt;T&gt;</code> is more powerful than <code>trait Foo { type Assoc&lt;T&gt;</code> in some ways because you can decide whether to implement it for _all_ <code>T</code> or just some <code>T</code></p>\n</blockquote>\n<p>Yeah, I'm definitely picturing that we might hit some things like \"I can't implement that trait because I can only do <code>type Foo&lt;T: Copy&gt;</code>, not <em>any</em> <code>T</code>\" or something.  Or how <code>type Foo&lt;T&gt; = Cow&lt;T&gt;;</code> can't work, for example, since it needs a bound.</p>",
        "id": 277997344,
        "sender_full_name": "scottmcm",
        "timestamp": 1649237258
    },
    {
        "content": "<p>more reasons to avoid bounds on type definitions <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 277997451,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649237297
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/144729-wg-traits/topic/how.20hard.20is.20.60impl.20for.3CT.3E.20Fn.28T.29.60/near/277996634\">said</a>:</p>\n<blockquote>\n<p>for&lt;'a&gt; is not all that ergonomic as you only get a single chance at applying it I believe</p>\n</blockquote>\n<p>Would something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Iter</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">Iter</span>: <span class=\"nb\">Iterator</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Be possible?</p>",
        "id": 278027361,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1649253585
    },
    {
        "content": "<p>Not right now. I don't know whether ir not it is feasible in the future.</p>",
        "id": 278027759,
        "sender_full_name": "bjorn3",
        "timestamp": 1649253725
    },
    {
        "content": "<p>its just a syntax problem isnt it</p>",
        "id": 278032307,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649255607
    },
    {
        "content": "<p>like if you could write <code>for&lt;'a&gt; &lt;F as Fn&lt;(&amp;'a str),&gt;&gt;::Output: Iterator + 'a</code></p>",
        "id": 278032362,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649255629
    },
    {
        "content": "<p>It's not always a syntax problem -- Ibraheem's example shows when you want the input's lifetime to be related to the output, for example</p>",
        "id": 278053592,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649263994
    },
    {
        "content": "<p>right but does <code>for&lt;'a&gt; &lt;F as Fn&lt;(&amp;'a str,)&gt;&gt;::Output: Iterator + 'a</code> not accomplish this in a world where <code>Fn*</code> traits arent special and let you actually access the assoc ty</p>",
        "id": 278053730,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649264044
    },
    {
        "content": "<p>or is there some compiler type system limitation thing as to why we dont allow access to the assoc type directly and its not just a \"we arent sure what the trait definition should be for stabilisation\"</p>",
        "id": 278053787,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649264077
    },
    {
        "content": "<p>oh there isn't any special magic about accssing the associated type as far as i can tell, it acts just like any other</p>",
        "id": 278054142,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649264238
    },
    {
        "content": "<p>i'm more thinking about cases where splitting up the <code>for&lt;'a&gt;</code> causes one of them to become impossible</p>",
        "id": 278054189,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649264265
    },
    {
        "content": "<p>do you have examples of that? <del>though im a bit concerned my original question in this thread is gonna get burried lol</del></p>",
        "id": 278054497,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649264395
    },
    {
        "content": "<p>nah, but yeah i don't want to digress</p>",
        "id": 278054634,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649264420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/144729-wg-traits/topic/how.20hard.20is.20.60impl.20for.3CT.3E.20Fn.28T.29.60/near/277978401\">said</a>:</p>\n<blockquote>\n<p>somewhat relatedly are GAT bounds like <code>T: Trait&lt;for&lt;U&gt; Assoc&lt;U&gt; = U&gt;</code> and <code>for&lt;U&gt; &lt;T as Trait&gt;::Assoc&lt;U&gt;: OtherTrait</code> the same<span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> thing impl wise as this and mean we would likely eventually get both at the same time?</p>\n</blockquote>\n<p>GAT bounds like the former don't exist as syntax yet, but they are functionally equivalent to <code>for&lt;U&gt; Trait&lt;Assoc&lt;U&gt; = U&gt;</code> -- the <code>for&lt;..&gt;</code> inside the doesn't do anything special to the GAT</p>",
        "id": 278054816,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649264496
    },
    {
        "content": "<p>yeah I just wrote the for there cos i prefer it syntactically</p>",
        "id": 278054934,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649264532
    },
    {
        "content": "<p>i should not have done so in order to minimize comments xD</p>",
        "id": 278054954,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649264542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/144729-wg-traits/topic/how.20hard.20is.20.60impl.20for.3CT.3E.20Fn.28T.29.60/near/277978323\">said</a>:</p>\n<blockquote>\n<p>bit of an open ended question- I was wondering how much work it would be to make <code>fn foo(_: impl for&lt;T&gt; Fn(T))</code> work? I would assume that it be rather easy other than the fact that we'd likely also want <code>impl for&lt;T: Trait&gt; Fn(T)</code> which im guessing is not so easy considering the ~3 or so open soundness holes that would be fixes by where clauses on binders have been open for ages</p>\n</blockquote>\n<p>The first example \"should\" work -- not sure if the logic exists to instantiate higher-kinded type bounds exists, but it doesn't seem ridiculously out of reach.</p>",
        "id": 278055375,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649264732
    },
    {
        "content": "<p>But where clauses on binders seems like a whole nother level of bookkeeping, cause they're basically <code>A =&gt; B</code> implications...?</p>",
        "id": 278055383,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649264737
    },
    {
        "content": "<p>Yeah I feel like I vaguelly recall someone mentioning that where clauses on binders was a polonius thing <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 278056127,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649265089
    },
    {
        "content": "<p>perhaps a chalk thing? where clauses on binders (other than region-outlives-region) doesnt seem like sth polonius would care about <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 278056257,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649265154
    },
    {
        "content": "<p>yeah its the region outlives stuff that i think made it relevent to polonius idk xD</p>",
        "id": 278056294,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649265176
    },
    {
        "content": "<p>_extremeely not familiar with how polonius and chalk and rustc all fit together conceptually rn or planned in the future_</p>",
        "id": 278056328,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649265196
    },
    {
        "content": "<p>yeah, those seem relevant to polonius then, and also particularly easier to handle, since they don't participate in trait selection afaik</p>",
        "id": 278056410,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1649265235
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> <a href=\"#narrow/stream/144729-wg-traits/topic/how.20hard.20is.20.60impl.20for.3CT.3E.20Fn.28T.29.60/near/277996634\">said</a>:</p>\n<blockquote>\n<p>for&lt;'a&gt; is not all that ergonomic as you only get a single chance at applying it I believe. typechecking of higher ranked types is undecidable.</p>\n</blockquote>\n<p>Do you have a source? I'm curious whether that actually applies to rust (with or without various type system extensions like GATs, const eval, trait bounds, lifetimes, etc)</p>",
        "id": 278108331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649295716
    },
    {
        "content": "<p>eg <a href=\"https://cstheory.stackexchange.com/questions/37523/higher-rank-polymorphism-over-unboxed-types\">https://cstheory.stackexchange.com/questions/37523/higher-rank-polymorphism-over-unboxed-types</a></p>\n<blockquote>\n<p>In general rank-2 polymorphism has decidable type-inference but for rank k&gt;2 type-inference is undecidable.</p>\n</blockquote>",
        "id": 278119298,
        "sender_full_name": "bjorn3",
        "timestamp": 1649309555
    },
    {
        "content": "<p>As I understand it, the problem is with ML style expressions with nested lambdas over higher order variables, and I don't think any of that is expressible in rust. (Or maybe it is with this addition? Hard to say.) I was hoping for a more concrete example to see if it was possible to rewrite the example in rust, because this fact about higher order unification and type inference is something I have heard before but I couldn't give an explicit example of it if needed.</p>",
        "id": 278119739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649310149
    },
    {
        "content": "<p>Even if it is undecidable, it might still be possible to implement as in haskell, where this just means that types have to be provided sometimes when using <code>RankNTypes</code></p>",
        "id": 278119841,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649310258
    },
    {
        "content": "<p>That providing of types is what can be painful as eg providing types for closures can require an identity function through which the closure is passed to force the correct lifetimes.</p>",
        "id": 278120892,
        "sender_full_name": "bjorn3",
        "timestamp": 1649311547
    },
    {
        "content": "<p>isn't that an indication that correct and complete type inference is <em>already</em> not possible in rust? The workarounds are already well known</p>",
        "id": 278122259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649313059
    },
    {
        "content": "<p>I think the analogue of this for <code>for&lt;T&gt;</code> bounds is that we can't infer that <code>let foo = |f| f(0u32)</code> is supposed to be <code>foo: fn(impl for&lt;T&gt; Fn(T))</code> vs <code>foo: fn(impl Fn(u32))</code>, which doesn't seem like a huge loss</p>",
        "id": 278122404,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649313230
    },
    {
        "content": "<p>That is, I don't see any indication that <code>for&lt;T&gt;</code> bounds would be any worse than the status quo with regard to type inference</p>",
        "id": 278122558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649313372
    },
    {
        "content": "<p>I found this paper which is relevant: <a href=\"https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/\">https://www.microsoft.com/en-us/research/publication/practical-type-inference-for-arbitrary-rank-types/</a> . The thrust of it seems to be that although it is difficult to infer the types in absence of annotations, it suffices to propagate type information from the functions to applications, which is essentially what we already do when it comes to higher order closure type inference</p>",
        "id": 278122692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649313503
    },
    {
        "content": "<p>We also have issues like <a href=\"https://github.com/rust-lang/rust/issues/90950\">https://github.com/rust-lang/rust/issues/90950</a> A list: <a href=\"https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+HRTB\">https://github.com/rust-lang/rust/issues?q=is%3Aissue+is%3Aopen+HRTB</a></p>",
        "id": 278122833,
        "sender_full_name": "bjorn3",
        "timestamp": 1649313700
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/144729-wg-traits/topic/how.20hard.20is.20.60impl.20for.3CT.3E.20Fn.28T.29.60/near/278053730\">said</a>:</p>\n<blockquote>\n<p>right but does <code>for&lt;'a&gt; &lt;F as Fn&lt;(&amp;'a str,)&gt;&gt;::Output: Iterator + 'a</code> not accomplish this in a world where <code>Fn*</code> traits arent special and let you actually access the assoc ty</p>\n</blockquote>\n<p>AFAIK you can already emulate this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Helper</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Helper</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">I</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">I</span>: <span class=\"nb\">Iterator</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">I</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Then you can use <code>F: for&lt;'a&gt; Helper&lt;'a&gt;</code>. The downside is that you'll murder type inference because now the bound is not directly on <code>Fn</code> anymore, and rustc will likely infer a non-HRTB closure at call site. See <a href=\"https://github.com/rust-lang/rust/issues/70263\">rust-lang/rust#70263</a></p>",
        "id": 278131734,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1649320059
    },
    {
        "content": "<p>HRTB type hints solves that though.</p>",
        "id": 278158312,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1649335585
    }
]