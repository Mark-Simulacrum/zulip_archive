[
    {
        "content": "<p>So I'm confused as to what Impl Trait will look like in the chalk ast. I was first assuming that we'd have some item <code>type Foo = impl A + B + C;</code>, but now I see some old tests that have goals like <code>impl Clone: Clone</code></p>",
        "id": 186200655,
        "sender_full_name": "detrumi",
        "timestamp": 1579624559
    },
    {
        "content": "<p>So I'm not <em>100%</em> sure all those tests still apply (though I assume they would)</p>",
        "id": 186202142,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579625379
    },
    {
        "content": "<p>But, I also am not super sure either</p>",
        "id": 186202173,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579625401
    },
    {
        "content": "<p>since the new <code>impl Trait</code> does need some def, I would guess the tests need to be rewritten to accomodate that. with the old implementation, one could simply write <code>impl Trait</code> as a type, but presumably now it'll need to be extracted to a definition</p>",
        "id": 186203475,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1579626117
    },
    {
        "content": "<p>I mean, if you can't write <code>impl Trait</code> as a type, then how do you lower <code>fn() -&gt; impl Trait</code>? For <code>type Foo = impl Trait</code>, it makes sense that <code>Foo</code> is an alias to the <code>impl Trait</code> type, to me.</p>",
        "id": 186206525,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579627914
    },
    {
        "content": "<p>types don't have IDs though, right? so I think during lowering, the <code>impl Trait</code> type needs to be assigned an ID (and then lowered to an alias)</p>",
        "id": 186206974,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1579628184
    },
    {
        "content": "<p>and it can't just be the def ID of the <code>type</code> definition, since you can also have things like <code>fn foo(x: Vec&lt;impl Trait&gt;)</code> (IIRC)</p>",
        "id": 186207065,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1579628264
    },
    {
        "content": "<p>Well, you could use placeholders types</p>",
        "id": 186207074,
        "sender_full_name": "detrumi",
        "timestamp": 1579628270
    },
    {
        "content": "<blockquote>\n<p>and it can't just be the def ID of the <code>type</code> definition, since you can also have things like <code>fn foo(x: Vec&lt;impl Trait&gt;)</code> (IIRC)</p>\n</blockquote>\n<p>Ah, good point. I was thinking of just the result type and parameter indices, but you can also nest them, so it's difficult to have them be a DefId and some offset</p>",
        "id": 186207169,
        "sender_full_name": "detrumi",
        "timestamp": 1579628317
    },
    {
        "content": "<p>but I don't know if you need that whole complexity for the test harness, so it might be enough to only allow explicit <code>type Foo = impl Trait</code> definitions</p>",
        "id": 186207246,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1579628373
    },
    {
        "content": "<p>I mean, you can rewrite everything to that form for tests, I think</p>",
        "id": 186207326,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1579628408
    },
    {
        "content": "<p>Right, that's what I have now in my PR</p>",
        "id": 186207347,
        "sender_full_name": "detrumi",
        "timestamp": 1579628419
    },
    {
        "content": "<p>And you could rewrite the goals to use those types, so you wouldn't need any <code>impl ...</code> in the goals</p>",
        "id": 186207365,
        "sender_full_name": "detrumi",
        "timestamp": 1579628442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> Could you explain how the goals in those tests work? I'm not sure what to make of this, for example:</p>\n<div class=\"codehilite\"><pre><span></span>impl Foo&lt;Ref&lt;&#39;static&gt;&gt;: Foo&lt;Ref&lt;&#39;a&gt;&gt;\n</pre></div>",
        "id": 186207491,
        "sender_full_name": "detrumi",
        "timestamp": 1579628536
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> I actually have no idea tbh</p>",
        "id": 186208294,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579629011
    },
    {
        "content": "<p>I never really looked at <code>Opaque</code> types</p>",
        "id": 186208315,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579629026
    },
    {
        "content": "<p>Heh, ok</p>",
        "id": 186208357,
        "sender_full_name": "detrumi",
        "timestamp": 1579629052
    },
    {
        "content": "<p>I can look at it a bit more later today and I'll leave some comments here</p>",
        "id": 186208511,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579629125
    },
    {
        "content": "<p>Appreciated <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 186208587,
        "sender_full_name": "detrumi",
        "timestamp": 1579629170
    },
    {
        "content": "<p>I mean, I think theoretically you could write the tests so that they're <code>type Foo = impl Trait; Foo: Trait</code></p>",
        "id": 186208591,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579629173
    },
    {
        "content": "<p>also, might be worth taking a looking at the rust-analyzer <code>impl Trait</code>-related tests</p>",
        "id": 186208637,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579629206
    },
    {
        "content": "<p>Yeah, and when this PR gets far enough, connecting it with rust-analyzer should be a great way to test it</p>",
        "id": 186208840,
        "sender_full_name": "detrumi",
        "timestamp": 1579629323
    },
    {
        "content": "<p>Alright, got something down for program clauses. Though I'm wondering which rule is better for the auto traits for <code>type Foo = impl A + B</code>:</p>\n<div class=\"codehilite\"><pre><span></span>Implemented(Foo: Send) :- Implemented(A + B: Send) // (1)\nImplemented(Foo: Send) :- Implemented(A: Send), Implemented(B: Send) // (2)\n</pre></div>\n\n\n<p>Or maybe it doesn't really matter <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 186222895,
        "sender_full_name": "detrumi",
        "timestamp": 1579638046
    },
    {
        "content": "<p>So, for <code>dyn Trait</code>, order of <code>A</code> and <code>B</code> would matter (according to Niko). But I'm not sure if order matters for <code>impl Trait</code>. but I'm also not sure if switching the clauses in (2) would change anything in Chalk. (Technically, we are \"allowed\" to select subgoals in any order, though right now they are chosen last first)</p>",
        "id": 186253389,
        "sender_full_name": "Jack Huey",
        "timestamp": 1579665071
    },
    {
        "content": "<p>Good to know that order might matter in some cases. Let's go with (1) for now, it's easily changed anyways</p>",
        "id": 186266369,
        "sender_full_name": "detrumi",
        "timestamp": 1579683303
    },
    {
        "content": "<blockquote>\n<p>So I'm confused as to what Impl Trait will look like in the chalk ast. I was first assuming that we'd have some item <code>type Foo = impl A + B + C;</code>, but now I see some old tests that have goals like <code>impl Clone: Clone</code></p>\n</blockquote>\n<p>btw I don't think these tests really apply</p>",
        "id": 187683684,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112305
    },
    {
        "content": "<p>I think they were thinking about things wrong</p>",
        "id": 187683691,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112311
    },
    {
        "content": "<p>I'm not 100% sure what we want for the chalk AST, but it <em>might</em> be something like</p>",
        "id": 187683756,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112342
    },
    {
        "content": "<p><code>opaque type Foo: Bounds = Ty;</code></p>",
        "id": 187683763,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112350
    },
    {
        "content": "<p>this is obviously not Rust syntax</p>",
        "id": 187683778,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112359
    },
    {
        "content": "<p>Having some consistent starting point would be a great help <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 187683793,
        "sender_full_name": "detrumi",
        "timestamp": 1581112377
    },
    {
        "content": "<p>it depends a bit on what we model <em>in</em> chalk -- I think that to start, I would say that the code which has the job of figuring out the \"hidden type\" is not chalk's job</p>",
        "id": 187683796,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112381
    },
    {
        "content": "<p>we could change that later, but it seems like a good starting point to me</p>",
        "id": 187683809,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112391
    },
    {
        "content": "<p>I guess that won't necessatrily help rust-analyzer, but in a way it won't matter</p>",
        "id": 187683823,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112405
    },
    {
        "content": "<p>maybe we make the \"hidden type\" optional</p>",
        "id": 187683828,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112409
    },
    {
        "content": "<blockquote>\n<p>I guess that won't necessatrily help rust-analyzer, but in a way it won't matter</p>\n</blockquote>\n<p>to clarify here</p>",
        "id": 187683847,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112424
    },
    {
        "content": "<p>the idea is that, if we are \"Reveal\" mode, then the hidden type becomes \"visible\" (i.e., we can normalize that alias to the hidden type)</p>",
        "id": 187683919,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112457
    },
    {
        "content": "<p>but rust-analyzer would never be in that mode</p>",
        "id": 187683921,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112462
    },
    {
        "content": "<p>still, the hidden type is relevant for auto trait \"leakage\"</p>",
        "id": 187683929,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112467
    },
    {
        "content": "<p>which is partly why I say we should just start out by having the AST tell us what it is</p>",
        "id": 187683939,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112479
    },
    {
        "content": "<blockquote>\n<p><code>opaque type Foo: Bounds = Ty;</code></p>\n</blockquote>\n<p>Hmm, is <code>Foo</code> the placeholder, and <code>Ty</code> the 'instance' here?</p>",
        "id": 187684012,
        "sender_full_name": "detrumi",
        "timestamp": 1581112547
    },
    {
        "content": "<p>I'm not sure about the term <em>instance</em></p>",
        "id": 187684137,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112660
    },
    {
        "content": "<p>but if the idea is</p>",
        "id": 187684145,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112669
    },
    {
        "content": "<p>you can define an alias type <code>A</code></p>",
        "id": 187684149,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112674
    },
    {
        "content": "<p>every alias type has a <em>placeholder form</em></p>",
        "id": 187684208,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112690
    },
    {
        "content": "<p>as well as rules for how to <em>normalize</em> it to some other type</p>",
        "id": 187684219,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112697
    },
    {
        "content": "<p>in the placeholder form, you don't know what <code>A</code> represents, but you can still say things about it</p>",
        "id": 187684236,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112714
    },
    {
        "content": "<p>so here, <code>Foo</code> would be the alias</p>",
        "id": 187684246,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112717
    },
    {
        "content": "<p>and there would indeed be a placeholder form of it</p>",
        "id": 187684253,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112724
    },
    {
        "content": "<p>we'd also have rules to normalize <code>Foo</code> to <code>Ty</code> (but they would require <code>Reveal</code> mode)</p>",
        "id": 187684264,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112740
    },
    {
        "content": "<p>and we'd have rules for proving that the placeholder version of <code>Foo</code> is <code>Send</code></p>",
        "id": 187684278,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112754
    },
    {
        "content": "<p>i.e.,</p>",
        "id": 187684280,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112756
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>Implemented(PlaceholderFoo: Send) :- Implemented(Ty: Send)\n</pre></div>",
        "id": 187684288,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581112769
    },
    {
        "content": "<p>is this a good topic to use, <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> ?</p>",
        "id": 189063511,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666419
    },
    {
        "content": "<p>I think the normalization rules for opaque types look like</p>\n<div class=\"codehilite\"><pre><span></span>ProjectionEq(T = Ty) :- Reveal\n</pre></div>\n\n\n<p>and</p>\n<div class=\"codehilite\"><pre><span></span>ProjectionEq(T = !T)\n</pre></div>",
        "id": 189063592,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666467
    },
    {
        "content": "<p>where <code>Reveal</code> is a special goal that we never generate program clauses for, but which can be added to the environment at monomrphization time</p>",
        "id": 189063605,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666483
    },
    {
        "content": "<p>maybe we have it already? I forget</p>",
        "id": 189063609,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666487
    },
    {
        "content": "<p>Huh, interesting. Didn't expect for the reveal concept to show up that literally</p>",
        "id": 189063637,
        "sender_full_name": "detrumi",
        "timestamp": 1582666515
    },
    {
        "content": "<p>we would integrate opaque types into type unification the same way as associated types, I think</p>",
        "id": 189063940,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666700
    },
    {
        "content": "<p>i.e., when you try to unify them, we'll generate a subgoal to solve <code>ProjectionEq</code></p>",
        "id": 189063954,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666711
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189063954\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189063954\">said</a>:</p>\n<blockquote>\n<p>i.e., when you try to unify them, we'll generate a subgoal to solve <code>ProjectionEq</code></p>\n</blockquote>\n<p>And it should be called <code>AliasEq</code> to allow all 3 alias kinds, right?</p>",
        "id": 189064047,
        "sender_full_name": "detrumi",
        "timestamp": 1582666801
    },
    {
        "content": "<p>er, yes</p>",
        "id": 189064102,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666817
    },
    {
        "content": "<p>sorry</p>",
        "id": 189064103,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666818
    },
    {
        "content": "<p>old habits die hard</p>",
        "id": 189064108,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582666822
    },
    {
        "content": "<p>No worries, just wanted to make sure I understood correctly</p>",
        "id": 189065282,
        "sender_full_name": "detrumi",
        "timestamp": 1582667610
    },
    {
        "content": "<p>does that make sense so far, <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> ?</p>",
        "id": 189065548,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582667812
    },
    {
        "content": "<p>Mostly, yes. Will have to read more into monomorphization</p>",
        "id": 189065721,
        "sender_full_name": "detrumi",
        "timestamp": 1582667935
    },
    {
        "content": "<p>note that in rustc the reveal concept is part of the environment too:</p>",
        "id": 189065912,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582668048
    },
    {
        "content": "<ul>\n<li><a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc/traits/enum.Reveal.html\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc/traits/enum.Reveal.html\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc/traits/enum.Reveal.html</a></li>\n<li><a href=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.ParamEnv.html#structfield.reveal\" target=\"_blank\" title=\"https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.ParamEnv.html#structfield.reveal\">https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.ParamEnv.html#structfield.reveal</a></li>\n</ul>",
        "id": 189065923,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582668056
    },
    {
        "content": "<p>Ah, that's very helpful</p>",
        "id": 189065965,
        "sender_full_name": "detrumi",
        "timestamp": 1582668091
    },
    {
        "content": "<p>I'll try to make time to try out this idea before Friday, so that I can ask some questions then</p>",
        "id": 189066172,
        "sender_full_name": "detrumi",
        "timestamp": 1582668274
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> is there a open chalk issue for this?</p>",
        "id": 189133993,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582736688
    },
    {
        "content": "<p>no, right?</p>",
        "id": 189133999,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582736694
    },
    {
        "content": "<p>/me goes to create one</p>",
        "id": 189134021,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582736709
    },
    {
        "content": "<p>should probably bring back the \"current sprint\" label and add it, in addition to the &amp;self to Interner</p>",
        "id": 189134229,
        "sender_full_name": "Jack Huey",
        "timestamp": 1582736853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189133999\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189133999\">said</a>:</p>\n<blockquote>\n<p>no, right?</p>\n</blockquote>\n<p>correct</p>",
        "id": 189134305,
        "sender_full_name": "detrumi",
        "timestamp": 1582736892
    },
    {
        "content": "<p>created <a href=\"https://github.com/rust-lang/chalk/issues/335\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/issues/335\">https://github.com/rust-lang/chalk/issues/335</a></p>",
        "id": 189134411,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582736984
    },
    {
        "content": "<p>we can update the description as we go to make it make sense</p>",
        "id": 189134426,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582736993
    },
    {
        "content": "<p>but we should also be documenting this stuff in the chalk book, I think</p>",
        "id": 189134433,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582737000
    },
    {
        "content": "<p>Yeah, I'll do that in a separate PR at some point</p>",
        "id": 189134680,
        "sender_full_name": "detrumi",
        "timestamp": 1582737116
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I added the <code>Reveal</code> goal. Not sure yet where to add <code>Reveal</code> to the environment, so I'm doing that in <code>to_program_clauses</code> for now. Somehow I got the test working without the <code>AliasEq(T&lt;..&gt; = !T)</code>, so I might be mixing up <code>!T</code> with the unnormalized <code>T</code></p>",
        "id": 189246635,
        "sender_full_name": "detrumi",
        "timestamp": 1582831013
    },
    {
        "content": "<blockquote>\n<p>Not sure yet where to add <code>Reveal</code> to the environment, so I'm doing that in <code>to_program_clauses</code> for now.</p>\n</blockquote>\n<p>AFAIU, that should be up to the caller. Whether <code>Reveal</code> should be in the environment depends on in what phase rustc is calling the solver</p>",
        "id": 189247137,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582831360
    },
    {
        "content": "<p>Right. Should it be an item in the <code>chalk-parse</code> AST then?</p>",
        "id": 189247878,
        "sender_full_name": "detrumi",
        "timestamp": 1582831821
    },
    {
        "content": "<p>can't the tests specify the environment? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 189255894,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582836937
    },
    {
        "content": "<p>Ah, good point</p>",
        "id": 189258458,
        "sender_full_name": "detrumi",
        "timestamp": 1582838406
    },
    {
        "content": "<p>Actually, the environment is just the list of program clauses, so it should be an item after all</p>",
        "id": 189427595,
        "sender_full_name": "detrumi",
        "timestamp": 1583056667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> tests can use the goal <code>if (Reveal) { .. }</code></p>",
        "id": 189506235,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583165529
    },
    {
        "content": "<p>to add <code>Reveal</code> into the environment</p>",
        "id": 189506246,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583165534
    },
    {
        "content": "<p>Ah nice, that did the trick</p>",
        "id": 189520230,
        "sender_full_name": "detrumi",
        "timestamp": 1583173649
    },
    {
        "content": "<p>I'm updating the book and might add some more tests, but the PR should be ready for review now</p>",
        "id": 189524919,
        "sender_full_name": "detrumi",
        "timestamp": 1583176298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> great!</p>",
        "id": 189531707,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583180175
    },
    {
        "content": "<p>so... what I'm imagining for return type impl Trait in RA is roughly:</p>\n<ul>\n<li>we need to give <code>impl Trait</code>s in function return types IDs, which they don't have yet</li>\n<li>if Chalk requires the 'revealed' type, I think we'll need to have a query which computes this for a function, by running type inference for that function and unifying the actual return type with the declared return type. It's a bit weird to have to run inference for a function to get its 'full' type, but it seems it's necessary</li>\n<li>and then I think it's just a matter of creating an impl Trait type with the right ID and revealed type at the call site?</li>\n</ul>",
        "id": 189639871,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583273247
    },
    {
        "content": "<p>Yeah, so you need the whole function body to infer the actual returned type</p>",
        "id": 189640135,
        "sender_full_name": "detrumi",
        "timestamp": 1583273468
    },
    {
        "content": "<p>Giving <code>impl Trait</code> types a type ID makes sense, given that there'll be more places where impl Trait will be allowed in the future, not just in functions</p>",
        "id": 189640226,
        "sender_full_name": "detrumi",
        "timestamp": 1583273549
    },
    {
        "content": "<p>It should be possible to get at least some info without revealing the type, but for the best results you need to reveal by checking the actual return type</p>",
        "id": 189640520,
        "sender_full_name": "detrumi",
        "timestamp": 1583273797
    },
    {
        "content": "<p>if we don't <em>need</em> to pass it, we could try it without first. We don't really deal a lot with auto traits anyway yet</p>",
        "id": 189640675,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583273940
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span>  One important thing that's changing in chalk is that <code>AliasTy</code> became an enum, to account for both projections and impl Trait (and later type aliases as well). In chalk there are both AssocTypeId and ImplTraitId types, but they could aloso be the same, like TypeAliasId is in RA</p>",
        "id": 189679124,
        "sender_full_name": "detrumi",
        "timestamp": 1583318947
    },
    {
        "content": "<p><code>TypeAliasId</code> doesn't include impl trait though, it's just any kind of <code>type X = ...</code></p>",
        "id": 189679164,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583318992
    },
    {
        "content": "<p>but yeah, that shouldn't be a problem</p>",
        "id": 189679174,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583319000
    },
    {
        "content": "<p>My PR also added an <code>auto_traits</code> method to <code>RustIrDatabase</code>, but I'm not entirely sure if that's the right place</p>",
        "id": 189679475,
        "sender_full_name": "detrumi",
        "timestamp": 1583319233
    },
    {
        "content": "<p>that seems fine</p>",
        "id": 189685217,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583324410
    },
    {
        "content": "<p>Created a WIP PR for RA that uses the impl trait branch: <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/3446\" target=\"_blank\" title=\"https://github.com/rust-analyzer/rust-analyzer/pull/3446\">https://github.com/rust-analyzer/rust-analyzer/pull/3446</a></p>",
        "id": 189691020,
        "sender_full_name": "detrumi",
        "timestamp": 1583329443
    },
    {
        "content": "<p>@detrumi I pushed a commit with what I imagine should be the general structure for giving return type impl traits IDs and integrating them with Chalk to your branch, hope you don't mind. This should hopefully make clearer how I think the whole thing should work. If you want to continue this, there are a bunch of todos (otherwise I'll do it once your Chalk PR is merged)</p>",
        "id": 189740799,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583359514
    },
    {
        "content": "<p>also, some things I noticed:</p>\n<ul>\n<li>the 'hidden type' for a return type impl trait can depend on the function's type parameter, so I think <code>ty</code> in <code>ImplTraitDatum</code> needs to have <code>Binders</code>?</li>\n<li>we can have <code>impl Iterator&lt;Item = Something&gt;</code>, so I don't think the <code>bounds</code> can just be <code>TypeBound</code>s?</li>\n</ul>",
        "id": 189742129,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583360526
    },
    {
        "content": "<p>also, if we have to infer a function to get full info about its RPIT, how do we actually deal with mutual recursion? e.g. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c482c0eb69648e53b91ab137af87dcb7\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=c482c0eb69648e53b91ab137af87dcb7\">like this</a>. Maybe I'm misunderstanding how this works after all -- don't we need to infer <code>a</code> to get its revealed return type so we know the auto traits of its RPIT so we can infer <code>b</code> so... ?</p>",
        "id": 189742274,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583360646
    },
    {
        "content": "<p>(<span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> see above)</p>",
        "id": 189742293,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583360667
    },
    {
        "content": "<p>interesting! I was pretty busy today and didn't get a chance to follow up on this</p>",
        "id": 189744154,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583362025
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189740799\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189740799\">said</a>:</p>\n<blockquote>\n<p>@detrumi I pushed a commit with what I imagine should be the general structure for giving return type impl traits IDs and integrating them with Chalk to your branch, hope you don't mind. This should hopefully make clearer how I think the whole thing should work. If you want to continue this, there are a bunch of todos (otherwise I'll do it once your Chalk PR is merged)</p>\n</blockquote>\n<p>Great! Yeah, that was exactly what I intended the PR for, to push the discussion forward. And I think the plan was to have impl trait integration work in RA before merging the chalk PR, but we'll see</p>",
        "id": 189766320,
        "sender_full_name": "detrumi",
        "timestamp": 1583393728
    },
    {
        "content": "<p>For the mutual recursion example, both functions are only ever returning <code>&amp;str</code>, right? The example doesn't work if you actually try to return different types</p>",
        "id": 189766476,
        "sender_full_name": "detrumi",
        "timestamp": 1583394001
    },
    {
        "content": "<blockquote>\n<p>For the mutual recursion example, both functions are only ever returning &amp;str, right? The example doesn't work if you actually try to return different types</p>\n</blockquote>\n<p>Yes, but if the return type influences auto traits, we'll still need the return type of a to type-check b and vice versa</p>",
        "id": 189766616,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583394202
    },
    {
        "content": "<p>ah, when I actually require <code>Send</code> on the types, rustc reports a cycle: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ef998b31e094ba5e1969ecdb4b9ed7c7\" target=\"_blank\" title=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ef998b31e094ba5e1969ecdb4b9ed7c7\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ef998b31e094ba5e1969ecdb4b9ed7c7</a></p>",
        "id": 189766802,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583394430
    },
    {
        "content": "<p>Interesting how the error message exposes the internal workings, like how it talks about <code>a::{{opaque}}#0</code></p>",
        "id": 189766938,
        "sender_full_name": "detrumi",
        "timestamp": 1583394616
    },
    {
        "content": "<p>but I think it means that we need to somehow only require the revealed type if we actually need some auto trait :/</p>",
        "id": 189767285,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583395080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189742129\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/189742129\">said</a>:</p>\n<blockquote>\n<p>also, some things I noticed:</p>\n<ul>\n<li>the 'hidden type' for a return type impl trait can depend on the function's type parameter, so I think <code>ty</code> in <code>ImplTraitDatum</code> needs to have <code>Binders</code>?</li>\n<li>we can have <code>impl Iterator&lt;Item = Something&gt;</code>, so I don't think the <code>bounds</code> can just be <code>TypeBound</code>s?</li>\n</ul>\n</blockquote>\n<p>Good points. I'll have to read up a bit about binders and such, but adding binders should be doable. Not sure what bounds should be other than <code>TraitBound</code>, but I'll try to add some tests for this</p>",
        "id": 189768573,
        "sender_full_name": "detrumi",
        "timestamp": 1583396480
    },
    {
        "content": "<blockquote>\n<p>Not sure what bounds should be other than TraitBound, but I'll try to add some tests for this</p>\n</blockquote>\n<p>why not use the same representation as <code>Ty::Dyn</code>(i.e. <code>QuantifiedWhereClause</code>s)?</p>",
        "id": 189784697,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583410886
    },
    {
        "content": "<p>going to try and catch up on this now :)</p>",
        "id": 189845341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583448222
    },
    {
        "content": "<p>ok I failed :) let me try again</p>",
        "id": 189893382,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583502347
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I think in principle it's not a problem for RA to do type inference on the function to find the hidden type; but we need to make it so that it's only necessary to do that if we actually need the auto traits. Otherwise we can't handle mutually recursive functions returning impl Trait. rustc allows that, it only reports a cycle if you actually require an auto trait in those mutually recursive functions</p>",
        "id": 190228585,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583876320
    },
    {
        "content": "<p><code>ImplTraitDatum</code> now uses <code>Vec&lt;QuantifiedWhereClause&lt;I&gt;&gt;</code> for the bounds, and binders around the type</p>",
        "id": 190284020,
        "sender_full_name": "detrumi",
        "timestamp": 1583935350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Could you make some time to review this?</p>",
        "id": 190284350,
        "sender_full_name": "detrumi",
        "timestamp": 1583935552
    },
    {
        "content": "<p>So, quickly glanced at the tests</p>",
        "id": 190285594,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936179
    },
    {
        "content": "<p>I'm a bit confused</p>",
        "id": 190285608,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936184
    },
    {
        "content": "<p>specifically, the test with params</p>",
        "id": 190285653,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936207
    },
    {
        "content": "<p>If the type is <code>T&lt;U&gt;</code>, then how can you have a goal <code>T: Trait</code>?</p>",
        "id": 190285695,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936230
    },
    {
        "content": "<p>Yeah, I don't think what I did there was correct</p>",
        "id": 190285739,
        "sender_full_name": "detrumi",
        "timestamp": 1583936257
    },
    {
        "content": "<p>do we not need a <code>exists&lt;U&gt; { T&lt;U&gt;: Trait }</code> or <code>forall&lt;U&gt; { T&lt;U&gt;: Trait }</code></p>",
        "id": 190285752,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936263
    },
    {
        "content": "<p>I haven't really looked at the rest. But if that lowers/passes without a substitution, is something wrong?</p>",
        "id": 190285875,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936326
    },
    {
        "content": "<p>I might just be wrong and you <em>can</em> have a goal <code>T: Trait</code> where <code>T</code> has params (but I'm not sure what it would be lowered into)</p>",
        "id": 190286129,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936473
    },
    {
        "content": "<p>If I wrap it in a exists in the goal (or try <code>T&lt;U&gt;: Trait</code> without the exists even), it gives back a <code>CannotApplyTypeParameter</code> error</p>",
        "id": 190286177,
        "sender_full_name": "detrumi",
        "timestamp": 1583936500
    },
    {
        "content": "<p>But yeah, it looks wrong</p>",
        "id": 190286238,
        "sender_full_name": "detrumi",
        "timestamp": 1583936523
    },
    {
        "content": "<p>I'm not familiar at all with the lowering code, so I can't really say what's going on</p>",
        "id": 190286504,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936697
    },
    {
        "content": "<p>Is it \"cannot apply type parameter <code>U</code>\"?</p>",
        "id": 190286552,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936742
    },
    {
        "content": "<p>The lowering tries to get a <code>StructId</code> <a href=\"https://github.com/rust-lang/chalk/blob/43fcfef6b2a78bab7e68ad6041f990ba0d3258f4/chalk-integration/src/lowering.rs#L1086\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/blob/43fcfef6b2a78bab7e68ad6041f990ba0d3258f4/chalk-integration/src/lowering.rs#L1086\">here</a></p>",
        "id": 190286837,
        "sender_full_name": "detrumi",
        "timestamp": 1583936882
    },
    {
        "content": "<p>oh, you know, I bet this goes back to the discussion we had about knowing the <code>Self</code> type</p>",
        "id": 190287007,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583936996
    },
    {
        "content": "<p>Probably right now, you can't use params in the type itself</p>",
        "id": 190287086,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583937025
    },
    {
        "content": "<p>Hmm, let me just remove that test then. For reference, this somehow passes at the moment:</p>\n<div class=\"codehilite\"><pre><span></span>program {\n    trait Trait { }\n    struct Ty&lt;U&gt; { }\n    struct Unit { }\n    impl Trait for Ty&lt;Unit&gt; { }\n\n    opaque type T&lt;U&gt;: Trait = Ty&lt;U&gt;;\n}\n\ngoal {\n    if (Reveal) {\n        T: Trait\n    }\n} yields {\n    &quot;Unique; substitution []&quot;\n}\n</pre></div>",
        "id": 190287275,
        "sender_full_name": "detrumi",
        "timestamp": 1583937140
    },
    {
        "content": "<p>I feel like for the <code>opaque_bounds_with_params</code> test, we <em>should</em> be able to say <code>forall&lt;U&gt; { T&lt;U&gt;: Trait }</code> in both <code>Reveal</code> and <code>!Reveal</code></p>",
        "id": 190287355,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583937184
    },
    {
        "content": "<p>But, say, if <code>impl Foo for Ty&lt;Bar&gt;</code>, then we should be able to say <code>if (Reveal) { T&lt;Bar&gt;: Foo }</code></p>",
        "id": 190287525,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583937266
    },
    {
        "content": "<p>But I'm not sure about that</p>",
        "id": 190287539,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583937271
    },
    {
        "content": "<p>The problem, with the first goal there, is that I think right now we can't have an <em>unknown</em> <code>Self</code> type (or I guess, a <em>known</em> <code>Self</code> with an unknown <code>Substitution</code>?)</p>",
        "id": 190287757,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583937370
    },
    {
        "content": "<p>Wait that's not right</p>",
        "id": 190287837,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583937426
    },
    {
        "content": "<p>of course we should be about to have bound vars as a param on a type</p>",
        "id": 190287857,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583937444
    },
    {
        "content": "<p>Not sure what you mean with that last sentence, but I don't think <code>forall&lt;U&gt; { T&lt;U&gt;: Trait }</code> really works, as it only holds for <code>T&lt;Unit&gt;</code> in the test. So that should be a <code>exists&lt;U&gt;</code> instead</p>",
        "id": 190288968,
        "sender_full_name": "detrumi",
        "timestamp": 1583937960
    },
    {
        "content": "<p>hmm I think that's kind of a well-formedness thing? like if you have a function returning <code>impl Trait</code>, you can't have your return value only implement the trait in some cases. the hidden type needs to implement the type in all cases, and the <code>T&lt;U&gt;</code> should by definition implement it for all <code>U</code></p>",
        "id": 190289325,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583938121
    },
    {
        "content": "<p>keep in mind that the parameters for the opaque type are the type parameters of the function in practice</p>",
        "id": 190289383,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583938160
    },
    {
        "content": "<p>it's mostly for unification purposes; the types of two calls to an RPIT function are observably the same exactly if the type parameters to the function are the same (or unify) in both cases</p>",
        "id": 190289504,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583938216
    },
    {
        "content": "<p>and so whether the hidden type implements the trait (for all type parameters) is checked at the definition site of the impl trait (i.e. the function definition), and callers can just assume it</p>",
        "id": 190289592,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583938274
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190289325\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190289325\">said</a>:</p>\n<blockquote>\n<p>hmm I think that's kind of a well-formedness thing? like if you have a function returning <code>impl Trait</code>, you can't have your return value only implement the trait in some cases. the hidden type needs to implement the type in all cases, and the <code>T&lt;U&gt;</code> should by definition implement it for all <code>U</code></p>\n</blockquote>\n<p>Right this</p>",
        "id": 190290179,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583938557
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> Slightly unrelated, but it looks like the chalk integration in RA will need some updates, now that <code>cast()</code> takes an interner as argument</p>",
        "id": 190293707,
        "sender_full_name": "detrumi",
        "timestamp": 1583940199
    },
    {
        "content": "<p>yes, I was kind of waiting for all these changes to be done</p>",
        "id": 190293843,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583940255
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> left an initial round of review comments -- it looks close! Some things I think are not quite right around how the bounders are setup. I'd be game to try and talk about it in more depth, perhaps on Friday (or maybe tomorrow, but THu tends to be quite a full day for me)</p>",
        "id": 190336235,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583963720
    },
    {
        "content": "<p>Thanks! Let's discuss this on Friday then</p>",
        "id": 190360059,
        "sender_full_name": "detrumi",
        "timestamp": 1583994764
    },
    {
        "content": "<p>OK <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> well I've been kind of knocked back by COVID-19 and the rest here, and this Friday I'll be off, but what about planning some time to talk about this on Wednesday (tomorrow) -- would 10am US Eastern time maybe be a good fit for you?</p>",
        "id": 190903151,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584475202
    },
    {
        "content": "<p>Yes, that works for me</p>",
        "id": 190903809,
        "sender_full_name": "detrumi",
        "timestamp": 1584475532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> I'm around now btw</p>",
        "id": 190980695,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584538817
    },
    {
        "content": "<p>Great, so am I</p>",
        "id": 190981014,
        "sender_full_name": "detrumi",
        "timestamp": 1584538973
    },
    {
        "content": "<p>I guess I should review what I wrote</p>",
        "id": 190981152,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539039
    },
    {
        "content": "<p>Let's start with naming: opaque type vs impl trait</p>",
        "id": 190981332,
        "sender_full_name": "detrumi",
        "timestamp": 1584539114
    },
    {
        "content": "<p>I called it opaque type around the ast, and impl trait once lowered</p>",
        "id": 190981373,
        "sender_full_name": "detrumi",
        "timestamp": 1584539137
    },
    {
        "content": "<p>I see</p>",
        "id": 190981475,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539171
    },
    {
        "content": "<p>I might've got the other way</p>",
        "id": 190981503,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539188
    },
    {
        "content": "<p>interestingly, that's exactly the other way around in RA <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 190981516,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584539197
    },
    {
        "content": "<p>in the sense that <code>impl Trait</code> is the \"concrete syntax\" people use, but the \"opaque type\" is more the underlying concept</p>",
        "id": 190981536,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539208
    },
    {
        "content": "<p>though now that we adopted the <code>type Foo = impl Trait</code> syntax for declaring an opaque type,</p>",
        "id": 190981559,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539222
    },
    {
        "content": "<p>I feel like we could just say impl Trait everywhere (also in rustc),</p>",
        "id": 190981578,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539231
    },
    {
        "content": "<p>although there is some potential confusion because <code>impl Trait</code> can <em>also</em> be used for other things of course</p>",
        "id": 190981593,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539240
    },
    {
        "content": "<p>e.g., <code>fn foo(x: impl Trait)</code>, which is something else</p>",
        "id": 190981607,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539251
    },
    {
        "content": "<p>The ast syntax is still <code>opaque type T: Trait = Ty;</code> in my PR</p>",
        "id": 190981633,
        "sender_full_name": "detrumi",
        "timestamp": 1584539265
    },
    {
        "content": "<p>and I think indeed that within rustc we use <code>impl Trait</code> for the \"ast type\", but when we find it in the \"existential\" position, we create an \"opaque type\"</p>",
        "id": 190981640,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539269
    },
    {
        "content": "<p>hence the confusion, I think</p>",
        "id": 190981641,
        "sender_full_name": "detrumi",
        "timestamp": 1584539269
    },
    {
        "content": "<p>yeah, chalk is a bit different because</p>",
        "id": 190981653,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539276
    },
    {
        "content": "<p>it doesn't really take in true rust syntax</p>",
        "id": 190981687,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539283
    },
    {
        "content": "<p>I say just use opaque type uniformly for now</p>",
        "id": 190981739,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539297
    },
    {
        "content": "<p>which seems consistent with rustc + r-a (if I understood <span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> correctly)</p>",
        "id": 190981814,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539329
    },
    {
        "content": "<p>So you mean renaming things like ImplTraitDatum to OpaqueTyDatum as well, right?</p>",
        "id": 190981937,
        "sender_full_name": "detrumi",
        "timestamp": 1584539379
    },
    {
        "content": "<p>I also feel that \"opaque type\" just works better in written text than \"impl trait\", I always wonder whether I should write impl Trait or <code>impl Trait</code> or impl Trait type... <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 190981972,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584539399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125131\">detrumi</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190981937\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190981937\">said</a>:</p>\n<blockquote>\n<p>So you mean renaming things like ImplTraitDatum to OpaqueTyDatum as well, right?</p>\n</blockquote>\n<p>right</p>",
        "id": 190982121,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539459
    },
    {
        "content": "<p>Yeah, I think it's useful to have a name for the \"existential impl trait\" concept anyway, even if it's not something that appears in rust's concrete syntax, and opaque type is I guess a decent enough name for that</p>",
        "id": 190982208,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539501
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> ok so apart from the name</p>",
        "id": 190982595,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539670
    },
    {
        "content": "<p>I think there were two other things</p>",
        "id": 190982623,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539686
    },
    {
        "content": "<p>well maybe more than two but at least two :)</p>",
        "id": 190982657,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539702
    },
    {
        "content": "<ul>\n<li>making the hidden type a distinct callback, used \"on demand\"</li>\n</ul>",
        "id": 190982670,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539712
    },
    {
        "content": "<ul>\n<li>getting the binders correct</li>\n</ul>",
        "id": 190982706,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539726
    },
    {
        "content": "<p>of the two, I'm more worried about the 2nd one</p>",
        "id": 190982715,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539731
    },
    {
        "content": "<p>I could see doing the 1st one in a follow-up PR</p>",
        "id": 190982722,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539735
    },
    {
        "content": "<p>Alright, let's focus on the 2nd then</p>",
        "id": 190982767,
        "sender_full_name": "detrumi",
        "timestamp": 1584539761
    },
    {
        "content": "<p>I'm referring to <a href=\"https://github.com/rust-lang/chalk/pull/324/files/32223e4b13463070edd5f89b2145c5934228e314#r391285010\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/pull/324/files/32223e4b13463070edd5f89b2145c5934228e314#r391285010\">this comment</a></p>",
        "id": 190982883,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539810
    },
    {
        "content": "<p>but now I'm reading a bit more to make sure what i'm saying makes sense ..</p>",
        "id": 190983027,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539880
    },
    {
        "content": "<p>ok, so, a <code>QuantifiedWhereClause</code> -- that represents a where clause like <code>where T: Foo</code> or (this is the quantified bit) <code>where for&lt;'a&gt; T: Foo&lt;'a&gt;</code></p>",
        "id": 190983101,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539903
    },
    {
        "content": "<p>actually though an opaque type has a bit more stuff going on I realize</p>",
        "id": 190983159,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539926
    },
    {
        "content": "<p>well, first off, there are really both \"where clauses\" <em>and</em> \"bounds\", just like with an associated type</p>",
        "id": 190983261,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584539990
    },
    {
        "content": "<p>Ah I see, you suggested to put the hidden type inside the binders</p>",
        "id": 190983272,
        "sender_full_name": "detrumi",
        "timestamp": 1584539995
    },
    {
        "content": "<p>where the \"Bounds\" are the things that \"other code\" gets to assume are true about the hidden type</p>",
        "id": 190983358,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540013
    },
    {
        "content": "<p>Yeah, it's quite confusing having both of those at play</p>",
        "id": 190983374,
        "sender_full_name": "detrumi",
        "timestamp": 1584540018
    },
    {
        "content": "<p>and the \"where clauses\" are things that the \"other code\" must prove</p>",
        "id": 190983380,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540024
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">type</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">Hash</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n</pre></div>",
        "id": 190983421,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540050
    },
    {
        "content": "<p>now, in the WF checking etc, we get to <em>assume</em> <code>T: Hash</code> but we must prove <code>$HIDDEN: Debug</code></p>",
        "id": 190983461,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540074
    },
    {
        "content": "<p>but in the \"outside\", to write <code>Foo&lt;X&gt;</code> we must <em>prove</em> <code>X: Hash</code> but we get to assume <code>!Foo&lt;X&gt;: Debug</code></p>",
        "id": 190983510,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125131\">detrumi</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190983272\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190983272\">said</a>:</p>\n<blockquote>\n<p>Ah I see, you suggested to put the hidden type inside the binders</p>\n</blockquote>\n<p>and yeah I was suggesting that we should express the \"bounds\" in terms of a bound variable, so that we can substitute different things depending on the context</p>",
        "id": 190983600,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190983380\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190983380\">said</a>:</p>\n<blockquote>\n<p>and the \"where clauses\" are things that the \"other code\" must prove</p>\n</blockquote>\n<p>honestly, we could leave this for a follow-up PR too</p>",
        "id": 190983647,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540149
    },
    {
        "content": "<p>I would just ignore the \"where clauses\" part of it for the purposes of this PR, it just means that WF checking etc won't work in full generality</p>",
        "id": 190983682,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540167
    },
    {
        "content": "<p>we should however start making a kind of check-list of details to get back to</p>",
        "id": 190983695,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540175
    },
    {
        "content": "<p>Getting this PR merged would be nice, I'm going to have to rebase for the 5th time <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span></p>",
        "id": 190983862,
        "sender_full_name": "detrumi",
        "timestamp": 1584540246
    },
    {
        "content": "<p>yeah</p>",
        "id": 190984039,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540330
    },
    {
        "content": "<p>I'm <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> on smaller PRs and checklists :)</p>",
        "id": 190984051,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540337
    },
    {
        "content": "<p>so you understand what I meant about using a bound variable for the hidden type, though?</p>",
        "id": 190984159,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540368
    },
    {
        "content": "<p>I'm going to start editing <a href=\"https://github.com/rust-lang/chalk/issues/335\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/issues/335\">https://github.com/rust-lang/chalk/issues/335</a> with follow-up items</p>",
        "id": 190984195,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540389
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190984159\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190984159\">said</a>:</p>\n<blockquote>\n<p>so you understand what I meant about using a bound variable for the hidden type, though?</p>\n</blockquote>\n<p>Do you mean that we should be introducing a new variable when lowering an opaque type?</p>",
        "id": 190984394,
        "sender_full_name": "detrumi",
        "timestamp": 1584540485
    },
    {
        "content": "<p>Yes</p>",
        "id": 190984483,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540526
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/chalk/issues/335#issuecomment-600645520\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/issues/335#issuecomment-600645520\">initial checklist</a> off the top of my head</p>",
        "id": 190984868,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540705
    },
    {
        "content": "<p>I'm not sure what the lowered result would look like</p>",
        "id": 190985035,
        "sender_full_name": "detrumi",
        "timestamp": 1584540775
    },
    {
        "content": "<p>let me see if I can find a decent example</p>",
        "id": 190985071,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584540792
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> so I think the closest example is <a href=\"https://github.com/rust-lang/chalk/blob/75718ac8578b884912facc192c14ccafcda6c6b5/chalk-integration/src/lowering.rs#L989-L1007\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/blob/75718ac8578b884912facc192c14ccafcda6c6b5/chalk-integration/src/lowering.rs#L989-L1007\">the code for dyn Trait types</a></p>",
        "id": 190985885,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541141
    },
    {
        "content": "<p>here we are using a bound variable with the name <code>FIXME_SELF</code> that represents the \"existential type\" -- it's the same basic concept, except we never learn what the hidden type is :)</p>",
        "id": 190985926,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541163
    },
    {
        "content": "<p>I did try something along those lines <a href=\"https://github.com/rust-lang/chalk/pull/324/files#diff-563a3df57abd0881a3def13e3bc472c6R384\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/pull/324/files#diff-563a3df57abd0881a3def13e3bc472c6R384\">here</a></p>",
        "id": 190986172,
        "sender_full_name": "detrumi",
        "timestamp": 1584541273
    },
    {
        "content": "<p>yeah but</p>",
        "id": 190986349,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541337
    },
    {
        "content": "<p>what that does is</p>",
        "id": 190986370,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541346
    },
    {
        "content": "<p>if you have generics like <code>type Foo&lt;T&gt;</code>, that brings <code>T</code> into scope --</p>",
        "id": 190986384,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541353
    },
    {
        "content": "<p>it also only brings <code>T</code> into scope during the closure</p>",
        "id": 190986398,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541362
    },
    {
        "content": "<p>so when lowering the \"opaque type\"</p>",
        "id": 190986405,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541366
    },
    {
        "content": "<p>Ah</p>",
        "id": 190986625,
        "sender_full_name": "detrumi",
        "timestamp": 1584541465
    },
    {
        "content": "<p>I see, that was forced by how the types were structured</p>",
        "id": 190986700,
        "sender_full_name": "detrumi",
        "timestamp": 1584541509
    },
    {
        "content": "<p>So by moving the hidden type inside the binders, we can also lower that inside the closure</p>",
        "id": 190986865,
        "sender_full_name": "detrumi",
        "timestamp": 1584541567
    },
    {
        "content": "<p>This is starting to make sense now, the way it needed multiple <code>empty_env</code> instances was weird anyways</p>",
        "id": 190987024,
        "sender_full_name": "detrumi",
        "timestamp": 1584541646
    },
    {
        "content": "<p>right but also</p>",
        "id": 190987062,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541661
    },
    {
        "content": "<p>well so we also want to lower whatever other things have those generics in scope w/in that same closure</p>",
        "id": 190987095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541680
    },
    {
        "content": "<p>notably the bounds</p>",
        "id": 190987110,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541682
    },
    {
        "content": "<p>except if we want the bounds to <em>also</em> have the \"hidden type\" in scope</p>",
        "id": 190987178,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541696
    },
    {
        "content": "<p>I'm not following</p>",
        "id": 190987395,
        "sender_full_name": "detrumi",
        "timestamp": 1584541778
    },
    {
        "content": "<p>What do you mean with that last  sentence?</p>",
        "id": 190987599,
        "sender_full_name": "detrumi",
        "timestamp": 1584541830
    },
    {
        "content": "<p>sorry I got distracted before I finished</p>",
        "id": 190987697,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541874
    },
    {
        "content": "<p>what I meant was</p>",
        "id": 190987702,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541876
    },
    {
        "content": "<p>Ah, so you mean that the bounds should be able to reference the hidden type</p>",
        "id": 190987707,
        "sender_full_name": "detrumi",
        "timestamp": 1584541877
    },
    {
        "content": "<p>right, so you probably want something like</p>",
        "id": 190987748,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541891
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"n\">empty_env</span><span class=\"p\">.</span><span class=\"n\">in_binders</span><span class=\"p\">(</span><span class=\"n\">parameter_kinds</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">env</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// bring the type parameters into scope</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">hidden_ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* lower hidden ty, as today */</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">hidden_ty_bounds</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">in_binders</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">chalk_ir</span>::<span class=\"n\">ParameterKind</span>::<span class=\"n\">Ty</span><span class=\"p\">(</span><span class=\"n\">intern</span><span class=\"p\">(</span><span class=\"n\">FIXME_SELF</span><span class=\"p\">))),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">|</span><span class=\"n\">env1</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// bring hidden type into scope</span>\n<span class=\"w\">           </span><span class=\"cm\">/* lower bounds, using `into_where_clauses` to supply the `Self` type as the innermos bound variable */</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">ImplTraitDatumBound</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">hidden_ty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">hidden_ty_bounds</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">})</span><span class=\"w\"></span>\n</pre></div>",
        "id": 190987969,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584541981
    },
    {
        "content": "<p>Why the FIXME_SELF?</p>",
        "id": 190988245,
        "sender_full_name": "detrumi",
        "timestamp": 1584542085
    },
    {
        "content": "<p>like, why introduce another parameter there, or why use this <code>FIXME_SELF</code> constant?</p>",
        "id": 190988428,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542151
    },
    {
        "content": "<p>that's the name of the parameter</p>",
        "id": 190988433,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542154
    },
    {
        "content": "<p>but it represents the \"hidden Self type\"</p>",
        "id": 190988465,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542162
    },
    {
        "content": "<p>i.e., if the bounds are <code>impl Foo</code>, then you have <code>$H: Foo</code>, so the hidden type <code>$H</code> is the \"Self\" parameter of the where clause</p>",
        "id": 190988547,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542182
    },
    {
        "content": "<p>In my mind we had the placeholders for that already</p>",
        "id": 190988598,
        "sender_full_name": "detrumi",
        "timestamp": 1584542209
    },
    {
        "content": "<p>Maybe I'm mixing things up though</p>",
        "id": 190988616,
        "sender_full_name": "detrumi",
        "timestamp": 1584542216
    },
    {
        "content": "<p>well</p>",
        "id": 190988750,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542280
    },
    {
        "content": "<p>not sure which placeholder you mean</p>",
        "id": 190988920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542337
    },
    {
        "content": "<p>do you mean in the first call to <code>in_binders</code>?</p>",
        "id": 190988939,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542344
    },
    {
        "content": "<p>I meant the ImplTraitId placeholders (<code>!T</code>)</p>",
        "id": 190989238,
        "sender_full_name": "detrumi",
        "timestamp": 1584542460
    },
    {
        "content": "<p>Ah so</p>",
        "id": 190989274,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542483
    },
    {
        "content": "<p>Those represent something different</p>",
        "id": 190989292,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542490
    },
    {
        "content": "<p>the main difference is</p>",
        "id": 190989577,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542583
    },
    {
        "content": "<p>at least in the code the way it is now</p>",
        "id": 190989604,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542592
    },
    {
        "content": "<p>you can't \"substitute\" for a placeholder (i.e., replace it with something else)</p>",
        "id": 190989630,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542601
    },
    {
        "content": "<p>You mean that you can't substitute the placeholder in <code>in_binders</code>, right?</p>",
        "id": 190989826,
        "sender_full_name": "detrumi",
        "timestamp": 1584542675
    },
    {
        "content": "<p>Because <code>ImplTraitTy</code> does have a substitution field</p>",
        "id": 190989860,
        "sender_full_name": "detrumi",
        "timestamp": 1584542689
    },
    {
        "content": "<p>in other words, by adding a binder, we've kind of made the \"bounds\" be something we can apply to <em>either</em> the hidden type (when it is known) <em>or</em> to the placeholder or other things</p>",
        "id": 190989867,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542692
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125131\">detrumi</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190989826\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190989826\">said</a>:</p>\n<blockquote>\n<p>You mean that you can't substitute the placeholder in <code>in_binders</code>, right?</p>\n</blockquote>\n<p>no</p>",
        "id": 190989899,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542707
    },
    {
        "content": "<p>so, <code>in_binders</code> creates a <code>Binders&lt;T&gt;</code> value which introduces various bound variables</p>",
        "id": 190989935,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542723
    },
    {
        "content": "<p>that may be referenced within the <code>T</code> term that is contained within</p>",
        "id": 190989956,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542733
    },
    {
        "content": "<p>but then <em>other code</em> can substitute values for those bound variables</p>",
        "id": 190989975,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542740
    },
    {
        "content": "<p>that is, <code>in_binders</code> doesn't itself do any substitution</p>",
        "id": 190990024,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542760
    },
    {
        "content": "<p>Ah, so you meant the opposite, in that we don't need the substitution here</p>",
        "id": 190990123,
        "sender_full_name": "detrumi",
        "timestamp": 1584542794
    },
    {
        "content": "<p>yeah but also</p>",
        "id": 190990167,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542814
    },
    {
        "content": "<p>the code the way it is written</p>",
        "id": 190990173,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542818
    },
    {
        "content": "<p>does</p>",
        "id": 190990179,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542822
    },
    {
        "content": "<p><code>qil.into_where_clauses(chalk_ir::TyData::BoundVar(0))</code> --</p>",
        "id": 190990209,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542836
    },
    {
        "content": "<p>i.e., it is saying</p>",
        "id": 190990216,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542839
    },
    {
        "content": "<p>convert the bounds like <code>Debug</code> into a where clause like <code>^0: Debug</code></p>",
        "id": 190990239,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542850
    },
    {
        "content": "<p>i.e., with the self type being the innermost bound variable</p>",
        "id": 190990261,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542858
    },
    {
        "content": "<p>that is actually correct <em>except</em></p>",
        "id": 190990271,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542862
    },
    {
        "content": "<p>we are doing that in the <code>empty_env</code></p>",
        "id": 190990291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542867
    },
    {
        "content": "<p>i.e., there are no bound variables \"in scope\"</p>",
        "id": 190990298,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542872
    },
    {
        "content": "<p>and we don't store the resulting <code>QuantifiedWhereClause</code> values in a <code>Binders&lt;QuantifiedWhereClause&gt;</code></p>",
        "id": 190990388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542893
    },
    {
        "content": "<p>Right, yeah I see</p>",
        "id": 190990404,
        "sender_full_name": "detrumi",
        "timestamp": 1584542903
    },
    {
        "content": "<p>so the <code>BoundVar</code> is kind of referencing \"something\"</p>",
        "id": 190990408,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584542905
    },
    {
        "content": "<p>Alright. Looking at the other feedback, there's one place I was using the alias type itself instead of the placeholder, that makes sense. Hopefully fixing these also makes the tests behave more like they should</p>",
        "id": 190990996,
        "sender_full_name": "detrumi",
        "timestamp": 1584543134
    },
    {
        "content": "<p>yep</p>",
        "id": 190991030,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584543149
    },
    {
        "content": "<p>I would expect so but maybe not :)</p>",
        "id": 190991060,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584543161
    },
    {
        "content": "<p>let me know if you get stuck or have updated it and I can take another look</p>",
        "id": 190991080,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584543169
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 190991103,
        "sender_full_name": "detrumi",
        "timestamp": 1584543180
    },
    {
        "content": "<p>You also mentioned the match in aggregate_tys that probably wasn't live, should we replace that with <code>unreachable!()</code> then to make sure?</p>",
        "id": 190991466,
        "sender_full_name": "detrumi",
        "timestamp": 1584543325
    },
    {
        "content": "<p>I also noticed that some of them might not get reached, because we don't use alias types in answers (/goals?)</p>",
        "id": 190991730,
        "sender_full_name": "detrumi",
        "timestamp": 1584543422
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I've resolved your comments, and updated the test. It's failing now because it's not finding a solution for <code>T: Trait</code> for a <code>opaque type T: Trait = Ty;</code>, which it should</p>",
        "id": 192667016,
        "sender_full_name": "detrumi",
        "timestamp": 1585835176
    },
    {
        "content": "<p>Hopefully it's just wrong clauses being generated in <code>to_program_clauses</code>, otherwise I'd like to land the PR and iterate in smaller PRs</p>",
        "id": 192668172,
        "sender_full_name": "detrumi",
        "timestamp": 1585835721
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> great! I'll take a look</p>",
        "id": 192836780,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585934275
    },
    {
        "content": "<p>Ah, turns out I was creating <code>Implemented(HiddenTy: Bound)</code> clauses directly, instead of <code>(Implemented(!T: Bound)</code></p>",
        "id": 192946504,
        "sender_full_name": "detrumi",
        "timestamp": 1586072161
    },
    {
        "content": "<p>Hmm, so maybe the lowering should use <code>TypeName::OpaqueType</code> for the <code>self_ty</code> in <code>into_where_clauses</code>?</p>",
        "id": 192946687,
        "sender_full_name": "detrumi",
        "timestamp": 1586072424
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190987969\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/190987969\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">empty_env</span><span class=\"p\">.</span><span class=\"n\">in_binders</span><span class=\"p\">(</span><span class=\"n\">parameter_kinds</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">env</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// bring the type parameters into scope</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">hidden_ty</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"cm\">/* lower hidden ty, as today */</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">hidden_ty_bounds</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">env</span><span class=\"p\">.</span><span class=\"n\">in_binders</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">chalk_ir</span>::<span class=\"n\">ParameterKind</span>::<span class=\"n\">Ty</span><span class=\"p\">(</span><span class=\"n\">intern</span><span class=\"p\">(</span><span class=\"n\">FIXME_SELF</span><span class=\"p\">))),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">|</span><span class=\"n\">env1</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"c1\">// bring hidden type into scope</span>\n<span class=\"w\">           </span><span class=\"cm\">/* lower bounds, using `into_where_clauses` to supply the `Self` type as the innermos bound variable */</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"n\">ImplTraitDatumBound</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">hidden_ty</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">hidden_ty_bounds</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">})</span><span class=\"w\"></span>\n</pre></div>\n\n\n</blockquote>\n<p>Returning to this suggestion, I don't have this quite right yet. <code>hidden_ty_bounds</code> in the example above would be a <code>Binders&lt;Vec&lt;Binders&lt;_&gt;&gt;&gt;</code> (the inner binders coming from lowering the bounds, and the outer binders from the second <code>in_binders</code>). The DatumBound.hidden_ty_bounds field doesn't expect binders, so I don't see a way to do this using <code>in_binders</code></p>",
        "id": 192963906,
        "sender_full_name": "detrumi",
        "timestamp": 1586099687
    },
    {
        "content": "<p>More specifically, I currently have this, but the <code>bounds: bounds.value</code> part just seems wrong:</p>\n<div class=\"codehilite\"><pre><span></span>let binders = empty_env.in_binders(parameter_kinds, |env| {\n    let hidden_ty = opaque_ty.ty.lower(&amp;env)?;\n\n    let bounds: chalk_ir::Binders&lt;Vec&lt;chalk_ir::Binders&lt;_&gt;&gt;&gt; = env\n        .in_binders(\n            Some(chalk_ir::ParameterKind::Ty(intern(FIXME_SELF))),\n            |env1| {\n                let interner = env1.interner();\n                Ok(opaque_ty\n                    .bounds\n                    .lower(&amp;env1)?\n                    .iter()\n                    .flat_map(|qil| {\n                        qil.into_where_clauses(\n                            interner,\n                            chalk_ir::TyData::BoundVar(BoundVar::new(\n                                DebruijnIndex::INNERMOST,\n                                0,\n                            ))\n                            .intern(interner),\n                        )\n                    })\n                    .collect())\n            },\n        )?;\n\n    Ok(OpaqueTyDatumBound {\n        hidden_ty,\n        bounds: bounds.value,\n    })\n})?;\n</pre></div>",
        "id": 192966377,
        "sender_full_name": "detrumi",
        "timestamp": 1586103419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/192836780\" title=\"#narrow/stream/144729-wg-traits/topic/impl.20trait/near/192836780\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125131\">detrumi</span> great! I'll take a look</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Ping! Do you have a suggestion for how to avoid the <code>Binders&lt;Vec&lt;Binders&lt;_&gt;&gt;&gt;</code> problem I described above?</p>",
        "id": 193067163,
        "sender_full_name": "detrumi",
        "timestamp": 1586190701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> sorry, didn't have time to take a look, but I can look now</p>",
        "id": 193088660,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586200872
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> I think I imagined you would change <code>OpaqueTyBound</code> to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">OpaqueTyBound</span><span class=\"o\">&lt;</span><span class=\"n\">I</span>: <span class=\"nc\">Interner</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// The value for the &quot;hidden type&quot; for `opaque type Foo = ...`</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">hidden_ty</span>: <span class=\"nc\">Ty</span><span class=\"o\">&lt;</span><span class=\"n\">I</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// Trait bounds for the opaque type.</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">bounds</span>: <span class=\"nc\">Binder</span><span class=\"o\">&lt;</span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">QuantifiedWhereClause</span><span class=\"o\">&lt;</span><span class=\"n\">I</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\">   </span><span class=\"c1\">// &lt;-- i.e., add a binder here!</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 193089009,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586201060
    },
    {
        "content": "<p>this will require you to instantiate that binder at various points</p>",
        "id": 193089054,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586201086
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Hmm, does that replace the binders on <code>OpaqueTyDatum.bound</code>, or is this an extra level of binders?</p>",
        "id": 193095170,
        "sender_full_name": "detrumi",
        "timestamp": 1586204077
    },
    {
        "content": "<p>extra level</p>",
        "id": 193095186,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204086
    },
    {
        "content": "<p>for the same reason that we have two calls to <code>in_binders</code>, basically</p>",
        "id": 193095200,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204095
    },
    {
        "content": "<p>Ah. I probably shouldn't be using <code>bound.value</code> directly in <code>ToProgramClauses</code> then, because that throws away the binders</p>",
        "id": 193095415,
        "sender_full_name": "detrumi",
        "timestamp": 1586204174
    },
    {
        "content": "<p>right</p>",
        "id": 193096648,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204669
    },
    {
        "content": "<p>definitely if you find you are throwing away binders, something is kind of doing wrong</p>",
        "id": 193096672,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204686
    },
    {
        "content": "<p>Heh, guess I need to think of some other names than <code>bound</code>:</p>\n<div class=\"codehilite\"><pre><span></span>for bound in &amp;opaque_ty_bound.bounds {\n    // Implemented(!T&lt;..&gt;: Bound).\n    builder.push_binders(&amp;bound, |builder, bound| {\n        builder.push_binders(&amp;bound, |builder, bound| {\n            builder.push_fact(bound.into_well_formed_goal(interner));\n        });\n    });\n}\n</pre></div>",
        "id": 193096905,
        "sender_full_name": "detrumi",
        "timestamp": 1586204794
    },
    {
        "content": "<p>heh, orthogonal from your PR, but I also don't really like the <code>FooBound</code> naming convention, and particularly don't liek that I called many of the fields <code>binders</code></p>",
        "id": 193097262,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204968
    },
    {
        "content": "<p>the code gets pretty hard to read</p>",
        "id": 193097279,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204972
    },
    {
        "content": "<p>Still didn't get the <code>T: Clone</code> goal to be proven for <code>opaque type T: Clone = Ty;</code>, sadly</p>",
        "id": 193097290,
        "sender_full_name": "detrumi",
        "timestamp": 1586204977
    },
    {
        "content": "<p>Agreed, naming improvements would be good to do afterwards</p>",
        "id": 193097428,
        "sender_full_name": "detrumi",
        "timestamp": 1586205027
    },
    {
        "content": "<p>OK, I didn't do a detailed review, I can try to do that later</p>",
        "id": 193097944,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586205263
    },
    {
        "content": "<p>Yeah, hopefully we can get this merged then. I'll just rebase first</p>",
        "id": 193098277,
        "sender_full_name": "detrumi",
        "timestamp": 1586205434
    },
    {
        "content": "<p>Rebased</p>",
        "id": 193099309,
        "sender_full_name": "detrumi",
        "timestamp": 1586205927
    },
    {
        "content": "<p>That's strange, <code>OpaqueTyDatum.to_program_clauses</code> isn't even being called for the failing test...</p>",
        "id": 193314850,
        "sender_full_name": "detrumi",
        "timestamp": 1586350566
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> are you around by any chance?</p>",
        "id": 193876379,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859596
    },
    {
        "content": "<p>OK, <a href=\"https://github.com/rust-lang/chalk/pull/324#pullrequestreview-392782721\" title=\"https://github.com/rust-lang/chalk/pull/324#pullrequestreview-392782721\">I left a review here</a> and the most notable comments are <a href=\"https://github.com/rust-lang/chalk/pull/324#discussion_r408027278\" title=\"https://github.com/rust-lang/chalk/pull/324#discussion_r408027278\">around this point</a>. I suspect the changes I suggest will fix the test. :)</p>",
        "id": 193877244,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586860114
    },
    {
        "content": "<p>Moving the substitution and such into <code>push_binders</code> didn't fix the test, but I haven't looked at the other changes yet</p>",
        "id": 193882107,
        "sender_full_name": "detrumi",
        "timestamp": 1586863217
    },
    {
        "content": "<p><code>bound.substitute(interner, &amp;[alias_placeholder_ty])</code> doesn't work because <code>alias_placeholder_ty</code> is a <code>Ty&lt;I&gt;</code>, which doesn't implement <code>AsParameters&lt;I&gt;</code></p>",
        "id": 193882862,
        "sender_full_name": "detrumi",
        "timestamp": 1586863693
    },
    {
        "content": "<p>Should be <code>&amp;Substitution::from1(interner, alias_placeholder_ty.clone())</code>, I think</p>",
        "id": 193883123,
        "sender_full_name": "detrumi",
        "timestamp": 1586863857
    },
    {
        "content": "<p>sure, that works. We could probably implement <code>AsParameters&lt;I&gt;</code> for <code>[Ty&lt;I&gt;]</code> as well but...</p>",
        "id": 193887394,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586866606
    },
    {
        "content": "<p>(or even for <code>Ty&lt;I&gt;</code> as a singleton list)</p>",
        "id": 193887419,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586866623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> push changes as you go and I can run tests locally</p>",
        "id": 193887457,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586866647
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> pushed already</p>",
        "id": 193887483,
        "sender_full_name": "detrumi",
        "timestamp": 1586866666
    },
    {
        "content": "<p>(don't have time rn to look into it further, will look at it later today)</p>",
        "id": 193889837,
        "sender_full_name": "detrumi",
        "timestamp": 1586867918
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> I think I see the problem.</p>",
        "id": 193891767,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586868929
    },
    {
        "content": "<p>I can leave a comment on the PR</p>",
        "id": 193891781,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586868939
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/chalk/pull/324#issuecomment-613428033\" title=\"https://github.com/rust-lang/chalk/pull/324#issuecomment-613428033\">done</a></p>",
        "id": 193892357,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586869222
    },
    {
        "content": "<p>Good point, something like that was missing. I'm trying something like this, but it doesn't fix the test yet:</p>\n<div class=\"codehilite\"><pre><span></span>if let TyData::Apply(ApplicationTy {\n                name: TypeName::OpaqueType(opaque_ty_id),\n                ..\n            }) = self_ty.data(interner)\n            {\n                db.opaque_ty_data(*opaque_ty_id).to_program_clauses(builder);\n            }\n</pre></div>\n\n\n<p>Will look into it more (and probably add/use some helper methods as well)</p>",
        "id": 193898564,
        "sender_full_name": "detrumi",
        "timestamp": 1586871911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> can you push to your branch?</p>",
        "id": 193932916,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586886220
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> oops, pushed now</p>",
        "id": 193938585,
        "sender_full_name": "detrumi",
        "timestamp": 1586888981
    },
    {
        "content": "<p>Doesn't look like that code path is being hit</p>",
        "id": 193938952,
        "sender_full_name": "detrumi",
        "timestamp": 1586889155
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> hmm</p>",
        "id": 193946734,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586892901
    },
    {
        "content": "<p>doing some quick debugging</p>",
        "id": 193946865,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586892970
    },
    {
        "content": "<p>ok, right, so the problem is</p>",
        "id": 193946953,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893040
    },
    {
        "content": "<p>well, so let me push one relevant change</p>",
        "id": 193947580,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893400
    },
    {
        "content": "<p>I am adding the rules also if the self type is the \"alias\" version of the opaque type</p>",
        "id": 193947589,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893411
    },
    {
        "content": "<p>but that's not quite enough to see the problem, I suspect that the rules are being removed</p>",
        "id": 193947616,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893437
    },
    {
        "content": "<p>oh, hmm, that's not quite right</p>",
        "id": 193947715,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893489
    },
    {
        "content": "<p>ah, I see</p>",
        "id": 193947766,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> so this was the diff</p>\n<div class=\"codehilite\"><pre><span></span>modified   chalk-solve/src/clauses/program_clauses.rs\n<span class=\"gu\">@@ -175,7 +175,7 @@ impl&lt;I: Interner&gt; ToProgramClauses&lt;I&gt; for OpaqueTyDatum&lt;I&gt; {</span>\n                     &amp;Substitution::from1(interner, alias_placeholder_ty.clone()),\n                 );\n                 builder.push_binders(&amp;bound_with_placeholder_ty, |builder, bound| {\n<span class=\"gd\">-                    builder.push_fact(bound.into_well_formed_goal(interner));</span>\n<span class=\"gi\">+                    builder.push_fact(bound);</span>\n                 });\n             }\n</pre></div>",
        "id": 193947906,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893587
    },
    {
        "content": "<p>given a type like <code>type Foo = impl Debug</code>, you were generating <code>WellFormed(!Foo: Debug)</code>, and not <code>Implemented(!Foo: Debug)</code></p>",
        "id": 193947932,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893603
    },
    {
        "content": "<p>with that change, the test passes</p>",
        "id": 193947953,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893617
    },
    {
        "content": "<p>Woah, <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 193947981,
        "sender_full_name": "detrumi",
        "timestamp": 1586893633
    },
    {
        "content": "<p>Good catch, yeah that doesn't fit there</p>",
        "id": 193948214,
        "sender_full_name": "detrumi",
        "timestamp": 1586893767
    },
    {
        "content": "<p>just for reference,</p>",
        "id": 193948254,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893788
    },
    {
        "content": "<p>the way I debugged this,</p>",
        "id": 193948258,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893790
    },
    {
        "content": "<p>was basically to look at what program clauses were being generated for the goal</p>",
        "id": 193948274,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893799
    },
    {
        "content": "<p>I was looking for one that looked like <code>Implemented(!T: Debug)</code> and I kept not seeing it :P</p>",
        "id": 193948326,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893809
    },
    {
        "content": "<p>also, the debug output for these things is really painful, it'd be nice to see <code>!Foo</code> or something and not the current output...</p>",
        "id": 193948391,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586893844
    },
    {
        "content": "<p>Yeah, pushed a fix for that just now</p>",
        "id": 193948435,
        "sender_full_name": "detrumi",
        "timestamp": 1586893867
    },
    {
        "content": "<p>Wasn't looking at the CHALK_DEBUG=1 output, which I should've been doing</p>",
        "id": 193948470,
        "sender_full_name": "detrumi",
        "timestamp": 1586893886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Wait, did you have more changes? Because just that change doesn't fix the <code>opaque_bounds</code> test</p>",
        "id": 193948714,
        "sender_full_name": "detrumi",
        "timestamp": 1586894002
    },
    {
        "content": "<p>oh</p>",
        "id": 193948902,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894077
    },
    {
        "content": "<p>wait</p>",
        "id": 193948903,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894078
    },
    {
        "content": "<p>pushed</p>",
        "id": 193948948,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894103
    },
    {
        "content": "<p>Ah, so a match for AliasTy::Opaque was missing in program_clauses_that_could_match. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 193949145,
        "sender_full_name": "detrumi",
        "timestamp": 1586894195
    },
    {
        "content": "<p>Yeah, so the reason that comes about</p>",
        "id": 193949265,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894255
    },
    {
        "content": "<p>is because we start out with the goal using the <em>unnormalized</em> type</p>",
        "id": 193949294,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894268
    },
    {
        "content": "<p>actually if we adopt the \"sem vs syntatic equality\" thing</p>",
        "id": 193949312,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894278
    },
    {
        "content": "<p>that would no longer be true...</p>",
        "id": 193949362,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894284
    },
    {
        "content": "<p>...but for now it's true</p>",
        "id": 193949379,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894294
    },
    {
        "content": "<p>I was wondering, side note, whether those goals should <em>actually</em> be FromEnv goals</p>",
        "id": 193949400,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894305
    },
    {
        "content": "<p>but I think it's fine as is, that kind of relates to implied bounds</p>",
        "id": 193949439,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894324
    },
    {
        "content": "<p>we might change it later, easy enough to do</p>",
        "id": 193949455,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894330
    },
    {
        "content": "<p>still, I <em>think</em> the corresponding stuff for associated types is <code>FromEnv</code>? have to compare</p>",
        "id": 193949479,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894342
    },
    {
        "content": "<p>What would it be instead of <code>FromEnv</code>?</p>",
        "id": 193949511,
        "sender_full_name": "detrumi",
        "timestamp": 1586894357
    },
    {
        "content": "<p>at minimum I was surprised that I didn't see similar rules for \"unnormalized associated types\", which made me think that it's probably in the <code>FromEnv</code> section</p>",
        "id": 193949517,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894358
    },
    {
        "content": "<p>what I mean is:</p>",
        "id": 193949537,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894365
    },
    {
        "content": "<p>we are generating clauses like <code>Implemented(!Foo: Debug)</code></p>",
        "id": 193949548,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894372
    },
    {
        "content": "<p>but maybe we should be generating <code>FromEnv(!Foo: Debug)</code></p>",
        "id": 193949567,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894380
    },
    {
        "content": "<p>which would also work, because <code>Implemented(T: Debug) :- FromEnv(T: Debug)</code></p>",
        "id": 193949585,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894390
    },
    {
        "content": "<p>anyway we'll get into all that in next week's design meeting I suppose ;)</p>",
        "id": 193949630,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586894402
    },
    {
        "content": "<p>Ah, yeah, that'd make more sense</p>",
        "id": 193949650,
        "sender_full_name": "detrumi",
        "timestamp": 1586894407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> merged!</p>",
        "id": 194321818,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587050782
    },
    {
        "content": "<p><code>DynTy</code> documentation states that it could be an <code>impl Trait</code>, is this info outdated and opaque types live either in <code>AliasTy</code> or <code>ApplicationTy</code>?</p>",
        "id": 194669253,
        "sender_full_name": "Areredify",
        "timestamp": 1587386770
    },
    {
        "content": "<p>Yes, <code>DynTy</code> is now only used for <code>dyn Trait</code>, and the documentation is outdated there</p>",
        "id": 194681164,
        "sender_full_name": "detrumi",
        "timestamp": 1587392454
    },
    {
        "content": "<p>Ok, I'll fix it in a relevant pr then</p>",
        "id": 194681451,
        "sender_full_name": "Areredify",
        "timestamp": 1587392571
    },
    {
        "content": "<p>Thanks! Yeah, I still need to get around to documenting opaque types, but there's bound to be other places that have outdated info</p>",
        "id": 194681698,
        "sender_full_name": "detrumi",
        "timestamp": 1587392673
    },
    {
        "content": "<p>Figuring out how all the rules work is kinda tricky. I'm trying to get generic opaque types working, using something like this:</p>\n<div class=\"codehilite\"><pre><span></span>program {\n    ...\n    opaque type Foo&lt;X&gt;: Iterator&lt;Item = X&gt; = Vec&lt;X&gt;\n} goal {\n    Foo&lt;u32&gt;: Iterator&lt;Item = u32&gt;\n}\n</pre></div>",
        "id": 194708298,
        "sender_full_name": "detrumi",
        "timestamp": 1587404045
    },
    {
        "content": "<p>It then gets stuck on this goal, with an empty environment:</p>\n<div class=\"codehilite\"><pre><span></span>all(\n    AliasEq(&lt;!Foo&lt;u32&gt; as Iterator&gt;::Item = u32),\n    Implemented(!Foo&lt;u32&gt;: Iterator)\n)\n</pre></div>",
        "id": 194708338,
        "sender_full_name": "detrumi",
        "timestamp": 1587404078
    },
    {
        "content": "<p>Ah, maybe I should just look at projections, since those normalize clauses are almost the same</p>",
        "id": 194708521,
        "sender_full_name": "detrumi",
        "timestamp": 1587404182
    },
    {
        "content": "<p>Yeah, those have <code>Env([for&lt;&gt; FromEnv(!1_0: Iterator)])</code> instead of <code>Env([])</code>, so I'm missing something</p>",
        "id": 194708646,
        "sender_full_name": "detrumi",
        "timestamp": 1587404275
    },
    {
        "content": "<p>Ooh, that's from the where_clauses/binders. Those layers of binders still confuse me</p>",
        "id": 194710413,
        "sender_full_name": "detrumi",
        "timestamp": 1587405175
    },
    {
        "content": "<p>Hmm, that's still not working. Something is still missing before this test works, not sure if it's the WF rules or implied bounds</p>",
        "id": 195377732,
        "sender_full_name": "detrumi",
        "timestamp": 1587969518
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> -- I didnt' quite get to your PR, but are your questions in there?</p>",
        "id": 195481830,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588025689
    },
    {
        "content": "<p>i.e., if I pull from your branch, can I reproduce the problems?</p>",
        "id": 195481854,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588025701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> Yes, I've pushed the failing test now. And I guess the main question is whether generics with opaque types should work like this, or whether implied bounds interactions need to be handled first</p>",
        "id": 195523665,
        "sender_full_name": "detrumi",
        "timestamp": 1588055846
    },
    {
        "content": "<p>Simply changing <code>Implemented</code> to <code>FromEnv</code> in the rules causes the simpler <code>opaque_bounds</code> test to fail, so either that's wrong or I'm missing a rule somewhere</p>",
        "id": 195668785,
        "sender_full_name": "detrumi",
        "timestamp": 1588144315
    },
    {
        "content": "<p>Hey <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> -- how's it going here</p>",
        "id": 196244063,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588628849
    },
    {
        "content": "<p>I'm wondering if I should be giving feedback to help push this along</p>",
        "id": 196244363,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588629069
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> So, I'm mostly just overwhelmed by implied bound interactions, and have a hard time debugging it. But maybe I've started with the hard part here</p>",
        "id": 196358717,
        "sender_full_name": "detrumi",
        "timestamp": 1588708563
    },
    {
        "content": "<p>I've been looking into opaque type generics recently (picking up where @detrumi left off) and I've figured out why the test in the draft PR fails, but I'm unsure of the best way to fix it.<br>\nFor context, the test case is:</p>\n<div class=\"codehilite\"><pre><span></span><code>program {\n    trait Iterator { type Item; }\n\n    struct Vec&lt;T&gt; { }\n    struct Bar { }\n    impl&lt;T&gt; Iterator for Vec&lt;T&gt; {\n        type Item = T;\n    }\n\n    opaque type Foo&lt;X&gt;: Iterator&lt;Item = X&gt; = Vec&lt;X&gt;;\n} goal {\n    Foo&lt;Bar&gt;: Iterator&lt;Item = Bar&gt;\n}\n</code></pre></div>\n\n\n<p>The problem is essentially this:</p>\n<ul>\n<li>We model the placeholder type <code>!Foo</code> for the opaque type as an application type (which makes sense, as we are applying a substitution to it)</li>\n<li>Our goal for this test case is:</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><code>all(\n    AliasEq(&lt;!Foo&lt;Bar&gt; as Iterator&gt;::Item = Bar),\n    Implemented(!Foo&lt;Bar&gt;: Iterator)\n)\n</code></pre></div>\n\n\n<ul>\n<li>We attempt to solve the <code>AliasEq</code> goal, which entails proving <code>Normalize(&lt;!Foo&lt;Bar&gt; as Iterator&gt;::Item -&gt; Bar)</code></li>\n<li>As part of proving the <code>Normalize</code> clause, we search for implementations of <code>Iterator</code>,  and find the clause <code>Normalize(&lt;Vec&lt;?0&gt; as Iterator&gt;::Item = ?0)</code></li>\n<li>We attempt to unify <code>Normalize(&lt;Vec&lt;?0&gt; as Iterator&gt;::Item = ?0</code> with <code>Normalize(&lt;!Foo&lt;Bar&gt; as Iterator&gt;::Item -&gt;Bar)</code></li>\n<li>During unification, we try to unify <code>Vec</code> and <code>!Foo</code></li>\n<li><code>!Foo</code> is an application type, and so is <code>Vec</code>, and unification for application types only succeeds if the type names are equivalent (which they aren't), so unification fails. </li>\n<li>There are no more relevant clauses to help prove our goal, and so we fail to find a solution</li>\n</ul>",
        "id": 198229257,
        "sender_full_name": "Nathan Whitaker",
        "timestamp": 1589994898
    },
    {
        "content": "<p>My initial thoughts as to a solution are:</p>\n<ul>\n<li>Don't model the placeholder as in application type</li>\n<li>Add a special case to unification which allows application types with an opaque type name to unify with other application types</li>\n</ul>\n<p>but I'd love to hear other thoughts/insight</p>",
        "id": 198229589,
        "sender_full_name": "Nathan Whitaker",
        "timestamp": 1589995054
    },
    {
        "content": "<p><code>Normalize(&lt;Vec&lt;?0&gt; as Iterator&gt;::Item = ?0)</code> is not the clause from which we should prove that goal</p>",
        "id": 198230411,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1589995485
    },
    {
        "content": "<p>there should be a clause like <code>for&lt;T&gt; AliasEq(&lt;!Foo&lt;T&gt; as Iterator&gt;::Item = T)</code> because that's how the opaque type is defined</p>",
        "id": 198230587,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1589995571
    },
    {
        "content": "<p>(the <code>Vec</code> clause is only relevant for proving the well-formedness of the opaque type definition; proving things about the opaque type itself then should not require knowledge about what's behind it -- that's the whole point of opaque types)</p>",
        "id": 198230733,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1589995645
    },
    {
        "content": "<p>(except for auto traits, of course)</p>",
        "id": 198230748,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1589995652
    },
    {
        "content": "<p>i.e. I think there needs to be some logic in <code>program_clauses</code> that produces the <code>AliasEq</code> clause</p>",
        "id": 198230947,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1589995738
    },
    {
        "content": "<p>and my guess is that <a href=\"https://github.com/rust-lang/chalk/blob/499d49245c117ffb78109cfd3a16496b2d832866/chalk-solve/src/clauses/program_clauses.rs#L172-L178\">this</a> already produces those clauses; it just doesn't get called in the right situations</p>",
        "id": 198234443,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1589997433
    },
    {
        "content": "<p>Ah yes that makes sense, and indeed <code>to_program_clauses</code> isn't being called for the opaque type during solving. Thanks for the help!</p>",
        "id": 198254435,
        "sender_full_name": "Nathan Whitaker",
        "timestamp": 1590007219
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"230601\">@Nathan Whitaker</span> Oh wow, great work</p>",
        "id": 198306883,
        "sender_full_name": "detrumi",
        "timestamp": 1590057485
    },
    {
        "content": "<p>I think the test should also work without the <code>impl&lt;T&gt; Iterator for Vec&lt;T&gt;</code> part, since the goal should be implied because of the bound on the opaque type</p>",
        "id": 198306927,
        "sender_full_name": "detrumi",
        "timestamp": 1590057529
    },
    {
        "content": "<p>Good point! Updated the test in the PR to reflect that.</p>",
        "id": 198335343,
        "sender_full_name": "Nathan Whitaker",
        "timestamp": 1590075169
    },
    {
        "content": "<p>Nit: same thing in the <code>opaque_generics_simple</code> test</p>",
        "id": 198354692,
        "sender_full_name": "detrumi",
        "timestamp": 1590084073
    },
    {
        "content": "<p>Hmm actually, this might change once WF checks are implemented, so never mind</p>",
        "id": 198354946,
        "sender_full_name": "detrumi",
        "timestamp": 1590084200
    },
    {
        "content": "<p>Seems like we should discuss the usage of placeholder vs alias in impl Trait -- <span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> brought it up and it was also relevant to the auto trait PR I just merged (perhaps hastily?)</p>",
        "id": 198823283,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590528108
    },
    {
        "content": "<p>I think I would expect that all the program clauses we make <em>apart</em> from <code>AliasEq</code> rules use the placeholder form</p>",
        "id": 198823348,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590528125
    },
    {
        "content": "<p>I think that makes sense, but they still need to check for both forms in the goal, right?</p>",
        "id": 198823580,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590528268
    },
    {
        "content": "<p>the time being, I think that's right</p>",
        "id": 198823615,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590528290
    },
    {
        "content": "<p>the \"semantic-syntactic\" equality would I guess change that</p>",
        "id": 198823651,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590528310
    },
    {
        "content": "<p>and e.g. in rust-analyzer, impl trait starts off in the alias form?</p>",
        "id": 198823708,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590528356
    },
    {
        "content": "<p>i.e. we never create placeholder types directly</p>",
        "id": 198823822,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590528414
    },
    {
        "content": "<p>right</p>",
        "id": 198824445,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590528771
    },
    {
        "content": "<p>the idea is that you generate what the \"user types\" (which is the alias form)</p>",
        "id": 198824467,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590528783
    },
    {
        "content": "<p>and chalk figures out the rest, so to speak</p>",
        "id": 198824474,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1590528789
    },
    {
        "content": "<p>so can <a href=\"https://github.com/rust-lang-nursery/chalk/issues/473\">chalk#473</a> be merged?</p>",
        "id": 198828198,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590531232
    },
    {
        "content": "<p>Seems okay to me</p>",
        "id": 198828734,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590531604
    },
    {
        "content": "<p>WF checks are kinda tricky, but it feels like I'm getting somewhere now.</p>",
        "id": 199913059,
        "sender_full_name": "detrumi",
        "timestamp": 1591380242
    },
    {
        "content": "<p>Given this opaque type:</p>\n<div class=\"codehilite\"><pre><span></span><code>opaque type Foo&lt;T&gt;: A&lt;U&gt; + B&lt;V&gt; = HiddenTy&lt;T&gt;\n</code></pre></div>",
        "id": 199913088,
        "sender_full_name": "detrumi",
        "timestamp": 1591380255
    },
    {
        "content": "<p>I _think_ it should be something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>forall&lt;T&gt; {\n    exists&lt;U, V&gt; {\n        if (FromEnv(HiddenTy&lt;T&gt;: A&lt;U&gt;) &amp;&amp; FromEnv(HiddenTy&lt;T&gt;: B&lt;V&gt;)) {\n            FromEnv(Foo&lt;T&gt;: A&lt;U&gt;) &amp;&amp; FromEnv(Foo&lt;T&gt;: B&lt;V&gt;)\n        }\n    }\n}\n</code></pre></div>",
        "id": 199913119,
        "sender_full_name": "detrumi",
        "timestamp": 1591380270
    },
    {
        "content": "<p>I've thought about creating a goal for each bound separately, but that might be problematic when there's where clauses (e.g. <code>opaque type Foo: A + B where Foo: C = HiddennType</code>)</p>",
        "id": 199913376,
        "sender_full_name": "detrumi",
        "timestamp": 1591380383
    },
    {
        "content": "<p>Hmm, not sure whether it's possible to get that <code>exists&lt;U, V&gt;</code> from the bounds <code>Vec&lt;QuantifiedWhereClause&lt;I&gt;&gt;</code></p>",
        "id": 199919840,
        "sender_full_name": "detrumi",
        "timestamp": 1591383321
    },
    {
        "content": "<p>Ah, there shouldn't even be a <code>forall&lt;T&gt;</code>, since the parameters to the opaque type should be hose of the hidden type</p>",
        "id": 199988888,
        "sender_full_name": "detrumi",
        "timestamp": 1591470627
    },
    {
        "content": "<p>Not sure if we can assume that the hidden type is an <code>ApplicationTy</code> though, since it might be an alias? (something like <code>type Foo = Bar&lt;T&gt;</code>)</p>",
        "id": 199989011,
        "sender_full_name": "detrumi",
        "timestamp": 1591470815
    }
]