[
    {
        "content": "<p>Does <code>AliasEq(&lt;T as Trait&gt;::*, *)</code> implicitly assume that someone proved <code>Implemeted(T: Trait)</code>? I am a little surprised that</p>\n<div class=\"codehilite\"><pre><span></span><code>forall&lt;T&gt; {\n    exists&lt;U&gt; {\n        AliasEq(&lt;T as Iterator&gt;::Item, U)\n   }\n}\n</code></pre></div>\n\n\n<p>is provable. (Mind you, <code>AliasEq</code> is not a real goal in <code>.chalk</code> syntax at the moment,  I added it for debug purposes)</p>",
        "id": 200040741,
        "sender_full_name": "Areredify",
        "timestamp": 1591561651
    },
    {
        "content": "<p>Wouldn't WF checks handle that?</p>",
        "id": 200042695,
        "sender_full_name": "detrumi",
        "timestamp": 1591564551
    },
    {
        "content": "<p>I mean, that <code>T as Trait</code> has to come from some item, and that item should be well-formed</p>",
        "id": 200042763,
        "sender_full_name": "detrumi",
        "timestamp": 1591564607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> you probably are looking for <code>Normalize</code></p>",
        "id": 200046591,
        "sender_full_name": "Jack Huey",
        "timestamp": 1591570324
    },
    {
        "content": "<p>But yes, the <code>T as Iterator</code> part is only okay because of WF checks</p>",
        "id": 200046598,
        "sender_full_name": "Jack Huey",
        "timestamp": 1591570346
    },
    {
        "content": "<p>So, like, in the parser, we would lower <code>T: Iterator&lt;Item=U&gt;</code> as two where clauses: <code>T: Iterator</code> and <code>ProjectionEq(&lt;T as Iterator&gt;::Item = U)</code></p>",
        "id": 200046667,
        "sender_full_name": "Jack Huey",
        "timestamp": 1591570452
    },
    {
        "content": "<p>I know that</p>",
        "id": 200061437,
        "sender_full_name": "Areredify",
        "timestamp": 1591596793
    },
    {
        "content": "<p>This example was generated by chalk in wf checks</p>",
        "id": 200061447,
        "sender_full_name": "Areredify",
        "timestamp": 1591596831
    },
    {
        "content": "<p>In this example (<code>assoc_tys</code>)</p>\n<div class=\"codehilite\"><pre><span></span><code>struct String { }\nstruct Char { }\n\ntrait Iterator { type Item; }\nimpl Iterator for String { type Item = Char; }\n\ntrait Foo { }\nimpl&lt;X&gt; Foo for &lt;X as Iterator&gt;::Item where X: Iterator { }\n</code></pre></div>\n\n\n<p>wf checks for <code>Foo</code> generate a goal</p>\n<div class=\"codehilite\"><pre><span></span><code>forall&lt;T&gt; {\n    LocalImplAllowed(&lt;T as Iterator&gt;::Item: Foo)\n}\n</code></pre></div>",
        "id": 200062354,
        "sender_full_name": "Areredify",
        "timestamp": 1591598070
    },
    {
        "content": "<p>which is provable but technically T doesn't implement iterator</p>",
        "id": 200062377,
        "sender_full_name": "Areredify",
        "timestamp": 1591598131
    },
    {
        "content": "<p>So...that's not a valid program...</p>",
        "id": 200067942,
        "sender_full_name": "Jack Huey",
        "timestamp": 1591603765
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f10f6686f3d66b800a9ccca35f1701c4\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=f10f6686f3d66b800a9ccca35f1701c4</a></p>",
        "id": 200068008,
        "sender_full_name": "Jack Huey",
        "timestamp": 1591603806
    },
    {
        "content": "<p>That test is wrong I think</p>",
        "id": 200068044,
        "sender_full_name": "Jack Huey",
        "timestamp": 1591603841
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> is it invalid or just a limitation of the rustc trait system?</p>",
        "id": 200074114,
        "sender_full_name": "Areredify",
        "timestamp": 1591607986
    },
    {
        "content": "<p>It's actually invalid. Allowing it would result in overlapping implementations of <code>Foo</code> for a type. For example <code>&amp;i32</code> would be implemented for both <code>X = std::option::Iter&lt;'_, i32&gt;</code> and <code>X = std::slice::Iter&lt;'_, i32&gt;</code></p>",
        "id": 200074724,
        "sender_full_name": "Matthew Jasper",
        "timestamp": 1591608401
    },
    {
        "content": "<p>...oh</p>",
        "id": 200075106,
        "sender_full_name": "Areredify",
        "timestamp": 1591608685
    },
    {
        "content": "<p>Coherence rules regarding associated items are in a little bit of a mess right now, iirc</p>\n<div class=\"codehilite\"><pre><span></span><code> impl&lt;I&gt; Foo for I where I: Iterator&lt;Item = u8&gt; {}\n impl&lt;I&gt; Foo for I where I: Iterator&lt;Item = u8&gt; {}\n</code></pre></div>\n\n\n<p>is still allowed in chalk</p>",
        "id": 200075298,
        "sender_full_name": "Areredify",
        "timestamp": 1591608822
    },
    {
        "content": "<p>Anyway, doesn't really change my question</p>",
        "id": 200075329,
        "sender_full_name": "Areredify",
        "timestamp": 1591608842
    },
    {
        "content": "<p>That is, is this inteded to be provable or not? </p>\n<div class=\"codehilite\"><pre><span></span><code>forall&lt;T&gt; {\n    exists&lt;U&gt; {\n        AliasEq(&lt;T as Iterator&gt;::Item, U)\n   }\n}\n</code></pre></div>",
        "id": 200075403,
        "sender_full_name": "Areredify",
        "timestamp": 1591608897
    },
    {
        "content": "<p>Seems like it's the same question as well-formedness of tuples and arrays</p>",
        "id": 200076769,
        "sender_full_name": "Areredify",
        "timestamp": 1591609913
    },
    {
        "content": "<p>The difference is that chalk produced the ill-formed type (&lt;T as Iterator&gt;::Item) instead of it being passed from outside</p>",
        "id": 200077031,
        "sender_full_name": "Areredify",
        "timestamp": 1591610072
    },
    {
        "content": "<p>I'm not sure what I think the answer should be</p>",
        "id": 200160652,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591653190
    },
    {
        "content": "<p>it seems clear that somebody needs to prove that <code>T: Iterator</code></p>",
        "id": 200160688,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591653219
    },
    {
        "content": "<p>but should it be that <code>AliasEq</code> rules, or a seperate WF check, is I guess the question</p>",
        "id": 200160706,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591653233
    },
    {
        "content": "<p>in particular, I guess the question is whether the \"placeholder rule\" needs to require that <code>T: Iterator</code></p>",
        "id": 200160756,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591653243
    },
    {
        "content": "<p>I don't remember if we elided it on purpose, <span class=\"user-mention\" data-user-id=\"131694\">@scalexm</span> might. Off the top of my head, I can't think of a good reason to do so.</p>",
        "id": 200160776,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1591653263
    },
    {
        "content": "<p>I agree, probably we elided it just because it was not strictly needed as <code>AliasEq</code> rules are never used directly, but rather are desugared from <code>T: Iterator&lt;Item = U&gt;</code></p>",
        "id": 200237711,
        "sender_full_name": "scalexm",
        "timestamp": 1591713532
    },
    {
        "content": "<p>... or can come from unification during type checking, in which case we’ll also issue a <code>WF(&lt;T as Iterator&gt;::Item)</code>, which requires <code>Implemented(T: Iterator)</code> to be proved (I guess that’s what <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> was saying)</p>",
        "id": 200238324,
        "sender_full_name": "scalexm",
        "timestamp": 1591713763
    }
]