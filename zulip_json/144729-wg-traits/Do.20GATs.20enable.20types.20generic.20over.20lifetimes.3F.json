[
    {
        "content": "<p>Just finished reading <a href=\"https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html\">https://blog.rust-lang.org/2021/08/03/GATs-stabilization-push.html</a> and while I don't immediately see how they would enable it, but there is enough overlap that I thought I'd ask. I'm the author of self_cell that's mostly where this is coming from. I'd love to drop the macro and just have a plain type. Can GATs help build a library interface where users provide a type without it's lifetime and the library describes and implements behavior with custom lifetimes?</p>",
        "id": 249613973,
        "sender_full_name": "Lukas Bergdoll",
        "timestamp": 1629132436
    },
    {
        "content": "<p>It's not perfect, but you can emulate this kind of like this:<br>\n<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=e086aa3ed8c9207dcfdeb7ff66b42411\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=e086aa3ed8c9207dcfdeb7ff66b42411</a></p>\n<p>This has a couple limitations, for example the user may end up needing to pass their type to the function as <code>Foo&lt;'static&gt;</code>, and the function fills in the real lifetime to return. There's also no guarantee that the implementer returns the same type. Bounding the associated type on the same trait at least limits the things they could make it, but there's nothing to stop them from making <code>Bar::Assoc&lt;'a&gt; = Foo&lt;'a&gt;</code> and <code>Foo::Assoc&lt;'a&gt; = Bar&lt;'a&gt;</code>.</p>",
        "id": 249656830,
        "sender_full_name": "CraftSpider",
        "timestamp": 1629153118
    },
    {
        "content": "<p>Basically, this doesn't totally obsolete generic-generics / higher-kinded types, but it can emulate them in some cases.</p>",
        "id": 249657005,
        "sender_full_name": "CraftSpider",
        "timestamp": 1629153240
    }
]