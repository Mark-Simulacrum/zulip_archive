[
    {
        "content": "<p>I'm trying to debug why inferring the type for <code>y</code>  fails with chalk:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Struct</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Value</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">isize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">grab</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">Get</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Get</span><span class=\"o\">&gt;</span>::<span class=\"n\">Value</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">grab</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// error[E0282]: type annotations needed for `_#2t`</span>\n<span class=\"w\">    </span><span class=\"c1\">//  ^ consider giving `y` the explicit type `_#2t`, where the type parameter `_#3t` is specified</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I think I've narrowed it down to this solver call returning no guidance: </p>\n<div class=\"codehilite\"><pre><span></span><code>│ │ │ │ │ ├─ DEBUG rustc_traits::chalk lowered_goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: ForAll[] { AliasEq(projection: AssocTypeId(DefId(0:4 ~ associated_types_in_fn[b8ba]::Get::Value)) [Ty(AdtId(Struct)&lt;[]&gt;)] = ^1.0) } }, binders: [U0 with kind type] }, universes: 1 }\n│ │ │ │ │ ├─ DEBUG rustc_traits::chalk evaluate goal, obligation=Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }], value: ChalkEnvironmentAndGoal { environment: [], goal: Binder(ProjectionPredicate(ProjectionTy { substs: [Struct], item_def_id: DefId(0:4 ~ associated_types_in_fn[b8ba]::Get::Value) }, Ty(^1_0)), []) } }, solution=Some(Ambig(Unknown))\n</code></pre></div>\n<p>It seems to methat has enough info to deduce <code>^1_0 = isize</code>, right?</p>",
        "id": 273862628,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646248977
    },
    {
        "content": "<p>Likely <a href=\"https://github.com/rust-lang/chalk/issues/234\">chalk#234</a></p>",
        "id": 273862738,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646249030
    },
    {
        "content": "<p>hmm I can repro in the REPL, did I do it right? </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Value</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Struct</span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Get</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Value</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">isize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// ?- exists&lt;T&gt; { &lt;Struct as Get&gt;::Value = T }</span>\n<span class=\"c1\">// Ambiguous; no inference guidance</span>\n</code></pre></div>",
        "id": 273864882,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646249928
    },
    {
        "content": "<p>this example seems much simpler than the one in <a href=\"https://github.com/rust-lang/chalk/issues/234\">chalk#234</a> though...?</p>",
        "id": 273864959,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646249965
    },
    {
        "content": "<p>It's because we get <code>(Get::Value)&lt;Struct&gt;</code> and <code>isize</code> as answers</p>",
        "id": 273865164,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646250041
    },
    {
        "content": "<p>welp I guess I didn't pick an easy one then :(<br>\nHas there been any new developments on how to proceed other than what's written in the issue, or is it still unclear? It does work with the recursive solver, is the plan to switch to that?</p>",
        "id": 273872462,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646253186
    },
    {
        "content": "<p>There aren't any new developments - even though I'm getting antsy to get back to it.</p>",
        "id": 273872531,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646253240
    },
    {
        "content": "<p>If you want, it might be worth just trying to switch to the recursive solver.</p>",
        "id": 273872599,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646253256
    },
    {
        "content": "<p>add a <code>-Zchalk-solver=recursive</code> flag to rustc?</p>",
        "id": 273872746,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646253320
    },
    {
        "content": "<p>Well, that could be one way. Or just switch</p>",
        "id": 273873249,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646253559
    },
    {
        "content": "<p>hmm, it makes 2 tests hang and 1 fail</p>\n<div class=\"codehilite\"><pre><span></span><code>test [ui] ui/chalkify/lower_env2.rs has been running for over 60 seconds\ntest [ui] ui/chalkify/lower_trait_where_clause.rs has been running for over 60 seconds\n\n---- [ui] ui/chalkify/lower_impl.rs stdout ----\n\nerror: test compilation failed although it shouldn&#39;t!\nstatus: exit status: 1\ncommand: &quot;/home/dirbaio/rust/build/x86_64-unknown-linux-gnu/stage1/bin/rustc&quot; &quot;/home/dirbaio/rust/src/test/ui/chalkify/lower_impl.rs&quot; &quot;-Zthreads=1&quot; &quot;--target=x86_64-unknown-linux-gnu&quot; &quot;--error-format&quot; &quot;json&quot; &quot;--json&quot; &quot;future-incompat&quot; &quot;-Ccodegen-units=1&quot; &quot;-Zui-testing&quot; &quot;-Zdeduplicate-diagnostics=no&quot; &quot;--emit&quot; &quot;metadata&quot; &quot;-C&quot; &quot;prefer-dynamic&quot; &quot;--out-dir&quot; &quot;/home/dirbaio/rust/build/x86_64-unknown-linux-gnu/test/ui/chalkify/lower_impl&quot; &quot;-A&quot; &quot;unused&quot; &quot;-Crpath&quot; &quot;-O&quot; &quot;-Cdebuginfo=0&quot; &quot;-Lnative=/home/dirbaio/rust/build/x86_64-unknown-linux-gnu/native/rust-test-helpers&quot; &quot;-Z&quot; &quot;chalk&quot; &quot;-L&quot; &quot;/home/dirbaio/rust/build/x86_64-unknown-linux-gnu/test/ui/chalkify/lower_impl/auxiliary&quot;\nstdout: none\n--- stderr -------------------------------\nerror[E0283]: type annotations needed\n  --&gt; /home/dirbaio/rust/src/test/ui/chalkify/lower_impl.rs:6:18\n   |\nLL | impl&lt;T: &#39;static&gt; Foo for T where T: Iterator&lt;Item = i32&gt; { }\n   |                  ^^^ cannot infer type for type parameter `T`\n   |\n   = note: cannot satisfy `T: Foo`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0283`.\n------------------------------------------\n</code></pre></div>",
        "id": 273876279,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646254851
    },
    {
        "content": "<p>Right okay. That sounds about like what it was the last time I tried it</p>",
        "id": 273876385,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646254906
    },
    {
        "content": "<p>(We should figure out why its hanging)</p>",
        "id": 273876460,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646254925
    },
    {
        "content": "<p>this hangs with an empty program: <code>exists&lt;'a, T&gt; { if(T: 'a) { WellFormed(&amp;'a T) } }</code></p>",
        "id": 273887448,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646260127
    },
    {
        "content": "<p>I think that's the cause of these tests hanging</p>",
        "id": 273887539,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646260189
    },
    {
        "content": "<p>That hangs with the recursive solver but not SLG?</p>",
        "id": 273887922,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646260321
    },
    {
        "content": "<p>yep, with SLG it gives</p>\n<div class=\"codehilite\"><pre><span></span><code>?- exists&lt;&#39;a, T&gt; { if(T: &#39;a) { WellFormed(&amp;&#39;a T) } }\nAmbiguous; definite substitution for&lt;?U0,?U0&gt; { [?0 := ^0.0, ?1 := &#39;^0.1] }\n</code></pre></div>",
        "id": 273888133,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646260429
    },
    {
        "content": "<p>these substitutions are weird, they contain no new info. Why are they returned?</p>",
        "id": 273889024,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646260859
    },
    {
        "content": "<p>That's exactly correct. It means \"this is true for the exact inputs given\"</p>",
        "id": 273889123,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646260920
    },
    {
        "content": "<p>Well, more precisely it's saying: There might be many solutions, but any solution will use the exact inputs given.</p>",
        "id": 273889371,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646261034
    },
    {
        "content": "<p>I see</p>",
        "id": 273889557,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646261111
    },
    {
        "content": "<p>It would be definitely good to know why this hangs :)</p>",
        "id": 273890069,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646261383
    },
    {
        "content": "<p>This is pretty critical I think</p>",
        "id": 273890090,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646261391
    },
    {
        "content": "<p>so, it's hanging here <a href=\"https://github.com/rust-lang/chalk/blob/master/chalk-recursive/src/fulfill.rs#L448\">https://github.com/rust-lang/chalk/blob/master/chalk-recursive/src/fulfill.rs#L448</a></p>",
        "id": 273912019,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646274174
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>            617ms DEBUG start of round, 2 obligations\n            prove wc=InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: ?2: &#39;?3 }\n              solve_goal goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: ^0.0: &#39;^0.1 }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }\n                0ms DEBUG Cache hit, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: ^0.0: &#39;^0.1 }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }, result=Ok(Ambig(Definite(Canonical { value: [?0 := ^0.0, ?1 := &#39;^0.1], binders: [U0 with kind type, U0 with kind lifetime] })))\n                0ms DEBUG solve_reduced_goal: cache hit, value=Ok(Ambig(Definite(Canonical { value: [?0 := ^0.0, ?1 := &#39;^0.1], binders: [U0 with kind type, U0 with kind lifetime] })))\n            618ms DEBUG fulfill::apply_solution: adding constraints []\n            618ms DEBUG unify(?2, ?1140) succeeded\n            618ms DEBUG unify: goals=[]\n            618ms DEBUG unify(&#39;?3, &#39;?1141) succeeded\n            618ms DEBUG unify: goals=[]\n            618ms DEBUG ambiguous result: Prove(InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: ?2: &#39;?3 })\n            prove wc=InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: WellFormed(?2) }\n              solve_goal goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: WellFormed(^0.0) }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }\n                0ms DEBUG Cache hit, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: WellFormed(^0.0) }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }, result=Ok(Ambig(Unknown))\n                0ms DEBUG solve_reduced_goal: cache hit, value=Ok(Ambig(Unknown))\n            618ms DEBUG ambiguous result: Prove(InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: WellFormed(?2) })\n            618ms DEBUG end of round, 2 obligations left\n\n\n            618ms DEBUG start of round, 2 obligations\n            prove wc=InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: WellFormed(?2) }\n              solve_goal goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: WellFormed(^0.0) }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }\n                0ms DEBUG Cache hit, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: WellFormed(^0.0) }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }, result=Ok(Ambig(Unknown))\n                0ms DEBUG solve_reduced_goal: cache hit, value=Ok(Ambig(Unknown))\n            619ms DEBUG ambiguous result: Prove(InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: WellFormed(?2) })\n            prove wc=InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: ?2: &#39;?3 }\n              solve_goal goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: ^0.0: &#39;^0.1 }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }\n                0ms DEBUG Cache hit, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: ^0.0: &#39;^0.1 }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }, result=Ok(Ambig(Definite(Canonical { value: [?0 := ^0.0, ?1 := &#39;^0.1], binders: [U0 with kind type, U0 with kind lifetime] })))\n                0ms DEBUG solve_reduced_goal: cache hit, value=Ok(Ambig(Definite(Canonical { value: [?0 := ^0.0, ?1 := &#39;^0.1], binders: [U0 with kind type, U0 with kind lifetime] })))\n            619ms DEBUG fulfill::apply_solution: adding constraints []\n            619ms DEBUG unify(?2, ?1142) succeeded\n            619ms DEBUG unify: goals=[]\n            619ms DEBUG unify(&#39;?3, &#39;?1143) succeeded\n            619ms DEBUG unify: goals=[]\n            619ms DEBUG ambiguous result: Prove(InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: ?2: &#39;?3 })\n            619ms DEBUG end of round, 2 obligations left\n\n\n            619ms DEBUG start of round, 2 obligations\n            prove wc=InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: ?2: &#39;?3 }\n              solve_goal goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: ^0.0: &#39;^0.1 }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }\n                0ms DEBUG Cache hit, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: ^0.0: &#39;^0.1 }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }, result=Ok(Ambig(Definite(Canonical { value: [?0 := ^0.0, ?1 := &#39;^0.1], binders: [U0 with kind type, U0 with kind lifetime] })))\n                0ms DEBUG solve_reduced_goal: cache hit, value=Ok(Ambig(Definite(Canonical { value: [?0 := ^0.0, ?1 := &#39;^0.1], binders: [U0 with kind type, U0 with kind lifetime] })))\n            620ms DEBUG fulfill::apply_solution: adding constraints []\n            620ms DEBUG unify(?2, ?1144) succeeded\n            620ms DEBUG unify: goals=[]\n            620ms DEBUG unify(&#39;?3, &#39;?1145) succeeded\n            620ms DEBUG unify: goals=[]\n            620ms DEBUG ambiguous result: Prove(InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: ?2: &#39;?3 })\n            prove wc=InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: WellFormed(?2) }\n              solve_goal goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: WellFormed(^0.0) }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }\n                0ms DEBUG Cache hit, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([for&lt;&gt; ^1.0: &#39;^1.1]), goal: WellFormed(^0.0) }, binders: [U0 with kind type, U0 with kind lifetime] }, universes: 1 }, result=Ok(Ambig(Unknown))\n                0ms DEBUG solve_reduced_goal: cache hit, value=Ok(Ambig(Unknown))\n            620ms DEBUG ambiguous result: Prove(InEnvironment { environment: Env([for&lt;&gt; ?0: &#39;?1]), goal: WellFormed(?2) })\n            620ms DEBUG end of round, 2 obligations left\n</code></pre></div>",
        "id": 273912071,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646274231
    },
    {
        "content": "<p>it tries to prove <code>InEnvironment { environment: Env([for&lt;&gt; ?0: '?1]), goal: ?2: '?3 }</code><br>\nit gets \"useless\" substs <code>[?0 := ^0.0, ?1 := '^0.1]</code><br>\nit applies them, they cause nothing to change but it thinks they did<br>\nso in next round it processes again the exact same obligation...</p>",
        "id": 273912319,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646274389
    },
    {
        "content": "<p>are substs always guaranteed to be \"useful\"?</p>",
        "id": 273913206,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646275118
    },
    {
        "content": "<p>Not necessarily</p>",
        "id": 273913508,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646275362
    },
    {
        "content": "<p>so the bug is in that loop, it needs a smarter way to check whether we've arrived to a fixed point</p>",
        "id": 273913530,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646275410
    },
    {
        "content": "<p>but how?</p>",
        "id": 273913582,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646275443
    },
    {
        "content": "<p>Not sure, it's been a bit</p>",
        "id": 273913604,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646275468
    },
    {
        "content": "<p>comparing the full <code>Fulfill</code> state won't work, it technically gets mutated (new vars get created then unified)</p>",
        "id": 273916060,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646277491
    },
    {
        "content": "<p>I'm thinking something like: if substs are 1-to-1 and there's no constraints, then they're \"useless\"</p>",
        "id": 273916112,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646277578
    },
    {
        "content": "<p>it feels like a hack though</p>",
        "id": 273916191,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646277639
    },
    {
        "content": "<p>this <code>if</code> is already kindof a hack <a href=\"https://github.com/rust-lang/chalk/blob/master/chalk-recursive/src/fulfill.rs#L474\">https://github.com/rust-lang/chalk/blob/master/chalk-recursive/src/fulfill.rs#L474</a><br>\nthis would be a more \"powerful\" version of it</p>",
        "id": 273916274,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646277723
    },
    {
        "content": "<p>it seems to work! :D <a href=\"https://github.com/rust-lang/chalk/pull/752\">https://github.com/rust-lang/chalk/pull/752</a></p>",
        "id": 273920794,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646281552
    },
    {
        "content": "<p>That's not quite right I don't think. Should be definite substitution</p>",
        "id": 273920973,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646281691
    },
    {
        "content": "<p>yeah I found that suspicious as well.. can this cause an issue in practice?</p>",
        "id": 273921033,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646281777
    },
    {
        "content": "<p>why does it have to be definite? it hasn't really learned anything, has it?</p>\n<p>it's hitting this <a href=\"https://github.com/rust-lang/chalk/blob/master/chalk-recursive/src/fulfill.rs#L576\">https://github.com/rust-lang/chalk/blob/master/chalk-recursive/src/fulfill.rs#L576</a><br>\nif I also put the \"trivial\" check there then it returns <code>Guidance::Unknown</code> instead, not sure if that's better or worse</p>",
        "id": 273921531,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646282183
    },
    {
        "content": "<p>It different, definite means \"real\" progress. Suggested is \"not real\"</p>",
        "id": 273921997,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646282598
    },
    {
        "content": "<p>but it's returning just \"0=0, 1=1\", how's that \"real\" progress?</p>",
        "id": 273922086,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646282696
    },
    {
        "content": "<blockquote>\n<p><code>Ambiguous; definite substitution for&lt;?U0,?U0&gt; { [?0 := ^0.0, ?1 := '^0.1] }</code></p>\n</blockquote>",
        "id": 273922109,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646282742
    },
    {
        "content": "<p>Because it literally means \"if you use these substs, the answer will be correct\"</p>",
        "id": 273922863,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646283500
    },
    {
        "content": "<p>Whereas suggested doesn't have that</p>",
        "id": 273922871,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646283511
    },
    {
        "content": "<p>(At least in theory, I dont think we've precisely defined these)</p>",
        "id": 273922885,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646283529
    },
    {
        "content": "<p>ah, so it's \"proven\" as in here <a href=\"https://rust-lang.github.io/chalk/book/canonical_queries.html\">https://rust-lang.github.io/chalk/book/canonical_queries.html</a> ?</p>",
        "id": 273922892,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646283535
    },
    {
        "content": "<p>I think so</p>",
        "id": 273923423,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646283847
    },
    {
        "content": "<p>hmhmhm I don't get it</p>",
        "id": 273924207,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646284662
    },
    {
        "content": "<p>as I understand it from the docs here:  <a href=\"https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/solve.rs#L12\">https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/solve.rs#L12</a></p>",
        "id": 273924307,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646284759
    },
    {
        "content": "<p><code>Unique(substs)</code> =&gt; Proven, always holds. You can substitute any value in <code>substs</code> and it'll work. <br>\n<code>Ambig(Definite(substs))</code> =&gt; Not proven, may or may not hold. However, <code>substs</code> is a logic consequence of the goal, it's guaranteed that all solutions (if any) satisfy <code>substs</code>.<br>\n<code>Ambig(Suggested(substs))</code> =&gt; Not proven, may or may not hold. <code>substs</code> is just heuristic guidance, there might be solutions either satisfying <code>substs</code> or not.</p>",
        "id": 273924652,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646285047
    },
    {
        "content": "<p>so returning <code>Suggested</code> instead of <code>Definite</code> is still correct, it's just \"less useful\"...?</p>",
        "id": 273924697,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646285091
    },
    {
        "content": "<p>ugh rustc does treat <code>Ambig(Definite(_))</code> as <code>Proven</code> <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_traits/src/chalk/mod.rs#L136\">here</a>.</p>\n<p>I feel like there's something super basic that I'm not understanding, not sure what. Enlightenment would be appreciated <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span></p>",
        "id": 273925556,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646285790
    },
    {
        "content": "<p><code>Unique</code> is basically \"there is one solution and this is it\", <code>Definite</code> is \"there are many solutions to your query, but these substs are a generalization of them all\", <code>Suggestion</code> is \"we didn't find a solution, but these substs might get you closer</p>",
        "id": 273975703,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646315874
    },
    {
        "content": "<p>Looking at the recursive code bit you linked, maybe that should be <code>Definite</code></p>",
        "id": 273975780,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646315895
    }
]