[
    {
        "content": "<p>so I have some questions about const generics</p>",
        "id": 193715251,
        "sender_full_name": "Areredify",
        "timestamp": 1586701493
    },
    {
        "content": "<p>a) does the structural match property mean that the type of a constant never has a type variable in it?</p>",
        "id": 193715375,
        "sender_full_name": "Areredify",
        "timestamp": 1586701694
    },
    {
        "content": "<p>b) can types of constants meaningfully partake in type inference? if they can, should they?</p>",
        "id": 193715593,
        "sender_full_name": "Areredify",
        "timestamp": 1586702131
    },
    {
        "content": "<p>/me summons <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 193715594,
        "sender_full_name": "Areredify",
        "timestamp": 1586702154
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> for the time being, const generic types will have to be fully known</p>",
        "id": 193715757,
        "sender_full_name": "eddyb",
        "timestamp": 1586702463
    },
    {
        "content": "<p>lifetime parameters used in those types <em>might</em> be easy to support</p>",
        "id": 193715762,
        "sender_full_name": "eddyb",
        "timestamp": 1586702500
    },
    {
        "content": "<p>type parameters used in const parameter types would require some trait to bound them IMO</p>",
        "id": 193715808,
        "sender_full_name": "eddyb",
        "timestamp": 1586702557
    },
    {
        "content": "<p>but also, we don't handle inference variables in those types well so it would likely break in weird ways</p>",
        "id": 193715813,
        "sender_full_name": "eddyb",
        "timestamp": 1586702585
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> do you have an usecase in mind?</p>",
        "id": 193715814,
        "sender_full_name": "eddyb",
        "timestamp": 1586702596
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"121053\">@varkor</span> <span class=\"user-mention\" data-user-id=\"218608\">@yodal</span></p>",
        "id": 193715819,
        "sender_full_name": "eddyb",
        "timestamp": 1586702613
    },
    {
        "content": "<p>Not really, I was just wondering if const types have inference variables (and/or type variables) in them while deducting types</p>",
        "id": 193715891,
        "sender_full_name": "Areredify",
        "timestamp": 1586702693
    },
    {
        "content": "<p>or wait I just realized that this stream is wg-traits oops</p>",
        "id": 193715898,
        "sender_full_name": "eddyb",
        "timestamp": 1586702710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> fully concrete although I'm not sure about normalization</p>",
        "id": 193715908,
        "sender_full_name": "eddyb",
        "timestamp": 1586702739
    },
    {
        "content": "<p>like <code>const NAME: &amp;'static &lt;Box&lt;str&gt; as Deref&gt;::Target</code></p>",
        "id": 193715956,
        "sender_full_name": "eddyb",
        "timestamp": 1586702765
    },
    {
        "content": "<p>I think that sort of works right now but I'm not sure</p>",
        "id": 193715960,
        "sender_full_name": "eddyb",
        "timestamp": 1586702776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@Bastian Kauschke</span> ^^ do we have tests like that?</p>",
        "id": 193715993,
        "sender_full_name": "eddyb",
        "timestamp": 1586702801
    },
    {
        "content": "<p>with <code>&lt;... as Trait&gt;::Assoc</code> in the type of a <code>const</code> generic</p>",
        "id": 193715997,
        "sender_full_name": "eddyb",
        "timestamp": 1586702814
    },
    {
        "content": "<p>I doubt it</p>",
        "id": 193716047,
        "sender_full_name": "lcnr",
        "timestamp": 1586702908
    },
    {
        "content": "<p>Haven't had to look at all tests yet though</p>",
        "id": 193716055,
        "sender_full_name": "lcnr",
        "timestamp": 1586702926
    },
    {
        "content": "<p>heh</p>",
        "id": 193716057,
        "sender_full_name": "eddyb",
        "timestamp": 1586702931
    },
    {
        "content": "<p>My main question is more like \"can unifying consts deduct something\" or we just deduct all const types beforehand</p>",
        "id": 193716134,
        "sender_full_name": "Areredify",
        "timestamp": 1586703119
    },
    {
        "content": "<p>unifying consts can deduct something from unevaluated consts</p>",
        "id": 193716199,
        "sender_full_name": "eddyb",
        "timestamp": 1586703222
    },
    {
        "content": "<p>although idk if they should unify. it's like projections</p>",
        "id": 193716204,
        "sender_full_name": "eddyb",
        "timestamp": 1586703233
    },
    {
        "content": "<p>but the const types are concrete for now anyway</p>",
        "id": 193716268,
        "sender_full_name": "eddyb",
        "timestamp": 1586703282
    },
    {
        "content": "<p>Is that why </p>\n<div class=\"codehilite\"><pre><span></span>trait Tr1 { const N: u32; }\ntrait Tr2 { const N: f32; }\n\nstruct S {}\n\nimpl Tr1 for S { const N: u32 = 0; }\nimpl Tr2 for S { const N: f32 = 0.0; }\n\nfn f() -&gt; u32 {\n   S::N\n}\n</pre></div>\n\n\n<p>is not working?</p>",
        "id": 193716494,
        "sender_full_name": "Areredify",
        "timestamp": 1586703664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> by the way thanks for blessing us with synstructure, it's awesome</p>",
        "id": 193716551,
        "sender_full_name": "Areredify",
        "timestamp": 1586703734
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> that code has 0 const generics</p>",
        "id": 193716569,
        "sender_full_name": "eddyb",
        "timestamp": 1586703781
    },
    {
        "content": "<p>associated consts are as simple as associated fn's (or even simpler) :P</p>",
        "id": 193716576,
        "sender_full_name": "eddyb",
        "timestamp": 1586703800
    },
    {
        "content": "<p>also, lol, <code>synstructure</code> is just I've heard everyone was using for the past year or two or however long it's been</p>",
        "id": 193716585,
        "sender_full_name": "eddyb",
        "timestamp": 1586703826
    },
    {
        "content": "<p>Yeah, but (presumably) it's not working because you can't use an inference variable as a type for S::N when deducting types</p>",
        "id": 193716626,
        "sender_full_name": "Areredify",
        "timestamp": 1586703850
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> no, it's because we don't have trait inference variables :P</p>",
        "id": 193716675,
        "sender_full_name": "eddyb",
        "timestamp": 1586703932
    },
    {
        "content": "<p>it should work if you use a type parameter for the associated const's type</p>",
        "id": 193716690,
        "sender_full_name": "eddyb",
        "timestamp": 1586703958
    },
    {
        "content": "<p>this works fine, yeah:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"nc\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">u32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Tr</span><span class=\"o\">&lt;</span><span class=\"kt\">f32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">f32</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mf\">0.0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">S</span>::<span class=\"n\">N</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 193716746,
        "sender_full_name": "eddyb",
        "timestamp": 1586704004
    },
    {
        "content": "<p>Hmm, I need to generate a more contrived example</p>",
        "id": 193716938,
        "sender_full_name": "Areredify",
        "timestamp": 1586704326
    },
    {
        "content": "<p>but again this has nothing to do with constants in types</p>",
        "id": 193716948,
        "sender_full_name": "eddyb",
        "timestamp": 1586704386
    },
    {
        "content": "<p>but it has to do with types in constants</p>",
        "id": 193716955,
        "sender_full_name": "Areredify",
        "timestamp": 1586704411
    },
    {
        "content": "<p>yeah but not in <em>the typesystem</em></p>",
        "id": 193716961,
        "sender_full_name": "eddyb",
        "timestamp": 1586704431
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> <code>S::N</code> is inferred to be <code>&lt;S as Tr&lt;u32&gt;&gt;::N</code> but the <code>Tr::N</code> part of that would never reach Chalk</p>",
        "id": 193717092,
        "sender_full_name": "eddyb",
        "timestamp": 1586704584
    },
    {
        "content": "<p>it'd just end up in MIR</p>",
        "id": 193717099,
        "sender_full_name": "eddyb",
        "timestamp": 1586704610
    },
    {
        "content": "<p>you can't unify consts unless you put them inside types</p>",
        "id": 193717106,
        "sender_full_name": "eddyb",
        "timestamp": 1586704630
    },
    {
        "content": "<p>Ok, I think I conjured a brittle image of what's happening in my mind, thanks</p>",
        "id": 193717168,
        "sender_full_name": "Areredify",
        "timestamp": 1586704796
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> there is one detail that may be confusing: <code>ty::Const</code> in rustc is used for both type-level constants and MIR constants</p>",
        "id": 193717222,
        "sender_full_name": "eddyb",
        "timestamp": 1586704836
    },
    {
        "content": "<p>I use it for both too, so I don't mind :)</p>",
        "id": 193717229,
        "sender_full_name": "Areredify",
        "timestamp": 1586704866
    },
    {
        "content": "<p>so you can have a <code>ty::Const</code> with a polymorphic type or even a type with inference variables in it</p>",
        "id": 193717230,
        "sender_full_name": "eddyb",
        "timestamp": 1586704867
    },
    {
        "content": "<p>but it's never unified with any other constant</p>",
        "id": 193717235,
        "sender_full_name": "eddyb",
        "timestamp": 1586704894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> okay now I am intrigued, is this about consts in Chalk or something else?</p>",
        "id": 193717241,
        "sender_full_name": "eddyb",
        "timestamp": 1586704910
    },
    {
        "content": "<p>since AFAIK Chalk doesn't know about MIR</p>",
        "id": 193717242,
        "sender_full_name": "eddyb",
        "timestamp": 1586704919
    },
    {
        "content": "<p>No I mean I use it for both associated consts and const params</p>",
        "id": 193717288,
        "sender_full_name": "Areredify",
        "timestamp": 1586704969
    },
    {
        "content": "<p>Not ty::Const of course, my const</p>",
        "id": 193717299,
        "sender_full_name": "Areredify",
        "timestamp": 1586704989
    },
    {
        "content": "<p>you mean it represents both?</p>",
        "id": 193717302,
        "sender_full_name": "eddyb",
        "timestamp": 1586704994
    },
    {
        "content": "<p>Yeah</p>",
        "id": 193717303,
        "sender_full_name": "Areredify",
        "timestamp": 1586705001
    },
    {
        "content": "<p>I'm talking about where <em>it's used</em></p>",
        "id": 193717306,
        "sender_full_name": "eddyb",
        "timestamp": 1586705005
    },
    {
        "content": "<p>i.e. as a generic argument to an user-defined type or as an array length</p>",
        "id": 193717307,
        "sender_full_name": "eddyb",
        "timestamp": 1586705027
    },
    {
        "content": "<p>i.e. if you write <code>Foo&lt;{S::N}&gt;</code> that's suddenly in the typesystem</p>",
        "id": 193717350,
        "sender_full_name": "eddyb",
        "timestamp": 1586705068
    },
    {
        "content": "<p>more specifically it's <code>Foo&lt;main::{constant#0}: u32&gt;</code> assuming <code>struct Foo&lt;const X: u32&gt;;</code></p>",
        "id": 193717389,
        "sender_full_name": "eddyb",
        "timestamp": 1586705128
    },
    {
        "content": "<p>and the MIR body of <code>main::{constant#0}</code> contains the constant <code>&lt;S as Tr&lt;u32&gt;&gt;::N: u32</code></p>",
        "id": 193717446,
        "sender_full_name": "eddyb",
        "timestamp": 1586705183
    },
    {
        "content": "<p>I guess <code>S::N</code> is still not in the typesystem itself</p>",
        "id": 193717450,
        "sender_full_name": "eddyb",
        "timestamp": 1586705219
    },
    {
        "content": "<p>and normalization would produce <code>Foo&lt;0: u32&gt;</code></p>",
        "id": 193717458,
        "sender_full_name": "eddyb",
        "timestamp": 1586705242
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> but without a <code>const</code> generic parameter to <em>pass</em> a constant to, you can't have constants in the typesystem</p>",
        "id": 193717506,
        "sender_full_name": "eddyb",
        "timestamp": 1586705284
    },
    {
        "content": "<p>Yeah, but chalk operates both, right?</p>",
        "id": 193717529,
        "sender_full_name": "Areredify",
        "timestamp": 1586705385
    },
    {
        "content": "<p>what do you mean?</p>",
        "id": 193717532,
        "sender_full_name": "eddyb",
        "timestamp": 1586705393
    },
    {
        "content": "<p>Maybe I don't understand the distinction you are making</p>",
        "id": 193717578,
        "sender_full_name": "Areredify",
        "timestamp": 1586705445
    },
    {
        "content": "<p>Chalk would see <code>main::{constant#0}: u32</code> and <code>0: u32</code></p>",
        "id": 193717582,
        "sender_full_name": "eddyb",
        "timestamp": 1586705453
    },
    {
        "content": "<p><code>S::N</code> aka <code>&lt;S as Tr&lt;u32&gt;&gt;::N</code> is <em>only</em> in a MIR body that Chalk can't see</p>",
        "id": 193717588,
        "sender_full_name": "eddyb",
        "timestamp": 1586705490
    },
    {
        "content": "<p>Ooooh</p>",
        "id": 193717593,
        "sender_full_name": "Areredify",
        "timestamp": 1586705515
    },
    {
        "content": "<p>I don't think rustc puts non-<code>AnonConst</code> <code>DefId</code>s into <code>ty::ConstKind::Unevaluated</code></p>",
        "id": 193717640,
        "sender_full_name": "eddyb",
        "timestamp": 1586705559
    },
    {
        "content": "<p>we <em>could</em> refer to the assoc const directly but only after inferring all of the generic args to the path</p>",
        "id": 193717650,
        "sender_full_name": "eddyb",
        "timestamp": 1586705587
    },
    {
        "content": "<p>And then if needed, mir would callback to chalk to get the value for S::N (if it was a more complicated projection)?</p>",
        "id": 193717651,
        "sender_full_name": "Areredify",
        "timestamp": 1586705592
    },
    {
        "content": "<p>nope</p>",
        "id": 193717653,
        "sender_full_name": "eddyb",
        "timestamp": 1586705599
    },
    {
        "content": "<p>miri would at most use Chalk to find which <code>const N</code> defines the value</p>",
        "id": 193717661,
        "sender_full_name": "eddyb",
        "timestamp": 1586705629
    },
    {
        "content": "<p>Chalk itself wouldn't see it as a constant</p>",
        "id": 193717699,
        "sender_full_name": "eddyb",
        "timestamp": 1586705646
    },
    {
        "content": "<p>it's the same as if miri wanted to call a method</p>",
        "id": 193717702,
        "sender_full_name": "eddyb",
        "timestamp": 1586705653
    },
    {
        "content": "<p>So if it was <code>&lt;S as Trait&lt;S2::T&gt;&gt;::N</code> it wouldn't make a chalk query?</p>",
        "id": 193717778,
        "sender_full_name": "Areredify",
        "timestamp": 1586705772
    },
    {
        "content": "<p>I mean, it would pass the <code>&lt;S as Trait&lt;S2::T&gt;&gt;</code> part to Chalk to find an <code>impl</code> that applies</p>",
        "id": 193717787,
        "sender_full_name": "eddyb",
        "timestamp": 1586705803
    },
    {
        "content": "<p>idk how much of the specialization graph Chalk handles</p>",
        "id": 193717792,
        "sender_full_name": "eddyb",
        "timestamp": 1586705813
    },
    {
        "content": "<p>Yeah, that's what I meant by \"a more complicated projection\"</p>",
        "id": 193717793,
        "sender_full_name": "Areredify",
        "timestamp": 1586705818
    },
    {
        "content": "<p>but Chalk wouldn't be seeing the <code>N</code> associated constant like a type-level constant</p>",
        "id": 193717805,
        "sender_full_name": "eddyb",
        "timestamp": 1586705845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> I think it's better to imagine that Rust has this syntax: <code>const FOO&lt;A, B, C&gt;: ... = ...;</code></p>",
        "id": 193717816,
        "sender_full_name": "eddyb",
        "timestamp": 1586705874
    },
    {
        "content": "<p>i.e. generic top-level <code>const</code> items</p>",
        "id": 193717856,
        "sender_full_name": "eddyb",
        "timestamp": 1586705883
    },
    {
        "content": "<p>and ignoring associated consts as a weird special-case of that</p>",
        "id": 193717883,
        "sender_full_name": "eddyb",
        "timestamp": 1586705973
    },
    {
        "content": "<p>even adding that syntax to Chalk's testing framework would be good IMO</p>",
        "id": 193717931,
        "sender_full_name": "eddyb",
        "timestamp": 1586706007
    },
    {
        "content": "<p>minus the <code>= ...</code> part</p>",
        "id": 193717934,
        "sender_full_name": "eddyb",
        "timestamp": 1586706020
    },
    {
        "content": "<p>Ooh, so for chalk there is no associated consts at all</p>",
        "id": 193717949,
        "sender_full_name": "Areredify",
        "timestamp": 1586706086
    },
    {
        "content": "<p>not to the extent that Chalk knows about associated <em>types</em>, no</p>",
        "id": 193717954,
        "sender_full_name": "eddyb",
        "timestamp": 1586706110
    },
    {
        "content": "<p>Ok, thanks a lot, my understanding has grown immensely</p>",
        "id": 193718434,
        "sender_full_name": "Areredify",
        "timestamp": 1586706862
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119009\">eddyb</span> <a href=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/193717816\" title=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/193717816\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"251766\">Areredify</span> I think it's better to imagine that Rust has this syntax: <code>const FOO&lt;A, B, C&gt;: ... = ...;</code></p>\n</blockquote>\n<p>I imagine this would be mostly (or entirely) the same as type aliases, from chalk's point of view</p>",
        "id": 193721870,
        "sender_full_name": "detrumi",
        "timestamp": 1586712486
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> right, except Chalk can't know about the \"RHS\" of the alias</p>",
        "id": 193736283,
        "sender_full_name": "eddyb",
        "timestamp": 1586736245
    },
    {
        "content": "<p>since this is basically the \"callback\" (or really, primitive operation) <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> was talking about, where miri evaluates the MIR body of that \"const alias\"</p>",
        "id": 193736287,
        "sender_full_name": "eddyb",
        "timestamp": 1586736285
    },
    {
        "content": "<p>Is it true that chalk does not care about types of constants because we always get a well-formed program as input?</p>",
        "id": 193770323,
        "sender_full_name": "Areredify",
        "timestamp": 1586783441
    },
    {
        "content": "<p>hmmm</p>",
        "id": 193781278,
        "sender_full_name": "eddyb",
        "timestamp": 1586790597
    },
    {
        "content": "<p>depends on what \"does not care\" means</p>",
        "id": 193781340,
        "sender_full_name": "eddyb",
        "timestamp": 1586790611
    },
    {
        "content": "<p>I think you can just require in unification of constants that the types are exactly equal and maybe in WF of constants you'd check that their type is fully concrete or something</p>",
        "id": 193781422,
        "sender_full_name": "eddyb",
        "timestamp": 1586790666
    },
    {
        "content": "<p>Yeah, but I thought a lot and I could not come up with an example where we need const types for anything</p>",
        "id": 193781583,
        "sender_full_name": "Areredify",
        "timestamp": 1586790760
    },
    {
        "content": "<p>If all type constructor applications are well formed</p>",
        "id": 193781688,
        "sender_full_name": "Areredify",
        "timestamp": 1586790830
    },
    {
        "content": "<p>And from I understand, rustc guarantees them to be</p>",
        "id": 193781790,
        "sender_full_name": "Areredify",
        "timestamp": 1586790876
    },
    {
        "content": "<p>that I don't know about</p>",
        "id": 193801111,
        "sender_full_name": "eddyb",
        "timestamp": 1586801070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> would know better</p>",
        "id": 193801130,
        "sender_full_name": "eddyb",
        "timestamp": 1586801082
    },
    {
        "content": "<p>but yeah I suppose you can get away without the type and just reason about parameters and const applications</p>",
        "id": 193801255,
        "sender_full_name": "eddyb",
        "timestamp": 1586801158
    },
    {
        "content": "<p>Hmm, I have encountered an interesting problem. So I have <code>I::ConstEvaluated</code> as a type that holds (who would've thought) evaluated constants. My approach was to make a function <code>interner.const_eq(c1, c2)</code> that checks if <code>c1 == c2</code></p>",
        "id": 193802363,
        "sender_full_name": "Areredify",
        "timestamp": 1586801732
    },
    {
        "content": "<p>So the problem is that I don't know how to fold <code>ConstEvaluated</code></p>",
        "id": 193802492,
        "sender_full_name": "Areredify",
        "timestamp": 1586801805
    },
    {
        "content": "<p>Oh wait</p>",
        "id": 193803044,
        "sender_full_name": "Areredify",
        "timestamp": 1586802099
    },
    {
        "content": "<p>This is what TargetInterner is for</p>",
        "id": 193803065,
        "sender_full_name": "Areredify",
        "timestamp": 1586802111
    },
    {
        "content": "<p>Pretend I said nothing</p>",
        "id": 193803128,
        "sender_full_name": "Areredify",
        "timestamp": 1586802128
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> you shouldn't need to, you can treat it as an opaque value that's equal if and only if <code>==</code> returns <code>true</code></p>",
        "id": 193808779,
        "sender_full_name": "eddyb",
        "timestamp": 1586805077
    },
    {
        "content": "<p>i.e. no substructure, just a leaf</p>",
        "id": 193808825,
        "sender_full_name": "eddyb",
        "timestamp": 1586805102
    },
    {
        "content": "<p>although I would call it <code>ConcreteConst</code> or <code>ConstValue</code> <em>shrug</em></p>",
        "id": 193808870,
        "sender_full_name": "eddyb",
        "timestamp": 1586805122
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> do you have a \"WIP\" branch here?</p>",
        "id": 193815229,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586808507
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> made a draft pr</p>",
        "id": 193815854,
        "sender_full_name": "Areredify",
        "timestamp": 1586808833
    },
    {
        "content": "<p>I presumably added all the necessary parts, but I don't have way to test it because parser, so Im doing that at the moment</p>",
        "id": 193816065,
        "sender_full_name": "Areredify",
        "timestamp": 1586808944
    },
    {
        "content": "<p>presumably the testing part will have just integers?</p>",
        "id": 193822684,
        "sender_full_name": "eddyb",
        "timestamp": 1586812711
    },
    {
        "content": "<p>Yeah, I use u32 atm</p>",
        "id": 193822750,
        "sender_full_name": "Areredify",
        "timestamp": 1586812750
    },
    {
        "content": "<p>may I suggest <code>u128</code> :P</p>",
        "id": 193834982,
        "sender_full_name": "eddyb",
        "timestamp": 1586820705
    },
    {
        "content": "<p><code>exists&lt;#N&gt; { Foo&lt;#N&gt; = Foo&lt;42&gt; }</code> works <span aria-label=\"party ball\" class=\"emoji emoji-1f38a\" role=\"img\" title=\"party ball\">:party_ball:</span></p>",
        "id": 193837944,
        "sender_full_name": "Areredify",
        "timestamp": 1586823296
    },
    {
        "content": "<p>don't ask about the syntax</p>",
        "id": 193837973,
        "sender_full_name": "Areredify",
        "timestamp": 1586823328
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>program {\n    struct Foo&lt;#N&gt; {}\n\n    trait Trait&lt;#M&gt; {}\n\n    impl&lt;#M&gt; Trait&lt;#M&gt; for Foo&lt;#M&gt; { }\n}\n\ngoal {\n    exists&lt;#N&gt; {\n        Foo&lt;#N&gt;: Trait&lt;45&gt;\n    }\n} yields {\n    &quot;Unique; substitution [?0 := 45], lifetime constraints []&quot;\n}\n</pre></div>\n\n\n<p>works too</p>",
        "id": 193838464,
        "sender_full_name": "Areredify",
        "timestamp": 1586823778
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> do you have a special syntax symbol for consts by any chance?</p>",
        "id": 193838976,
        "sender_full_name": "Areredify",
        "timestamp": 1586824256
    },
    {
        "content": "<p>uhhhhh</p>",
        "id": 193839008,
        "sender_full_name": "eddyb",
        "timestamp": 1586824292
    },
    {
        "content": "<p>Like <code>'</code> for lifetimes</p>",
        "id": 193839017,
        "sender_full_name": "Areredify",
        "timestamp": 1586824299
    },
    {
        "content": "<p><code>struct Foo&lt;const N&gt;</code></p>",
        "id": 193839020,
        "sender_full_name": "eddyb",
        "timestamp": 1586824306
    },
    {
        "content": "<p>but not at use sites</p>",
        "id": 193839028,
        "sender_full_name": "eddyb",
        "timestamp": 1586824319
    },
    {
        "content": "<p>I mean in debug output, not in code :P</p>",
        "id": 193839272,
        "sender_full_name": "Areredify",
        "timestamp": 1586824523
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> print it <code>{N}</code> I guess</p>",
        "id": 193839392,
        "sender_full_name": "eddyb",
        "timestamp": 1586824641
    },
    {
        "content": "<p>that's valid in actual Rust</p>",
        "id": 193839405,
        "sender_full_name": "eddyb",
        "timestamp": 1586824652
    },
    {
        "content": "<p>most verbose that is still valid syntax would be</p>\n<ul>\n<li>defs: <code>const N: usize</code></li>\n<li>uses: <code>{N: usize}</code></li>\n</ul>",
        "id": 193839470,
        "sender_full_name": "eddyb",
        "timestamp": 1586824685
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> where can I steal const generics tests?</p>",
        "id": 193839833,
        "sender_full_name": "Areredify",
        "timestamp": 1586825034
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> presumably <code>src/test/ui/const-generics</code> :P</p>",
        "id": 193839904,
        "sender_full_name": "eddyb",
        "timestamp": 1586825093
    },
    {
        "content": "<p>So presumably the const branch is working, I haven't done extensive testing but it works so far <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 193875182,
        "sender_full_name": "Areredify",
        "timestamp": 1586858866
    },
    {
        "content": "<p>even gats work</p>",
        "id": 193875246,
        "sender_full_name": "Areredify",
        "timestamp": 1586858887
    },
    {
        "content": "<p>the code for lifetimes and types is duplicated in a lot of places, and with consts it is now triplicated</p>",
        "id": 193875513,
        "sender_full_name": "Areredify",
        "timestamp": 1586859033
    },
    {
        "content": "<p>great! I did expect this to be fairly straightforward. Re: code dup, it'd be nice to see what we can do to reduce that, I agree.</p>",
        "id": 193875581,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859075
    },
    {
        "content": "<p>If you want to play with it, note that syntax for consts in types and applications is <code>$N</code>, I haven't implemented name resolution yet</p>",
        "id": 193875963,
        "sender_full_name": "Areredify",
        "timestamp": 1586859312
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> I left some comments on the PR</p>",
        "id": 194364479,
        "sender_full_name": "detrumi",
        "timestamp": 1587069607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> btw I plan to leave some feedback on this pr and your other one today, I've been pushing them off slightly to get a few other \"long standing\" items merged</p>",
        "id": 194420637,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587119072
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> at long last I'm taking a look at your PR!</p>",
        "id": 195474828,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588021452
    },
    {
        "content": "<p>Sorry it stalled so long</p>",
        "id": 195474836,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588021457
    },
    {
        "content": "<p>OK, so, I skimmed the code, and it all looked basically correct to me, <span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span></p>",
        "id": 195479203,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588023936
    },
    {
        "content": "<p>Obviously it needs more tests</p>",
        "id": 195479217,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588023943
    },
    {
        "content": "<p>Do you have some idea what tests to add?</p>",
        "id": 195479226,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588023948
    },
    {
        "content": "<p>Would it be helpful for me to try and make a list?</p>",
        "id": 195479234,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588023954
    },
    {
        "content": "<p>Yes please, that would be very helpful</p>",
        "id": 195479422,
        "sender_full_name": "Areredify",
        "timestamp": 1588024047
    },
    {
        "content": "<p>Also concerning const types: I am still on the fence about it, if we don't have any clauses (besides const equality) about constants and all constants only appear in type expressions, we don't really need types of those consts, do we?</p>",
        "id": 195480237,
        "sender_full_name": "Areredify",
        "timestamp": 1588024546
    },
    {
        "content": "<p>If everything passed from rustc to chalk is well-formed, I can't think of a place where we need const types</p>",
        "id": 195480670,
        "sender_full_name": "Areredify",
        "timestamp": 1588024838
    },
    {
        "content": "<p>it's fine in this PR to remove</p>",
        "id": 195480801,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588024946
    },
    {
        "content": "<p>as we move towards reconciling the types that chalk and rustc use</p>",
        "id": 195480808,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588024952
    },
    {
        "content": "<p>we may find we want it</p>",
        "id": 195480809,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588024954
    },
    {
        "content": "<p>I have a branch with const types, <code>Binders&lt;T, I&gt;</code> is <span aria-label=\"crying cat\" class=\"emoji emoji-1f63f\" role=\"img\" title=\"crying cat\">:crying_cat:</span></p>",
        "id": 195481307,
        "sender_full_name": "Areredify",
        "timestamp": 1588025318
    },
    {
        "content": "<p>Oh, <code>T</code> is <code>HasInterner</code> now anyways</p>",
        "id": 195481337,
        "sender_full_name": "Areredify",
        "timestamp": 1588025341
    },
    {
        "content": "<p>Then it won't be too bad if we add it</p>",
        "id": 195481375,
        "sender_full_name": "Areredify",
        "timestamp": 1588025377
    },
    {
        "content": "<p>I would definitely not want to have <code>Binders&lt;T, I&gt;</code></p>",
        "id": 195481933,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588025751
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  Also, is it ok to leave consts to be declared and used as <code>$N</code> or should I implement name resolution? On one hand, we should of course match Rust syntax, on the other I like the <code>$</code> more and (for me) it improves readability in tests</p>",
        "id": 195564114,
        "sender_full_name": "Areredify",
        "timestamp": 1588080714
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> I'm not sure I totally follow</p>",
        "id": 195615347,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588102802
    },
    {
        "content": "<p>I guess that rust syntax is something like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 195615415,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588102828
    },
    {
        "content": "<p>and the point is that we have to accommodate the case that <code>N</code> might be a const and might not?</p>",
        "id": 195615430,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588102838
    },
    {
        "content": "<p>Yeah</p>",
        "id": 195615726,
        "sender_full_name": "Areredify",
        "timestamp": 1588102979
    },
    {
        "content": "<p>I guess I think we should match Rust syntax, I don't think it would be too hard to get the name resolution right</p>",
        "id": 195616007,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588103101
    },
    {
        "content": "<p>but I'd be ok to do it in a follow-up</p>",
        "id": 195616023,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588103105
    },
    {
        "content": "<p>eh, I'll have to write tests anyway, so it's not big deal to add while Im at it</p>",
        "id": 195616097,
        "sender_full_name": "Areredify",
        "timestamp": 1588103142
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> started working on a <a href=\"https://hackmd.io/Ah_J6nFQSbuUiVOsH5acLg\" title=\"https://hackmd.io/Ah_J6nFQSbuUiVOsH5acLg\">list of test cases</a> but didn't get <em>that</em> far yet</p>",
        "id": 195618420,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588104079
    },
    {
        "content": "<p>OK, I guess that'll do for now for tests</p>",
        "id": 195627406,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108183
    },
    {
        "content": "<p>er, I didn't think about associated constants</p>",
        "id": 195627471,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108206
    },
    {
        "content": "<p>wait, we probably didn't add support for that</p>",
        "id": 195627516,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108235
    },
    {
        "content": "<p>just GATs?</p>",
        "id": 195627520,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108236
    },
    {
        "content": "<p>that is actually a \"to do\" item we should include at some point</p>",
        "id": 195627536,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108246
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/195627520\" title=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/195627520\">said</a>:</p>\n<blockquote>\n<p>just GATs?</p>\n</blockquote>\n<p>this presumably just kind of \"falls out\"</p>",
        "id": 195627577,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108270
    },
    {
        "content": "<p>@eddyb said that we don't need them in chalk for anything really</p>",
        "id": 195627618,
        "sender_full_name": "Areredify",
        "timestamp": 1588108294
    },
    {
        "content": "<p>so I didn't bother adding them</p>",
        "id": 195627652,
        "sender_full_name": "Areredify",
        "timestamp": 1588108314
    },
    {
        "content": "<p>should I do that?</p>",
        "id": 195627661,
        "sender_full_name": "Areredify",
        "timestamp": 1588108319
    },
    {
        "content": "<p>/me thinks</p>",
        "id": 195627662,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108320
    },
    {
        "content": "<p>That doesn't seem true to me :)</p>",
        "id": 195627741,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108345
    },
    {
        "content": "<p>like, if you have associated constants, it seems like chalk would have to resolve them</p>",
        "id": 195627756,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108358
    },
    {
        "content": "<p>I think we should add them, yes</p>",
        "id": 195627790,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108379
    },
    {
        "content": "<p>but not in this PR</p>",
        "id": 195627799,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108382
    },
    {
        "content": "<p><a href=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/193717588\" title=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/193717588\">https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/const.20generics/near/193717588</a></p>",
        "id": 195627828,
        "sender_full_name": "Areredify",
        "timestamp": 1588108401
    },
    {
        "content": "<p>yeah but</p>",
        "id": 195627924,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108444
    },
    {
        "content": "<p>somebody has to map that to an impl</p>",
        "id": 195627941,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108461
    },
    {
        "content": "<p>and that should obviously be chalk</p>",
        "id": 195627943,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108464
    },
    {
        "content": "<p>so at some point, there's going to be a 'normalization' operation on that</p>",
        "id": 195627968,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108481
    },
    {
        "content": "<p>it's true that we probably don't need it to start</p>",
        "id": 195627978,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108486
    },
    {
        "content": "<p>(and it maybe makes some sense to wait until the picture is a bit more complete)</p>",
        "id": 195628023,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108516
    },
    {
        "content": "<p>but I think that it's kind of clear what it will look like for chalk</p>",
        "id": 195628039,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108524
    },
    {
        "content": "<p>there will be some <code>Normalize(&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::CONSTANT -&gt; Value)</code> rules</p>",
        "id": 195628082,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108545
    },
    {
        "content": "<p>added, from an impl, for each associated const</p>",
        "id": 195628102,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108557
    },
    {
        "content": "<p>Eddyb said that to resolve &lt;S as Trait&gt;::N mir will callback to typeck with &lt;S as Trait&gt;, get the type, and then mir will get the associated const from the type by itself</p>",
        "id": 195628180,
        "sender_full_name": "Areredify",
        "timestamp": 1588108589
    },
    {
        "content": "<p>But I guess your setup makes more sense</p>",
        "id": 195628214,
        "sender_full_name": "Areredify",
        "timestamp": 1588108613
    },
    {
        "content": "<p>that's not correct</p>",
        "id": 195628276,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108654
    },
    {
        "content": "<p>it does map to the older trait solver</p>",
        "id": 195628285,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108662
    },
    {
        "content": "<p>Doesn't seem very \"lazy normalized\" without it</p>",
        "id": 195628290,
        "sender_full_name": "Areredify",
        "timestamp": 1588108665
    },
    {
        "content": "<p>in particular, in that trait solver, you can ask things like \"&lt;S as Trait&gt;\" and it gives you an impl</p>",
        "id": 195628310,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108675
    },
    {
        "content": "<p>but in chalk, that's not how it works, and I'd rather keep it that way</p>",
        "id": 195628368,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108685
    },
    {
        "content": "<p>(so we'd need to add a goal that the impl lets you prove, like <code>Normalize</code>)</p>",
        "id": 195628392,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588108704
    },
    {
        "content": "<p>Should I add const types as a follow-up or in current pr?</p>",
        "id": 195628634,
        "sender_full_name": "Areredify",
        "timestamp": 1588108838
    },
    {
        "content": "<p>Either works for me</p>",
        "id": 195629445,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109257
    },
    {
        "content": "<p>I guess might as well do it now</p>",
        "id": 195629461,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588109264
    },
    {
        "content": "<p>A side question: do fully instantiated types have a \"normal form\" (I really want to know if  <code>==</code>'ing types of consts is possible)</p>",
        "id": 195630780,
        "sender_full_name": "Areredify",
        "timestamp": 1588110029
    },
    {
        "content": "<p>not really</p>",
        "id": 195630838,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110051
    },
    {
        "content": "<p>or at least not a trivial one</p>",
        "id": 195630847,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110058
    },
    {
        "content": "<p>this falls out from <code>fn(&amp;u32, &amp;u32)</code> and <code>for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)</code> being equivalent</p>",
        "id": 195630866,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588110072
    },
    {
        "content": "<p>I should probably read stacked borrows first to think properly about this</p>",
        "id": 195631898,
        "sender_full_name": "Areredify",
        "timestamp": 1588110630
    },
    {
        "content": "<p>I'm not sure that's required</p>",
        "id": 195633630,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588111432
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> am I correct in that in chalk we assume all consts to have infinite values of their type?</p>",
        "id": 195738701,
        "sender_full_name": "Areredify",
        "timestamp": 1588178886
    },
    {
        "content": "<p>I think that's what Î»Prolog does, right?</p>",
        "id": 195738874,
        "sender_full_name": "Areredify",
        "timestamp": 1588178994
    },
    {
        "content": "<p>do you mean like, will we enumerate bool to true/false?</p>",
        "id": 195739242,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588179199
    },
    {
        "content": "<p>if so, you are correct, we do the same for types</p>",
        "id": 195739277,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588179218
    },
    {
        "content": "<p>e.g., with <code>forall&lt;T&gt; { .. }</code>, we don't go trying to enumerate all the types that exist</p>",
        "id": 195739364,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588179251
    },
    {
        "content": "<p>Yeah that's what I meant, with types it's kinda self-evident, with consts less so (for me)</p>",
        "id": 195739413,
        "sender_full_name": "Areredify",
        "timestamp": 1588179278
    },
    {
        "content": "<p>agreed, nonetheless, I would keep that behavior</p>",
        "id": 195739443,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588179295
    },
    {
        "content": "<p>Well, I don't have <code>Binders&lt;T, I&gt;</code> this time, but I do have <code>ParameterKinds&lt;I, T&gt;</code> <span aria-label=\"crying cat\" class=\"emoji emoji-1f63f\" role=\"img\" title=\"crying cat\">:crying_cat:</span></p>",
        "id": 195764719,
        "sender_full_name": "Areredify",
        "timestamp": 1588191640
    },
    {
        "content": "<p>Const types are up, everybody is welcome to leave a review <span aria-label=\"smile\" class=\"emoji emoji-263a\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 195824737,
        "sender_full_name": "Areredify",
        "timestamp": 1588245159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I think zulip is a better fit for our github convo, do you have time to discuss it?</p>",
        "id": 196222433,
        "sender_full_name": "Areredify",
        "timestamp": 1588617661
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> yep, I'd like to see this branch land.</p>",
        "id": 196223084,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588617916
    },
    {
        "content": "<p>Although I think I'm starting to see your point --</p>",
        "id": 196223617,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618095
    },
    {
        "content": "<p>So, I thought about not having const type in parameter kind when implementing, but it is in some sense backwards</p>",
        "id": 196223642,
        "sender_full_name": "Areredify",
        "timestamp": 1588618105
    },
    {
        "content": "<p>hmm</p>",
        "id": 196223748,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618157
    },
    {
        "content": "<p>Each bound var would carry a ty, but the binder variable they are referring to does not, which is... strange</p>",
        "id": 196223751,
        "sender_full_name": "Areredify",
        "timestamp": 1588618158
    },
    {
        "content": "<p>Same for universes and inference vars</p>",
        "id": 196223820,
        "sender_full_name": "Areredify",
        "timestamp": 1588618178
    },
    {
        "content": "<p>I guess the question is whether the \"kind\" of the variable (in the type theory sense) includes the type or not</p>",
        "id": 196223853,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618192
    },
    {
        "content": "<p>is it <code>impl&lt;const C: usize&gt;</code> or <code>impl&lt;const C&gt; where C is a usize</code></p>",
        "id": 196223989,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618238
    },
    {
        "content": "<p>Yes</p>",
        "id": 196224007,
        "sender_full_name": "Areredify",
        "timestamp": 1588618247
    },
    {
        "content": "<p>At first I thought it was a no-brainer (of course it does, duh), but now I am less sure</p>",
        "id": 196224057,
        "sender_full_name": "Areredify",
        "timestamp": 1588618277
    },
    {
        "content": "<p>I'm a bit surprised I never noticed this question in rustc before</p>",
        "id": 196224060,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618278
    },
    {
        "content": "<p>in rustc, when we create inference variables...</p>",
        "id": 196224224,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618350
    },
    {
        "content": "<p>they don't see to carry a type</p>",
        "id": 196224231,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618355
    },
    {
        "content": "<p>I'm not yet sure why it <em>can't</em> be <code>C is a usize</code></p>",
        "id": 196224249,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618367
    },
    {
        "content": "<p>ah well</p>",
        "id": 196224264,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618375
    },
    {
        "content": "<p>I mean, it can</p>",
        "id": 196224272,
        "sender_full_name": "Areredify",
        "timestamp": 1588618378
    },
    {
        "content": "<p>ok, so, I guess that when we instantiate a constant in rustc</p>",
        "id": 196224277,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618380
    },
    {
        "content": "<p>it carries a type but not \"in the inference variable\", so to speak</p>",
        "id": 196224303,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618389
    },
    {
        "content": "<p>I can see why chalk's setup</p>",
        "id": 196224361,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618428
    },
    {
        "content": "<p>which tries to unify the logic across types/lifetimes</p>",
        "id": 196224376,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618433
    },
    {
        "content": "<p>will then run aground here</p>",
        "id": 196224388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618438
    },
    {
        "content": "<p>right, so conceivably</p>",
        "id": 196224520,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618489
    },
    {
        "content": "<p>the \"type\" could move into a combination of a <em>where clause</em> and something attached to the <em>value</em> itself</p>",
        "id": 196224539,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618500
    },
    {
        "content": "<p>i.e., if the value of a constant is some set of bits and needs a type for interpretation, it can be there</p>",
        "id": 196224569,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618526
    },
    {
        "content": "<p>we would need the where-clause to make this an error:</p>",
        "id": 196224623,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618552
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">exists</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"kt\">u32</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">22_</span><span class=\"k\">i32</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 196224678,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618563
    },
    {
        "content": "<p>and really the above would be more like</p>",
        "id": 196224703,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618578
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>exists&lt;const C&gt; { HasType(C: u32), C = 22_i32 }\n</code></pre></div>",
        "id": 196224727,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618588
    },
    {
        "content": "<p>similarly </p>\n<div class=\"codehilite\"><pre><span></span><code>impl&lt;const C: usize&gt; {\n}\n</code></pre></div>\n\n\n<p>is kind of</p>\n<div class=\"codehilite\"><pre><span></span><code>forall&lt;const C&gt; { if (HasType(C: usize)) { ... } }\n</code></pre></div>",
        "id": 196224822,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618637
    },
    {
        "content": "<p>Does that sound like a viable alternative to you?</p>",
        "id": 196224857,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618663
    },
    {
        "content": "<p>It feels \"more elegant\" to me, though clearly different from what rustc is doing</p>",
        "id": 196224867,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618671
    },
    {
        "content": "<p>it has some strange implications</p>",
        "id": 196224947,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618695
    },
    {
        "content": "<p>e.g., if you reference <code>C</code> as an expression, it needs a type</p>",
        "id": 196224969,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618708
    },
    {
        "content": "<p>but under this setup it can conceivably have multiple types</p>",
        "id": 196224979,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618714
    },
    {
        "content": "<p>or none</p>",
        "id": 196224983,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618719
    },
    {
        "content": "<p>Well, I always thought of const sort to be { C } (singleton) x Ty</p>",
        "id": 196225012,
        "sender_full_name": "Areredify",
        "timestamp": 1588618735
    },
    {
        "content": "<p>I gotta run for a bit but</p>",
        "id": 196225216,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618824
    },
    {
        "content": "<p>I guess I have to think about this</p>",
        "id": 196225264,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618853
    },
    {
        "content": "<p>and re-read your commits now that I understand better the problem</p>",
        "id": 196225274,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618860
    },
    {
        "content": "<p>From the theoretical standpoint, I don't like it</p>",
        "id": 196225275,
        "sender_full_name": "Areredify",
        "timestamp": 1588618860
    },
    {
        "content": "<p>I would prefer consts to be a collection of different sorts</p>",
        "id": 196225323,
        "sender_full_name": "Areredify",
        "timestamp": 1588618883
    },
    {
        "content": "<p>Yeah, it seems to lose something \"important\" to have them be untyped</p>",
        "id": 196225372,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618902
    },
    {
        "content": "<p>though from an engineering pov I also don't love having <code>ParameterKind</code> carry extra data</p>",
        "id": 196225456,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618929
    },
    {
        "content": "<p>that can't be stuffed into the lots bits of a pointer</p>",
        "id": 196225469,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618936
    },
    {
        "content": "<p>(that's how rustc handles this case)</p>",
        "id": 196225523,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588618967
    },
    {
        "content": "<p>So, the alternatives I see are:</p>\n<ol start=\"0\">\n<li>Leave everything as is, \"as is\" being: we carry a <code>Ty</code> in both <code>ParameterKind::Const</code> and <code>ConstData</code>, we always know the type of everything at any time.</li>\n<li>Have untyped consts with an ambient clause about their type, which is weird from the theoretical standpoint and implementation wise is also weird (also we would have to push a goal when we unify stuff? or that would be resolved with syn-sem lowering) </li>\n<li>Store type only in binders and in concrete consts. The idea is to store the type only if we have to, and if we want the type of a bound var we go to the binder and fetch it</li>\n<li>Wild west of untyped consts, we assume everything to be well formed and then we don't have to care about it</li>\n<li>Don't use <code>ParameterKind</code> for <code>Parameter</code> and use <code>enum ParameterKind2.0 { Ty(Ty), Lifetime(Lifetime), Const(Const) }</code> instead</li>\n<li>Something else?</li>\n</ol>",
        "id": 196229105,
        "sender_full_name": "Areredify",
        "timestamp": 1588620772
    },
    {
        "content": "<p>So, I think option 4 we want to do anyway</p>",
        "id": 196232061,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622135
    },
    {
        "content": "<p>eventually</p>",
        "id": 196232067,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622137
    },
    {
        "content": "<p>but I think that's not the interesting part, right?</p>",
        "id": 196232077,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622142
    },
    {
        "content": "<p>like, the relevant part was more the cases like <code>ParameterKind&lt;EnaVariable&gt;</code> or <code>ParameterKind&lt;()&gt;</code></p>",
        "id": 196232196,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622189
    },
    {
        "content": "<p>as you pointed out, <code>Binders</code> does indeed need to carry the <em>type</em> of the constant</p>",
        "id": 196232232,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622208
    },
    {
        "content": "<p>I don't quite get why you think Option 1 is weird from a theoretical/implementation standpoint, it doesn't strike me as so weird -- my main concern there though is that it admits a lot of things that don't \"map back up\" to the Rust standpoint, where every constant has a type. In particular, I think it might be weird more in rustc, if we are sharing some of these core types.</p>\n<p>From chalk's POV, I think it's basically the same as 3 -- we're saying that constants don't have types, but that any particular constant <em>value</em> has a type, and that there's this <code>HasType</code> predicate we can prove about constants (and we know how to prove it for constant <em>values</em>).</p>",
        "id": 196232556,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622388
    },
    {
        "content": "<p>(Not to say I favor that approach, I'm just not quite sure I see the problem's you are alluding to.)</p>",
        "id": 196232629,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622409
    },
    {
        "content": "<p>I mean weird stuff that you pointed out: constants having many types or no type</p>",
        "id": 196232714,
        "sender_full_name": "Areredify",
        "timestamp": 1588622456
    },
    {
        "content": "<p>Maybe you are right in that it's not that weird from the implementation standpoint, we could make it work</p>",
        "id": 196232988,
        "sender_full_name": "Areredify",
        "timestamp": 1588622618
    },
    {
        "content": "<p>(Not to say that I favor this approach either)</p>",
        "id": 196233072,
        "sender_full_name": "Areredify",
        "timestamp": 1588622650
    },
    {
        "content": "<p>Yeah, I think it can work, but it's not great that chalk would be able to accommodate things that don't map to Rust</p>",
        "id": 196233792,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588622991
    },
    {
        "content": "<p>Personally, I am inclined to pick 0/4 (as you pointed out, we would want to do 4 anyway)</p>",
        "id": 196235875,
        "sender_full_name": "Areredify",
        "timestamp": 1588624199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  Should we just put it on the agenda tomorrow and think of alternatives until the meeting?</p>",
        "id": 196237008,
        "sender_full_name": "Areredify",
        "timestamp": 1588624773
    },
    {
        "content": "<p>Sure. It still seems to me, though, that 4 is orthogonal.</p>",
        "id": 196238017,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588625266
    },
    {
        "content": "<p>I think there is a \"5\"</p>",
        "id": 196238033,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588625274
    },
    {
        "content": "<p>Which is to try and match how rustc handles this situation</p>",
        "id": 196238078,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588625283
    },
    {
        "content": "<p>Which would mean that we put <code>ty</code> into the <code>ConstData</code> struct</p>",
        "id": 196238140,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588625312
    },
    {
        "content": "<p>Hmm, erm, no I mean that still leaves us with the need to include types in binders</p>",
        "id": 196238201,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588625342
    },
    {
        "content": "<p>yeah, ok, never mind.</p>",
        "id": 196238217,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588625350
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/196238017\" title=\"#narrow/stream/144729-wg-traits/topic/const.20generics/near/196238017\">said</a>:</p>\n<blockquote>\n<p>Sure. It still seems to me, though, that 4 is orthogonal.</p>\n</blockquote>\n<p>That's what I meant (sorry, I have terrible communicating/explaining skills, even in my native tongue; my sometimes broken english doesn't help)</p>",
        "id": 196239346,
        "sender_full_name": "Areredify",
        "timestamp": 1588625945
    },
    {
        "content": "<p>So I was thinking about this --</p>",
        "id": 196916959,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588954924
    },
    {
        "content": "<p>I was thinking that maybe a good \"next step\" <span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> would be to create a PR that</p>\n<ul>\n<li>replaces <code>type Parameter = ParameterKind&lt;...&gt;</code> with a <code>GenericArg</code> (copying Rust's name) -- for bonus points, it should be an interned struct as well with a <code>data</code> method that gets a <code>GenericArgData</code></li>\n<li>and refactors <code>ParameterKind&lt;()&gt;</code> into <code>BoundVariableKind&lt;I&gt;</code> or something like (which for now is just type/lifetime and I guess a phantomdata for the <code>I</code> parameter)</li>\n<li>and refactors <code>ParameterKind&lt;EnaVariable&gt;</code> into a <code>(BoundVariableKind, EnaVariable)</code> pair</li>\n</ul>\n<p>Then we can, in the const generics PR:</p>\n<ul>\n<li>extend <code>BoundVariableKind</code> with <code>Const(Ty&lt;I&gt;)</code></li>\n<li>extend <code>GenericArg</code> with a <code>Const(Const&lt;I&gt;)</code> variable, and <code>Const&lt;I&gt;</code> can carry the <code>Ty&lt;I&gt;</code> (as rustc handles it)</li>\n</ul>",
        "id": 196917276,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588955084
    },
    {
        "content": "<p>What do you think of that?</p>",
        "id": 196917289,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588955091
    },
    {
        "content": "<p>Makes sense</p>",
        "id": 196917656,
        "sender_full_name": "Areredify",
        "timestamp": 1588955280
    },
    {
        "content": "<p>I'll go do that tomorrow, then</p>",
        "id": 196918051,
        "sender_full_name": "Areredify",
        "timestamp": 1588955466
    },
    {
        "content": "<p>If I rebase const pr to that new branch then I won't have to rebase when it lands?</p>",
        "id": 196918153,
        "sender_full_name": "Areredify",
        "timestamp": 1588955527
    },
    {
        "content": "<p>Not sure I understand</p>",
        "id": 196931742,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588961964
    },
    {
        "content": "<p>Can I rebase my const generics branch on top of my local branch for the refactoring (after it's done), so after landing the refactoring branch I won't have to rebase my const branch on top of master?</p>",
        "id": 196933431,
        "sender_full_name": "Areredify",
        "timestamp": 1588962864
    },
    {
        "content": "<p>yes</p>",
        "id": 196933842,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588963094
    },
    {
        "content": "<p>that is indeed what I would expect you to do :)</p>",
        "id": 196933859,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588963102
    },
    {
        "content": "<p>Hmm, do we want to name it <code>BoundVariableKind</code>? It implies that it's related to <code>BoundVar</code>, even though we will use it in inference contexts and universes (of course, inference vars and placeholders are, in a sense, bound in the corresponding inference context/universe, but it wouldn't be my first guess)</p>",
        "id": 196969280,
        "sender_full_name": "Areredify",
        "timestamp": 1588991706
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> I'm open to other names :)</p>",
        "id": 197212062,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589235606
    },
    {
        "content": "<p>maybe just <code>VariableKind</code>?</p>",
        "id": 197212096,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589235619
    },
    {
        "content": "<p>Halfway into doing this I realized that maybe instead of using <code>(VariableKind, EnaVariable) </code> type we can use</p>\n<div class=\"codehilite\"><pre><span></span><code>KindedData&lt;I, T&gt; {\n   kind: VariableKind&lt;I&gt;,\n   data: T,\n}\n</code></pre></div>",
        "id": 197491690,
        "sender_full_name": "Areredify",
        "timestamp": 1589413632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> what do you think?</p>",
        "id": 197491795,
        "sender_full_name": "Areredify",
        "timestamp": 1589413698
    },
    {
        "content": "<p>probably a dumb question, <code>KindedData</code> is obviously better than a pair in every way and allows us to keep <code>map</code> and other cool stuff, I am going to go with it (but tomorrow :P)</p>",
        "id": 197492287,
        "sender_full_name": "Areredify",
        "timestamp": 1589414040
    },
    {
        "content": "<p>Yes, a named struct is better, agreed.</p>",
        "id": 197536590,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589453478
    },
    {
        "content": "<p>I would probably call it <code>WithKind</code> or something but doesn't matter</p>",
        "id": 197536633,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589453503
    }
]