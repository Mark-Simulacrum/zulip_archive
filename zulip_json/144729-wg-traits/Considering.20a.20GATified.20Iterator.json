[
    {
        "content": "<p>So, GATs get closer and clsoer to stabilization, I've started to think hard about how std will look like with GATs (see <a href=\"#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs\">https://rust-lang.zulipchat.com/#narrow/stream/219381-t-libs/topic/APIs.20with.20GATs</a>).</p>\n<p>In particular, I'm interested in thinking about <code>Iterator</code>/<code>LendingIterator</code>. Essentially, I've been thinking: What is the most ergonomic way to integrate GATs into iterator-based APIs. A few examples: <code>for</code> loops, <code>FromIterator</code>, iterator adapters. One way that would be \"easiest\" would be to making a separate <code>LendingIterator</code> trait and a <code>impl&lt;I: Iterator&gt; LendingIterator for I {}</code>. But, the essentially splits the ecosystem around adapters and <code>FromIterator</code> (for loops could maybe change their desugaring). So a separate question: <em>Could we GATify <code>Iterator</code> somehow?</em> This has been brought up <a href=\"https://internals.rust-lang.org/t/pre-rfc-backward-compatible-gatification/15141/4\">before</a>, but the conclusion was basically that wouldn't work.</p>\n<p>Well, I want to get creative. Rather than say \"this wouldn't work\", I want to reframe this as \"what would it take to make this work?\" Particularly, is there any extension or modification to the current design of GATs that would allow it to work? What about other orthogonal language features? What if we <em>somehow</em> could prove lifetime bounds in some different way. Could this, in theory, be done in a backwards-compatible way (pre or post-GAT stabilization); if not, could it be done in an edition? What about trait objects? Currently, they're disallowed for GATs, so how does that factor in?</p>\n<p>I don't think this is an easy problem to solve. But, like I said, I'd like to see some creative solutions. Really, \"solving\" this problem for <code>Iterator</code> means we could conceivably solve this for other traits, like <code>Deref</code>.</p>",
        "id": 268342550,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642480592
    },
    {
        "content": "<p>To start, I'll elaborate some of my thoughts.</p>",
        "id": 268342584,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642480659
    },
    {
        "content": "<p>So, let's start by imagining that <code>Iterator::Item</code> has a lifetime <code>'a</code>. What would this mean for some existing APIs? (Just a forewarning that I haven't thought these completely through)</p>",
        "id": 268343439,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642481742
    },
    {
        "content": "<p>Let look at the <code>Iterator</code> trait</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>vs <code>LendingIterator</code></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">LendingIterator</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>To be able \"change\" the former into the latter, we'll need some way to indicate that the lifetime on <code>Item</code> is unused, and therefore doesn't hold a borrow to <code>Self</code>. So, maybe the signature of <code>next</code> should be</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"o\">&lt;'</span><span class=\"na\">out</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">in</span>: <span class=\"o\">'</span><span class=\"na\">out</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">in</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">out</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But this isn't really what we want: the caller specifies the lifetimes here.<br>\nTo make things concrete, let's look at a specific impl:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">LendingIterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>: <span class=\"o\">'</span><span class=\"na\">x</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&gt;</span>::<span class=\"n\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Iterator</span>::<span class=\"n\">next</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This works today, but the return type borrows from <code>Self</code>, so calling <code>LendingIterator::next(x)</code> is not the same <code>Iterator::next(x)</code>. This is normally what we want. But we need for a way for an impl to \"opt-out\" of this behavior.<br>\nLet's also include a function that uses <code>Iterator</code> today</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">iterate</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">I</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">_i</span>: <span class=\"nc\">I</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We essentially need a way to say that \"for any lifetime passed to <code>Item</code>, <code>I:Item</code> does not use it\". How would you express this?<br>\n<code>I: for&lt;'x&gt; Iterator&lt;Item&lt;'x&gt; = &amp;'a T&gt;</code> sort of works, because we see that <code>'x</code> isn't in the type. But that's a little weird - what if we <em>want</em> the normal <code>LendingIterator</code> behavior of a mutable borrow of <code>Self</code>? Is there ever a case would want that behavior? This only really works because we know that <code>T</code> can't name <code>'x</code>. For example if we had</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">iterate</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">I</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">_i</span>: <span class=\"nc\">I</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then this same behavior can't hold: <code>'x</code> might be in <code>T</code>.<br>\nTo my suprise (or maybe not, idk), this actually works right now:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">iter</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">core</span>::<span class=\"n\">fmt</span>::<span class=\"n\">Debug</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">I</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">LendingIterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_i</span>: <span class=\"nc\">I</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_i</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">_i</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So, at least in the respect, if a lifetime param was added to <code>Iterator::Item</code>, we would only have to desugar <code>I: Iterator&lt;Item = T&gt;</code> to <code>I: for&lt;'x&gt; Iterator&lt;Item&lt;'x&gt; = T&gt;</code>.</p>\n<p>But, next problem: <code>Iterator::collect</code>. The current signature looks like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">collect</span><span class=\"o\">&lt;</span><span class=\"n\">B</span>: <span class=\"nc\">FromIterator</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">Self</span>: <span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So, I made a test trait, with the same \"desugaring\"</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FromLendingIterator</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from_iter</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">LendingIterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">(</span><span class=\"n\">iter</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and a GATified collect:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">collect</span><span class=\"o\">&lt;</span><span class=\"n\">B</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FromLendingIterator</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;&gt;&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">Self</span>: <span class=\"nb\">Sized</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">FromLendingIterator</span>::<span class=\"n\">from_iter</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This, unfortunately, errors:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">E0308</span><span class=\"p\">]</span>: <span class=\"nc\">mismatched</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">src</span><span class=\"o\">/</span><span class=\"n\">main</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">14</span>:<span class=\"mi\">9</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">14</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\">         </span><span class=\"n\">FromLendingIterator</span>::<span class=\"n\">from_iter</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\">         </span><span class=\"o\">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span><span class=\"w\"> </span><span class=\"n\">lifetime</span><span class=\"w\"> </span><span class=\"n\">mismatch</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">expected</span><span class=\"w\"> </span><span class=\"n\">associated</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"err\">`</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">LendingIterator</span><span class=\"o\">&gt;</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">x</span><span class=\"o\">&gt;</span><span class=\"err\">`</span><span class=\"w\"></span>\n<span class=\"w\">                         </span><span class=\"n\">found</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"err\">`</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">LendingIterator</span><span class=\"o\">&gt;</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"err\">`</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But that might be fixable bug.</p>",
        "id": 268347665,
        "sender_full_name": "Jack Huey",
        "timestamp": 1642486547
    },
    {
        "content": "<p>So, a few thoughts:</p>\n<ul>\n<li>The prime challenge is that iterators and lending iterators aren't equivalent from the user's point-of-view.</li>\n<li>Given a lending iterator, values can't cross for loop iterations, in short, unless you already know their type.</li>\n</ul>\n<p>So I think the first question is what kinds of code we would like people to be able to write...</p>\n<p>...I think <em>probably</em> the ideal is that \"if the data crosses for loop iterations, you get some kind of error if that doesn't work\"</p>",
        "id": 269112215,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643034139
    },
    {
        "content": "<p>Okay, for those following along: the next step here is probably to come up with some \"user stories\" for how we might expect people to use LendingIterator or a GATified Iterator (<a href=\"https://github.com/rust-lang/generic-associated-types-initiative/issues/1\">https://github.com/rust-lang/generic-associated-types-initiative/issues/1</a>). We need to update the repo to have a place for them, but if you have some thoughts, please feel free to file an issue there, and I'll make sure it gets included. (Also welcome examples of other traits too, like Deref)</p>",
        "id": 269137918,
        "sender_full_name": "Jack Huey",
        "timestamp": 1643044424
    },
    {
        "content": "<p>So, I was trying to play with what a <code>FromIterator</code> would look like with a GATified <code>Iterator</code>:  <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2387f62342b52c091dc7e756c4a23359\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=2387f62342b52c091dc7e756c4a23359</a></p>",
        "id": 271716809,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644710518
    },
    {
        "content": "<p>Here, I'm just imagining that <code>for&lt;'x&gt; LendingIterator&lt;Item&lt;'x&gt; = A&gt;</code> would be \"generated\" if the user wrote <code>LendingIterator&lt;Item = A&gt;</code></p>",
        "id": 271716879,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644710629
    },
    {
        "content": "<p>This doesn't compile as-is right now</p>",
        "id": 271716931,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644710667
    },
    {
        "content": "<p>For seemingly two separate reasons</p>",
        "id": 271716936,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644710683
    },
    {
        "content": "<p>First, when we compare the impl against the trait, we have to check that, knowing the bounds from the trait method, we can prove that the bounds on the impl method hold</p>",
        "id": 271716976,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644710741
    },
    {
        "content": "<p>namely <code>I: for&lt;'x&gt; LendingIterator&lt;Item&lt;'x&gt; = A&gt;</code></p>",
        "id": 271716982,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644710751
    },
    {
        "content": "<p>However, long story short, when proving this, we normalize <code>for&lt;'x&gt; &lt;I as LendingIterator&gt;::Item&lt;'x&gt;</code>, which requires that <code>I: 'x</code>, for some <code>'x</code> as a placeholder</p>",
        "id": 271717052,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644710831
    },
    {
        "content": "<p>There's an open issue (I think) for GATs somewhere that covers this scenario. Basically, we need to be better about knowing that the normalization <em>here</em>, we don't really care about <code>'x</code>, because we know that when we use this method, we require that <code>I: 'x</code> for the lifetime we pick for <code>'x</code></p>",
        "id": 271717207,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644711099
    },
    {
        "content": "<p>I guess <a href=\"https://github.com/rust-lang/rust/issues/90573\">#90573</a> is the issue I'm thinking of</p>",
        "id": 271717370,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644711320
    },
    {
        "content": "<p>In particular, <a href=\"https://users.rust-lang.org/t/gats-and-hrtb-confusion/66830/4\">this comment</a> does a great job of explaining it</p>",
        "id": 271717426,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644711381
    },
    {
        "content": "<p>(I realize I think I wrote the wrong explanation on the issue)</p>",
        "id": 271717433,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644711410
    },
    {
        "content": "<p>The second issue with this example is</p>\n<div class=\"codehilite\"><pre><span></span><code>note: expected associated type `&lt;Self as LendingIterator&gt;::Item&lt;&#39;x&gt;`\n              found associated type `&lt;Self as LendingIterator&gt;::Item&lt;&#39;_&gt;`\n</code></pre></div>\n<p>which seems very similar to other associated type bugs that I've seen - but I  haven't investigated that</p>",
        "id": 271717500,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644711502
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6b4637cc023c8107560e2aadd44da0ae\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=6b4637cc023c8107560e2aadd44da0ae</a> &lt;-- so, the first problem you can do with <code>'static</code>, the second is that we don't have required where clause to say that \"no matter what lifetime produced by Item, we get same result\"</p>",
        "id": 271894801,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644875669
    },
    {
        "content": "<p>So, to expand on what we found yesterday a bit: the first issue can be solved with a <code>'static</code> bound on <code>LendingIterator</code> (<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=06771e6c633fb44eecf4bc4cf697f577\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=06771e6c633fb44eecf4bc4cf697f577</a>). The second issue (with collect) can be changed with a bit of modification to the function signature (in Niko's playground link)</p>",
        "id": 272011755,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644947341
    },
    {
        "content": "<p>Not strictly related, but <a href=\"https://github.com/rust-lang/rust/issues/93203#issuecomment-1040720703\">this deep dive into scoped threads</a> turned up an interesting conclusion.</p>",
        "id": 272029117,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644954892
    },
    {
        "content": "<p>In short, the ability to have a more ergonomic API turns out to be gated on richer HRTB (e.g., implication goals)</p>",
        "id": 272029145,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644954905
    },
    {
        "content": "<blockquote>\n<p>If you insist, but remember that you asked for it.</p>\n</blockquote>\n<p>These are the best</p>",
        "id": 272029311,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644954977
    },
    {
        "content": "<p>I was thinking a bit too. The issue here isn't just lifetimes: if we had <code>I: for&lt;X&gt; Foo&lt;Item&lt;X&gt; = A&gt;</code>, and there was some like <code>where X: Iterator</code> bound on <code>Item</code>, then we would get an error about <code>X: Iterator</code> not being provable</p>",
        "id": 272029478,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644955067
    },
    {
        "content": "<p>We would either need to <em>imply</em> that <code>X: Iterator</code> hold here or have some way to write <code>for&lt;X: Iterator&gt;</code></p>",
        "id": 272029593,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644955103
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator/near/272029145\">said</a>:</p>\n<blockquote>\n<p>In short, the ability to have a more ergonomic API turns out to be gated on richer HRTB (e.g., implication goals)</p>\n</blockquote>\n<p>maybe because I've only skimmed this, but I don't necessarily see the relation?</p>",
        "id": 272030140,
        "sender_full_name": "Jack Huey",
        "timestamp": 1644955318
    },
    {
        "content": "<p>This is the non-lifetime case: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=129c544fe99596c4388c3429df1124e5\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=129c544fe99596c4388c3429df1124e5</a></p>",
        "id": 272134734,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645027056
    },
    {
        "content": "<p>And an example of why using that kind of scheme (lifetime on the function instead of <code>for&lt;'x&gt;</code> doesn't work: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=552f9f34e4823b647c503203537a1fbc\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=552f9f34e4823b647c503203537a1fbc</a></p>",
        "id": 272134857,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645027094
    },
    {
        "content": "<p>I think we need implied binds that essentially amounts to <code>fn from_iter&lt;T: for&lt;'x where WF(LendingIterator&lt;Item&lt;'x&gt; = A&gt;)&gt; LendingIterator&lt;Item&lt;'x&gt; = A&gt;&gt;(mut iter: I) -&gt; Self;</code></p>",
        "id": 272149901,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645032971
    },
    {
        "content": "<p>Because I don't think we can necessarily treat <code>LendingIterator&lt;Item&lt;'x&gt; = A&gt;</code> as WF always</p>",
        "id": 272150030,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645033024
    },
    {
        "content": "<p>because maybe there's a <code>where &lt;Self as LendingIterator&gt;::Item: Foo</code> bound; we would then have to check that <code>A: Foo</code>, not just treat it as WF</p>",
        "id": 272150125,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645033070
    },
    {
        "content": "<p>but what if there was something like <code>trait Trait&lt;U&gt; { type Assoc&lt;T&gt; where Option&lt;(T, U)&gt;: Foo; }</code></p>",
        "id": 272150400,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645033180
    },
    {
        "content": "<p>If we then had <code>T: for&lt;X, Y&gt; Trait&lt;X, Assoc&lt;Y&gt; = ()&gt;</code>, what are the implied bounds on <code>X</code> and <code>Y</code>?</p>",
        "id": 272150633,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645033273
    },
    {
        "content": "<p>or, better example <code>&lt;X, T: for&lt;Y&gt; Trait&lt;X, Assoc&lt;Y&gt; = ()&gt;&gt;</code></p>",
        "id": 272150961,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645033393
    },
    {
        "content": "<p>do we need a where clause on the function: <code>where for&lt;Y&gt; Option&lt;(X, Y)&gt;: Foo</code>?</p>",
        "id": 272151099,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645033458
    },
    {
        "content": "<p>And in both cases it's implied that it's <code>for&lt;Y where Option&lt;(X, Y)&gt;: Foo&gt;</code></p>",
        "id": 272151185,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645033497
    },
    {
        "content": "<p>This is what I mean: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fc8e420591a297e757b2853987d59b44\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fc8e420591a297e757b2853987d59b44</a></p>",
        "id": 272530571,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645291379
    },
    {
        "content": "<p>Also seeing <a href=\"https://github.com/rust-lang/chalk/blob/662706f0e27722386f77d694fe8602b16be010f9/chalk-solve/src/wf.rs#L209\">this</a> and thinking about what it would mean for <em>everything</em> to be \"lazy\"</p>",
        "id": 272530646,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645291447
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Considering.20a.20GATified.20Iterator/near/272029593\">said</a>:</p>\n<blockquote>\n<p>We would either need to <em>imply</em> that <code>X: Iterator</code> hold here or have some way to write <code>for&lt;X: Iterator&gt;</code></p>\n</blockquote>\n<p>this seems right. I'd be inclined to do the implication---</p>",
        "id": 273574510,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646094339
    },
    {
        "content": "<p>For this, probably</p>",
        "id": 273576872,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646095933
    },
    {
        "content": "<p>Would GAT-ified iterator requires extension to GAT that could be backward incompatible with current GAT design and therefore postpone stabilization of GAT?</p>",
        "id": 274311195,
        "sender_full_name": "marmeladema",
        "timestamp": 1646580031
    },
    {
        "content": "<p>Working on that. I think the answer is no, but still have to work through some things.</p>",
        "id": 274312196,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646581346
    },
    {
        "content": "<p>I made a <code>generic_associated_types_extended</code> feature, which (currently) ignores obligations generated in <code>poly_project_and_unify_type</code> that reference new placeholders (with the <em>idea</em> being that they get checked later with a concrete lifetime) <a href=\"https://github.com/rust-lang/rust/issues/94869\">#94869</a></p>",
        "id": 275063804,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647042818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span></p>",
        "id": 275063808,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647042820
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"426609\">@Michael Goulet (compiler-errors)</span></p>",
        "id": 275063816,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647042830
    },
    {
        "content": "<p>This alone is enough to make the <code>LendingIterator</code> <code>FromIterator</code> example work</p>",
        "id": 275063880,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647042859
    },
    {
        "content": "<p>\"Object-safe\" GATs under <code>generic_associated_type_extended</code> feature: <a href=\"https://github.com/rust-lang/rust/issues/94911\">#94911</a></p>",
        "id": 275162220,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647188105
    }
]