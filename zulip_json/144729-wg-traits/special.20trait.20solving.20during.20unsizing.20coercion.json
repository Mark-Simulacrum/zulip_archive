[
    {
        "content": "<p>soo, when doing unsizing coercions, we have to solve some <code>T: CoerceUnsized&lt;U&gt;</code> goal at a point where <code>T</code> and <code>U</code> might still contain some unknown type variables, and it turns out this might be hard to do correctly. rustc actually has a <a href=\"https://github.com/rust-lang/rust/blob/d488de82f30fd1dcb0220d57498638596622394e/compiler/rustc_typeck/src/check/coercion.rs#L581-L667\">custom trait solving loop</a> during coercion, where it just tries to solve <code>CoerceUnsized</code> and <code>Unsize</code> subgoals and keeps the rest for later, plus there's some additional special handling for dyn types. </p>\n<p>Now that we're <a href=\"https://github.com/rust-analyzer/rust-analyzer/pull/9807\">implementing <code>Sized</code> bounds in rust-analyzer</a>, it looks like something like this is actually necessary to get coercions correct in all cases. Any ideas how this could be handled in Chalk, or whether there might be some other way?</p>",
        "id": 249096002,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628682501
    },
    {
        "content": "<p>CC <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span></p>",
        "id": 249096202,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628682666
    },
    {
        "content": "<p>Uh, I have to get this back in my mind. I'm not personally super familiar with CoerceUnsized</p>",
        "id": 249107949,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628689067
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> could you provide an example goal that is problematic?</p>",
        "id": 249114058,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628691454
    },
    {
        "content": "<p>not right now, maybe <span class=\"user-mention\" data-user-id=\"319948\">@Dawer</span> can, otherwise I'll collect more details probably this evening</p>",
        "id": 249114563,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628691648
    },
    {
        "content": "<p>I think it's something like, when we want to unsize something that contains an inference variable we'll get an ambiguous answer, but we also get an ambiguous answer in other cases where we actually shouldn't unsize (e.g. for <code>&amp;$0 -&gt; &amp;SomeStruct</code>)</p>",
        "id": 249117029,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628692680
    },
    {
        "content": "<p>so we have no way of distinguishing those cases</p>",
        "id": 249117088,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628692692
    },
    {
        "content": "<p>So, it doesn't surprise me that if there is an inference variable, you'll get an ambiguous answer. (but when I skimmed through the thread, you did get <code>Definite</code>, which means progress was made)</p>",
        "id": 249120427,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628694155
    },
    {
        "content": "<p><code>&amp;$0 -&gt; &amp;SomeStruct</code> is interesting...I imagine that's probably not <code>Definite</code>?</p>",
        "id": 249120507,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628694196
    },
    {
        "content": "<p>I would guess not, and drawing the line at Definite is something I thought about as well, but it seems a bit arbitrary. We'll see how the results look with that</p>",
        "id": 249126941,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628697010
    },
    {
        "content": "<p><code>Ambiguous(Definite)</code> means \"we didn't find a 'concrete' answer, but we made progress; the eventually concrete answer will look like this\"</p>",
        "id": 249127234,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628697145
    },
    {
        "content": "<p>yeah, but are we sure we'll get definite guidance in every situation where we should do unsizing?</p>",
        "id": 249127905,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628697430
    },
    {
        "content": "<p>I'm not sure. I'm not really familiar with the types of goals generated.</p>",
        "id": 249128605,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628697675
    },
    {
        "content": "<p>yeah</p>",
        "id": 249128794,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628697738
    },
    {
        "content": "<p>we'll have to extract some goals from our test cases and see</p>",
        "id": 249128817,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628697749
    },
    {
        "content": "<p>yeah, looking at the examples, it's pretty much what I described above</p>",
        "id": 249159477,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628710990
    },
    {
        "content": "<p>so maybe deciding based on the guidance will work</p>",
        "id": 249159518,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628711006
    },
    {
        "content": "<p>Oh good</p>",
        "id": 249159723,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628711106
    },
    {
        "content": "<p>I'm still a bit worried that rustc's special handling is necessary in some edge cases, but we'll see</p>",
        "id": 249160052,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1628711270
    }
]