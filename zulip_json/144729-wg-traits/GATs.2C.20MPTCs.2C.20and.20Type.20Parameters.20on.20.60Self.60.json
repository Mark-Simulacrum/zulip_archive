[
    {
        "content": "<p>I recently attempted to more-accurately define the example of functional categories from <a href=\"https://www.fpcomplete.com/blog/monads-gats-nightly-rust/\">Monads and GATs in nightly Rust (FPComplete / M. Snoyman)</a>; I ended up with a synthetic <code>Id</code> supertrait which maps- via a GAT- the first type parameter to its type constructor.</p>\n<p>( See the example code at <a href=\"https://rust.godbolt.org/z/8eWsqoWPo\">https://rust.godbolt.org/z/8eWsqoWPo</a> )</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Id</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">New</span><span class=\"o\">&lt;</span><span class=\"n\">Ego</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Implementing this trait for each type that will participate in the categories hierarchy allows it to be used in a category definition such as the following excerpt:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Functor</span>: <span class=\"nc\">Id</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">fmap</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">New</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Notice that, unlike the GAT implementation on the blog post, a <code>Functor</code> implementation is type-constrained to produce the <em>same</em> <code>Functor</code> implementation for the output of <code>fmap</code>, but this is only true as long as the <code>Id</code> implementation is truthful.</p>\n<p>There are three problems with this solution:</p>\n<ul>\n<li><code>Id</code> can be implemented dishonestly, producing unexpected types, but it  is not auto-implemented, because auto traits do not allow type parameters</li>\n<li><code>Id</code> effectively takes the place of an update syntax over <code>Self</code>, whereas <code>Self</code> could hypothetically be made to do this on its own</li>\n<li>Only one type parameter is supported- thus forbidding usage of <a href=\"https://wiki.haskell.org/Multi-parameter_type_class\">Multi-parameter Type Classes</a> locking us away from a host of common categories such as contextual monads</li>\n</ul>\n<p>The reason we need to express this at all, however, is that traits are only describable from a <code>self</code> context; if we could define traits in terms of a global space, such that Self is a type parameter, we could eliminate the need for most of this complexity, enabling the much simpler Haskell syntax. GATs handle the rest by allowing subtypes with type parameters.</p>\n<p>In summary, while I recognize this is far too vague for an RFC, I'd suggest we do one of two things:</p>\n<ul>\n<li>Enable type parameters on <code>Self</code> (but how do we represent the variadic nature of Self types without variadic generics support?)</li>\n<li>Allow global-context trait definitions by creating a syntax for a special-case of Self as a type parameter to the trait, such that a single generic parameter can be bound to both the <code>self</code> parameter <em>and</em> others.</li>\n</ul>\n<p>Thoughts?</p>",
        "id": 248920777,
        "sender_full_name": "Zoey",
        "timestamp": 1628550423
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"398288\">@Zoey</span>. Don't have ton of time right now to dig into this, but if you ping towards the end of the week, I can look more at it</p>",
        "id": 249162580,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628712470
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> Hey Jack, pinging you as requested :)</p>",
        "id": 249398701,
        "sender_full_name": "Zoey",
        "timestamp": 1628880784
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 249399025,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628880976
    },
    {
        "content": "<p>whoops. Was reading this then got pulled away</p>",
        "id": 249404885,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628883953
    },
    {
        "content": "<p>Okay, so I see what's trying to be accomplished here</p>",
        "id": 249406102,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628884638
    },
    {
        "content": "<p>So, first question</p>",
        "id": 249406402,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628884796
    },
    {
        "content": "<p>Why is it necessary to split out <code>Id</code> here?</p>",
        "id": 249406462,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628884805
    },
    {
        "content": "<p>If you don't, there's no way to describe \"Self but with one parameter modified\"- and, if you don't, I could lie by giving you a <em>different</em> functor implementation in response to the first one (See the Monads and GATs article linked above).</p>",
        "id": 249406591,
        "sender_full_name": "Zoey",
        "timestamp": 1628884865
    },
    {
        "content": "<p>I'm not sure I follow. Why doesn't this work: <a href=\"https://rust.godbolt.org/z/r55eo8Tsh\">https://rust.godbolt.org/z/r55eo8Tsh</a></p>",
        "id": 249406797,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628884976
    },
    {
        "content": "<p>Ah, because of massive redundancy and potential for inconsistancy; <code>Id</code> is simulating a compiler-intrinsic / auto-trait; The way your example works, anyone could \"lie\" in their impl of Functor, but- aside from that- you couldn't generate a <code>monad</code> instance without redefining New for that, and so on for each subsequent category</p>",
        "id": 249407001,
        "sender_full_name": "Zoey",
        "timestamp": 1628885074
    },
    {
        "content": "<p>So you're basically trying to come up with a design that allows you to create traits that disallow</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">New</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">fmap</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249407617,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628885353
    },
    {
        "content": "<p>I was mulling over it the other night, and realized that if, for a trait <code>T&lt;Y&gt;</code> with implementer  <code>Foo&lt;Bar, Baz&gt; such that Y maps to Baz</code> and <code>Bar</code> is provided by <code>impl&lt;Bar&gt;</code>, if we consider <code>Self</code> in context, it currently equates <code>Self</code> =&gt; <code>Foo&lt;Bar, Y&gt;</code>, right?</p>\n<p>If so, what if we give <code>Self</code> optional generic parameters when in trait context, and those parameters are allowed to override the associated types of the Self type in a sort of \"update\" syntax?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">fmap</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Any that aren't explicitly mentioned are \"filled in\" with the ones on the current <code>Self</code></p>",
        "id": 249407645,
        "sender_full_name": "Zoey",
        "timestamp": 1628885364
    },
    {
        "content": "<p>As for the example you just gave- that looks more like a catamorphism- B isn't wrapped in a Functor at all?</p>\n<p>What I'm trying to prevent with <code>Id</code> is, quoting from the article, a \"horrifically non-sensible implementation such as\" the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyOption</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Unwrapped</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Wrapped</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// wut?</span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">map</span><span class=\"o\">&lt;</span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">MyOption</span>::<span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">MyOption</span>::<span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"s\">\"Well this is weird, isn't it?\"</span><span class=\"p\">.</span><span class=\"n\">to_owned</span><span class=\"p\">()),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Such a definition would allow <code>Option::&lt;T&gt;::map</code> to produce a <code>Result&lt;T, ...&gt;</code> or anything else that implements <code>Functor</code>.</p>",
        "id": 249407902,
        "sender_full_name": "Zoey",
        "timestamp": 1628885468
    },
    {
        "content": "<p>the idea is roughly the same</p>",
        "id": 249408252,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628885634
    },
    {
        "content": "<p>that the type that we return doesn't necessarily have to be <code>Self</code></p>",
        "id": 249408338,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628885665
    },
    {
        "content": "<p>have to think, but associated types doesn't feel like the right way to approach this</p>",
        "id": 249408413,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628885708
    },
    {
        "content": "<blockquote>\n<p>that the type that we return doesn't necessarily have to be Self</p>\n</blockquote>\n<p>Correct- and if we can define it as \"Self in every way <em>except</em> this one\", and we can define it at the trait level rather than the implementor level, that would allow enforced correctness and more concise code.</p>",
        "id": 249408421,
        "sender_full_name": "Zoey",
        "timestamp": 1628885714
    },
    {
        "content": "<blockquote>\n<p>have to think, but associated types doesn't feel like the right way to approach this</p>\n</blockquote>\n<p>Higher-kinded types would be the most appropriate solution, but - with GATs- this appears to be the most-consistent way to go about encoding category theory and morphisms.</p>\n<p>I did mention- in my opening post- that, if we can use <code>Self</code> generically alongside an associated-type-update syntax, we could theoretically do true HKT</p>\n<p><code>fn fmap&lt;X, Y, A: Functor&lt;Item = X&gt;, B: A&lt;Item = Y&gt;, F: Fn(X) -&gt; Y&gt;(self: A, f: F) -&gt; B;</code></p>",
        "id": 249408589,
        "sender_full_name": "Zoey",
        "timestamp": 1628885797
    },
    {
        "content": "<p>It's interesting to think about</p>",
        "id": 249408687,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628885851
    },
    {
        "content": "<p>But I feel like the best approach for this would be start by asking \"why would we need this\" and \"what would this kind of feature allow us to do that existing features (or planned) wouldn't\"</p>",
        "id": 249408826,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628885930
    },
    {
        "content": "<p>Looking above at your \"problems with this solution\":</p>",
        "id": 249408962,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628885998
    },
    {
        "content": "<blockquote>\n<p>Id effectively takes the place of an update syntax over Self, whereas Self could hypothetically be made to do this on its own</p>\n</blockquote>\n<p>Not sure that's really a <em>problem</em>, as much as an observation</p>",
        "id": 249409048,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886025
    },
    {
        "content": "<p>It's a problem because Self can have multiple parameters, and Id::New&lt;T&gt; can't- Id also cannot be trusted, whereas Self can be</p>",
        "id": 249409107,
        "sender_full_name": "Zoey",
        "timestamp": 1628886055
    },
    {
        "content": "<p>I mean, that's your point 3, yeah</p>",
        "id": 249409168,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886085
    },
    {
        "content": "<p>but just saying that <code>Id</code> takes the place of a \"self update syntax\" isn't a problem</p>",
        "id": 249409227,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886122
    },
    {
        "content": "<p>If <code>Id</code> were a builtin and could do true updates, I'd be fine with that; it feels less elegant, but that's mostly a bikeshed.</p>",
        "id": 249409328,
        "sender_full_name": "Zoey",
        "timestamp": 1628886164
    },
    {
        "content": "<p>As far as <code>Id</code> being implemented dishonestly, this is true</p>",
        "id": 249409330,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886166
    },
    {
        "content": "<p>So, how would you expect <code>Functor</code> on a struct with multiple type parameters to look?</p>",
        "id": 249409396,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886209
    },
    {
        "content": "<blockquote>\n<p>So, how would you expect <code>Functor</code> on a struct with multiple type parameters to look?</p>\n</blockquote>\n<p>It'd be encoded by the trait being unaware of the presence of multiple type parameters, because it's using <code>Self</code> to refer back; Effectively, the other parameter would be hidden.</p>\n<p>For categories that require multiple parameters, they'd simply <code>update</code> both of the associated types, instead of just one. The implicit update syntax where it \"fills in\" the rest to be consistent with the current <code>Self</code> handles the rest.</p>",
        "id": 249409727,
        "sender_full_name": "Zoey",
        "timestamp": 1628886356
    },
    {
        "content": "<p>I mean, what would the equivalent of <code>fmap</code> look like?</p>",
        "id": 249410193,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886569
    },
    {
        "content": "<p>i.e. would you expect that <code>fmap</code> to only be able to change one type parameter? Or would you expect it to be able to change <em>all</em> type parameters? Or <em>any</em>?</p>",
        "id": 249410420,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886698
    },
    {
        "content": "<p>One (or really, a fixed number), are relatively easy, since you could just make <code>type New&lt;A, B&gt; = MyStruct&lt;Z, Y, A, B&gt;;</code> (on <code>MyStruct&lt;Z, Y, X, W&gt;</code>)</p>",
        "id": 249410635,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886799
    },
    {
        "content": "<p><em>all</em> is not doable right now (but you could conceivably imagine that maybe with variadic generics you might be able to get there)</p>",
        "id": 249410744,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886848
    },
    {
        "content": "<blockquote>\n<p>I mean, what would the equivalent of fmap look like?</p>\n</blockquote>\n<p>With multiple category parameters?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Bifunctor</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Left</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Right</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bimap</span><span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">FL</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Left</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">FL</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Right</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fl</span>: <span class=\"nc\">FL</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fr</span>: <span class=\"nc\">FR</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">New</span><span class=\"o\">&lt;</span><span class=\"n\">Left</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249410787,
        "sender_full_name": "Zoey",
        "timestamp": 1628886869
    },
    {
        "content": "<p><em>any</em>, I'm not even sure. You would have to have some way of pick a function (almost like monomorphization) by the type parameter to change</p>",
        "id": 249410889,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"398288\">Zoey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/GATs.2C.20MPTCs.2C.20and.20Type.20Parameters.20on.20.60Self.60/near/249410787\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I mean, what would the equivalent of fmap look like?</p>\n</blockquote>\n<p>With multiple category parameters?</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Bifunctor</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Left</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Right</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bimap</span><span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">FL</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Left</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">FL</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Right</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fl</span>: <span class=\"nc\">FL</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">fr</span>: <span class=\"nc\">FR</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">New</span><span class=\"o\">&lt;</span><span class=\"n\">Left</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Right</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Right, so this doesn't work with <code>Id</code>, but it would work with the code I gave</p>",
        "id": 249411023,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628886977
    },
    {
        "content": "<p>I think considering supertraits may help; A category could be defined that requires membership with Functor but returns a new functor of a separate content type- for example, the <code>Bind</code> operation from Monad; We'd need to redefine New for each typeclass, and be unable to represent it without variadics.</p>",
        "id": 249411234,
        "sender_full_name": "Zoey",
        "timestamp": 1628887103
    },
    {
        "content": "<p>The fundamental problem here is just that traits don't know about an implementer's parameters. And, as such, it can't \"name\"</p>",
        "id": 249411419,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628887205
    },
    {
        "content": "<p>Ah, right! I see where the problem could be from your read:</p>\n<p>Okay, so the other thing about the <code>Self-update</code> syntax is that it doesn't care about the implementor- it can <em>only</em> update associated types from <em>itself</em> or its supertraits.</p>\n<p>(Incidentally, \"Self-update syntax\" sounds like a reasonable name for an RFC or feature gate)</p>",
        "id": 249411505,
        "sender_full_name": "Zoey",
        "timestamp": 1628887258
    },
    {
        "content": "<p>Like, I guess what would you expect <code>Self&lt;U&gt;</code> to be inside of a trait? You do briefly state this. For <code>Box&lt;T&gt;</code>, it's probably <code>Box&lt;U&gt;</code>, but for you <code>MyStruct&lt;X, Y&gt;</code>, is it <code>MyStruct&lt;U, Y&gt;</code> or <code>MyStruct&lt;X, U&gt;</code></p>",
        "id": 249411590,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628887307
    },
    {
        "content": "<p>To do this (\"properly\", I guess), we need some way to encode in a trait the idea that \"an implementor must have a type parameter <code>T</code>\", and then that <code>T</code> can be used</p>",
        "id": 249411843,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628887415
    },
    {
        "content": "<p>Pseudo-syntax: <code>trait Foo: Self&lt;T&gt;</code></p>",
        "id": 249411905,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628887440
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/GATs.2C.20MPTCs.2C.20and.20Type.20Parameters.20on.20.60Self.60/near/249411843\">said</a>:</p>\n<blockquote>\n<p>To do this (\"properly\", I guess), we need some way to encode in a trait the idea that \"an implementor must have a type parameter <code>T</code>\", and then that <code>T</code> can be used</p>\n</blockquote>\n<p>nonono, this is way too powerful and far more than I'm asking for- let me restrict it so we aren't talking about something universal in extent</p>\n<p>The implementor is irrelevant, with regards to the request; I'm going to write up a scoped-down solution.</p>",
        "id": 249411994,
        "sender_full_name": "Zoey",
        "timestamp": 1628887472
    },
    {
        "content": "<p>Then <code>fn map&lt;U, F: Fn(T) -&gt; U&gt;(self, f: F) -&gt; Self&lt;U&gt;</code></p>",
        "id": 249412060,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628887509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/GATs.2C.20MPTCs.2C.20and.20Type.20Parameters.20on.20.60Self.60/near/249411905\">said</a>:</p>\n<blockquote>\n<p>Pseudo-syntax: <code>trait Foo: Self&lt;T&gt;</code></p>\n</blockquote>\n<p>unsure what an impl would look like though...</p>",
        "id": 249412457,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628887733
    },
    {
        "content": "<blockquote>\n<p>unsure what an impl would look like though...</p>\n</blockquote>\n<p>I'm writing a formalization as fast as I can- I think we lost coherence and diverged at some point</p>",
        "id": 249412530,
        "sender_full_name": "Zoey",
        "timestamp": 1628887775
    },
    {
        "content": "<p>I think I'm following</p>",
        "id": 249412670,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628887828
    },
    {
        "content": "<p>To formalize and restrict so it's not so hard to work with:</p>\n<p><code>Self</code>-update syntax allows traits to refer to <code>Self</code> with changes to a subset of associated types such that all associated types which are not explicitly mentioned remain equivalent. <br>\nWhen in a trait <code>T</code>, <code>Self</code> is equivalent to <code>Self&lt;&gt;</code>; <br>\nWhen in a trait <code>T</code> with AssocType <code>Y</code>, <code>Self</code> is equivalent to <code>Self&lt;&gt;</code>, <code>Self&lt;Y = Self::Y&gt;</code>;<br>\nWhen in a trait <code>T</code> with AssocTypes <code>Y</code>, <code>Z</code>, <code>Self</code> is equivalent to <code>Self&lt;&gt;</code>, <code>Self&lt;Y = Self::Y&gt;</code>, <code>Self&lt;Z = Self::Z&gt;</code>, <code>Self&lt;Y = Self::Y, Z = Self::Z&gt;</code></p>\n<p>For traits with supertraits, associated types on those supertraits can be referenced as if they were associated types in <code>Self</code>, but (until we come up with a syntax for it and solve any other problems therein) you can only update one associated types from one supertrait at a time:</p>\n<p>When in a trait Foo: Bar where Foo has associated type X and Bar has associated type Y:<br>\n<code>Self&lt;X = Self::X&gt;</code> ≈ <code>Self</code><br>\n<code>&lt;Self as Bar&gt;::&lt;Y = Self::Y&gt;</code> ≈ <code>Self</code><br>\nUpdates can be performed to the supertrait by using <code>&lt;Self as SuperTrait&gt;::&lt;...&gt;</code> syntax, but - as you cannot <code>as</code>-cast for multiple types in the same expression, and we lack intersection types, we restrict to updating one supertrait or the current trait itself at a time.</p>",
        "id": 249412920,
        "sender_full_name": "Zoey",
        "timestamp": 1628888005
    },
    {
        "content": "<p>I got lost/sidetracked after the first paragraph</p>",
        "id": 249413094,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888133
    },
    {
        "content": "<p>But I feel like this is possible doable</p>",
        "id": 249413117,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888148
    },
    {
        "content": "<p>Where precisely did you get lost? I can refine it</p>",
        "id": 249413151,
        "sender_full_name": "Zoey",
        "timestamp": 1628888163
    },
    {
        "content": "<p>Reminds me of the \"struct update\" syntax being extended to allowing</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"nc\">Struct</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">other</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">p</span>: <span class=\"nc\">u</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nc\">Struct</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Struct</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">p</span>: <span class=\"nc\">t</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">..</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249413313,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888243
    },
    {
        "content": "<p>/me goes to find that PR</p>",
        "id": 249413440,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888300
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/86555\">https://github.com/rust-lang/rust/issues/86555</a></p>",
        "id": 249413532,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888357
    },
    {
        "content": "<p>I've wanted that for a while- This is similar but potentially much more powerful in what it can accomplish for the ecosystem. It may also allow us to avoid <code>specialization</code> while gaining massive performance benefits in generic code.</p>",
        "id": 249413606,
        "sender_full_name": "Zoey",
        "timestamp": 1628888401
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/GATs.2C.20MPTCs.2C.20and.20Type.20Parameters.20on.20.60Self.60/near/249411843\">said</a>:</p>\n<blockquote>\n<p>To do this (\"properly\", I guess), we need some way to encode in a trait the idea that \"an implementor must have a type parameter <code>T</code>\", and then that <code>T</code> can be used</p>\n</blockquote>\n<p>now that I think about it...this is <em>nearly</em> an associated type</p>",
        "id": 249413753,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888443
    },
    {
        "content": "<p>Exactly! That's why we skip caring about the implementer and stick to the trait level</p>",
        "id": 249413797,
        "sender_full_name": "Zoey",
        "timestamp": 1628888469
    },
    {
        "content": "<p>So far as I can currently tell, we could actually do this all as a not-quite-sugar-but-close, but it would probably be better done at a higher level.</p>",
        "id": 249413938,
        "sender_full_name": "Zoey",
        "timestamp": 1628888523
    },
    {
        "content": "<p>Interestingly, in the case, using a \"self-update syntax\" like that forbids using the associated type as any <em>other</em> than a parameter</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">map</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">BadOption</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">BadOption</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">map</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">BadOption</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// Problem! `U != ()`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249414239,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888670
    },
    {
        "content": "<p>also prevents</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Functor</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">BadOption</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">map</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">Fn</span><span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">BadOption</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// Problem! `U != Option&lt;T&gt;`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249414468,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628888773
    },
    {
        "content": "<p>Interesting- Item should be referring to <code>T</code> directly here, I think, but yeah- that's pretty much the point :)</p>\n<p>It doesn't enforce <code>laws</code> in the category theory sense, but it does prevent \"illegal\" abstractions such as those which care too much about the details.</p>\n<p>I'll note that I had to add a clause at the end of <a href=\"#narrow/stream/144729-wg-traits/topic/GATs.2C.20MPTCs.2C.20and.20Type.20Parameters.20on.20.60Self.60/near/249412920\">the above formalization</a> which constrains the updated Self type to not refer to <code>Functor with updates</code> but <em>literally the implementing type</em> but with the new associations.</p>\n<p><code>Self</code> already does this, but it helps to clarify why this is not an equivalent ask to simply saying <code>Self&lt;T = ...&gt;</code> somehow equates to <code>Functor&lt;T = ...&gt;</code>, which would allow <code>Option</code> to return <code>Result</code> etc again.</p>",
        "id": 249414778,
        "sender_full_name": "Zoey",
        "timestamp": 1628888951
    },
    {
        "content": "<blockquote>\n<p>I'll note that I had to add a clause at the end</p>\n</blockquote>\n<p>That makes sense. Otherwise, I would expect some <code>U: Functor&lt;Item = B&gt;</code> where <code>U</code> is returned</p>",
        "id": 249415804,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628889506
    },
    {
        "content": "<p>Yeah, I think it's important for Self to remain conceptually-consistent with its current meaning, and that clause ensures that we don't surprise people.</p>\n<p>I think I'm starting to see an actual possibility for an RFC taking shape here... I'm not sure where to begin with actually writing one, but I could learn. Would you agree that this seems doable and simple enough to be desirable?</p>",
        "id": 249415897,
        "sender_full_name": "Zoey",
        "timestamp": 1628889590
    },
    {
        "content": "<p>Interestingly, when you can write <code>where T::Item == Foo</code>, I would if you could write <code>where Self::Item == Foo</code></p>",
        "id": 249415968,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628889627
    },
    {
        "content": "<p>Isn't that currently possible already?</p>",
        "id": 249416028,
        "sender_full_name": "Zoey",
        "timestamp": 1628889676
    },
    {
        "content": "<p>This seems doable and simple enough to be desirable, given that it solves a class of problems not currently solvable.</p>",
        "id": 249416062,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628889702
    },
    {
        "content": "<p>Nope</p>",
        "id": 249416065,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628889707
    },
    {
        "content": "<p>Can you give an example of using that last bit you suggested, and how it differs from what I proposed?</p>",
        "id": 249416120,
        "sender_full_name": "Zoey",
        "timestamp": 1628889728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/GATs.2C.20MPTCs.2C.20and.20Type.20Parameters.20on.20.60Self.60/near/249416062\">said</a>:</p>\n<blockquote>\n<p>This seems doable and simple enough to be desirable, given that it solves a class of problems not currently solvable.</p>\n</blockquote>\n<p>I've been looking at building a category hierarchy based on the <code>Id</code> GAT but I'd be willing to switch my efforts to this if I'd have your support and advice.</p>",
        "id": 249416174,
        "sender_full_name": "Zoey",
        "timestamp": 1628889787
    },
    {
        "content": "<p>See <a href=\"https://github.com/rust-lang/rust/issues/87471\">#87471</a> though</p>",
        "id": 249416288,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628889869
    },
    {
        "content": "<p>I'm pretty strapped for time, but given that there's general support from the lang team, I wouldn't mind mentoring (or attempting to; not even sure where I'd begin)</p>",
        "id": 249416363,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628889924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/GATs.2C.20MPTCs.2C.20and.20Type.20Parameters.20on.20.60Self.60/near/249416288\">said</a>:</p>\n<blockquote>\n<p>See <a href=\"https://github.com/rust-lang/rust/issues/87471\">#87471</a> though</p>\n</blockquote>\n<p>I'm not sure this is required to implement the feature I described- and seems to be orthogonal; such a feature could potentially add some work around where we substitute symbolically but I don't see anything that would block either RFC.</p>",
        "id": 249416527,
        "sender_full_name": "Zoey",
        "timestamp": 1628890011
    },
    {
        "content": "<p>You're correct. Completely orthogonal and just a thought</p>",
        "id": 249416551,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890028
    },
    {
        "content": "<p>If you're serious about pursuing this, I would start by outlining<br>\n1) What is a problem/class of problems that existing/planned features can't solve.<br>\n2) What is the general syntax/feature that you're proposing.<br>\n3) How the feature can solve those problem(s).</p>\n<p>And probably open a lang-team MCP. I'm really not quite sure if they want to start another initiative, but like I said, if there's support, I'm willing to be a liaison.</p>",
        "id": 249416903,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890295
    },
    {
        "content": "<p>Hm- reading the guide for MCPs, it looks like it describes a \"lightweight RFC\" for \"non-user-facing\" changes. Wouldn't a full RFC be more appropriate?</p>",
        "id": 249417115,
        "sender_full_name": "Zoey",
        "timestamp": 1628890431
    },
    {
        "content": "<p>Maybe it's just called a \"proposal\" now</p>",
        "id": 249417345,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890594
    },
    {
        "content": "<p><a href=\"https://lang-team.rust-lang.org/initiatives/process.html\">https://lang-team.rust-lang.org/initiatives/process.html</a></p>",
        "id": 249417346,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890596
    },
    {
        "content": "<p>Yes, there's an issue template on <a href=\"https://github.com/rust-lang/lang-team\">https://github.com/rust-lang/lang-team</a></p>",
        "id": 249417403,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890635
    },
    {
        "content": "<p>Are you on the lang team? You mentioned you'd be willing to be the <code>liaison</code>, but this document restricts that role to lang-team membership.</p>",
        "id": 249417443,
        "sender_full_name": "Zoey",
        "timestamp": 1628890673
    },
    {
        "content": "<p>Oh does it? I thought I remember at some point it being not necessarily lang team members</p>",
        "id": 249417686,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890828
    },
    {
        "content": "<p>So, you'd have to find someone from the lang team interested enough to be liaison</p>",
        "id": 249417716,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890858
    },
    {
        "content": "<p><code>A lang team member can decide to be your liaison and second your proposal.</code> - it doesn't say that a liaison must be from the lang-team, but it does say that a lang-team member can be a liaison.</p>\n<p>Sadly, <a href=\"https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html\">https://lang-team.rust-lang.org/initiatives/process/roles/liaison.html</a> <em>does</em> restrict it to lang-team membership.</p>",
        "id": 249417739,
        "sender_full_name": "Zoey",
        "timestamp": 1628890875
    },
    {
        "content": "<p>Well, nonetheless, you can still open an initiative issue. I'm still willing to mentor</p>",
        "id": 249417877,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628890980
    },
    {
        "content": "<p>Any chance you know of a good way to find a lang-team member who may be interested, or should I start by writing it up, <em>then</em> find someone interested in liaison-ing? The guide recommends identifying a potential owner prior to a proposal, but doesn't require a liaison until after filing.</p>\n<p>I don't know if I'm qualified to be the <code>Owner</code> yet, according to this document, as I've not yet worked on RustC internals, but it does say that delegation of that portion is an option.</p>",
        "id": 249418045,
        "sender_full_name": "Zoey",
        "timestamp": 1628891142
    },
    {
        "content": "<p>Unsure if we could \"co-own\", or if that's even necessarily. These are questions for <span class=\"user-group-mention\" data-user-group-id=\"1977\">@T-lang</span></p>",
        "id": 249418046,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891142
    },
    {
        "content": "<p>I would probably start by filling out the initiative issue (<a href=\"https://github.com/rust-lang/lang-team/blob/master/.github/ISSUE_TEMPLATE/initiative_proposal.md\">https://github.com/rust-lang/lang-team/blob/master/.github/ISSUE_TEMPLATE/initiative_proposal.md</a>)</p>",
        "id": 249418214,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891276
    },
    {
        "content": "<p>That would get a good way there in terms of \"presenting it\" to people</p>",
        "id": 249418285,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891308
    },
    {
        "content": "<p>Then maybe either open an issue, or make a post in <a class=\"stream\" data-stream-id=\"213817\" href=\"/#narrow/stream/213817-t-lang\">#t-lang</a> and see what people think</p>",
        "id": 249418326,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891340
    },
    {
        "content": "<p>Alright- I'll do a preliminary writeup in t-lang, then file an initiative. I think we've done the <code>Talk about it on internals, Zulip, etc to flesh it out a bit</code> step quite a bit, since it reduced it from \"This needs variadic types, HKT, and universal type qualifiers\" to \"Actually, this helps provide HKT, and could theoretically be syntactic sugar\"</p>",
        "id": 249418468,
        "sender_full_name": "Zoey",
        "timestamp": 1628891435
    },
    {
        "content": "<p>Well, I wouldn't necessarily say one day's discussion is \"fleshing it out\"</p>",
        "id": 249418533,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891484
    },
    {
        "content": "<p>but it's a start :)</p>",
        "id": 249418539,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891488
    },
    {
        "content": "<p>Yeah, we haven't been the most thorough yet- but it is vastly simpler than the original comment- and, unlike that comment, it's not a question, it's a potential answer.</p>",
        "id": 249418629,
        "sender_full_name": "Zoey",
        "timestamp": 1628891544
    },
    {
        "content": "<p>Anyways, gotta run now.</p>",
        "id": 249419037,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891830
    },
    {
        "content": "<p>Keep me posted!</p>",
        "id": 249419045,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628891835
    },
    {
        "content": "<p>Oh, quickly. Just thought. But you could potentially imagine that an alternative way to think about this:</p>",
        "id": 249419345,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892013
    },
    {
        "content": "<p>Is if a trait had an associated type <code>Self</code> with generics for each other associated type</p>",
        "id": 249419346,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892013
    },
    {
        "content": "<p>Err wait</p>",
        "id": 249419394,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892035
    },
    {
        "content": "<p>Hold on (on mobile now)</p>",
        "id": 249419415,
        "sender_full_name": "Jack Huey",
        "timestamp": 1628892052
    }
]