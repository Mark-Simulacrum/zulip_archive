[
    {
        "content": "<blockquote>\n<p>This looks like a higher-order unification problem</p>\n</blockquote>\n<p>It's a bit easier in our case, as they must be fully generic to be defining and so we can just (yes it's actually easy), substitute all generic params with new ones in both cases and then compare the hidden types. So <code>Foo&lt;T, U&gt; = (t, u)</code> and <code>Foo&lt;U, T&gt; = (u, t)</code>both become <code>Foo&lt;?X, ?Y&gt; = (_: ?X, _: ?Y)</code>, and are thus equal</p>",
        "id": 263464493,
        "sender_full_name": "oli",
        "timestamp": 1638462951
    },
    {
        "content": "<p>(I don't know how this cool type check stuff works so I'm sorry in advance) </p>\n<p>Wouldn't there be a problem with something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Copy, Clone)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">define_foo</span><span class=\"o\">&lt;</span><span class=\"n\">U</span>: <span class=\"nb\">Copy</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">u</span>: <span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">t</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Foo&lt;?X, ?Y&gt; = (?X, ?Y, ?X)</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Foo&lt;?X, ?Y&gt; = (?X, ?Y, ?Y)</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Or does this work differently? Or we disallow this anyway for some reason?</p>",
        "id": 263773684,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638718193
    },
    {
        "content": "<p>This already doesn't work because all defining uses must be fully generic</p>",
        "id": 263774462,
        "sender_full_name": "oli",
        "timestamp": 1638719367
    },
    {
        "content": "<p>Technically we could allow some of these by checking whether there is at least one fully generic defining use, but for now it keeps me comfortable with the impl to stick with the restrictive version</p>",
        "id": 263774541,
        "sender_full_name": "oli",
        "timestamp": 1638719471
    },
    {
        "content": "<p>\"Fully generic\" means that if a type has generics (like \"<code>Tuple3&lt;A, B, C&gt;</code> / <code>(A, B, C)</code>\" in my example), then all of them must be filled from generics of TAIT, right?</p>",
        "id": 263774713,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1638719716
    },
    {
        "content": "<p>Yes, and all trait bounds on these must match up</p>",
        "id": 263787662,
        "sender_full_name": "oli",
        "timestamp": 1638736640
    },
    {
        "content": "<p>So your function can't have fewer bounds than the type alias</p>",
        "id": 263787824,
        "sender_full_name": "oli",
        "timestamp": 1638736811
    }
]