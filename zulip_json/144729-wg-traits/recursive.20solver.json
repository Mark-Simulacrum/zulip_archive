[
    {
        "content": "<p>I'm still working on the writeup here -- on vacation in New York City this weekend :) -- but I wanted to drop a note to <a href=\"https://gist.github.com/nikomatsakis/bfbdbe588d6fc61ecb09e3b51847fb7c\" target=\"_blank\" title=\"https://gist.github.com/nikomatsakis/bfbdbe588d6fc61ecb09e3b51847fb7c\">this gist</a> where I'm leaving some notes about my thoughts on returning to a recursive solver for chalk and how it might help with the associated type ambiguity problem. (I didn't get to that last part yet, really ;)</p>",
        "id": 188374760,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581943115
    },
    {
        "content": "<p>will post some notes in it when I get chance</p>",
        "id": 188374777,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1581943135
    },
    {
        "content": "<p>I pushed the remaining notes here -- sorry again for not catching up on the other topics, will do so on Monday &lt;3</p>",
        "id": 188813573,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582371354
    },
    {
        "content": "<p>The connection between the recursive solver and the associated type ambiguity problem is not clear to me -- would it not be possible to implement the priority logic in the SLG solver?</p>",
        "id": 188814373,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582372664
    },
    {
        "content": "<p>Also, I don't really understand <em>how</em> the solver is supposed to work and is different than the current</p>",
        "id": 188820591,
        "sender_full_name": "Jack Huey",
        "timestamp": 1582383321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> my understanding is that the difference is that <em>each subgoal</em> returns either a unique solution or 'ambiguous', while in the current solver a subgoal can return multiple solutions and only the top-level turns that into ambiguity.</p>\n<p>I guess that's the connection to the associated type ambiguity -- the SLG solver might have to return both possible solutions to the type normalization (the real one and the placeholder) for correctness, while the recursive solver can't do that anyway. But it's not clear to me that that's really the case for SLG -- with my naive understanding of how it works, I can imagine it stopping after it has found a solution with the 'high-priority' subgoal and skipping the equivalent 'low-priority' one (I guess that's maybe similar to other solutions proposed in the past?)</p>",
        "id": 188821249,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1582384438
    },
    {
        "content": "<p>Ah, that makes sense I think.</p>",
        "id": 188821360,
        "sender_full_name": "Jack Huey",
        "timestamp": 1582384591
    },
    {
        "content": "<p>For SLG, what you're talking about is the \"cut\" idea <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> was talking about on the issue thread. I think it <em>might</em> be possible to conditionally generate the fallback if the normalization clause can't be generated. But it doesn't align really well with the idea of \"generating all possible answers\"</p>",
        "id": 188821447,
        "sender_full_name": "Jack Huey",
        "timestamp": 1582384779
    },
    {
        "content": "<p>So, <span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span>, I think maybe you already worked your way to my answer, but to clarify. The connection I see is this. In the \"recursive\" solver, we fully compute <strong>a single answer</strong> from each query and we don't do any dependent work until that answer is ready (with the exception of cycles). This makes it (relatively) easy to allow some answers to \"override\" others before they propagate out.</p>\n<p>I'm not sure how to do that in the \"non-recursive\" setup -- it seems to me it would be much harder.</p>\n<p>That said, the other reason thing that I think may be useful about the recursive solver is precisely that it may use less time/memory, basically for the same reason, though at the cost of completeness (as I mentioned). </p>\n<p>I'm not really sure which approach is best, idealy we'd have some room to experiment with both.</p>",
        "id": 188947665,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1582565776
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> I've revived the old recursive solver in a branch <a href=\"https://github.com/flodiebold/chalk/tree/recursive-solver\" target=\"_blank\" title=\"https://github.com/flodiebold/chalk/tree/recursive-solver\">here</a>. It's passing a lot of tests, but also failing a few; I haven't looked into the test failures though</p>",
        "id": 190020506,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583687239
    },
    {
        "content": "<p>just from a quick glance, it's probably failing the coinductive tests</p>",
        "id": 190020712,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583687626
    },
    {
        "content": "<p>no coinductive tests are failing, but I only changed the default solver choice, so the later ones which specify the slg solver parameters still run with that one</p>",
        "id": 190020781,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583687759
    },
    {
        "content": "<p>here are the failing tests:</p>\n<div class=\"codehilite\"><pre><span></span>failures:\n    test::auto_traits::auto_semantics\n    test::coherence::nonoverlapping_assoc_types\n    test::coherence_goals::fundamental_types\n    test::cycle::overflow\n    test::existential_types::dyn_Foo_Bar\n    test::existential_types::dyn_binders_reverse\n    test::misc::subgoal_abstraction\n    test::misc::subgoal_cycle_inhabited\n    test::misc::subgoal_cycle_uninhabited\n    test::projection::normalize_under_binder_multi\n    test::projection::projection_from_env_slow\n    test::unify::unify_quantified_lifetimes\n    test::wf_lowering::assoc_type_recursive_bound\n    test::wf_lowering::higher_ranked_cyclic_requirements\n</pre></div>",
        "id": 190020825,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583687781
    },
    {
        "content": "<p>ohh</p>",
        "id": 190021304,
        "sender_full_name": "Jack Huey",
        "timestamp": 1583688670
    },
    {
        "content": "<p>oh, interesting</p>",
        "id": 190077752,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583765971
    },
    {
        "content": "<p>I was starting a branch re-implementing the recursive solver</p>",
        "id": 190077773,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583765981
    },
    {
        "content": "<p>but maybe starting from the old code is a good idea, indeed</p>",
        "id": 190077964,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583766066
    },
    {
        "content": "<p>You might be able to easily reimplement it from scratch; I thought I'd probably get farther this way ;)</p>",
        "id": 190078168,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583766168
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> maybe but I suspect this would be faster :)</p>",
        "id": 190080220,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583767281
    },
    {
        "content": "<p>skimming the code now</p>",
        "id": 190080225,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583767283
    },
    {
        "content": "<p>side note that I was wondering whether having a chalk-engine crate with callbacks into chalk-solve was a real win</p>",
        "id": 190080313,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583767325
    },
    {
        "content": "<p>given that rustc would integrate at the chalk-solve level, and not chalk-engine level</p>",
        "id": 190080335,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583767338
    },
    {
        "content": "<p>one difference is that it invokes <code>program_clauses_for_goal</code> to get the callbacks, which is going to include the results from the environment; the old logic of finding <code>env_solution</code> prog_solution` needs to be updated</p>",
        "id": 190080448,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583767386
    },
    {
        "content": "<p>the main point of that logic was to rationalize some of rustc's more \"curious\" behavior</p>",
        "id": 190080508,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583767418
    },
    {
        "content": "<p>I think the call to <code>program_clauses_for_goal</code> also doesn't deal correctly with bound vars. It's causing the <code>dyn_Foo_Bar</code> test to fail. I'm just calling <code>program_clauses_for_goal</code> with the canonicalized value, and I don't think it's handling that correctly</p>",
        "id": 190080874,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583767602
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> btw are you hacking on this stuff? do you want me to take a look?</p>",
        "id": 190224618,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583874292
    },
    {
        "content": "<p>I am hacking on it a bit, I'll see how far I get</p>",
        "id": 190228247,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583876126
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I'm wondering if you have an idea how to integrate the caching for the recursive solver with Salsa, though. In principle it seems straightforward, but in practice I think the cycle handling makes it more complicated</p>",
        "id": 190289124,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1583938013
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> I do have thoughts, but it involves modifying salsa somewhat</p>",
        "id": 190336248,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583963737
    },
    {
        "content": "<p>I may try to pull in some of your changes from branch and do some tinkering, but I think you should go on changing</p>",
        "id": 190336269,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583963756
    },
    {
        "content": "<p>I don't think there's a \"perfect answer\" when it comes to salsa -- i.e., I'm not sure what mechanism we can add that can't be misused -- but it should be possible to make some \"opt-in\" way for salsa to accept cyclic queries like this one</p>",
        "id": 190336343,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583963794
    },
    {
        "content": "<p>perhaps with a few \"modes\" of operation -- the \"re-execute until a consistent response is reached\" mode is not bad (i.e., \"Tabled prolog execution\")</p>",
        "id": 190336357,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1583963811
    },
    {
        "content": "<p>hmm... there's this test:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"w\">        </span><span class=\"n\">program</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">struct</span> <span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">struct</span> <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Vec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">forall</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">T</span>: <span class=\"nb\">Iterator</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">exists</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&gt;</span>::<span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&gt;</span>::<span class=\"n\">Item</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">yields</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// True for `U = T`, of course, but also true for `U = Vec&lt;T&gt;`.</span>\n<span class=\"w\">            </span><span class=\"s\">&quot;Ambiguous&quot;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>I fail to understand how that can be true. With <code>U = Vec&lt;T&gt;</code>, <code>&lt;U as Iterator&gt;::Item = T</code>, and there's no reason why <code>&lt;T as Iterator&gt;::Item = T</code> would hold? Is this test just succeeding because of <a href=\"https://github.com/rust-lang/chalk/issues/234\" target=\"_blank\" title=\"https://github.com/rust-lang/chalk/issues/234\">rust-lang/chalk#234</a>?</p>",
        "id": 190842866,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584449813
    },
    {
        "content": "<p>goal 3 of <code>normalize_under_binder</code> seems to be another example that's not actually ambiguous</p>",
        "id": 190844428,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584450565
    },
    {
        "content": "<p>also goal 1</p>",
        "id": 190844674,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584450680
    },
    {
        "content": "<p>(I've implemented the lower priority for the fallback clause, but haven't implemented the \"are the inputs equal\" check yet, and am looking for a test that fails because of it to understand better how the check needs to work...)</p>",
        "id": 190844850,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584450756
    },
    {
        "content": "<p>I think I've found my example, and am starting to get an idea... I'm thinking to substitute the found solutions into the domain goal we're trying to solve, get the 'inputs' of the substituted domain goal, and check whether they're equal</p>",
        "id": 190857834,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584456491
    },
    {
        "content": "<p>hmm, I think you're right that the comment is confused.</p>",
        "id": 190879149,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584464355
    },
    {
        "content": "<p>btw awesome <span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> to hear you are making progress! I'd like to take a look, is it in that same branch?</p>",
        "id": 190902137,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584474737
    },
    {
        "content": "<p>Yes, I'm not sure whether I pushed everything</p>",
        "id": 190904469,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584475766
    },
    {
        "content": "<p>I did push everything, it's very much WIP and not very nice code in the places where I fixed things though ;)</p>",
        "id": 190960057,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584526477
    },
    {
        "content": "<p>Here's another failure:</p>\n<div class=\"codehilite\"><pre><span></span>goal { exists &lt; &#39;a &gt; { forall &lt; &#39;b &gt; { exists &lt; &#39;c &gt; { &#39;a = &#39;c, &#39;c = &#39;b } } } }\nusing solver: Recursive { overflow_depth: 100, caching_enabled: false }\nexpected:\nUnique; for&lt;?U0&gt; { substitution [?0 := &#39;^0, ?1 := &#39;!1_0], lifetime constraints [InEnvironment { environment: Env([]), goal: &#39;^0 == &#39;!1_0 }] }\nactual:\nUnique; for&lt;?U0&gt; { substitution [?0 := &#39;^0, ?1 := &#39;^0], lifetime constraints [InEnvironment { environment: Env([]), goal: &#39;^0 == &#39;!1_0 }] }\n</pre></div>\n\n\n<p>those are equivalent, right? or is it a requirement that the <code>^0</code> gets substituted there?</p>",
        "id": 190960152,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584526532
    },
    {
        "content": "<p>I've implemented the 'are the inputs the same' check in a crude way, and also added floundering on too-general goals and goal truncation similar to the SLG solver (also in a crude way <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> ). I'm down to 3 failures, the one above and two that seem to be infinite-looping...</p>",
        "id": 190977262,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584537117
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ok, the infinite loop actually is caused by the <code>AliasEq</code> logic... it's kind of complicated:</p>\n<div class=\"codehilite\"><pre><span></span>WellFormed(str: Sized)\n-&gt; Implemented(str: Sized)\n   -&gt; FromEnv(str: Sized)\n      -&gt; AliasEq(&lt;i32 as Foo&gt;::Item = str)\n         -&gt; Normalize(&lt;i32 as Foo&gt;::Item -&gt; str)\n            -&gt; Implemented(&lt;i32 as Foo&gt;::Item: Sized)\n               -&gt; AliasEq(&lt;i32 as Foo&gt;::Item = ^0) &amp;&amp; FromEnv(^0: Sized)\n                  -&gt; Normalize(&lt;i32 as Foo&gt;::Item -&gt; ^0)\n                     - Implemented(&lt;i32 as Foo&gt;::Item: Sized) gives cycle error; first attempt: no solution\n                  hence ^0 = (Foo::Item)&lt;i32&gt;\n                  hence Implemented(&lt;i32 as Foo&gt;::Item: Sized) has solution\n\n               -&gt; AliasEq(&lt;i32 as Foo&gt;::Item = ^0) &amp;&amp; FromEnv(^0: Sized)\n                  -&gt; Normalize(&lt;i32 as Foo&gt;::Item -&gt; ^0)\n                     - Implemented(&lt;i32 as Foo&gt;::Item: Sized) gives cycle error; second attempt: has solution\n                  hence ^0 = str\n                  but trying to then prove FromEnv(str: Sized) gives cycle error -&gt; no solution\n                  hence Implemented(&lt;i32 as Foo&gt;::Item: Sized) has no solution\n</pre></div>\n\n\n<p>so while trying to prove <code>Implemented(&lt;i32 as Foo&gt;::Item: Sized)</code>, we oscillate between having a solution and having no solution and never exit the loop. The loop for dealing with cycles is based on the assumption that the solution will increase under <a href=\"https://github.com/flodiebold/chalk/blob/5b3f5b91541706dc13475c0a5bb72e27c6334cb4/chalk-solve/src/recursive/mod.rs#L208-L216\" target=\"_blank\" title=\"https://github.com/flodiebold/chalk/blob/5b3f5b91541706dc13475c0a5bb72e27c6334cb4/chalk-solve/src/recursive/mod.rs#L208-L216\">this partial order</a>, but the prioritization logic kind of breaks this by giving a completely different answer.</p>\n<p>any idea how to salvage this?</p>",
        "id": 191029175,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1584559165
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> yeah I had though about this and expected to take prioritization into account</p>",
        "id": 191044462,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584566858
    },
    {
        "content": "<p>basically to say that we remember the priority</p>",
        "id": 191044473,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584566870
    },
    {
        "content": "<p>anyway I'll have to look into the code a bit more deeply to say this more precisely</p>",
        "id": 191044571,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584566918
    },
    {
        "content": "<p>but in short I think that we can treat a higher priority answer as \"subsuming\" a lower priority answer -- i.e., where you would've used the lower priority one, you should be able to use the higher priority one too equivalently (interstingly, this ought to be true \"globally\" of Rust programs, but perhaps not \"locally\" -- i.e., if some associated type is supposed to have a bound <code>type T: Debug</code>, and you supply a value that is not <code>Debug</code></p>",
        "id": 191044650,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584566993
    },
    {
        "content": "<p>then the placeholder would be considered <code>Debug</code> but the true type would not</p>",
        "id": 191044668,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584567002
    },
    {
        "content": "<p>there would be an error in the WF checking for the impl of course</p>",
        "id": 191044733,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1584567013
    },
    {
        "content": "<p>to give an update here, I implemented something that keeps track of the priority and lets a high-priority answer just override the low-priority one, which fixes the loop, though the tests still fail because they give different answers than SLG now</p>",
        "id": 191673028,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585084358
    },
    {
        "content": "<p>I also tried using the recursive solver with rust-analyzer, but it seems there's another endless loop which I haven't investigated yet...</p>",
        "id": 191673105,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585084397
    },
    {
        "content": "<blockquote>\n<p>the tests still fail because they give different answers than SLG now</p>\n</blockquote>\n<p>and I'm not sure whether it's a <em>requirement</em> that we give the same answer as SLG in IMO nonsensical cases like the one in that test, which is basically</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span>: <span class=\"nb\">Sized</span> <span class=\"nc\">where</span><span class=\"w\"> </span><span class=\"n\">Self</span>::<span class=\"n\">Item</span>: <span class=\"nb\">Sized</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// not Sized</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>I mean, at least that doesn't make sense to me...</p>",
        "id": 191753158,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585146643
    },
    {
        "content": "<blockquote>\n<p>I also tried using the recursive solver with rust-analyzer, but it seems there's another endless loop which I haven't investigated yet...</p>\n</blockquote>\n<p>Ok, I fixed that, and RA works with the recursive solver now. It fixes about 500 unknown types in the RA codebase, which is a good number, though less than I'd have hoped. And it's a lot slower, making RA take about double the time for type inference</p>",
        "id": 192055413,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585331474
    },
    {
        "content": "<p>(probably there's some low-hanging fruit somewhere though, and there's a lot of potential for better caching)</p>",
        "id": 192055544,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585331531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> what do you think about moving the floundering-on-too-general-goals logic to the program clauses code? I think it makes sense to share it between the solvers, and also I needed to add floundering for too general <code>Normalize</code> goals (since the program clauses logic for them also will try to enumerate all impls). and it just feels like the program clauses logic actually knows better what goals are too general</p>",
        "id": 192371873,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585651407
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> I'm not sure which logic you're referring to exactly -- the logic that prevents things from being enumerated currently lives in the chalk-solve code, which I would expect to be shared by the recursive solver</p>",
        "id": 192381706,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585657849
    },
    {
        "content": "<p>it lives in <a href=\"https://github.com/rust-lang/chalk/blob/1ac0d00e61b427964c2b9b10e21bd8cd183e5932/chalk-solve/src/solve/slg.rs#L188-L212\" title=\"https://github.com/rust-lang/chalk/blob/1ac0d00e61b427964c2b9b10e21bd8cd183e5932/chalk-solve/src/solve/slg.rs#L188-L212\"><code>chalk_solve::solve::slg</code></a>, so I have to move it <em>somewhere</em> to share it.</p>\n<p>but also, for the <code>Normalize</code> floundering logic, I need it to <em>not</em> return ambiguous if we have a goal like <code>Normalize(&lt;?0 as SomeTrait&gt;::Assoc -&gt; SomeTrait::Assoc&lt;SomeType&gt;)</code>, because we <em>know</em> this particular goal won't have a solution, and if we return ambiguous there, it breaks things (because then the <code>AliasEq(&lt;?0 as SomeTrait&gt;::Assoc = SomeTrait::Assoc&lt;SomeType&gt;)</code> will also be ambiguous). So the logic becomes more intertwined with the program clauses logic there</p>",
        "id": 192382487,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585658276
    },
    {
        "content": "<p>I see. Yeah I have no problem moving that logic to <code>program_clauses_for_goal</code></p>",
        "id": 192382946,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585658482
    },
    {
        "content": "<p>In fact I sort of thought that's where it lived already</p>",
        "id": 192382957,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585658488
    },
    {
        "content": "<p>I'm not sure I understand the Normalize case yet</p>",
        "id": 192382994,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585658512
    },
    {
        "content": "<p>(How do we know that won't have a solution, for one thing?)</p>",
        "id": 192383137,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585658575
    },
    {
        "content": "<p>Do we return ambiguous today? I thought that the flounder logic applied only to <code>Implemented</code> goals...?</p>",
        "id": 192383177,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585658592
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/192383177\" title=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/192383177\">said</a>:</p>\n<blockquote>\n<p>Do we return ambiguous today? I thought that the flounder logic applied only to <code>Implemented</code> goals...?</p>\n</blockquote>\n<p>We don't, but when testing the recursive solver with RA, I ran into it trying to enumerate all impls for <code>Iterator</code> to solve something like <code>Normalize(&lt;?0 as Iterator&gt;::Item -&gt; Something)</code>. I <em>think</em> we should apply the same logic as for <code>Implemented</code> goals there.</p>\n<blockquote>\n<p>(How do we know that won't have a solution, for one thing?)</p>\n</blockquote>\n<p>hmm maybe I have a misunderstanding here, but I think nothing can ever <code>Normalize</code> to an assoc type placeholder since the right-hand side of <code>Normalize</code> is always some type written by a user, and you can't write assoc type placeholders. (When we have something like <code>type Item = &lt;T as OtherTrait&gt;::OtherType</code>, I think that would still be a <code>TyData::Alias</code>?)</p>",
        "id": 192384606,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585659288
    },
    {
        "content": "<p>That's not true, it could normalize to an associated type placeholder. For example, you might have</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">A</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">A</span>::<span class=\"n\">Item</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">baz</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">...</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"kt\">u32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"p\">...</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 192388717,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585661217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/192384606\" title=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/192384606\">said</a>:</p>\n<blockquote>\n<p>We don't, but when testing the recursive solver with RA, I ran into it trying to enumerate all impls for <code>Iterator</code> to solve something like <code>Normalize(&lt;?0 as Iterator&gt;::Item -&gt; Something)</code>. I <em>think</em> we should apply the same logic as for <code>Implemented</code> goals there.</p>\n</blockquote>\n<p>so this is an interesting question too. The compiler never uses the <code>-&gt; Something</code> part to figure out the result -- it looks purely at the inputs. And, I suspect, it probably has a rule  about unknown self types. At minimum, that would yield an ambiguous result when looking for trait impls, which would lead to overall ambiguity I think.</p>\n<p>I have been debating with myself over time whether we would <em>want</em> to be able to (e.g.) deduce what <code>?0</code> is based on the <em>target type</em> of the normalization. There are some scenarios where it would be uesful. We have some special case hacks in the compiler, for example, to handle things like <code>let x: u32 = 22 + 44</code>, which requires us to deduce that 22 and 44 must be <code>u32</code> because the <em>output type</em> is <code>u32</code>.</p>",
        "id": 192388954,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585661343
    },
    {
        "content": "<p>But I'd be happy to match rustc's behavior for now.</p>",
        "id": 192388976,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585661356
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> so i'm reading over the recursive solver branch again</p>",
        "id": 192391259,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585662325
    },
    {
        "content": "<p>it looks reasonably close to what I envisioned</p>",
        "id": 192391273,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585662334
    },
    {
        "content": "<p>which tests are you currently looking at?</p>",
        "id": 192391281,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585662339
    },
    {
        "content": "<p>I see a few obvious refactorings I had in mind, though not critical to the problems we were discussing</p>\n<ul>\n<li>refactoring the <code>program_clauses_for_goal</code> and <code>program_clauses_for_env</code> logic a bit. </li>\n<li>separating out the \"global cache\" from the \"per-thread solver\", to allow for better multi-thread integration in rust-analyzer etc</li>\n</ul>",
        "id": 192391495,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585662442
    },
    {
        "content": "<ul>\n<li>remove the overflow checking and replace with truncation logic instead</li>\n</ul>",
        "id": 192391733,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585662555
    },
    {
        "content": "<ul>\n<li>convert tests to run with <em>both</em> solvers, like they used to?</li>\n</ul>",
        "id": 192391782,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585662579
    },
    {
        "content": "<p>( I was wondering in particular if it'd be good to land the solver in tree so we can collaborate a bit more on it -- or maybe it's good living where it is, or even could land on a branch in rust-lang?)</p>",
        "id": 192391875,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585662604
    },
    {
        "content": "<p>1 and 4 are already on my list <span aria-label=\"slight smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"slight smile\">:slight_smile:</span> as to 3... I did add truncation (I don't know whether in the right place), so I don't actually know whether the overflow check is still necessary</p>",
        "id": 192392059,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585662672
    },
    {
        "content": "<p>so, the problem why I wanted to cut <code>Normalize(&lt;?0 as SomeTrait&gt;::Assoc -&gt; SomeTrait::Assoc&lt;SomeType&gt;)</code> short was that <code>AliasEq(&lt;?0 as SomeTrait&gt;::Assoc = SomeTrait::Assoc&lt;SomeType&gt;)</code> shows up as a goal that I think we need to be able to solve. The concrete case was the <code>lowering::assoc_tys</code> test, where it'll need to solve <code>Implemented((Iterator::Item)&lt;!1_0&gt;: Foo)</code> in <code>Env([for&lt;&gt; FromEnv(!1_0: Iterator), FromEnv(&lt;!1_0 as Iterator&gt;::Item)])</code> at some point, and that requires <code>AliasEq(&lt;^0.0 as Iterator&gt;::Item = (Iterator::Item)&lt;!1_0&gt;)</code> since it unifies it with <code>Implemented(&lt;?0 as Iterator&gt;::Item: Foo)</code>. Solving <code>AliasEq(&lt;^0.0 as Iterator&gt;::Item = (Iterator::Item)&lt;!1_0&gt;)</code> seems like it should be easy, but if the <code>Normalize</code> rule returns ambiguous we have no way of making progress</p>",
        "id": 192395007,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585663990
    },
    {
        "content": "<p>I thought it'd make sense to land the solver once the tests work with both solvers</p>",
        "id": 192398625,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1585665680
    },
    {
        "content": "<p>Regarding <code>test::unify::unify_quantified_lifetimes</code>, I think the new output is equivalent, i'm not 100% sure why it turns out different but it seems 'ok'</p>",
        "id": 192422083,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1585675641
    },
    {
        "content": "<p>I'm now running all tests for both solvers by default (except for the lowering tests, which hides at least one test failure currently)</p>",
        "id": 192952934,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586082856
    },
    {
        "content": "<p>also, I refactored the env clauses handling a bit; <code>program_clauses_for_env</code> didn't actually add the env clauses themselves, which seemed weird, so now it does that and I removed the corresponding code from both solvers</p>",
        "id": 192952952,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586082903
    },
    {
        "content": "<p>I've removed the <code>Normalize</code> floundering for the moment, but I think we'll need some solution there</p>",
        "id": 192952964,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586082932
    },
    {
        "content": "<p>(regarding the env clause handling, I've also removed the code that favored env solutions over program clause solutions; it didn't break any tests at the moment)</p>",
        "id": 192953247,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586083376
    },
    {
        "content": "<p>I made a <a href=\"https://github.com/rust-lang/chalk/pull/372\" title=\"https://github.com/rust-lang/chalk/pull/372\">pull request</a>, so you should even be able to push to the branch now</p>",
        "id": 192957642,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586090513
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/192953247\" title=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/192953247\">said</a>:</p>\n<blockquote>\n<p>(regarding the env clause handling, I've also removed the code that favored env solutions over program clause solutions; it didn't break any tests at the moment)</p>\n</blockquote>\n<p>yeah that's ok we can add that back later</p>",
        "id": 193097985,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586205284
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I'd like to start considering merging the branch, rebasing it over all the refactorings happening at the moment is a lot of work <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> </p>\n<p>It's working well with RA now, though I added back the floundering on Normalize because it otherwise wasn't usable</p>",
        "id": 193874322,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586858386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> Yes! I was hoping to review this morning. Sorry for the delay. Reading <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span>'s impl Trait PR right now, since I neglected that one, too.</p>",
        "id": 193875509,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859028
    },
    {
        "content": "<p>Suddenly there's a lot to review!</p>",
        "id": 193875517,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859035
    },
    {
        "content": "<p>let me check whether I've pushed the current version, though</p>",
        "id": 193875571,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586859067
    },
    {
        "content": "<p>Side note that I realized the recursive solver interacts (negatively, in a sense) with some of my plans around solving higher-ranked region constraints.</p>",
        "id": 193875693,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859128
    },
    {
        "content": "<p>But I'll worry about that later. :)</p>",
        "id": 193875706,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859134
    },
    {
        "content": "<p>In particular, I wanted to have use the SLG solver's ability to enumerate all possible solutions to figure out things like \"which regions might outlive <code>'a</code> given something like <code>forall&lt;'a&gt; { if ('b: 'a) { _: 'a } }</code></p>",
        "id": 193875808,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859218
    },
    {
        "content": "<p>but there were other problems to consider with that approach anyway</p>",
        "id": 193875814,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859226
    },
    {
        "content": "<p>Also I know I have to ping you about salsa integration, not sure if you did anything in that direction at all</p>",
        "id": 193875888,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586859259
    },
    {
        "content": "<p>I also don't know how we'll handle integer/float variables with the recursive solver, with SLG we could just have a trait <code>?0: Integer</code> in the environment, but the recursive solver might need special knowledge of them after all</p>",
        "id": 193876569,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586859710
    },
    {
        "content": "<p>Yeah, I'm kind of expecting I'll have to give way and just add them</p>",
        "id": 193877072,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586860002
    },
    {
        "content": "<p>tbh I was sort of expecting that before, for efficiency reasons</p>",
        "id": 193877094,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586860015
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> did a first pass, I didn't get to the solver itself yet, just the code around it -- the main thing is that I'd like to avoid commenting out tests and instead document the existing behavior for both sovlers (and add FIXME if needed)</p>",
        "id": 193879506,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586861542
    },
    {
        "content": "<p>really nice work btw <span aria-label=\"sparkling heart\" class=\"emoji emoji-1f496\" role=\"img\" title=\"sparkling heart\">:sparkling_heart:</span></p>",
        "id": 193879528,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586861562
    },
    {
        "content": "<p>One thing that's a bit surprising to me</p>",
        "id": 193961161,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586900994
    },
    {
        "content": "<p>is that this solver is able to handle all the coinduction tests</p>",
        "id": 193961169,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901001
    },
    {
        "content": "<p><em>ah</em> I see</p>",
        "id": 193961645,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901310
    },
    {
        "content": "<p>those tests are (for some reason) written like </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"w\">        </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">forall</span><span class=\"o\">&lt;</span><span class=\"n\">X</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"nc\">C1orC2</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">yields_all</span><span class=\"p\">[</span><span class=\"n\">SolverChoice</span>::<span class=\"n\">slg</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">)]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 193961661,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901323
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> do you remember why you did that?</p>",
        "id": 193961677,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901329
    },
    {
        "content": "<p>(as opposed to <code>yields</code>)</p>",
        "id": 193961712,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901356
    },
    {
        "content": "<p>uh</p>",
        "id": 193961761,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901365
    },
    {
        "content": "<p>hmm</p>",
        "id": 193961771,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901372
    },
    {
        "content": "<p>I wonder if that had to do with</p>",
        "id": 193961795,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901387
    },
    {
        "content": "<p>how the slg testes used to have different macros</p>",
        "id": 193961801,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901392
    },
    {
        "content": "<p>tha you unified at some point?</p>",
        "id": 193961803,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901394
    },
    {
        "content": "<p>I think it was because specifically wanted to test that no answers were given</p>",
        "id": 193961814,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901402
    },
    {
        "content": "<p>it seems like</p>",
        "id": 193961822,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901413
    },
    {
        "content": "<p>but yeah, it might have also been because of the macros</p>",
        "id": 193961824,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901415
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"w\">        </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">forall</span><span class=\"o\">&lt;</span><span class=\"n\">X</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"nc\">C1orC2</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">yields</span><span class=\"p\">[</span><span class=\"n\">SolverChoice</span>::<span class=\"n\">slg</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">)]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"s\">&quot;No possible solution&quot;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 193961826,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901415
    },
    {
        "content": "<p>is more or less equivalent?</p>",
        "id": 193961829,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901420
    },
    {
        "content": "<p>the only reason I mention it is that the recursive solver doesn't support <code>yields_all</code></p>",
        "id": 193961840,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901430
    },
    {
        "content": "<p>and it'd be nice for the tests to be \"as analogous as possible\"</p>",
        "id": 193961850,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901443
    },
    {
        "content": "<p>but doesn't matter that much</p>",
        "id": 193961851,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901444
    },
    {
        "content": "<p>in any case the recursive solver does indeed fail  here</p>",
        "id": 193961861,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901455
    },
    {
        "content": "<p>as expected</p>",
        "id": 193961871,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901459
    },
    {
        "content": "<p>if you mean <code>yields</code> there?</p>",
        "id": 193961873,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901463
    },
    {
        "content": "<p>which is good because otherwise I was quite confused</p>",
        "id": 193961874,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901464
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"w\">        </span><span class=\"n\">goal</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">forall</span><span class=\"o\">&lt;</span><span class=\"n\">X</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">X</span>: <span class=\"nc\">C1orC2</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">yields</span><span class=\"p\">[</span><span class=\"n\">SolverChoice</span>::<span class=\"n\">recursive</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"s\">&quot;No possible solution&quot;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 193961882,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901476
    },
    {
        "content": "<p>that's the test for the recursive solver, I mean</p>",
        "id": 193961888,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901481
    },
    {
        "content": "<p>ah</p>",
        "id": 193961924,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901483
    },
    {
        "content": "<p>yeah, I think that's equivalent</p>",
        "id": 193961945,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901497
    },
    {
        "content": "<p>the other question is why <code>slg(3, None)</code> in particular</p>",
        "id": 193962023,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901569
    },
    {
        "content": "<p>(vs the default)</p>",
        "id": 193962037,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901580
    },
    {
        "content": "<p>I'm not sure</p>",
        "id": 193962057,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901589
    },
    {
        "content": "<p>I don't <em>think</em> that's important</p>",
        "id": 193962207,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586901678
    },
    {
        "content": "<p>if you change it to 10, does the test still pass</p>",
        "id": 193962277,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586901722
    },
    {
        "content": "<p>yes the tests all still pass</p>",
        "id": 193962853,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902057
    },
    {
        "content": "<p>I changed them</p>",
        "id": 193962863,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902064
    },
    {
        "content": "<p>because in some cases that lets me write <code>goal { } yields { }</code> to test \"all solvers\"</p>",
        "id": 193962885,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902078
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span> I pushed a commit to your branch that ensures all tests run for the recursive solver--</p>",
        "id": 193962977,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902123
    },
    {
        "content": "<p>two commits, now</p>",
        "id": 193963078,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902202
    },
    {
        "content": "<p>but with that, I think I am satisfied to land, though we should definitely file some follow-up issues</p>",
        "id": 193963128,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902214
    },
    {
        "content": "<p>notably around coinduction</p>",
        "id": 193963133,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902216
    },
    {
        "content": "<p>I guess I should read over the priority code carefully</p>",
        "id": 193963153,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902233
    },
    {
        "content": "<p>ah, ok, so I think this is incomplete</p>",
        "id": 193963211,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902302
    },
    {
        "content": "<p>I'd like to try and write a test that exercises that</p>",
        "id": 193963212,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902307
    },
    {
        "content": "<p>ok well I can't think of a test right now :P</p>",
        "id": 193964076,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902813
    },
    {
        "content": "<p>sorry, to elaborate</p>",
        "id": 193964086,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902817
    },
    {
        "content": "<p>the current code <em>always</em> prefers a higher-priority solution</p>",
        "id": 193964097,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902827
    },
    {
        "content": "<p>even if the higher-priority solution is not 'fully general'</p>",
        "id": 193964105,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902836
    },
    {
        "content": "<p>at least if I'm reading it correctly</p>",
        "id": 193964110,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902841
    },
    {
        "content": "<p>so if you have something like <code>&lt;T as Trait&lt;?X&gt;&gt;::Foo</code>, and an impl that gives <code>T: Trait&lt;S1&gt;</code>, it would say that <code>?X = S1</code></p>",
        "id": 193964151,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902878
    },
    {
        "content": "<p>which..is not <em>wrong</em>, i.e., in terms of the impls we see, it's correct, and rustc often makes such leaps (for better and worse)</p>",
        "id": 193964169,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902894
    },
    {
        "content": "<p>but at the same time there <em>is</em> another solution available to us, the placeholder, that doesn't require that <code>?X = S1</code></p>",
        "id": 193964246,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902931
    },
    {
        "content": "<p>so in some sense the answer is strange</p>",
        "id": 193964275,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902951
    },
    {
        "content": "<p>but I can't come up with a test that will compile with the placeholder but not without it right now</p>",
        "id": 193964291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902974
    },
    {
        "content": "<p>I wonder if it's even needed</p>",
        "id": 193964310,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586902989
    },
    {
        "content": "<p>I was thinking maybe something like</p>",
        "id": 193964386,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586903039
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span>: <span class=\"nc\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">S2</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S1</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">S3</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>and then </p>\n<div class=\"codehilite\"><pre><span></span>exists&lt;T, U&gt; {\n    S1: Foo&lt;T, Bar = U&gt;,\n    U: Debug, // true with the placeholder (or with S3)\n    T = S4, // this would error because we forced T to be S2\n}\n</pre></div>\n\n\n<p>but of course that won't compile because we don't know that <code>S1: Foo&lt;S4, Bar = U&gt;</code> is true. And if we <em>did</em> know it were true, we'd get an ambiguity and wouldn't have normalized successfully.</p>",
        "id": 193964529,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586903135
    },
    {
        "content": "<p>(In particular, it <em>is</em> true that <em>another crate</em> could define <code>Foo&lt;S4&gt; for S1</code> for some <code>S4</code>, but of course we can't see that definition.)</p>",
        "id": 193964620,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586903177
    },
    {
        "content": "<p>oh huh</p>",
        "id": 193965128,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586903511
    },
    {
        "content": "<p>I found some other weird results...</p>",
        "id": 193965136,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586903515
    },
    {
        "content": "<p><del>that do seem like a bug, but for... both the slg and the recursive solver</del></p>",
        "id": 193965190,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586903532
    },
    {
        "content": "<p>ok, well, hmm. I guess I'm inclined to land the recursive solver, but I think we should open a follow-up issue to dig a bit more here</p>",
        "id": 193965854,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586903996
    },
    {
        "content": "<p>unfortunately I have to run</p>",
        "id": 193965896,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586904007
    },
    {
        "content": "<p>I started playing some tests and got some surprising results</p>",
        "id": 193965914,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586904023
    },
    {
        "content": "<p>that I don't fully understand yet</p>",
        "id": 193965919,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586904027
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/193963211\" title=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/193963211\">said</a>:</p>\n<blockquote>\n<p>ah, ok, so I think this is incomplete</p>\n</blockquote>\n<p>this is just wrong, which explains some of my confusion last night. I hadn't found the <code>combine_with_priorities</code> function.</p>",
        "id": 194005608,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586943547
    },
    {
        "content": "<p>OK, I pushed some updated tests, and I think everything is behaving as expected. Nice job, <span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span>! I left a few comments on the PR, but I think they're all things I'm comfortable addressing in follow up issues.</p>",
        "id": 194006304,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586943940
    },
    {
        "content": "<p>Oh, well, I'd like to figure out <a href=\"https://github.com/rust-lang/chalk/pull/372#discussion_r408711359\" title=\"https://github.com/rust-lang/chalk/pull/372#discussion_r408711359\">this question</a></p>",
        "id": 194006402,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586944004
    },
    {
        "content": "<p>yeah I guess we can just use <code>combine_with_priorities</code> there, I wasn't sure about <em>combining</em> solutions from previous iterations</p>",
        "id": 194006472,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586944060
    },
    {
        "content": "<p>and also, I didn't have a test that produces a problem because of that <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 194006575,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586944108
    },
    {
        "content": "<p>Yeah, I was having trouble making a test for that, but now I think I understand a bit better</p>",
        "id": 194007402,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586944613
    },
    {
        "content": "<p>so I can think about it and maybe grab one</p>",
        "id": 194007415,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586944621
    },
    {
        "content": "<p>i.e,. I understand where it comes up</p>",
        "id": 194007420,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586944624
    },
    {
        "content": "<p>it should be ok to combine solutions from previous iterations -- it's actually no different than combining solutions from different program clauses</p>",
        "id": 194007452,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586944646
    },
    {
        "content": "<p>basically in each case the new solution represents \"some possible answer\"</p>",
        "id": 194007478,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586944667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I've implemented that (though it was more complicated than it seemed at the outset, you can see in the last commit). I've also rebased, and had to change the truncation to flounder like SLG now does. That actually fixed the result for that <code>cycle::overflow</code> test that surprised you</p>",
        "id": 194205431,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586974161
    },
    {
        "content": "<p>ah interesting</p>",
        "id": 194226716,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586984383
    },
    {
        "content": "<p>great, then perhaps we'll land this thing wth some follow-up issues</p>",
        "id": 194226733,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586984390
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> <a href=\"https://github.com/rust-lang/chalk/issues/404\" title=\"https://github.com/rust-lang/chalk/issues/404\">rust-lang/chalk#404</a> should be a very fast review and improves performance a lot <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>",
        "id": 194659332,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1587380156
    },
    {
        "content": "<p>You might also want to look at <a href=\"https://github.com/rust-lang/chalk/issues/403\" title=\"https://github.com/rust-lang/chalk/issues/403\">rust-lang/chalk#403</a>, though Jack already merged that one</p>",
        "id": 194659454,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1587380207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/194659332\" title=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/194659332\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"https://github.com/rust-lang/chalk/issues/404\" title=\"https://github.com/rust-lang/chalk/issues/404\">rust-lang/chalk#404</a> should be a very fast review and improves performance a lot <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span></p>\n</blockquote>\n<p>reviewed and merged, <span class=\"user-mention\" data-user-id=\"129457\">@Florian Diebold</span></p>",
        "id": 194682806,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393083
    },
    {
        "content": "<p>thanks</p>",
        "id": 194682833,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1587393093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/194659454\" title=\"#narrow/stream/144729-wg-traits/topic/recursive.20solver/near/194659454\">said</a>:</p>\n<blockquote>\n<p>You might also want to look at <a href=\"https://github.com/rust-lang/chalk/issues/403\" title=\"https://github.com/rust-lang/chalk/issues/403\">rust-lang/chalk#403</a>, though Jack already merged that one</p>\n</blockquote>\n<p>ah, yeah, I saw that and had that queued for review, though I'm happy that <span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> merged it</p>",
        "id": 194682872,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393110
    },
    {
        "content": "<p>I'd like to make the whole \"give me the clauses for this goal\" thing into a cacheable query</p>",
        "id": 194682948,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393126
    },
    {
        "content": "<p>I've been wanting to revisit the <code>RustIrDatabase</code> trait to make that work, I suppose it might be as simple as</p>",
        "id": 194682981,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393138
    },
    {
        "content": "<p>having a callback</p>",
        "id": 194683008,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393148
    },
    {
        "content": "<p>which actually suggests that maybe you were right to make the input be the <code>Canonical</code> gola in environment</p>",
        "id": 194683049,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393164
    },
    {
        "content": "<p>and maybe we should even refactor the <em>SLG solver</em> to work that way... hmm.....</p>",
        "id": 194683073,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393176
    },
    {
        "content": "<p>I remember thinking it should change, but I want to revisit my thoughts on that and see if I have a convincing reason why</p>",
        "id": 194683106,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393189
    },
    {
        "content": "<p>in any case, I could imagine that we setup something where chalk calls out to the rust-ir-database which (in turn) calls back into a \"helper method\" in chalk-solve, the main reason for the setup then being to enable salsa-style caching</p>",
        "id": 194683176,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393213
    },
    {
        "content": "<p>i.e., to intervene with a salsa query</p>",
        "id": 194683192,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587393220
    },
    {
        "content": "<p>yeah, that would basically be the idea for the recursive solver as well, right? except there cycles pose a problem</p>",
        "id": 194683667,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1587393392
    },
    {
        "content": "<p>Right, but they shouldn't if we extend salsa to permit cycles</p>",
        "id": 194853216,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587498973
    },
    {
        "content": "<p>at least in cases like this</p>",
        "id": 194853221,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587498979
    },
    {
        "content": "<p>which is what I wanted to talk to you about yesterday but didn't have time :( :(</p>",
        "id": 194853233,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1587498985
    }
]