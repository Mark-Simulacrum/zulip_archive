[
    {
        "content": "<p>I want to unblock dyn upcasting and get this done. <span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span>  I started a fresh <a href=\"https://hackmd.io/BZIOk5AOR2Sc_Gn7LbLfJA\">write-up</a> but it's not that far yet. I'm mostly just bringing things back in cache right now. When it's done I'm going to ping you.</p>",
        "id": 264757594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639423792
    },
    {
        "content": "<p>OK, <span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span>, I think the doc is ready. I'd also like to ping <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>, <span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span>, <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>, <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> and maybe <span class=\"user-mention\" data-user-id=\"124288\">@oli</span> -- am I missing things in <a href=\"https://hackmd.io/BZIOk5AOR2Sc_Gn7LbLfJA?edit\">this write-up on dyn upcasting</a>? Do you understand it? Help me improve it!</p>",
        "id": 264769562,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639429400
    },
    {
        "content": "<p>Actually I moved the write-up to the repo (and tweaked it a bit): <a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html\">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html</a></p>",
        "id": 264772192,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639430795
    },
    {
        "content": "<p>I'm guessing \"upsizing\" should be \"unsizing\"?</p>",
        "id": 264778218,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639433651
    },
    {
        "content": "<p>So, I think I fully understand the document as written.</p>",
        "id": 264778588,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639433792
    },
    {
        "content": "<p>I do think that we need <em>at least</em> the special case for a null pointer.</p>",
        "id": 264778639,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639433803
    },
    {
        "content": "<p>More importantly, though, I'm <em>really</em> concerned about letting this be a coercion rather than an explicit cast.</p>",
        "id": 264778884,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639433868
    },
    {
        "content": "<p>Reading the document, I don't see any mention of requiring an <code>as</code> or a conversion function, rather than just letting the pointer coerce silently.</p>",
        "id": 264778974,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639433904
    },
    {
        "content": "<p>The <em>combination</em> of that with the fact that the coercion explodes with an invalid pointer (including null) feels especially hazardous to me. It feels like a violation of a general principle in Rust that we don't do invisible operations that have semantic significance.</p>",
        "id": 264779063,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639433958
    },
    {
        "content": "<blockquote>\n<p>(Although not directly relevant here, there is another option that requires accessing the vtable from safe code, which is finding the offset of fields. This is because the alignment of a *const dyn Foo depends on the hidden type and hence we must load the alignment from the vtable and do offsetting adjustments at runtime.)</p>\n</blockquote>\n<p>I'm not sure I understand this bit -- which fields is this talking about?</p>\n<hr>\n<p>I feel like there's a possible alternative to \"Make raw pointer upcasting unsafe (not possible once <code>dyn SubTrait: Unsize&lt;dyn SuperTrait&gt;</code> is stable)\":</p>\n<ul>\n<li>Instead of UnsafeUnsize, we forbid the case for raw pointers (i.e., it's not unsafe, just not allowed at all). Obviously, complicates the system, but less so than introducing conditionally unsafe operations.<ul>\n<li>Do we have use cases where it's necessary/helpful to have this upcast on raw pointers?</li>\n<li>One might imagine that <code>Unsize</code> is not <em>really</em> a marker trait, but rather has an <code>unsafe fn make_metadata(old: Source::Metadata) -&gt; Target::Metadata</code>, where all current impls are <em>safe</em> impls of that method. In such a world, it's not really a separate UnsafeUnsize trait, but rather just some types are safe to coerce from and some are not, largely because for some types getting the target metadata is a safe operation (it's statically known as <code>()</code>) and for some types that's not the case.</li>\n</ul>\n</li>\n</ul>\n<p>This is the most(?) future proof of the options, I think, and lets us pick a story here when we've nailed down the safety &amp; validity invariant more generally for metadata.</p>",
        "id": 264798506,
        "sender_full_name": "simulacrum",
        "timestamp": 1639448353
    },
    {
        "content": "<p>It's also worth noting that for many (don't have a characterization off hand) trait hierarchies the coercion doesn't actually perform a load, so we could expand in that direction as well -- it's plausible that we can have a min version of this feature that is still eminently useful that only addresses those hierarchies, right?</p>",
        "id": 264798643,
        "sender_full_name": "simulacrum",
        "timestamp": 1639448499
    },
    {
        "content": "<p>I think the key bit is that for me <code>*const u32 -&gt; *const dyn Debug</code> is an unsizing coercion, but it's not so clear that <code>*const dyn SubTrait -&gt; *const dyn SuperTrait</code> is -- that's not really unsizing anymore. So it going through <code>Unsize</code> seems \"interesting\" as an assumption.</p>",
        "id": 264798758,
        "sender_full_name": "simulacrum",
        "timestamp": 1639448616
    },
    {
        "content": "<p>I want to add some background info that <code>*const dyn Trait + AutoTraits -&gt; *const dyn Trait</code> going through <code>Unsize</code> was the previous status quo, and our previous dyn upcasting implementation followed that.</p>",
        "id": 264808218,
        "sender_full_name": "Charles Lew",
        "timestamp": 1639455106
    },
    {
        "content": "<p>-</p>",
        "id": 264808489,
        "sender_full_name": "Charles Lew",
        "timestamp": 1639455270
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264778884\">said</a>:</p>\n<blockquote>\n<p>More importantly, though, I'm <em>really</em> concerned about letting this be a coercion rather than an explicit cast.</p>\n</blockquote>\n<p>We must be talking past each other, because an explicit cast feels to me like it would be a really big ergonomic hit and I don't understand the urgency you feel about it. In particular...</p>\n<blockquote>\n<p>The combination of that with the fact that the coercion explodes with an invalid pointer (including null) feels especially hazardous to me. It feels like a violation of a general principle in Rust that we don't do invisible operations that have semantic significance.</p>\n</blockquote>\n<p>This doesn't match what I expect. What the document proposes is that we don't <em>have</em> invalid pointers -- you always use a valid vtable (even if it's a dummy one). I'm not opposed to special casing null in some way, although I think I would prefer to use the \"function to give a sufficiently valid vtable\" approach versus saying that the vtable can be null. This is purely an efficiency argument, though, I just don't want to generate inefficient assembly for every upcast to cater to what feels to me like an obscure case.</p>",
        "id": 264882436,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639498730
    },
    {
        "content": "<p>I will say that more and more I regret that <code>*const T</code> permits null</p>",
        "id": 264882518,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639498764
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> </p>\n<blockquote>\n<p>Instead of UnsafeUnsize, we forbid the case for raw pointers (i.e., it's not unsafe, just not allowed at all). Obviously, complicates the system, but less so than introducing conditionally unsafe operations.</p>\n</blockquote>\n<p>I will add this as an alternative, but I think it's not a good choice. I think in particular that there are definitely use cases for raw pointer upcasting, though I don't have a crisp example at hand. I just know that I've been very grateful that dyn works smoothly with raw pointers in general numerous times, and I can't see why this would be an exception.</p>",
        "id": 264883035,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639498954
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116458\">@Charles Lew</span> that sounds like the proposed plan, but I remain pretty opposed to it :)</p>",
        "id": 264883095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639498984
    },
    {
        "content": "<p>it feels significantly worse than having some kind of \"sufficiently valid\" vtable (which may include just accepting null)</p>",
        "id": 264883258,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499044
    },
    {
        "content": "<p>I want to try and articulate in what way... I guess in that it introduces an asymmetry between pointer types and I don't really understand the use case it is protecting</p>",
        "id": 264883319,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499071
    },
    {
        "content": "<p>really I think that people should be using <code>Option&lt;NonNull&lt;dyn Foo&gt;&gt;</code> and we should make <em>that</em> ergonomic</p>",
        "id": 264883450,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499131
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264882436\">said</a>:</p>\n<blockquote>\n<p>This doesn't match what I expect. What the document proposes is that we don't <em>have</em> invalid pointers -- you always use a valid vtable (even if it's a dummy one). </p>\n</blockquote>\n<p>To build on this, I'd like to see <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> if we can get real specific -- can we sketch out some code that you anticipate being harder to write under the proposal than you would like?</p>",
        "id": 264883697,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499224
    },
    {
        "content": "<p>yeah, I agree that option nonnull etc are probably the right path in general -- I think my perspective comes less so from a place of <em>wanting</em> the invalid vtables to \"work\" (i.e., I don't have code off hand that might fail that) but there's a concern in the back of my mind where it's plausibly unexpected behavior that introduces subtle UB</p>",
        "id": 264884603,
        "sender_full_name": "simulacrum",
        "timestamp": 1639499579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264883095\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> that sounds like the proposed plan, but I remain pretty opposed to it :)</p>\n</blockquote>\n<p>ok, I'm trying to elaborate it in the doc; maybe I am not as opposed as I thought I was, but I'm still not sure I like it :)</p>",
        "id": 264884617,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499584
    },
    {
        "content": "<p>but that may not be actually a problem if it's hard to generate this case in the first place</p>",
        "id": 264884643,
        "sender_full_name": "simulacrum",
        "timestamp": 1639499595
    },
    {
        "content": "<p>(i.e., how does one end up with a vtable that doesn't work well?)</p>",
        "id": 264885198,
        "sender_full_name": "simulacrum",
        "timestamp": 1639499791
    },
    {
        "content": "<p>Right. I'd like to drill into that question.</p>",
        "id": 264885229,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499801
    },
    {
        "content": "<p>I also wonder how much appetite there is for some kind of \"raw but not null\" pointer that is nice to use</p>",
        "id": 264885292,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499821
    },
    {
        "content": "<p>It feels like it would be much more ergonomic overall to me</p>",
        "id": 264885341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639499837
    },
    {
        "content": "<blockquote>\n<p><a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future\">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#extend-safety-condition-to-require-a-fully-valid-vtable-still-possible-in-the-future</a></p>\n</blockquote>\n<p><a href=\"https://doc.rust-lang.org/nightly/std/ptr/fn.metadata.html\">https://doc.rust-lang.org/nightly/std/ptr/fn.metadata.html</a> is currently safe, and the methods on the returned <a href=\"https://doc.rust-lang.org/nightly/std/ptr/struct.DynMetadata.html\">https://doc.rust-lang.org/nightly/std/ptr/struct.DynMetadata.html</a> are also safe -- there was another discussion on this, somewhat recently, I think</p>",
        "id": 264889460,
        "sender_full_name": "simulacrum",
        "timestamp": 1639501345
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/63851\">https://github.com/rust-lang/rust/issues/63851</a>, I suppose</p>",
        "id": 264890019,
        "sender_full_name": "simulacrum",
        "timestamp": 1639501526
    },
    {
        "content": "<p>but I think there was discussion on Zulip as well</p>",
        "id": 264890038,
        "sender_full_name": "simulacrum",
        "timestamp": 1639501533
    },
    {
        "content": "<p>in any case, I agree that drilling into the ways folks are constructing dyn metadata -- it seems like vtables are pretty opaque today, so it seems like the only way to actually get it wrong would be to mem::transmute -- even <a href=\"https://doc.rust-lang.org/nightly/std/ptr/fn.from_raw_parts.html\">https://doc.rust-lang.org/nightly/std/ptr/fn.from_raw_parts.html</a> wouldn't let you manufacture and incorrect vtable as far as I can tell</p>",
        "id": 264890586,
        "sender_full_name": "simulacrum",
        "timestamp": 1639501729
    },
    {
        "content": "<p>FWIW C++ does <a href=\"https://stackoverflow.com/questions/29850716/does-upcasting-a-null-pointer-lead-to-undefined-behavior\">allow</a> null pointer casting, it seems, but that's a slightly different case, I think, since their vtable is behind the pointer and not on the side</p>",
        "id": 264891105,
        "sender_full_name": "simulacrum",
        "timestamp": 1639501872
    },
    {
        "content": "<p>anyway, I think I'd be OK with the original proposal -- but part of me is inclined to block raw pointer dyn upcasts until we have concrete code that wants them. But given the difficulty of manufacturing an incorrect vtable already that seems not as necessary.</p>",
        "id": 264891400,
        "sender_full_name": "simulacrum",
        "timestamp": 1639501974
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264778884\">said</a>:</p>\n<blockquote>\n<p>More importantly, though, I'm <em>really</em> concerned about letting this be a coercion rather than an explicit cast.</p>\n</blockquote>\n<p>I'd like to second this. I think introducing a new safety invariant for raw pointers is an enormous conceptual shift in how users need to think about raw pointers. While raw pointers are currently \"more than just bytes\" (provenance), this only affects explicit (unsafe) loads/stores. Simply copying a raw pointer around in memory doesn't require any additional care.</p>\n<p>If we do take the approach of adding in some kind of safety invariant related to the vtable, I think it would be a large footgun to perform an implicit upcasting coercion with raw pointers. Unsafe code that appears to be 'just copying around' a raw pointer may actually be performing a read from memory, which I think will be extremely suprising to code reviewers</p>",
        "id": 264891826,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502126
    },
    {
        "content": "<p>Note that simply copying a raw pointer here wouldn't require any additional care either</p>",
        "id": 264892035,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502198
    },
    {
        "content": "<p>What would require care is <em>producing a raw pointer from nothing</em></p>",
        "id": 264892064,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502206
    },
    {
        "content": "<p>Or, more to the point, synthesizing a vtable</p>",
        "id": 264892171,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502243
    },
    {
        "content": "<p>If we're just modifying the safety invariant, then it would still be legal to produce a raw pointer with invalid metadata / vtable, right?</p>",
        "id": 264892214,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502260
    },
    {
        "content": "<p>Define \"legal\"</p>",
        "id": 264892246,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502271
    },
    {
        "content": "<p>Not immediate undefined behavior</p>",
        "id": 264892259,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502278
    },
    {
        "content": "<p>since it doesn't violate the validity invariant</p>",
        "id": 264892317,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502286
    },
    {
        "content": "<p>That is correct, not immediate UB.</p>",
        "id": 264892342,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502296
    },
    {
        "content": "<p>Though I'd be happy to make it be UB :)</p>",
        "id": 264892366,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502304
    },
    {
        "content": "<p>I might then have a helper function, and do <code>my_function(my_synthetic_raw_ptr)</code></p>",
        "id": 264892367,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502304
    },
    {
        "content": "<p>But I don't think it's required to be UB</p>",
        "id": 264892378,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502308
    },
    {
        "content": "<p>Yes, ok, I see your point.</p>",
        "id": 264892393,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502315
    },
    {
        "content": "<p>and that could actually trigger undefined behavior, if the function call performs a coercion in the argument</p>",
        "id": 264892421,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502319
    },
    {
        "content": "<p>which I think would be extremely suprising</p>",
        "id": 264892436,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502324
    },
    {
        "content": "<p>I guess in my head it would be good to treat it like undefined bytes, that's how I would teach it to people -- in other words, part of the validity invariant.</p>",
        "id": 264892487,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502346
    },
    {
        "content": "<p>Perhaps that is another alternative that should be listed.</p>",
        "id": 264892506,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502352
    },
    {
        "content": "<p>I think that would be the right way to treat it, regardless.</p>",
        "id": 264892541,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502365
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264892393\">said</a>:</p>\n<blockquote>\n<p>Yes, ok, I see your point.</p>\n</blockquote>\n<p>let me try to articulate that example in the writeup somewhere more cleanly</p>",
        "id": 264892605,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639502396
    },
    {
        "content": "<p>Anecdotally, I think I've seen that there's a pretty strong belief in the community that raw pointers are \"just bytes\" when you're not dereferencing them (e.g. ignoring provenance)</p>",
        "id": 264892785,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502454
    },
    {
        "content": "<p>I think introducing any kind of validity invariant for raw pointers themselves would be a very significant change to how people percieve the language</p>",
        "id": 264892835,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502470
    },
    {
        "content": "<p>Even if the spec currently leaves the door open for doing that (e.g. we don't specify certain things about raw pointers)</p>",
        "id": 264892872,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502487
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264883035\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> </p>\n<blockquote>\n<p>Instead of UnsafeUnsize, we forbid the case for raw pointers (i.e., it's not unsafe, just not allowed at all). Obviously, complicates the system, but less so than introducing conditionally unsafe operations.</p>\n</blockquote>\n<p>I will add this as an alternative, but I think it's not a good choice. I think in particular that there are definitely use cases for raw pointer upcasting, though I don't have a crisp example at hand. I just know that I've been very grateful that dyn works smoothly with raw pointers in general numerous times, and I can't see why this would be an exception.</p>\n</blockquote>\n<p>My impression has been that <code>*const dyn Trait</code> is a very niche feature (though I certainly could be wrong about that). Even if raw pointer upcasting coercions were made to work without any changes to safety/validity invariants, I would expect any actual uses to be extremely rare. Are there any examples of code currently making use of raw trait object pointers?</p>",
        "id": 264893517,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639502725
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264892214\">said</a>:</p>\n<blockquote>\n<p>If we're just modifying the safety invariant, then it would still be legal to produce a raw pointer with invalid metadata / vtable, right?</p>\n</blockquote>\n<p>Note that this is today -- at least by my reading -- pretty hard</p>",
        "id": 264896865,
        "sender_full_name": "simulacrum",
        "timestamp": 1639503999
    },
    {
        "content": "<p>you basically have to transmute</p>",
        "id": 264896877,
        "sender_full_name": "simulacrum",
        "timestamp": 1639504003
    },
    {
        "content": "<p>and when you're transmuting a pair of usizes or so into a dyn raw pointer, you're probably already being pretty careful -- I'm not sure <em>anyone</em> is synthesizing dyn vtables today</p>",
        "id": 264896992,
        "sender_full_name": "simulacrum",
        "timestamp": 1639504047
    },
    {
        "content": "<p>ok, I pushed a bunch of edits. I also removed the reference to a \"prefered option\" since I think my mind at least is not made up</p>",
        "id": 264897033,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504061
    },
    {
        "content": "<p>that took way longer than I thought it would lol</p>",
        "id": 264897055,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504072
    },
    {
        "content": "<p>I wnated to do other lang team tasks int his hour</p>",
        "id": 264897066,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504076
    },
    {
        "content": "<p>but that's ok! this is an important one :)</p>",
        "id": 264897095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504082
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#core-decision-to-be-made\">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#core-decision-to-be-made</a></p>",
        "id": 264897204,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504106
    },
    {
        "content": "<p>this section summarizes what I see as the <em>core decision</em> as well as the arguments for each choice</p>",
        "id": 264897233,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504117
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> I will read your latest comments now but I'd appreciate if you gave <a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#why-prefer-unsafe-raw-pointer-upcasting\">this section</a> a skim to see if it covers your argument</p>",
        "id": 264897306,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504137
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264892785\">said</a>:</p>\n<blockquote>\n<p>Anecdotally, I think I've seen that there's a pretty strong belief in the community that raw pointers are \"just bytes\" when you're not dereferencing them (e.g. ignoring provenance)</p>\n</blockquote>\n<p>I think I got this aspect, yes.</p>",
        "id": 264897375,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264896865\">said</a>:</p>\n<blockquote>\n<p>Note that this is today -- at least by my reading -- pretty hard</p>\n</blockquote>\n<p>I think this is right, I was struggling a bit to come up with a realistic example that isn't <em>also</em> uninitialized -- I came up with <code>unsafe { std::mem::zeroed() }</code></p>",
        "id": 264897453,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504194
    },
    {
        "content": "<p>seems plausible</p>",
        "id": 264897462,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264897306\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> I will read your latest comments now but I'd appreciate if you gave <a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#why-prefer-unsafe-raw-pointer-upcasting\">this section</a> a skim to see if it covers your argument</p>\n</blockquote>\n<p>Yes, that looks like a good summary to me</p>",
        "id": 264897629,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639504254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264897453\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264896865\">said</a>:</p>\n<blockquote>\n<p>Note that this is today -- at least by my reading -- pretty hard</p>\n</blockquote>\n<p>I think this is right, I was struggling a bit to come up with a realistic example that isn't <em>also</em> uninitialized -- I came up with <code>unsafe { std::mem::zeroed() }</code></p>\n</blockquote>\n<p>yeah, though it's worth noting:</p>\n<div class=\"codehilite\"><pre><span></span><code>warning: the type `*const dyn Debug` does not permit zero-initialization\n --&gt; src/lib.rs:2:14\n  |\n2 |     unsafe { std::mem::zeroed() }\n  |              ^^^^^^^^^^^^^^^^^^\n  |              |\n  |              this code causes undefined behavior when executed\n  |              help: use `MaybeUninit&lt;T&gt;` instead, and only call `assume_init` after initialization is done\n  |\n  = note: `#[warn(invalid_value)]` on by default\n  = note: the vtable of a wide raw pointer must be non-null\n</code></pre></div>",
        "id": 264897961,
        "sender_full_name": "simulacrum",
        "timestamp": 1639504366
    },
    {
        "content": "<p>interesting :)</p>",
        "id": 264898042,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504398
    },
    {
        "content": "<p>and that the current std::ptr::metadata at least implies that there's at least a safety invariant of not doing so -- that gives you safe access to fields of dyn vtables, though it's unstable</p>",
        "id": 264898106,
        "sender_full_name": "simulacrum",
        "timestamp": 1639504419
    },
    {
        "content": "<p>I guess I should adjust the doc</p>",
        "id": 264898110,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504421
    },
    {
        "content": "<p>there <em>is</em> a layout advantage to the validity invariant</p>",
        "id": 264898129,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504428
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125294\">@Aaron Hill</span> I'm curious if you feel differently if the result is validity invariant</p>",
        "id": 264898162,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504438
    },
    {
        "content": "<p>and I'm also curious whether a standard UB detector would change the calculus for you</p>",
        "id": 264898244,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504455
    },
    {
        "content": "<p>that's something I am feelign very strongly about :)</p>",
        "id": 264898260,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504460
    },
    {
        "content": "<p>in which case validity invariant failures would mean cargo test just fails</p>",
        "id": 264898278,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504469
    },
    {
        "content": "<p>oh, <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span>, I wrote up  the case you found confusing</p>",
        "id": 264898341,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504489
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#metadata-and-field-offsets\">https://rust-lang.github.io/dyn-upcasting-coercion-initiative/design-discussions/upcast-safety-2.html#metadata-and-field-offsets</a></p>",
        "id": 264898360,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504494
    },
    {
        "content": "<p>My initial reaction is that a change to the validity invariant seems like a much larger change to the idea that \"raw pointers are just bytes until you dereference them\"</p>",
        "id": 264898435,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639504519
    },
    {
        "content": "<p>I'll have to think about the trade-off with detecting U.B.</p>",
        "id": 264898453,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639504526
    },
    {
        "content": "<p>Generic code does need to 'opt in' to this in a sense (since a <code>*const T</code> won't accept <code>*const dyn Trait</code> due to the implicit <code>Sized</code> bound), so the overall impact might be smaller than I initially thought</p>",
        "id": 264898760,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639504625
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> ah, hm. I guess I'll need to stare at it -- \"This is because the offset of field is a function of the alignment of <code>Foo&lt;U&gt;</code>, which is a function of the alignment of U.\" does not instantly compute for me just yet :)</p>",
        "id": 264898774,
        "sender_full_name": "simulacrum",
        "timestamp": 1639504630
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> I just realized that this example is more complex than it has to be</p>",
        "id": 264899731,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639504938
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264883697\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264882436\">said</a>:</p>\n<blockquote>\n<p>This doesn't match what I expect. What the document proposes is that we don't <em>have</em> invalid pointers -- you always use a valid vtable (even if it's a dummy one). </p>\n</blockquote>\n<p>To build on this, I'd like to see <span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> if we can get real specific -- can we sketch out some code that you anticipate being harder to write under the proposal than you would like?</p>\n</blockquote>\n<p>I think that isn't capturing the nature of my feedback. I can sketch out some code that I anticipate <em>not being sufficiently hard to accidentally write</em>. :)</p>",
        "id": 264900509,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639505247
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264882518\">said</a>:</p>\n<blockquote>\n<p>I will say that more and more I regret that <code>*const T</code> permits null</p>\n</blockquote>\n<p>That seems like a rather primary property of raw pointers; if you don't want to permit null or garbage, you can often use a reference.</p>",
        "id": 264900679,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639505302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264898760\">said</a>:</p>\n<blockquote>\n<p>Generic code does need to 'opt in' to this in a sense (since a <code>*const T</code> won't accept <code>*const dyn Trait</code> due to the implicit <code>Sized</code> bound), so the overall impact might be smaller than I initially thought</p>\n</blockquote>\n<p>That doesn't seem at all like it should be correlated with \"can't be null or garbage\".</p>",
        "id": 264900807,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639505384
    },
    {
        "content": "<p>I meant that in practice, it might be more difficult that I thought to write code that will ever actually deal with a raw pointer with invalid metadata</p>",
        "id": 264900984,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639505464
    },
    {
        "content": "<p>I'm still in favor of leaving the validity and safety invariants unchanged</p>",
        "id": 264901008,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639505477
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264900679\">said</a>:</p>\n<blockquote>\n<p>That seems like a rather primary property of raw pointers; if you don't want to permit null or garbage, you can often use a reference.</p>\n</blockquote>\n<p>I disagree that it's primary, I guess. To me it's primarily about \"compiler can't prove that it's valid\"</p>",
        "id": 264901015,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639505479
    },
    {
        "content": "<p>being potentially null seems better expressed with <code>Option</code>, and being potentially not initialized seems like <code>MaybeUninit</code>; not sure what other forms of \"garbage\" there are</p>",
        "id": 264901128,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1639505528
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264900679\">said</a>:</p>\n<blockquote>\n<p>That seems like a rather primary property of raw pointers; if you don't want to permit null or garbage, you can often use a reference.</p>\n</blockquote>\n<p>I'm not convinced, there.  Past-the-end references don't exist, for example, and it's incredibly common for pointers in C to be de-facto non-null, even if the type system can't know that.</p>\n<p>Not to mention the stacked borrows implications.  You can use a pointer to read past the item in a way you can't with a <code>&amp;mut T</code>, for example.</p>\n<p>And a ton of the methods on pointers just don't work on nullable things.  Putting the few methods that do on <code>Option&lt;NonNull&lt;T&gt;&gt;</code> instead would make sense to me.  (<code>wrapping_offset</code>, perhaps, though that's a very rare thing.)</p>",
        "id": 264902186,
        "sender_full_name": "scottmcm",
        "timestamp": 1639506040
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264901008\">said</a>:</p>\n<blockquote>\n<p>I'm still in favor of leaving the validity and safety invariants unchanged</p>\n</blockquote>\n<p>I believe we already have an invariant that vtable is non-null even for raw pointers.</p>",
        "id": 264908415,
        "sender_full_name": "Gary Guo",
        "timestamp": 1639508383
    },
    {
        "content": "<p>So despite that I originally think raw pointers should be raw, currently I am leaning towards requiring a fully valid vtable (or as the doc says, \"sufficiently valid\" for now and leave the fully valid option on the table).</p>",
        "id": 264909142,
        "sender_full_name": "Gary Guo",
        "timestamp": 1639508574
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264901128\">said</a>:</p>\n<blockquote>\n<p>being potentially null seems better expressed with <code>Option</code>, and being potentially not initialized seems like <code>MaybeUninit</code>; not sure what other forms of \"garbage\" there are</p>\n</blockquote>\n<p>I think it's too late to make raw pointers <em>not</em> be nullable, and having <em>some</em> raw pointers not be nullable seems confusing.</p>",
        "id": 264910094,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639508859
    },
    {
        "content": "<p>I agree it's too late to directly change <code>*const</code> right now.</p>\n<p>The conversation about <code>Aligned&lt;_&gt;</code> in <a href=\"https://github.com/rust-lang/RFCs/issues/3204\">RFCs#3204</a> has been making me thing about a more generic <code>Ptr&lt;...&gt;</code> type, though, which could represent more of these things.  Maybe even say that <code>*const T</code> is sugar for <code>Ptr&lt;T, {Alignment::Unknown}&gt;</code> or something.</p>\n<p>That would make it <em>potentially</em> possible to change <code>*const</code> to desugar to something else over like 6 years and multiple editions if we really wanted to later.</p>\n<p>But I guess I should take that out of this thread...</p>",
        "id": 264914911,
        "sender_full_name": "scottmcm",
        "timestamp": 1639511081
    },
    {
        "content": "<p>I think I mentioned this before in another thread: Interaction with <code>#![feature(arbitrary_self_types)]</code> is important. This feature alone requires all vtable pointers to always be valid. E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(arbitrary_self_types)]</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// this is safe code, hence `*const dyn Trait` must always</span>\n<span class=\"c1\">// contain a completely valid vtable pointer</span>\n<span class=\"k\">fn</span> <span class=\"nf\">call_method</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">method</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I’m not aware of any soundness issues around <code>arbitrary_self_types</code>. If there are any, feel free to point me to them; if there are none, then there must already be an invariant in place that raw pointers to trait objects always have a valid vtable.</p>\n<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span>  IMO this point about <code>arbitrary_self_types</code> should be mentioned in the write-up.</p>",
        "id": 264915065,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1639511167
    },
    {
        "content": "<p>I think it's questionable if we actually want to support raw pointers with arbitrary_self_types.</p>",
        "id": 264919085,
        "sender_full_name": "Gary Guo",
        "timestamp": 1639513051
    },
    {
        "content": "<p>Hmm, interesting, the tracking issue for that, <a href=\"https://github.com/rust-lang/rust/issues/44874\">#44874</a>, contains a short mention of the problem of \"raw pointer[s] with a garbage vtable\", too. If that’s really a problem, I feel like the unstable feature <code>arbitrary_self_types</code> should to more to communicate (potential) soundness issues e.g. by triggering a <code>incomplete_features</code> warning?</p>\n<p>In any case, that feature <em>does</em> make for some prior discussion of vtable pointer validity guarantees, so it definitely makes sense to consider it as prior art in this discussion.</p>",
        "id": 264921892,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1639514353
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264919085\">said</a>:</p>\n<blockquote>\n<p>I think it's questionable if we actually want to support raw pointers with arbitrary_self_types.</p>\n</blockquote>\n<p>I think for trait methods the answer is no (or perhaps it should require <code>Self: Sized</code> — that is, I'm not in favor of having <code>*const dyn Foo</code> require a valid vtable), but I have wanted them very badly many times on inherent methods, for improving ergonomics of unsafe code (currently it's a lot safer to work with raw pointers than references in unsafe code, but the ergonomics push you to use references)</p>",
        "id": 264959450,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1639537301
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/264892785\">said</a>:</p>\n<blockquote>\n<p>Anecdotally, I think I've seen that there's a pretty strong belief in the community that raw pointers are \"just bytes\" when you're not dereferencing them (e.g. ignoring provenance)</p>\n</blockquote>\n<p>this is already violated by the nonnull attribute on the vtable ptr, though... (which is the reason for the warning on <code>mem::zeroed</code>)</p>",
        "id": 265042198,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588340
    },
    {
        "content": "<p>if this is to be part of the validity invariant then I hope we can have a clear operational spec for \"sufficiently valid\" -- Miri will have to implement <em>something</em> after all ;)</p>",
        "id": 265042512,
        "sender_full_name": "RalfJ",
        "timestamp": 1639588466
    },
    {
        "content": "<p>My intuition for raw dyn pointers has been that the data pointer part works like a raw pointer but that the vtable pointer bit (and by extension the vtable itself and anything related to method dispatch) works like any other fat pointer. In other words a raw dyn pointer is a dyn pointer first and a raw pointer second</p>",
        "id": 265129460,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639646779
    },
    {
        "content": "<p>I guess I've been thinking of the \"raw\" in \"raw pointer\" as applying to the entire pointer+metadata, when it really only (or should only) apply to the pointer part, and not the metadata part</p>",
        "id": 265174299,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1639669367
    },
    {
        "content": "<p>I think that's likely to break <em>many</em> people's intuitions.</p>",
        "id": 265354856,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639772042
    },
    {
        "content": "<p>Many people, including myself, see <code>*T</code> as \"raw pointer to something or other\", and the <code>T</code> shouldn't be relevant for the core properties of a raw pointer (e.g. \"it's the size of a pointer, it can be null, it's just a number until you dereference it, you can pass it through C\", etc).</p>",
        "id": 265354955,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639772087
    },
    {
        "content": "<p>If <code>*T</code> for some value of <code>T</code> is suddenly something with validity invariants, my <em>first</em> question is going to be \"so how do I get the raw-er thing that doesn't have validity invariants\".</p>",
        "id": 265355055,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639772161
    },
    {
        "content": "<p>(And my second question is likely to be \"why isn't <code>*</code> the raw-er thing, and the less-raw thing some kind of reference\".)</p>",
        "id": 265355119,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639772186
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265129460\">said</a>:</p>\n<blockquote>\n<p>My intuition for raw dyn pointers has been that the data pointer part works like a raw pointer but that the vtable pointer bit (and by extension the vtable itself and anything related to method dispatch) works like any other fat pointer. In other words a raw dyn pointer is a dyn pointer first and a raw pointer second</p>\n</blockquote>\n<p>I would have expected that a \"raw dyn pointer\" was a raw pointer to something that itself included a vtable, rather than a fat pointer.</p>",
        "id": 265355272,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639772300
    },
    {
        "content": "<p>(And that the thing-that-included-a-vtable would be where any non-null non-garbage validity expectations are. So, for instance, you could have a garbage raw pointer, but not a valid raw pointer with a garbage vtable pointer on the other end.)</p>",
        "id": 265355445,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639772406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265355272\">said</a>:</p>\n<blockquote>\n<p>I would have expected that a \"raw dyn pointer\" was a raw pointer to something that itself included a vtable, rather than a fat pointer.</p>\n</blockquote>\n<p>Does that type exist in rust? (\"raw pointer to something that itself included a vtable\") I assume that changes to the data layout of <code>*const dyn T</code> are not feasible due to stability concerns</p>",
        "id": 265355730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639772586
    },
    {
        "content": "<p>I don't <em>think</em> we've stabilized those internals yet?</p>",
        "id": 265356409,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639772998
    },
    {
        "content": "<p>I think we have functions for unpacking and packing them, but not the structures themselves.</p>",
        "id": 265356465,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773009
    },
    {
        "content": "<p>Oh, it looks like even the functions to pack and unpack them are still unstable.</p>",
        "id": 265356560,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773074
    },
    {
        "content": "<p>So I don't think there are stability issues that would prevent us from saying <code>*const dyn T</code> and <code>*mut dyn T</code> are just thin pointers to a thing that has a vtable on the other end.</p>",
        "id": 265356609,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773110
    },
    {
        "content": "<p>I mean more fundamentally, I think it would break a lot of things if <code>*const dyn T</code> suddenly became 8 bytes</p>",
        "id": 265356613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639773111
    },
    {
        "content": "<p>but also, I don't understand how you want the data layout to work. Where is the data pointer then?</p>",
        "id": 265356714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639773146
    },
    {
        "content": "<p>you wouldnt be able to do <code>&amp;dyn Trait</code> -&gt; <code>*const dyn Trait</code> if <code>*const dyn Trait</code> was a thin pointer could you?</p>",
        "id": 265356727,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1639773155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265356613\">said</a>:</p>\n<blockquote>\n<p>I mean more fundamentally, I think it would break a lot of things if <code>*const dyn T</code> suddenly became 8 bytes</p>\n</blockquote>\n<p>Oh, I didn't realize <code>*const dyn T</code> was two pointers already. :(</p>\n<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9bc076c78e3327ef02f8dfdfcf7fce4a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=9bc076c78e3327ef02f8dfdfcf7fce4a</a></p>",
        "id": 265356815,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773207
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265355055\">said</a>:</p>\n<blockquote>\n<p>If <code>*T</code> for some value of <code>T</code> is suddenly something with validity invariants, my <em>first</em> question is going to be \"so how do I get the raw-er thing that doesn't have validity invariants\".</p>\n</blockquote>\n<p>It seems like you can take a fat pointer and split it into a <code>data_ptr: *const ()</code> and <code>vtable_ptr: &lt;dyn T&gt;::Metadata</code>, but the latter part still has validity invariants. There isn't any type that has no validity invariants there, although I suppose you could wrap it in <code>MaybeUninit</code> or use <code>[u8; size_of::&lt;&lt;dyn T&gt;::Metadata&gt;()]</code> instead</p>",
        "id": 265357403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639773570
    },
    {
        "content": "<p>I'm not sure what kind of code is being enabled by invalid metadata types though</p>",
        "id": 265357563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639773655
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265356714\">said</a>:</p>\n<blockquote>\n<p>but also, I don't understand how you want the data layout to work. Where is the data pointer then?</p>\n</blockquote>\n<p>I can imagine a few different layouts that could work, with various properties and tradeoffs:</p>\n<ul>\n<li>Thin pointer to <code>(data pointer, vtable pointer)</code>.</li>\n<li>Thin pointer directly to a vtable that has a slot for a data pointer (less indirect vtable access, at the expense of copying more when creating it)</li>\n<li>Thin pointer to data, where the data has a vtable pointer in it or available from it via an offset. (That seems likely to have layout compatibility issues.)</li>\n</ul>",
        "id": 265357605,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265357563\">said</a>:</p>\n<blockquote>\n<p>I'm not sure what kind of code is being enabled by invalid metadata types though</p>\n</blockquote>\n<p>Passing pointers through FFI. Or storing them in data structures as pointers, where some slots of the data structure aren't filled in and you don't want a separate \"is valid\" bit.</p>",
        "id": 265357745,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773771
    },
    {
        "content": "<p>The first one already exists, that's <code>&amp;&amp;dyn T</code></p>",
        "id": 265357803,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639773817
    },
    {
        "content": "<p>Presumably <code>*const &amp;dyn T</code> if you want a raw pointer and its lack of validity expectations?</p>",
        "id": 265357890,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773855
    },
    {
        "content": "<p>sure</p>",
        "id": 265357910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639773868
    },
    {
        "content": "<p>(Or <code>*mut &amp;mut dyn T</code> if mutable)</p>",
        "id": 265357929,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773879
    },
    {
        "content": "<p>Both of the first two suffer from the issue of an additional allocation, which has to be put somewhere (and the rust user will want to control whether that pointer is a <code>Box</code>, <code>&amp;</code>, <code>*const</code> etc)</p>",
        "id": 265357963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639773896
    },
    {
        "content": "<p>Going back to \"already exists\" for a moment: don't we already have a thick pointer with validity expectations, in the form of <code>&amp;dyn T</code>?</p>",
        "id": 265358131,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773963
    },
    {
        "content": "<p>(or <code>&amp;mut dyn T</code>)</p>",
        "id": 265358155,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639773969
    },
    {
        "content": "<p>That has a lifetime though, what if you want to opt out?</p>",
        "id": 265358209,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774013
    },
    {
        "content": "<p>I don't see how you can possibly opt out of having a valid vtable pointer when rust gives you no tools for constructing a vtable pointer by hand or checking the validity of vtable pointers</p>",
        "id": 265358319,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774064
    },
    {
        "content": "<p>We have (unstably, but with plans to stabilize in the future) functions to disassemble and reassemble a vtable-and-data pointer pair.</p>",
        "id": 265358433,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774124
    },
    {
        "content": "<p>Also, <code>extern \"C\" fn xyz() -&gt; *const T</code> for various <code>T</code>. And <code>extern \"C\" fn xyz(*const T)</code> with the expectation you'll be handed the pointer back in the future.</p>",
        "id": 265358498,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774163
    },
    {
        "content": "<p>That part seems okay, that's the <code>&lt;dyn T&gt;::Metadata</code> part I mentioned. But this type is not just <code>usize</code>, it has validity invariants</p>",
        "id": 265358528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774180
    },
    {
        "content": "<p>I think the concept of a thick pointer with validity invariants isn't the main sticking point, it's the idea of that type being spelled with a <code>*</code> but not behaving like other <code>*</code>s.</p>",
        "id": 265358614,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774214
    },
    {
        "content": "<p>and I see no reasonable analogue of this type that doesn't have validity invariants except for wrapping it in <code>MaybeUninit</code> as I mentioned</p>",
        "id": 265358631,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774225
    },
    {
        "content": "<p>(I want to acknowledge here that I feel like I'm late to the party and confused. Sorry for that.)</p>",
        "id": 265358659,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774252
    },
    {
        "content": "<p>I see your general point about <code>*</code> meaning no invariants, but this implies that there is some other type <code>&lt;dyn T&gt;::RawMetadata</code> and I don't see how it can possibly be handled safely</p>",
        "id": 265358773,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774327
    },
    {
        "content": "<p>Suppose you have a big hash table full of \"output streams\", which you want to represent as <code>dyn std::io::Write</code>. You want each output stream to take up one pointer in size, and you want them to be potentially null so that your hash table can use a null pointer to represent \"there's nothing in this bucket\".</p>",
        "id": 265358799,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774355
    },
    {
        "content": "<p>(that is, if we define <code>*const dyn T = (*const (), &lt;dyn T&gt;::RawMetadata)</code>)</p>",
        "id": 265358810,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774365
    },
    {
        "content": "<p>That hashmap example sounds like <code>*const Box&lt;dyn Write&gt;</code></p>",
        "id": 265358963,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774447
    },
    {
        "content": "<p>or even <code>Option&lt;Box&lt;Box&lt;dyn Write&gt;&gt;</code> since that example doesn't call for any unsafe access</p>",
        "id": 265359058,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774515
    },
    {
        "content": "<p><code>*Box</code> or <code>Box&lt;Box&lt;...</code> feels like one more level of indirection than ought to be required there...</p>",
        "id": 265359089,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774543
    },
    {
        "content": "<p>I'm assuming your option 1 data layout, which has a pointer to a pointer pair</p>",
        "id": 265359173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774583
    },
    {
        "content": "<p>the others can't easily be represented in rust today</p>",
        "id": 265359211,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774618
    },
    {
        "content": "<p>I'm wondering if it's possible that I have some assumptions inherited from C++, where any non-POD object already has a vtable pointer in front of it, so the idea of \"pointer to data and pointer to vtable\" isn't a necessary concept, whereas Rust allows traits on otherwise-POD types so the pointers have to be separate.</p>",
        "id": 265359215,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774622
    },
    {
        "content": "<p>(Or, likewise, Haskell's approach to structures and \"vtables\", which similarly has pointers in front of each object.)</p>",
        "id": 265359253,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774648
    },
    {
        "content": "<p>Well, a big part of the issue is that you can take any type and put it in a<code>&amp;dyn T</code> for any <code>T</code> implemented by the type, including traits defined downstream</p>",
        "id": 265359345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774690
    },
    {
        "content": "<p>so a mechanism that tries to stuff the vtable pointer in the data seems fundamentally impossible</p>",
        "id": 265359403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774730
    },
    {
        "content": "<p>that is, option 3</p>",
        "id": 265359408,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774737
    },
    {
        "content": "<p>Right, and you can't know in advance which types might need vtables handled that way, because unlike C++ where <code>virtual</code> is a big clue, any trait can be implemented by any type.</p>",
        "id": 265359484,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774779
    },
    {
        "content": "<p>(For what it's worth here, I'm fairly sure at this point that I'm <em>not</em> arguing against the existence of <em>some</em> type that contains a validity invariant for the vtable; I'm just trying to figure out how to avoid confusing people who have a <em>lot</em> of intuition attached to <code>*</code> that's being broken here, and I'm trying to figure out if there's any reasonable way for this to still act like a raw pointer.)</p>",
        "id": 265359575,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774805
    },
    {
        "content": "<p>what's an example of code that would be broken by validity-carrying <code>*const dyn T</code> that isn't already broken?</p>",
        "id": 265359740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1639774865
    },
    {
        "content": "<p>Is it possible for <code>dyn T</code> to be the X in a <code>fn&lt;X&gt;(..., *const X)</code>?</p>",
        "id": 265359824,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639774917
    },
    {
        "content": "<p>with <code>X: ?Sized</code>, yes</p>",
        "id": 265359879,
        "sender_full_name": "simulacrum",
        "timestamp": 1639774930
    },
    {
        "content": "<p>\"it's the size of a pointer\" is already clearly not the case though for raw ptrs to dyn types.</p>",
        "id": 265494292,
        "sender_full_name": "RalfJ",
        "timestamp": 1639940237
    },
    {
        "content": "<p>(and \"just a number\" is also wrong given that provenance is required to explain which interactions with that supposed 'number' are legal and which are not, but that is a separate discussion)</p>",
        "id": 265494359,
        "sender_full_name": "RalfJ",
        "timestamp": 1639940291
    },
    {
        "content": "<p>That's true, but I think the intuition that <code>*const T</code>/<code>*mut T</code> shouldn't have validity invariants probably still holds — I find the notion very surprising and like it would need a lot of justification if it does. — After all, that's what references/Box/etc are for.</p>",
        "id": 265599848,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1640024699
    },
    {
        "content": "<p>This might have been already addressed, but there are any performance/optimization reasons for raw pointer metadata validity invariants? The only one I'm aware of would be emitting <code>nonnull</code> and <code>deferenceable</code> to LLVM, but I'd be curious to see if that actually makes a difference in practice</p>",
        "id": 265600133,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1640024857
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span> ah, thank you! good callout on the arbitrary self types point. I will add it to the writeup. (Catching up on this thread)</p>",
        "id": 265611396,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640031708
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265599848\">said</a>:</p>\n<blockquote>\n<p>That's true, but I think the intuition that <code>*const T</code>/<code>*mut T</code> shouldn't have validity invariants probably still holds — I find the notion very surprising and like it would need a lot of justification if it does. — After all, that's what references/Box/etc are for.</p>\n</blockquote>\n<p>we are, indeed, discussing those justifications <em>now</em> :)</p>",
        "id": 265611599,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640031831
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125294\">Aaron Hill</span> <a href=\"#narrow/stream/144729-wg-traits/topic/dyn.20upcasting.202021-12/near/265600133\">said</a>:</p>\n<blockquote>\n<p>This might have been already addressed, but there are any performance/optimization reasons for raw pointer metadata validity invariants? The only one I'm aware of would be emitting <code>nonnull</code> and <code>deferenceable</code> to LLVM, but I'd be curious to see if that actually makes a difference in practice</p>\n</blockquote>\n<p>niches?</p>",
        "id": 265611669,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640031851
    },
    {
        "content": "<p>For niches you can always use NonNull&lt;dyn T&gt;. Actually, I think it would be reasonable for the NonNull to apply to both the vtable pointer as well as the data pointer.</p>",
        "id": 265644188,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1640058162
    }
]