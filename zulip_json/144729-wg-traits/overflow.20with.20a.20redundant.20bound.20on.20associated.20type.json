[
    {
        "content": "<p>Working on answering <a href=\"https://stackoverflow.com/q/71210295/155423\">Why does a trait bound of an associated type cause an evaluation overflow when the bound is guaranteed to always hold?</a>.</p>\n<p>If you uncomment the <code>S::Expr: Clone</code> bound, you get an overflow error.</p>\n<p>My reasoning for that is that the trait system isn't smart enough to see that <code>S: Schema</code> implies <code>S::Expr: Clone</code> when checking <code>Clone</code> for <code>ParserSchema::Expr</code>. Instead, it gets stuck in a loop </p>\n<p>When it's computing <code>impl&lt;S&gt; Clone for Expr&lt;S&gt;</code> without the bound on the associated type, no loop is needed as it can terminate and say \"so long as <code>S</code> implements <code>Schema</code>\". Proving that can be a separate check later, not part of a cycle.</p>\n<p>Am I missing any key points?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Expr</span>: <span class=\"nb\">Clone</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">S</span>: <span class=\"nc\">Schema</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">S</span>::<span class=\"n\">Expr</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span>: <span class=\"nc\">Schema</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// S::Expr: Clone, // overflow evaluating the requirement `Wrapper&lt;ParserSchema&gt;: Clone`</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(Clone)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">ParserSchema</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Schema</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ParserSchema</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Expr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">ParserSchema</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272829241,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645547659
    },
    {
        "content": "<p><code>Wrapper&lt;ParserSchema&gt;: Clone</code> requires that <code>&lt;ParserSchema as Schema&gt;::Expr: Clone</code>, which is just <code>Wrapper&lt;ParserSchema&gt;: Clone</code></p>",
        "id": 272833309,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645549196
    },
    {
        "content": "<p>There's no coinduction here</p>",
        "id": 272833440,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645549219
    },
    {
        "content": "<p>So it's just a cycle</p>",
        "id": 272833460,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645549223
    },
    {
        "content": "<p>notably, this isn't a <em>generic</em> check</p>",
        "id": 272834096,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645549447
    },
    {
        "content": "<blockquote>\n<p>Proving that can be a separate check later, not part of a cycle.</p>\n</blockquote>\n<p>That is in fact what we're doing</p>",
        "id": 272834136,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645549463
    },
    {
        "content": "<p>we're checking that <code>Wrapper&lt;ParserSchema&gt;</code> fulfills the bounds on <code>Schema::Expr</code></p>",
        "id": 272834192,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645549492
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type/near/272833440\">said</a>:</p>\n<blockquote>\n<p>There's no coinduction here</p>\n</blockquote>\n<p>I'm not clear; did something I state indicate that there was? I don't even know what \"coinduction\" means, so I don't think I intended to mean that.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type/near/272834136\">said</a>:</p>\n<blockquote>\n<p>That is in fact what we're doing</p>\n</blockquote>\n<p>I'm not following; are you agreeing with me or correcting me?</p>",
        "id": 272842885,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645553021
    },
    {
        "content": "<p>(I think, in context) \"coinduction\" means that the trait bound is allowed to be self-proving. There's a cycle here, because when we need to prove that <code>Wrapper&lt;ParserSchema&gt;: Clone</code> by proving <code>Wrapper&lt;ParserSchema&gt;: Clone</code>, we can't.</p>",
        "id": 272843643,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645553372
    },
    {
        "content": "<p>This is in comparison to other traits, like <code>Send</code>, that can circularly depend on themselves being <code>Send</code> for the bound to be satisfied (at least afaik).</p>",
        "id": 272843743,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645553411
    },
    {
        "content": "<p>Let me try to start from the top...</p>\n<p>When the compiler sees <code>impl Schema for ParserSchema</code>, it makes sure that <code>&lt;Schema as ParserSchema&gt;::Expr: Clone</code>. </p>\n<p>When we have</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span>: <span class=\"nc\">Schema</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then the check can stop and say \"yes, so long as <code>S: Schema</code>\". It doesn't need to re-check that <code>&lt;S as Schema&gt;::Expr: Clone</code>.</p>\n<p>However, with </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span>: <span class=\"nc\">Schema</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">S</span>::<span class=\"n\">Expr</span>: <span class=\"nb\">Clone</span><span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>it <strong>does</strong> re-check <code>&lt;S as Schema&gt;::Expr: Clone</code>, which is what leads to the loop.</p>\n<p>A Sufficiently Advanced Compiler could see that <code>Schema</code> already enforces that and the two pieces of code could have the same behavior.</p>",
        "id": 272843801,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645553451
    },
    {
        "content": "<p>Like, I get that with the bound on the associated type we get a loop and even a bit why.</p>",
        "id": 272843966,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645553523
    },
    {
        "content": "<p>but based on the definition of <code>Schema</code>, <code>S: Schema</code> implies <code>S::Expr: Clone</code>, so from the outside it seems odd that one form is allowed and the other isn't.</p>",
        "id": 272844108,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645553595
    },
    {
        "content": "<p>I'm assuming that the difference boils down to an implementation trade-off.</p>",
        "id": 272844142,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645553612
    },
    {
        "content": "<p>So the cycle begins when we start to check <code>impl Schema for ParserSchema</code>. We need to enforce that <code>&lt;ParserSchema as Schema&gt;::Expr</code> is <code>Clone</code> for that <code>impl</code> to be happy. But we know what the exact concrete type for <code>&lt;ParserSchema as Schema&gt;::Expr</code> is, so we _actually_ check if <code>Wrapper&lt;ParserSchema&gt;: Clone</code>. When we _exclude_ that commented-out bound on <code>impl Clone for Wrapper&lt;S&gt;</code>, then the only nested bound we need to check is <code>S: Schema</code>. That's fine, because we know that <code>ParserSchema: Schema</code> with no extra requirements to check. However, when we have that <code>&lt;S as  Schema&gt;::Expr: Clone</code> bound, we substitute <code>S = ParserSchema</code> and then normalize the type, getting <code>Wrapper&lt;ParserSchema&gt;: Clone</code>. That's a cycle.</p>",
        "id": 272844639,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645553798
    },
    {
        "content": "<p>Yes</p>",
        "id": 272844859,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645553887
    },
    {
        "content": "<p>The fact that we substitute the <code>&lt;S as Schema&gt;::Expr</code> when <code>S = ParserSchema</code> and then compute the real type of the assoc is what makes us have a cycle, I think, because once we turn that cyclical bound from <code>&lt;ParserSchema as Schema&gt;::Expr: Clone</code> into <code>Wrapper&lt;ParserSchema&gt;: Clone</code>, then we can no longer (easily) apply the fact that we know that any <code>&lt;_ as Schema&gt;::Expr</code> is <code>Clone</code>.</p>",
        "id": 272844919,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645553919
    },
    {
        "content": "<p>(since applying that known fact requires the LHS of the trait bound to be an associated type)</p>",
        "id": 272844958,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645553936
    },
    {
        "content": "<p>But that  Sufficiently Advanced Compiler could see that we don't <em>need</em> to check <code>S::Expr: Clone</code> /  substitute <code>S = ParserSchema</code> because it's implied by the definition of <code>Schema</code>.</p>",
        "id": 272845083,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645553983
    },
    {
        "content": "<p>(note that I'm not claiming that a SAC is easy to implement, by any means <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>)</p>",
        "id": 272845229,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645554034
    },
    {
        "content": "<p>Sure, I could see it might be able to filter out implied impl bounds that are possible to prove before doing any substitutions, and then only substitute and check the bounds that are remaining.</p>",
        "id": 272845384,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645554117
    },
    {
        "content": "<p>(thus filtering that commented out bound in the example)</p>",
        "id": 272845439,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645554126
    },
    {
        "content": "<p>would perhaps also be solved if we had lazy projection normalization :^)</p>",
        "id": 272845607,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645554208
    },
    {
        "content": "<p>Isn't everything solved by that?</p>",
        "id": 272848100,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645555234
    },
    {
        "content": "<p>that's what I tell myself constantly</p>",
        "id": 272848172,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645555273
    },
    {
        "content": "<p>i've heard lazy normalization writes your code for you /s</p>",
        "id": 272848201,
        "sender_full_name": "Michael Goulet (compiler-errors)",
        "timestamp": 1645555291
    },
    {
        "content": "<p>It looks like the associated type stuff is a red herring. This code also causes an overflow:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Wrapper</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">f</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">Wrapper</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span>: <span class=\"nb\">Clone</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">fn</span> <span class=\"nf\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272848606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645555499
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/144729-wg-traits/topic/overflow.20with.20a.20redundant.20bound.20on.20associated.20type/near/272845083\">said</a>:</p>\n<blockquote>\n<p>But that  Sufficiently Advanced Compiler could see that we don't <em>need</em> to check <code>S::Expr: Clone</code> /  substitute <code>S = ParserSchema</code> because it's implied by the definition of <code>Schema</code>.</p>\n</blockquote>\n<p>I don't think this is correct (logically). <code>S::Expr: Clone</code> is exactly the bound we are trying to check. So it's not really <em>implied</em>. But, it can be conductive \"it's Clone as long as it's Clone\". A subtle distinction, but kind of important logically. (You could imagine that there might be type variables thrown in here in a more complicated case)</p>",
        "id": 272849087,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645555710
    },
    {
        "content": "<p>I don't think <code>Clone</code> can be coinductive though</p>",
        "id": 272849142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645555734
    },
    {
        "content": "<p>Now, I think the desire <em>is</em> to make all traits conductive at some point</p>",
        "id": 272849155,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645555741
    },
    {
        "content": "<p>trait implementations usually can't be, since you have to call some code at the end of the day</p>",
        "id": 272849191,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645555758
    },
    {
        "content": "<p><code>Send</code> is more about ensuring certain bad things don't happen, so coinductive makes sense there</p>",
        "id": 272849253,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645555796
    },
    {
        "content": "<p>Well, there's an impl. Sort of one of the requirements</p>",
        "id": 272849323,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645555816
    },
    {
        "content": "<p>Making it coinductive doesn't remove that requirement</p>",
        "id": 272849423,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645555873
    },
    {
        "content": "<p>hm, I see what you mean. This is weird, but I guess it's fine since termination was never on the agenda</p>",
        "id": 272849638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645555980
    },
    {
        "content": "<p>Strangely, adding a type variable to <code>Wrapper</code> makes the overflow go away (although since the <code>Clone</code> bound is inductive ATM it doesn't end up implementing <code>Clone</code> in the end)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">t</span>: <span class=\"nc\">std</span>::<span class=\"n\">marker</span>::<span class=\"n\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">f</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Clone</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span>: <span class=\"nb\">Clone</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"k\">fn</span> <span class=\"nf\">clone</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">       </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">t</span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">self</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">w</span>: <span class=\"nc\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Wrapper</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">w</span><span class=\"p\">.</span><span class=\"n\">clone</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// fail</span>\n</code></pre></div>",
        "id": 272850013,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645556137
    },
    {
        "content": "<p>Aha, <code>Sized</code> definitely can't be coinductive, if we assume that the witness to <code>Sized</code> comes with an answer to <code>size_of::&lt;T&gt;()</code></p>",
        "id": 272850514,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645556342
    },
    {
        "content": "<p>Sized is definitely harder :)</p>",
        "id": 272851123,
        "sender_full_name": "Jack Huey",
        "timestamp": 1645556528
    }
]