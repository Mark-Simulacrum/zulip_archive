[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/Contribution.20to.20chalk/near/192922454\" title=\"#narrow/stream/144729-wg-traits/topic/Contribution.20to.20chalk/near/192922454\">said</a>:</p>\n<blockquote>\n<p>This was really just a start. Really, we would want it to be at the <code>chalk_ir</code> level, not <code>chalk_integration</code></p>\n</blockquote>\n<p>Would that mean it belongs inside chalk-ir itself, or in an adjacent crate like the parser?</p>",
        "id": 192922873,
        "sender_full_name": "David Ross",
        "timestamp": 1586027986
    },
    {
        "content": "<p>Hmm</p>",
        "id": 192922933,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586028037
    },
    {
        "content": "<p>I imagine probably just in chalk-ir</p>",
        "id": 192922937,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586028054
    },
    {
        "content": "<p>I know we talked about this a little bit more in the past, let me see if I can find the relevant discussion</p>",
        "id": 192923014,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586028172
    },
    {
        "content": "<p>I can't find it :(</p>",
        "id": 192923171,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586028469
    },
    {
        "content": "<p>This? <a href=\"#narrow/stream/144729-wg-traits/topic/design.20meeting.202019.2E12.2E30/near/184494609\" title=\"#narrow/stream/144729-wg-traits/topic/design.20meeting.202019.2E12.2E30/near/184494609\">https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/design.20meeting.202019.2E12.2E30/near/184494609</a></p>",
        "id": 192923254,
        "sender_full_name": "detrumi",
        "timestamp": 1586028580
    },
    {
        "content": "<p>(searching for \".chalk\" in this stream did the trick)</p>",
        "id": 192923300,
        "sender_full_name": "detrumi",
        "timestamp": 1586028605
    },
    {
        "content": "<p>I think we didn't actually discuss it that much, apart from that</p>",
        "id": 192923326,
        "sender_full_name": "detrumi",
        "timestamp": 1586028684
    },
    {
        "content": "<p>mmm, I think we discussed it briefly once I actually was working on my branch</p>",
        "id": 192923374,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586028733
    },
    {
        "content": "<p>because we were dicussing how to name the parameters</p>",
        "id": 192923379,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586028753
    },
    {
        "content": "<p>(if I recall correctly)</p>",
        "id": 192923382,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586028769
    },
    {
        "content": "<p>I guess for now we'll keep it in chalk-ir, and we can fix/change that before submitting a PR if necessary</p>",
        "id": 192929188,
        "sender_full_name": "David Ross",
        "timestamp": 1586037854
    },
    {
        "content": "<p>yeah, we can also move it to a separate crate if we want/need</p>",
        "id": 192929202,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586037893
    },
    {
        "content": "<p>I'm wondering</p>",
        "id": 192929231,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586037935
    },
    {
        "content": "<p>It actually might be better in chalk-solve</p>",
        "id": 192929233,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586037944
    },
    {
        "content": "<p>Because we presumably want to write as traits/structs rather than the clauses themselves</p>",
        "id": 192929274,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586037968
    },
    {
        "content": "<p>With all the data required to print things accurately, that seems like it might be a good idea?</p>\n<p>We were looking at possibly moving most of the rendering/writing code into methods in chalk-ir, we're accessing the RustIrDatabase methods of Program a lot to get names for types and other data, and we don't have access to that trait in chalk-ir</p>",
        "id": 192931335,
        "sender_full_name": "David Ross",
        "timestamp": 1586041528
    },
    {
        "content": "<p>Right now we've mostly implemented more things within the giant \"write\" method on program and looked into various places we could move that code to be more modular</p>",
        "id": 192931381,
        "sender_full_name": "David Ross",
        "timestamp": 1586041595
    },
    {
        "content": "<p>chalk-solve looks like it'd provide more functionality, but it also seems really kind of wrong to have the IR writing code in solve? That might just be a hangup around naming, though, I'm not sure</p>",
        "id": 192931392,
        "sender_full_name": "David Ross",
        "timestamp": 1586041627
    },
    {
        "content": "<p>Err, if we wrote the code in chalk-solve, then we'd have access to the RustIrDatabase trait, and that'd be helpful</p>",
        "id": 192931409,
        "sender_full_name": "David Ross",
        "timestamp": 1586041674
    },
    {
        "content": "<p>Yes, we definitely should write in chalk-solve</p>",
        "id": 192979226,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586122273
    },
    {
        "content": "<p>so, there's really two different \"levels\" of IR</p>",
        "id": 192979231,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586122287
    },
    {
        "content": "<p>There is are \"pseudo-Rust\" IR</p>",
        "id": 192979234,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586122307
    },
    {
        "content": "<p>Then the \"Chalk IR\"</p>",
        "id": 192979237,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586122315
    },
    {
        "content": "<p>the former would have something like <code>impl Foo for Bar {}</code> where the latter is <code>Implemented(Bar: Foo)</code></p>",
        "id": 192979290,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586122352
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/192922937\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/192922937\">said</a>:</p>\n<blockquote>\n<p>I imagine probably just in chalk-ir</p>\n</blockquote>\n<p>no, I think not chalk-ir, probably chalk-solve</p>",
        "id": 193096708,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204707
    },
    {
        "content": "<p>oh, I see you kind of got there</p>",
        "id": 193096731,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204718
    },
    {
        "content": "<p>what I was imagining is specifically that</p>",
        "id": 193096774,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204739
    },
    {
        "content": "<p>we would make a \"wrapper\" around <code>RustIrDatabase</code></p>",
        "id": 193096787,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204746
    },
    {
        "content": "<p>if some environment variable is set, we would take the <code>&amp;mut dyn RustIrDatabase&lt;I&gt;</code> that we get from the user</p>",
        "id": 193096801,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204756
    },
    {
        "content": "<p>and wrap it in our own database that (a) forwards along the calls and then (b) collects and dumps out the data it gets in response</p>",
        "id": 193096878,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204777
    },
    {
        "content": "<p>some of the things we have to do that are annoying: </p>\n<ul>\n<li>giving unique names from def-ids, it'd be best if we can preserve the names the user gave, obviously, perhaps creating longer vesions where needed</li>\n</ul>",
        "id": 193096954,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204824
    },
    {
        "content": "<p>(but I'd say that to start we can just ignore the \"fully qualified\" things and assume names don't overlap, or else just add a disambiguation integer to every name)</p>",
        "id": 193097019,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204861
    },
    {
        "content": "<p>e.g., if the user defines <code>struct Foo</code> we write out <code>struct Foo1</code> and then if have another <code>Foo</code> in some other module, you get <code>Foo2</code></p>",
        "id": 193097053,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204878
    },
    {
        "content": "<ul>\n<li>avoiding duplicate calls -- we would basically be monitoring the requests for things like <code>trait_datum(def_id)</code>, so obviously we only want to collect the first def-id</li>\n</ul>",
        "id": 193097189,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204928
    },
    {
        "content": "<ul>\n<li>we probably want to create many distinct files, one for each goal we are asked to solve</li>\n</ul>",
        "id": 193097210,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1586204935
    },
    {
        "content": "<p>Would the main thing be implementing a writer for the \"pseudo-Rust\" IR, then, or should we also aim at transforming the pure-Chalk IR into .chalk files as well?</p>\n<p>Right now we're just doing the pseudo-Rust IR</p>",
        "id": 193675823,
        "sender_full_name": "David Ross",
        "timestamp": 1586633651
    },
    {
        "content": "<p>Just the pseudo-Rust IR</p>",
        "id": 193675863,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586633703
    },
    {
        "content": "<p>Cool, that works. Unrelated question, do you think it'd be appropriate to depend on DebugContext to get names from ids, or to try to make a better generic way to do that?</p>\n<p>I can't seem to find a way to use either Interner nor RustIrDatabase to get good name information for traits from TraitIds</p>",
        "id": 193675959,
        "sender_full_name": "David Ross",
        "timestamp": 1586633814
    },
    {
        "content": "<p>Um not sure</p>",
        "id": 193675981,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586633858
    },
    {
        "content": "<p>It's probably okay to use on DebugContext</p>",
        "id": 193675989,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586633872
    },
    {
        "content": "<p>but also feel free to add methods to Interner or RustIrDatabase as you see fit</p>",
        "id": 193676029,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586633893
    },
    {
        "content": "<p>alright <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 193676148,
        "sender_full_name": "David Ross",
        "timestamp": 1586634076
    },
    {
        "content": "<p><code>DebugContext</code> only exists for the Chalk integration tests, shouldn't the methods on <code>Interner</code> be enough though?</p>",
        "id": 193676331,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586634313
    },
    {
        "content": "<p>uh let me check</p>",
        "id": 193676400,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586634416
    },
    {
        "content": "<p>tbh I actually don't remember where <code>DebugContext</code> is</p>",
        "id": 193676412,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586634432
    },
    {
        "content": "<p>okay, I actually think <code>DebugContext</code> and all the tls-specific stuff should be moved out of chalk-ir</p>",
        "id": 193676485,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586634527
    },
    {
        "content": "<p>seems like it just duplicates methods in <code>Interner</code></p>",
        "id": 193676493,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586634544
    },
    {
        "content": "<p>err</p>",
        "id": 193676592,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586634700
    },
    {
        "content": "<p>I guess it can be under <code>#[cfg(any(test, feature = \"default-interner\"))]</code></p>",
        "id": 193676719,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586634878
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"129457\">Florian Diebold</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193676331\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193676331\">said</a>:</p>\n<blockquote>\n<p><code>DebugContext</code> only exists for the Chalk integration tests, shouldn't the methods on <code>Interner</code> be enough though?</p>\n</blockquote>\n<p>If that's what it is then I'm OK with not using it.</p>\n<p>Interner as it's currently written isn't enough because it doesn't expose any information about what things were originally named (or if it does, I can't find it)</p>",
        "id": 193677093,
        "sender_full_name": "David Ross",
        "timestamp": 1586635473
    },
    {
        "content": "<p>or I guess it does have those debug_* methods but they aren't guaranteed to have answers?</p>",
        "id": 193677111,
        "sender_full_name": "David Ross",
        "timestamp": 1586635507
    },
    {
        "content": "<p>probably should be <code>RustIrDatabase</code></p>",
        "id": 193677715,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586636425
    },
    {
        "content": "<p>for things like trait/struct names and such</p>",
        "id": 193677722,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586636435
    },
    {
        "content": "<p>I personally think the debug methods should be enough for the chalk file writer, which is a debug tool itself</p>",
        "id": 193677818,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1586636573
    },
    {
        "content": "<p>Mmm, I think it will be enough for 80-90% of the work</p>",
        "id": 193677941,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586636741
    },
    {
        "content": "<p>Is there a chance that someone will need the debug methods to output something other than valid syntax? Maybe we can provide some interfaces to give access to the data that these debug methods are using?</p>",
        "id": 193684304,
        "sender_full_name": "Super Tuple",
        "timestamp": 1586646903
    },
    {
        "content": "<p>Unrelated question: how do binders work?</p>\n<p>I think I understand the concept of debrujin indices, but I'm struggling to grasp how exactly to find some parameter's debrujin index if it isn't a BoundVar</p>",
        "id": 193687291,
        "sender_full_name": "David Ross",
        "timestamp": 1586652695
    },
    {
        "content": "<p>Like, in places, we'll get something wrapping a BoundVar and from that we can get a debrujin index &amp; the other index to name it by. But then, for instance, in AssociatedTyBound, the only way to get its generics is to iterate over x.binders.binders, which has no debrujin indices</p>",
        "id": 193687353,
        "sender_full_name": "David Ross",
        "timestamp": 1586652825
    },
    {
        "content": "<p>oh! wait, I think I got it. they always have debrujin index 0 because they're freshly introduced. that makes sense</p>",
        "id": 193687426,
        "sender_full_name": "David Ross",
        "timestamp": 1586652933
    },
    {
        "content": "<p>Separate question: what's the recommended way to get the various types out of an AliasEq that's part of a WhereClause?</p>\n<p>We've looked at the inner data, but I can't help but feel like we're missing the bigger picture here. It looks like for a where clause <code>X: Y&lt;A1, A2, A3, Z&lt;B1, B2, B3&gt;=D&gt;</code>, the various parameters end up as:</p>\n<div class=\"codehilite\"><pre><span></span>alias_eq.alias.substitution = [A1, A2, A3, X, B1, B2, B3]\nalias_eq.ty = D\nalias_eq.alias.associated_ty_id = (some way to get Y, Z)\n</pre></div>\n\n\n<p>(for <code>alias_eq</code> being the <code>AliasEq</code> inside <code>WhereClause:::AliasEq</code>)</p>\n<p>All the types there, but I have no idea how A1,A2,A3 and X and B1,B2,B3 are related and why they're put in the same data structure, or how to get them out of that structure (and differentiate between A_, X, and B_).</p>",
        "id": 193690277,
        "sender_full_name": "David Ross",
        "timestamp": 1586658387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218710\">David Ross</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193687426\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193687426\">said</a>:</p>\n<blockquote>\n<p>oh! wait, I think I got it. they always have debrujin index 0 because they're freshly introduced. that makes sense</p>\n</blockquote>\n<p>yes, exactly. <code>Binders</code> define <em>what</em> is bound</p>",
        "id": 193693337,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586665018
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218710\">David Ross</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193690277\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193690277\">said</a>:</p>\n<blockquote>\n<p>Separate question: what's the recommended way to get the various types out of an AliasEq that's part of a WhereClause?</p>\n<p>We've looked at the inner data, but I can't help but feel like we're missing the bigger picture here. It looks like for a where clause <code>X: Y&lt;A1, A2, A3, Z&lt;B1, B2, B3&gt;=D&gt;</code>, the various parameters end up as:</p>\n<div class=\"codehilite\"><pre><span></span>alias_eq.alias.substitution = [A1, A2, A3, X, B1, B2, B3]\nalias_eq.ty = D\nalias_eq.alias.associated_ty_id = (some way to get Y, Z)\n</pre></div>\n\n\n<p>(for <code>alias_eq</code> being the <code>AliasEq</code> inside <code>WhereClause:::AliasEq</code>)</p>\n<p>All the types there, but I have no idea how A1,A2,A3 and X and B1,B2,B3 are related and why they're put in the same data structure, or how to get them out of that structure (and differentiate between A_, X, and B_).</p>\n</blockquote>\n<p>uh, I'll have to look into this. Or <span class=\"user-mention\" data-user-id=\"125131\">@detrumi</span> might be able to answer since they have worked on the <code>AliasEq</code>-related code more recently</p>",
        "id": 193693384,
        "sender_full_name": "Jack Huey",
        "timestamp": 1586665085
    },
    {
        "content": "<p>Isn't it just like everything else, i.e. you do <code>assoc_ty_datum.binders.substitute(interner, alias_eq.alias.substitution)</code> and get assoc type bounds and whatever</p>",
        "id": 193693723,
        "sender_full_name": "Areredify",
        "timestamp": 1586665691
    },
    {
        "content": "<p>As to how distinguish between A, X and B, you can refer to chalk-solve\\src\\split.rs, it has everything you need</p>",
        "id": 193694130,
        "sender_full_name": "Areredify",
        "timestamp": 1586666616
    },
    {
        "content": "<p>ToProgramClauses impl for AssocTyDatum is a good example of how they are used</p>",
        "id": 193694249,
        "sender_full_name": "Areredify",
        "timestamp": 1586666787
    },
    {
        "content": "<p>One thing to know is that <code>AliasEq</code> was previously called <code>ProjectionEq</code>, the name was generalized but the other kinds of aliases (impl Trait, type alias) haven't been added yet</p>",
        "id": 193698057,
        "sender_full_name": "detrumi",
        "timestamp": 1586674274
    },
    {
        "content": "<p>Looking at just the where clause can get confusing if you don't look at the associated type as well</p>",
        "id": 193698067,
        "sender_full_name": "detrumi",
        "timestamp": 1586674304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"251766\">Areredify</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193694130\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193694130\">said</a>:</p>\n<blockquote>\n<p>As to how distinguish between A, X and B, you can refer to chalk-solve\\src\\split.rs, it has everything you need</p>\n</blockquote>\n<p>I'm not familiar with the exact representation either, but this part seems relevant:</p>\n<div class=\"codehilite\"><pre><span></span>Given a projection of an associated type, split the type\nparameters into those that come from the *trait* and those\nthat come from the *associated type itself*.\n</pre></div>",
        "id": 193698111,
        "sender_full_name": "detrumi",
        "timestamp": 1586674381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"251766\">Areredify</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193694130\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193694130\">said</a>:</p>\n<blockquote>\n<p>As to how distinguish between A, X and B, you can refer to chalk-solve\\src\\split.rs, it has everything you need</p>\n</blockquote>\n<p>Awesome! This looks like exactly what we need.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"125131\">detrumi</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193698067\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193698067\">said</a>:</p>\n<blockquote>\n<p>Looking at just the where clause can get confusing if you don't look at the associated type as well</p>\n</blockquote>\n<p>I'll be sure to try and check that out independently too!</p>",
        "id": 194558736,
        "sender_full_name": "David Ross",
        "timestamp": 1587236242
    },
    {
        "content": "<p>Thanks all for answering the questions though! It's super helpful</p>",
        "id": 194568749,
        "sender_full_name": "David Ross",
        "timestamp": 1587252153
    },
    {
        "content": "<p>We've made progress and have most of the cases covered, if anyone wants to take a look:<br>\n<a href=\"https://github.com/rust-lang/chalk/compare/master...daboross:program-writer\" title=\"https://github.com/rust-lang/chalk/compare/master...daboross:program-writer\">https://github.com/rust-lang/chalk/compare/master...daboross:program-writer</a><br>\nThanks for all the advice, it was very useful.</p>",
        "id": 194572834,
        "sender_full_name": "Super Tuple",
        "timestamp": 1587259420
    },
    {
        "content": "<p>I'm looking forward to this being a real thing we can submit!</p>",
        "id": 194572874,
        "sender_full_name": "David Ross",
        "timestamp": 1587259480
    },
    {
        "content": "<p>Nice! Feel free to open a draft/WIP PR, that makes it easier to track ongoing work, and allows leaving early review comments on the code</p>",
        "id": 194583725,
        "sender_full_name": "detrumi",
        "timestamp": 1587280888
    },
    {
        "content": "<p>Instead of getting the trait name from trait_id in several places (I see that you're planning to use the interner debug methods), it might be cleaner to implement <code>RenderAsRust</code> for <code>TraitId&lt;I&gt;</code>, and look up the trait name there</p>",
        "id": 194584196,
        "sender_full_name": "detrumi",
        "timestamp": 1587281707
    },
    {
        "content": "<p>One thing that's going to be important for the <code>.chalk</code> files is that they can be parsed again correctly, as it's easy for the display impl's to get outdated. One way to reduce that might be to re-use code for both debug and display output, if they produce the same output in some places, but that might be tricky.<br>\nWhat you could also do, to ensure that chalk can parse the display output, is to have the tests parse the displayed output, and check that the original program and the reparsed program are the same (<code>Program</code> implements <code>Eq</code> after all)</p>",
        "id": 194584464,
        "sender_full_name": "detrumi",
        "timestamp": 1587282198
    },
    {
        "content": "<p>We were unable to find anything in the chalk program parser or the lowering logic that produces <code>TyData::Placeholder</code> or <code>TyData::InferenceVar</code>.  My guess is they are only produced by goals rather than programs. Do we need to be able to output these, and if so, what program would produce them?</p>",
        "id": 195297678,
        "sender_full_name": "Super Tuple",
        "timestamp": 1587840731
    },
    {
        "content": "<p>You are correct with that guess :)</p>",
        "id": 195298951,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587842734
    },
    {
        "content": "<p>I don't think those will ever get outputed</p>",
        "id": 195298955,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587842749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125131\">detrumi</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/194584464\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/194584464\">said</a>:</p>\n<blockquote>\n<p>One thing that's going to be important for the <code>.chalk</code> files is that they can be parsed again correctly, as it's easy for the display impl's to get outdated. One way to reduce that might be to re-use code for both debug and display output, if they produce the same output in some places, but that might be tricky.<br>\nWhat you could also do, to ensure that chalk can parse the display output, is to have the tests parse the displayed output, and check that the original program and the reparsed program are the same (<code>Program</code> implements <code>Eq</code> after all)</p>\n</blockquote>\n<p>Using reparse tests sounds good! We'll implement that.</p>\n<p>On a related note, do you think it would be reasonable to implement some kind of snapshot testing for display output? We were looking at the insta crate for doing that, but it's another dependency to add (even if only a dev-dependency).</p>\n<p>We're slightly hesitant to reuse debug/display code - I think the biggest problem is that they operate under different constraints. Like, the debug code doesn't have to produce valid code, but it also doesn't have access to all the data we do via RustIrDatabase. That distinction will be slightly muddled if we use the interner debug methods, but they at least seem like a small interface.</p>",
        "id": 195299119,
        "sender_full_name": "David Ross",
        "timestamp": 1587842986
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218710\">David Ross</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/195299119\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/195299119\">said</a>:</p>\n<blockquote>\n<p>On a related note, do you think it would be reasonable to implement some kind of snapshot testing for display output? We were looking at the insta crate for doing that, but it's another dependency to add (even if only a dev-dependency).</p>\n</blockquote>\n<p>I don't think the actual output matters all that much. More so, it matters that it get re-parsed correctly. Keeping around snapshots I don't think makes sense, because we can easily just re-parse and check equality.</p>",
        "id": 195299264,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587843224
    },
    {
        "content": "<p>The output is probably too large to really track in snapshots as well. And having stable output isn't really a goal, it's fine if things change ordering and such (correctness tests and benchmarks are better tools to ensure output quality)</p>",
        "id": 195299515,
        "sender_full_name": "detrumi",
        "timestamp": 1587843595
    },
    {
        "content": "<p>Sounds good! We're writing the reparse tests and it turns out our code had many more errors than we thought</p>",
        "id": 195306612,
        "sender_full_name": "David Ross",
        "timestamp": 1587855625
    },
    {
        "content": "<p>So, I just took a short glance over your branch</p>",
        "id": 195311873,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587865729
    },
    {
        "content": "<p>looking pretty good</p>",
        "id": 195311876,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587865732
    },
    {
        "content": "<p>one thing though</p>",
        "id": 195311880,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587865741
    },
    {
        "content": "<p>that I'm not sure if you've thought about</p>",
        "id": 195311887,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587865750
    },
    {
        "content": "<p>but rather having the <code>WriteProgram</code> impl on <code>Program</code>, we really should have a wrapper around <code>RustIrDatabase</code> of sorts, that essentially intercepts all calls and writes/stores them</p>",
        "id": 195311953,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587865883
    },
    {
        "content": "<p>so we could, for example, wrap the rustc <code>RustIrDatabase</code> while debugging and print that</p>",
        "id": 195312001,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587865933
    },
    {
        "content": "<p>That sounds like a reasonable thing to add to me!</p>\n<p>We haven't written that part of the code yet, but I think everything we have written should be fully applicable to it. Like, there's a little bit of code in WriteProgram, but we should be able to migrate it to the wrapper once we've confirmed all the display code is working well.</p>",
        "id": 195313135,
        "sender_full_name": "David Ross",
        "timestamp": 1587868163
    },
    {
        "content": "<p>Thanks for taking a look at it! We pushed some more commits today that added a lot of test cases, and fixed most of the issues those tests exposed.</p>",
        "id": 195313244,
        "sender_full_name": "Super Tuple",
        "timestamp": 1587868374
    },
    {
        "content": "<p>Yeah, I didn't look super deeply. If you open a WIP PR, I'll spend some time on it and make comments :)</p>",
        "id": 195315691,
        "sender_full_name": "Jack Huey",
        "timestamp": 1587873081
    },
    {
        "content": "<p>what is the current status here?</p>",
        "id": 195720695,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588171723
    },
    {
        "content": "<p>is there a draft PR available?</p>",
        "id": 195720709,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588171727
    },
    {
        "content": "<p>I'm pretty excited to see so much activity <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>",
        "id": 195720726,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588171734
    },
    {
        "content": "<p>No draft PR. Just their branch</p>",
        "id": 195738185,
        "sender_full_name": "Jack Huey",
        "timestamp": 1588178673
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/chalk/compare/master...daboross:program-writer\" title=\"https://github.com/rust-lang/chalk/compare/master...daboross:program-writer\">https://github.com/rust-lang/chalk/compare/master...daboross:program-writer</a></p>",
        "id": 195738218,
        "sender_full_name": "Jack Huey",
        "timestamp": 1588178688
    },
    {
        "content": "<p>^^ I think we were mostly trying to fix all the things we know it's missing before submitting a PR</p>",
        "id": 195780387,
        "sender_full_name": "David Ross",
        "timestamp": 1588201100
    },
    {
        "content": "<p>We've made a WIP PR! <a href=\"https://github.com/rust-lang/chalk/pull/430\" title=\"https://github.com/rust-lang/chalk/pull/430\">https://github.com/rust-lang/chalk/pull/430</a></p>\n<p>We cleaned up a good number of things today; remaining tasks we know about are listed in that PR</p>",
        "id": 196082539,
        "sender_full_name": "David Ross",
        "timestamp": 1588476772
    },
    {
        "content": "<p>I'll take a look :)</p>",
        "id": 196117311,
        "sender_full_name": "Jack Huey",
        "timestamp": 1588532349
    },
    {
        "content": "<p>nice! left a few comments, but I guess it's mostly stuff you know</p>",
        "id": 196219394,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1588616275
    },
    {
        "content": "<p>thanks for that! I think everything seems reasonable, and we'll reply to individual comments in the PR</p>",
        "id": 197019982,
        "sender_full_name": "David Ross",
        "timestamp": 1589066658
    },
    {
        "content": "<p>Unrelated question: for names of things, do you all think it's more important to provide useful name information, or to reduce pollution of RustIrDatabase and the burden on its implementers?</p>\n<p>We've been rediscussing these two possible solutions for naming things:</p>\n<ol>\n<li>ask for exact, valid names, either through new methods on RustIrDatabase or new methods on DebugContext</li>\n<li>\n<p>use existing <code>Interner</code> debug methods, and do post-work to make these valid identifiers.</p>\n<p>I think we can address the concern raised here:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"271698\">Super Tuple</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193684304\" title=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/193684304\">said</a>:</p>\n<blockquote>\n<p>Is there a chance that someone will need the debug methods to output something other than valid syntax? Maybe we can provide some interfaces to give access to the data that these debug methods are using?</p>\n</blockquote>\n<p>by simply replacing invalid characters with <code>_</code>, in a \"best effort\" sort of manner.</p>\n<p>I've double checked and I believe all debug methods necessary to at least try to find names exist.</p>\n</li>\n</ol>\n<p>In either case, we'd be appending identifiers to create unique names. With that, both should be fully viable. </p>\n<p>We're currently aiming to switch to option 2, and just wanted to ensure that's a sane choice. There was that discussion earlier, but I'm not 100% sure if it ended in a consensus?</p>",
        "id": 197021015,
        "sender_full_name": "David Ross",
        "timestamp": 1589067840
    },
    {
        "content": "<p>We have updated the PR with more changes, including an (untested) implementation of the <code>LoggingRustIrDatabase</code>.</p>",
        "id": 197031234,
        "sender_full_name": "Super Tuple",
        "timestamp": 1589083331
    },
    {
        "content": "<p>Another pending question: what kind of integration with ChalkDatabase / the salsa system there do you think we want?</p>\n<p>We were trying to integrate LoggingRustIrDatabase into the existing tests to run it on a variety of cases, but ran into trouble trying to wrap Program while at the same time keeping salsa happy.</p>\n<p>Is it reasonable to try to rerun the logging database on all existing test cases? This would give us a bunch of free test cases for LoggingRustIrDatabase, but seems like it could also triple the time to run tests. Is this worth it, and if so, how would you recommend integrating it?</p>\n<p>We're consider either adding a database wrapper into <code>ChalkDatabase</code>, or just circumventing <code>ChalkDatabase</code> completely.</p>\n<p>For the former, what's the best way to integrate with the salsa system? Could we make <code>ChalkDatabase</code> generic over the wrapper, or somehow give salsa a function for constructing the wrapper? We tried to get this to work, but salsa's requiring <code>Eq</code> bounds makes using <code>dyn RustIrDatabase</code> pretty messy. We haven't tried making <code>ChalkDatabase</code> itself generic yet.</p>\n<p>Since integrating this wrapper with the salsa system in a general way seems overly complicated, what about completely circumventing it? Would it be alright to, in tests, ignore all the <code>ChalkDatabase</code> methods and just construct the solver ourselves - passing it in a <code>LoggingRustIrDatabase</code>?</p>",
        "id": 197826479,
        "sender_full_name": "David Ross",
        "timestamp": 1589683218
    },
    {
        "content": "<p>Oh I was gonna look at these changes</p>",
        "id": 197827944,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686012
    },
    {
        "content": "<p>I think we want to be able to get all the info from RustIrDatabase alone</p>",
        "id": 197827956,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686049
    },
    {
        "content": "<p>I think for logging tests, maybe just add an extra set of tests like we have lowering tests</p>",
        "id": 197827995,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686100
    },
    {
        "content": "<p>I don't think I'm answering your question correctly</p>",
        "id": 197828060,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686248
    },
    {
        "content": "<p>Ah so. Interesting. <code>RustIrDatabase</code> is implemented for both <code>ChalkDatabase</code> and <code>Program</code></p>",
        "id": 197828190,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686520
    },
    {
        "content": "<p>And then <code>LoweringDatabase</code> <em>also</em> extends <code>RustIrDatabase</code></p>",
        "id": 197828260,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686658
    },
    {
        "content": "<p>I feel like this is a little needlessly complicated</p>",
        "id": 197828375,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686884
    },
    {
        "content": "<p>(but I also don't know a <em>ton</em> about how salsa requires it set up)</p>",
        "id": 197828380,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686896
    },
    {
        "content": "<p>I think <code>ChalkDatabase</code> doesn't need to implement <code>RustIrDatabase</code></p>",
        "id": 197828425,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589686950
    },
    {
        "content": "<p>Oh hmm. I see what's happening</p>",
        "id": 197828481,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687061
    },
    {
        "content": "<p>you could just add a \"logging\" field to <code>ChalkDatabase</code> and then wrap the <code>program_ir</code> result with that</p>",
        "id": 197828631,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687370
    },
    {
        "content": "<blockquote>\n<p>Could we make ChalkDatabase generic over the wrapper, or somehow give salsa a function for constructing the wrapper?</p>\n</blockquote>\n<p>I guess that's what you mean here</p>",
        "id": 197828688,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687452
    },
    {
        "content": "<p>But also, to answer your last question: yes I think it's acceptable to just not use <code>ChalkDatabase</code> for logging tests :)</p>",
        "id": 197828707,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687520
    },
    {
        "content": "<p>Since <em>really</em> those tests are only tests the wrapper</p>",
        "id": 197828746,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687541
    },
    {
        "content": "<p>You also can completely ignore and coherence or well formed checks</p>",
        "id": 197828749,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687579
    },
    {
        "content": "<p>Sorry, that was perhaps too much</p>",
        "id": 197828754,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687608
    },
    {
        "content": "<p>I rambled a bit</p>",
        "id": 197828755,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589687614
    },
    {
        "content": "<p>It's all good! I think that hardcoding the logger as a field sounds workable. It feels a little icky, but I guess not as much if I think if <code>ChalkDatabase</code> as a program implementation detail rather than as an API</p>\n<p>the main reason we wanted to use <code>ChalkDatabase</code> rather than not, though, was so we could hook into existing tests &amp; just add it as a tests pass. But I get the feeling that might not be great</p>",
        "id": 197836161,
        "sender_full_name": "David Ross",
        "timestamp": 1589701784
    },
    {
        "content": "<p>If you happen to have more time to review it in the near future, do you think you could also see what you think of this post? <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/197021015\">https://rust-lang.zulipchat.com/#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/197021015</a></p>\n<p>I think that's one the main remaining decision remaining. The others being the logger tests, and the possibility of extending to include solver goals (though I think that could end up reasonably in a future PR?)</p>",
        "id": 197836330,
        "sender_full_name": "David Ross",
        "timestamp": 1589702063
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218710\">@David Ross</span> sorry, what's the question? That link just goes in the middle of my rambling</p>",
        "id": 197859369,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589736103
    },
    {
        "content": "<p>Like I said, it's probably just easiest to not use <code>ChalkDatabase</code> for logging tests. (For now at least. Its already a big PR)</p>",
        "id": 197859453,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589736186
    },
    {
        "content": "<p>Sounds good</p>",
        "id": 197871559,
        "sender_full_name": "David Ross",
        "timestamp": 1589753465
    },
    {
        "content": "<p>With the link, weird. I was trying to point to my post from the 9th about using debug methods vs. adding name methods to RustIrDatabase. After research, both methods seem possible, so we were wondering if your earlier opinion still stood?</p>",
        "id": 197871716,
        "sender_full_name": "David Ross",
        "timestamp": 1589753649
    },
    {
        "content": "<p>Hmm, so if it's possible to have the name methods with a default implementation that falls back to the \"debug-like\" representation, that would be \"best\"</p>",
        "id": 197884078,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589771167
    },
    {
        "content": "<p>though, I'm not <em>super</em> worried about just adding the name methods and having no fallback</p>",
        "id": 197884083,
        "sender_full_name": "Jack Huey",
        "timestamp": 1589771188
    },
    {
        "content": "<p>I'm not sure I understood the salsa problem yet</p>",
        "id": 197980132,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589827969
    },
    {
        "content": "<p>Well I'm sure I didn't :)</p>",
        "id": 197980149,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589827978
    },
    {
        "content": "<p>I guess I better read the PR</p>",
        "id": 197980182,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589828004
    },
    {
        "content": "<p>My opinion on names:</p>\n<p>I don't think the exact names matter. I would tend to prefer simplified names. I think leveraging the <code>debug!</code> output is a fine place to start.</p>",
        "id": 197980205,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1589828015
    },
    {
        "content": "<p>Sounds good - we can implement a fallback. Having the name methods there and optional seems like a good compromise. It'd allow us to keep the tests nice (comparing Program is a lot easier if the names match), and at the same time not place a huge burden on all RustIrDatabase implementors</p>",
        "id": 198560368,
        "sender_full_name": "David Ross",
        "timestamp": 1590283565
    },
    {
        "content": "<p>On a different note, do you have any good ideas for dealing with const values in debug programs?</p>\n<p>We're at a loss trying to figure out the any good way to output <code>ConcreteConst</code> that's correct for general rust programs.</p>\n<p>The main thing chalk seems to expose is <code>const_eq</code>. We were thinking of trying to add a \"const_value\" method, and an implementation for that for <code>chalk-integration</code> doesn't sound hard. However, if I recall correctly, const values can in general be arbitrary rust expression.</p>\n<p>We were also thinking of possibly building up a map of consts to integers we can just insert into the .chalk file source, but building such a map accurately using only <code>const_eq</code> would be <code>O(n^2)</code>, and it seems like there might be cases where even that's technically incorrect or doesn't capture the full nature of the program.</p>\n<p>For instance, how should we output a program like this into a <code>.chalk</code> file?</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">U</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"p\">{</span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 198560888,
        "sender_full_name": "David Ross",
        "timestamp": 1590284822
    },
    {
        "content": "<p>For now, I would say let's get the most simple case working for now</p>",
        "id": 198563597,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590290279
    },
    {
        "content": "<p>Right now, we're only accepting something like <code>2</code> or <code>T</code> for const</p>",
        "id": 198563638,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590290307
    },
    {
        "content": "<p>not more complicated expressions</p>",
        "id": 198563639,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590290313
    },
    {
        "content": "<p>OK - we can add simple support. For that case, do you think it'd be alright to add a new method to get the u32 value? Or if not, is the <code>O(n^2)</code> solution the best one?</p>",
        "id": 198566058,
        "sender_full_name": "David Ross",
        "timestamp": 1590295320
    },
    {
        "content": "<p>Another issues has also popped up: when recording only the calls that are made, we miss a lot of information needed for everything to be well formed.</p>\n<p>For instance, if we have the goal <code>S: Child</code> and the input</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Child</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"bp\">Self</span>: <span class=\"nc\">Parent</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Parent</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Child</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>We completely miss the <code>impl Parent for S</code> (as well as <code>Parent</code>)</p>",
        "id": 198566335,
        "sender_full_name": "David Ross",
        "timestamp": 1590295781
    },
    {
        "content": "<p>We were thinking of possibly recursing through everything mentioned by the printing as well, and that would fix missing <code>Parent</code>, but there doesn't seem an obvious way to get <code>impl Parent for S {}</code> without picking up the universe.</p>",
        "id": 198566394,
        "sender_full_name": "David Ross",
        "timestamp": 1590295911
    },
    {
        "content": "<p>Hmm, I think I'm missing the problem with const</p>",
        "id": 198566435,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590295952
    },
    {
        "content": "<p>I think maybe <span class=\"user-mention\" data-user-id=\"251766\">@Areredify</span> or <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> can better answer that</p>",
        "id": 198566438,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590295966
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218710\">David Ross</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/198566058\">said</a>:</p>\n<blockquote>\n<p>OK - we can add simple support. For that case, do you think it'd be alright to add a new method to get the u32 value? Or if not, is the <code>O(n^2)</code> solution the best one?</p>\n</blockquote>\n<p>What <code>u32</code> value?</p>",
        "id": 198566448,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590295996
    },
    {
        "content": "<p>As far as well formed. I think it depends. If we are logging in a single-goal kind of view, we don't really even <em>need</em> those</p>",
        "id": 198566501,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590296056
    },
    {
        "content": "<p>But if we are logging a <em>series</em> of goals, then we <em>should</em> see a well-formed check somewhere in there</p>",
        "id": 198566508,
        "sender_full_name": "Jack Huey",
        "timestamp": 1590296081
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/198566501\">said</a>:</p>\n<blockquote>\n<p>As far as well formed. I think it depends. If we are logging in a single-goal kind of view, we don't really even <em>need</em> those</p>\n</blockquote>\n<p>But if there's a bug in the code we're logging for, don't we need to pass the well-formedness check in order to get to the point of reproducing it?</p>",
        "id": 198566583,
        "sender_full_name": "David Ross",
        "timestamp": 1590296199
    },
    {
        "content": "<p>Or I might be misunderstanding the goal here</p>",
        "id": 198566651,
        "sender_full_name": "David Ross",
        "timestamp": 1590296284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232957\">Jack Huey</span> <a href=\"#narrow/stream/144729-wg-traits/topic/.2Echalk.20file.20writer/near/198566448\">said</a>:</p>\n<blockquote>\n<p>What <code>u32</code> value?</p>\n</blockquote>\n<p>We were unable to find a way to obtain the input value for a const generic. So we can't display the three below:</p>\n<div class=\"codehilite\"><pre><span></span><code>struct Foo&lt;const T: u32&gt; {}\nimpl Bar for Foo&lt;3&gt; {}\n</code></pre></div>",
        "id": 198566772,
        "sender_full_name": "Super Tuple",
        "timestamp": 1590296551
    },
    {
        "content": "<p>So the question is how to serialize consts for general rust programs?</p>",
        "id": 198574486,
        "sender_full_name": "Areredify",
        "timestamp": 1590311651
    },
    {
        "content": "<p>Uhh I think just making <code>Interner::InternedConst</code> to have a <code>Serialize + Deserialize</code> bounds and let the implementor deal with this is one option</p>",
        "id": 198574775,
        "sender_full_name": "Areredify",
        "timestamp": 1590312093
    },
    {
        "content": "<p>In parser we would <code>Deserialize</code> from the contents of <code>{ ... }</code></p>",
        "id": 198574831,
        "sender_full_name": "Areredify",
        "timestamp": 1590312172
    },
    {
        "content": "<p>Or make interner methods to do that (which is probably more in the spirit of what we already have)</p>",
        "id": 198574969,
        "sender_full_name": "Areredify",
        "timestamp": 1590312448
    },
    {
        "content": "<p>this might be playing devil's advocate a bit - but I think the point is to be able to reproduce chalk problems purely in chalk, without the rustc integration.</p>\n<p>If we have that goal, how could we produce valid chalk syntax from the arbitrary rust expressions?</p>",
        "id": 198574973,
        "sender_full_name": "David Ross",
        "timestamp": 1590312461
    },
    {
        "content": "<p>what would the Serialize / Deserialize go _into_...</p>\n<p>Or maybe it could be like json or something within .chalk files and then it'd use Serialize / Deserialize to go to that?</p>",
        "id": 198575021,
        "sender_full_name": "David Ross",
        "timestamp": 1590312524
    },
    {
        "content": "<p>actually though I think I see it now more than I did initially! It could push the problem to whoever's writing it, and then we could potentially expand .chalk syntax if we ever want to be able to handle and test more complicated situations than just data which can serialize to something unique?</p>",
        "id": 198575197,
        "sender_full_name": "David Ross",
        "timestamp": 1590312855
    },
    {
        "content": "<p>Sorry for being negative initially / not seeing that initially</p>",
        "id": 198575200,
        "sender_full_name": "David Ross",
        "timestamp": 1590312867
    },
    {
        "content": "<p>So hmm</p>",
        "id": 198575213,
        "sender_full_name": "Areredify",
        "timestamp": 1590312928
    },
    {
        "content": "<p>Is chalk file writer interner-agnostic?</p>",
        "id": 198575221,
        "sender_full_name": "Areredify",
        "timestamp": 1590312957
    },
    {
        "content": "<p>Yes; it works over any impl of Interner and RustIrDatabase</p>",
        "id": 198575270,
        "sender_full_name": "David Ross",
        "timestamp": 1590313000
    },
    {
        "content": "<p>In that case yeah, delegating to rustc to [de-]serialize mir bodies or whatever is the way to go</p>",
        "id": 198575339,
        "sender_full_name": "Areredify",
        "timestamp": 1590313091
    },
    {
        "content": "<p>No way chalk is going to know how to parse an arbitrary rust experssion</p>",
        "id": 198575349,
        "sender_full_name": "Areredify",
        "timestamp": 1590313128
    },
    {
        "content": "<p>hm - so would that mean we just don't support re-loading the file without doing so from within rustc?</p>",
        "id": 198575358,
        "sender_full_name": "David Ross",
        "timestamp": 1590313176
    },
    {
        "content": "<p>We won't support re-loading the file unless it was written with the same interner it is being read with</p>",
        "id": 198575427,
        "sender_full_name": "Areredify",
        "timestamp": 1590313259
    },
    {
        "content": "<p>I thought part of the motivation was to reproduce a bug from rustc in chalk - but if that's not a possibility for const generics, then it does seem still useful to be able to reproduce it using rustc</p>",
        "id": 198575441,
        "sender_full_name": "David Ross",
        "timestamp": 1590313276
    },
    {
        "content": "<p>right now everything else in our code is aimed towards re-loading the file with chalk-integration, regardless of where it comes from</p>",
        "id": 198575452,
        "sender_full_name": "David Ross",
        "timestamp": 1590313303
    },
    {
        "content": "<p>Hmm, alternatively, we could require both the original file and the chalk file, so we can just reference mir bodies inside it</p>",
        "id": 198575572,
        "sender_full_name": "Areredify",
        "timestamp": 1590313490
    },
    {
        "content": "<p>I think <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> and <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> can make a more informed decision here than I can</p>",
        "id": 198575641,
        "sender_full_name": "Areredify",
        "timestamp": 1590313615
    },
    {
        "content": "<p>the whole point is to produce a file that can be used as a test in <code>chalk-integration</code>, yeah. Considering other interners have complete control over the representation of consts, I don't think it's possible to faithfully represent all possible consts from all possible interners (unless chalk-integration switches to allowing arbitrary-size integers or byte slices as consts), but it's probably not necessary either. I'd think it's probably fine to make a 'best effort' for now, e.g. by just debug-printing the interned const, or by adding a default-implemented method to <code>Interner</code> that does that</p>",
        "id": 198577074,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590316232
    },
    {
        "content": "<p>basically, I think the operation you would need is mapping from the interner's const representation to <code>u32</code> in an injective way (i.e. respecting the <code>const_eq</code> equality), which is likely not possible in general, can only be done by the interner, and is not a thing that exists \"naturally\" already</p>",
        "id": 198577258,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590316629
    },
    {
        "content": "<p>but an approximation that works correctly for most integer constants would be easy to implement by the interner, of course</p>",
        "id": 198577299,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590316686
    },
    {
        "content": "<p>The problem is with unevaluated consts, not with the evaluated ones, we can of course sort evaluated consts into equivalency classes, n^2 for debug is more than enough</p>",
        "id": 198578660,
        "sender_full_name": "Areredify",
        "timestamp": 1590319188
    },
    {
        "content": "<p>Making a best-effort representation and supporting only evaluated consts is fine, I just think that we have to take unevaluated consts into account early so we won't have to make drastic rewrites later</p>",
        "id": 198578781,
        "sender_full_name": "Areredify",
        "timestamp": 1590319397
    },
    {
        "content": "<p>as long as chalk-integration doesn't have a way of representing unevaluated consts, that seems to be the best we can do. It won't be possible to use the chalk file writer to create tests for problems that only occur with unevaluated consts, but chalk-integration won't be able to represent those problems anyway</p>",
        "id": 198580078,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590321625
    },
    {
        "content": "<p>I don't know about the extent const stuff uses unevaluated consts, it very well might be so virtually all const-related type checking uses it. For example (if I understand const rfc correctly), <code>let x: [u32; N]</code> is in reality <code>let x: [u32; { N }]</code>.</p>",
        "id": 198581266,
        "sender_full_name": "Areredify",
        "timestamp": 1590323569
    },
    {
        "content": "<p>well, the interner (i.e. rustc) will have to deal with that <em>somehow</em>, because even if chalk-integration did model unevaluated consts, I imagine it would do so in an extremely simplified way (maybe by having <code>const X = 1</code> declarations instead of just inline consts). Though I have no idea if that's actually worth having in chalk-integration <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 198582242,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1590325062
    },
    {
        "content": "<p>So far I am inclined to have lowering be dependent on the interner that produced that particular file and knows how to parse mir bodies or w/e</p>",
        "id": 198582632,
        "sender_full_name": "Areredify",
        "timestamp": 1590325583
    },
    {
        "content": "<p>Anyway Im interested what niko and eddyb have to say first</p>",
        "id": 198582644,
        "sender_full_name": "Areredify",
        "timestamp": 1590325618
    },
    {
        "content": "<p>why are MIR bodies under discussion? I don't think there is any way of deserializing them? (feel free to PM me if you are working on that, I have opinions :P. I've mostly discussed it with <span class=\"user-mention\" data-user-id=\"228912\">@James Munns</span>)</p>",
        "id": 202036078,
        "sender_full_name": "eddyb",
        "timestamp": 1593126322
    },
    {
        "content": "<p>we're building a tool that lets chalk dump out isolated tests, so if you are running e.g. rustc and you want to debug a chalk problem, you can reproduce it in standalone chalk. And it will ultimately have to interact with constants and things, though opaquely.</p>",
        "id": 202144889,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593206973
    },
    {
        "content": "<p>I don't think the solution will involve deserializing MIR bodies, though..</p>",
        "id": 202144905,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1593206991
    },
    {
        "content": "<p>I'm experimenting a bit with integrating the .chalk writer into rust-analyzer, and overall it seems to work pretty well. One unexpected thing was that there's placeholders in the output:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[upstream]\n#[non_enumerable]\n#[object_safe]\ntrait IterMutTrait&lt;_1_1&gt;\nwhere\n  Self: DoubleEndedIterator,\n  Self: Iterator&lt;Assoc_type_4909=&amp;&lt;placeholder(!0_18446744073709551615)&gt; mut _1_1&gt;,\n  Self: ExactSizeIterator,\n  Self: Iterator&lt;Assoc_type_4909=&amp;&lt;placeholder(!0_18446744073709551615)&gt; mut _1_1&gt;\n{}\n</code></pre></div>\n\n\n<p>(ignore the <code>Assoc_type_4909</code>, I haven't found a way to display <code>AssocTypeId</code> values properly yet)<br>\nThe <code>&lt;placeholder(..)&gt;</code> part is where it would normally crash with \"cannot print placeholder variables; these should only be in goals not programs\".</p>",
        "id": 202865409,
        "sender_full_name": "detrumi",
        "timestamp": 1593854664
    },
    {
        "content": "<p>Ah, looks like it has to do with lifetimes, since it's the <code>'a</code> in this trait:</p>\n<div class=\"codehilite\"><pre><span></span><code>trait IterMutTrait&lt;&#39;a, T: &#39;a&gt;:\n    DoubleEndedIterator&lt;Item = &amp;&#39;a mut T&gt; + ExactSizeIterator&lt;Item = &amp;&#39;a mut T&gt;\n{\n}\n</code></pre></div>",
        "id": 202865556,
        "sender_full_name": "detrumi",
        "timestamp": 1593854989
    },
    {
        "content": "<p>yeah, we use a placeholder when we have to provide lifetimes because we don't handle them at all yet</p>",
        "id": 202865723,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1593855316
    },
    {
        "content": "<p><a href=\"https://github.com/rust-analyzer/rust-analyzer/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates/ra_hir_ty/src/traits/chalk/mapping.rs#L141\">https://github.com/rust-analyzer/rust-analyzer/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates/ra_hir_ty/src/traits/chalk/mapping.rs#L141</a></p>",
        "id": 202865776,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1593855418
    },
    {
        "content": "<p>Cool. We probably shouldn't crash when trying to display a placeholder then, for now</p>",
        "id": 202865788,
        "sender_full_name": "detrumi",
        "timestamp": 1593855457
    },
    {
        "content": "<p>Ah, and there's some <code>{error}</code>parts in some places, but that's probably also expected:</p>\n<div class=\"codehilite\"><pre><span></span><code>trait RcEqIdent&lt;_1_1&gt;\nwhere\n  _1_1: PartialEq&lt;{error}&gt;\n{}\n</code></pre></div>",
        "id": 202866221,
        "sender_full_name": "detrumi",
        "timestamp": 1593856216
    },
    {
        "content": "<p>it'd probably be good if the error type could be represented in some way in Chalk tests</p>",
        "id": 202868901,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1593860829
    }
]