[
    {
        "content": "<p>I have a type with an <code>AtomicI32</code> field that can't derive Copy and Clone... but I don't see any reason why AtomicI32 can't be Copy and Clone.</p>",
        "id": 252149750,
        "sender_full_name": "hannahE2",
        "timestamp": 1630920382
    },
    {
        "content": "<p>What's the workaround here?</p>",
        "id": 252149759,
        "sender_full_name": "hannahE2",
        "timestamp": 1630920391
    },
    {
        "content": "<p>For Copy an impl would make it too easy to accidentally change a copy instead of the original. For Clone I don't know for sure why it doesn't implement it. Maybe it was deemed too confusing.</p>\n<p>You can manually implement Clone for your struct. You can't manually implement Copy though unless all fields are Copy. You probably shouldn't anyway when using interior mutability.</p>",
        "id": 252150029,
        "sender_full_name": "bjorn3",
        "timestamp": 1630920569
    },
    {
        "content": "<p>Makes little sense to me :/</p>",
        "id": 252150673,
        "sender_full_name": "hannahE2",
        "timestamp": 1630920955
    },
    {
        "content": "<p>An <code>AtomicI32</code> is just an <code>i32</code> that requires memory ops to pointers to it to be performed using atomic ops</p>",
        "id": 252150785,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921001
    },
    {
        "content": "<p>And <code>i32</code>s are <code>Copy + Clone</code></p>",
        "id": 252150828,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921028
    },
    {
        "content": "<p>I guess I can just use <code>i32</code> and transmute back and forth when I need to do atomic updates</p>",
        "id": 252150903,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921079
    },
    {
        "content": "<p>Just need to make sure to preserve the alignment</p>",
        "id": 252150977,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921110
    },
    {
        "content": "<p>Do we guarantee the layout of <code>AtomicI32</code> ? (is it sound to transmute <code>&amp;i32</code> to <code>&amp;AtomicI32</code> ?)</p>",
        "id": 252151020,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921146
    },
    {
        "content": "<p>Not sure</p>",
        "id": 252151034,
        "sender_full_name": "bjorn3",
        "timestamp": 1630921164
    },
    {
        "content": "<p>the documentation for it says</p>\n<blockquote>\n<p>This type has the same in-memory representation as the underlying integer type, i32.</p>\n</blockquote>",
        "id": 252151166,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1630921243
    },
    {
        "content": "<blockquote>\n<p>I guess I can just use <code>i32</code> and transmute back and forth when I need to do atomic updates</p>\n</blockquote>\n<p>No, if you have <code>i32</code> behind an immutable reference updating it is UB. If you have an <code>AtomicI32</code> it isn't UB due to the <code>UnsafeCell</code> wrapper it contains.</p>",
        "id": 252151171,
        "sender_full_name": "bjorn3",
        "timestamp": 1630921245
    },
    {
        "content": "<p>Right, so I need <code>UnsafeCell&lt;i32&gt;</code></p>",
        "id": 252151198,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921269
    },
    {
        "content": "<p>and then transmute <code>&amp;UnsafeCell&lt;i32&gt;</code> to <code>&amp;i32</code> or <code>&amp;AtomicI32</code> as required</p>",
        "id": 252151244,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921302
    },
    {
        "content": "<p>I don't think <code>UnsafeCell</code> implements Copy or Clone, for the same reasons that the atomics don't?</p>",
        "id": 252151315,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1630921330
    },
    {
        "content": "<p>This impacts generics as well</p>",
        "id": 252152458,
        "sender_full_name": "hannahE2",
        "timestamp": 1630921979
    },
    {
        "content": "<p>like <code>struct S&lt;T&gt;(T)</code>, how do I derive Copy for it such that it is Copy when <code>T</code> is <code>AtomicI32</code> ?!</p>",
        "id": 252152510,
        "sender_full_name": "hannahE2",
        "timestamp": 1630922012
    },
    {
        "content": "<p>ok i can just overrie these impls, nice</p>",
        "id": 252152901,
        "sender_full_name": "hannahE2",
        "timestamp": 1630922238
    },
    {
        "content": "<p>I don't think you can make it Copy if <code>T</code> is not Copy</p>",
        "id": 252154522,
        "sender_full_name": "Florian Diebold",
        "timestamp": 1630923142
    },
    {
        "content": "<blockquote>\n<p>For Copy an impl would make it too easy to accidentally change a copy instead of the original. For Clone I don't know for sure why it doesn't implement it. Maybe it was deemed too confusing.</p>\n</blockquote>\n<p>Copy has a different reason actually, it would be impossible to implement soundly, as memcpy or a structural copy is non-atomic. If you copy an atomic that's being written to elsewhere without a happens-before relationship, that's a data race and UB.<br>\nClone could be, but as atomic operations can be expensive, and it's generally not necessary to clone atomics (as typically they reside at a well-known memory address), so I assume that's why it's not Clone.</p>",
        "id": 252161009,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630927173
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/why.20isn't.20AtomicI32.20Copy.20.2B.20Clone.20.3F/near/252151020\">said</a>:</p>\n<blockquote>\n<p>Do we guarantee the layout of <code>AtomicI32</code> ? (is it sound to transmute <code>&amp;i32</code> to <code>&amp;AtomicI32</code> ?)</p>\n</blockquote>\n<p>That seems unsafe since the atomic would allow modifying the value behind the reference while the normal borrow doesn't.</p>",
        "id": 252171798,
        "sender_full_name": "The 8472",
        "timestamp": 1630933090
    },
    {
        "content": "<blockquote>\n<p>Copy has a different reason actually, it would be impossible to implement soundly, as memcpy or a structural copy is non-atomic.</p>\n</blockquote>\n<p>LLVM has atomic memcpy</p>",
        "id": 252183766,
        "sender_full_name": "hannahE2",
        "timestamp": 1630938740
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/why.20isn't.20AtomicI32.20Copy.20.2B.20Clone.20.3F/near/252151020\">said</a>:</p>\n</blockquote>\n<blockquote>\n<p>Do we guarantee the layout of <code>AtomicI32</code> ? (is it sound to transmute <code>&amp;i32</code> to <code>&amp;AtomicI32</code> ?)</p>\n</blockquote>\n<p>That seems unsafe since the atomic would allow modifying the value behind the reference while the normal borrow doesn't.</p>\n<p>It's not guaranteed (it may have stricter size or alignment requirements to function on a particular platform), but on platforms where it is, AtomicI32::from_mut exists (unstable, though).</p>",
        "id": 252197838,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630945852
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/why.20isn't.20AtomicI32.20Copy.20.2B.20Clone.20.3F/near/252183766\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Copy has a different reason actually, it would be impossible to implement soundly, as memcpy or a structural copy is non-atomic.</p>\n</blockquote>\n<p>LLVM has atomic memcpy</p>\n</blockquote>\n<p>It would be very hard, or even impossible to enforce that only for atomics though.</p>",
        "id": 252209429,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1630952893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/why.20isn't.20AtomicI32.20Copy.20.2B.20Clone.20.3F/near/252150785\">said</a>:</p>\n<blockquote>\n<p>An <code>AtomicI32</code> is just an <code>i32</code> that requires memory ops to pointers to it to be performed using atomic ops</p>\n</blockquote>\n<p>Since an <code>AtomicI32</code> may be accessed, and more importantly, <em>mutated</em>, in parallel, a read of it needs to be done in a thread-safe fashion, mainly, an atomic read. <code>Copy</code> is a marker trait for basic bitwise copies, that is, unsynchronized / non-atomic reads.</p>\n<p>So <strong><code>Atomic…</code> very much cannot impl <code>Copy</code></strong>!!</p>\n<p>It could indeed implement <code>Clone</code> since that allows custom code to be inserted, but then remains the question of atomic memory orderings / memory coherence. Since there is no good default for the atomic memory ordering to be used when cloning, it makes sense that <code>AtomicI32</code> do not impl <code>Clone</code>, and to let people define their own custom wrapper types that implement it with the memory ordering they fancy.</p>\n<p>That is, considering a type with no interior padding such as <code>i32</code>, if you wanted something with kind-of-decent defaults (<code>SeqCst</code> ordering…), then you could consider <a href=\"https://docs.rs/crossbeam/0.8.1/crossbeam/atomic/struct.AtomicCell.html#method.load\"><code>AtomicCell</code></a><code>&lt;i32&gt;</code>. For some reason, it doesn't implement <code>Clone</code>, although it would be an excellent candidate for it, especially given how it intends to be a thread-safe equivalent of the <code>Cell</code> type, and how <code>Cell</code> <a href=\"https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#impl-Clone\">does implement <code>Clone</code></a>.</p>\n<ul>\n<li>Tangentially, if there was a type with interior mutability that could implement <code>Copy</code>, then that would very much be <code>Cell&lt;impl Copy&gt;</code>, and <code>Cell&lt;impl Copy&gt;</code> <em>only</em>. It currently can't since <code>Copy</code> currently comes with unavoidable structural requirements, and <code>UnsafeCell</code> does not implement <code>Copy</code> yet to avoid footguns (similar to it, or raw pointers, not implementing <code>Sync</code>, even though it wouldn't be unsound).</li>\n</ul>",
        "id": 252285365,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1631012078
    },
    {
        "content": "<blockquote>\n<p>LLVM has atomic memcpy</p>\n</blockquote>\n<p>Copy requires support for \"normal\" non-arguments memcopy/structural copy.</p>",
        "id": 255354181,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1632900278
    },
    {
        "content": "<p>I would describe a <code>AtomicI32</code>:</p>\n<p>A memory object (not ptr.) which is at least 4 bytes long but (unstable) platform dependent might be larger which semantically contains <code>UnsafeCell&lt;i32&gt;</code> and provides methods to allow lock-free (and often wait-free) mutable access through shared references in the style of C++20 atomics.</p>",
        "id": 255354799,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1632900632
    },
    {
        "content": "<p>One could also think of it as an especially compact rwlock that comes with some predefined critical sections.</p>",
        "id": 255574170,
        "sender_full_name": "The 8472",
        "timestamp": 1633008726
    },
    {
        "content": "<p>I would like an inherent clone method that takes an ordering.</p>",
        "id": 255607585,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1633020630
    },
    {
        "content": "<p>Isn't that just <code>load</code>?</p>",
        "id": 255680319,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1633055215
    },
    {
        "content": "<p>load into new, ig</p>",
        "id": 255680341,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633055235
    },
    {
        "content": "<p>I don't understand the distinction, you can do <code>let x = y.load()</code> without a problem</p>",
        "id": 255680381,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1633055282
    },
    {
        "content": "<p>Well, specifically, it's <code>AtomicN::new(y.load(ord));</code></p>",
        "id": 255680466,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633055365
    },
    {
        "content": "<p>I would like an inherent clone method that takes an ordering.</p>",
        "id": 256259249,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1633445442
    }
]