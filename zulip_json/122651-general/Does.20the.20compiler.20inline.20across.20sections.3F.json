[
    {
        "content": "<p>If you have a function with a link_section attribute to place it in a specific section of the program, can it also still get inlined into other parts of the program?</p>",
        "id": 250532171,
        "sender_full_name": "Lokathor",
        "timestamp": 1629831678
    },
    {
        "content": "<p>I would assume so.</p>",
        "id": 250532367,
        "sender_full_name": "bjorn3",
        "timestamp": 1629831749
    },
    {
        "content": "<p>unfortunate</p>",
        "id": 250532456,
        "sender_full_name": "Lokathor",
        "timestamp": 1629831790
    },
    {
        "content": "<p>yeah it can</p>",
        "id": 250532524,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629831823
    },
    {
        "content": "<p>are you trying to put code in RAM or something like that?</p>",
        "id": 250532544,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629831832
    },
    {
        "content": "<p>oh, or is this the thumb vs. arm mode code thing again?</p>",
        "id": 250532642,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629831862
    },
    {
        "content": "<p><a href=\"https://rust.godbolt.org/z/Gf6qxexGj\">https://rust.godbolt.org/z/Gf6qxexGj</a></p>",
        "id": 250532700,
        "sender_full_name": "bjorn3",
        "timestamp": 1629831893
    },
    {
        "content": "<p>yeah, code in ram</p>",
        "id": 250540100,
        "sender_full_name": "Lokathor",
        "timestamp": 1629835169
    },
    {
        "content": "<p>Couldn't you just add <code>#[inline(never)]</code>?</p>",
        "id": 250757708,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1629977618
    },
    {
        "content": "<p>(or use external linking, but even then LTO can still link it)</p>",
        "id": 250757796,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1629977654
    },
    {
        "content": "<p><code>#[inline(never)]</code> is just a hint. LLVM happily looks at the content of the function for global analysis. Currently it just causes things like calls to such functions to disappear if they don't have side-effects and the result isn't used, but I wouldn't put it past LLVM to try to hoist code out of <code>#[inline(never)]</code> functions in the (far) future.</p>",
        "id": 250767854,
        "sender_full_name": "bjorn3",
        "timestamp": 1629982968
    },
    {
        "content": "<p>I've even seen clang duplicate and const-prop functions that have __attribute__((noinline))</p>",
        "id": 250768982,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629983432
    },
    {
        "content": "<p><code>#[inline(never)]</code> is probably the strongest hint of the three, but like <code>#[inline(always)]</code>, it's a misnomer.</p>",
        "id": 250769289,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629983554
    },
    {
        "content": "<p>yeah we need to, long term, get something that's not a hint</p>",
        "id": 250769391,
        "sender_full_name": "Lokathor",
        "timestamp": 1629983592
    },
    {
        "content": "<p>It may be possible to make <code>#[inline(never)]</code> actually guaranteed? I would prefer that we don't get a guaranteed <code>#[inline(always)]</code> because that implies that rust compilers MUST include the ability to inline functions at all (which, while that behaviour may be desirable of any optimizing compiler, it complicates non-optimizing compilers).</p>",
        "id": 250769832,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629983775
    },
    {
        "content": "<p>most of the compiler pipeline is also angostic to linkage concerns.</p>",
        "id": 250771615,
        "sender_full_name": "nagisa",
        "timestamp": 1629984560
    },
    {
        "content": "<p>I wouldn't say thay inline(absolutely_never) doesn't imply that you're able to inline, it just implies that if inline happens, this one won't be considered.</p>",
        "id": 250777697,
        "sender_full_name": "Lokathor",
        "timestamp": 1629986986
    },
    {
        "content": "<p>Why does this need a separate attribute? Just make inline(never) behave how inline (absolutely_never) would</p>",
        "id": 250779130,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629987515
    },
    {
        "content": "<p>uh, sure? I don't care, but currently it's a hint is all</p>",
        "id": 250779531,
        "sender_full_name": "Lokathor",
        "timestamp": 1629987676
    },
    {
        "content": "<blockquote>\n<p>I wouldn't say thay inline(absolutely_never) doesn't imply that you're able to inline, it just implies that if inline happens, this one won't be considered.</p>\n</blockquote>\n<p>I was saying <code>inline(always)</code> being anything other than a strong hint would imply rust impls must inline.</p>",
        "id": 250790642,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629991681
    },
    {
        "content": "<p>Although, I guess it could be the same - if any function would be inlined, a function marked inline(always) that can be, must be.</p>",
        "id": 250791839,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629992156
    },
    {
        "content": "<p>Unless it is done at MIR level I don't want to guarantee that <code>#[inline(always)]</code> is always inlined. Not every backend (eg cg_clif) implements inlining.</p>",
        "id": 250801780,
        "sender_full_name": "bjorn3",
        "timestamp": 1629995851
    },
    {
        "content": "<p>i think doing it at MIR level is the right solution then. I think <code>#[inline(always)]</code> ever not inlining is a bug, although i guess we could push people who really need it to use macros instead.</p>",
        "id": 250807965,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629998317
    },
    {
        "content": "<p>it can't inline recursion, for example</p>",
        "id": 250808215,
        "sender_full_name": "cuviper",
        "timestamp": 1629998428
    },
    {
        "content": "<p>hmm, I feel like it should warn if it's really impossible to inline</p>",
        "id": 250808408,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629998539
    },
    {
        "content": "<blockquote>\n<p>i think doing it at MIR level is the right solution then. I think <code>#[inline(always)]</code> ever not inlining is a bug, although i guess we could push people who really need it to use macros instead.</p>\n</blockquote>\n<p>Still rules out other impls that may not have inlining support (at the current time, or as-planned).</p>",
        "id": 250810943,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629999577
    },
    {
        "content": "<p>It could be reasonable to lint - that's a trivial implementation if it really doesn't support inlining whatsoever.</p>",
        "id": 250811165,
        "sender_full_name": "Connor Horman",
        "timestamp": 1629999657
    },
    {
        "content": "<blockquote>\n<p>it can't inline recursion, for example</p>\n</blockquote>\n<p>Heavy agreement that it should at least warn if you try to use <code>#[inline(always)]</code> on a recursive function.</p>\n<blockquote>\n<p>Still rules out other impls that may not have inlining support (at the current time, or as-planned).</p>\n</blockquote>\n<p>I don't think this is the most difficult thing in the list of things a compiler must support in order to implement Rust.</p>",
        "id": 250815059,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1630001272
    },
    {
        "content": "<p>One of the problems here is that you need to specify what <code>inline</code> actually does if it's not just a hint, but in the abstract machine it doesn't do anything, thus making it something other than a lint difficult.</p>\n<p>That said, I'd love more options for inlining.  For example, we have a bunch of things where it'd be great for them to be inlined into their <em>callers</em> before inlining their <em>callees</em> into themselves.  But the LLVM ones is bottom-up-only right now, IIRC.</p>",
        "id": 250818975,
        "sender_full_name": "scottmcm",
        "timestamp": 1630002972
    },
    {
        "content": "<p>Guarantees like that also make alternative implementations hard.</p>",
        "id": 250819033,
        "sender_full_name": "nagisa",
        "timestamp": 1630003010
    },
    {
        "content": "<p>performance!</p>",
        "id": 250819679,
        "sender_full_name": "Lokathor",
        "timestamp": 1630003293
    },
    {
        "content": "<p>but I'd really like the other way: <em>guaranteed to not be inlined</em></p>",
        "id": 250819730,
        "sender_full_name": "Lokathor",
        "timestamp": 1630003323
    },
    {
        "content": "<p>Being able to rely on the fact that there won't be a stack frame associated with the call, for example. Also yes, performance.</p>",
        "id": 250819853,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1630003384
    },
    {
        "content": "<p>Performance is not a justification for a guarantee in the abstract machine. A valid implementation of rust could compile to brainf*ck code, running inside java, on a super nintendo. Would guaranteed inlining be useful to code running in such an implementation?</p>",
        "id": 250825890,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630005968
    },
    {
        "content": "<p>I gave another justification.</p>",
        "id": 250827398,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1630006581
    },
    {
        "content": "<p>For example, when accessing a backtrace, you may want to hide (or force) certain frames to be captured as part of that backtrace.</p>",
        "id": 250827683,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1630006696
    },
    {
        "content": "<p>True.</p>",
        "id": 250828597,
        "sender_full_name": "Connor Horman",
        "timestamp": 1630007084
    },
    {
        "content": "<p>they will still show up when debuginfo is enabled. unless it is a tail call, in which case even debuginfo and <code>#[inline(never)]</code> won't help keeping the frame. you need something like a volatile read after the call to prevent tco. libstd had to do this to get short backtraces to work again.</p>",
        "id": 250832248,
        "sender_full_name": "bjorn3",
        "timestamp": 1630008532
    },
    {
        "content": "<p>It's been a while, but this still matters when implementing backtraces. Anyway, the point is whether or not something is inlined is not entirely a noop in the abstract machine, just partially.</p>",
        "id": 250847903,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1630015619
    },
    {
        "content": "<p>(I'm pretty sure that backtraces aren't part of the abstract machine either -- or at very least they definitely have no stability guarantees, since otherwise no heuristics could be changed.)</p>",
        "id": 250850603,
        "sender_full_name": "scottmcm",
        "timestamp": 1630016933
    },
    {
        "content": "<p>backtraces have to be part of the abstract machine, but they aren't stable</p>",
        "id": 250852028,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630017683
    },
    {
        "content": "<p>it seems similar to pointer addresses, in that they are very obviously observable differences in response to compiler-internal changes, so \"observational equivalence\" is useless as a litmus test for compiler optimizations like eliminating a malloc / inlining a function</p>",
        "id": 250852463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630017921
    },
    {
        "content": "<p>I think an <code>inline(always)</code> that's guaranteed to work (or emit an error) makes sense. Among other uses, wrappers around inline assembly make sense to be always inlined.</p>",
        "id": 251239762,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630334495
    },
    {
        "content": "<p>clearly we need repr(transparent) on functions</p>",
        "id": 251248649,
        "sender_full_name": "Lokathor",
        "timestamp": 1630337975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> We actually specify that <code>asm!()</code> invocations may be outlined by any backend for compatibility with backends that don't natively support inline asm. cg_clif uses an external assembler to assemble the <code>asm!()</code> by wrapping it in instructions to implement the SystemV abi, making it possible to call it from a cranelift generated function.</p>",
        "id": 251263859,
        "sender_full_name": "bjorn3",
        "timestamp": 1630344517
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/2873-inline-asm.html#supporting-back-ends-without-inline-assembly\">https://rust-lang.github.io/rfcs/2873-inline-asm.html#supporting-back-ends-without-inline-assembly</a></p>",
        "id": 251264003,
        "sender_full_name": "bjorn3",
        "timestamp": 1630344592
    },
    {
        "content": "<p>Fair point, I'd forgotten that. (I do hope we add \"native\" inline asm support there one day, but <em>shrug</em>.)</p>",
        "id": 251302189,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1630361147
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/122651-general/topic/Does.20the.20compiler.20inline.20across.20sections.3F/near/250532456\">said</a>:</p>\n<blockquote>\n<p>unfortunate</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> if you want to prevent it from being inlined, this seems to work on Godbolt: <a href=\"https://godbolt.org/z/GrWEdf5eT\">https://godbolt.org/z/GrWEdf5eT</a><br>\nIt basically wraps a function pointer inside a global <code>UnsafeCell</code> to fool the compiler into thinking that it might be mutated from other threads, therefore it won't be inlined.</p>",
        "id": 251517696,
        "sender_full_name": "Pointerbender",
        "timestamp": 1630482808
    },
    {
        "content": "<p>Also it does not make use of the <code>inline</code> attribute</p>",
        "id": 251517796,
        "sender_full_name": "Pointerbender",
        "timestamp": 1630482857
    },
    {
        "content": "<p>There are other optimizations here that can be sketchy – function deduplication comes to mind.</p>",
        "id": 251523321,
        "sender_full_name": "nagisa",
        "timestamp": 1630485686
    },
    {
        "content": "<p>Good point <span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span>  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  I guess this is because of the <code>link_section</code> attribute?</p>",
        "id": 251524612,
        "sender_full_name": "Pointerbender",
        "timestamp": 1630486275
    },
    {
        "content": "<p>When all the function pointers point to the same <code>link_section</code>, it seems to deduplicate functions alright: <a href=\"https://godbolt.org/z/fTf8K9e4x\">https://godbolt.org/z/fTf8K9e4x</a> (This is not the case when there are multiple <code>link_section</code> holding identical code). Curious now how this plays out with generics on functions <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 251535220,
        "sender_full_name": "Pointerbender",
        "timestamp": 1630491426
    },
    {
        "content": "<p>With generics it also deduplicates functions, but slightly differently: <a href=\"https://godbolt.org/z/bn841rfxK\">https://godbolt.org/z/bn841rfxK</a><br>\nWithout generics the assembly is <code>jmp     qword ptr [rip + example::square@GOTPCREL]</code> and with generics the assembly says <code>jmp     example::square</code></p>",
        "id": 251536427,
        "sender_full_name": "Pointerbender",
        "timestamp": 1630492034
    }
]