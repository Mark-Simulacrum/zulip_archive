[
    {
        "content": "<p>Hi everyone, I have been working with a small group of people to add  <code>std</code> support for the recently added <code>armv6k-nintendo-3ds</code> target (<a href=\"https://github.com/rust-lang/rust/pull/88529\">https://github.com/rust-lang/rust/pull/88529</a>) . A lot of the changes have just been adding <code>#[cfg]</code> where needed to enable std, but we have found some places where <code>std</code> doesn't provide as much of an API as we'd like.</p>\n<p>Specifically in this case <code>std::thread</code> does not seem to provide any API for setting CPU affinity or priority, which are usually required on the 3DS due to its cooperative threading model. So, we have a model with an extension trait that lives in <code>std::os::horizon</code> (OS-specific module), but it would require some code changes to other <code>sys::thread</code> modules in order to function properly.</p>\n<p>So, I basically have two questions:</p>\n<ol>\n<li>For the best chance of upstreaming the changes for <code>std</code> working on our target, how should we approach PRs to mainline? All the work is in a fork for now and requires some special linking with other crates and <code>-Zbuild-std</code> to work, but the majority of the code changes to <code>std</code> are fairly minimal. It does seem preferred to avoid a huge PR all at once to merge support, though...</li>\n<li>For larger changes like adding an OS-specific extension trait to <code>std::thread::ThreadBuilder</code>, would we need to create an RFC  or MCP ? This is not something that would impact any other OS users, and is mostly an implementation detail within <code>sys::thread::ThreadBuilder</code>, but it does include some public surface area, so we wanted to make sure adding something like this wouldn't prevent a merge upstream. </li>\n</ol>\n<p>Thanks in advance for your help. Any advice from maintainers / other <code>std</code> hackers appreciated.</p>\n<p>CC <span class=\"user-mention\" data-user-id=\"452421\">@Meziu</span>  <span class=\"user-mention\" data-user-id=\"218805\">@Mark Drobnak</span></p>",
        "id": 271654826,
        "sender_full_name": "Ian Chamberlain",
        "timestamp": 1644623768
    },
    {
        "content": "<p>ThreadBuilder? Is setting the priority after it has been created not an option?</p>",
        "id": 271656858,
        "sender_full_name": "The 8472",
        "timestamp": 1644625551
    },
    {
        "content": "<blockquote>\n<p>but it does include some public surface area</p>\n</blockquote>\n<p>This probably is the most critical part. OS-specific extension traits are less of an issue.</p>",
        "id": 271656936,
        "sender_full_name": "The 8472",
        "timestamp": 1644625624
    },
    {
        "content": "<p>It doesn't actually include any public interface changes besides the extension trait</p>",
        "id": 271658213,
        "sender_full_name": "Mark Drobnak",
        "timestamp": 1644626889
    },
    {
        "content": "<p>The thing we're most concerned about is some changes to the internal <code>sys::thread</code> interface that abstracts platform implementation details, which is needed to make this extension trait work.</p>\n<p>The details are here if you're interested: <a href=\"https://github.com/Meziu/rust-horizon/pull/10\">https://github.com/Meziu/rust-horizon/pull/10</a></p>",
        "id": 271658313,
        "sender_full_name": "Mark Drobnak",
        "timestamp": 1644627000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/std.3A.3Athread.20support.20for.20armv6k-nintendo-3ds/near/271656858\">said</a>:</p>\n<blockquote>\n<p>ThreadBuilder? Is setting the priority after it has been created not an option?</p>\n</blockquote>\n<p>I'm not sure if this is possible with the APIs we have available for affinity + priority, but if so I wonder if we could just use the existing <a href=\"https://doc.rust-lang.org/std/os/unix/thread/trait.JoinHandleExt.html\"><code>JoinHandleExt::as_pthread_t()</code></a> and use the same APIs on that, in user code rather than in <code>std</code> itself...</p>",
        "id": 271658408,
        "sender_full_name": "Ian Chamberlain",
        "timestamp": 1644627066
    },
    {
        "content": "<p>More important is CPU affinity, which should be set at thread creation</p>",
        "id": 271658433,
        "sender_full_name": "Mark Drobnak",
        "timestamp": 1644627098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"352170\">Ian Chamberlain</span> <a href=\"#narrow/stream/122651-general/topic/std.3A.3Athread.20support.20for.20armv6k-nintendo-3ds/near/271658408\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/std.3A.3Athread.20support.20for.20armv6k-nintendo-3ds/near/271656858\">said</a>:</p>\n<blockquote>\n<p>ThreadBuilder? Is setting the priority after it has been created not an option?</p>\n</blockquote>\n<p>I'm not sure if this is possible with the APIs we have available for affinity + priority, but if so I wonder if we could just use the existing <a href=\"https://doc.rust-lang.org/std/os/unix/thread/trait.JoinHandleExt.html\"><code>JoinHandleExt::as_pthread_t()</code></a> and use the same APIs on that, in user code rather than in <code>std</code> itself...</p>\n</blockquote>\n<p>The closest thing I found is <a href=\"https://github.com/devkitPro/libctru/blob/4815537048b3143dd677584f37cf09fb3caa737d/libctru/include/3ds/svc.h#L886\"><code>svcSetThreadAffinityMask</code></a>, but not sure if that's actually related. There's not much docs on it.</p>\n<p>Either way setting the affinity after the fact makes it hard to spawn threads from the system core (can only have one of those).</p>",
        "id": 271659556,
        "sender_full_name": "Mark Drobnak",
        "timestamp": 1644628197
    },
    {
        "content": "<p>I would definitely advise making the entire thread thing, or at least the part that adds new public API, a separate PR into std if at all possible, based on what this sounds like. Remember, as a tier 3 target, it's fine if a std API is only <code>todo!()</code></p>",
        "id": 271661539,
        "sender_full_name": "Jubilee",
        "timestamp": 1644630251
    },
    {
        "content": "<p>Think of it as shipping a vertical slice. <span aria-label=\"relieved\" class=\"emoji emoji-1f60c\" role=\"img\" title=\"relieved\">:relieved:</span></p>",
        "id": 271661973,
        "sender_full_name": "Jubilee",
        "timestamp": 1644630782
    },
    {
        "content": "<p>It doesn't seem unacceptable to pass the builder in on thread creation but yeah it should be its own PR</p>",
        "id": 271673298,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644647744
    }
]