[
    {
        "content": "<p>If a Vec-like struct has some heap memory allocated, but has already drained the values inside, what's the correct way to deallocate that memory (which is now in an invalid state)?</p>\n<p>For example,</p>\n<div class=\"codehilite\"><pre><span></span><code>struct MyVec&lt;T&gt; {\n    contents: *const T,\n    capacity: usize,\n    length: usize,\n}\n\nimpl&lt;T&gt; Drop for MyVec&lt;T&gt; {\n    fn drop(&amp;mut self) {\n        // There&#39;s no easy way to deal with half-initialized arrays/slices.\n        // To get a fully-uninitialized array, iterate over the contents,\n        // dropping them.\n        for _ in self.drain() {}\n        unsafe {\n            // Now that the contents have been dropped, drop the array memory\n            // without interpreting it as initialized.\n            let contents = self.contents as *mut MaybeUninit&lt;T&gt;;\n            let raw_slice = slice::from_raw_parts_mut(contents, self.capacity);\n            let _dropme = Box::from_raw(raw_slice);\n        }\n    }\n}\n</code></pre></div>\n<p>Is there an easier way to drop a raw slice than casting it as a slice of <code>MaybeUninit</code>, then adopting it into a <code>Box&lt;[MaybeUninit&lt;T&gt;]</code>, then dropping the Box?</p>",
        "id": 273049045,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645680228
    },
    {
        "content": "<p>Deallocate the memory without running any destructors of T. With Vec you could do that with <code>.set_len(0)</code> for example.</p>",
        "id": 273049914,
        "sender_full_name": "mejrs",
        "timestamp": 1645681310
    },
    {
        "content": "<p>Where are you getting the pointer from?</p>",
        "id": 273049967,
        "sender_full_name": "mejrs",
        "timestamp": 1645681335
    },
    {
        "content": "<p>This (and other things) are also answered by <a href=\"https://doc.rust-lang.org/nomicon/vec/vec.html\">https://doc.rust-lang.org/nomicon/vec/vec.html</a></p>",
        "id": 273050008,
        "sender_full_name": "mejrs",
        "timestamp": 1645681408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"433532\">mejrs</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273049967\">said</a>:</p>\n<blockquote>\n<p>Where are you getting the pointer from?</p>\n</blockquote>\n<p>In my current code, the pointer and length began life as a <code>Box&lt;[T]&gt;</code>, though it's possible that they could have originated from a Vec as well. There's no FFI in the picture; I am just experimenting with my own Vec-like constructs.</p>",
        "id": 273051712,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645683349
    },
    {
        "content": "<p>The comment mentions that the contents start \"half-initialized\". If the vector is not fully initialized, then <code>self.drain()</code> causes UB just from reading uninitialized memory, and dropping the values returned from it can cause further UB depending on <code>T</code>.</p>",
        "id": 273051770,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1645683387
    },
    {
        "content": "<p>If it is fully initialized, then the <code>drop</code> function is trivial:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">raw_slice</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts_mut</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">contents</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">capacity</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">from_raw</span><span class=\"p\">(</span><span class=\"n\">raw_slice</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273051792,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1645683419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"429617\">LegionMammal978</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273051770\">said</a>:</p>\n<blockquote>\n<p>The comment mentions that the contents start \"half-initialized\". If the vector is not fully initialized, then <code>self.drain()</code> causes UB just from reading uninitialized memory, and dropping the values returned from it can cause further UB depending on <code>T</code>.</p>\n</blockquote>\n<p>Sorry if the comment is misleading; the \"half-initialized\" state would result from a fully-initialized <code>MyVec</code> that has been partially drained.<br>\nSo what was once a 4-element array of valid values could now be e.g. a 4-element array containing 2 valid values and 2 invalid values. The call to drain() is meant to drop the remaining valid values to place the memory in a fully invalid state.</p>",
        "id": 273051806,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645683450
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"433532\">mejrs</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273050008\">said</a>:</p>\n<blockquote>\n<p>This (and other things) are also answered by <a href=\"https://doc.rust-lang.org/nomicon/vec/vec.html\">https://doc.rust-lang.org/nomicon/vec/vec.html</a></p>\n</blockquote>\n<p>This looks quite useful, thanks! I wasn't familiar with this style of deallocation.</p>",
        "id": 273051957,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645683643
    },
    {
        "content": "<p>Note that <code>std::alloc::dealloc</code> may eventually be deprecated; your current code is the most futureproof, since it doesn't depend on the <code>Box</code>'s underlying allocator.</p>",
        "id": 273052319,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1645684103
    },
    {
        "content": "<p>If you use something like box::from_raw to deallocate it, you can't use a pointer derived from vec</p>",
        "id": 273053974,
        "sender_full_name": "mejrs",
        "timestamp": 1645686037
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"383356\">Eric Seppanen</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273049045\">said</a>:</p>\n<blockquote>\n<p>If a Vec-like struct has some heap memory allocated, but has already drained the values inside, what's the correct way to deallocate that memory (which is now in an invalid state)?</p>\n<p>For example,</p>\n<p><div class=\"codehilite\"><pre><span></span><code>struct MyVec&lt;T&gt; {\n    contents: *const T,\n    capacity: usize,\n    length: usize,\n}\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Have you considered just storing that as</p>\n<div class=\"codehilite\"><pre><span></span><code>struct MyVec&lt;T, A = Global&gt; {\n    buffer: Box&lt;[MaybeUninit&lt;T&gt;], A&gt;,\n    length: usize,\n}\n</code></pre></div>\n<p>instead?  Then the drop glue will correctly handle deallocating, so you can not worry about that part and will just need to deal with <code>drop_in_place</code>ing the initialized elements.</p>\n<p>But in general, <code>.for_each(drop);</code> to run an iterator to the end is a great way to deal with the elements.</p>\n<p><code>vec::Drain</code> has such a loop too: <a href=\"https://doc.rust-lang.org/1.58.0/src/alloc/vec/drain.rs.html#134-139\">https://doc.rust-lang.org/1.58.0/src/alloc/vec/drain.rs.html#134-139</a></p>",
        "id": 273054206,
        "sender_full_name": "scottmcm",
        "timestamp": 1645686300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"433532\">mejrs</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273053974\">said</a>:</p>\n<blockquote>\n<p>If you use something like box::from_raw to deallocate it, you can't use a pointer derived from vec</p>\n</blockquote>\n<p>Why is that?</p>",
        "id": 273055163,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645687280
    },
    {
        "content": "<p>Short answer: because the documentation says so</p>",
        "id": 273056928,
        "sender_full_name": "mejrs",
        "timestamp": 1645689242
    },
    {
        "content": "<p>Can you point me toward the relevant documentation?</p>",
        "id": 273057113,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645689431
    },
    {
        "content": "<p>Long answer: I'm not really qualified to explain, but these types can allocate in different ways, so you generally can only use from_raw types functions if they came from appropriate into_raw functions</p>",
        "id": 273057193,
        "sender_full_name": "mejrs",
        "timestamp": 1645689486
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw\">https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw</a></p>",
        "id": 273057236,
        "sender_full_name": "mejrs",
        "timestamp": 1645689542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"433532\">mejrs</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273057236\">said</a>:</p>\n<blockquote>\n<p><a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw\">https://doc.rust-lang.org/std/boxed/struct.Box.html#method.from_raw</a></p>\n</blockquote>\n<p>I don't see any rules there about the origin of the pointer.</p>",
        "id": 273057624,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645689858
    },
    {
        "content": "<p>Also, I don't understand how <code>Vec::into_boxed_slice</code> could work then, because it seems to do a very similar thing.</p>",
        "id": 273057704,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645689949
    },
    {
        "content": "<p><code>Box::from_raw</code> requires the allocation to be exactly as big as the type says. A <code>Vec</code> often has extra capacity. <code>Vec::into_boxed_slice</code> reallocates to drop the extra capacity if any.</p>",
        "id": 273057963,
        "sender_full_name": "bjorn3",
        "timestamp": 1645690172
    },
    {
        "content": "<p>imo </p>\n<blockquote>\n<p>For this to be safe, the memory must have been allocated in accordance with the memory layout used by Box .</p>\n</blockquote>\n<p>That and the Vec docs are vague enough. and I don't see it spelled out anywhere, so that's why i wouldn't recommend it</p>",
        "id": 273058092,
        "sender_full_name": "mejrs",
        "timestamp": 1645690272
    },
    {
        "content": "<p>Also looking at std's implementation details to see what is allowed is usually a bad idea, because they're... well, implementation details</p>",
        "id": 273058175,
        "sender_full_name": "mejrs",
        "timestamp": 1645690325
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273057963\">said</a>:</p>\n<blockquote>\n<p><code>Box::from_raw</code> requires the allocation to be exactly as big as the type says. A <code>Vec</code> often has extra capacity. <code>Vec::into_boxed_slice</code> reallocates to drop the extra capacity if any.</p>\n</blockquote>\n<p>Here I'm assuming code (like that at the top) which is capable of tracking the spare capacity also. I think the question is whether the heap-allocated-bytes backing a Vec are compatible with the heap-allocated-bytes inside a boxed slice. Enough that converting one into the other and then deallocating that memory is safe.</p>",
        "id": 273058288,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645690442
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"433532\">@mejrs</span>  I would love to see more documentation of what you're describing.</p>\n<p>The fact that std <code>Vec&lt;T&gt;</code> and <code>Box&lt;[T]&gt;</code> can be converted back and forth without reallocating (excluding the possible shrink_to_fit)  seems like a pretty strong signal that there's no magic \"pointer provenance\" violation there.</p>",
        "id": 273058654,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645690686
    },
    {
        "content": "<p>The Vec and Box docs have documentation about what they guarantee</p>",
        "id": 273059344,
        "sender_full_name": "mejrs",
        "timestamp": 1645691230
    },
    {
        "content": "<p>Can you be more specific? I'm not seeing it.</p>",
        "id": 273059690,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645691494
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/alloc/vec/struct.Vec.html#guarantees\">https://doc.rust-lang.org/alloc/vec/struct.Vec.html#guarantees</a><br>\n<a href=\"https://doc.rust-lang.org/alloc/boxed/index.html#memory-layout\">https://doc.rust-lang.org/alloc/boxed/index.html#memory-layout</a></p>",
        "id": 273059765,
        "sender_full_name": "mejrs",
        "timestamp": 1645691523
    },
    {
        "content": "<p>I don't think those pages mean to say that Vec&lt;-&gt;Box by way of raw pointers is unsound by definition.</p>",
        "id": 273060429,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645691976
    },
    {
        "content": "<p>Yeah that's my point - it doesn't say it's allowed, so I'm assuming it is just an implementation detail and not allowed</p>",
        "id": 273060960,
        "sender_full_name": "mejrs",
        "timestamp": 1645692354
    },
    {
        "content": "<p>The uninitialized space is pretty hazardous, and I would probably want to stay away from that.<br>\nIf I'm calling <code>into_boxed_slice</code>, then I would certainly hope that Box can deconstructed, later reassembled, and freed (as a <code>Box&lt;[T]&gt;</code>).</p>",
        "id": 273061021,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645692374
    },
    {
        "content": "<p>That's why <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> 's solution uses <code>Box&lt;[MaybeUninit&lt;T&gt;], A&gt;</code></p>",
        "id": 273061086,
        "sender_full_name": "mejrs",
        "timestamp": 1645692445
    },
    {
        "content": "<p>(It makes it clear that the job of <em>this</em> type is just to track the initialized-ness of the slots in that storage.  Actually deallocating the space is <code>Box</code>'s problem.  And you can use something like <code>MaybeUninit::slice_assume_init_mut(&amp;mut self.buffer[..self.length])</code> in your <code>DerefMut</code> if you want to give out <code>&amp;mut [T]</code>s.)</p>",
        "id": 273061475,
        "sender_full_name": "scottmcm",
        "timestamp": 1645692728
    },
    {
        "content": "<p>I like <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span>'s code too. I don't think that has much to do with the argument whether pointers with Vec origin are unsound (when dropped as a boxed slice of <code>MaybeUninit&lt;T&gt;</code>).</p>",
        "id": 273061847,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1645692993
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/122651-general/topic/Dropping.20a.20raw.20slice.20that.20contains.20invalid.20values/near/273054206\">said</a>:</p>\n<blockquote>\n<p><code>vec::Drain</code> has such a loop too: <a href=\"https://doc.rust-lang.org/1.58.0/src/alloc/vec/drain.rs.html#134-139\">https://doc.rust-lang.org/1.58.0/src/alloc/vec/drain.rs.html#134-139</a></p>\n</blockquote>\n<p>Had. <a href=\"https://doc.rust-lang.org/nightly/src/alloc/vec/drain.rs.html#106\">https://doc.rust-lang.org/nightly/src/alloc/vec/drain.rs.html#106</a></p>",
        "id": 273084368,
        "sender_full_name": "The 8472",
        "timestamp": 1645707081
    }
]