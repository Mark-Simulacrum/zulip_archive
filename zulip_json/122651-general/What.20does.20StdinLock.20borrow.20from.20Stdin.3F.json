[
    {
        "content": "<p>i can't seem to use <code>io::stdin().lock()</code> without explicitly binding <code>io::stdin()</code> in that scope. i've seen other explanations of this problem, but none that clearly identify exactly what is still borrowed from <code>Stdin</code>. the closest i can think of is that <code>Stdin::lock()</code> has <code>-&gt; StdinLock&lt;'_&gt;</code>, which might make the borrow checker think that <code>StdinLock</code> holds a ref to something in <code>Stdin</code></p>",
        "id": 238995660,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621188072
    },
    {
        "content": "<p>why couldn't <code>Stdin::lock()</code> return <code>StdinLock&lt;'static&gt;</code>? the only ref that <code>StdinLock</code> seems to hold is the <code>Mutex</code> (indirectly through <code>MutexGuard</code>, and the <code>Mutex</code>  is static</p>",
        "id": 238996010,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621188387
    },
    {
        "content": "<p>ok, trying to replicate what <code>Stdin</code> does, it seems like a lifetime of <code>'static</code> would probably work? i think this might be a bug in <code>std::io</code>. is there something i'm missing? <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=3d5d7666e9ada98a6a6e4287ce783fcc\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=3d5d7666e9ada98a6a6e4287ce783fcc</a></p>",
        "id": 239002557,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621195479
    },
    {
        "content": "<p>i don't get it; why do any of the locked stdio handles take a lifetime parameter at all, if they're all going to reference a static <code>Mutex</code>?</p>",
        "id": 239002943,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621195820
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/85383\">https://github.com/rust-lang/rust/issues/85383</a></p>",
        "id": 239007538,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621200370
    },
    {
        "content": "<p>Perhaps an owned mutex was used in the past or the option to do so is supposed to be kept open.</p>",
        "id": 239010018,
        "sender_full_name": "The 8472",
        "timestamp": 1621202893
    },
    {
        "content": "<p>I'm not sure why when &amp;self = &amp;'a Stdin, self.inner, that resolves to 'a &amp;'static Mutex&lt;...&gt; is not being lifted to 'static &amp;'static Mutex&lt;...&gt;. I shot a more detailed comment in the issue - seems to me that if reference's underlying type does not reference non-static lifetimes, 'a &amp;'static X can be lifted to 'static &amp;'static X.<br>\nAFAICT that's an application of theorem from modal logic: if somewhere it is true that X is true everywhere, then X is true everywhere.<br>\n(in this case, \"somewhen\" I guess).</p>",
        "id": 239011300,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621204274
    },
    {
        "content": "<p>What do you mean by <code>'a &amp;'static X</code>? Usually that lifetime would be attached to something like <code>&amp;'a &amp;'static X</code>. Note that from <code>&amp;'a &amp;'static X</code> you can get <code>&amp;'static X</code> (by dereferencing) but not <code>&amp;'static &amp;'static X</code> (because the pointer to the static may not itself have static lifetime). Similarly, from <code>&amp;'a mut &amp;'static X</code> you can get <code>&amp;'static X</code> but not <code>&amp;'static mut &amp;'static X</code>.</p>",
        "id": 239011626,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621204591
    },
    {
        "content": "<p>In your example, if <code>&amp;self: &amp;'a Stdin</code>, then <code>&amp;self.inner: &amp;'a &amp;'static Mutex&lt;...&gt;</code> and <code>self.inner: &amp;'static Mutex&lt;...&gt;</code>. I don't think the modal logic analogy works here.</p>",
        "id": 239011730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621204714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239011626\">said</a>:</p>\n<blockquote>\n<p>What do you mean by <code>'a &amp;'static X</code>? Usually that lifetime would be attached to something like <code>&amp;'a &amp;'static X</code>. Note that from <code>&amp;'a &amp;'static X</code> you can get <code>&amp;'static X</code> (by dereferencing) but not <code>&amp;'static &amp;'static X</code> (because the pointer to the static may not itself have static lifetime). Similarly, from <code>&amp;'a mut &amp;'static X</code> you can get <code>&amp;'static X</code> but not <code>&amp;'static mut &amp;'static X</code>.</p>\n</blockquote>\n<p>Hm, yeah, upon further reflection in makes no sense to assign lifetimes to values, only to variables and references.<br>\nThen, I'm not sure, why with T: struct {inner: &amp;'static U }; self.inner resolves to &amp;'a U when &amp;self is &amp;'a T.</p>",
        "id": 239011753,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621204768
    },
    {
        "content": "<p>You can actually get both <code>&amp;'a U</code> and <code>&amp;'static U</code> from <code>&amp;'a &amp;'static U</code>: the first comes from reborrowing (i.e. <code>&amp;**x</code>) and the second comes from dereferencing (<code>*x</code>)</p>",
        "id": 239011840,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621204851
    },
    {
        "content": "<p>If you want to be really explicit about copying the reference out you could write <code>(*self).inner.clone()</code> but usually rust just does the right thing here</p>",
        "id": 239011928,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621204950
    },
    {
        "content": "<p>Oh. Since return type is parametrized by a lifetime, it inherits &amp;'a T lifetime - it's the function signature that limits the lifetime here. I'm dumb.<br>\nThen I guess the error is that borrowck doesn't extend temporary's lifetime till the end of main(), even though it totally could?</p>",
        "id": 239012080,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621205153
    },
    {
        "content": "<p>It does, under certain circumstances, this is called temporary promotion IIRC</p>",
        "id": 239012126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205178
    },
    {
        "content": "<p>But normally the temporary will be destroyed at the end of the statement and the lock would be useless</p>",
        "id": 239012155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205227
    },
    {
        "content": "<p>In fact, I think that's why the \"fake\" lifetime on <code>StdioLock</code> is there - it lets the borrow checker prevent this situation</p>",
        "id": 239012203,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205273
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/0066-better-temporary-lifetimes.html\">https://rust-lang.github.io/rfcs/0066-better-temporary-lifetimes.html</a> this seems to be the RFC that references a similar behaviour - TS, you could probably weigh in on that and link your issue to the tracking issue.</p>",
        "id": 239012293,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621205376
    },
    {
        "content": "<p>see also <a href=\"https://doc.rust-lang.org/reference/destructors.html#temporary-lifetime-extension\">https://doc.rust-lang.org/reference/destructors.html#temporary-lifetime-extension</a></p>",
        "id": 239012385,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205455
    },
    {
        "content": "<p>Yeah, but that's incredibly underspecified, \"sometimes it happens\". RFC is more precise.</p>",
        "id": 239012404,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621205490
    },
    {
        "content": "<p>it specifies further down on the page</p>",
        "id": 239012419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205521
    },
    {
        "content": "<p>in any case, <code>let x = (&amp;foo()).bar();</code> (usually written <code>let x = foo().bar();</code>) is explicitly mentioned as an example where the <code>foo()</code> temporary is <em>not</em> extended. Sometimes macros prefer to use <code>match (&amp;foo()).bar() { x =&gt; ... }</code> instead of <code>let</code> for this reason</p>",
        "id": 239012545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205651
    },
    {
        "content": "<p>Thanks, totally missed the counterexample.</p>",
        "id": 239012599,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621205726
    },
    {
        "content": "<p>Assuming <code>Stdin</code> is built on <code>Mutex</code> and <code>StdinLock</code> on <code>MutexGuard</code>, it isn't possible to use <code>StdinLock&lt;'static&gt;</code> because that corresponds to <code>MutexGuard&lt;'static, T&gt;</code> which is a neverending lock. The destructor wouldn't be able to close the lock</p>",
        "id": 239012658,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205768
    },
    {
        "content": "<p>the lifetime in question is the critical section itself, not the validity of some piece of memory per se</p>",
        "id": 239012700,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621205827
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239012700\">said</a>:</p>\n<blockquote>\n<p>the lifetime in question is the critical section itself, not the validity of some piece of memory per se</p>\n</blockquote>\n<p>I'm not sure that's true? <a href=\"https://doc.rust-lang.org/src/std/sync/mutex.rs.html#194-197\">https://doc.rust-lang.org/src/std/sync/mutex.rs.html#194-197</a> looks like <code>'a</code> applies to the <code>&amp;'a Mutex</code> and a bound on the contained type <code>T</code>?</p>",
        "id": 239013080,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621206173
    },
    {
        "content": "<p>sure, but even if it only stored a raw pointer it would still want the lifetime for API purposes</p>",
        "id": 239013303,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621206326
    },
    {
        "content": "<p>do you mean that because it's already  a part of the API, we can't remove the lifetime parameter from <code>StdinLock</code>?</p>",
        "id": 239013364,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621206367
    },
    {
        "content": "<p>Well, looking at the API now there is nothing that exposes <code>Stdin -&gt; &amp;'static Stdin</code> or similar, so there could be resources associated to the return value of <code>stdin()</code></p>",
        "id": 239013672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621206710
    },
    {
        "content": "<p><code>Stdin</code> isn't even <code>Copy</code> or <code>Clone</code></p>",
        "id": 239013739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621206758
    },
    {
        "content": "<p>Plus this is an API over an OS dependent thing, so my guess is that this is trying to be conservative over different implementation strategies for different OSs</p>",
        "id": 239013771,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621206829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"411291\">Taylor Yu</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239013364\">said</a>:</p>\n<blockquote>\n<p>do you mean that because it's already  a part of the API, we can't remove the lifetime parameter from <code>StdinLock</code>?</p>\n</blockquote>\n<p>The return value of lock() needs to be temporary because it needs to drop and release the lock.</p>\n<p>The 'a in MutexGuard applies to 'a Mutex, but it's actually a constraint: \"Mutex needs to live at least as long as this guard\". Mutex usually far outlives one of the guards.<br>\nSo the lifetime is needed because there's a nontrivial drop.</p>",
        "id": 239014691,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621207911
    },
    {
        "content": "<p><code>Mutex::&lt;T&gt;::lock(&amp;self)</code> returns <code>LockResult&lt;MutexGuard&lt;'_,T&gt;</code>, so it seems to me that any <code>MutexGuard</code> resulting from <code>Mutex::lock()</code> would have its <code>'a</code> lifetime equal to that of the elided lifetime of the <code>&amp;self</code> reference of the original <code>Mutex</code>. is that right? so for a static <code>Mutex&lt;T&gt;</code>, that would mean <code>MutexGuard&lt;'static,T&gt;</code></p>",
        "id": 239027371,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621221095
    },
    {
        "content": "<p>Yes, if you had a <code>&amp;'static Mutex&lt;T&gt;</code> you could derive a <code>MutexGuard&lt;'static, T&gt;</code>. However <code>Stdin</code> does not expose this implementation detail. If it wrapped a <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> instead, then it would not be possible to get a <code>&amp;'static Mutex&lt;T&gt;</code> without leaking memory, so the analogue of <code>StdinLock</code> would need that lifetime parameter.</p>",
        "id": 239029939,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621223880
    },
    {
        "content": "<p>(Earlier I said that <code>'a</code> in <code>MutexGuard&lt;'a, T&gt;</code> is the critical section, but that's not quite right. <code>'a</code> is an upper bound on the critical section (the actual critical section is the lifetime of the guard object itself), and a lower bound on the lifetime of the shared reference <code>&amp;'a Mutex&lt;T&gt;</code>  passed to <code>lock()</code>, and indirectly the lifetime of the mutex itself.)</p>",
        "id": 239030645,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621224338
    },
    {
        "content": "<p>ok, the compiler calls it a borrow even though it's really a lifetime constraint violation on the return type and no borrow of the inputs exists in the return type: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=84f6bb1b93633e45af71e8eab9fc44e9\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=84f6bb1b93633e45af71e8eab9fc44e9</a></p>",
        "id": 239118102,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621268197
    },
    {
        "content": "<p>There's an implicit borrow on A, <em>and</em> a constraint that ties that borrow's lifetime to the return type's lifetime.<br>\nWe could call it a constraint violation, or we could say that the constraint forces the implicit borrow to live for too long.</p>",
        "id": 239120260,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621269026
    },
    {
        "content": "<p>the borrow of <code>&amp;self</code> ends when the method returns, right? the only reason the compiler acts like the borrow lasts longer is the lifetime constraint on the return value</p>",
        "id": 239121364,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621269480
    },
    {
        "content": "<p>anyway, i find the error message misleading in these sorts of situations, and it could use improvement. (i went digging into <code>std::io</code> internals looking trying to figure out what borrow was actually taking place, when it was really a lifetime constraint problem)</p>",
        "id": 239122027,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621269729
    },
    {
        "content": "<p>As far as the compiler is concerned, you expressing a lifetime relationship via signature constraint <em>is</em> specifying a logical borrow - what you're saying is \"this borrow to self ought to live at least as long as the return type's parameter.\" In other circumstances, that borrow would've been successfully extended.</p>\n<p>It's tricky to modify this error message without accidentally breaking other cases when the only thing connecting self borrow lifetime to return type is a signature constraint (ie, when we're doing some unsafe stuff).</p>",
        "id": 239124105,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621270536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"411291\">Taylor Yu</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239121364\">said</a>:</p>\n<blockquote>\n<p>the borrow of <code>&amp;self</code> ends when the method returns, right? the only reason the compiler acts like the borrow lasts longer is the lifetime constraint on the return value</p>\n</blockquote>\n<p>No, in this case since the borrow is tied to the returned guard object the borrow doesn't end until the guard returned from the function is dropped.</p>",
        "id": 239163931,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621287288
    },
    {
        "content": "<p>that tie is the result of the <code>StdinLock&lt;'_&gt;</code> in the return type, isn't it? if it were some other type that didn't contain any refs, the <code>&amp;self</code> borrow would end when the method returns, right?</p>",
        "id": 239164420,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621287594
    },
    {
        "content": "<p>yes</p>",
        "id": 239164756,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621287795
    },
    {
        "content": "<p>and remember that it's not necessarily that the type \"contains refs\", for all I know the internal implementation uses raw pointers everywhere. The <code>&lt;'a&gt;</code> is there for API purposes</p>",
        "id": 239164891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621287865
    },
    {
        "content": "<p>the point is that the <code>StdinLock</code> object becomes invalid if the <code>Stdin</code> object it was derived from is moved, mutated, or goes out of scope</p>",
        "id": 239165002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621287941
    },
    {
        "content": "<p>or at least that's what the API says. Since in reality <code>Stdin</code> wraps a <code>&amp;'static Mutex&lt;T&gt;</code>, it isn't any real harm to allow those things because mutation isn't a possibility, moves can be copies and it's just a reference so there is no drop</p>",
        "id": 239165137,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288020
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239165002\">said</a>:</p>\n<blockquote>\n<p>the point is that the <code>StdinLock</code> object becomes invalid if the <code>Stdin</code> object it was derived from is moved, mutated, or goes out of scope</p>\n</blockquote>\n<p>i think in the current implementation, there's no reason for that to always be true. changing the signature to <code>lock() -&gt; StdinLock&lt;'static&gt;</code> might theoretically break some users, but i doubt it's significant in practice</p>",
        "id": 239165217,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621288081
    },
    {
        "content": "<p>I think you are assuming more stability of the current implementation strategy than actually exists</p>",
        "id": 239165343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288155
    },
    {
        "content": "<p>i think it's also important to avoid surprising behavior for new users, especially behavior that isn't officially documented anywhere</p>",
        "id": 239165492,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621288235
    },
    {
        "content": "<p>what if on some target we need <code>stdin()</code> to produce some data that is not shared by other calls to <code>stdin()</code> and which is accessible via the guard? In that case if lock returned <code>StdinLock&lt;'static&gt;</code> we would be stuck</p>",
        "id": 239165544,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288270
    },
    {
        "content": "<p>The current API is <em>conservative</em> against these possibilities</p>",
        "id": 239165593,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288315
    },
    {
        "content": "<p>If you want a <code>StdinLock&lt;'static&gt;</code> you can always leak the result of <code>stdin()</code></p>",
        "id": 239165688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239165544\">said</a>:</p>\n<blockquote>\n<p>what if on some target we need <code>stdin()</code> to produce some data that is not shared by other calls to <code>stdin()</code> and which is accessible via the guard? In that case if lock returned <code>StdinLock&lt;'static&gt;</code> we would be stuck</p>\n</blockquote>\n<p><code>Stdin</code> _is_ already documented to be a handle that references a shared global resource, so your hypothetical is contrary to official documentation</p>",
        "id": 239165695,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621288367
    },
    {
        "content": "<p>the handle itself might carry metadata about the call though</p>",
        "id": 239165727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288396
    },
    {
        "content": "<p>for example it might look like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Stdin</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">mutex</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"nc\">Mutex</span><span class=\"o\">&lt;</span><span class=\"n\">RawStdin</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">when_called</span>: <span class=\"nc\">Instant</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(assuming you turn on some kind of profiling feature in the standard library)</p>",
        "id": 239165905,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288503
    },
    {
        "content": "<p>this does not contradict \"a handle that references a shared global resource\"</p>",
        "id": 239166032,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288572
    },
    {
        "content": "<p>i think all these hypotheticals don't outweigh the benefit of producing behavior that's less surprising to new users</p>",
        "id": 239166197,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621288684
    },
    {
        "content": "<p>I think the presented API is quite standard for mutex-like things</p>",
        "id": 239166263,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288719
    },
    {
        "content": "<p>there are lots of \"guard objects\" that have exactly this design: <code>RefCell</code>, <code>Mutex</code>, <code>RwLock</code> all use the same pattern</p>",
        "id": 239166325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288775
    },
    {
        "content": "<p>Well, RFC for better temporary promotion would be the behaviour that's less surprising for new users.<br>\nThere's also an argument that current API does forbid \"forever lock\" (since there's no way to produce &amp;'static Stdin), which is kinda nice.</p>",
        "id": 239166396,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621288804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"412531\">Alex Mobius</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239166396\">said</a>:</p>\n<blockquote>\n<p>Well, RFC for better temporary promotion would be the behaviour that's less surprising for new users.<br>\nThere's also an argument that current API does forbid \"forever lock\" (since there's no way to produce &amp;'static Stdin), which is kinda nice.</p>\n</blockquote>\n<p>what do you mean by \"temporary promotion\"?</p>",
        "id": 239166486,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621288841
    },
    {
        "content": "<p>you can <code>mem::forget</code> a lock guard if you want to forever lock</p>",
        "id": 239166492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288845
    },
    {
        "content": "<p><a href=\"https://rust-lang.github.io/rfcs/0066-better-temporary-lifetimes.html\">https://rust-lang.github.io/rfcs/0066-better-temporary-lifetimes.html</a></p>",
        "id": 239166526,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621288862
    },
    {
        "content": "<p>that is a very old RFC that has already been implemented</p>",
        "id": 239166553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288889
    },
    {
        "content": "<p>so if that's the better option then you are already experiencing \"better\"</p>",
        "id": 239166644,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288932
    },
    {
        "content": "<p>I have no idea what it was like before</p>",
        "id": 239166663,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288941
    },
    {
        "content": "<p>The tracking  issue is open. It even references the stdout lock case in the tracking issue.</p>",
        "id": 239166679,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621288952
    },
    {
        "content": "<p>oh I see, the RFC was accepted but there was no implemetation</p>",
        "id": 239166782,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621288996
    },
    {
        "content": "<p>See also: <a href=\"https://github.com/rust-lang/rust/issues/70844\">https://github.com/rust-lang/rust/issues/70844</a></p>",
        "id": 239166798,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621289008
    },
    {
        "content": "<p>i guess another alternative is to make forwarding methods on <code>Stdin</code> for the few methods that consume a <code>StdinLock</code> to produce iterators, so users can call them directly on <code>Stdin</code> instead</p>",
        "id": 239166907,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621289057
    },
    {
        "content": "<p>Hm, the RFC apparently has a storied history. The accepted RFC is very vague about the implementation side of things, and niko wrote a more elaborated version here: <a href=\"https://github.com/nikomatsakis/rfcs/blob/rfc66-amendment/text/0066-better-temporary-lifetimes.md\">https://github.com/nikomatsakis/rfcs/blob/rfc66-amendment/text/0066-better-temporary-lifetimes.md</a></p>",
        "id": 239167598,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621289436
    },
    {
        "content": "<p>But I definitely agree with Alex that the issue here has more to do with temporary lifetime extension rules than <code>Stdin</code> itself</p>",
        "id": 239167652,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621289478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"411291\">Taylor Yu</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239166907\">said</a>:</p>\n<blockquote>\n<p>i guess another alternative is to make forwarding methods on <code>Stdin</code> for the few methods that consume a <code>StdinLock</code> to produce iterators, so users can call them directly on <code>Stdin</code> instead</p>\n</blockquote>\n<p>You can already do this, you don't need to create a lock to call <code>println!()</code>. The reason for <code>StdinLock</code> is if you want to share the same lock across multiple IO operations, in which case having methods on <code>Stdin</code> are defeating the purpose because they would take individual locks</p>",
        "id": 239167847,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621289612
    },
    {
        "content": "<p>i think there are two(?) <code>BufRead</code> methods that it makes sense for beginners to call on <code>StdinLock</code> that aren't available on <code>Stdin</code>: <code>lines()</code> and <code>split()</code>. so right now, users who want to call those methods have to use <code>StdinLock</code> and deal with lifetime complications on what would seem like a very simple operation</p>",
        "id": 239168616,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621290033
    },
    {
        "content": "<p>my particular use case was i wanted an iterator over lines of <code>Stdin</code>, so i very reasonably tried something like <code>let lines = io::stdin().lock().lines();</code>, based on what i read in the libstd documentation, and ran smack into a very non-obvious and confusing lifetime constraint problem</p>",
        "id": 239169049,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621290351
    },
    {
        "content": "<p>Have you looked at RFC 66? It's about exactly this</p>",
        "id": 239169159,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621290410
    },
    {
        "content": "<p>it's not great that it's been in implementation limbo for six years though</p>",
        "id": 239169205,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621290458
    },
    {
        "content": "<p>it's not a lifetime issue, really. The lifetime mismatch is just how rust notices that there is an issue, but what is wrong is the destructor placement and even if you turned off the borrow checker that would still be wrong</p>",
        "id": 239169337,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621290551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239169205\">said</a>:</p>\n<blockquote>\n<p>it's not great that it's been in implementation limbo for six years though</p>\n</blockquote>\n<p>exactly! i'm trying to suggest solutions that would hopefully help newcomers sooner than that RFC would likely get implemented</p>",
        "id": 239169368,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621290581
    },
    {
        "content": "<p>The problem is that \"when destructors run\" is a stable part of the rust language, so it's not easy to mess with the rules without breaking a lot of code</p>",
        "id": 239169572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621290668
    },
    {
        "content": "<p>there was a pass at this a few weeks ago here on zulip</p>",
        "id": 239169602,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621290689
    },
    {
        "content": "<p>it's a common complaint, but the reason the RFC stalled is because it's not proposing a solution so much as identifying a problem</p>",
        "id": 239169720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621290760
    },
    {
        "content": "<p>i mean i'm guessing even a <code>Stdin::into_lock(self)-&gt;StdinLock&lt;'static&gt;</code> might help, though the naming is somewhat less friendly to newcomers</p>",
        "id": 239170089,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621290973
    },
    {
        "content": "<p>The change you are proposing will not solve the problem at all, and in fact will make the eventual better solution not work for <code>Stdin</code>. The destructor will still run early, but you are letting the <code>StdinLock</code> object live on even though the parent <code>Stdin</code> object is gone. For a regular mutex that would be a memory error, but for <code>Stdin</code> that means exposing the fact that it's actually a global object. If we wanted to expose this then <code>Stdin</code> should just be a static variable</p>",
        "id": 239170100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621290978
    },
    {
        "content": "<p>but <code>Stdin</code> contains a ref to the mutex, not the mutex itself!</p>",
        "id": 239170145,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291014
    },
    {
        "content": "<p>If <code>io::stdin()</code> returned <code>&amp;'static Stdin</code> then there would be no problem</p>",
        "id": 239170214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291063
    },
    {
        "content": "<p>in which case <code>Stdin</code> could be either the mutex itself or a static reference to it as currently</p>",
        "id": 239170323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291103
    },
    {
        "content": "<p>the non-existence of a lifetime parameter on <code>Stdin</code> already implies that it contains no non-static references, right?</p>",
        "id": 239170455,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291203
    },
    {
        "content": "<p>Yes...</p>",
        "id": 239170501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291221
    },
    {
        "content": "<p>but since it is an object it has a lifetime that the user has to manage</p>",
        "id": 239170545,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291248
    },
    {
        "content": "<p>and it is that lifetime <code>'a</code> that ends up in <code>StdinLock&lt;'a&gt;</code></p>",
        "id": 239170570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291271
    },
    {
        "content": "<p>and that is the lifetime that is cut short when you don't use enough let bindings</p>",
        "id": 239170587,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239170570\">said</a>:</p>\n<blockquote>\n<p>and it is that lifetime <code>'a</code> that ends up in <code>StdinLock&lt;'a&gt;</code></p>\n</blockquote>\n<p>but that's an unnecessarily strict constraint on the lifetime of the return value given that <code>Stdin</code> contains only a static reference</p>",
        "id": 239170663,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291326
    },
    {
        "content": "<p>If <code>io::stdin() -&gt; &amp;'static Stdin</code> then the user is never actually given a <code>Stdin</code> object which needs to be destroyed, and calling <code>lock()</code> on it will produce <code>StdinLock&lt;'static&gt;</code> like you want</p>",
        "id": 239170727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291350
    },
    {
        "content": "<blockquote>\n<p>but that's an unnecessarily strict constraint on the lifetime of the return value given that Stdin contains only a static reference</p>\n</blockquote>\n<p>My argument so far has been that this unnecessarily strict constraint exists because the designers of the std API want the flexibility for the object returned from <code>stdin</code> to actually maintain some memory of its own. <code>io::stdin() -&gt; &amp;'static Stdin</code> is explicitly encoding that this is not the case, because the <code>Stdin</code> object here has to be global or otherwise leaked</p>",
        "id": 239170954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291510
    },
    {
        "content": "<p>if it weren't for the <code>StdinLock&lt;'_&gt;</code> lifetime, then there is no connection between the lifetimes of any <code>Stdin</code> object and any <code>StdinLock</code> resulting from <code>Stdin::lock()</code>. and there is no memory safety issue because <code>Stdin::lock()</code> only ever produces a lock based on a static mutex</p>",
        "id": 239170980,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291521
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239170954\">said</a>:</p>\n<blockquote>\n<p>My argument so far has been that this unnecessarily strict constraint exists because the designers of the std API want the flexibility for the object returned from <code>stdin</code> to actually maintain some memory of its own. <code>io::stdin() -&gt; &amp;'static Stdin</code> is explicitly encoding that this is not the case, because the <code>Stdin</code> object here has to be global or otherwise leaked</p>\n</blockquote>\n<p>where is this documented as the intent of the designers? or are you speculating?</p>",
        "id": 239171131,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291619
    },
    {
        "content": "<p>It is extrapolating from the shape of the API. Why else would an object that wraps a static reference not be copy or clone?</p>",
        "id": 239171187,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291669
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/What.20does.20StdinLock.20borrow.20from.20Stdin.3F/near/239171187\">said</a>:</p>\n<blockquote>\n<p>It is extrapolating from the shape of the API. Why else would an object that wraps a static reference not be copy or clone?</p>\n</blockquote>\n<p>maybe an accident of history, probably due to the shape of a prior implementation that has evolved</p>",
        "id": 239171292,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291719
    },
    {
        "content": "<p>that's a pretty unusual choice for a rust API, so I find it unlikely to be an accident</p>",
        "id": 239171293,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291722
    },
    {
        "content": "<blockquote>\n<p>probably due to the shape of a prior implementation that has evolved</p>\n</blockquote>\n<p>Yes, evolution constraints are a thing, <em>especially</em> for std</p>",
        "id": 239171323,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291744
    },
    {
        "content": "<p>better to not promise too much</p>",
        "id": 239171343,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291763
    },
    {
        "content": "<p>see <a href=\"https://github.com/rust-lang/rust/pull/77154\">https://github.com/rust-lang/rust/pull/77154</a></p>",
        "id": 239171362,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291781
    },
    {
        "content": "<p>like that <code>Stdin</code> and <code>StdinLock</code> do not have related lifetimes, or <code>Stdin</code> is actually a global object</p>",
        "id": 239171368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291788
    },
    {
        "content": "<p>See, that's exactly the kind of implementation change that would not be possible with a wide API of the kind you want</p>",
        "id": 239171521,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621291878
    },
    {
        "content": "<p>my interpretation is that a prior implementation <em>did</em> use <code>Arc</code>, so the distinct <code>Stdin</code> object was required, but that approach was abandoned, and now we have this partially-static implementation by accident (or because the <code>Arc</code>-based implementation boxed them in API-wise)</p>",
        "id": 239171642,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621291975
    },
    {
        "content": "<p>I agree. Imagine if we had to go in the other direction though, or suppose that that refactor didn't work on some target. With today's API that would be no problem, nothing to bother users about, while if we had this <code>'static</code> stuff in the public API then it would be a problem</p>",
        "id": 239171975,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621292147
    },
    {
        "content": "<p>That's what API stability is all about</p>",
        "id": 239172068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621292181
    },
    {
        "content": "<p>The reason I linked the RFC wasn't \"yeah they're working on it\", btw, but rather \"this problem has a history, maybe we can meaningfully contribute to its solution instead of trying to rephrase an error message here\"</p>",
        "id": 239172164,
        "sender_full_name": "Alex Mobius",
        "timestamp": 1621292240
    },
    {
        "content": "<p>i still think that the E0716 text could be better. or maybe add more details to its extended error explanation about how the lifetimes of return values can effectively extend a borrow of the inputs</p>",
        "id": 239173345,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621292973
    },
    {
        "content": "<p>do borrow checking or lifetime validation cross function call boundaries? i seem to recall that type inference does not</p>",
        "id": 239278390,
        "sender_full_name": "Taylor Yu [they/she]",
        "timestamp": 1621353436
    },
    {
        "content": "<p>they don't</p>",
        "id": 239296509,
        "sender_full_name": "The 8472",
        "timestamp": 1621360174
    },
    {
        "content": "<p>borrow checking across function calls is mediated by lifetime annotations on function signatures</p>",
        "id": 239303201,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1621362709
    },
    {
        "content": "<p>i once had cause to make a combination struct that put the Stdin and StdinLock in the same thing by just transmuting the lock to be 'static and keeping both in ManuallyDrop and then undoing it all very carefully.</p>",
        "id": 239331473,
        "sender_full_name": "Lokathor",
        "timestamp": 1621374664
    }
]