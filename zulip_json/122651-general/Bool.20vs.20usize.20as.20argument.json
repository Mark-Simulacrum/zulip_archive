[
    {
        "content": "<p>Using bool argument instead of usize seems to result in a redundant copy/conditional move.</p>\n<p><a href=\"https://rust.godbolt.org/z/eTEo3Y18v\">https://rust.godbolt.org/z/eTEo3Y18v</a></p>\n<p>(Failure to optimize <code>n + b as usize * 7</code> into <code>n + b as usize * 8 - b as usize</code> appears to be on LLVM side)</p>",
        "id": 267455751,
        "sender_full_name": "Bot+",
        "timestamp": 1641829685
    },
    {
        "content": "<p>That's because the call ABI specifies that the upper 32 bits are undefined. The initial move is not a no-op, it zero-extends the value to clear the upper 32 bits.</p>",
        "id": 267461575,
        "sender_full_name": "Amanieu",
        "timestamp": 1641831836
    },
    {
        "content": "<p>If you replace <code>usize</code> with <code>u32</code> then the extra <code>mov</code> disappears.</p>",
        "id": 267461641,
        "sender_full_name": "Amanieu",
        "timestamp": 1641831852
    },
    {
        "content": "<blockquote>\n<p>the call ABI specifies that the upper 32 bits are undefined.</p>\n</blockquote>\n<p>Thanks, this is news to me.</p>\n<p>I already have <code>u64 as bool</code> so switching to <code>u64 as usize</code> with <code>debug_assert!(condition == 0 || condition == 1);</code> works well enough (and avoids comparison on non-x86 <a href=\"https://rust.godbolt.org/z/h31c11c1T\">https://rust.godbolt.org/z/h31c11c1T</a>)</p>",
        "id": 267467198,
        "sender_full_name": "Bot+",
        "timestamp": 1641833915
    }
]