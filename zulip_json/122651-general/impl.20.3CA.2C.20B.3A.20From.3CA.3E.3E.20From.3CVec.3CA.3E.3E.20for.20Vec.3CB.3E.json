[
    {
        "content": "<p>It will be useful to have impl &lt;A, B: From&lt;A&gt;&gt; From&lt;Vec&lt;A&gt;&gt; for Vec&lt;B&gt; in std<br>\nWDYT?</p>",
        "id": 257231019,
        "sender_full_name": "Beknar",
        "timestamp": 1634055911
    },
    {
        "content": "<p>I think it would violate coherence because there is already <code>From&lt;Vec&lt;T&gt;&gt; for Vec&lt;T&gt;</code></p>",
        "id": 257231703,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1634056167
    },
    {
        "content": "<p>yes, this comes up often that such proposals run afoul of coherence in the <code>A=B</code> identity case</p>",
        "id": 257234844,
        "sender_full_name": "cuviper",
        "timestamp": 1634057392
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"306504\">Tavian Barnes</span> <a href=\"#narrow/stream/122651-general/topic/impl.20.3CA.2C.20B.3A.20From.3CA.3E.3E.20From.3CVec.3CA.3E.3E.20for.20Vec.3CB.3E/near/257231703\">said</a>:</p>\n<blockquote>\n<p>I think it would violate coherence because there is already <code>From&lt;Vec&lt;T&gt;&gt; for Vec&lt;T&gt;</code></p>\n</blockquote>\n<p>Dont see that in docs</p>",
        "id": 257234956,
        "sender_full_name": "Beknar",
        "timestamp": 1634057424
    },
    {
        "content": "<p>it's <code>impl&lt;T&gt; From&lt;T&gt; for T</code>, where it could be <code>T = Vec&lt;U&gt;</code></p>",
        "id": 257235059,
        "sender_full_name": "cuviper",
        "timestamp": 1634057472
    },
    {
        "content": "<p>so any other <code>impl From</code> must avoid that identity case</p>",
        "id": 257235285,
        "sender_full_name": "cuviper",
        "timestamp": 1634057549
    },
    {
        "content": "<p>doesn't <code>vec.into_iter().map(From::from).collect()</code> do the job?</p>",
        "id": 257236127,
        "sender_full_name": "The 8472",
        "timestamp": 1634057881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/impl.20.3CA.2C.20B.3A.20From.3CA.3E.3E.20From.3CVec.3CA.3E.3E.20for.20Vec.3CB.3E/near/257236127\">said</a>:</p>\n<blockquote>\n<p>doesn't <code>vec.into_iter().map(From::from).collect()</code> do the job?</p>\n</blockquote>\n<p>It does, but could be shorter and be optimised with_capacity</p>\n<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/122651-general/topic/impl.20.3CA.2C.20B.3A.20From.3CA.3E.3E.20From.3CVec.3CA.3E.3E.20for.20Vec.3CB.3E/near/257235059\">said</a>:</p>\n<blockquote>\n<p>it's <code>impl&lt;T&gt; From&lt;T&gt; for T</code>, where it could be <code>T = Vec&lt;U&gt;</code></p>\n</blockquote>\n<p>Thanks. No I get it</p>",
        "id": 257241459,
        "sender_full_name": "Beknar",
        "timestamp": 1634059942
    },
    {
        "content": "<blockquote>\n<p>be optimised with_capacity </p>\n</blockquote>\n<p>It already does that.</p>",
        "id": 257242608,
        "sender_full_name": "The 8472",
        "timestamp": 1634060402
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/impl.20.3CA.2C.20B.3A.20From.3CA.3E.3E.20From.3CVec.3CA.3E.3E.20for.20Vec.3CB.3E/near/257242608\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>be optimised with_capacity </p>\n</blockquote>\n<p>It already does that.</p>\n</blockquote>\n<p>I see it returns iterator that implements ExactSizeIterator in into_iterator. but FromIterator collect delegates to <a href=\"https://stdrs.dev/nightly/x86_64-unknown-linux-gnu/src/alloc/vec/spec_from_iter.rs.html#58\">https://stdrs.dev/nightly/x86_64-unknown-linux-gnu/src/alloc/vec/spec_from_iter.rs.html#58</a>.<br>\nWhere I am not sure if size optimisation is applied</p>",
        "id": 257244852,
        "sender_full_name": "Beknar",
        "timestamp": 1634061305
    },
    {
        "content": "<p>all specialized implementations in that graph either use the lower bound size hint or don't need to allocate at all since they reuse the input allocation</p>",
        "id": 257245776,
        "sender_full_name": "The 8472",
        "timestamp": 1634061641
    },
    {
        "content": "<p>If the layout matches then the input allocation is used (SpecInPlaceCollect), otherwise it'll use the upper bound size hint, since the iterator is TrustedLen.</p>",
        "id": 257253179,
        "sender_full_name": "Gary Guo",
        "timestamp": 1634064686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/impl.20.3CA.2C.20B.3A.20From.3CA.3E.3E.20From.3CVec.3CA.3E.3E.20for.20Vec.3CB.3E/near/257245776\">said</a>:</p>\n<blockquote>\n<p>all specialized implementations in that graph either use the lower bound size hint or don't need to allocate at all since they reuse the input allocation</p>\n</blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/122651-general/topic/impl.20.3CA.2C.20B.3A.20From.3CA.3E.3E.20From.3CVec.3CA.3E.3E.20for.20Vec.3CB.3E/near/257253179\">said</a>:</p>\n<blockquote>\n<p>If the layout matches then the input allocation is used (SpecInPlaceCollect), otherwise it'll use the upper bound size hint, since the iterator is TrustedLen.</p>\n</blockquote>\n<p>Thanks. makes sense. I will read up on it</p>",
        "id": 257343100,
        "sender_full_name": "Beknar",
        "timestamp": 1634121010
    }
]