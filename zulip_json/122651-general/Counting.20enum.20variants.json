[
    {
        "content": "<p>I have an enum with 10 variants, and I want to count how many occurrences of each variant are passed to a function. I can create a <code>Vec&lt;usize&gt;</code> with 10 elements using <code>std::mem::variant_count</code>. If the enum variants don't have any arguments then I can coerce each one to an integer using <code>as</code>. But if one or more of the enum variants have arguments I don't think there's an automatic way to convert the discriminant to the appropriate integer, right? <code>std::mem::Discriminant</code> doesn't have any kind of to-integer conversion.</p>\n<p>I guess I can just write my own function for it...</p>",
        "id": 269223892,
        "sender_full_name": "nnethercote",
        "timestamp": 1643099842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> <code>std::intrinsics::discriminant_value</code> should help</p>",
        "id": 269227774,
        "sender_full_name": "lqd",
        "timestamp": 1643101931
    },
    {
        "content": "<p>How do you convert that to an integer?</p>",
        "id": 269229711,
        "sender_full_name": "nnethercote",
        "timestamp": 1643102966
    },
    {
        "content": "<p>Oh, I see. It's not clear from the docs, but <code>&lt;T as DiscriminantKind&gt;::Discriminant</code> appears in practice to be... an <code>isize</code> O_o</p>",
        "id": 269230526,
        "sender_full_name": "nnethercote",
        "timestamp": 1643103384
    },
    {
        "content": "<p>I wouldn't have predicted that, I would have guessed <code>usize</code></p>",
        "id": 269230535,
        "sender_full_name": "nnethercote",
        "timestamp": 1643103390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/122651-general/topic/Counting.20enum.20variants/near/269230526\">said</a>:</p>\n<blockquote>\n<p>Oh, I see. It's not clear from the docs, but <code>&lt;T as DiscriminantKind&gt;::Discriminant</code> appears in practice to be... an <code>isize</code> O_o</p>\n</blockquote>\n<p>I've gotten ICEs making by making this assumption, I don't think it's always true. I think maybe its <code>#[repr(DifferentType)]</code> that is the cause of issues? Not sure though</p>",
        "id": 269233005,
        "sender_full_name": "Jake",
        "timestamp": 1643104669
    },
    {
        "content": "<p>The type exists to hide the actual type, this is very intentional.</p>",
        "id": 269237133,
        "sender_full_name": "The 8472",
        "timestamp": 1643106717
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> doesn't a <code>Vec&lt;Discriminant&lt;YourEnum&gt;&gt;</code> work for you? If you <em>really</em> need an integer, you could use its <code>Hash</code> impl</p>",
        "id": 269251929,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643115204
    },
    {
        "content": "<p>I want a <code>Vec&lt;usize&gt;</code> with a length that matches the variant count, and index into it based on the integer value of the discriminant</p>",
        "id": 269254850,
        "sender_full_name": "nnethercote",
        "timestamp": 1643116675
    },
    {
        "content": "<p>And I could use <code>Hash</code> and a hash table, that's just suboptimal when there is an obvious mapping for each variant to 0..n</p>",
        "id": 269254977,
        "sender_full_name": "nnethercote",
        "timestamp": 1643116730
    },
    {
        "content": "<p>You could use <code>#[repr(u8)]</code> and then <code>unsafe { *(self as *const Self as *const u8) }</code> as suggested by <a href=\"https://rust-lang.github.io/rfcs/2363-arbitrary-enum-discriminant.html\">rfc 2363</a>.</p>",
        "id": 269257745,
        "sender_full_name": "bjorn3",
        "timestamp": 1643118141
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120989\">nnethercote</span> <a href=\"#narrow/stream/122651-general/topic/Counting.20enum.20variants/near/269254977\">said</a>:</p>\n<blockquote>\n<p>And I could use <code>Hash</code> and a hash table, that's just suboptimal when there is an obvious mapping for each variant to 0..n</p>\n</blockquote>\n<p>Well, the point seems to be that that mapping is currently unstable, hence the opaque layer. If you feel confident about extracting a <code>u64</code>, potentially lossily, I'd suggest still taking advantage of <code>Hash</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">to_u64</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">d</span>: ::<span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">Discriminant</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"kt\">u64</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Hasher</span><span class=\"p\">(</span><span class=\"kt\">u64</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">hash</span>::<span class=\"n\">Hasher</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Hasher</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">write_u64</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">n</span>: <span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">n</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">write</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">write_u64</span><span class=\"p\">(</span><span class=\"kt\">u64</span>::<span class=\"n\">from_ne_bytes</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">d</span><span class=\"p\">.</span><span class=\"n\">try_into</span><span class=\"p\">().</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">finish</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">          </span>-&gt; <span class=\"kt\">u64</span>\n        <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"fm\">unimplemented!</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Hasher</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span>::<span class=\"n\">core</span>::<span class=\"n\">hash</span>::<span class=\"n\">Hash</span>::<span class=\"n\">hash</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">d</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">h</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">h</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>It's a way less \"stable\" approach than, for instance, using a well-defined repr to read the discriminant (since the point of a well-defined repr is to opt-out of future improvements to discriminants), but if you can't use the <code>repr()</code> approach, then this is the only way to extract the integer that I know of.</p>\n<p>FWIW, </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">E</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"kt\">u16</span> <span class=\"p\">}}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">aaa</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">e</span>: <span class=\"nc\">E</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"kt\">u64</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">to_u64</span><span class=\"p\">(</span>::<span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">discriminant</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">e</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>currently compiles down to:</p>\n<div class=\"codehilite\" data-code-language=\"ActionScript\"><pre><span></span><code><span class=\"nx\">aaa</span><span class=\"o\">:</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">movzx</span><span class=\"w\">   </span><span class=\"nx\">eax</span><span class=\"o\">,</span><span class=\"w\"> </span><span class=\"nx\">di</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nx\">ret</span><span class=\"w\"></span>\n</code></pre></div>\n<p>on release.</p>",
        "id": 269296569,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643133443
    }
]