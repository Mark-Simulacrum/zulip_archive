[
    {
        "content": "<p>hi, may i suggest an input! macro, if not inputln! and input! ?</p>",
        "id": 265481726,
        "sender_full_name": "Abhishek",
        "timestamp": 1639922762
    },
    {
        "content": "<p>As a wrapper for <code>std::io::stdin().read_line()</code> ?</p>",
        "id": 265481819,
        "sender_full_name": "Patrick Poitras",
        "timestamp": 1639922861
    },
    {
        "content": "<p>yes basically</p>",
        "id": 265481872,
        "sender_full_name": "Abhishek",
        "timestamp": 1639922904
    },
    {
        "content": "<p>like in python,  you can do input().split() right to find tokens? and then parse them however you'd like</p>",
        "id": 265481886,
        "sender_full_name": "Abhishek",
        "timestamp": 1639922945
    },
    {
        "content": "<p>i mean ideally id want it to be like java, where, we could take input tokens or the whole line?</p>",
        "id": 265481894,
        "sender_full_name": "Abhishek",
        "timestamp": 1639922970
    },
    {
        "content": "<p>There is quite a lot of work currently on stdio and related functions, see <a href=\"https://github.com/rust-lang/rust/issues/15023\">#15023</a>. It was last discussed in early November by the language team. There is also a proposal for functions that you can call to create iterators on <code>stdin</code> at <a href=\"https://github.com/rust-lang/rust/issues/87096\">#87096</a>. This one has already some implementation of those functions, so you can use them as long as you use the nightly build.<br>\n<a href=\"https://doc.rust-lang.org/std/io/struct.Stdin.html#method.lines\">https://doc.rust-lang.org/std/io/struct.Stdin.html#method.lines</a></p>",
        "id": 265482291,
        "sender_full_name": "Patrick Poitras",
        "timestamp": 1639923598
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(stdin_forwarders)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">io</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">lines</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">io</span>::<span class=\"n\">stdin</span><span class=\"p\">().</span><span class=\"n\">lines</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">lines</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"got a line: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">line</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(stdin_forwarders)]</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">io</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">splits</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">io</span>::<span class=\"n\">stdin</span><span class=\"p\">().</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"sc\">b'-'</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">split</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">splits</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"got a chunk: {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from_utf8_lossy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">split</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">()));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>are two examples.</p>",
        "id": 265482343,
        "sender_full_name": "Patrick Poitras",
        "timestamp": 1639923633
    },
    {
        "content": "<p>for the first code when would the console stop taking input? I mean wouldn't that go on infinitely even if we press enter?<br>\nim not talking about anything complicated, just an inputln! and inputint! and inputf! and inputdouble! and inputstr! im saying actually</p>",
        "id": 265483642,
        "sender_full_name": "Abhishek",
        "timestamp": 1639925480
    },
    {
        "content": "<p>It would accept input until it reaches end of file. This would be for piping in a file from console, for example. You can also write your own check of the value and break if you reach the end. If you're looking for only a line to be parsed then the solution is likely <code>read_line</code>rather than the two above</p>",
        "id": 265484409,
        "sender_full_name": "Patrick Poitras",
        "timestamp": 1639926455
    },
    {
        "content": "<p>oh i thought there was already a way to read files using std::fs::prelude::* and std::fs::File?</p>",
        "id": 265486646,
        "sender_full_name": "Abhishek",
        "timestamp": 1639929705
    },
    {
        "content": "<p>If you're looking for a solution today, check out the crate ezio</p>",
        "id": 268336145,
        "sender_full_name": "Evan Richter",
        "timestamp": 1642473291
    }
]