[
    {
        "content": "<p>Given the following code:</p>\n<div class=\"codehilite\"><pre><span></span><code>pub trait DynConstErr {\n    fn get_const_err(self) -&gt; ConstEvalErr;\n\n    fn get_handled_err(self) -&gt; ErrorHandled;\n}\n\npub struct ErrorHandled;\nimpl DynConstErr for ErrorHandled {\n    fn get_const_err(self) -&gt; ConstEvalErr {\n        panic!()\n    }\n\n    fn get_handled_err(self) -&gt; ErrorHandled {\n        self\n    }\n}\n\npub struct ConstEvalErr;\nimpl DynConstErr for ConstEvalErr {\n    fn get_const_err(self) -&gt; ConstEvalErr {\n        self\n    }\n\n    fn get_handled_err(self) -&gt; ErrorHandled {\n        panic!()\n    }\n}\n\npub enum Reveal {\n    Selection,\n    UserFacing,\n}\n\nenum ConstDedupError&lt;E: DynConstErr&gt; {\n    Silent(E),\n    Handled(ErrorReported),\n}\n\nimpl&lt;E: DynConstErr&gt; ConstDedupError&lt;E&gt; {\n    fn new(e: E, reveal: Reveal) -&gt; Self {\n        match reveal {\n            Reveal::Selection =&gt; ConstDedupError::Silent(e),\n            Reveal::UserFacing =&gt; ConstDedupError::Handled(e.get_handled_err()),\n        }\n    }\n}\n\npub enum ConstDedupResult&lt;T, E: DynConstErr&gt; {\n    Selection&lt;Result&lt;T, E&gt;&gt;,\n    UserFacing&lt;Result&lt;T, ErrorReported&gt;&gt;,\n}\n\nimpl&lt;T, E: DynConstErr&gt; ConstDedupResult&lt;T, E&gt; {\n    pub fn new(val: Result&lt;T, E&gt;, reveal: Reveal) -&gt; Self {\n        match reveal {\n            Reveal::Selection =&gt; {\n                val.map_err(|e| ConstDedupError::new(e, reveal))\n            }\n            Reveal::UserFacing =&gt; {\n                val.map_err(|e| ConstDedupError::new(e, reveal))\n            }\n        }\n    }\n}\n\nfn use_result&lt;T, E: DynConstErr&gt;(val: ConstDedupResult&lt;T, E&gt;) {\n    match val {\n        ConstDedupResult::Selection(Ok(val)) =&gt; ...\n        ConstDedupResult::Selection(Err(e)) =&gt; {\n            // need to distinguish between type of e here\n        }\n        ....\n    }\n}\n</code></pre></div>\n<p>How can I prevent exposing <code>ConstDedupError</code> while still having a generic <code>new</code> method on <code>ConstDedupResult</code>? I feel that this is poorly designed, can anybody make some suggestions? </p>\n<p>I could write a non-generic version by creating another enum, say <code>SilentError</code> that allows me to distinguish between <code>ConstEvalErr</code> and <code>ErrorHandled</code> in <code>ConstDedupError::Silent</code>, but that would require having to expose both <code>ConstDedupError</code> and <code>SilentError</code> when creating <code>ConstDedupResult</code>. How can I design a generic <code>ConstDedupResult::new</code> function that still allows me to distinguish between the error types later? Is <code>TypeId</code> the only option here and if so, is it acceptable to use this inside the compiler (there isn't a single use of it currently)?</p>",
        "id": 265708803,
        "sender_full_name": "BN",
        "timestamp": 1640105931
    },
    {
        "content": "<p>Why do you want to avoid exposing <code>ConstDedupError</code>?</p>",
        "id": 265710886,
        "sender_full_name": "bjorn3",
        "timestamp": 1640106990
    },
    {
        "content": "<p>Just convenience I guess. I'd like to avoid having to always repeat writing something like <code>ConstDedupResult::new(Err(ConstDedupError::Silent(SilentError::ConstErr(e))))</code> e.g., which isn't really that bad, but I was just wondering whether there was a more elegant approach.</p>",
        "id": 265712076,
        "sender_full_name": "BN",
        "timestamp": 1640107645
    },
    {
        "content": "<p>Why are there two <code>Ok</code> variants in <code>ConstDedupResult</code>? Does <code>ConstDedupResult::Selection(Ok(val))</code> mean the same thing as <code>ConstDedupResult::UserFacing(Ok(val))</code>?</p>",
        "id": 265713081,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640108153
    },
    {
        "content": "<p>because if so it would be highly preferable to just use <code>Result</code> at the top level and have an enum only for the error case</p>",
        "id": 265713252,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640108232
    },
    {
        "content": "<p>The <code>Ok</code> variants are equivalent, but the errors aren't. I'm trying to store query results in order to deduplicate calls, which is why I wrap them in <code>ConstDedupResult</code>. How would having a separate error enum simplify things here (this would just be <code>ConstDedupError</code> afaict)?</p>",
        "id": 265714211,
        "sender_full_name": "BN",
        "timestamp": 1640108765
    },
    {
        "content": "<p>It would at least eliminate the <code>ConstDedupResult::new</code> in your example. With some <code>From</code> impls you could get it down to just <code>Err(e)?</code></p>",
        "id": 265743228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1640126466
    }
]