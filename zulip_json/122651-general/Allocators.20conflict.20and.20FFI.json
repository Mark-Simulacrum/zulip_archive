[
    {
        "content": "<p>Hi,</p>\n<p>I have trouble understanding how things work when doing FFI calls to some <code>extern \"C\"</code> function that may allocate memory: Rust and C will each have their allocator, likely different. On modern Linux systems, these allocators obtain memory through <code>mmap</code> and hence are each working with different chunks of the heap and won't conflict. But is this a guarantee on every platform?</p>\n<p>If we imagine something similar to <code>sbrk</code>, then both allocators would be giving-out part from the same segment of the heap, and memory may very well end up being corrupted. How strong are our guarantee against this?</p>",
        "id": 213472250,
        "sender_full_name": "krtab",
        "timestamp": 1602788399
    },
    {
        "content": "<p>I believe rust uses the system allocator by default</p>",
        "id": 213473466,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1602788919
    },
    {
        "content": "<p>so as someone building a crate (executable/shared lib), you should only have an issue if some crate in the depndency graph overrides the global allocator</p>",
        "id": 213473559,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1602788990
    },
    {
        "content": "<p>and if that custom allocator is somehow incompatible with the allocator used by C code</p>",
        "id": 213473607,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1602789004
    },
    {
        "content": "<blockquote>\n<p>Binaries generated by the compiler will use alloc_jemalloc by default (where available). In this situation the compiler \"controls the world\" in the sense of it has power over the final link. Primarily this means that the allocator decision can be left up the compiler.</p>\n</blockquote>\n<p>From <a href=\"https://doc.rust-lang.org/1.9.0/book/custom-allocators.html\">https://doc.rust-lang.org/1.9.0/book/custom-allocators.html</a> </p>\n<p>So I guess there can be a problem if I'm doing a binary right ? Or is the allocator set on a per-crate basis (in which case the problem for before is even bigger).</p>",
        "id": 213473911,
        "sender_full_name": "krtab",
        "timestamp": 1602789136
    },
    {
        "content": "<p>This is the 1.9.0 documentation, this has been changed since</p>",
        "id": 213474629,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1602789484
    },
    {
        "content": "<p>You're right it is the wrong version, but I can't find any resource on how it is done now.<br>\nAnyway, I think my original question is a bit orthogonal because the C library itself may have a custom allocator for example, or might be C-ABI bindings exposed by some other language for example.</p>",
        "id": 213475217,
        "sender_full_name": "krtab",
        "timestamp": 1602789780
    },
    {
        "content": "<p>That sounds to me like the job of the OS, to make sure it doesn't hand 2 entities the same chunk of memory</p>",
        "id": 213475423,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1602789877
    },
    {
        "content": "<p>System allocator is default on all platforms currently, see <a href=\"https://doc.rust-lang.org/nightly/std/alloc/trait.GlobalAlloc.html\">https://doc.rust-lang.org/nightly/std/alloc/trait.GlobalAlloc.html</a> for docs on how to change that.</p>",
        "id": 213475510,
        "sender_full_name": "simulacrum",
        "timestamp": 1602789918
    },
    {
        "content": "<p>oh I see your point about <code>sbrk</code> hmmm interesting</p>",
        "id": 213475549,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1602789935
    },
    {
        "content": "<p><a href=\"https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html#jemalloc-is-removed-by-default\">https://blog.rust-lang.org/2019/01/17/Rust-1.32.0.html#jemalloc-is-removed-by-default</a></p>",
        "id": 213475562,
        "sender_full_name": "simulacrum",
        "timestamp": 1602789945
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> I still think this question is quite interesting regardless of that fact.<br>\nit's also interesting in C only or Rust only, can something bad happen when combining multiple allocators</p>",
        "id": 213475741,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1602790024
    },
    {
        "content": "<p>I am confused -- what question?</p>",
        "id": 213475799,
        "sender_full_name": "simulacrum",
        "timestamp": 1602790052
    },
    {
        "content": "<p>Calling malloc with one allocator and free with the other (or vice versa etc) is UB.</p>",
        "id": 213475921,
        "sender_full_name": "simulacrum",
        "timestamp": 1602790099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/122651-general/topic/Allocators.20conflict.20and.20FFI/near/213475921\">said</a>:</p>\n<blockquote>\n<p>Calling malloc with one allocator and free with the other (or vice versa etc) is UB.</p>\n</blockquote>\n<p>But that's not what is mentioned here: I'm asking about case where simply allocating memory could be unsound.</p>",
        "id": 213476072,
        "sender_full_name": "krtab",
        "timestamp": 1602790165
    },
    {
        "content": "<blockquote>\n<p>If we imagine something similar to sbrk, then both allocators would be giving-out part from the same segment of the heap, and memory may very well end up being corrupted. How strong are our guarantee against this?</p>\n</blockquote>\n<p>I'm not sure how this matters -- each allocator should only be looking at memory it specifically allocated</p>",
        "id": 213476247,
        "sender_full_name": "simulacrum",
        "timestamp": 1602790237
    },
    {
        "content": "<p>(And I also think the question is generally interesting as a programming language design problem: many languages do not use malloc at all and ship their custom allocator, I wonder how they deal with that at their FFI bounday for example.)</p>",
        "id": 213476331,
        "sender_full_name": "krtab",
        "timestamp": 1602790284
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/122651-general/topic/Allocators.20conflict.20and.20FFI/near/213476247\">said</a>:</p>\n<blockquote>\n<p>I'm not sure how this matters -- each allocator should only be looking at memory it specifically allocated</p>\n</blockquote>\n<p>How do they \"know\" what memory is theirs if all they have is a beginning and end for the heap?</p>",
        "id": 213476446,
        "sender_full_name": "krtab",
        "timestamp": 1602790331
    },
    {
        "content": "<p>Specific allocators may require that they are the only ones around, but I suspect that predominantly they do not assume that they only have a beginning and end.</p>",
        "id": 213476571,
        "sender_full_name": "simulacrum",
        "timestamp": 1602790404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/122651-general/topic/Allocators.20conflict.20and.20FFI/near/213476571\">said</a>:</p>\n<blockquote>\n<p>Specific allocators may require that they are the only ones around, but I suspect that predominantly they do not assume that they only have a beginning and end.</p>\n</blockquote>\n<p>I would hope so! But I am curious about the actual guarantees we have. :)</p>",
        "id": 213476710,
        "sender_full_name": "krtab",
        "timestamp": 1602790465
    },
    {
        "content": "<p>From what allocator?</p>",
        "id": 213479096,
        "sender_full_name": "simulacrum",
        "timestamp": 1602791671
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/122651-general/topic/Allocators.20conflict.20and.20FFI/near/213479096\">said</a>:</p>\n<blockquote>\n<p>From what allocator?</p>\n</blockquote>\n<p>I don't understand your question.</p>",
        "id": 213483753,
        "sender_full_name": "krtab",
        "timestamp": 1602794092
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"354910\">krtab</span> <a href=\"#narrow/stream/122651-general/topic/Allocators.20conflict.20and.20FFI/near/213476446\">said</a>:</p>\n<blockquote>\n<p>How do they \"know\" what memory is theirs if all they have is a beginning and end for the heap?</p>\n</blockquote>\n<p>In something like Linux or Windows, virtual memory means that allocators <em>must</em> get their memory from the OS.  None of them work by just \"knowing\" where the heap is.</p>\n<p>Now, if you're in Ring0 things might be different, but so will so many other things that this is the least of your problems :P</p>",
        "id": 213498141,
        "sender_full_name": "scottmcm",
        "timestamp": 1602802599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/122651-general/topic/Allocators.20conflict.20and.20FFI/near/213498141\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"354910\">krtab</span> <a href=\"#narrow/stream/122651-general/topic/Allocators.20conflict.20and.20FFI/near/213476446\">said</a>:</p>\n<blockquote>\n<p>How do they \"know\" what memory is theirs if all they have is a beginning and end for the heap?</p>\n</blockquote>\n<p>In something like Linux or Windows, virtual memory means that allocators <em>must</em> get their memory from the OS.  None of them work by just \"knowing\" where the heap is.</p>\n<p>Now, if you're in Ring0 things might be different, but so will so many other things that this is the least of your problems :P</p>\n</blockquote>\n<p>Could you elaborate on that? Especially even in recent linux <code>sbrk</code> is still available so I'm not sure I understand the dichotomy between \"virtual memory\" and \"just knowing where the heap is\".</p>",
        "id": 213525676,
        "sender_full_name": "krtab",
        "timestamp": 1602832741
    },
    {
        "content": "<p><code>sbrk</code> based allocators should still not conflict with each other as even in C they can not really assume they are the only ones calling it. So a \"proper\" <code>sbrk</code> based allocator would do something like following to get a new chunk/page of memory.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">start</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">sbrk</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">.</span><span class=\"n\">is_null</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">oom</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">//for simplicity no free here ;-)</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">chunk</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts</span>::<span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"p\">,</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"bp\">Self</span><span class=\"p\">.</span><span class=\"n\">add_raw_memory</span><span class=\"p\">(</span><span class=\"n\">chunk</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Only by using <code>brk</code> or by (dangerously) somehow assuming it owns all memory up-to start would this create a conflict.</p>\n<p>Or in other words only if there is some implicitly shared process global state does this lead to problems.</p>",
        "id": 213526937,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602833544
    },
    {
        "content": "<p>(as far as I know)</p>",
        "id": 213527004,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602833597
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209646\">@Philipp Korber</span> <br>\nInteresting! Do you know if \"they can not really assume they are the only ones calling it\" is something widely accepted? Does it have a name (like \"multi allocator safety\" or something)?</p>",
        "id": 213528391,
        "sender_full_name": "krtab",
        "timestamp": 1602834650
    },
    {
        "content": "<p>I think it's more like a best practice then any rule, like they better should not do so because other (old) C programs they statically or dynamically link against might call <code>sbrk</code> themself.</p>",
        "id": 213528694,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602834881
    },
    {
        "content": "<p>Ok! Thanks a lot!</p>",
        "id": 213528749,
        "sender_full_name": "krtab",
        "timestamp": 1602834939
    },
    {
        "content": "<p>At least for old not really maintained libraries from the University computer since corner I have run into libraries which allocate their own block of memory using <code>sbrk</code> as a \"performance optimization\" (supposedly, they never ran a benchmark).</p>\n<p>But in the end you can't rely on a custom allocator not doing something problematic.</p>\n<p>Even if they use mmap  for system allocation the are a bunch of ways to introduce processes global state.</p>",
        "id": 213529239,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602835298
    },
    {
        "content": "<p>You piqued my interest, what would be such ways?</p>",
        "id": 213529458,
        "sender_full_name": "krtab",
        "timestamp": 1602835446
    },
    {
        "content": "<p>Like having two instances of the same custom allocator which both use the same global non mangled mutable variable but both assuming that they are singletons.</p>",
        "id": 213529972,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602835793
    },
    {
        "content": "<p>I see</p>\n<p>Thanks a lot for your answers!</p>",
        "id": 213530093,
        "sender_full_name": "krtab",
        "timestamp": 1602835867
    }
]