[
    {
        "content": "<p>I was wondering if there will be any fast math planned for simd, because I noticed <code>std::simd</code> doesn't seem to have any fast math options. I think it would be beneficial since there are a variety of optimizations to pick from available in Intel's <em>Optimization Reference Manual</em> especially for AVX in chapter 15.</p>",
        "id": 274097743,
        "sender_full_name": "Jonathan",
        "timestamp": 1646383911
    },
    {
        "content": "<p>Given that there's no \"fast\" math for <code>f32</code> scalars either, it's unclear what it should look like, and thus it's probably not actively planned.  Doing the same thing as <code>-ffast-math</code> would allow UB from safe code, which is absolutely not allowed, so it needs to be more nuanced.</p>\n<p>Was there anything in particularly you were interested in?</p>",
        "id": 274109406,
        "sender_full_name": "scottmcm",
        "timestamp": 1646389820
    },
    {
        "content": "<p>scalar math has some intrinsics for fast math like <code>std::intrinsics::fdiv_fast</code>, but this isn't the case for simd.<br>\nI'm interesting in taking advantage of <code>rcpps</code>, and <code>rsqrtps</code> when possible, because sometimes low accuracy should be fine for certain tasks that don't require comparisons.</p>",
        "id": 274115220,
        "sender_full_name": "Jonathan",
        "timestamp": 1646393217
    },
    {
        "content": "<p>I am reluctant to enable a path to a low-accuracy hardware instruction because that has in the past resulted in Intel and AMD not agreeing on how it should be implemented which results in actual bugs in actual programs:<br>\n<a href=\"https://cookieplmonster.github.io/2020/07/19/silentpatch-mass-effect/\">https://cookieplmonster.github.io/2020/07/19/silentpatch-mass-effect/</a><br>\n<a href=\"https://robert.ocallahan.org/2021/09/rr-trace-portability-diverging-behavior.html\">https://robert.ocallahan.org/2021/09/rr-trace-portability-diverging-behavior.html</a></p>",
        "id": 274165586,
        "sender_full_name": "Jubilee",
        "timestamp": 1646416649
    },
    {
        "content": "<p>The problem isn't that the answer is wibbly, it's that two different CPUs for what's supposed to be the <strong>same damn target</strong> wibbling on the answer cause really wacky results. I don't want Rust to have to have <code>cfg(amd)</code> or <code>cfg(intel)</code>.</p>",
        "id": 274165735,
        "sender_full_name": "Jubilee",
        "timestamp": 1646416701
    },
    {
        "content": "<p>The Rust vision of so-called \"fast math\" is going to look a lot less like \"fast math in a general sense\" and a lot more like \"enabling specific compiler contracts in some code, like <code>fp_contract</code>\"</p>",
        "id": 274166118,
        "sender_full_name": "Jubilee",
        "timestamp": 1646416844
    },
    {
        "content": "<p>I was not aware that amd and intel had those stupid issues. I still hope we see simd fast math eventually, but without those architectural mistakes.</p>",
        "id": 274252377,
        "sender_full_name": "Jonathan",
        "timestamp": 1646498153
    },
    {
        "content": "<p>We will definitely try to expose fast operations where uh, they don't explode things.</p>",
        "id": 274267014,
        "sender_full_name": "Jubilee",
        "timestamp": 1646517436
    }
]