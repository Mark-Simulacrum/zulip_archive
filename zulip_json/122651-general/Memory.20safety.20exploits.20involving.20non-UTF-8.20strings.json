[
    {
        "content": "<p>I see that CVE-2020-36317, or <a href=\"https://github.com/rust-lang/rust/issues/78498\">#78498</a>, mentions the possibility of a vulnerability caused by APIs producing non-UTF-8 strings. Now I am aware that <code>str</code> and <code>String</code> make UTF-8 part of the safety contract of the type, so a safe function is permitted to assume that the contents are UTF-8, but are there actually any current API functions that rely on this for memory safety? Assuming an attacker can somehow use <code>from_utf8_unchecked</code> arbitrarily, how can we construct memory unsafety from String's API?</p>",
        "id": 234106504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618206555
    },
    {
        "content": "<p>In utf8, you can assume the length of the codepoint (in bytes) from only the first byte. So <em>some</em> functions will look at the first byte, make a determination about the minimum remaining length within the &amp;str, and then unchecked read from the next 1 to 3 bytes. If that first byte is wrong you'll get unchecked reads out of bounds.</p>",
        "id": 234107027,
        "sender_full_name": "Lokathor",
        "timestamp": 1618207016
    },
    {
        "content": "<p>turning a 3 byte over-read into an attack instead of getting junk or a page fault is left as an exercise for the enterprising young programmers out there</p>",
        "id": 234107151,
        "sender_full_name": "Lokathor",
        "timestamp": 1618207116
    },
    {
        "content": "<p>The following data might not be junk, so an information leak could enable other attacks.</p>",
        "id": 234107243,
        "sender_full_name": "cuviper",
        "timestamp": 1618207209
    },
    {
        "content": "<blockquote>\n<p>If that first byte is wrong you'll get unchecked reads out of bounds.</p>\n</blockquote>\n<p>That still seems pretty far from an attack though, since the read itself will probably just read garbage or at worst attacker-controlled data</p>",
        "id": 234107667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618207522
    },
    {
        "content": "<p>LLVM does out of bounds reads all the time, that's what <code>poison</code> is for</p>",
        "id": 234107752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618207603
    },
    {
        "content": "<p>Perhaps you could also confuse reverse iterators if you only had continuation bytes, so it reads past the front looking for the start of a char.</p>",
        "id": 234107813,
        "sender_full_name": "cuviper",
        "timestamp": 1618207669
    },
    {
        "content": "<p>But I can see how it might be an information leak</p>",
        "id": 234107815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618207671
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> that's what <code>cuviper</code> just said :3</p>",
        "id": 234107869,
        "sender_full_name": "Lokathor",
        "timestamp": 1618207695
    },
    {
        "content": "<p>Actually, I took a look at <code>impl&lt;'a&gt; DoubleEndedIterator for Chars&lt;'a&gt;</code> and the core function, <code>next_code_point_reverse</code>, depends on an iterator over <code>&amp;u8</code>, which it gets from <code>slice::Iter</code>, so it does not overrun</p>",
        "id": 234108444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618208224
    },
    {
        "content": "<p>I'm not sure where to look to find the rumored 3 byte over-read</p>",
        "id": 234108552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618208305
    },
    {
        "content": "<p>Ok, but that's an implementation detail. Maybe in the future we'll find better performance in that iterator with raw pointers.</p>",
        "id": 234108578,
        "sender_full_name": "cuviper",
        "timestamp": 1618208333
    },
    {
        "content": "<p>I wonder if there's mischief to be had in stuff like overlong encoding too</p>",
        "id": 234108698,
        "sender_full_name": "cuviper",
        "timestamp": 1618208407
    },
    {
        "content": "<p>Sure, I'm trying to figure out how actually vulnerable the code is to non-UTF-8 strings, not what our stability promises say</p>",
        "id": 234108809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618208505
    },
    {
        "content": "<p>Although if the answer is \"not at all\", it makes me wonder whether we should downgrade the UTF-8 promise from \"memory safety\" to \"logical error\"</p>",
        "id": 234108913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618208570
    },
    {
        "content": "<blockquote>\n<p>I wonder if there's mischief to be had in stuff like overlong encoding too</p>\n</blockquote>\n<p>Overlong meaning UTF-8-ish but with too many bytes? Like <code>11111110 (10xxxxx)*6</code></p>",
        "id": 234109049,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618208674
    },
    {
        "content": "<p>There's another kind of overlong here, since 4 byte UTF-8 goes up to <code>0x1FFFFF</code> but unicode only goes up to <code>0x10FFFF</code></p>",
        "id": 234109261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618208872
    },
    {
        "content": "<p>I mean encoding a char as more bytes than it needs, like you could write <code>\\0</code> as 11000000 10000000</p>",
        "id": 234109344,
        "sender_full_name": "cuviper",
        "timestamp": 1618208976
    },
    {
        "content": "<p>I would be surprised if that leads to memory errors, but it will almost certainly throw off <code>str::eq</code></p>",
        "id": 234109481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618209083
    },
    {
        "content": "<p>Well, there are things like <a href=\"https://github.com/rust-lang/rust/blob/master/library/alloc/src/str.rs#L392\">https://github.com/rust-lang/rust/blob/master/library/alloc/src/str.rs#L392</a> where we assume that the char iterator advanced by the utf8-length of the character that was parsed; overlong encodings will mess with that</p>",
        "id": 234109748,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618209256
    },
    {
        "content": "<p>It's not just <code>std</code> that matters either -- this is a language property, so third-party code may also depend on valid utf-8.</p>",
        "id": 234110329,
        "sender_full_name": "cuviper",
        "timestamp": 1618209676
    },
    {
        "content": "<p>Wikipedia cites some vulnerabilities in the \"invalid sequences\" section:<br>\n<a href=\"https://en.wikipedia.org/wiki/UTF-8\">https://en.wikipedia.org/wiki/UTF-8</a></p>",
        "id": 234110476,
        "sender_full_name": "cuviper",
        "timestamp": 1618209782
    },
    {
        "content": "<p>(I haven't looked at what actually failed in those cases)</p>",
        "id": 234110519,
        "sender_full_name": "cuviper",
        "timestamp": 1618209809
    },
    {
        "content": "<p>From the description, it sounds like the trick is to use a bad partial utf8 character to hide or insert a close quote, leading to an SQL injection style attack</p>",
        "id": 234110950,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618210098
    },
    {
        "content": "<p>FYI when I found that bug I tried to see if I could easily exploit it to read out of bounds memory but I couldn't find anything. That's why there's just that harmless assert at the end of the code snippet.</p>",
        "id": 234119206,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1618214809
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234109344\">said</a>:</p>\n<blockquote>\n<p>I mean encoding a char as more bytes than it needs, like you could write <code>\\0</code> as 11000000 10000000</p>\n</blockquote>\n<p>This is illegal in UTF-8, characters must be encoded using the least number of bytes possible (source: gynvael's book)</p>",
        "id": 234181972,
        "sender_full_name": "Soveu",
        "timestamp": 1618242110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"328907\">@Soveu</span> I know it is illegal, but that's what this thread is contemplating</p>",
        "id": 234183731,
        "sender_full_name": "cuviper",
        "timestamp": 1618242727
    },
    {
        "content": "<blockquote>\n<p>it sounds like the trick is to use a bad partial utf8 character to hide or insert a close quote, leading to an SQL injection style attack</p>\n</blockquote>\n<p>Huh, wow. I'm pretty sure in practice it's somewhere between \"very difficult\" and \"only possible in theory without serious contrivances\" to cause exploitable <em>memory unsafety</em> using invalid UTF8 in the stdlib, but yeah...</p>\n<p>I guess it makes sense that you can probably use invalid UTF8 to cause all kinds of bugs in the str functions, and those bugs can be used to cause other security-sensitive code to do the wrong thing. Pretty clever/interesting, honestly. </p>\n<hr>\n<p>That said, non-exploitable/very-hard-to-exploit memory unsafety is totally doable, and if you <em>had</em> to go about it, I think you should be able to get a 3-byte or so heap overflow if you carefully construct arguments to String::insert_str (or something like this — I'd look at <code>&amp;mut String</code> methods).</p>\n<p>In theory, if this is done correctly, and the String was very close to capacity, and the stars align to shine properly your a program, and you're using the right allocator... this could stomp on some allocator metadata for the next object, and which could be Bad News.</p>",
        "id": 234360457,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1618332050
    },
    {
        "content": "<p>it looks like the core contemplation here is a question about whether we could eliminate the safety invariant and convert it to a logical error. my sense is that this is a breaking change. even if it's the case that std routines itself don't have memory safety vulnerabilities---or perhaps, even if they could be changed to not have them---other code outside on std may be relying on the invariant that a <code>str</code> is always valid UTF-8 for safety purposes. relaxing this to a logical error could potentially cause that downstream code that didn't have UB before to have UB. if that reasoning is correct, then i think removing the UTF-8 invariant is probably a non-starter.</p>",
        "id": 234421897,
        "sender_full_name": "BurntSushi",
        "timestamp": 1618359301
    },
    {
        "content": "<p>Plus future optimizations might want to exploit that guarantee.</p>",
        "id": 234460998,
        "sender_full_name": "The 8472",
        "timestamp": 1618389028
    },
    {
        "content": "<p>maybe, but I think that UTF-8 is a rather intricate logical property to be using in the memory safety regime. I don't think it pays for itself if we consider the possible potential for vulnerabilities against potential for optimization</p>",
        "id": 234462618,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618389835
    },
    {
        "content": "<p>Also, there is a possible middle ground, where we promise that std will not elevate UTF-8 vulnerabilities but also keep <code>unsafe</code> on non-UTF-8 functions and promise that any safe function will generate proper UTF-8. Then an application can, in <code>unsafe</code> code, use non-UTF-8 strings and be sure of memory safety (but probably not correctness) provided it only passes them to std functions or other non-UTF-8-vetted crates</p>",
        "id": 234463355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618390198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234462618\">said</a>:</p>\n<blockquote>\n<p>maybe, but I think that UTF-8 is a rather intricate logical property to be using in the memory safety regime.</p>\n</blockquote>\n<p>That is, if we consider the work required to do unsafe code verification a la RustBelt, all the string functions are going to be <em>way</em> more complicated to verify compared to, say, <code>Vec</code></p>",
        "id": 234463820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618390422
    },
    {
        "content": "<p>I know when I first started with Rust the messaging around <code>&amp;str</code> was that it's a strong guarantee of valid UTF-8. And indeed this was often used as an example of what the type system can absolutely guarantee. Perhaps this was overzealous but, as BurntSushi says, it's a bit late to be clarifying that now. And it's theoretically pretty trivial to produce UB if working under that assumption (e.g. using <code>unreachable_unchecked</code> for invalid cases).</p>\n<p>The middle ground sounds interesting to me but I worry it'll confuse the situation from a user perspective. Why are some functions now ok to pass an ill-formed <code>&amp;str</code> to but others not? Do crates that handle <code>&amp;str</code> all need to state their UTF-8 handling policy? Would it not be simpler to use a byte string type for this? I can see that advantage of making it merely a logical error, I just think it might be too late to do so.</p>",
        "id": 234495090,
        "sender_full_name": "Chris Denton",
        "timestamp": 1618405743
    },
    {
        "content": "<p>it might be worth pointing out that we did relax the UTF-8 invariant from a \"language\" level safety invariant down to a \"normal\" library level invariant: <a href=\"https://github.com/rust-lang/rust/issues/71033\">https://github.com/rust-lang/rust/issues/71033</a></p>",
        "id": 234497460,
        "sender_full_name": "BurntSushi",
        "timestamp": 1618406599
    },
    {
        "content": "<blockquote>\n<p>The middle ground sounds interesting to me but I worry it'll confuse the situation from a user perspective. Why are some functions now ok to pass an ill-formed &amp;str to but others not? Do crates that handle &amp;str all need to state their UTF-8 handling policy? Would it not be simpler to use a byte string type for this? I can see that advantage of making it merely a logical error, I just think it might be too late to do so.</p>\n</blockquote>\n<p>Note that there is no version of this proposal that involves making non-UTF-8 a legal value for <code>&amp;str</code> at the logical level. So it would never be <em>recommended</em> to do this, and any occurrence of it is unambiguously a bug. However, by making it a logical bug instead of a memory safety bug it is possible to sleep a little better regarding complex programs manipulating UTF-8 strings via the unsafe functions, knowing that \"at worst\" bad handling will result in a panic. (This isn't really true, there are all sorts of ways a memory safe rust program can have vulnerabilities, but, well, you only get so much \"for free\".)</p>",
        "id": 234501025,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618407909
    },
    {
        "content": "<p>The weakest version of this proposal would not change any of the messaging but would ensure that any functions in std do not exploit the UTF-8 property to read or write out of bounds. From what I can tell this is already 90%+ true, but it would be good to make sure and keep it that way.</p>",
        "id": 234501657,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618408159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"https://github.com/rust-lang/rust/issues/71033#issuecomment-612671908\">mentions</a> this possibility on <a href=\"https://github.com/rust-lang/rust/issues/71033\">#71033</a>:</p>\n<blockquote>\n<p>I wonder if we might be able, in the future, to carefully exclude a few of <code>str</code>'s functions from the \"library UB\" requirements.</p>\n</blockquote>\n<p>although I'm interpreting \"a few of <code>str</code>'s functions\" as \"everything in std\" which is a bit of expansion of scope</p>",
        "id": 234503288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618408793
    },
    {
        "content": "<p>I recall exploiting the UTF-8 only property for speeds at some points in the past, but I don't recall exact situations, its been a while.</p>",
        "id": 234509636,
        "sender_full_name": "nagisa",
        "timestamp": 1618411099
    },
    {
        "content": "<p>The thing I'd most expect to be used somewhere is that <code>0b11111xxx</code> cannot happen in valid UTF-8, so the most obvious bit of \"UB if we changed the safety rule\" code would be arms like <code>0xF8..=0xFF =&gt; /* SAFETY: str is valid UTF-8 */ unsafe { unreachable_unchecked() }</code>, and I'd fully expect there's plenty of that out there.</p>",
        "id": 234517960,
        "sender_full_name": "scottmcm",
        "timestamp": 1618413314
    },
    {
        "content": "<p>and unchecked indexing</p>",
        "id": 234518737,
        "sender_full_name": "The 8472",
        "timestamp": 1618413598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> For that kind of thing, I assume that is one part of a match with several arms, so it should not be a huge performance hit to replace that branch with <code>unreachable!()</code>, or perhaps rolling it into one of the other branches and using <code>debug_assert!</code> to assert unreachability of those values</p>",
        "id": 234520279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618414026
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234107752\">said</a>:</p>\n<blockquote>\n<p>LLVM does out of bounds reads all the time, that's what <code>poison</code> is for</p>\n</blockquote>\n<p>no, it doesn't, and no, it's not. out-of-bounds reads are UB in LLVM. <code>poison</code> is for reads from <em>uninitialized in-bounds</em> bytes.</p>",
        "id": 234520359,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414057
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234501025\">said</a>:</p>\n<blockquote>\n<p>However, by making it a logical bug instead of a memory safety bug it is possible to sleep a little better regarding complex programs manipulating UTF-8 strings via the unsafe functions, knowing that \"at worst\" bad handling will result in a panic. </p>\n</blockquote>\n<p>FWIW, I'd rather not do that.  I really appreciate that <code>unsafe</code> in the library has been kept strictly to \"no, you really can get UB with this\" (even if hitting <code>unreachable_unchecked</code> is a weird kind of memory unsafety), because it helps avoid the \"how bad could it be?\" instinct that people seem to have.</p>\n<p>Having a <em>different</em> type for the \"do something reasonable if it's not UTF-8\" logic is great, though: <a href=\"https://lib.rs/crates/bstr\">https://lib.rs/crates/bstr</a></p>",
        "id": 234520522,
        "sender_full_name": "scottmcm",
        "timestamp": 1618414107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234462618\">said</a>:</p>\n<blockquote>\n<p>maybe, but I think that UTF-8 is a rather intricate logical property to be using in the memory safety regime. I don't think it pays for itself if we consider the possible potential for vulnerabilities against potential for optimization</p>\n</blockquote>\n<p><code>RefCell</code> uses <em>much more</em> intricate logical properties for its memory safety. At least UTF-8 is a pure property on the data! <code>RefCell</code> uses <a href=\"https://gitlab.mpi-sws.org/iris/lambda-rust/-/blob/9f72ef668c9df582a616b6e558baaeb11bedb3b0/theories/typing/lib/refcell/refcell.v#L45\">something like this</a>. To even understand what this means, you basically have to <a href=\"https://people.mpi-sws.org/~jung/thesis.html\">read a book</a>.<br>\nAnd don't let me get started on <code>Arc</code>...</p>",
        "id": 234520844,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414217
    },
    {
        "content": "<p>So, I am personally not very worried about this being a too complex safety invariant.</p>",
        "id": 234521408,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414388
    },
    {
        "content": "<p>That invariant seems reasonable, although I'm sure there is a lot of subtlety involved in choosing the right relations like <code>▷=∗</code> there. But UTF8 is complicated in the much more straightforward and boring CS way - I would be very surprised if you could get the UTF8 spec to be that small</p>",
        "id": 234521637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618414462
    },
    {
        "content": "<p>sure you could:</p>\n<div class=\"codehilite\"><pre><span></span><code>is_utf8 list_of_bytes\n</code></pre></div>",
        "id": 234521726,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414493
    },
    {
        "content": "<p>you might say it's cheating that we all moved it into a def.n, but then you really don't want to know what <code>&amp;{α}</code> unfolds to.</p>",
        "id": 234521782,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414518
    },
    {
        "content": "<p>Well yes, you can play the same game with <code>refcell_inv</code></p>",
        "id": 234521783,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618414519
    },
    {
        "content": "<p><code>refcell_inv</code> unfolds to things that are unspeakably more horrifying than what <code>is_utf8</code> unfolds to^^</p>",
        "id": 234521864,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414547
    },
    {
        "content": "<p>That's only useful if you never have to unfold the definition. I think that most uses of <code>unsafe</code> in <code>str</code> actually require unfolding the definition, or at least using several associated predicates</p>",
        "id": 234521995,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618414595
    },
    {
        "content": "<p>Here's a teaser:<br>\n<a href=\"/user_uploads/4715/w2eVC_bk2UTOUNXSMZpUmfXO/Screenshot_20210414_173641.png\">Screenshot_20210414_173641.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/w2eVC_bk2UTOUNXSMZpUmfXO/Screenshot_20210414_173641.png\" title=\"Screenshot_20210414_173641.png\"><img src=\"/user_uploads/4715/w2eVC_bk2UTOUNXSMZpUmfXO/Screenshot_20210414_173641.png\"></a></div>",
        "id": 234522045,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414625
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234521995\">said</a>:</p>\n<blockquote>\n<p>That's only useful if you never have to unfold the definition. I think that most uses of <code>unsafe</code> in <code>str</code> actually require unfolding the definition, or at least using several associated predicates</p>\n</blockquote>\n<p>I assume there are fairly reasonable reasoning principles for <code>is_utf8</code> in terms of individual \"codepoint units\" or whatever you want to call them</p>",
        "id": 234522125,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414660
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>  Proof. move=&gt;???[|[[]|]]//=. Qed.\n</code></pre></div>\n<p>ssreflect is great</p>",
        "id": 234522144,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1618414666
    },
    {
        "content": "<p>just like there are fairly reasonable reasoning principles for these borrow connectives that <code>refcell_inv</code> is using</p>",
        "id": 234522473,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414782
    },
    {
        "content": "<p>but when I say \"reasonable\" I mean <a href=\"https://plv.mpi-sws.org/rustbelt/popl18/appendix.pdf#page=23\">this</a>. So, \"several associated predicates\"? check.</p>",
        "id": 234522918,
        "sender_full_name": "RalfJ",
        "timestamp": 1618414936
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234517960\">said</a>:</p>\n<blockquote>\n<p>The thing I'd most expect to be used somewhere is that <code>0b11111xxx</code> cannot happen in valid UTF-8</p>\n</blockquote>\n<p>I wonder, could we make that a niche? (are unsized enums even possible?)</p>",
        "id": 234524907,
        "sender_full_name": "cuviper",
        "timestamp": 1618415641
    },
    {
        "content": "<p>we can't make it a niche because that would promote utf8 back to being language UB</p>",
        "id": 234533177,
        "sender_full_name": "Lokathor",
        "timestamp": 1618418656
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings/near/234524907\">said</a>:</p>\n<blockquote>\n<p>I wonder, could we make that a niche? (are unsized enums even possible?)</p>\n</blockquote>\n<p>We discussed that in &lt;<a href=\"https://github.com/rust-lang/rust/issues/71033#issuecomment-614859618\">https://github.com/rust-lang/rust/issues/71033#issuecomment-614859618</a>&gt;, and decided not to use it.</p>",
        "id": 234535994,
        "sender_full_name": "scottmcm",
        "timestamp": 1618419647
    }
]