[
    {
        "content": "<p>As Rust does not provide support for bitfield structs, what is the best practice for porting over a C bitfield struct to Rust code? I have been looking at a number of crates (<code>bitfield</code>, <code>modular-bitfield</code>, etc.), but the approaches all seem quite bloated or heavy (maybe I am too much of a minimalist). Are these crates what is currently recommended, or is there another approach which is better?</p>",
        "id": 250386690,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1629740966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> bitfields aren't flags</p>",
        "id": 250386862,
        "sender_full_name": "Laurențiu",
        "timestamp": 1629741046
    },
    {
        "content": "<p>Oh oh I was confused</p>",
        "id": 250386925,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629741081
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> I did look at those for another solution, but as <span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu</span> mentioned, bitfields aren't quite the same thing.</p>",
        "id": 250387164,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1629741214
    },
    {
        "content": "<p>What do you mean by bloated and heavy?</p>",
        "id": 250387362,
        "sender_full_name": "Laurențiu",
        "timestamp": 1629741320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu</span> lots of boilerplate implementations which look to mimic the behavior, many of them dramatically changing the behavior you would find in C. I understand that Rust makes things much safer, but it seems like a pretty important feature which is currently missing from the core language. After reading a number of threads, I recognize the teams desire to make all code portable between different architectures in Rust, but blacklisting a feature due to portability seems a bit extreme. It also is inconsistent with previously implemented features in the standard library which are unique implementations for individual operating systems, etc.</p>",
        "id": 250388129,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1629741679
    },
    {
        "content": "<p>That being said, I am probably missing something, and recognize there might be a much better way to approach manipulating registers. Thus my question <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 250388335,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1629741762
    },
    {
        "content": "<p><code>modular-bitfield</code> looks reasonable unless you want to avoid proc macros.</p>",
        "id": 250388613,
        "sender_full_name": "Laurențiu",
        "timestamp": 1629741933
    },
    {
        "content": "<p>I wouldn't call this \"blacklisting a feature\". It's not available yet. It can still be proposed (like in <a href=\"https://github.com/rust-lang/rfcs/pull/3113\">https://github.com/rust-lang/rfcs/pull/3113</a>), and there is a chance that the proposal will be accepted, but there's probably a high bar of entry.</p>",
        "id": 250388835,
        "sender_full_name": "Laurențiu",
        "timestamp": 1629742035
    },
    {
        "content": "<p>If you have C headers afaik bindgen can generate wrapper structs that provide equivalent APIs. But that's not exactly minimal either.</p>",
        "id": 250389080,
        "sender_full_name": "The 8472",
        "timestamp": 1629742172
    },
    {
        "content": "<p>Specifically for registers, I'd look at the <code>cortex-m</code> ecosystem. It uses the <code>volatile-register</code> crate, which has some wrappers over registers to provide a <code>modify</code> operation.</p>",
        "id": 250389207,
        "sender_full_name": "Laurențiu",
        "timestamp": 1629742230
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu</span> I appreciate the approach <code>modular-bitfield</code> took, but it doesn't provide an easy way to mix with primitive data types outside of the pre-defined bit types (B1-B64). An example of what I mean:</p>\n<div class=\"codehilite\"><pre><span></span><code>typedef struct some_example_t\n{\n    uint64_t a;\n    uint8_t b[8];    &lt;--- porting over this in Rust while also using bit types.\n    uint64_t c; // reserved\n    uint64_t d; // reserved\n    uint32_t e : 1;\n    uint32_t f : 2;\n    uint32_t g : 29;\n} some_example;\n</code></pre></div>",
        "id": 250400563,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1629747256
    },
    {
        "content": "<p>would <code>#[bitfield] struct B8Array([u8; 8]);</code> work?</p>",
        "id": 250401003,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1629747500
    },
    {
        "content": "<p>I think that example would have a rust type of</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">SomeExample</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"kt\">u64</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">c</span>: <span class=\"kt\">u64</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">d</span>: <span class=\"kt\">u64</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">efg</span>: <span class=\"kt\">u32</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and the rest is made up with macro magic from a library like <code>#[bitfield]</code></p>",
        "id": 250401228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629747605
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>  I tried that, but received:</p>\n<p>Error: the trait bound <code>[u8; 8]: Specifier</code> is not satisfied.</p>",
        "id": 250401338,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1629747684
    },
    {
        "content": "<p>we ran into similar issues with bitfield crates a couple years ago, so maybe this would be a useful resource for you? <a href=\"https://immunant.com/blog/2020/01/bitfields/\">https://immunant.com/blog/2020/01/bitfields/</a> Not sure if the c2rust crate does exactly what you need, but I think it might.</p>",
        "id": 250401376,
        "sender_full_name": "Stephen Crane",
        "timestamp": 1629747709
    },
    {
        "content": "<p>The type being magicked here is <code>efg: u32</code></p>",
        "id": 250401437,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629747726
    },
    {
        "content": "<p>so you would have <code>efg: MyU32Bitfield</code> where some macro defines <code>MyU32Bitfield</code></p>",
        "id": 250401507,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629747758
    },
    {
        "content": "<p>and since the repr of this type is just a plain <code>u32</code> you shouldn't have issues with <code>Specifier</code> (I don't know much about the <code>modular-bitfield</code> crate though so I might be off base for the intended usage)</p>",
        "id": 250401585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629747803
    },
    {
        "content": "<p>Nesting the bitfield field as a struct itself? I think that would work, although it's a bit cumbersome</p>",
        "id": 250401816,
        "sender_full_name": "Stephen Crane",
        "timestamp": 1629747915
    },
    {
        "content": "<p>It sounds reasonable for a bitfield crate to support structs containing \"foreign\" fields with no constraints, but that might be technically difficult for the macro implementation</p>",
        "id": 250401972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629747994
    },
    {
        "content": "<p>But I think that it would be a bad idea for this to be integrated into the language the way it is in C/C++. It adds <em>way</em> too much complication to the spec, since the concept of what a field is gets very muddy</p>",
        "id": 250402189,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629748109
    },
    {
        "content": "<p>Even if it gets some sugar, it should never be more than that</p>",
        "id": 250402259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1629748137
    },
    {
        "content": "<p>yeah the number of places bitfields need special casing in the c++ standard is... a bit much lol</p>",
        "id": 250404569,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1629749274
    },
    {
        "content": "<p>for this, i just newtype and in and use getter/setter stuff. I don't even use proc-macros, this sort of code is usually made once and then doesn't change because it's baked into hardware, so proc-macros aren't useful.</p>",
        "id": 250429487,
        "sender_full_name": "Lokathor",
        "timestamp": 1629764869
    }
]