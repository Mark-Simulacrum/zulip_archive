[
    {
        "content": "<p>Hi, <br>\nI found some weirdness on the way <a href=\"http://BufReader.read\">BufReader.read</a> works and I don't know where to discuss it.<br>\nThe behavior is tested and expected <a href=\"https://github.com/rust-lang/rust/blob/4919988fe1765e51232558647f2260fff3544658/library/std/src/io/buffered/tests.rs#L47\">here</a>.  The test is copied bellow:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[test]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">test_buffered_reader</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">inner</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">reader</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BufReader</span>::<span class=\"n\">with_capacity</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">inner</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">nread</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">nread</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">buffer</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">[]);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">nread</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">nread</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">buffer</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">[]);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">nread</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">nread</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">buffer</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">nread</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">nread</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]);</span><span class=\"w\">                 </span><span class=\"c1\">//  &lt;--- why :(</span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">buffer</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">[]);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">nread</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">nread</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">buffer</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"p\">[]);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The issue is, at the annotated line, dest buffer has enough space to hold the remaining 2 bytes, but the read is limited by the remaining space on BufReader internal buffer, instead of the actual available data. This means that I can't simply change </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">File</span>::<span class=\"n\">open</span><span class=\"p\">(</span><span class=\"n\">some_path</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>\n<p>to </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">file</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BufReader</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">File</span>::<span class=\"n\">open</span><span class=\"p\">(</span><span class=\"n\">some_path</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>without accounting for this behavior.<br>\nSo, is this intended? Where is the best place to discuss this? Should I open an issue? Create a PR?</p>\n<p>Thanks in advance :)</p>",
        "id": 262914621,
        "sender_full_name": "Luiz Gustavo",
        "timestamp": 1638083942
    },
    {
        "content": "<p>That's not ideal behavior, I think.</p>",
        "id": 262914970,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638084584
    },
    {
        "content": "<p>Generally <a href=\"https://doc.rust-lang.org/std/io/trait.Read.html#tymethod.read\"><code>Read::read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;</code></a> does not guarantee that all of <code>buf.len()</code> bytes are being read if they are available. That is true for <code>File::read()</code> as well. So your implementation needs to handle that in any case.</p>",
        "id": 262915651,
        "sender_full_name": "Hans Kratz",
        "timestamp": 1638085781
    },
    {
        "content": "<p>Or, IIRC, the code reading the buffer should use <a href=\"https://doc.rust-lang.org/std/io/struct.BufReader.html#method.read_exact\"><code>read_exact</code></a> instead of <code>read</code> if it needs the buffer filled.</p>",
        "id": 262915709,
        "sender_full_name": "scottmcm",
        "timestamp": 1638085901
    },
    {
        "content": "<p><code>read_exact</code>, though, blocks until there is enough bytes, right?</p>",
        "id": 262915762,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638085981
    },
    {
        "content": "<p>Docs don't actually say what the behaviour is</p>",
        "id": 262915777,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638086025
    },
    {
        "content": "<p>Yeah, it will, and it'll error if there aren't enough.</p>",
        "id": 262915902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638086207
    },
    {
        "content": "<p>If you don't want to block, e.g. on a socket, then it's even more important to deal with short reads.</p>",
        "id": 262932570,
        "sender_full_name": "The 8472",
        "timestamp": 1638110910
    },
    {
        "content": "<blockquote>\n<p>The issue is, at the annotated line, dest buffer has enough space to hold the remaining 2 bytes, but the read is limited by the remaining space on BufReader internal buffer, instead of the actual available data. </p>\n</blockquote>\n<p>BufReader cannot try to retrieve the remaining data from the underlying reader because that read could error even though there's still data in the buffer. To maintain error-transparency it first has to return all the data that has already been buffered up before performing an action that could return an error.</p>",
        "id": 262935261,
        "sender_full_name": "The 8472",
        "timestamp": 1638114660
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"407656\">@Hans Kratz</span> what I found annoying is that in this case it is an almost guaranteed short read  every time the buffer is filled. My first thought was that every short read should come from a short read on the underlying  <code>read</code>.<br>\nBut if I understand what <span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> pointed out, we might have previously successful read data lost due to an error occurred on a different read, which would be more than just annoying.<br>\nIt make sense now, thanks everyone.</p>",
        "id": 262936509,
        "sender_full_name": "Luiz Gustavo",
        "timestamp": 1638116449
    },
    {
        "content": "<p>Also note that <code>File</code> can very much return short reads. While at least linux tries hard to fulfill the full read length for regular files it does not guarantee that either (e.g. consider FUSE filesystems) and one can always open non-regular files via <code>File::open</code> such as named pipes, unix sockets or arbitrary file descriptors via <code>/proc/&lt;pid&gt;/fd/</code>, which in turn is used by bash command substitution.</p>",
        "id": 262936914,
        "sender_full_name": "The 8472",
        "timestamp": 1638117048
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> On the other hand, if you're going to treat any read error as a fatal error and all the data read so far won't be useful anyway in that case, then it'd be nice to optimize and not have short reads.</p>",
        "id": 262942445,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638125230
    },
    {
        "content": "<p>As an example, I have a BufRead wrapped around a reader that produces, alternating, large files and small headers. It'd be nice if every small header didn't result in a nine-byte read.</p>",
        "id": 262942511,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638125308
    },
    {
        "content": "<p>Does the wrapped reader produce short reads?</p>",
        "id": 262943407,
        "sender_full_name": "The 8472",
        "timestamp": 1638126525
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">reader</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">BufReader</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">futures_util</span>::<span class=\"n\">TryStreamExt</span>::<span class=\"n\">into_async_read</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">pin</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">futures_util</span>::<span class=\"n\">stream</span>::<span class=\"n\">try_unfold</span><span class=\"p\">(</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 262943813,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638127138
    },
    {
        "content": "<p>It's a <code>try_unfold</code> that produces, alternately, chunks of file data up to 4k, and per-file headers that are 9 bytes.</p>",
        "id": 262943831,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638127172
    },
    {
        "content": "<p>Isn't that all async, i.e. not the std buf reader?</p>",
        "id": 262944663,
        "sender_full_name": "The 8472",
        "timestamp": 1638128454
    },
    {
        "content": "<p>Anyway, what I was going for is that if you don't care about the bytes before an error then the underlying reader could do the looping when BufReader tries to fill its buffer. Then the header will end up in the buffer at the end of the previous file.</p>",
        "id": 262945153,
        "sender_full_name": "The 8472",
        "timestamp": 1638129241
    },
    {
        "content": "<p>I'd like to avoid hand-coding that logic. I'm not writing a reader; I'm using <code>into_async_read</code> and a <code>try_unfold</code> closure.</p>",
        "id": 262950103,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638136068
    },
    {
        "content": "<p>But that means you are using <a href=\"https://docs.rs/futures/0.3.18/futures/io/struct.BufReader.html\"><code>futures::io::BufReader</code></a>, right?</p>",
        "id": 262950346,
        "sender_full_name": "Hans Kratz",
        "timestamp": 1638136373
    },
    {
        "content": "<p>As re-exported from smol, but yeah.</p>",
        "id": 262954096,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1638141715
    }
]