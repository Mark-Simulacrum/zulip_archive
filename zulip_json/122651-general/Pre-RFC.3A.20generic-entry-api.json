[
    {
        "content": "<p>Hello! I've been putting together an RFC, and was hoping to get some eyes on it before going ahead and making a PR</p>\n<p><a href=\"https://github.com/maboesanman/rfcs/blob/generic-entry-api/text/0000-generic-entry-api.md\">here's the rfc</a></p>\n<p>and the quick summary:</p>\n<p>There are parallel features for “entries” in <code>std::collections::HashMap</code> and <code>std::collections::BTreeMap</code>, but as of now they are both incomplete and inconsistent. This RFC is an effort to make the two consistent, and to extend the pattern other collections by adding two new traits: <code>OccupiedEntry</code> and <code>VacantEntry</code>, and many more subtraits providing additional specific behaviors that are common among collections.</p>",
        "id": 276573257,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648179676
    },
    {
        "content": "<p>Apart from the complexity, my main concern would restricting implementations. And iirc, we are still adding methods to <code>HashMap::Entry</code>.</p>",
        "id": 276573890,
        "sender_full_name": "sgk",
        "timestamp": 1648180387
    },
    {
        "content": "<p>could you elaborate on \"restricting implementations\"?</p>",
        "id": 276574044,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648180574
    },
    {
        "content": "<p>And as for continued efforts on existing entries, the intention is that all current and in progress methods on Entry be ported to the new traits/enums, and made generic where appropriate. Mostly the actual code changes here are defining new traits and moving logic from methods to trait implementations</p>",
        "id": 276575427,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648182355
    },
    {
        "content": "<p>My initial feedback is that std is generally light on traits, so adding <em>nine</em> more just for this is something I'd not expect to be accepted.</p>\n<p>How critical are all the traits?  Could everything just be concrete instead?  If they're concrete now, is there any reason traits couldn't be added later if so desired?</p>\n<p>Also, it seems a shame to have to deprecate so many things.  Telling a substantial fraction of HashMap users to change to a new thing is pretty high impact.</p>",
        "id": 276575941,
        "sender_full_name": "scottmcm",
        "timestamp": 1648183070
    },
    {
        "content": "<p>I'm already grumpy about having to <code>use std::collections::hash_map::Entry</code> in order to use the entry api (which is otherwise very nice). I use the entry API rarely enough that it is usually my first use in the file, so there is added friction in using the method for this reason. None of the other hashmap methods require that, and if everything was in traits I would expect this problem to be much worse.</p>\n<p>I'm also not clear on why the  entry API is being deprecated in the first place, if all you are doing is adding another way to access it. (Is that all you are doing? I can't see any new <em>functionality</em> being proposed.)</p>",
        "id": 276576754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648184350
    },
    {
        "content": "<p>Also, why can't this be implemented in a separate library if it's just traits over existing functions? Your MVP implements the traits on <code>DummyHashMap</code> instead of <code>HashMap</code> and I'm not sure why.</p>",
        "id": 276576974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648184627
    },
    {
        "content": "<p>You need access to the internals, so it can’t really be an external crate completely. Maybe if the concrete entries had a few more features it would be possible to just implement on top of existing entries as an external crate, which could still be useful.</p>\n<p>Is it a breaking change to move a method from a concrete type to a trait impl on that concrete type? I would think yes right?</p>\n<p>As far as deprecations go, you’re probably right that this could be lighter touch, but this is really only deprecating the entry methods on HashMap and BTreeMap, as all the other types just support those.</p>",
        "id": 276577949,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648185894
    },
    {
        "content": "<p>One of the frustrating things about the current design is that so many of the methods on entries return things that might not be expected. I do think if none of the trait stuff makes it in, that the pattern of <code>*_entry</code> returning an entry, <code>*_vacate</code> returning a vacant entry, and <code>*_occupy</code> returning an occupied entry is one that’s worth adding.</p>",
        "id": 276578134,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648186132
    },
    {
        "content": "<p>Yeah, I think that the issue of \"entry APIs are inconsistent\" is well motivated, but the traits less so. I think a version of this RFC that just proposes a consistent API for Entry types across collections only would be better - we could then experiment with that and re-evaluate the need for traits at that point</p>",
        "id": 276578354,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648186414
    },
    {
        "content": "<blockquote>\n<p>You need access to the internals, so it can’t really be an external crate completely.</p>\n</blockquote>\n<p>But the trait would be exposing any such internals, right? So I think one way to cut this PR would be to determine what concrete \"internals\" you would need to implement the trait hierarchy in an external crate, and propose those instead of the traits themselves</p>",
        "id": 276578709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648186876
    },
    {
        "content": "<p>Yeah, I also don’t mind so much having this trait stuff live in a crate. I’ll take some more time this weekend to pare down the changes I feel are important. </p>\n<p>By far the biggest thing I have a problem with is this: OccupiedEntries have an optional key, which really confuses the model. They should have no key and the collections should have a get_entry method which takes a borrow&lt;K&gt;, cloning if needed for occupied entries.</p>",
        "id": 276578715,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648186906
    },
    {
        "content": "<blockquote>\n<p>By far the biggest thing I have a problem with is this: OccupiedEntries have an optional key, which really confuses the model.</p>\n</blockquote>\n<p>What do you mean by that? <code>key()</code> returns a <code>&amp;K</code> so I don't see how the key could be optional</p>",
        "id": 276578865,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648187063
    },
    {
        "content": "<p>An occupied entry can own a key which matches the key in the collectikn</p>",
        "id": 276578892,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187097
    },
    {
        "content": "<p>That reference is a reference into the collection</p>",
        "id": 276578899,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187111
    },
    {
        "content": "<p>Look at the <code>replace_key</code> method. I really don’t like that method as it relies on some key being there from the initial insert</p>",
        "id": 276578971,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187178
    },
    {
        "content": "<p>Right, you had to give it a key when you called <code>entry()</code></p>",
        "id": 276579002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648187229
    },
    {
        "content": "<p>I guess it always has that key though, it's not optional</p>",
        "id": 276579016,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648187247
    },
    {
        "content": "<p>and it would be unergonomic to ask for the key twice</p>",
        "id": 276579023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648187265
    },
    {
        "content": "<p>the current API also does not require any cloning of keys. In fact I don't think any of the hashmap API requires K: Clone</p>",
        "id": 276579090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648187331
    },
    {
        "content": "<p>I think that changes here are reasonable but not obviously a win</p>",
        "id": 276579131,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648187399
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Pre-RFC.3A.20generic-entry-api/near/276578715\">said</a>:</p>\n<blockquote>\n<p>Yeah, I also don’t mind so much having this trait stuff live in a crate. I’ll take some more time this weekend to pare down the changes I feel are important. </p>\n<p>By far the biggest thing I have a problem with is this: OccupiedEntries have an optional key, which really confuses the model. They should have no key and the collections should have a get_entry method which takes a borrow&lt;K&gt;, cloning if needed for occupied entries.</p>\n</blockquote>\n<p>Hmm, right now <code>OccupiedEntry</code>s have a non-optional key. This was almost accidentally changed, but the change was de-stabilized last minute specifically for this reason. What is the problem with the mandatory key on <code>OccupiedEntry</code>?</p>",
        "id": 276579197,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648187458
    },
    {
        "content": "<p>The point is once you have an occupied entry you don’t need that key. You want two methods: one that takes the key by ownership, searches, and throws the search key away if it doesn’t find anything, and another which takes a borrow of a key, and clones if needed</p>",
        "id": 276579207,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187465
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Pre-RFC.3A.20generic-entry-api/near/276579207\">said</a>:</p>\n<blockquote>\n<p>The point is once you have an occupied entry you don’t need that key. You want two methods: one that takes the key by ownership, searches, and throws the search key away if it doesn’t find anything, and another which takes a borrow of a key, and clones if needed</p>\n</blockquote>\n<p>Neither of these cover the possibility of me deciding later if I want to keep a copy of the key or if the HashMap can have it</p>",
        "id": 276579278,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648187543
    },
    {
        "content": "<p>In my RFC there is a EntryWithSearchKey enum for this purpose</p>",
        "id": 276579318,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187601
    },
    {
        "content": "<p>Or maybe I don’t understand your scenario</p>",
        "id": 276579326,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187616
    },
    {
        "content": "<p>You want the key to be used for insertion if vacant, and returned to you if occupied.</p>",
        "id": 276579415,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187725
    },
    {
        "content": "<p>Or you want the key to be cloned for vacant</p>",
        "id": 276579483,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187798
    },
    {
        "content": "<p>Ah, yeah, that is what I meant. I was just responding to the two options you had given in the message, not the RFC itself</p>",
        "id": 276579579,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648187907
    },
    {
        "content": "<p>If you ignore the collection methods and just look at the entry methods, moving from vacant to occupied is clearly problematic if occupied is required to own a key. You give your vacant entry a value, and it suddenly needs to clone it’s key because it needs to put one owned key in the occupied entry, and another in the collection with the new value.</p>",
        "id": 276579613,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648187981
    },
    {
        "content": "<p>But moving back and forth from occupied to vacant is actually a really useful thing to be able to do</p>",
        "id": 276579702,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648188022
    },
    {
        "content": "<p>Good point, and solving this problem would be wonderful - the scope of this RFC just feels like it goes significantly too far beyond that for me</p>",
        "id": 276579844,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648188156
    },
    {
        "content": "<p>The only method that is impossible to fix here is the key method on occupied entry. For these entries to be ideologically consistent that would have to return a reference into the collection, not the entry.</p>\n<p>This is why I wanted to just make fully new entry types. The abstraction for entries as they stand now is wrong, and I don’t think it’s possible to correct it without breaking stuff.</p>",
        "id": 276580019,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648188402
    },
    {
        "content": "<p>I think that's an argument for adding a <code>entry_ref()</code> function which maps to different types</p>",
        "id": 276580030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648188431
    },
    {
        "content": "<p>The problem with that is it gets really confusing what the difference between Entry and EntryRef is</p>",
        "id": 276580087,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648188496
    },
    {
        "content": "<p>one takes a <code>&amp;K</code> the other takes a <code>K</code></p>",
        "id": 276580091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648188507
    },
    {
        "content": "<p>and otherwise they have roughly equivalent methods</p>",
        "id": 276580100,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648188528
    },
    {
        "content": "<p>I think everything would be resolved by adding an OccupiedEntryRef, and an EntryRef</p>\n<p>Both would impl <code>From</code> the non ref variants.</p>\n<p>The insert_entry on VacantEntry should then also be changed to return an OccupiedEntryRef</p>\n<p>OccupiedEntry would then just be an artifact of searching with an owned key.</p>",
        "id": 276581111,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648189983
    },
    {
        "content": "<p>I agree with scott that while I can see a few traits being added (arguably, <code>std</code> is trait-light to the point of crying out for them) I doubt a design which requires 9 will get through. As someone who has advocated for more traits before, I have come face to face with the fact that there are design pressures making traits <strong>much</strong> less of a good idea for <code>std</code>.</p>",
        "id": 276586175,
        "sender_full_name": "Jubilee",
        "timestamp": 1648195294
    },
    {
        "content": "<p>I’ve been looking around for some info on this EntryRef api. Does anyone have an RFC link? Or any links to discussions?</p>",
        "id": 276616429,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648214071
    },
    {
        "content": "<blockquote>\n<p>The point is once you have an occupied entry you don’t need that key. You want two methods: one that takes the key by ownership, searches, and throws the search key away if it doesn’t find anything, and another which takes a borrow of a key, and clones if needed</p>\n</blockquote>\n<p>There have been previous RFC's about the fact that the entry API takes an owned value even though it only needs it for insertion. As I recall they went through several iterations with hundreds of comments both on the RFC's repo and internals. These previous discussions should be linked in your prior art. I don't remember the details, but a bunch of things turned out to be unsafe and other things turned out to have hidden costs. The outcome was that we should have a \"raw API\" that allowed for zero cost interactions at the risk of unsafety, and that this API should be prototyped outside of STD. In the interim HashBrown, the outside crate where it was being prototyped, became STDs HashMap implementation.</p>",
        "id": 276628980,
        "sender_full_name": "Eh2406",
        "timestamp": 1648219578
    },
    {
        "content": "<p>I really have looked around and all I can find are mentions. Do you have any suggestions for keywords to include in my search? Or other advice for locating these threads?</p>",
        "id": 276630914,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648220335
    },
    {
        "content": "<p>I will look.</p>",
        "id": 276631846,
        "sender_full_name": "Eh2406",
        "timestamp": 1648220647
    },
    {
        "content": "<p>Thanks I appreciate it!</p>",
        "id": 276635148,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648221917
    },
    {
        "content": "<ul>\n<li>May '15 <a href=\"https://internals.rust-lang.org/t/head-desking-on-entry-api-4-0/2156\">https://internals.rust-lang.org/t/head-desking-on-entry-api-4-0/2156</a> Head-Desking on Entry API 4.0</li>\n<li>Mar '18 <a href=\"https://internals.rust-lang.org/t/pre-rfc-abandonning-morals-in-the-name-of-performance-the-raw-entry-api/7043\">https://internals.rust-lang.org/t/pre-rfc-abandonning-morals-in-the-name-of-performance-the-raw-entry-api/7043</a> [Pre-RFC] Abandonning Morals In The Name Of Performance: The Raw Entry API</li>\n</ul>",
        "id": 276635650,
        "sender_full_name": "Eh2406",
        "timestamp": 1648222115
    },
    {
        "content": "<p>There are links in the second thread.</p>",
        "id": 276636010,
        "sender_full_name": "Eh2406",
        "timestamp": 1648222235
    },
    {
        "content": "<p>Some of the discussions hinged on \"can we find a solution's before GAT ship?\". Apparently the answer is \"No!\".<br>\nBut now that we have GAT, some of the older options may work fine.</p>",
        "id": 276636653,
        "sender_full_name": "Eh2406",
        "timestamp": 1648222513
    },
    {
        "content": "<p>I am actually pretty confident GAT are not required. Will hack on this a bit, and make a new, much more stripped down RFC.</p>",
        "id": 276637122,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648222728
    },
    {
        "content": "<p>But thanks for the links! I really appreciate the help. Time for me to do some reading</p>",
        "id": 276637218,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648222780
    },
    {
        "content": "<p>The project was a lot smaller then. So people did not provide links as often. As everyone was reading all the discussions anyway.<br>\nLike \"Entry API 4.0\" implies at leased 3 earlier discussions, but they are not linked. It may require follow up searching.</p>",
        "id": 276638163,
        "sender_full_name": "Eh2406",
        "timestamp": 1648223203
    },
    {
        "content": "<p>I think I have something pretty compelling for users of the regular and raw entry apis. Going to finish writing it up tonight and see what people think. It adds 4 new structs and removes the raw api structs, so the actual number of types goes down, while not losing any power.</p>\n<p>The only unfortunate thing is that it can’t be done using the original Entry and OccupiedEntry, so it adds new types EntryRef and OccupiedEntryRef.</p>\n<p>I’m pretty happy with the RawEntry changes, because I think it gets a lot easier to think about.</p>",
        "id": 276672104,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648238724
    },
    {
        "content": "<p>Hmmm I think I’m discovering that one of the problems with making this api useful is that the various entry types are not generic over the BuildHasher. Idk if much growth of old apis is actually possible without that parameter</p>",
        "id": 276690770,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648250140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Pre-RFC.3A.20generic-entry-api/near/276616429\">said</a>:</p>\n<blockquote>\n<p>I’ve been looking around for some info on this EntryRef api. Does anyone have an RFC link? Or any links to discussions?</p>\n</blockquote>\n<p><code>hashbrown</code> has it: <a href=\"https://docs.rs/hashbrown/latest/hashbrown/hash_map/enum.EntryRef.html\">https://docs.rs/hashbrown/latest/hashbrown/hash_map/enum.EntryRef.html</a></p>",
        "id": 276691981,
        "sender_full_name": "cuviper",
        "timestamp": 1648251412
    },
    {
        "content": "<p>(and quite the generic alphabet soup, <code>&lt;'a, 'b, K, Q, V, S, A&gt;</code>)</p>",
        "id": 276692019,
        "sender_full_name": "cuviper",
        "timestamp": 1648251478
    },
    {
        "content": "<p>Yeah I’m looking at hashbrown’s mechanism and it still feels off</p>",
        "id": 276692074,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251522
    },
    {
        "content": "<p>It doesn’t seem like there should be much reason to keep Q around in the entry</p>",
        "id": 276692089,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251544
    },
    {
        "content": "<p>KVSA are unavoidable cause its a hashmap</p>",
        "id": 276692099,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251563
    },
    {
        "content": "<p>Also b goes away if you don’t need to hold onto Q</p>",
        "id": 276692108,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251578
    },
    {
        "content": "<p><code>insert</code> uses <code>K: From&lt;&amp;Q&gt;</code></p>",
        "id": 276692124,
        "sender_full_name": "cuviper",
        "timestamp": 1648251590
    },
    {
        "content": "<p>Right but if you passed in a &amp;Q, you could just pass it in again at insert time</p>",
        "id": 276692188,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251626
    },
    {
        "content": "<p>Cause the lifetime will still be valid if your entry is valid</p>",
        "id": 276692197,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251640
    },
    {
        "content": "<p>And it’s a shared reference, so you can alias them</p>",
        "id": 276692212,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251658
    },
    {
        "content": "<p>Not much reason to hold onto it in the entry</p>",
        "id": 276692228,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251691
    },
    {
        "content": "<p>Maybe I’m just not being imaginative enough</p>",
        "id": 276692236,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648251700
    },
    {
        "content": "<p>I think not many types impl <code>From&lt;&amp;_&gt;</code> anyway, maybe just some <code>From&lt;&amp;str&gt;</code> and <code>From&lt;&amp;[_]&gt;</code></p>",
        "id": 276692296,
        "sender_full_name": "cuviper",
        "timestamp": 1648251733
    },
    {
        "content": "<p>I'm guessing the real reason is so you don't smuggle a totally different <code>&amp;Q</code> in its place.</p>",
        "id": 276693153,
        "sender_full_name": "cuviper",
        "timestamp": 1648252618
    },
    {
        "content": "<p>that would still be <em>memory safe</em>, but would otherwise break the map</p>",
        "id": 276693168,
        "sender_full_name": "cuviper",
        "timestamp": 1648252646
    },
    {
        "content": "<p>But that’s already possible all over the place in this api</p>",
        "id": 276693173,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252648
    },
    {
        "content": "<p>other than interior-mutable keys?</p>",
        "id": 276693196,
        "sender_full_name": "cuviper",
        "timestamp": 1648252671
    },
    {
        "content": "<p>You can get mutable references to keys</p>",
        "id": 276693252,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252685
    },
    {
        "content": "<p>I’m the collections</p>",
        "id": 276693254,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252689
    },
    {
        "content": "<p>At which point all bets are off</p>",
        "id": 276693256,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252695
    },
    {
        "content": "<p>where do you get mutable keys?</p>",
        "id": 276693265,
        "sender_full_name": "cuviper",
        "timestamp": 1648252711
    },
    {
        "content": "<p>Sorry that was the raw api.</p>",
        "id": 276693305,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252774
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.replace_entry\">https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.replace_entry</a></p>",
        "id": 276693308,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252783
    },
    {
        "content": "<p>but this does it kinda. i guess this method checks the hash?</p>",
        "id": 276693319,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252799
    },
    {
        "content": "<p>that checks hash and equality</p>",
        "id": 276693397,
        "sender_full_name": "cuviper",
        "timestamp": 1648252814
    },
    {
        "content": "<p>well the raw api certainly doesn't check<br>\n<a href=\"https://doc.rust-lang.org/std/collections/hash_map/struct.RawOccupiedEntryMut.html#method.into_key\">https://doc.rust-lang.org/std/collections/hash_map/struct.RawOccupiedEntryMut.html#method.into_key</a></p>",
        "id": 276693455,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252844
    },
    {
        "content": "<p>there are many reasons the raw api is still unstable</p>",
        "id": 276693474,
        "sender_full_name": "cuviper",
        "timestamp": 1648252877
    },
    {
        "content": "<p>indeed</p>",
        "id": 276693545,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1648252936
    },
    {
        "content": "<p>at least \"raw\" kind of indicates that something pseudo-unsafe is happening</p>",
        "id": 276693584,
        "sender_full_name": "cuviper",
        "timestamp": 1648253013
    }
]