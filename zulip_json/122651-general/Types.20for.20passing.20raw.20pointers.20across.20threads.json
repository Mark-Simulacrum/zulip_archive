[
    {
        "content": "<p>Do we have any types / APIs for passing raw pointers across threads \"less unsafely\" ?</p>\n<p>We used to have <code>core::ptr::{Unique, Shared}</code> to communicate variance, but those were replaced with <code>NonNull</code> which does not have any <code>Send</code> or <code>Sync</code> impls.</p>",
        "id": 251780036,
        "sender_full_name": "hannahE2",
        "timestamp": 1630613948
    },
    {
        "content": "<p>Do we have any documentation about this ?</p>",
        "id": 251781216,
        "sender_full_name": "hannahE2",
        "timestamp": 1630614497
    },
    {
        "content": "<p>You can create a wrapper type for the raw pointer and then implement Send for it.</p>",
        "id": 251784393,
        "sender_full_name": "bjorn3",
        "timestamp": 1630615887
    },
    {
        "content": "<p>Since I have to opt into doing this, and implementing Send and Sync is unsafe, what do I have to worry about when doing so ? </p>\n<p>I guess subtyping and variance ? Ownership? To be honest I just want to send raw pointers from a function that I implement to a different function in the same module. There is no \"API\" contract for these two functions.</p>",
        "id": 251863564,
        "sender_full_name": "hannahE2",
        "timestamp": 1630667629
    },
    {
        "content": "<p>I guess you could cast them to <code>usize</code> and back...</p>",
        "id": 251962159,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630718875
    },
    {
        "content": "<p>Please don't cast to <code>usize</code> for a reason like that. <span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> 's suggestion is much better, but it's a good question what exactly you are committing to by the <code>unsafe impl</code>. Assuming you do nothing at all with the pointers at the receiving end (or at least, not reading or writing), it's totally fine to impl Send and Sync for a wrapped pointer type. They are \"just bytes\" after all, and the lack of Send + Sync impls is really meant to be a \"think twice\" situation because you are almost certainly using the pointer for something on the receiving end...</p>\n<p>Which leads to the question: what if you are using the pointer on sending and receiving end, when can it be send? This is hard to say in general, because this basically means you are sharing resources in some way and whether the data structure you are implementing can handle the resource sharing pattern. The types in <code>std::sync</code> implement different kinds of sharing strategies with different properties.</p>\n<p><span class=\"user-mention\" data-user-id=\"409057\">@hannahE2</span></p>",
        "id": 251985613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630745789
    },
    {
        "content": "<blockquote>\n<p>hat if you are using the pointer on sending and receiving end, when can it be send? This is hard to say in general, </p>\n</blockquote>\n<p>I'm using the pointers in the receiving end to read and write through them using multiple threads</p>",
        "id": 252148430,
        "sender_full_name": "hannahE2",
        "timestamp": 1630919646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"409057\">@hannahE2</span>  I expected as much. Unfortunately, without more information about how the accesses are coordinated that's just plain <del>unsafe</del> <em>unsound</em>, and will cause data races and corruption if you are unlucky</p>",
        "id": 252182077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630937948
    },
    {
        "content": "<blockquote>\n<p>I expected as much. Unfortunately, without more information about how the accesses are coordinated that's just plain unsafe unsound,</p>\n</blockquote>\n<p>That's only unsound if the accesses cause a data-race but my program does not have data races.</p>",
        "id": 252183878,
        "sender_full_name": "hannahE2",
        "timestamp": 1630938806
    },
    {
        "content": "<p>Right, so why doesn't your access pattern cause data races?</p>",
        "id": 252183926,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630938834
    },
    {
        "content": "<p>what property of the access pattern ensures that this is impossible?</p>",
        "id": 252184001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630938850
    },
    {
        "content": "<p>The barriers and mutexes i have in between.</p>",
        "id": 252184050,
        "sender_full_name": "hannahE2",
        "timestamp": 1630938876
    },
    {
        "content": "<p>These are recycled for the different groups of pointers I have.</p>",
        "id": 252184064,
        "sender_full_name": "hannahE2",
        "timestamp": 1630938890
    },
    {
        "content": "<p>And it does not have data-races because my theorem prover says it doesn't.</p>",
        "id": 252184121,
        "sender_full_name": "hannahE2",
        "timestamp": 1630938916
    },
    {
        "content": "<p>It says that the way I am doing synchronization is sound.</p>",
        "id": 252184183,
        "sender_full_name": "hannahE2",
        "timestamp": 1630938937
    },
    {
        "content": "<p>It's probably still not going to be a safe interface, but you can put the barriers and the pointers behind newtypes and make it required to have the barrier to access the pointer</p>",
        "id": 252184321,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630938998
    },
    {
        "content": "<p>For a safe interface you might be able to use some trick like <code>GhostCell</code></p>",
        "id": 252184377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939029
    },
    {
        "content": "<p>having some cut down API will at least make it clear where you are relying on the safety properties</p>",
        "id": 252184547,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939088
    },
    {
        "content": "<p>and then you can <code>unsafe impl Send</code> and/or <code>Sync</code> on the wrapper</p>",
        "id": 252184586,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939109
    },
    {
        "content": "<blockquote>\n<p>It's probably still not going to be a safe interface</p>\n</blockquote>\n<p>This is all unsafe code</p>",
        "id": 252184630,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939133
    },
    {
        "content": "<p>I don't want a safe interface here</p>",
        "id": 252184650,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939141
    },
    {
        "content": "<p>I have unsafe code that launches threads that execute unsafe functions</p>",
        "id": 252184677,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939151
    },
    {
        "content": "<p>I mean that the user still has proof obligations</p>",
        "id": 252184698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939166
    },
    {
        "content": "<p>and I can't pass raw pointers to these threads, so I am trying to figure out what to pass instead</p>",
        "id": 252184720,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939177
    },
    {
        "content": "<p>even though the unsafety is \"encapsulated\"</p>",
        "id": 252184730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939184
    },
    {
        "content": "<p>no, that's wrong, a safe API has no proof obligations</p>",
        "id": 252184783,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939203
    },
    {
        "content": "<p>because, for instance, you could use the wrong mutex to lock a pointer access</p>",
        "id": 252184815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939212
    },
    {
        "content": "<p>right, but these are unsafe APIs</p>",
        "id": 252184838,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939225
    },
    {
        "content": "<p>right, that's why I say it wouldn't be a safe API</p>",
        "id": 252184856,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939232
    },
    {
        "content": "<p>and the proof obligations are uphold</p>",
        "id": 252184862,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939236
    },
    {
        "content": "<p>the proof obligations are \"you can either read/write to one element behind this pointer, as long as no other thread reads/writes to it,  or read to all of them as long as no thread writes, across each barrier phase\"</p>",
        "id": 252184974,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939292
    },
    {
        "content": "<p>and at each barrier phase, each thread can decide to write to a different element, as long as that's upheld, because the barrier synchronizes-with</p>",
        "id": 252185143,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939360
    },
    {
        "content": "<p>the barrier is not part of the pointer, cause there are many and the only thing that matters is that one is used consistently for each phase</p>",
        "id": 252185206,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939388
    },
    {
        "content": "<p>That sounds like it could be a safe interface, if you make \"barrier phase for reading\" and \"barrier phase for reading/writing\" ZSTs</p>",
        "id": 252185213,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939392
    },
    {
        "content": "<p>it could, but i don' know of a primitve that exposes this to users without including a huge performance cost</p>",
        "id": 252185264,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939419
    },
    {
        "content": "<p>so it's a token that you use to access the pointer</p>",
        "id": 252185273,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939422
    },
    {
        "content": "<p>the token changes dynamically, but it must have zero runtime size</p>",
        "id": 252185300,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939438
    },
    {
        "content": "<p>i don't know how to express that</p>",
        "id": 252185360,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939449
    },
    {
        "content": "<p>That's what ZSTs are for</p>",
        "id": 252185370,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939457
    },
    {
        "content": "<p>ZSTs only have one value</p>",
        "id": 252185403,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939472
    },
    {
        "content": "<p>Not ZST's with phantom data</p>",
        "id": 252185425,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939487
    },
    {
        "content": "<p>they can carry lifetime arguments</p>",
        "id": 252185445,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939500
    },
    {
        "content": "<p>different lifetime makes them different types by definition</p>",
        "id": 252185475,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939514
    },
    {
        "content": "<p>a lifetime kind is a \"kind\"</p>",
        "id": 252185493,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939521
    },
    {
        "content": "<p>plus, even if they only have one value they can still be unforgeable</p>",
        "id": 252185516,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939531
    },
    {
        "content": "<p>you can make them not copy</p>",
        "id": 252185563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939549
    },
    {
        "content": "<p>this is all useless and you are not helping</p>",
        "id": 252185576,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939557
    },
    {
        "content": "<p>i can't even do this with unsafe code, and your answer is \"build a safe abstraction on top of ????\" instead</p>",
        "id": 252185654,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939574
    },
    {
        "content": "<p>what's <code>????</code> here?</p>",
        "id": 252185695,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939593
    },
    {
        "content": "<p>If you don't care about safety, just <code>unsafe impl Send for MyWrapper</code> and call it a day</p>",
        "id": 252185703,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939596
    },
    {
        "content": "<p>the docs need to be more clear about this, they strongly suggest that there are other invariants to uphold</p>",
        "id": 252185812,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939641
    },
    {
        "content": "<p>There are, but you don't want to talk about them</p>",
        "id": 252185843,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939654
    },
    {
        "content": "<p>what are those ?</p>",
        "id": 252185859,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939662
    },
    {
        "content": "<p>You shouldn't cause data races by mutating shared state</p>",
        "id": 252185901,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939681
    },
    {
        "content": "<p>I think you know this already though</p>",
        "id": 252185948,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939687
    },
    {
        "content": "<p>the passing of pointers itself is safe, it is the subsequent use that is not</p>",
        "id": 252185985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939707
    },
    {
        "content": "<p>that invariant is already ensured by the <code>unsafe</code> required to dereference a raw pointer</p>",
        "id": 252186000,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939716
    },
    {
        "content": "<p>not sure what <code>Send</code> has to do with this, and why the docs suggest using wrappers with more semantic meaning like the old <code>ptr::{Unique, Shared}</code>, and what one has to take care about here</p>",
        "id": 252186095,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939754
    },
    {
        "content": "<p>for all these wrapper pointer types, the dereference is still <code>unsafe { *ptr }</code></p>",
        "id": 252186140,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939776
    },
    {
        "content": "<p>And, as mentioned in an earlier thread, the reason <code>*const T</code> is not marked Send or Sync is because doing what you are doing would normally result in unsound code</p>",
        "id": 252186146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939778
    },
    {
        "content": "<p>I don't think that's possible, i am pretty sure that requires using <code>unsafe</code> to dereference the raw pointers</p>",
        "id": 252186274,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939821
    },
    {
        "content": "<p>you have to pay close attention to the invariants to make sure you don't slip up. If you are doing that, then good, have a stamp of approval and <code>unsafe impl</code></p>",
        "id": 252186277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939823
    },
    {
        "content": "<p>You can use a wrapper called <code>Shared</code> or <code>Unique</code> that tries to emulate some variance, and then still screw everything up when doing the <code>unsafe { *ptr }</code> dereference</p>",
        "id": 252186361,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939865
    },
    {
        "content": "<p>so I am really having a lot of trouble understanding what these wrappers need to account for</p>",
        "id": 252186414,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939888
    },
    {
        "content": "<p>It would be technically correct for <code>*const T</code> and <code>*mut T</code> to impl Send and Sync, because of the reasons you have already said</p>",
        "id": 252186540,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939926
    },
    {
        "content": "<p>it is not so because this is a footgun</p>",
        "id": 252186563,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939934
    },
    {
        "content": "<p>and auto traits</p>",
        "id": 252186581,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939943
    },
    {
        "content": "<p>but why do i need to handle variance in any way what so ever when writing a wrapper ?</p>",
        "id": 252186617,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939959
    },
    {
        "content": "<p>or why do people care about the variance of these wrappers ?</p>",
        "id": 252186657,
        "sender_full_name": "hannahE2",
        "timestamp": 1630939975
    },
    {
        "content": "<p>because the variance of your type affects the variance of their type</p>",
        "id": 252186688,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630939991
    },
    {
        "content": "<p>so it is just in case they want to use my type as their field ?</p>",
        "id": 252186741,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940012
    },
    {
        "content": "<p>my type is private, so that can't happen, so any wrapper would do for me then i think</p>",
        "id": 252186780,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940028
    },
    {
        "content": "<p>If your <code>MyWrapper&lt;T&gt;</code> type is invariant in <code>T</code>, then if they have some bigger <code>Foo&lt;T&gt;</code> containing a <code>MyWrapper&lt;T&gt;</code> then <code>Foo&lt;T&gt;</code> will also be invariant in <code>T</code></p>",
        "id": 252186791,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940033
    },
    {
        "content": "<p>ok this makes sense</p>",
        "id": 252186867,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940051
    },
    {
        "content": "<p>i think it would make sense to update the nomicon with this info</p>",
        "id": 252186891,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940061
    },
    {
        "content": "<p>i was superconfused about what exactly these wrapper types need to upheld</p>",
        "id": 252186957,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940082
    },
    {
        "content": "<p>Unfortunately I don't think there is a <code>struct MyWrapper&lt;#[unsafe covariant] T&gt;</code> syntax</p>",
        "id": 252187037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940110
    },
    {
        "content": "<p>so you have to use one of the library types if you want a different variance</p>",
        "id": 252187089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940139
    },
    {
        "content": "<p><code>struct S&lt;T&gt;(*const T)</code> is covariant in <code>T</code></p>",
        "id": 252187185,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940170
    },
    {
        "content": "<p>if I want a different variance, I can just use <code>PhantomData</code> with a particular type that implies that variance I guess</p>",
        "id": 252187249,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940201
    },
    {
        "content": "<p>Yes, you could have <code>struct S&lt;T&gt;(*const (), PhantomData&lt;fn(T)&gt;)</code> or something if you want a contravariant pointer</p>",
        "id": 252187351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940237
    },
    {
        "content": "<p>yes</p>",
        "id": 252187390,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940254
    },
    {
        "content": "<p>what i am not sure of is how variance relates here to <code>Unique</code>/<code>Shared</code> , it does not look to me that they relate at all</p>",
        "id": 252187495,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940284
    },
    {
        "content": "<p>maybe <code>unique</code> / <code>shared</code> are just \"nullable\" <code>&amp;mut T</code>, <code>&amp;T</code> ?! (from this POV it would make sense for them to have the same variance)</p>",
        "id": 252187568,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940320
    },
    {
        "content": "<p>but have the same permissions otherwise ?</p>",
        "id": 252187584,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Types.20for.20passing.20raw.20pointers.20across.20threads/near/252187568\">said</a>:</p>\n<blockquote>\n<p>maybe <code>unique</code> / <code>shared</code> are just \"nullable\" <code>&amp;mut T</code>, <code>&amp;T</code> ?! (from this POV it would make sense for them to have the same variance)</p>\n</blockquote>\n<p>Well no, they are just as unsafe as pointers</p>",
        "id": 252187673,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940375
    },
    {
        "content": "<p>also <code>Unique</code> is not nullable, it has a niche that you can use with <code>Option</code></p>",
        "id": 252187774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940406
    },
    {
        "content": "<p>that sounds like <code>NonNull</code>, how does <code>Unique</code> differ from it ?</p>",
        "id": 252187894,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940438
    },
    {
        "content": "<p><code>Unique&lt;T&gt;</code> is defined as <code>struct Unique&lt;T&gt;(NonNull&lt;T&gt;, PhantomData&lt;T&gt;)</code></p>",
        "id": 252188128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940525
    },
    {
        "content": "<p>so it has the same variance as <code>T</code></p>",
        "id": 252188190,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940562
    },
    {
        "content": "<p>the comment says the phantom data is there to deal with dropck, which also looks at struct definitions</p>",
        "id": 252188204,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940568
    },
    {
        "content": "<p>what's the variance of <code>NonNull&lt;T&gt;</code> over <code>T</code>?</p>",
        "id": 252188233,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940580
    },
    {
        "content": "<p>both are covarinat</p>",
        "id": 252188247,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940587
    },
    {
        "content": "<p>i need to read about <code>dropck</code></p>",
        "id": 252188306,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940618
    },
    {
        "content": "<p>I think it has to do with being able to drop a <code>Box&lt;Foo&lt;'a&gt;&gt;</code> where <code>'a</code> is already expired at the point of the box destructor</p>",
        "id": 252188538,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940711
    },
    {
        "content": "<p>so the <code>drop</code> impl has to not touch any <code>Foo&lt;'a&gt;</code> instances because they are invalid</p>",
        "id": 252188637,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940759
    },
    {
        "content": "<p>hm</p>",
        "id": 252188704,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940774
    },
    {
        "content": "<p>There is some mechanism for automatically inferring when this happens, and a <code>dropck_eyepatch</code> to fix the cases where it gets the wrong answer</p>",
        "id": 252188741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940796
    },
    {
        "content": "<p>do you know if there is a good intro to this?</p>",
        "id": 252188791,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940822
    },
    {
        "content": "<p>I'll check in the nomicon, but hopefully there is something gentler</p>",
        "id": 252188807,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940833
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nomicon/dropck.html#an-escape-hatch\">https://doc.rust-lang.org/nomicon/dropck.html#an-escape-hatch</a> is that what you mean?</p>",
        "id": 252188873,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940868
    },
    {
        "content": "<p>Yes</p>",
        "id": 252188884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940873
    },
    {
        "content": "<p>ok i have not read that yet, thanks, maybe that clarifies all of this</p>",
        "id": 252188963,
        "sender_full_name": "hannahE2",
        "timestamp": 1630940895
    },
    {
        "content": "<p>If you like videos I also suggest this one: <a href=\"https://www.youtube.com/watch?v=TJOFSMpJdzg\">https://www.youtube.com/watch?v=TJOFSMpJdzg</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"TJOFSMpJdzg\" href=\"https://www.youtube.com/watch?v=TJOFSMpJdzg\"><img src=\"https://uploads.zulipusercontent.net/589e35b876ad27163232055f703d4d3634eb00cd/68747470733a2f2f692e7974696d672e636f6d2f76692f544a4f46534d704a647a672f64656661756c742e6a7067\"></a></div>",
        "id": 252189037,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630940938
    },
    {
        "content": "<p>thanks!</p>",
        "id": 252189662,
        "sender_full_name": "hannahE2",
        "timestamp": 1630941240
    }
]