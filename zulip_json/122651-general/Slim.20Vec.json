[
    {
        "content": "<p><code>Vec</code> is three words: len, capacity, and a (possibly null) pointer to the heap-allocated elements.<br>\nAn alternative arrangement would be a single word, that is a possibly null pointer to a heap-allocated trio of (len, capacity, elements).<br>\nThis is potentially beneficial if you need a vector within a struct that you want to be as small as possible. (<code>rustc_ast::ast::Path</code>'s <code>segments</code> field is my motivation here.)<br>\nAnyone know if such a type has been implemented?</p>",
        "id": 262020419,
        "sender_full_name": "nnethercote",
        "timestamp": 1637289352
    },
    {
        "content": "<p>(I do know about <code>ThinVec</code> within rustc: <code>struct ThinVec&lt;T&gt;(Option&lt;Box&lt;Vec&lt;T&gt;&gt;&gt;);</code></p>",
        "id": 262020484,
        "sender_full_name": "nnethercote",
        "timestamp": 1637289420
    },
    {
        "content": "<p>It is also just a single word, but if you have a non-zero number of elements it requires two allocations, so it's best for cases where zero elements is the common case.)</p>",
        "id": 262020499,
        "sender_full_name": "nnethercote",
        "timestamp": 1637289453
    },
    {
        "content": "<p>There's a PR for ThinBox&lt;Dyn&gt; <a href=\"https://github.com/rust-lang/rust/issues/90066\">#90066</a> which could also store slices.</p>",
        "id": 262020582,
        "sender_full_name": "The 8472",
        "timestamp": 1637289588
    },
    {
        "content": "<p>Would that allow the vec to grow and shrink if needed?</p>",
        "id": 262020649,
        "sender_full_name": "nnethercote",
        "timestamp": 1637289657
    },
    {
        "content": "<p>(Similarly, a boxed slice gets you down to two elements, which is an improvement, but isn't suitable if the number of elements can change)</p>",
        "id": 262020726,
        "sender_full_name": "nnethercote",
        "timestamp": 1637289747
    },
    {
        "content": "<p>I think you could put this inside the ThinBox</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">DstVec</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">len</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">elements</span>: <span class=\"p\">[</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the dyn metadata would carry the capacity and the field the length.</p>",
        "id": 262020847,
        "sender_full_name": "The 8472",
        "timestamp": 1637289896
    },
    {
        "content": "<p>Not 100% sure if it would work since that's combining a bunch of exotic features.</p>",
        "id": 262020873,
        "sender_full_name": "The 8472",
        "timestamp": 1637289953
    },
    {
        "content": "<p>Might be easier just to implement what I described directly <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  It would subsume <code>ThinVec</code></p>",
        "id": 262020967,
        "sender_full_name": "nnethercote",
        "timestamp": 1637290061
    },
    {
        "content": "<p>the downside compared to thinvec is that converting it to a proper vec would be expensive in the general case. you could get lucky where the cap/length can be reinterpreted as some extra capacity.</p>",
        "id": 262021174,
        "sender_full_name": "The 8472",
        "timestamp": 1637290328
    },
    {
        "content": "<p>but even then it'd require moving stuff to the front</p>",
        "id": 262021182,
        "sender_full_name": "The 8472",
        "timestamp": 1637290361
    },
    {
        "content": "<p>hrrm, maybe not if you'd point to the end of the struct, then cap/len could sit at the end and be reinterpreted.</p>",
        "id": 262021221,
        "sender_full_name": "The 8472",
        "timestamp": 1637290438
    },
    {
        "content": "<p>and with some extra padding... yeah... this could work</p>",
        "id": 262021268,
        "sender_full_name": "The 8472",
        "timestamp": 1637290491
    },
    {
        "content": "<p>At least for the <code>Path</code> case, conversion to/from <code>Vec</code> isn't common</p>",
        "id": 262021359,
        "sender_full_name": "nnethercote",
        "timestamp": 1637290624
    },
    {
        "content": "<p>if you have free conversion from/to vec then you can delegate IntoIterator and FromIterator to the Vec impls which are quite optimized.</p>",
        "id": 262021423,
        "sender_full_name": "The 8472",
        "timestamp": 1637290686
    },
    {
        "content": "<p>There's a <code>thin_vec</code> crate,  have you seen that one? It seems to be implemented that way.</p>",
        "id": 262056058,
        "sender_full_name": "panstromek",
        "timestamp": 1637322187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/Slim.20Vec/near/262021221\">said</a>:</p>\n<blockquote>\n<p>hrrm, maybe not if you'd point to the end of the struct, then cap/len could sit at the end and be reinterpreted.</p>\n</blockquote>\n<p>This seems like fun thing to try to implement. I tried to play around with it for a while and into_vec is pretty simple to do, but from_vec has quite a few edge cases, based on the alignment and how much eccesive capacity does the original vec have. In the worst case it has to relocate anyway.</p>",
        "id": 262062573,
        "sender_full_name": "panstromek",
        "timestamp": 1637326662
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Seems like a good idea to me. If you're going to have an indirection anyway, though, it might make sense to store the elements inline at the destination, to avoid a second indirection.</p>",
        "id": 262106787,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637345919
    },
    {
        "content": "<p>len, capacity, elem0, elem1, ...</p>",
        "id": 262106839,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637345943
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"208862\">panstromek</span> <a href=\"#narrow/stream/122651-general/topic/Slim.20Vec/near/262062573\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/Slim.20Vec/near/262021221\">said</a>:</p>\n<blockquote>\n<p>hrrm, maybe not if you'd point to the end of the struct, then cap/len could sit at the end and be reinterpreted.</p>\n</blockquote>\n<p>This seems like fun thing to try to implement. I tried to play around with it for a while and into_vec is pretty simple to do, but from_vec has quite a few edge cases, based on the alignment and how much eccesive capacity does the original vec have. In the worst case it has to relocate anyway.</p>\n</blockquote>\n<p>Storing cap/length in an unaligned manner could get us a bit further. But that performance tradeoff may not be worth it.</p>",
        "id": 262115124,
        "sender_full_name": "The 8472",
        "timestamp": 1637349359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I think what you described is exactly what I was intending. A non-empty SlimVec would have a single heap allocation</p>",
        "id": 262138564,
        "sender_full_name": "nnethercote",
        "timestamp": 1637360424
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120989\">@nnethercote</span> Ah, I misunderstood then. When you said <code>(len, capacity, elements)</code>, I thought <code>elements</code> was a pointer.</p>",
        "id": 262140230,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637361273
    }
]