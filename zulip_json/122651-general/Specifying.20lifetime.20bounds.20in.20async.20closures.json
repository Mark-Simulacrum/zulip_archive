[
    {
        "content": "<p>Is there a way to specify lifetime bounds on the future returned by a closure in a function generic bounds? Like <code>async fn foo&lt;F&gt;(cb: F) where F: for&lt;'a&gt; FnMut(&amp;'a u32) -&gt; (impl Future + 'a)</code>?</p>\n<p>I've ran into this issue pretty much every time I've tried doing stuff with async for one reason or another, and it's driving me mad. All the workarounds I can find either require boxing or destroy the ergonomics.</p>",
        "id": 274756021,
        "sender_full_name": "Alex Parrill",
        "timestamp": 1646861889
    },
    {
        "content": "<p>The only way I know is a hack like <a href=\"https://gist.github.com/tl-marco-cameriero/5cc6d21b64f892b9fb32fa41085dfe7a#file-hrtb-rs-L39\">https://gist.github.com/tl-marco-cameriero/5cc6d21b64f892b9fb32fa41085dfe7a#file-hrtb-rs-L39</a></p>",
        "id": 274756420,
        "sender_full_name": "Conrad Ludgate",
        "timestamp": 1646862120
    },
    {
        "content": "<p>I'm aware of using a trait, but it unfortunately does not work very for FnMut closures due to <a href=\"https://github.com/rust-lang/rust/issues/70263\">https://github.com/rust-lang/rust/issues/70263</a>.</p>\n<p>There's the higher_order_closure crate/macro that helps but... ugh. I keep hitting this issue and I'm surprised it's not talked about more.</p>",
        "id": 274757107,
        "sender_full_name": "Alex Parrill",
        "timestamp": 1646862499
    },
    {
        "content": "<p>I mentioned this thread over in <a class=\"stream\" data-stream-id=\"187312\" href=\"/#narrow/stream/187312-wg-async\">#wg-async</a>. Unfortunately I don't have a great solution that I can come up with right now, but this feels like the kind of problem wg-async is interested in solving.</p>",
        "id": 274758812,
        "sender_full_name": "eholk",
        "timestamp": 1646863381
    },
    {
        "content": "<p>Cool. Yeah, that's probably a better place for it. Didn't realize there were more channels with Zulip's interface.</p>",
        "id": 274759075,
        "sender_full_name": "Alex Parrill",
        "timestamp": 1646863526
    },
    {
        "content": "<p>Yeah :) There are quite a few. More than any one person could read...</p>",
        "id": 274759144,
        "sender_full_name": "eholk",
        "timestamp": 1646863562
    },
    {
        "content": "<p>Pedantically note that isn't an \"async closure\" (<code>async || {}</code>) but a synchronous closure that returns an async value (<code>|| async {}</code>). I can never recall the benefit of the first over the second, however.</p>",
        "id": 274886386,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646941772
    },
    {
        "content": "<p>Maybe it only matter if you want to put a return type, like <code>async || -&gt; i32 { ... }</code>?</p>",
        "id": 274886667,
        "sender_full_name": "scottmcm",
        "timestamp": 1646941928
    },
    {
        "content": "<p>The second also requires <code>{}</code>, while the first does not</p>",
        "id": 274926632,
        "sender_full_name": "Jake",
        "timestamp": 1646967984
    },
    {
        "content": "<p>I'd personally say that proper future-may-borrow-from-higher-order-input-args bounds would be the main advantage of the dedicated <code>async || …</code> syntax, without having to worry about retro-compatibility with current lifetime signature inference of <code>|| async …</code></p>",
        "id": 274988349,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1647011697
    },
    {
        "content": "<p>The last time I tried to simulate something like this I chalked it up to <a href=\"https://github.com/rust-lang/rust/issues/84937\">#84937</a>, which has since been closed by <span class=\"user-mention\" data-user-id=\"232957\">@Jack Huey</span> implementing lazy normalization. I think that could have removed the fundamental type checker obstacles, and now what you lack is really just a way to spell it.</p>",
        "id": 275332339,
        "sender_full_name": "tmandry",
        "timestamp": 1647323458
    },
    {
        "content": "<p>Just fyi, it wasn't lazy normalization that fixed that. In fact, it was kind of the opposite: \"more\"  normalization</p>",
        "id": 275389193,
        "sender_full_name": "Jack Huey",
        "timestamp": 1647358390
    }
]