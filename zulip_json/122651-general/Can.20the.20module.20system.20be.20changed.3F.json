[
    {
        "content": "<p>Is it possible for the development  team to change the module system? The current module system isn't very intuitive and is a bad programming paradigm.</p>",
        "id": 264304996,
        "sender_full_name": "Arun Kumar",
        "timestamp": 1639058519
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459117\">@Arun Kumar</span> what concrete changes would make it easier to learn or use? It's not <em>impossible</em> to change but it's a very large task, it has to wait for an edition and it gives an impression of instability because people have to learn the new system.</p>",
        "id": 264306597,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1639059177
    },
    {
        "content": "<p>implement the module system as a key value pair. Where key is the module name with which we can access with respect to crate. Th key should be the module name and value should be the path to the file.</p>\n<p>Under the hood we should be process this key-value pair to build  the file into <br>\n modules</p>",
        "id": 264306867,
        "sender_full_name": "Arun Kumar",
        "timestamp": 1639059293
    },
    {
        "content": "<p>You mean, making <code>#[path = \"...\"]</code> mandatory? That seems a lot of boilerplate - you can already use it today if you find the current system confusing</p>",
        "id": 264307141,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1639059402
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>[\n{name: &quot;my_module1&quot;, path:&quot;/path/to/thefile1&quot;},\n{name: &quot;my_module2&quot;, path:&quot;/path/to/thefile2&quot;}\n{name: &quot;my_module3&quot;, path:&quot;/path/to/thefile3&quot;}\n]\n</code></pre></div>\n<p>use the above description to build the modules and we access the those modules using the <code>  use crate::my_module1::my_function</code> syntax</p>",
        "id": 264307262,
        "sender_full_name": "Arun Kumar",
        "timestamp": 1639059464
    },
    {
        "content": "<p>or we declare the module definition in cargo.toml file and during build time it auto builds based on that definition in the cargo.toml file</p>",
        "id": 264307472,
        "sender_full_name": "Arun Kumar",
        "timestamp": 1639059547
    },
    {
        "content": "<p>Do away with the mod key word. File is anyway the right abstraction for modules.</p>",
        "id": 264307712,
        "sender_full_name": "Arun Kumar",
        "timestamp": 1639059661
    },
    {
        "content": "<p>Yeah, that's too large a change to reasonably be made</p>",
        "id": 264307799,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1639059709
    },
    {
        "content": "<p>Keep in mind that what seems like the \"obvious right abstraction\" to you, might be  less obvious for other users of the language. There are scenarios like macro- or build script-generated modules, which might be harder to achieve with your approach. Also, listing every file in <code>Cargo.toml</code>, or potentially having <code>mod b</code> in <code>a.rs</code> and <code>mod a</code> in <code>b.rs</code> is not great.</p>",
        "id": 264308919,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639060188
    },
    {
        "content": "<p>But crates work similarly to what you're proposing (at a different granularity, of course), so maybe you actually want a Cargo workspace.</p>",
        "id": 264309106,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639060252
    },
    {
        "content": "<p>Let me check Cargo workspace</p>",
        "id": 264310799,
        "sender_full_name": "Arun Kumar",
        "timestamp": 1639060970
    },
    {
        "content": "<p>Why do you think the current state is a bad programming paradigm?</p>",
        "id": 264332320,
        "sender_full_name": "fee1-dead",
        "timestamp": 1639069565
    },
    {
        "content": "<blockquote>\n<p>Do away with the mod key word.</p>\n</blockquote>\n<p>This breaks stability guarantees so it's a non-starter.</p>\n<blockquote>\n<p>File is anyway the right abstraction for modules.</p>\n</blockquote>\n<p>As someone who has written a fair amount of Rust, I disagree.</p>",
        "id": 264336792,
        "sender_full_name": "Jubilee",
        "timestamp": 1639071292
    },
    {
        "content": "<p>It's the other way around. Modules are an abstraction that happens to also enable using external files easily.</p>",
        "id": 264337052,
        "sender_full_name": "Jubilee",
        "timestamp": 1639071395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"459117\">@Arun Kumar</span> The module system was tweaked for the 2018 edition.  More changes are not impossible, but before proposing any concrete changes I'd suggest that you read the history of that.  Many things were discussed, including the possibility of having <code>foo.rs</code> get compiled even without <code>mod foo;</code>.  So unless the material facts have changed, I don't see a different outcome as likely.</p>",
        "id": 264353226,
        "sender_full_name": "scottmcm",
        "timestamp": 1639077828
    },
    {
        "content": "<p>From a Rust teacher's perspective, the module system _is_ divisive. 50% of people have no major issues with it, 50% do. It's a matter of how your brain is structured.</p>\n<p>My hypothesis is that it's all about which language(s) you learned \"module systems\" with first.</p>",
        "id": 264353420,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1639077936
    },
    {
        "content": "<p>so for every person who hates it, there's another that enjoys (or at least tolerates) it. I count myself in that group.</p>",
        "id": 264353529,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1639077974
    },
    {
        "content": "<p>I had trouble with modules at first because I didn't realize <code>mod</code> and <code>use</code> did different things</p>",
        "id": 264353544,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1639077985
    },
    {
        "content": "<p>once I figured that out it wasn't too hard</p>",
        "id": 264353554,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1639077990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Can.20the.20module.20system.20be.20changed.3F/near/264353420\">said</a>:</p>\n<blockquote>\n<p>My hypothesis is that it's all about which language(s) you learned \"module systems\" with first.</p>\n</blockquote>\n<p>Interesting. Personally my experience is that it depends on which problem you're trying to solve first. If it's \"I want to modularize my API\" then you'll do well, if it's \"my file's getting too big\" you might be in for disappointment</p>",
        "id": 264354581,
        "sender_full_name": "Jake",
        "timestamp": 1639078515
    },
    {
        "content": "<p>Yeah, if someone's been taught \"different types go in different files\" in previous languages, they're unlikely to intuit the <code>mod foo; pub use foo::*;</code> dance.</p>\n<p>Whereas if you show up trying to introduce privacy boundaries, you'll be pretty happy with it.</p>",
        "id": 264356534,
        "sender_full_name": "scottmcm",
        "timestamp": 1639079394
    },
    {
        "content": "<p>The only time i care about modules is when the file gets too big and the module system of rust suits me perfectly so I'm not sure I follow you <span class=\"user-mention\" data-user-id=\"310518\">@Jake</span></p>",
        "id": 264362959,
        "sender_full_name": "Lokathor",
        "timestamp": 1639082393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Can.20the.20module.20system.20be.20changed.3F/near/264353420\">said</a>:</p>\n<blockquote>\n<p>From a Rust teacher's perspective, the module system _is_ divisive. 50% of people have no major issues with it, 50% do. It's a matter of how your brain is structured.</p>\n<p>My hypothesis is that it's all about which language(s) you learned \"module systems\" with first.</p>\n</blockquote>\n<p>Yeah, this is why I tried to underscore that I feel Rust's system is somewhat better for the problems Rust aims to solve, and... prooobably less great for a lot of other things.</p>\n<p>imo it feels intuitive <strong>enough</strong> to me now, but I do remember fighting with it for a week until I was able to slot it in. But I come from a... highly... uh... <strong>unstructured</strong> language (YavaScript... we got both ESM and CJS, and tbh both have fairly weirdly specific and verbose exports/imports too, tbh).</p>",
        "id": 264365970,
        "sender_full_name": "Jubilee",
        "timestamp": 1639083861
    },
    {
        "content": "<p>Once I realized that the <code>mod</code> and <code>use</code> dance  is like perfectly designed for composing with attributes like <code>#[cfg]</code> and thus having a bunch of conditionally compiled modules in a file, and thus slots <strong>very</strong> nicely in where a bunch of C's ifdefs would go, it suddenly made sense.</p>",
        "id": 264366287,
        "sender_full_name": "Jubilee",
        "timestamp": 1639083996
    },
    {
        "content": "<p>I do <em>personally</em> think we might be better off if Rust just automatically picked up all <code>.rs</code> files as modules without requiring <code>mod</code>, at the expense of making it a little more complex to do complex <code>cfg</code> dances around modules. But I also think I'm hesitant to have more churn in this area.</p>",
        "id": 264370067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639085792
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/122651-general/topic/Can.20the.20module.20system.20be.20changed.3F/near/264362959\">said</a>:</p>\n<blockquote>\n<p>The only time i care about modules is when the file gets too big and the module system of rust suits me perfectly so I'm not sure I follow you <span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span></p>\n</blockquote>\n<p>I don't mean to imply that the module system does a bad job of this, it's perfectly up to the task, what I mean instead is that it's design is clearly not primarily designed as a solution to this problem.</p>\n<p>For example, say someone just wants to split their one source file up into two: They now have to do three different things, depending on where they are. In <code>mymod.rs</code> they have to put <code>mod submod;</code> and <code>use submod::*;</code>, in <code>submod.rs</code> they have to do nothing, and everywhere else they need to do <code>use mymod::*;</code> (or some variations of this, but you get the point). This is cofusing and complicated at first because its not really clear how the solution maps naturally to the problem, but once you realize that actually you're just defining a namespace, everything is sort of obvious. On the other hand, if you actually walk in going \"hey, I want to namespace a part of my API\" the solution is a super easy: \"put things behind a <code>mod</code>\".</p>\n<p>Other languages do this differently. For example, in C, if you go \"hey, I'd like to split my file into two.\" The solution is to write a header file, and then <code>#include</code> it everywhere you need it. This is much more \"uniform\" a solution for this problem than Rust's. On the other hand, if you want to namespace stuff, uhhh... good luck with that.</p>\n<p>Now of course <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> could just be right, that this is basically equivalent to a language difference, ie the problem you run into is the one you're used to solving in the language you come from</p>",
        "id": 264371219,
        "sender_full_name": "Jake",
        "timestamp": 1639086350
    },
    {
        "content": "<p>Well, if all you wanted is to split the source file you could use <code>include!()</code> <span aria-label=\"see no evil\" class=\"emoji emoji-1f648\" role=\"img\" title=\"see no evil\">:see_no_evil:</span></p>",
        "id": 264371880,
        "sender_full_name": "The 8472",
        "timestamp": 1639086651
    },
    {
        "content": "<p>So what I do is:</p>\n<ul>\n<li>cut out a portion of <code>mymod.rs</code>, put that into <code>submod.rs</code></li>\n<li>also put <code>use super::*;</code> in <code>submod.rs</code></li>\n<li>add <code>mod submod; pub use submod::*;</code> to <code>mymod.rs</code>.</li>\n</ul>\n<p>and the rest of the world doesn't notice the difference at all.</p>\n<p>which isn't to say i never use modules for other reasons, such as the occasional feature gates and rustdoc organization, but in terms of keeping files from getting too large the workflow is quite quick and painless.</p>\n<p>though, yeah, it's non-obvious to learn this the first time you learn it. but you can put it in a book or whatever and people can just learn the trick.</p>",
        "id": 264373415,
        "sender_full_name": "Lokathor",
        "timestamp": 1639087353
    },
    {
        "content": "<p>Maybe this could be put in Rust by Example</p>",
        "id": 264373620,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1639087398
    },
    {
        "content": "<p>I also had to figure out this pattern</p>",
        "id": 264373674,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1639087425
    },
    {
        "content": "<p>When making a sub-module like this, it's sometimes desirable to make the sub-module be pub, but in that case you generally still <em>also</em> have the <code>use</code> globs. The fact that the sub-module is pub changes how the rustdoc renders the content though so you can (sometimes) get cleaner docs with a public module.</p>",
        "id": 264374341,
        "sender_full_name": "Lokathor",
        "timestamp": 1639087723
    },
    {
        "content": "<p>But i like very flat crate organization. I would certainly never in my life have designed <code>alloc::alloc::alloc</code> ;3c</p>",
        "id": 264374451,
        "sender_full_name": "Lokathor",
        "timestamp": 1639087794
    },
    {
        "content": "<p>While we are in the anecdotal realm, I want to point out that the module system felt very natural to me. One thing I've noticed for some people is that many examples in the book use inline modules for self-contained examples, but truth be told, and especially for people coming from other languages, inline modules can be surprising.</p>\n<p>So maybe start with clear examples with only <code>;</code>-modules, and once that has sunk in, explain that one can even just inline those in some cases. The completely opposite teaching strategy is to only start with inline modules, and then say that <code>mod name;</code> is <code>mod name { include!(\"name.rs\" or \"name/mod.rs\"); }</code>.</p>\n<p>Also, I think I've never had to deal with / or encountered a <code>;</code>-module <em>inside</em> an inline module: that could indeed be confusing.</p>",
        "id": 264375574,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639088317
    },
    {
        "content": "<p>Finally, and after some thought, I realize one thing: for the namespace / fs parallelism tobe <strong>consistent</strong> I find that only picking <code>name/mod.rs</code> files (no <code>name.rs</code> shorthand), when starting, could help quite a lot!</p>",
        "id": 264375612,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639088354
    },
    {
        "content": "<p>(and have <code>lib.rs</code> be named <code>mod.rs</code> as well)</p>",
        "id": 264375628,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639088366
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Bash\"><pre><span></span><code>src/\n  mod.rs  <span class=\"c1\"># items at the root of the crate (`crate::*`) since matched by `src/*` blob</span>\n  foo/ <span class=\"c1\"># the foo namespace</span>\n    mod.rs  <span class=\"c1\"># items at `crate::foo::*` since file matched by `src/foo/*` blob</span>\n    bar/ <span class=\"c1\"># the bar namespace</span>\n      mod.rs  <span class=\"c1\"># items at `crate::foo::bar::*` since file matched by `src/foo/bar/*` blob</span>\n</code></pre></div>",
        "id": 264375883,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639088504
    },
    {
        "content": "<p>On that note, a little while ago <a href=\"https://github.com/rust-lang/rust/commit/fc0fd9ae5d6d0c31393b773e6b36cc01cb87ccc7\">I made this</a>. Mostly as a joke. Understanding it requires you to know that Windows NTFS filesystem allows adding data to directory files. So you can have a \"<a href=\"http://foo.rs\">foo.rs</a>\" that's both a source file and a directory containing other source files. I thought it was a natural fit for Rust <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>. But obviously I'm not seriously proposing it.</p>",
        "id": 264377304,
        "sender_full_name": "Chris Denton",
        "timestamp": 1639089291
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"260325\">@Chris Denton</span> That's great. :)</p>",
        "id": 264378802,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639090038
    },
    {
        "content": "<p>Given that the module system was reworked once and opinions are still divided about whether that was a good thing, I'd be <em>very</em> wary about changing it again <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 264379415,
        "sender_full_name": "nnethercote",
        "timestamp": 1639090464
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/122651-general/topic/Can.20the.20module.20system.20be.20changed.3F/near/264377304\">said</a>:</p>\n<blockquote>\n<p>On that note, a little while ago <a href=\"https://github.com/rust-lang/rust/commit/fc0fd9ae5d6d0c31393b773e6b36cc01cb87ccc7\">I made this</a>. Mostly as a joke. Understanding it requires you to know that Windows NTFS filesystem allows adding data to directory files. So you can have a \"<a href=\"http://foo.rs\">foo.rs</a>\" that's both a source file and a directory containing other source files. I thought it was a natural fit for Rust <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>. But obviously I'm not seriously proposing it.</p>\n</blockquote>\n<p>This is simultaneously amazing and horrifying.</p>",
        "id": 264379447,
        "sender_full_name": "Jubilee",
        "timestamp": 1639090493
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/122651-general/topic/Can.20the.20module.20system.20be.20changed.3F/near/264377304\">said</a>:</p>\n<blockquote>\n<p>On that note, a little while ago <a href=\"https://github.com/rust-lang/rust/commit/fc0fd9ae5d6d0c31393b773e6b36cc01cb87ccc7\">I made this</a>. Mostly as a joke. Understanding it requires you to know that Windows NTFS filesystem allows adding data to directory files. So you can have a \"<a href=\"http://foo.rs\">foo.rs</a>\" that's both a source file and a directory containing other source files. I thought it was a natural fit for Rust <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>. But obviously I'm not seriously proposing it.</p>\n</blockquote>\n<p><span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span> More like Windows FFS filesystem</p>",
        "id": 264439006,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639138927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/122651-general/topic/Can.20the.20module.20system.20be.20changed.3F/near/264377304\">said</a>:</p>\n<blockquote>\n<p>On that note, a little while ago <a href=\"https://github.com/rust-lang/rust/commit/fc0fd9ae5d6d0c31393b773e6b36cc01cb87ccc7\">I made this</a>.</p>\n</blockquote>\n<p>Are those Alternate Data Streams? Nice!</p>",
        "id": 264468293,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639152334
    },
    {
        "content": "<p>Ah, you could do something like that with xattrs under various unixes too. But not all of them, so not a cross-platform solution yet.</p>",
        "id": 264469020,
        "sender_full_name": "The 8472",
        "timestamp": 1639152638
    },
    {
        "content": "<p>And xattrs have a much lower size limit, don't they?</p>",
        "id": 264469083,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1639152663
    },
    {
        "content": "<p>64k ought to be enough for anybody</p>",
        "id": 264469207,
        "sender_full_name": "The 8472",
        "timestamp": 1639152710
    },
    {
        "content": "<p>If not, you can just split your source code file into multiple and ... oh no we've come full circle</p>",
        "id": 264469379,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1639152762
    },
    {
        "content": "<p>You could chain multiple attributes</p>",
        "id": 264469619,
        "sender_full_name": "The 8472",
        "timestamp": 1639152857
    },
    {
        "content": "<p>Paginated source format, not the same as modules.</p>",
        "id": 264469651,
        "sender_full_name": "The 8472",
        "timestamp": 1639152867
    },
    {
        "content": "<p>Just split it into submodules, they'll be different files with their own xattrs</p>",
        "id": 264469686,
        "sender_full_name": "Laurențiu",
        "timestamp": 1639152884
    },
    {
        "content": "<p>but those are different scopes, which we wanted to avoid</p>",
        "id": 264469821,
        "sender_full_name": "The 8472",
        "timestamp": 1639152943
    },
    {
        "content": "<p>so clearly pagination within a single scope is the correct solution</p>",
        "id": 264469884,
        "sender_full_name": "The 8472",
        "timestamp": 1639152964
    }
]