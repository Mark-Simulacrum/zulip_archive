[
    {
        "content": "<p>I see that libloading’s Symbol&lt;T&gt; (where T can be a function pointer) somehow goes from a raw pointer to a function pointer without using transmute (but is probably equally as unsafe): <a href=\"https://docs.rs/libloading/0.7.2/src/libloading/os/unix/mod.rs.html#397\">https://docs.rs/libloading/0.7.2/src/libloading/os/unix/mod.rs.html#397</a></p>\n<p>How exactly does this work? it seems that it’s making a pointer to the pointer<br>\ncasting that to *const *mut _ (so, a pointer to a pointer of an inferred type), and then casting that back to *mut T?<br>\nthat extra pointer would still be there, so I’m confused…</p>",
        "id": 264961676,
        "sender_full_name": "Winter",
        "timestamp": 1639539777
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span>)</p>",
        "id": 264962338,
        "sender_full_name": "Winter",
        "timestamp": 1639540536
    },
    {
        "content": "<p>there, they're transmuting as if by:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">P</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">pointer</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"c1\">// same as: let b: T = transmute_copy(&amp;a);</span>\n</code></pre></div>",
        "id": 264962645,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639540882
    },
    {
        "content": "<p>except that instead of just reading the dereferenced pointer into <code>b</code>, they convert it to a reference so they can return it.</p>",
        "id": 264962818,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639541049
    },
    {
        "content": "<p>hopefully that explanation makes sense...</p>",
        "id": 264962850,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639541118
    },
    {
        "content": "<p>hmm<br>\ni think i understand…<br>\nbut why the interim cast to *const P?</p>",
        "id": 264962923,
        "sender_full_name": "Winter",
        "timestamp": 1639541193
    },
    {
        "content": "<p>oh because the ref needs to be a pointer</p>",
        "id": 264962931,
        "sender_full_name": "Winter",
        "timestamp": 1639541221
    },
    {
        "content": "<p>of the same type</p>",
        "id": 264962937,
        "sender_full_name": "Winter",
        "timestamp": 1639541234
    },
    {
        "content": "<p>right, okay</p>",
        "id": 264962938,
        "sender_full_name": "Winter",
        "timestamp": 1639541239
    },
    {
        "content": "<p>but what I don’t get is that: 1. why is this allowed for function pointers in the generic position but not explicitly? 2. if I’m casting to a *const fn(…), isn’t that a pointer to the function pointer, therefore if <code>pointer</code> is the function pointer itself, it’s invalid?</p>",
        "id": 264963009,
        "sender_full_name": "Winter",
        "timestamp": 1639541315
    },
    {
        "content": "<p>(as in, if my pointer was 0x1, and I casted to *const fn(…), it would first try to go to 0x1, then whenever 0x1 pointed to, then it would think that was the code)</p>",
        "id": 264963084,
        "sender_full_name": "Winter",
        "timestamp": 1639541416
    },
    {
        "content": "<p>but that would be invalid if the pointer is the actual function pointer and not a pointer to the function pointer</p>",
        "id": 264963093,
        "sender_full_name": "Winter",
        "timestamp": 1639541433
    },
    {
        "content": "<p>…if that makes sense at all</p>",
        "id": 264963096,
        "sender_full_name": "Winter",
        "timestamp": 1639541439
    },
    {
        "content": "<p>well, <code>self</code> is a reference to a struct with a field that's a function pointer, <code>&amp;self.pointer</code> is a reference to a function pointer (the reference points into the memory where <code>Self</code> lives), <code>&amp;self.pointer as *const _</code> is a pointer to a function pointer field of <code>Self</code>, <code>&amp;self.pointer as *const _ as *const T</code> is a pointer to that field, but reinterpreted as a field of type <code>T</code> (transmuted), <code>&amp;*(&amp;self.pointer as *const _ as *const T)</code> is a reference to that field, but reinterpreted as a field of type <code>T</code>.</p>",
        "id": 264963444,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639541849
    },
    {
        "content": "<p>...maybe that helps</p>",
        "id": 264963462,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639541866
    },
    {
        "content": "<p>but if it’s a reference to the pointer reinterpreted like the reference is the function pointer, that would be invalid, no?</p>",
        "id": 264963649,
        "sender_full_name": "Winter",
        "timestamp": 1639542015
    },
    {
        "content": "<blockquote>\n<ol>\n<li>why is this allowed for function pointers in the generic position but not explicitly?</li>\n</ol>\n</blockquote>\n<p>idk, i'd expect it to be the same as <code>transmute_copy</code> and to work on all types that <code>transmute_copy</code> works on (some transmutes are UB).</p>",
        "id": 264963659,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542024
    },
    {
        "content": "<p>since the address of the pointer != the address in the pointer</p>",
        "id": 264963672,
        "sender_full_name": "Winter",
        "timestamp": 1639542045
    },
    {
        "content": "<p>since the pointer in this case is the location of the code</p>",
        "id": 264963684,
        "sender_full_name": "Winter",
        "timestamp": 1639542064
    },
    {
        "content": "<p>which would be a valid function pointer</p>",
        "id": 264963689,
        "sender_full_name": "Winter",
        "timestamp": 1639542073
    },
    {
        "content": "<p>but a pointer to that pointer is not a valid function pointer</p>",
        "id": 264963698,
        "sender_full_name": "Winter",
        "timestamp": 1639542080
    },
    {
        "content": "<p>therefore calling the transmuted function pointer would be invalid</p>",
        "id": 264963712,
        "sender_full_name": "Winter",
        "timestamp": 1639542102
    },
    {
        "content": "<p>don't forget that deref returns a reference to a function pointer, the deref operator then dereferences that reference leaving just the function pointer</p>",
        "id": 264963725,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542111
    },
    {
        "content": "<p>oh</p>",
        "id": 264963795,
        "sender_full_name": "Winter",
        "timestamp": 1639542142
    },
    {
        "content": "<p>right</p>",
        "id": 264963802,
        "sender_full_name": "Winter",
        "timestamp": 1639542146
    },
    {
        "content": "<p>but wait</p>",
        "id": 264963816,
        "sender_full_name": "Winter",
        "timestamp": 1639542162
    },
    {
        "content": "<p>so</p>",
        "id": 264963819,
        "sender_full_name": "Winter",
        "timestamp": 1639542163
    },
    {
        "content": "<p>so if you drop the final reference from that expression, it’s just of T, and if you drop the final dereference, it’s *T</p>",
        "id": 264963861,
        "sender_full_name": "Winter",
        "timestamp": 1639542232
    },
    {
        "content": "<p>okay i think I’m understanding this</p>",
        "id": 264963866,
        "sender_full_name": "Winter",
        "timestamp": 1639542242
    },
    {
        "content": "<p>umm, <code>T</code> is some function pointer...</p>",
        "id": 264963968,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542334
    },
    {
        "content": "<p>well yes</p>",
        "id": 264963977,
        "sender_full_name": "Winter",
        "timestamp": 1639542344
    },
    {
        "content": "<p>by “the expression” i meant the deref body</p>",
        "id": 264964034,
        "sender_full_name": "Winter",
        "timestamp": 1639542368
    },
    {
        "content": "<p>so <code>*T</code> isn't ever valid (unless your trying to read the machine code in the function)</p>",
        "id": 264964057,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542397
    },
    {
        "content": "<p>oh, my mistake, by *T i meant *const T</p>",
        "id": 264964101,
        "sender_full_name": "Winter",
        "timestamp": 1639542449
    },
    {
        "content": "<p>i meant a pointer to T</p>",
        "id": 264964105,
        "sender_full_name": "Winter",
        "timestamp": 1639542459
    },
    {
        "content": "<p>oh, yeah</p>",
        "id": 264964107,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542466
    },
    {
        "content": "<blockquote>\n<p>so if you drop the final reference from that expression, it’s just of T, and if you drop the final dereference, it’s *T</p>\n</blockquote>\n<p>that's correct, since you meant <code>*const T</code> by <code>*T</code></p>",
        "id": 264964233,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542552
    },
    {
        "content": "<p>is there any particular reason this manual way is done instead of using transmute_copy?</p>",
        "id": 264964364,
        "sender_full_name": "Winter",
        "timestamp": 1639542704
    },
    {
        "content": "<p>cuz transmute copy would return a function pointer, rather than a reference to a function pointer, as needed by deref's return type</p>",
        "id": 264964446,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542770
    },
    {
        "content": "<p>or so i'd assume</p>",
        "id": 264964469,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1639542807
    },
    {
        "content": "<p>ah fair</p>",
        "id": 264965360,
        "sender_full_name": "Winter",
        "timestamp": 1639543689
    },
    {
        "content": "<p>thanks for the help</p>",
        "id": 264965376,
        "sender_full_name": "Winter",
        "timestamp": 1639543708
    }
]