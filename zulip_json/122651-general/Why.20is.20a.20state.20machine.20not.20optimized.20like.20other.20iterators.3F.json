[
    {
        "content": "<p>What prevents <code>usage1</code> from being as optimized as <code>usage2</code> and <code>usage3</code>? That implementation is closer to what I'd expect from async code / a generator, so I would have assumed it had more optimization attention paid to it than the other two.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">it1</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">from_fn</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(),</span><span class=\"w\">             </span><span class=\"c1\">// Code A, does not emit item</span>\n<span class=\"w\">                </span><span class=\"mi\">2</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">),</span><span class=\"w\">  </span><span class=\"c1\">// Code B, emits item</span>\n<span class=\"w\">                </span><span class=\"mi\">3</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">45</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"c1\">// Code C, emits item</span>\n<span class=\"w\">                </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">it2</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"c1\">// Code A runs, does not emit item</span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// Code B runs, emits item</span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">45</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// Code C runs, emits item</span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">into_iter</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">filter_map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">it3</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">empty</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">chain</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">once_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// Code A runs, does not emit item</span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">chain</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">once_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// Code B runs, emits item</span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">chain</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">iter</span>::<span class=\"n\">once_with</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// Code C runs, emits item</span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">45</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">filter_map</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">x</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">usage1</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">it1</span><span class=\"p\">().</span><span class=\"n\">sum</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">usage2</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">it2</span><span class=\"p\">().</span><span class=\"n\">sum</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">usage3</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">it3</span><span class=\"p\">().</span><span class=\"n\">sum</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>usage2</code> and <code>usage3</code> are optimized all the way:</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">playground:</span><span class=\"err\">:</span><span class=\"nl\">usage2:</span>\n    <span class=\"nf\">movl</span>    <span class=\"no\">$48</span><span class=\"p\">,</span> <span class=\"nv\">%eax</span>\n    <span class=\"nf\">retq</span>\n</code></pre></div>\n<p>From <a href=\"https://stackoverflow.com/q/70426439/155423\">Are there established patterns to build iterators that return items from different code blocks?</a></p>",
        "id": 265603380,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640026765
    },
    {
        "content": "<p>May be irrelevant, but <code>it2</code> and <code>it3</code> implement <code>FusedIterator</code>.</p>",
        "id": 265605759,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640028173
    },
    {
        "content": "<p>My guess is that it can turn the other variants into counted loops</p>",
        "id": 265606508,
        "sender_full_name": "The 8472",
        "timestamp": 1640028628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F/near/265603380\">said</a>:</p>\n<blockquote>\n<p>What prevents <code>usage1</code> from being as optimized as <code>usage2</code> and <code>usage3</code>? </p>\n</blockquote>\n<p>Looks to me like the classic internal-vs-external iteration problem.  <code>sum</code> uses <code>fold</code>, which is overridden for 2 &amp; 3, but <code>from_fn</code> produces a pretty poor iterator in lots of ways.</p>\n<p>Also, you're <em>always</em> incrementing <code>state</code> in <code>it1</code>, which means it's non-fused, which could also confuse it.  (The loop canonicalizer might not obviously recognize it, for example, when compiling the closure, which happens before everything else.)</p>",
        "id": 265612266,
        "sender_full_name": "scottmcm",
        "timestamp": 1640032227
    },
    {
        "content": "<p>scott \"internal vs external iteration\" mcm</p>",
        "id": 265612380,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640032310
    },
    {
        "content": "<p>My own intuition (not necessarily based on any optimizer knowledge) was that the <code>from_fn</code> version allows for a lot more flexibility even if that wasn't used (e.g. <code>state</code> _could_ go backwards).</p>",
        "id": 265612637,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640032451
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F/near/265612637\">said</a>:</p>\n<blockquote>\n<p>e.g. <code>state</code> _could_ go backwards</p>\n</blockquote>\n<p>Looks like that's not it, because use no-wrap add doesn't do better: <a href=\"https://rust.godbolt.org/z/5KW6xTGMq\">https://rust.godbolt.org/z/5KW6xTGMq</a></p>",
        "id": 265612972,
        "sender_full_name": "scottmcm",
        "timestamp": 1640032663
    },
    {
        "content": "<p>Moving the state initialization into the closure helps</p>",
        "id": 265613160,
        "sender_full_name": "The 8472",
        "timestamp": 1640032783
    },
    {
        "content": "<p>semi-related: I love showing off iterator optimizations during training <em>so much</em>. Please keep making them more and more awesome :-)</p>",
        "id": 265613169,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640032786
    },
    {
        "content": "<p>They don't come for free.</p>",
        "id": 265613428,
        "sender_full_name": "The 8472",
        "timestamp": 1640032934
    },
    {
        "content": "<p>/me has caused at least one CVE</p>",
        "id": 265613441,
        "sender_full_name": "The 8472",
        "timestamp": 1640032942
    },
    {
        "content": "<p>Are you a \"real programmer\" if you haven't caused memory unsafety in a million-dollar business? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 265613501,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640032986
    },
    {
        "content": "<p>ðŸ¦¹</p>",
        "id": 265613573,
        "sender_full_name": "The 8472",
        "timestamp": 1640033034
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20a.20state.20machine.20not.20optimized.20like.20other.20iterators.3F/near/265612637\">said</a>:</p>\n<blockquote>\n<p>My own intuition (not necessarily based on any optimizer knowledge) </p>\n</blockquote>\n<p>My understanding -- though I'm by no means an expert -- is that LLVM is <em>highly</em> dependant on getting a loop canonicalized.  It needs <em>exactly one</em> iteration variable, and <em>exactly one</em> loop exit condition.</p>\n<p>That's why the classic min-max binary search doesn't unroll, for example, which is why it's written to have a descending width instead -- just one variable, which stops at zero.  (Well, that was true before they made <code>binary_search</code> perf much worse for cheap predicates.  Hopefully <code>partition_point</code> still works like that.)</p>",
        "id": 265613866,
        "sender_full_name": "scottmcm",
        "timestamp": 1640033177
    },
    {
        "content": "<p>(thank you for implicitly describing what loop canonicalization is, I was dreading trying to search for those terms)</p>",
        "id": 265613935,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640033224
    },
    {
        "content": "<p>Example of an unrollable binary search: <a href=\"https://github.com/scottmcm/uax/blob/7a82b89312c0f3bfa5cde1a59b761a40ac0dfa5a/src/lookup_table.rs#L39-L48\">https://github.com/scottmcm/uax/blob/7a82b89312c0f3bfa5cde1a59b761a40ac0dfa5a/src/lookup_table.rs#L39-L48</a></p>",
        "id": 265614066,
        "sender_full_name": "scottmcm",
        "timestamp": 1640033292
    },
    {
        "content": "<p>This might be interesting: <a href=\"https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/strength-reduction-pass-in-llvm/#loop-strength-reduction\">https://www.cs.cornell.edu/courses/cs6120/2019fa/blog/strength-reduction-pass-in-llvm/#loop-strength-reduction</a></p>\n<hr>\n<p>Some extra info for loops: the classic <code>while C { B }</code> loop is a bad structure for optimizers.  It'll basically always turn that into <code>if C { do { B } while C; }</code> because that way the body of the loop always runs at least once.  That makes it much easier, for example, to move loop-invariant code out of the body because it'll still be inside the <code>if C</code> so if the condition was important for soundness it's still met.</p>",
        "id": 265614532,
        "sender_full_name": "scottmcm",
        "timestamp": 1640033596
    },
    {
        "content": "<blockquote>\n<p>Unfortunately, our pass does not optimize all programs correctly [...] We have not figured out the reason of these errors yet.</p>\n</blockquote>\n<p>Heh</p>",
        "id": 265615086,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1640033936
    },
    {
        "content": "<p>Another thing you might explore: try writing it as a <code>try_fold</code>, then just using <code>self.try_for_each(ControlFlow::Break).break_value()</code> as the <code>next()</code> method.</p>\n<p>I don't know if it'll be possible to do that in general, but since you needed a <code>loop</code> in the <code>next</code> anyway, it might translate really nicely to a <code>try_fold</code> so the summing loop is internal, not around the closure.</p>",
        "id": 265616322,
        "sender_full_name": "scottmcm",
        "timestamp": 1640034608
    },
    {
        "content": "<p>relevant, llvm getting better loop optimizations: <a href=\"https://reviews.llvm.org/rG1d0244aed781\">https://reviews.llvm.org/rG1d0244aed781</a></p>",
        "id": 265617803,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1640035677
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> Do you get better optimization if you change the loop/match/break to just a match, or an if/else-if? (I realize that doesn't \"naturally\" handle case 1, but that's what I'm trying to find out: is it the loop that's throwing off the optimization?</p>",
        "id": 265623895,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640039685
    }
]