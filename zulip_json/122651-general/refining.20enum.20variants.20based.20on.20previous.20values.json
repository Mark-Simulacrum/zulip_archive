[
    {
        "content": "<p>I have an enum and a sequence of enum values:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Color</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Red</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Yellow</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Green</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">color_stream</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Color</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I'm going to iterate over the sequence and match on the color. However, I know that the same color will never happen twice and I'd like to inform the compiler of this in some fashion.</p>\n<p>I'm pretty sure that Rust doesn't have the capabilities to do this now (would love to be proven wrong!). My current designs end up with a large match on a tuple of <code>previous_color</code> and <code>current_color</code> and a bunch of <code>unreachable!()</code>.</p>\n<p>I'm mostly curious if there are languages with this capability or something similar for me to read about.</p>",
        "id": 272170048,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645041462
    },
    {
        "content": "<p>if the enum is as is (i.e. small enough), you could write out all possible combinations in a single match statement</p>\n<div class=\"codehilite\"><pre><span></span><code>match (i.next(), i.next(), i.next()) {\n    (Some(Red), Some(Yellow), Some(Green))  =&gt; ...,\n    (Some(Yellow), Some(Green), None)) =&gt; ...,\n    ...\n    _ =&gt; std::hint::unreachable_unchecked()\n}\n</code></pre></div>",
        "id": 272188536,
        "sender_full_name": "nagisa",
        "timestamp": 1645050601
    },
    {
        "content": "<p>that way the compiler will have a pretty easy time telling that e.g. green yellow green is not a possible combination. Whether there's any value in it being able to determine that is debatable though.</p>",
        "id": 272188694,
        "sender_full_name": "nagisa",
        "timestamp": 1645050677
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272170048\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure that Rust doesn't have the capabilities to do this now (would love to be proven wrong!).</p>\n</blockquote>\n<p>I think <code>Iterator</code> fundamentally can't, because there's nowhere for the type system to accumulate the necessary information when the iterator and its items are not allowed to change their static types.</p>\n<p>But there's probably some dependent types language that can do it.</p>",
        "id": 272195608,
        "sender_full_name": "scottmcm",
        "timestamp": 1645055132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272188536\">said</a>:</p>\n<blockquote>\n<p>if the enum is as is (i.e. small enough), you could write out all possible combinations in a single match statement</p>\n</blockquote>\n<p>Are you saying that I'd put that... somewhere... nearby, but not actually as part of my \"iterate over the sequence\" business logic? If not, I'm unclear on how that differs from my \"My current designs end up with [...]  a bunch of <code>unreachable!()</code>.\" (Other than the <code>unsafe</code> hint function)</p>",
        "id": 272202488,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645060513
    },
    {
        "content": "<p>It does lead my brain to some sort of \"inform the compiler by example\" possibility, where the programmer could say that a function body is additional information about the type, which is in the same vein as a dependently typed language.</p>",
        "id": 272202602,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645060647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272195608\">said</a>:</p>\n<blockquote>\n<p>I think <code>Iterator</code> fundamentally can't, because there's nowhere for the type system to accumulate the necessary information when the iterator and its items are not allowed to change their static types.</p>\n</blockquote>\n<p>Hmm, that makes me think of typestate (and the various issues therein). If the signature was some made-up syntax</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Thing</span><span class=\"o\">&lt;</span><span class=\"n\">Red</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">Yellow</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">Green</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Thing</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Output</span>::<span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272202780,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645060822
    },
    {
        "content": "<p>Yeah, the simpler version of your problem is that there's no \"fixed-length iterator\" marker trait, because you can't do that -- the iterator shrinks without changing type.  A hypothetical solution could also solve the need for fuse, since the type would just change to make <code>next</code> impossible to call after you find out it's empty.</p>",
        "id": 272205408,
        "sender_full_name": "scottmcm",
        "timestamp": 1645063350
    },
    {
        "content": "<p>The general idea is called refinement types, I think liquid Haskell has them, though not for enum variants. They have been discussed for Rust (though there hasn't been an RFC or other serious proposal) as a generalisation of the idea of enum variant types</p>",
        "id": 272231580,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645088963
    },
    {
        "content": "<p>Nice to see that the “refinement” in this thread title wasn’t completely made up.</p>",
        "id": 272251822,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645100984
    },
    {
        "content": "<p>TypeScript has this which I believe is likely the most \"popular\" example of this feature in the wild.</p>",
        "id": 272252175,
        "sender_full_name": "rylev",
        "timestamp": 1645101222
    },
    {
        "content": "<p>(FYI: <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> recently wrote about \"anonymous enums\" - among other things - which are a related concept in this post: <a href=\"https://blog.yoshuawuyts.com/more-enum-types/\">https://blog.yoshuawuyts.com/more-enum-types/</a>)</p>",
        "id": 272252250,
        "sender_full_name": "rylev",
        "timestamp": 1645101246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> , not <em>exactly</em> what you’re asking for since you want it in the type system, but this is also what formal verification is for</p>",
        "id": 272258825,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645104769
    },
    {
        "content": "<p>A verification tool could verify that your iterator returns a unique result each time</p>",
        "id": 272258897,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645104810
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224872\">@rylev</span> does TypeScript call it refinement types as well? I didn’t see anything beyond proposals to add them.</p>",
        "id": 272264492,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645107203
    },
    {
        "content": "<p>I don't believe they advertise it as such. It's just the way that TypeScript works</p>",
        "id": 272265064,
        "sender_full_name": "rylev",
        "timestamp": 1645107432
    },
    {
        "content": "<p>Looks like they call it \"narrowing\": <a href=\"https://www.typescriptlang.org/docs/handbook/2/narrowing.html\">https://www.typescriptlang.org/docs/handbook/2/narrowing.html</a></p>",
        "id": 272265260,
        "sender_full_name": "rylev",
        "timestamp": 1645107504
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> this makes me think I almost want <code>unsafe</code> at the type level. Then I’d use the verification tool like I use valgrind or Miri.</p>",
        "id": 272265379,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645107569
    },
    {
        "content": "<p>Refinement types are a slightly different concept, another way of phrasing them is 'subset types' where you have a type <code>{ x : T | P x }</code> aka: values <code>x</code> of type <code>T</code> which satisfy <code>P</code></p>",
        "id": 272267755,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645108599
    },
    {
        "content": "<p>using this you can encode the condition you wanted, but the TypeScript case is different and emerges from its support for open union types (aka the type <code>A + B</code> or <code>{A | B}</code>)</p>",
        "id": 272267909,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645108662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272265379\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> this makes me think I almost want <code>unsafe</code> at the type level. Then I’d use the verification tool like I use valgrind or Miri.</p>\n</blockquote>\n<p>that would be one option but my personal opinion has been evolving to saying that trying to fit everything into the type system can be counterproductive in practice</p>",
        "id": 272268027,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645108699
    },
    {
        "content": "<p>it can be simpler to have certain obligations which are not in types and just have a seperate aspect to verificaiton</p>",
        "id": 272268076,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645108728
    },
    {
        "content": "<p>this is similar to the Coq advice to not use dependent types in your functions, but instead use simple types and <em>seperately</em> prove it to be correct</p>",
        "id": 272268135,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645108761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> from a current/practical perspective absolutely, but that does lead to a lot of cases where <code>unimplemented!</code> needs to be used. Without using the unsafe version, that also means that there’s junk code in the compiled binary.</p>",
        "id": 272276294,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645111955
    },
    {
        "content": "<p>I’ve written some TypeScript before, but I don’t immediately see how to model this example in its type system</p>",
        "id": 272276632,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645112104
    },
    {
        "content": "<p>Not <code>unimplemented!</code> but <code>unreachable</code> which can be optimized out afaik</p>",
        "id": 272277102,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645112261
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 272277334,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645112344
    },
    {
        "content": "<p>You could do it by implementing 3 functions with progressively narrower types</p>",
        "id": 272277591,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645112426
    },
    {
        "content": "<p>But since afaik typescript must be erasable you can’t do any sort of “type based dispatch/overloading”</p>",
        "id": 272277766,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645112498
    },
    {
        "content": "<p>I don’t know typescript well… merely enough to dable</p>",
        "id": 272277836,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645112522
    },
    {
        "content": "<p><code>unimplemented!</code> and <code>unreachable!</code> are both runtime panics. The unsafe version in <code>hint</code> is different.</p>",
        "id": 272278077,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645112593
    },
    {
        "content": "<p>Ah yea ok</p>",
        "id": 272284519,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645115250
    },
    {
        "content": "<p>Then I guess the “solution” would be the unsafe + external Verif</p>",
        "id": 272284567,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645115271
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272202488\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/122651-general/topic/refining.20enum.20variants.20based.20on.20previous.20values/near/272188536\">said</a>:</p>\n<blockquote>\n<p>if the enum is as is (i.e. small enough), you could write out all possible combinations in a single match statement</p>\n</blockquote>\n<p>Are you saying that I'd put that... somewhere... nearby, but not actually as part of my \"iterate over the sequence\" business logic? If not, I'm unclear on how that differs from my \"My current designs end up with [...]  a bunch of <code>unreachable!()</code>.\" (Other than the <code>unsafe</code> hint function)</p>\n</blockquote>\n<p>I think making this match a part of iterate over sequence business logic is not that inconceivable if its wrapped into a macro or something. But yeah. And one big match statement is there to basically demonstrate to LLVM that it only needs to consider 3 iterations ever, and not an unknown number of them that a <code>for</code> loop and similar signals.</p>",
        "id": 272321517,
        "sender_full_name": "nagisa",
        "timestamp": 1645131499
    },
    {
        "content": "<p>I was pretty much reacting to “inform compiler of this” portion of your question which to me kind of became “inform optimizer of this…” ^^</p>",
        "id": 272321639,
        "sender_full_name": "nagisa",
        "timestamp": 1645131567
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> do you have any resources that are useful for a Rust expert (with a large ego) but a formal verification newbie? Something specifically addressing a concern of mine of \"I proved system A to be correct, too bad my code implements system B\"?</p>",
        "id": 272452134,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645215507
    },
    {
        "content": "<p>Ha going straight for the hard problems</p>",
        "id": 272458871,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645219172
    },
    {
        "content": "<p>There’s few ways to interpret and answer that question let me see if I have some good papers</p>",
        "id": 272458994,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645219250
    },
    {
        "content": "<p>That's how I know I'm in for a bad time: when papers are the solution. Usually ends up with me having to learn at least one whole new domain of math / computer science.</p>",
        "id": 272459276,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645219408
    },
    {
        "content": "<p>heh it won't be just papers (unless that's what you want)</p>",
        "id": 272461606,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645220701
    },
    {
        "content": "<p>nah, a mix of sources is fine. And please don't rush to gather things up for me; this is mostly a background thing for me to learn more about (but I might as well ask someone who knows while they are around!)</p>",
        "id": 272462200,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645221007
    },
    {
        "content": "<p>So I'm far from an expert, I'm only starting out in my career here but let me share what I've learned.</p>\n<p>For the french speakers in the audience: Xavier Leroy's lecture series at the college de france are <em>very</em> good and give a rather complete, and tight overview of verification and formal language design / modeling: <a href=\"https://www.college-de-france.fr/site/xavier-leroy/course-2021-03-04-09h30.htm\">https://www.college-de-france.fr/site/xavier-leroy/course-2021-03-04-09h30.htm</a></p>\n<p>A broad overview by Hillel: <a href=\"https://www.hillelwayne.com/post/why-dont-people-use-formal-methods/\">https://www.hillelwayne.com/post/why-dont-people-use-formal-methods/</a> I think this post gives a good amount of context on the challenges in FV/FM. However, obviously his opinions are shaped by his domain of expertise (TLA+) so I don't necessarily agree with all his posts. </p>\n<p>\"seL4: Formal verification of an OS kernel\": I think this work touches <em>exactly</em> on the heart of your question. They proved a high-performance microkernel in a long duration collaboration between fm and os researchers. They also specifically explored the question of proving they proved the right things as well as proving that the final binary actually did what their proofs said. I think all the papers on sel4 are good reads for this topic.</p>\n<p>Verification of the Ligne 14 metro in Paris: <a href=\"https://link.springer.com/content/pdf/10.1007%252F3-540-48119-2_22.pdf\">https://link.springer.com/content/pdf/10.1007%252F3-540-48119-2_22.pdf</a></p>\n<p>More generally your question is verify similar to the so called 'specification problem': how do we know that the specification we've given is the correct one? Depending on your intellectual/academic heritage you'll typically have a different answer to the question. </p>\n<p>On the one hand you will have 'modellers' who argue we should focus on building and reasoning about <em>models</em> of our systems rather than their implementations. This allows us to focus on the specification itself. However, since the models are written by hand, there's always a gap between it and the actual implementation. The typical tool here is TLA+ and related languages. If you're interested in this there's a <em>huge</em> literature on model checking. </p>\n<p>In the other camp you have what could be called 'verifiers' who focus on the actual implementation, and specifying its behavior. This tradeoff isn't free, specifications usually have to care about details that wouldn't appear in a TLA model, potentially obscuring comprehension. <br>\nPeople here would argue that its easier to verify by hand a terse and compact specification than a large complex codebase. <br>\nI have some thoughts on that...</p>\n<p>What follows is mostly context about various verification tools, terminology and approaches.</p>\n<p>There's a wide-range of different tools here but many revolve in some way or another around the concept of 'weakest-preconditions' and 'hoare logic'. If you are not familiar with these terms I would highly recommend reading about them, here are some different resources:</p>\n<ul>\n<li><a href=\"https://softwarefoundations.cis.upenn.edu/plf-current/Hoare.html\">Software Foundations</a> a great series of 'textbooks' on formal verification, written as exercises in Coq. The newest tome even covers 'seperation logic'. </li>\n<li><a href=\"https://www.cl.cam.ac.uk/archive/mjcg/HL/Notes/Notes.pdf\">https://www.cl.cam.ac.uk/archive/mjcg/HL/Notes/Notes.pdf</a> lecture notes that seem to form a quite good introduction to the topic of Hoare logic. </li>\n</ul>\n<p>The notion of 'weakest preconditions' was introduced by Dijkstra to explore the eponymous question: What is the <em>bare minimum</em> required for a program <code>P</code> to satisfy property <code>Q</code>. <br>\nIt turns out we can give a very efficient algorithmic answer to this.</p>\n<ul>\n<li>Old lecture notes from my supervisor: <a href=\"https://www.lri.fr/~marche/MPRI-2-36-1/2013/poly1.pdf\">https://www.lri.fr/~marche/MPRI-2-36-1/2013/poly1.pdf</a> . They may be a bit terse, let me know. </li>\n<li>A paper on the foundations of 'Why3' my lab's tool which is based on Hoare logic and weakest preconditions: <a href=\"https://hal.inria.fr/hal-01256434v3/document\">https://hal.inria.fr/hal-01256434v3/document</a></li>\n</ul>\n<p>It turns out though that pointers throw a wrench in this whole weakest precondition and hoare logic business. All of a sudden we can effect changes 'at a distance'. This challenge stumped researchers for a very long time until in the early 2000s \"seperation logic\" was invented (an intellectual ancestor of Rust). It bore <a href=\"https://ilyasergey.net/assets/other/CSL-Family-Tree.pdf\">many fruit</a> and has come to be accepted as the 'correct' answer to imperative program verification. Today, many seperation logics exist, like the one in <a href=\"https://www.pm.inf.ethz.ch/research/viper.html\">Viper</a> the tool underlying Prusti, or Iris, the logic developed in part by our very own Ralf.<br>\nIn way too short, the key idea of seperation logic was to introduce a way to explicitly 'cut up' memory (ie: <em>seperate</em> it). Making memory first-class in our logic gives a lot of power to describe imperative pointer programs, and naturally generalizes to other kinds of 'resources' (see Iris). </p>\n<ul>\n<li>Software Foundations volume 5: <a href=\"https://softwarefoundations.cis.upenn.edu/slf-current/index.html\">https://softwarefoundations.cis.upenn.edu/slf-current/index.html</a></li>\n<li>RustBelt, a proof of Rust type safety using seperation logic: <a href=\"https://plv.mpi-sws.org/rustbelt/\">https://plv.mpi-sws.org/rustbelt/</a></li>\n<li><a href=\"https://www.cambridge.org/core/services/aop-cambridge-core/content/view/26301B518CE2C52796BFA12B8BAB5B5F/S0956796818000151a.pdf/iris_from_the_ground_up_a_modular_foundation_for_higherorder_concurrent_separation_logic.pdf\">Iris 3.0</a>. This is a <em>hard</em> paper, I do not expect it to make sense.</li>\n</ul>\n<p>I hope this is useful for you, if you have any questions don't hesitate, but I should say I'm only a journeyman I have a long way to go still.</p>",
        "id": 272468998,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645224560
    },
    {
        "content": "<p>I hope you find this useful :)</p>",
        "id": 272469039,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645224594
    },
    {
        "content": "<p>Thank you; there's a lot to chew on there!</p>\n<p>Let's pretend that I'm a code monkey interested in making my normal run-of-the-mill Rust software \"better\" (for a handwavy definition of better) using formal verification. Is there a specific/primary tool that you'd point me towards using?</p>\n<p>For example, I've read some papers about the usage of quickcheck in the small (reversing a list) and in the large (verifying C programs via their APIs) and I've since grown to be a fan of property-based testing as well as fuzzing.</p>",
        "id": 272485772,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645237812
    },
    {
        "content": "<p>Thanks Xavier for this comprehensive list of links. One of the transitive links seems like a pretty good fit for <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> 's question: the <a href=\"https://web.archive.org/web/20190228165642/infohost.nmt.edu/~al/cseet-paper.html\">Cleanroom</a> method, which I had not heard of before. I would summarize it as: pretend you are using a formal specification language around your code like cruesot, but replace the actual checker by a human code review process. This has the advantage that you don't have to learn a formal language, only formal thinking, and it adapts much better to semi-formal methods that are important to making it useful in the \"real world\".</p>\n<p>In a way, <code>// Safety</code> comments are a basic form of this, but you can extend the method to include all sorts of invariants, pushing beyond mere memory safety and into functional correctness. It's certainly not required to use a tool to do this; mathematicians write proofs without computer assistance so it stands to reason that similar methods can be applied to code as well. The most important part (IMO) is to actually <em>write the invariants down</em> so that people can see what you think should be true. Once you have the invariants at each program point, verification becomes a local problem, and long-distance bugs suddenly become obvious. Using a tool to derive that each line correctly preserves the invariants is just icing on the cake.</p>",
        "id": 272510811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645268207
    },
    {
        "content": "<p>You can push this further, into an actual formal language that can be checked by tools, but if your goal is just to eliminate bugs then I would guess that the majority of bugs are squeezed out by the time you get to this semi-formal stage. The main thing that continuing to a formal language will help with is errors in reasoning or flaws in the proof, which in my experience is relatively rare compared to miscommunicated preconditions in real code.</p>",
        "id": 272511173,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1645268577
    },
    {
        "content": "<p>^^^^^^^</p>",
        "id": 272513173,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645271026
    },
    {
        "content": "<p>1000% what mario said. A <em>lot</em> of the benefit in FV is being forced to <em>actually</em> write your invariants and specifications and not 'handwave' them. Then behind that you often have hours that are 'wasted' to convince the formal tools of those invariants.</p>\n<p>Beyond writing invariants or contracts, if you're looking for an actual tool to help you, <code>quickcheck</code> is a <em>very</em> good cost benefit ratio tool</p>",
        "id": 272513259,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645271138
    },
    {
        "content": "<p>it plays into this 'writing your specification down' as you can only quickcheck things that have <em>properties</em> to check.</p>",
        "id": 272513271,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645271161
    },
    {
        "content": "<p>If you want to move beyond fuzzing/checking properties, things quickly get more difficult as you ask to verify more. (My PhD thesis is about how we can bend that curve for rust).</p>",
        "id": 272513635,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1645271635
    }
]