[
    {
        "content": "<p>In general, the compiler will let you use a 'longer-lived' value where a 'shorter' lived value is expected. The most common example of this is using a <code>&amp;'static T</code> where an <code>&amp;'a T</code> is expected</p>",
        "id": 266621333,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140587
    },
    {
        "content": "<p>So in this example 'a matches to the intersection of 'static and whatever lifetimes my arguments have at the calling site, effectively ensuring that x and y have non-empty lifetime intersection?</p>",
        "id": 266621346,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641140616
    },
    {
        "content": "<p>The 'static lifetime doesn't really come into play when you're calling the function</p>",
        "id": 266621397,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140655
    },
    {
        "content": "<p>If you're calling the function with two references, then they are effectively guaranteed to have a non-empty 'intersection', since they're both 'alive' in the caller</p>",
        "id": 266621407,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140693
    },
    {
        "content": "<p>For example, if I have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">first_ref</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">second_ref</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"n\">longest</span><span class=\"p\">(</span><span class=\"n\">first_ref</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">second_ref</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266621421,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140720
    },
    {
        "content": "<p>the fact that I'm able to use both <code>first_ref</code> and <code>second_ref</code> in the call arguments means that they both must be 'alive' at the time that call occurs</p>",
        "id": 266621431,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140743
    },
    {
        "content": "<p>so they must have some non-empty intersection</p>",
        "id": 266621433,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140749
    },
    {
        "content": "<p>And regarding this formulation I have come up with, is it true and is it complete, or is there more to the lifetimes?</p>\n<p>\"whenever there are entities with the same lifetime parameter, ensure that at the function body and at any call site the factual lifetimes have non-empty intersection\"</p>",
        "id": 266621440,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641140760
    },
    {
        "content": "<p>The caller doesn't actually know that I'm returning a <code>&amp;'static str</code> (\"Hello\")</p>",
        "id": 266621479,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140764
    },
    {
        "content": "<p>That's essentially correct</p>",
        "id": 266621486,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140780
    },
    {
        "content": "<p>The details of what an 'intersection' actually means, as well as how the lifetimes in a function body are actually determined, are quite subtle</p>",
        "id": 266621495,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140798
    },
    {
        "content": "<p>Rust has what are called \"non-lexical lifetimes\" (NLL), which allows the compiler to be fairly clever about determining how long a lifetime in a function body should 'actually' last</p>",
        "id": 266621520,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140856
    },
    {
        "content": "<p>For example, if I do:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">my_var</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">first_ref</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">my_var</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">first_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">second_ref</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">my_var</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">second_ref</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266621572,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140916
    },
    {
        "content": "<p>It might look like I have two mutable references (<code>first_ref</code> and <code>second_ref</code>) to the same variable (<code>my_var</code>), which is not allowed</p>",
        "id": 266621581,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140936
    },
    {
        "content": "<p>However, the compiler will notice that <code>first_ref</code> is never used again after <code>*first_ref = false</code></p>",
        "id": 266621597,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140954
    },
    {
        "content": "<p>So the lifetime of <code>first_ref</code> can end right after that statement, before <code>second_ref</code> is created</p>",
        "id": 266621605,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140968
    },
    {
        "content": "<p>So, the exact 'length' of a lifetime might not be obvious at first, as well as what lifetime the intersection of two lifetimes should have</p>",
        "id": 266621659,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141005
    },
    {
        "content": "<p>But your overall understanding is correct</p>",
        "id": 266621670,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141020
    },
    {
        "content": "<p>Thank you, I got it!</p>\n<p>And one very final question: the third of the three rules states that if we have a method with &amp;self as a first argument, than the return value automatically gets assigned the same lifetime as &amp;self. Wouldn't this assignment be wrong if I have a second argument that has some other lifetime?<br>\nSay, instead of a standalone function longest(&amp;x: str, &amp;y: str) I have a method for a str, which does exactly the same, with signature longest(&amp;self, &amp;y: str) -&gt; &amp;str. Then I automatically get 'a for &amp;self, 'b for &amp;y, 'a for the return value, but that would be wrong, because the semantics of the body require that all the lifetimes are the same. Will it fail to compile, or will there be something more at play here?</p>",
        "id": 266621702,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641141083
    },
    {
        "content": "<p>You're correct</p>",
        "id": 266621765,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141145
    },
    {
        "content": "<p>The idea behind that elision rule is that <code>self</code> is usually 'special'</p>",
        "id": 266621771,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141157
    },
    {
        "content": "<p>and that the data you return will usually be derived from it in some way</p>",
        "id": 266621778,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141168
    },
    {
        "content": "<p>For example, I could have accessor function that returns a reference to a field of a struct</p>",
        "id": 266621784,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141181
    },
    {
        "content": "<p>that pattern is common enough for that lifetime elision rule to be useful</p>",
        "id": 266621793,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141199
    },
    {
        "content": "<p>However, it's not always the right choice, as in your example</p>",
        "id": 266621796,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141207
    },
    {
        "content": "<p>so, you may sometimes need to explicitly write lifetimes to indicate the behavior that you want</p>",
        "id": 266621805,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141222
    },
    {
        "content": "<p>So it is totally possible for Lifetime Elision to come up with some lifetimes (as opposed to failing to determine them for some entities), just to see that these lifetimes do not align with the function body, and then it fails to compile and I provide them in a correct way manually?</p>",
        "id": 266621861,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641141276
    },
    {
        "content": "<p>Yes</p>",
        "id": 266621868,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141285
    },
    {
        "content": "<p>and the lifetimes you need may change over time, as you change the body of the function</p>",
        "id": 266621884,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141305
    },
    {
        "content": "<p>You might start out just wanting to print out two references, so they don't need to have the same lifetime</p>",
        "id": 266621898,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141328
    },
    {
        "content": "<p>But then you might later want to do some additional processing that requires them to have the same lifetime</p>",
        "id": 266621910,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641141353
    },
    {
        "content": "<p>Great, thank you very much for your time and answers, it seems like I have no more questions with respect to lifetimes! :)</p>",
        "id": 266621941,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641141362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"467334\">Sergey A New Rustacean</span> has marked this topic as resolved.</p>",
        "id": 266621967,
        "sender_full_name": "Notification Bot",
        "timestamp": 1641141390
    }
]