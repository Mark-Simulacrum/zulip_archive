[
    {
        "content": "<p>So... i may have just realized one of my codegen flags may be unsound... oops<br>\nI just wanted to ask though since its a pretty helpful flag. CUDA has approximate float instructions for things like recp, div, and sqrt, which can greatly speed up certain kernels. But im not sure if me adding support for that is sound, is it? I thought the problem was that the operations would not be applied globally, but in this case they <em>would</em>.</p>",
        "id": 269682655,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643341407
    },
    {
        "content": "<p>Do we ever guarantee strict floating point arithmetic?</p>",
        "id": 269698012,
        "sender_full_name": "fee1-dead",
        "timestamp": 1643356227
    },
    {
        "content": "<p>A lot of the fast math flags introduce UB when a floating point number is eg NaN or Infinity.</p>",
        "id": 269699042,
        "sender_full_name": "bjorn3",
        "timestamp": 1643356883
    },
    {
        "content": "<p>Hmm, for Â½ULP things it's more sketchy to approximate them.</p>\n<p><a class=\"stream\" data-stream-id=\"257879\" href=\"/#narrow/stream/257879-project-portable-simd\">#project-portable-simd</a> is probably looking at how to expose the low-precision versions of these that come in SIMD, so maybe they'll set a precedent for special methods for these things?</p>\n<p>It'd definitely make sense to me to have scalar <code>invsqrt_approx</code> and such methods...</p>",
        "id": 269713137,
        "sender_full_name": "scottmcm",
        "timestamp": 1643364637
    },
    {
        "content": "<p>There has bean a lot of talk on internals about how to expose fast math <a href=\"https://internals.rust-lang.org/search?q=fast%20math\">https://internals.rust-lang.org/search?q=fast%20math</a></p>",
        "id": 269750657,
        "sender_full_name": "Eh2406",
        "timestamp": 1643382756
    },
    {
        "content": "<p>PTX approx instructions do not introduce UB for NaN/inf inputs AFAIK</p>",
        "id": 269801880,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643403743
    },
    {
        "content": "<p>the effect is not really observable by llvm because it just replaces the normal stuff with <code>.approx</code> ptx instructions as far as i know</p>",
        "id": 269801967,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643403798
    },
    {
        "content": "<p>so miscompilations can't happen i believe</p>",
        "id": 269801986,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643403807
    },
    {
        "content": "<p>then you can probably introduce them as a codegen flag soundly. that said, i dont think a codegen flag is how we want this to work more broadly (i think <span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> had a comment on IRLO that roughly mapped how i hope things will eventually work, although I'm having trouble locating it)</p>",
        "id": 269802034,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643403839
    },
    {
        "content": "<p>but it also makes sense that this would be more important than average for a gpu backend.</p>",
        "id": 269802144,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643403886
    },
    {
        "content": "<p>Yeah this is pretty important for gpus, since usually gpu programs contain millions of these sqrt/div ops</p>",
        "id": 269802198,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643403913
    },
    {
        "content": "<p>and precise sqrt takes a lot of valuable registers</p>",
        "id": 269802215,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643403927
    },
    {
        "content": "<p>yeah that makes sense</p>",
        "id": 269803151,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1643404399
    },
    {
        "content": "<p>testing my toy path tracer with fast div and fast sqrt, it seems to work fine without issues. Though obviously it is a small test case</p>",
        "id": 269803614,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643404586
    },
    {
        "content": "<p>Isn't the main issue with fast-math the fact it touches unwanted things, like removing certain checks?</p>",
        "id": 269803692,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643404614
    },
    {
        "content": "<p>with this flag it only affects the div and sqrt calculations</p>",
        "id": 269803726,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643404625
    },
    {
        "content": "<p>if it uses <code>fast</code> &lt;<a href=\"https://llvm.org/docs/LangRef.html#fast-math-flags\">https://llvm.org/docs/LangRef.html#fast-math-flags</a>&gt; it's unsound (because use of poison can produce UB) if it's passed a nan or an infinity, thought.</p>",
        "id": 269804351,
        "sender_full_name": "scottmcm",
        "timestamp": 1643404926
    },
    {
        "content": "<p>It does not, it uses the fast_div and fast_sqrt libnvvm flags which replace some functions in <code>libdevice</code> (gpu libm) with <code>sqrt.approx</code> ptx instructions</p>",
        "id": 269804634,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643405061
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"276242\">Riccardo D'Ambrosio</span> <a href=\"#narrow/stream/122651-general/topic/Soundness.20of.20gpu.20fast.20math/near/269803692\">said</a>:</p>\n<blockquote>\n<p>Isn't the main issue with fast-math the fact it touches unwanted things, like removing certain checks?</p>\n</blockquote>\n<p>Well part of the problem is that in the past it's been discussed as a <em>compiler flag</em>, as in a global flag which is applied to all units of the compilation, even units that aren't expecting an approximation will be applied to them. This can potentially make a library suddenly have issues.</p>\n<p>If it's limited to particular alternate f32 methods (such as how fused multiply-add works) that would be one way to make things a lot easier to manage.</p>",
        "id": 269841984,
        "sender_full_name": "Lokathor",
        "timestamp": 1643435606
    },
    {
        "content": "<p>What is the actual spec for the operations in question vs. when they are replaced?</p>",
        "id": 269963027,
        "sender_full_name": "Jubilee",
        "timestamp": 1643583354
    },
    {
        "content": "<p>I am, broadly speaking, not that concerned about \"the call stretches an ULP wider than expected\".<br>\nThough, maybe I should be for division.<br>\nThe question is, does it allow things like reassociation? It seems the answer is not? But what rules <strong>are</strong> these new ops bound by instead?</p>",
        "id": 269963124,
        "sender_full_name": "Jubilee",
        "timestamp": 1643583457
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"361356\">fee1-dead</span> <a href=\"#narrow/stream/122651-general/topic/Soundness.20of.20gpu.20fast.20math/near/269698012\">said</a>:</p>\n<blockquote>\n<p>Do we ever guarantee strict floating point arithmetic?</p>\n</blockquote>\n<p>We do, implicitly, by stating our floats are IEEE754-2008's <code>binary32</code> and <code>binary64</code>.</p>\n<p>By actually including-by-reference IEEE754, we pretty much commit ourselves to a fairly strict interpretation of floating point operations. The rules of iEEE754 are somewhat more permissive than people think in places but can be pretty damn strict in a few places people whine the most about.</p>",
        "id": 269963139,
        "sender_full_name": "Jubilee",
        "timestamp": 1643583479
    },
    {
        "content": "<p>To weigh in with my Mini-Kahan hat actually on:</p>\n<p>Because square root is potentially lowered as a library function, I think it's reasonable to approximate it. However, I would really rather that it is <strong>consistent</strong>. If you are telling me that all CUDA GPUs will return the same result from <code>fast_sqrt</code> for a given value, it just is \"sloppily\" calculated (but in the same way every time) then actually I am pretty in favor. For instance, I am somewhat against using the x86-64 <code>rcpss</code> instruction because AMD and Intel differ on this.</p>",
        "id": 269964452,
        "sender_full_name": "Jubilee",
        "timestamp": 1643585074
    },
    {
        "content": "<p>However, it's probably pretty bad to cheap out on division, unfortunately.</p>",
        "id": 269964538,
        "sender_full_name": "Jubilee",
        "timestamp": 1643585169
    },
    {
        "content": "<p>But, in either case, I would like to know what actually we would be agreeing to, essentially.<br>\nI think allowing this as an opt-in with a codegen flag would be OK, regardless, but I agree with Thom that we would ideally want to use a Proper approach. The catch is that I say this because a codegen flag is implicitly <code>unsafe</code>. I am not saying this is necessarily a good idea, I am saying that you are allowed to have codegen flags that give Rust programs UB!</p>\n<p>And also because philosophically, \"you should do this as precisely as you can afford, but you may offer an opt-in to a slightly faster or more imprecise version\" is mentioned a few times in IEEE754's later versions.</p>",
        "id": 269965012,
        "sender_full_name": "Jubilee",
        "timestamp": 1643585876
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> It is replaced when calling the libdevice functions provided by the libdevice llvm bitcode file. But only when you pass <code>-prec-sqrt</code> and <code>-prec-div</code> to libnvvm (i think thats what theyre called). You can technically call sqrt urself  by just using inline ptx assembly but realistically nobody will do that</p>",
        "id": 269979681,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643604387
    },
    {
        "content": "<p>as for the spec of how it works, u can find more info <a href=\"https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#floating-point-instructions-sqrt\">here</a></p>",
        "id": 269979704,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643604429
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/fPc9LzUdnCOF1MRbLNYRuGIU/Screenshot_576.png\">Screenshot_576.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/fPc9LzUdnCOF1MRbLNYRuGIU/Screenshot_576.png\" title=\"Screenshot_576.png\"><img src=\"/user_uploads/4715/fPc9LzUdnCOF1MRbLNYRuGIU/Screenshot_576.png\"></a></div>",
        "id": 269979724,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643604464
    },
    {
        "content": "<p>and div: </p>\n<div class=\"codehilite\"><pre><span></span><code>div.approx.f32 implements a fast approximation to divide, computed as d = a * (1/b). For |b| in [2-126, 2126], the maximum ulp error is 2. For 2126 &lt; |b| &lt; 2128, if a is infinity, div.approx.f32 returns NaN, otherwise it returns 0.\ndiv.full.f32 implements a relatively fast, full-range approximation that scales operands to achieve better accuracy, but is not fully IEEE 754 compliant and does not support rounding modifiers. The maximum ulp error is 2 across the full range of inputs.\nSubnormal inputs and results are flushed to sign-preserving zero. Fast, approximate division by zero creates a value of infinity (with same sign as a).\n</code></pre></div>",
        "id": 269979803,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643604528
    },
    {
        "content": "<p>There seems to be nothing about UB on subnormal inputs, only that it returns NaN on subnormal inputs</p>",
        "id": 269979822,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643604560
    },
    {
        "content": "<p>so it seems to be much saner than normal fast math, which is why i added it</p>",
        "id": 269979832,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643604576
    },
    {
        "content": "<p>Oh and in particular, the codegen replaces calls to <code>libm</code> with calls to libdevice by default, so anything using libm will be using libdevice and therefore a fast approximation if fast_sqrt/div is turned on</p>",
        "id": 269979908,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643604656
    },
    {
        "content": "<p><code>sqrt.approx.f32</code> returns a zero on subnormals, actually, that's much better.</p>",
        "id": 270102328,
        "sender_full_name": "Jubilee",
        "timestamp": 1643662155
    },
    {
        "content": "<p>they don't specify the maximum absolute or relative error for <code>sqrt.approx</code>?</p>",
        "id": 270102837,
        "sender_full_name": "Jubilee",
        "timestamp": 1643662399
    },
    {
        "content": "<p>Dont think so</p>",
        "id": 270102873,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643662417
    },
    {
        "content": "<p>Annoying.<br>\nAnd the div.approx.f32 and div.full.f32 have a 2ulp margin, at least, within a range for <code>approx</code>.</p>",
        "id": 270103139,
        "sender_full_name": "Jubilee",
        "timestamp": 1643662531
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"276242\">@Riccardo D'Ambrosio</span> I double-checked a few things and I don't think using <code>div.approx</code> is appropriate, unfortunately: according to their spec, it can give very wrong answers and actually generate <strong>more NaNs</strong> than otherwise, which is... usually not what programmers want. <code>div.full</code> doesn't give enough information to fairly judge it, either.</p>",
        "id": 270479652,
        "sender_full_name": "Jubilee",
        "timestamp": 1643846891
    },
    {
        "content": "<p>I see</p>",
        "id": 270479685,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643846917
    },
    {
        "content": "<p>Yeah approx div is much rarer than sqrt anyways</p>",
        "id": 270479699,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643846928
    },
    {
        "content": "<p>Though i dont think approx div is <em>unsound</em> is it?</p>",
        "id": 270479722,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643846953
    },
    {
        "content": "<p>That depends on what your definition of unsound is. :^)</p>",
        "id": 270479750,
        "sender_full_name": "Jubilee",
        "timestamp": 1643846982
    },
    {
        "content": "<p>stuff goes kaboom in a not so fun way</p>",
        "id": 270479766,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643846998
    },
    {
        "content": "<p>Shame that <span aria-label=\"boom\" class=\"emoji emoji-1f4a5\" role=\"img\" title=\"boom\">:boom:</span> was removed from I-unsound <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>",
        "id": 270479857,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643847038
    },
    {
        "content": "<p>Mmm.<br>\nI would say \"generates NaNs on an otherwise-valid division\" is probably unsound then in that sense, yes.<br>\nIn a formal or Rust sense, \"does it breach the  <code>unsafe</code> contract?\" the answer is \"probably not\", but that is entirely because the way floating point works makes basically everything \"well-defined\". It makes it monstrously easier to commit logic errors, however.</p>",
        "id": 270480632,
        "sender_full_name": "Jubilee",
        "timestamp": 1643847552
    },
    {
        "content": "<p>The <code>sqrt.approx</code> operation only has the quirk of the \"denormals are zero\"-like behavior, but that doesn't introduce any more NaNs, it just suppresses NaNs in the case of a negative subnormal input. I don't expect anyone actually cares about that.</p>",
        "id": 270481537,
        "sender_full_name": "Jubilee",
        "timestamp": 1643848149
    },
    {
        "content": "<p>At the very least, adding more NaNs opens the door for programs that render images that look like this to the screen: <a href=\"/user_uploads/4715/zVmxE7NlahqNrLkmi-w4J_w4/lovely_nan_coloring.png\">lovely_nan_coloring.png</a> <br>\nwhich is kind of the opposite of what we would want~</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/zVmxE7NlahqNrLkmi-w4J_w4/lovely_nan_coloring.png\" title=\"lovely_nan_coloring.png\"><img src=\"/user_uploads/4715/zVmxE7NlahqNrLkmi-w4J_w4/lovely_nan_coloring.png\"></a></div>",
        "id": 270482882,
        "sender_full_name": "Jubilee",
        "timestamp": 1643849039
    },
    {
        "content": "<p>its not a bug its a feature</p>",
        "id": 270496883,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1643860173
    },
    {
        "content": "<p>Generally soundness in rust is about causing undefined behavior from safe code. But there are tons of ways you can pass dubious flags to compilers to get it to produce things that are not safe to run.</p>",
        "id": 270872090,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644126931
    },
    {
        "content": "<p>for sure a few of the weirder -C ones are (llvm-args, passes, definitely anything involving linking, in some sense target-{cpu,feature}...), but <code>-Zsaturating-float-casts=no</code> is clearly unsound</p>",
        "id": 270872245,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644127183
    },
    {
        "content": "<p>I think this seems fine though (so long as it doesnt migrate to other backends...)</p>",
        "id": 270872384,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1644127256
    },
    {
        "content": "<p>Yeah, that's why I drew the line the way I did, on \"you <strong>probably</strong> shouldn't do the thing that <strong>adds</strong> NaNs if you want code to 'not go boom', but it probably wouldn't be \"\"\"unsound\"\"\" in the technical sense.\"</p>",
        "id": 271040521,
        "sender_full_name": "Jubilee",
        "timestamp": 1644267367
    }
]