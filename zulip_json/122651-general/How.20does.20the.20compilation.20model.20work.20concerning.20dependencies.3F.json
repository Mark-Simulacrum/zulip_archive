[
    {
        "content": "<p>Hello everyone, I'm not an compiler expert so forgive me when my question seems somewhat ignorant.<br>\nI was wondering, in the overall topic \"of compilation times\" and rust general issues with that, how much effort is being done in compilation scope reduction, especially in the interaction across crates. I was pointed towards the query system for the general approach on how the compiler resolves dependent expressions, but how does this interact across module and crate borders?</p>\n<p>More specifically, is the compilation bottom-up? Meaning, starting from e.g. a binary that uses several libraries, determing in a minimalistic way, what exact functions, types, etc. are required to compile the binary?</p>\n<p>Preferrably I'd like to read up on the details of how that works, so any pointers would be greatly appreciated.</p>",
        "id": 250226258,
        "sender_full_name": "Armin Kazmi",
        "timestamp": 1629564237
    },
    {
        "content": "<p>The query system is not used across crates</p>",
        "id": 250226329,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629564308
    },
    {
        "content": "<p>All library crates are compiled into rlib files that are required to build downstream crates, so the compilation model is fairly standard in that sense</p>",
        "id": 250226411,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629564401
    },
    {
        "content": "<p>There is one optimization that we use: build pipelining. rustc can start compiling a downstream crate even before a dependency is <em>fully</em> compiled to an rlib, since only metadata emitted by the compiler is required to build downstream crates.</p>",
        "id": 250226473,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629564469
    },
    {
        "content": "<p>So while rustc still optimizes and generates machine code for a library's functions, Cargo can already spawn another rustc that builds a downstream crate. Just linking won't work until all code has been generated.</p>",
        "id": 250226558,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629564558
    },
    {
        "content": "<p>What kind of metadata?</p>",
        "id": 250226564,
        "sender_full_name": "Armin Kazmi",
        "timestamp": 1629564573
    },
    {
        "content": "<p>Metadata that describes the entire API surface of a crate, basically.</p>",
        "id": 250226629,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629564615
    },
    {
        "content": "<p>But why is it designed in that way? I mean, wouldn't a bottom-up approach enable minimalisation that the current direction does not allow?<br>\nIf I understand you correctly, the metadata needs to be built. Thefore the crate needs to be <em>fully</em> built as well (with the exception of linking). At that stage, a lot of work is already wasted, because e.g. functions and code have been compiled that will never be consumed and used.</p>",
        "id": 250226709,
        "sender_full_name": "Armin Kazmi",
        "timestamp": 1629564739
    },
    {
        "content": "<p>Quoting from here: <a href=\"https://rustc-dev-guide.rust-lang.org/queries/query-evaluation-model-in-detail.html\">https://rustc-dev-guide.rust-lang.org/queries/query-evaluation-model-in-detail.html</a></p>\n<blockquote>\n<p>As of January 2021, this input data consists mainly of the HIR map, upstream crate metadata, and the command-line options the compiler was invoked with; but in the future inputs will just consist of command-line options and a list of source files -- the HIR map will itself be provided by a query which processes these source files.</p>\n</blockquote>\n<p>Apaprently this already goes in the direction I mean, when that source file gathering happens across crates.</p>",
        "id": 250227144,
        "sender_full_name": "Armin Kazmi",
        "timestamp": 1629565316
    },
    {
        "content": "<p>It was designed that way because it is how most (all?) existing compilation models work. There has been some discussion on enabling multi-crate compilation sessions within the same rustc instance, which sounds like what you're suggesting, but that is a lot of work.</p>",
        "id": 250227187,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629565340
    },
    {
        "content": "<p>That quote talks about end-to-end queries, not building multiple crates at once, I think</p>",
        "id": 250227319,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629565527
    },
    {
        "content": "<p>Currently the query system is only used after HIR is built, the plan is to use it throughout the entire compiler</p>",
        "id": 250227385,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629565572
    },
    {
        "content": "<p>It could mean that of course, but the 2nd listing removed \"upstream crate metadata\".</p>",
        "id": 250227387,
        "sender_full_name": "Armin Kazmi",
        "timestamp": 1629565574
    }
]