[
    {
        "content": "<p>Is there a stream/thread we are talking about <a href=\"https://github.com/rust-lang/rust/pull/81782#issuecomment-780193354\">https://github.com/rust-lang/rust/pull/81782#issuecomment-780193354</a>? cc <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <br>\nI see wg-performance is about the perf of compile times, not generated code</p>",
        "id": 227180852,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613927580
    },
    {
        "content": "<p>Not currently, but that is really a compile times point I think? i.e., jemalloc for rustc is the only thing that thread touches</p>",
        "id": 227180886,
        "sender_full_name": "simulacrum",
        "timestamp": 1613927621
    },
    {
        "content": "<p>oh i see. where does rustc make jemalloc the default allocator for  binaries it produces? <a href=\"https://github.com/rust-lang/rust/blob/master/RELEASES.md#compiler-17\">https://github.com/rust-lang/rust/blob/master/RELEASES.md#compiler-17</a> suggests that jemalloc is the default on some platforms, have we checked if we correctly use sdallocx there? (interestingly, jemallocator appears to do the correct thing? <a href=\"https://docs.rs/jemallocator/0.3.2/src/jemallocator/lib.rs.html#100\">https://docs.rs/jemallocator/0.3.2/src/jemallocator/lib.rs.html#100</a>)</p>",
        "id": 227181262,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613928032
    },
    {
        "content": "<p>Do we like...override the libc symbols with jemalloc ones? <a href=\"https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/alloc.rs#L42\">https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/alloc.rs#L42</a></p>",
        "id": 227181644,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613928429
    },
    {
        "content": "<p>omg i read that competeeelty wrong, it said switched FROM jemalloc to default system allocator lol<br>\nThat said, we should def do a perf run where we use sdallocx. I wonder why we don't just use #[global_allocator] inside the rustc main</p>",
        "id": 227181873,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613928667
    },
    {
        "content": "<p>one reason is there's the fear there's cases where we allocate memory in rustc/free in llvm and vice versa. but also overriding the global C allocator. i don't know if this fear is founded, but it's been cited several times in the past.</p>\n<p>that said, overridign the system malloc is not really viable on some platforms (on macos — see some of my comments here: <a href=\"https://github.com/purpleprotocol/mimalloc_rust/issues/41\">https://github.com/purpleprotocol/mimalloc_rust/issues/41</a>)... so #[global_allocator] would be better.</p>",
        "id": 227183192,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613930135
    },
    {
        "content": "<p>should we try swapping the way we do it now with #[global_allocator] = jemallocator and see if anything breaks?</p>",
        "id": 227185621,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613932631
    },
    {
        "content": "<p><code>#[global_allocator]</code> doesn't work when dynamically linking to <a href=\"http://libstd.so\">libstd.so</a>.</p>",
        "id": 227189043,
        "sender_full_name": "bjorn3",
        "timestamp": 1613936239
    },
    {
        "content": "<p>so moving rustc to use jemalloc is going to require like...<code>cfg(jemalloc_sys)</code> in the unix GlobalAlloc impl?</p>",
        "id": 227194248,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613941845
    },
    {
        "content": "<p><code>rustc</code> can be configured to use jemalloc itself -- some of the CI dist builders do this</p>",
        "id": 227195255,
        "sender_full_name": "cuviper",
        "timestamp": 1613943001
    },
    {
        "content": "<p>But it was an explicit decision that the default for user code should be the system allocator</p>",
        "id": 227195312,
        "sender_full_name": "cuviper",
        "timestamp": 1613943041
    },
    {
        "content": "<p>Oh, I misunderstood @_bjorn3's point... that is tricky.</p>",
        "id": 227195525,
        "sender_full_name": "cuviper",
        "timestamp": 1613943297
    },
    {
        "content": "<p>Is the way rustc currently uses jemalloc to basically override the libc symbols? if thats true...then switching to <code>sdallocx</code> is going to be....not ez</p>",
        "id": 227195728,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613943549
    },
    {
        "content": "<p>yes</p>",
        "id": 227195742,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1613943591
    },
    {
        "content": "<p>wouldn't that require make the <a href=\"http://libstd.so\">libstd.so</a> depend on a libc where we have add the sdallocx symbol or something?</p>",
        "id": 227195934,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613943786
    },
    {
        "content": "<p>Perhaps it could have weak-null symbols of its own</p>",
        "id": 227196248,
        "sender_full_name": "cuviper",
        "timestamp": 1613944104
    },
    {
        "content": "<p>Oh weak symbols is an interesting idea...</p>",
        "id": 227198001,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1613945192
    },
    {
        "content": "<p>My feeling is that if we aren't on sized deallocation in the compiler then that is a bug that needs fixing. We don't want to leave compiler performance on the table and sized deallocation is algorithmically a significant win for typical malloc techniques.</p>",
        "id": 227480311,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1614105178
    },
    {
        "content": "<p>Do you happen to have on hand something that explains why it's so important? I'm not disagreeing, I just want to read about it.</p>",
        "id": 227482916,
        "sender_full_name": "Laurențiu",
        "timestamp": 1614106110
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu Nicola</span> <a href=\"https://github.com/jemalloc/jemalloc/issues/28\">https://github.com/jemalloc/jemalloc/issues/28</a> links to <a href=\"https://isocpp.org/files/papers/n3778.html\">https://isocpp.org/files/papers/n3778.html</a> which says<br>\n\"Modern memory allocators often allocate in size categories, and, for space efficiency reasons, do not store the size of the object near the object.\" which i suppose means sized deallocation don't have to traverse a different datastructure to find the size</p>",
        "id": 227483412,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1614106304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"203546\">Laurențiu Nicola</span> <a href=\"#narrow/stream/122651-general/topic/where.20do.20we.20talk.20about.20performance.20(of.20generated.20code).3F/near/227482916\">said</a>:</p>\n<blockquote>\n<p>Do you happen to have on hand something that explains why it's so important? I'm not disagreeing, I just want to read about it.</p>\n</blockquote>\n<p>Daniel Micay was a big advocate of this (rightly so IMO) and had some performance numbers as I recall. I don't have them offhand but they were significant.</p>",
        "id": 227488197,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1614108123
    },
    {
        "content": "<p>And yeah, the reason is that the allocator doesn't have to go search some sort of data structure that maps blocks to sizes. It's wasteful to do that at runtime since the compiler already statically knows the size of what's to be deallocated.</p>",
        "id": 227491186,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1614109331
    },
    {
        "content": "<p>Ah, I see. I guess it was storing the size next to the block in my mental model.</p>",
        "id": 227491342,
        "sender_full_name": "Laurențiu",
        "timestamp": 1614109392
    },
    {
        "content": "<p>mimalloc manages without it, but yeah, jemalloc needs the size. One of the reasons I prefer using mimalloc is that it's fully compatible with the normal malloc/free interface and doesn't really require using extensions to get good perf</p>",
        "id": 227491438,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614109439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/122651-general/topic/where.20do.20we.20talk.20about.20performance.20(of.20generated.20code).3F/near/227491438\">said</a>:</p>\n<blockquote>\n<p>mimalloc manages without it, but yeah, jemalloc needs the size. One of the reasons I prefer using mimalloc is that it's fully compatible with the normal malloc/free interface and doesn't really require using extensions to get good perf</p>\n</blockquote>\n<p>Note that Daniel's position was that sized deallocation opens the door to some potential faster allocator designs, which seems interesting</p>",
        "id": 227493393,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1614110241
    },
    {
        "content": "<p>Right, the general rust allocator api supports this — in fact global and (unstable) local allocators <em>only</em> allow for sized deallocation.</p>\n<p>At the end of the day though, a decent chunk of rustc's allocations come from LLVM, which will only use plain <code>free</code> (or delete sometimes), and so we're kinda bounded by that in some respect (that said It also seems hard to switch rustc itself generally to use a sized deallocation).</p>\n<p>If LLVM didn't do this, and had an easier way to swap allocators other than \"swap the libc allocator/override global operator new/delete\", we'd have a lot more flexibility in how rustc can use allocators. But, it's not really a trivial change (I looked into it at once point).</p>",
        "id": 227496598,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614111475
    },
    {
        "content": "<p>IIRC the reason jemalloc isn't registered as the rust-side global allocator in rustc is that rustc is dynamically linked and the infrastructure isn't built to support that well?</p>",
        "id": 227498227,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614112124
    },
    {
        "content": "<p>i remember hearing there was also concerns about memory allocated in rustc, deallocated in llvm, or vice versa. i would consider this a bug, but <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> mentioned it at one point in the past.</p>",
        "id": 227498344,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614112187
    },
    {
        "content": "<p>that said, generating IR allocates a bunch IIRC, and so it would be unfortunate for all those allocations not to use a better allocator.</p>",
        "id": 227498497,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614112243
    },
    {
        "content": "<p>I would be very surprised we did this (allocate in rustc, deallocate in LLVM) except maybe for cstrings we pass into llvm?</p>",
        "id": 227498715,
        "sender_full_name": "nagisa",
        "timestamp": 1614112345
    },
    {
        "content": "<blockquote>\n<p>i remember hearing there was also concerns about memory allocated in rustc, deallocated in llvm, or vice versa. </p>\n</blockquote>\n<p>Would that be a problem as long as C symbols are overridden so that they point to the same allocators as <code>#[global_allocator]</code>?</p>",
        "id": 227499705,
        "sender_full_name": "The 8472",
        "timestamp": 1614112819
    },
    {
        "content": "<p>No, but at that point there's less of a benefit. I guess it means rust allocations would get to used the sized deallocation api though.</p>",
        "id": 227501000,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614113431
    },
    {
        "content": "<p>Yeah, the point of setting the global allocator would be to use the sized API, but if LLVM is just passing the pointers to free those allocations couldn't use that API</p>",
        "id": 227504876,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614115080
    },
    {
        "content": "<p>But if the set of allocations that work like that are small, then it'd be easy to explicitly malloc in those instances</p>",
        "id": 227505101,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614115164
    },
    {
        "content": "<p>One question I do have -- is the sized API perhaps usable in an optional way? Intuitively you don't get all the wins if you have to support both in the allocator, but it seems like some amount of traversal/cost of deallocation may be avoidable if that information is provided</p>",
        "id": 227514814,
        "sender_full_name": "simulacrum",
        "timestamp": 1614118803
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span>  my understanding is overriding the symbols is how rustc uses jemalloc today, but jemalloc exposes a non-standard api called sdallocx which is free that takes the size as well</p>\n<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> yeah thats my understanding as well, we aren't sure if global_allocator would work in rust</p>\n<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> I think that would mean we would need to optionally use sdallocx here: <a href=\"https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/alloc.rs#L42\">https://github.com/rust-lang/rust/blob/master/library/std/src/sys/unix/alloc.rs#L42</a> somehow? unless i am totally off about how rustc uses jemalloc?</p>",
        "id": 227515809,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1614119259
    },
    {
        "content": "<p>If rustc were to use jemalloc as the global allocator it'd do it through something like the jemallocator crate, not by modifying the System type</p>",
        "id": 227515985,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614119333
    },
    {
        "content": "<p>right, I'm trying to understand if we actually need to know if we don't pass pointers to llvm which calls free</p>",
        "id": 227516055,
        "sender_full_name": "simulacrum",
        "timestamp": 1614119369
    },
    {
        "content": "<p>i.e., if we override the global allocator like we do today in rustc (via symbols) and also do so via #[global_allocator] (after fixing the dynamic linking issues), would that be fine?</p>",
        "id": 227516157,
        "sender_full_name": "simulacrum",
        "timestamp": 1614119408
    },
    {
        "content": "<p>I believe so? any extraneous free calls in llvm or whatever would be fine but most deallocs would go through the global_allocator dealloc impl that correctly uses sdallocx<br>\nI can't think of a reason why doing both would break anything, as long as we know the symbols in both cases are the same</p>",
        "id": 227518441,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1614120544
    },
    {
        "content": "<p>free calls in llvm of memory allocated by the sized APIs in rustc would be very not fine</p>",
        "id": 227518498,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614120576
    },
    {
        "content": "<p>oh actually maybe it is fine</p>",
        "id": 227518693,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614120663
    },
    {
        "content": "<p>it doesn't look like jemalloc's man page says anything about the nonstandard API being totally separate from the standard API</p>",
        "id": 227518809,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614120722
    },
    {
        "content": "<p>it should be fine</p>",
        "id": 227518974,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614120797
    },
    {
        "content": "<p>though the existence of dallocx is a bit worrying WRT the flags rather than the size</p>",
        "id": 227519055,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614120844
    },
    {
        "content": "<p>but I don't know if alignment in particular is important there rather than the tcache/arena or whatever else</p>",
        "id": 227519137,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614120867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243558\">Steven Fackler</span> <a href=\"#narrow/stream/122651-general/topic/where.20do.20we.20talk.20about.20performance.20(of.20generated.20code).3F/near/227518498\">said</a>:</p>\n<blockquote>\n<p>free calls in llvm of memory allocated by the sized APIs in rustc would be very not fine</p>\n</blockquote>\n<p>it would be nice if we could be sure we dont do this, since that would allow using a better allocator at least for rust code on platforms where the global override of libc malloc isnt viable (macos, for example)</p>",
        "id": 227519395,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614120984
    },
    {
        "content": "<p>you can override macos's allocator via zone stuff, which jemalloc does</p>",
        "id": 227519437,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614121019
    },
    {
        "content": "<p>the performance there isn't great, and even then you have to be able to handle a lot of weird edge cases. for example, your alloc_size api has to return 0 for allocations performed by different zones (since free calls each zone in the zone list until it finds a zone that \"claims\" the pointer). this tends to break external allocators</p>",
        "id": 227519710,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614121135
    },
    {
        "content": "<p>and system apis will allocate out of specific zones and then free using the normal free, for example: <a href=\"https://github.com/opensource-apple/objc4/blob/master/runtime/hashtable2.mm#L62-L68\">https://github.com/opensource-apple/objc4/blob/master/runtime/hashtable2.mm#L62-L68</a>. some of these allocations come very early, e.g. during loading by dyld, so you can't rely on always being the default zone in general.</p>",
        "id": 227519958,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614121224
    },
    {
        "content": "<p>should this thread be moved to t-compiler/performance?</p>",
        "id": 227685403,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1614205611
    }
]