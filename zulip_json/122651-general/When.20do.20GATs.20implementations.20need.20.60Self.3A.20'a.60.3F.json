[
    {
        "content": "<p>It's especially annoying when the concrete associated type doesn't have lifetimes.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">token</span>::<span class=\"n\">Exchange</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Validator</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">R</span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">char</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">exchange</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">idx</span>: <span class=\"kt\">char</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">idx</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 273416470,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645984575
    },
    {
        "content": "<p>What is the rationale in general for requiring the full list of <code>where</code> bounds in a GAT impl, instead of implicitly copying them from the trait definition?</p>",
        "id": 273418006,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1645986594
    },
    {
        "content": "<p>Some background in <a href=\"https://github.com/rust-lang/rust/issues/87479\">https://github.com/rust-lang/rust/issues/87479</a></p>",
        "id": 273420846,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645990210
    },
    {
        "content": "<p>Also in general... \"that's how Rust does it\"</p>",
        "id": 273420970,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645990266
    },
    {
        "content": "<p>But I think <a href=\"https://rust-lang.github.io/rfcs/2089-implied-bounds.html\">implied_bounds</a> is relevant to your point.</p>",
        "id": 273421042,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1645990334
    },
    {
        "content": "<p>Yeah, I think implied_bounds is closer to what I was talking about. To me, there would appear to be no issue if <code>where Self: 'a</code> was always required in the trait definition but was optional in the impl block.</p>",
        "id": 273423422,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1645993800
    },
    {
        "content": "<p>So, I think what you are hinting at, <span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span>, is that being able to name an assoc type with no clause is actually a <em>more general</em> definition than what the trait requires, and thus, it should be compatible with that narrower version.</p>\n<p>Similarly to</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&lt;'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">r</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">r</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&lt;'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;'</span><span class=\"na\">any</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">any</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>compiling.</p>\n<p>The trait:</p>\n<blockquote>\n<p>You must give me an impl able to handle <code>'r</code>.</p>\n</blockquote>\n<p>The implementor:</p>\n<blockquote>\n<p>I won't bother with that fine-grained level of detail. Would handling <em>any</em> lifetime suit you?</p>\n</blockquote>\n<p>The trait:</p>\n<blockquote>\n<p>Even better!</p>\n</blockquote>\n<hr>\n<p>Back to GATs, the idea of that <code>where Self : 'r</code> bound stems from the trait definition trying to play nice with implementors. Indeed, given</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"o\">&lt;'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">r</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">r</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>by virtue of having that <code>&amp;'r … Self</code>, we know that the <code>Self : 'r</code> range will be the only acceptable range / set of applicable lifetimes. So let's at least use that when defining <code>Self::Item&lt;'r&gt;</code>. Indeed, imagine an \"identity lending iterator\":</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">IdentityLendingIterator</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">IdentityLendingIterator</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">LendingIterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"o\">&lt;'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">r</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">r</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// where</span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Item</span><span class=\"o\">&lt;'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">r</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">It</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Error, can't name `&amp;'r mut It` if you can't guarantee that `It : 'r` holds.</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But, obviously, given the <code>fn next</code> usage, <em>we could guarantee it</em>! Hence why the trait definition is able to <em>provide</em> <code>where Self : 'r</code> as a bonus / gift.</p>\n<p>The issue then stems from the fact that this <em>gift</em> suddenly becomes a mandatory one for downstream implementors to mention, even for those who don't need that extra property.</p>\n<p><strong>Given the <code>Trait&lt;'r&gt;</code> example above, it would make sense for the <code>where Self : 'r</code> kind of clauses not to be <em>necessary</em> either, by providing a <em>more general</em> (generic) associated type definition</strong>; (make it be needed only when the associated type itself makes use of it for WF-ness).</p>",
        "id": 273480813,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646050837
    },
    {
        "content": "<p>Ah, nothing that intelligent from me. I mean it on a more basic level:</p>\n<ul>\n<li>my trait’s associated type has <code>Self: 'a</code></li>\n<li>not all implementations need to restate that bound</li>\n</ul>\n<p>I understand that we are being conservative in requiring the bounds when we don’t strictly need it. </p>\n<p>What I’m missing: what are the conditions where I <strong>don’t</strong> need to restate the bound?</p>",
        "id": 273487685,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646054731
    },
    {
        "content": "<p>So you're saying that repeating an explicit <code>where</code> bound could be unnecessary when it is covered by a bound implied by the <code>impl</code> or <code>type</code> declaration?</p>",
        "id": 273489542,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1646055620
    },
    {
        "content": "<p>I'd be somewhat wary of that, since implied bounds seem somewhat fragile currently (e.g., with <a href=\"https://github.com/rust-lang/rust/issues/25860\">rust-lang/rust#25860</a>)</p>",
        "id": 273489894,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1646055824
    },
    {
        "content": "<p>My current mental model is: we don’t need to restate <code>Self: 'a</code> when the implementing type doesn’t have generics.</p>",
        "id": 273490691,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1646056166
    },
    {
        "content": "<p>I think there are two similar but different questions here: When/why do we need <code>Self: 'a</code> bounds in the <em>trait</em> and when/why do we need <code>Self: 'a</code> bounds in the <em>impl</em></p>",
        "id": 273520525,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646067617
    },
    {
        "content": "<p>For the first question, the answer is: We require bounds that are provable when constructing the GAT in the methods of the trait. (So, if you have <code>fn foo(&amp;'a self) -&gt; Self::Gat&lt;'a&gt;</code> then we require <code>Self: 'a</code>)</p>",
        "id": 273520791,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646067678
    },
    {
        "content": "<p>This is done to give \"maximum\" flexibility to impls in decided what types can be chosen</p>",
        "id": 273520997,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646067752
    },
    {
        "content": "<p>Any bounds on the trait must be repeated on the impl when without them you cannot prove the bounds on trait.</p>",
        "id": 273521106,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646067812
    },
    {
        "content": "<p>In theory, we could \"imply\" these - but like with <code>unsafe</code> in impls, we might want to one day allow omitting these requirements in impls</p>",
        "id": 273521245,
        "sender_full_name": "Jack Huey",
        "timestamp": 1646067876
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> you <em>currently</em> don't need to repeat the <code>where Self : 'a</code> bounds when, for a given concrete impl, <code>Self</code> is some type that is known to be <code>'static</code>. Indeed, in that case <code>Self : 'a</code> holds for literally any lifetime, and thus becomes a trivial(ly true) bound.</p>\n<p>In my previous comment, I advocated for the bound technically not being necessary when the actually provided GAT does not make use of the bound, <em>e.g.</em>, when the stuff behind <code>'a</code> (if any) is already known to be usable-within-<code>'a</code> (<em>e.g.</em>, <code>u32</code>, or <code>&amp;'a str</code>).</p>\n<p>Finally, for when the bound is both non-trivial, and used (<em>e.g.</em>, <code>&amp;'a Self</code> assoc type, for a not-ncessarily-<code>'static</code> <code>Self</code>), there is the case of \"if the trait provides the bound, why is it necessary for the downstream impl to repeat it\". I know that Rust, in general, often requires that kind of repetitions, even outside of GATs, so I don't see them being elidable in this situation.</p>",
        "id": 273523646,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646068942
    }
]