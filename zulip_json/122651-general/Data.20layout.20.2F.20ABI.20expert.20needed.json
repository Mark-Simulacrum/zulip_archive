[
    {
        "content": "<p>Could someone who knows stuff about <code>repr(C)</code> and the C ABI take a look at <a href=\"https://github.com/rust-lang/rust/issues/82101\">https://github.com/rust-lang/rust/issues/82101</a> and <a href=\"https://github.com/rust-lang/rust/issues/82100\">https://github.com/rust-lang/rust/issues/82100</a>? I am not sure whom to ping for issues like this... Cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> <span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span></p>",
        "id": 227165249,
        "sender_full_name": "RalfJ",
        "timestamp": 1613911218
    },
    {
        "content": "<p>I think unsound is the correct term for this kind of bug. It can cause UB when linking to C code using <code>#[repr(C)]</code> enums that should be identical to the enums on the C side, but aren't due to the ABI incompatbility.</p>",
        "id": 227165422,
        "sender_full_name": "bjorn3",
        "timestamp": 1613911388
    },
    {
        "content": "<p>That might be</p>",
        "id": 227165497,
        "sender_full_name": "RalfJ",
        "timestamp": 1613911458
    },
    {
        "content": "<p>I am not familiar with the memory layout used by the C abi on the various platforms, so I won't be of much more help.</p>",
        "id": 227165502,
        "sender_full_name": "bjorn3",
        "timestamp": 1613911486
    },
    {
        "content": "<p>I was more hoping someone could confirm whether indeed rustc is implementing the C ABI incorrectly here, which seems like a critical bug regardless of whether it's I-unsound or not</p>",
        "id": 227165504,
        "sender_full_name": "RalfJ",
        "timestamp": 1613911491
    },
    {
        "content": "<p>I think they are similar to <a href=\"https://github.com/rust-lang/rust/issues/89116\">#89116</a>, and <code>T-lang</code> have already made a <a href=\"https://github.com/rust-lang/rust/issues/81996#issuecomment-780047179\">decision</a> there.</p>",
        "id": 227165870,
        "sender_full_name": "hyd-dev",
        "timestamp": 1613911927
    },
    {
        "content": "<p>As per <a href=\"https://github.com/rust-lang/rust/issues/81996\">https://github.com/rust-lang/rust/issues/81996</a> its not entirely clear what's our definition of <code>repr(c)</code> is in the first place. If its \"exactly what the 'native' C compiler does\", then yes, our C ABI impl is not correct. If its \"what the 'native' ABI document documents\" then at least <a href=\"https://github.com/rust-lang/rust/issues/82101\">#82101</a> is in a debatable state.</p>",
        "id": 227165889,
        "sender_full_name": "nagisa",
        "timestamp": 1613911946
    },
    {
        "content": "<p>A number of the issues filled by mahkoh involves code that's brushing against implementation-defined behaviour.</p>",
        "id": 227165913,
        "sender_full_name": "nagisa",
        "timestamp": 1613912012
    },
    {
        "content": "<p>In my memory we have considered egregious C ABI mismatches (like the <a href=\"https://github.com/rust-lang/rust/issues/82100\">#82100</a>) a soundness issue because they would make \"correct\" unsafe code not behave the way it should.</p>",
        "id": 227166127,
        "sender_full_name": "nagisa",
        "timestamp": 1613912257
    },
    {
        "content": "<p>For <a href=\"https://github.com/rust-lang/rust/issues/82101#issuecomment-782852942\">https://github.com/rust-lang/rust/issues/82101#issuecomment-782852942</a>:</p>\n<blockquote>\n<p>Can't this lead to types whose alignment is larger than their size? What happens in C when you put these into an array?</p>\n</blockquote>\n<p>I don't understand what clang is doing... <a href=\"https://godbolt.org/z/156h4M\">https://godbolt.org/z/156h4M</a></p>",
        "id": 227167345,
        "sender_full_name": "hyd-dev",
        "timestamp": 1613913495
    },
    {
        "content": "<p>It looks like <code>sizeof(enum Enum) = 4</code> (the actual size of the type) but <code>sizeof(enum Enum[n])</code> is <code>4 * n</code> rounded up to 128 (the alignment of the type). In particular the elements of the array are densely packed, they are not 128 byte aligned</p>",
        "id": 227169944,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613916486
    },
    {
        "content": "<p>Is this behavior actually defined by any standard? Because it's pretty nuts, I hope we don't have to be bug-ward compatible</p>",
        "id": 227170002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613916578
    },
    {
        "content": "<blockquote>\n<p><code>repr(C)</code> is intended to mean \"match the default C ABI for the target\"</p>\n</blockquote>\n<p>Which to me says it should be bug-ward compatible with the target.</p>",
        "id": 227171802,
        "sender_full_name": "Chris Denton",
        "timestamp": 1613918549
    },
    {
        "content": "<p>However, an alignment on a C enum is nonsensical, no? The enum must have the same representation (size/alignment) as its underlying type. But it can't have the same alignment if the alignment of the enum itself is changed. So there's a conflict to be resolved? Or ignored, I guess.</p>",
        "id": 227171803,
        "sender_full_name": "Chris Denton",
        "timestamp": 1613918552
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227169944\">said</a>:</p>\n<blockquote>\n<p>It looks like <code>sizeof(enum Enum) = 4</code> (the actual size of the type) but <code>sizeof(enum Enum[n])</code> is <code>4 * n</code> rounded up to 128 (the alignment of the type). In particular the elements of the array are densely packed, they are not 128 byte aligned</p>\n</blockquote>\n<p>so the array elements violate alignment then...?</p>",
        "id": 227177156,
        "sender_full_name": "RalfJ",
        "timestamp": 1613923602
    },
    {
        "content": "<p>increasing the alignment is not invalid or contradictory with the request. The weird thing is that <code>sizeof(enum Enum)</code> returns a size… rather than stride.</p>",
        "id": 227177422,
        "sender_full_name": "nagisa",
        "timestamp": 1613923871
    },
    {
        "content": "<p>if you ask <code>_Alignof(enum Enum)</code> you get 128 for that example.</p>",
        "id": 227177536,
        "sender_full_name": "nagisa",
        "timestamp": 1613923977
    },
    {
        "content": "<p>In rust <code>std::mem::size_of</code> returns the stride, unlike in C… it seems?</p>",
        "id": 227177572,
        "sender_full_name": "nagisa",
        "timestamp": 1613924003
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"260325\">Chris Denton</span> <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227171802\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p><code>repr(C)</code> is intended to mean \"match the default C ABI for the target\"</p>\n</blockquote>\n<p>Which to me says it should be bug-ward compatible with the target.</p>\n</blockquote>\n<p>The C ABI is generally specified by a specification document and not an arbitrary implementation of it. The documents sometimes fail to specify certain situations (e.g. MSVC comes to mind as not specifying the 128 bit integers or their interactions in calling conventions). So the T-lang's take on the problem is still ambiguous.</p>",
        "id": 227177821,
        "sender_full_name": "nagisa",
        "timestamp": 1613924234
    },
    {
        "content": "<p>Another example and the topic of the issue in questino of this is ZSTs. They are not permitted by the primary implementation on msvc targets (visual studio/msvc toolchain) at all, and not specified by the ABI documents Microsoft publishes on the topic. And so, what should Rust's behaviour there be?</p>",
        "id": 227177904,
        "sender_full_name": "nagisa",
        "timestamp": 1613924331
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227177572\">said</a>:</p>\n<blockquote>\n<p>In rust <code>std::mem::size_of</code> returns the stride, unlike in C… it seems?</p>\n</blockquote>\n<p>in Rust, size == stride. I thought the same was true for C.</p>",
        "id": 227178458,
        "sender_full_name": "RalfJ",
        "timestamp": 1613924943
    },
    {
        "content": "<p>However, if an array with n elements has size <code>4 * n</code> rounded up to something... then the stride is 4, right?</p>",
        "id": 227178489,
        "sender_full_name": "RalfJ",
        "timestamp": 1613925001
    },
    {
        "content": "<p>Hm, <code>sizeof(struct { uint64_t foo; uint8_t bar; });</code> returns 16... That seems awfully stride-like</p>",
        "id": 227178911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1613925474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227178458\">said</a>:</p>\n<blockquote>\n<p>in Rust, size == stride. I thought the same was true for C.</p>\n</blockquote>\n<p>That's what I thought, so what clang does makes no sense to me...<br>\nIn that example, <code>sizeof(Enum[1]) != sizeof(Enum)</code>: <a href=\"https://godbolt.org/z/eGEdhj\">https://godbolt.org/z/eGEdhj</a></p>",
        "id": 227178964,
        "sender_full_name": "hyd-dev",
        "timestamp": 1613925500
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227178458\">said</a>:</p>\n<blockquote>\n<p>in Rust, size == stride. I thought the same was true for C.</p>\n</blockquote>\n<p>Wouldn't any instance where <code>sizeof(T) &lt; _Alignof(T)</code> make size != stride? That's what happening with clang code here.</p>",
        "id": 227179093,
        "sender_full_name": "nagisa",
        "timestamp": 1613925701
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 227179172,
        "sender_full_name": "nagisa",
        "timestamp": 1613925747
    },
    {
        "content": "<p>Ah I see, the elements are \"packed\" in the array. weird lol</p>",
        "id": 227179182,
        "sender_full_name": "nagisa",
        "timestamp": 1613925764
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227179093\">said</a>:</p>\n<blockquote>\n<p>Wouldn't any instance where <code>sizeof(T) &lt; _Alignof(T)</code> make size != stride? That's what happening with clang code here.</p>\n</blockquote>\n<p>To my knowledge, no C/C++ compiler other than clang does that.</p>",
        "id": 227179271,
        "sender_full_name": "hyd-dev",
        "timestamp": 1613925866
    },
    {
        "content": "<blockquote>\n<p>Wouldn't any instance where sizeof(T) &lt; _Alignof(T) make size != stride? That's what happening with clang code here.</p>\n</blockquote>\n<p>Yes (except for size==0). Which is why I said above that size is always a(n integer) multiple of alignment... or at least, it should be, in languages with size==stride.</p>",
        "id": 227246035,
        "sender_full_name": "RalfJ",
        "timestamp": 1613989820
    },
    {
        "content": "<p>And C is such a language... ptr arithmetic on a <code>T *ptr</code> moves <code>ptr</code> in multiples of <code>sizeof(T)</code>, after all. That only makes sense if stride==size.</p>",
        "id": 227246487,
        "sender_full_name": "RalfJ",
        "timestamp": 1613990042
    },
    {
        "content": "<p>I agree that we should follow the C ABI for a target as specified and not as implemented, unless there is literally only one implementation and we do not expect another to arise, or if literally all implementations we are aware of share a matching bug, in which case then being bug-for-bug compatible starts to make sense. This doesn't mean we shouldn't keep an eye on what the clang extensions are doing, just that we shouldn't assume that we need to match it.</p>\n<p>We may need to introduce better tools for interacting with such, ah, <strong>impressive</strong> choices by compilers, though, at least on the <code>unsafe</code> level.</p>",
        "id": 227333751,
        "sender_full_name": "Jubilee",
        "timestamp": 1614026455
    },
    {
        "content": "<p>well, in the case of, for example, the windows-MSVC target, there is literally one C compiler</p>",
        "id": 227336170,
        "sender_full_name": "Lokathor",
        "timestamp": 1614027520
    },
    {
        "content": "<p>I think it might make sense to prevent people from doing things with repr(C) that are wildly incompatible with C implementations, if real C code doesn't actually use them.</p>",
        "id": 227339478,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614028954
    },
    {
        "content": "<p>Does any real C code use enums with weird alignment settings?</p>",
        "id": 227339507,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614028970
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227339507\">said</a>:</p>\n<blockquote>\n<p>Does any real C code use enums with weird alignment settings?</p>\n</blockquote>\n<p>But then you get into the overloading issue, as I might want an Enum with a stable ABI with a weird alignment. I've used this before when I wanted to do weird tagging things.</p>",
        "id": 227354770,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1614035207
    },
    {
        "content": "<p>yeah, repr C being overloaded is the heart of the problem here. I think a split in purpose is what's called for.</p>",
        "id": 227357052,
        "sender_full_name": "Lokathor",
        "timestamp": 1614036322
    },
    {
        "content": "<p>I have used repr C many times in rust code but never for ABI compatibility with C, only for predictable C-ish layout with an actual specification. In these situations <code>repr(Rust)</code> isn't usable because the layout is not guaranteed so UB is always possible (although I'm not sure how often this breaks in practice), and actually taking the C compatibility thing seriously and implementing all these other compiler bugs would also be a move away from a stable specification, so I'm quite opposed to it. What fools we were to think that C was ABI compatible with C! <span aria-label=\"rolling on the floor laughing\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rolling on the floor laughing\">:rolling_on_the_floor_laughing:</span> </p>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> brought up on another thread that repr(C) is also the only allowed repr for extern functions (even Rust-to-Rust!), which means changing this may cause unfixable bugs. (Not all FFI is to actual C, it's sometimes just the common baseline of two non-C implementations.)</p>",
        "id": 227358325,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614037084
    },
    {
        "content": "<p>Indeed, i have a crate on <a href=\"http://crates.io\">crates.io</a> (well, version 0.0.2 of it) that would be broken by a change to how repr(C) currently does ZST values. And the theoretical purpose of the crate was exactly to make a stable way to pass slices into and out of \"C\" ABI functions.</p>",
        "id": 227360002,
        "sender_full_name": "Lokathor",
        "timestamp": 1614038091
    },
    {
        "content": "<p>Yes, if PhantomData becomes non-zst inside repr(C), i have a lot of broken FFI code.</p>",
        "id": 227360210,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614038203
    },
    {
        "content": "<p>PhantomData is a language item though, and a special case in many ways.</p>",
        "id": 227361728,
        "sender_full_name": "nagisa",
        "timestamp": 1614039048
    },
    {
        "content": "<p>e.g. IIRC it does not influence the alignment of the containing ADT, like other ZSTs would.</p>",
        "id": 227361747,
        "sender_full_name": "nagisa",
        "timestamp": 1614039063
    },
    {
        "content": "<p>and the thing is: this change <em>would not</em> show up in crater checking. Because the crate doesn't have a test to assert that the struct as a whole is the same size as two usize values, because <em>of course</em> that's the size, and repr(C) is stable, so of course i don't need to assert the size of the struct any more than i need to try asserting that usize and isize are the same size, or any other pedantic assertions.</p>",
        "id": 227361809,
        "sender_full_name": "Lokathor",
        "timestamp": 1614039103
    },
    {
        "content": "<p>Yeah, right now repr C is one of those things where if I'm doing unsafe mucking or C-style casting within Rust, I'll throw it on to guard against field reordering. Changing it would probably be a pretty big hidden break.</p>",
        "id": 227362705,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1614039629
    },
    {
        "content": "<blockquote>\n<p>We may need to introduce better tools for interacting with such, ah, impressive choices by compilers, though, at least on the unsafe level.</p>\n</blockquote>\n<p>For now I'd stick to the hypothesis that there's a clang bug here -- it makes no sense that a one-element array of a type would have a different size than the type itself... basically this can lead to UB even in completely innocent C code, like creating a two-element array, getting pointers to both elements and using them. At least one element will definitely not be aligned -&gt; UB. Even by C standards, this does not seem right.^^</p>",
        "id": 227396987,
        "sender_full_name": "RalfJ",
        "timestamp": 1614069335
    },
    {
        "content": "<p>repr(C) is definitely intended to be C-compatible, not just a generic stable layout. But we should indeed look into implementation bugs in clang and others, as well as actual usage in practice, before assuming we have to match every last quirk.</p>",
        "id": 227471027,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614101827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> If that's the case, then I'd like your initial reaction on two points:<br>\n1) PhantomData can continue to be special and still not affect repr C layout <em>even if</em> it turns out that other ZSTs will begin to affect repr C layout<br>\n2) We add a dedicated generic stable layout to the language that doesn't change based on the local C compiler's whims.</p>\n<p>and if the answer is \"I'll have to think about it\" that's okay too</p>",
        "id": 227475270,
        "sender_full_name": "Lokathor",
        "timestamp": 1614103364
    },
    {
        "content": "<p>(Currently in lang team meeting, expect slow asynchronous responses.)</p>",
        "id": 227475494,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614103444
    },
    {
        "content": "<p>To (2), I'm broadly speaking in favor of something like <code>repr(inorder)</code> or similar.</p>",
        "id": 227475578,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614103471
    },
    {
        "content": "<p>It'd need careful definition, but I'm in favor of the concept.</p>",
        "id": 227475874,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614103571
    },
    {
        "content": "<p>For (1), my initial reaction is that I'd <em>generally</em> like ZSTs to behave the same as they do in C by default, to the extent that the C ABI supports them, but I'm fine with making a mechanism for special things like <code>PhantomData</code> and <code>PhantomPinned</code> to opt for a different \"don't affect layout at all\" approach.</p>",
        "id": 227476554,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614103812
    },
    {
        "content": "<p>I personally think that <code>PhantomData</code> and <code>PhantomPinned</code> are not the ideal solutions, and I feel like there'd be a better way to express the same semantics without requiring (for instance) a phantom value to be provided at construction time. But until we have that better mechanism, we should allow those to behave differently than ZSTs in repr(C) if ZSTs in repr(C) stop being ZS.</p>",
        "id": 227476887,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614103939
    },
    {
        "content": "<p>We could come up with a new name for \"types that never affect layout at all\", and flag the phantom types accordingly.</p>",
        "id": 227476944,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614103970
    },
    {
        "content": "<p>Well also consider this: what happens to repr(transparent)?</p>\n<p>because if it's not changed to match how this C thing then you'll have a very subtle difference exactly where you have the most unsafe code.</p>\n<p>specifically</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// size = 1 usize</span>\n<span class=\"cp\">#[repr(transparent)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">CRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">p</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mark</span>: <span class=\"nc\">PhantomData</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// size = 2 usize</span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ThingX</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">x</span>: <span class=\"nc\">CRef</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">capacity</span>: <span class=\"kt\">usize</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// size = 3 usize!!</span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">ThingY</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mark</span>: <span class=\"nc\">PhantomData</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">capacity</span>: <span class=\"kt\">usize</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 227479038,
        "sender_full_name": "Lokathor",
        "timestamp": 1614104754
    },
    {
        "content": "<p>Given the purpose of <code>repr(transparent)</code>, I think we <em>have</em> to change it to match <code>repr(C)</code>.</p>",
        "id": 227479360,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614104865
    },
    {
        "content": "<p>Hmmm. Did the behavior of allowing ZSTs in <code>repr(transparent)</code> make it to stable?</p>",
        "id": 227479504,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614104912
    },
    {
        "content": "<p>yes, for quite some time</p>",
        "id": 227479635,
        "sender_full_name": "Lokathor",
        "timestamp": 1614104963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"127859\">@Taylor Cramer</span> made a couple of points that <em>should</em> address this completely.</p>",
        "id": 227480251,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614105157
    },
    {
        "content": "<p>there were some blog posts exploring the fact that \"zst, align 1\" becomes an API feature of your type because of <code>repr(transparent)</code></p>",
        "id": 227480271,
        "sender_full_name": "cuviper",
        "timestamp": 1614105166
    },
    {
        "content": "<p>(i.e. it's a breaking change to depart from that)</p>",
        "id": 227480494,
        "sender_full_name": "cuviper",
        "timestamp": 1614105240
    },
    {
        "content": "<p>To match the ABI of C, we just need to change the layout behavior of putting a <em><code>repr(C)</code></em> type that would be zero-sized inside another structure with <code>repr(C)</code>. And for that matter, the layout differences primarily seem to come up if you have a <code>repr(align)</code> alignment, or you're a <code>[T; 0]</code> zero-length array and thus have the alignment of <code>T</code>. <code>PhantomData</code> and <code>PhantomPinned</code> aren't <code>repr(C)</code> and aren't <code>repr(align)</code> and don't have an alignment.</p>",
        "id": 227480773,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614105323
    },
    {
        "content": "<p>I think if we apply that rule, we should get the correct behavior.</p>",
        "id": 227480862,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614105354
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> Does that sound to you like it'd do the right thing?</p>",
        "id": 227481080,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614105421
    },
    {
        "content": "<p>Concretely: <code>repr(Rust)</code> 1-ZST fields should not affect the layout of a <code>repr(C)</code> type in any way.</p>",
        "id": 227481416,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614105537
    },
    {
        "content": "<p>yes, if we dony change ZSTs in general, just the layout of repr(C) on an empty struct, that should make everyone happy</p>",
        "id": 227481478,
        "sender_full_name": "Lokathor",
        "timestamp": 1614105562
    },
    {
        "content": "<p>It sounds like we also need to fix the handling of alignment, but yeah, those fixes shouldn't change the handling of 1-ZSTs.</p>",
        "id": 227481680,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614105640
    },
    {
        "content": "<p>Supporting ZSTs in repr(transparent) was intentional to allow PhantomData/PhantomPinned/etc</p>",
        "id": 227482720,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1614106047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243558\">@Steven Fackler</span> Yeah, I remember that. IIRC, we <em>only</em> allow 1-ZSTs (ZSTs with alignment 1) in <code>repr(transparent)</code>.</p>",
        "id": 227483126,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614106195
    },
    {
        "content": "<p>That's what this followup was trying to cover: can we write a general rule that fixes <code>repr(C)</code> usage of ZSTs without breaking <code>PhantomData</code>/<code>PhantomPinned</code> and without special-casing those types.</p>",
        "id": 227483228,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614106225
    },
    {
        "content": "<p>And it seems like we can: we can fix the behavior of <code>repr(C)</code> zero-sized types inside <code>repr(C)</code> structures, while still maintaining the property that <code>repr(Rust)</code> 1-ZSTs don't affect layout at all.</p>",
        "id": 227483480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614106324
    },
    {
        "content": "<p>should we introduce a concept of 0-alignment?</p>",
        "id": 227484377,
        "sender_full_name": "nagisa",
        "timestamp": 1614106650
    },
    {
        "content": "<p>That'd be how you'd mark the types that don't have any effect at all in repr(c) types.</p>",
        "id": 227484516,
        "sender_full_name": "nagisa",
        "timestamp": 1614106691
    },
    {
        "content": "<p>Though I guess that does sound like a magic number kind of thing</p>",
        "id": 227484574,
        "sender_full_name": "nagisa",
        "timestamp": 1614106711
    },
    {
        "content": "<p>There's a bunch of places using <code>NonZeroUSize</code> to store alignments, so that scares me.</p>",
        "id": 227484589,
        "sender_full_name": "scottmcm",
        "timestamp": 1614106718
    },
    {
        "content": "<p>I said that and now I'm remembering I wrote code that assumes power-of-two (== nonzero) too.</p>",
        "id": 227484790,
        "sender_full_name": "nagisa",
        "timestamp": 1614106798
    },
    {
        "content": "<p>The <code>Layout</code> class as a whole gates all its constructors on <code>.is_power_of_two()</code>.</p>",
        "id": 227484882,
        "sender_full_name": "scottmcm",
        "timestamp": 1614106823
    },
    {
        "content": "<p>primarily around use of ctlz_nonzero cttz_nonzero</p>",
        "id": 227484903,
        "sender_full_name": "nagisa",
        "timestamp": 1614106829
    },
    {
        "content": "<p>(Aside: <a href=\"https://doc.rust-lang.org/nightly/core/num/struct.NonZeroUsize.html#method.trailing_zeros\"><code>NonZeroUSize::leading_zeros</code></a> exists now, on nightly, if you want to avoid some intrinsics usage.)</p>",
        "id": 227485250,
        "sender_full_name": "scottmcm",
        "timestamp": 1614106949
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> if i recall the initial issue post properly, a repr(C) zero field type would also need to be size 1 on its own, outside of a larger structure</p>",
        "id": 227486825,
        "sender_full_name": "Lokathor",
        "timestamp": 1614107539
    },
    {
        "content": "<p>/me nods.</p>",
        "id": 227488037,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614108060
    },
    {
        "content": "<p>That still wouldn't break the use of Phantom.</p>",
        "id": 227488055,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614108066
    },
    {
        "content": "<p>I think this means that repr(C) ZST's inside repr(transparent) will break</p>",
        "id": 227531098,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614127726
    },
    {
        "content": "<p>i.e. this compiles on stable, and probably shouldn't with the revised rules</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">ZST</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[repr(transparent)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">ZST</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 227531258,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614127838
    },
    {
        "content": "<p>That seems potentially acceptable if nothing uses it.</p>",
        "id": 227535658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614131326
    },
    {
        "content": "<p>(And there's a bunch of <code>repr(transparent)</code> things that we want to break, see <a href=\"https://github.com/rust-lang/rust/issues/78586#issuecomment-720729169\">https://github.com/rust-lang/rust/issues/78586#issuecomment-720729169</a>)</p>",
        "id": 227539345,
        "sender_full_name": "scottmcm",
        "timestamp": 1614134452
    },
    {
        "content": "<p>Well that's a different issue, that's about semver</p>",
        "id": 227540904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614135817
    },
    {
        "content": "<p>Really, the fact that repr(transparent) can cause the compile to break is the best case scenario here; as others have pointed out this is only the tip of the iceberg with most breakage being silent UB</p>",
        "id": 227541005,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614135890
    },
    {
        "content": "<p>Maybe I missed something, but it sounds like <a href=\"https://github.com/dtolnay/ref-cast\">ref-cast</a> will be unhappy <strong>silently</strong>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">ref_cast</span>::<span class=\"n\">RefCast</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Zst</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(RefCast)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">ContainsZst</span><span class=\"p\">(</span><span class=\"n\">Zst</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(RefCast)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">ContainsZeroSizedArray</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">ContainsZst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ContainsZst</span>::<span class=\"n\">ref_cast</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">Zst</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">ContainsZeroSizedArray</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ContainsZeroSizedArray</span>::<span class=\"n\">ref_cast</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">[]);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 227568973,
        "sender_full_name": "hyd-dev",
        "timestamp": 1614158070
    },
    {
        "content": "<p>I may be missing some subtleties, but wouldn't a warning be a better approach than <em>changing semantics</em>? IIUC, the main problem here is that \"for cases where there is no official C ABI / the official C rules do not cover it\", such as zero-sized types, there is a discrepancy between Rust's <code>#[repr(C)]</code> semantics and what most C compilers do with the \"equivalent\" C definition.</p>\n<ul>\n<li>For instance, <code>#[repr(C)] struct Zst {}</code> <em>vs.</em> <code>typedef struct {} Zst_t;</code></li>\n</ul>\n<p>If that is the case, a warning would prevent that misconception of \"ABI matching\", which seems to be the main concern.</p>\n<p>From there follows a second concern, which is that of having a way to write / express in Rust a definition that would be equivalent to some nonstandard C idioms (<em>e.g.</em>, how do we write <code>typedef struct {} Zst_t;</code> in Rust)</p>\n<p>And we do have the ability to express these semantics: in the case of a zero-sized type, or more specifically, defining a struct with no fields, if most C compilers out there accept it as a align-sized definition, then an equivalent way to write it in Rust would be to define:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"> </span><span class=\"c1\">// Warning, this may not match the ABI of common C compilers</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Zst</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// hint: either remove that annotation or write:</span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">CZst</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_cant_be_zero_sized</span>: <span class=\"nc\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>There could even be a helper type definition under <code>std::ffi</code>, something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">CZst</span><span class=\"o\">&lt;</span><span class=\"n\">Payload</span><span class=\"w\"> </span><span class=\"cm\">/* : IsZeroLongArray */</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[();</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_payload</span>: <span class=\"nc\">Payload</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_cant_be_zero_sized</span>: <span class=\"nc\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- or make it `#[lang]` special-cased item</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so as to write:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MyZst</span><span class=\"p\">(</span><span class=\"n\">CZst</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// would warn without it</span>\n\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Complex</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span>: <span class=\"kt\">f32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_arr</span>: <span class=\"nc\">CZst</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// would warn without it</span>\n<span class=\"w\">    </span><span class=\"n\">b</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// …</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This solution features non-breaking changes, better-defined expectations (thanks to the warning), and a way to still easily interface with these nonstandard C semantics.</p>",
        "id": 227611293,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614178941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> +1 to that, but how would you propose to handle the clang \"over-aligned enum\" case <a href=\"#narrow/stream/122651-general/topic/Data.20layout.20.2F.20ABI.20expert.20needed/near/227167345\">above</a>?</p>",
        "id": 227711906,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614223034
    },
    {
        "content": "<p>That is left as an exercice to the reader <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 227749022,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614250396
    },
    {
        "content": "<p>More seriously, I was / am mostly concerned with breakage <em>w.r.t.</em> <code>#[repr(C)]</code> zero-sized types / 0-long arrays, since they are not that uncommon in the Rust ecosystem (<a href=\"https://grep.app/search?current=57&amp;q=%5Cs%5C%5B.%2A%3B%200%5C%5D%2C&amp;regexp=true&amp;filter[lang][0]=Rust\">grep.app</a>); <code>#[repr(C, align(…)]</code>, otoh, is not as pervasive (I tried <code>grep.app</code>-ing for <code>#[repr(C, align</code>, and on the first few pages it was always applied to <code>struct</code>s).<br>\nI don't know enough to judge whether a change is necessary for the over-aligned enum case, but, <strong>in practice</strong>, changing the semantics of for<code>#[repr(C, align…]</code> enums seems to be far less disruptive. I also personally think that <code>#[repr(C)]</code> enums have always been quite underspecified, in Rust (because they are, in C), which is different than the <code>repr(inorder)</code> semantics that were given to <code>#[repr(C)]</code> <code>struct</code>s, so the very concept of \"breaking\" in that case is less clear cut <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 227750177,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614251044
    },
    {
        "content": "<blockquote>\n<p>I also personally think that #[repr(C)] enums have always been quite underspecified, in Rust</p>\n</blockquote>\n<p>Really? I feel like they're very well specified, surprisingly so: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md\">https://github.com/rust-lang/rfcs/blob/master/text/2195-really-tagged-unions.md</a></p>",
        "id": 227752184,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1614252187
    },
    {
        "content": "<p>Sorry I should have been more clear: I am talking about the <em>size</em> of a <code>#[repr(C)]</code> enum, (which, IIUC, is where there could be breakage regarding over-aligned enums). It's defined as \"the size that C woud give\", but C does not define what size it gives to an <code>enum</code> <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 227754499,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614253574
    },
    {
        "content": "<p>(IIRC, a C enum must have <del>a size so that it fits in an <code>int</code></del> the size of some integral type, but that type could very well be a <code>uint8_t</code> (<em>e.g.</em>, <code>-fshort-enums</code>))</p>",
        "id": 227754833,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614253776
    },
    {
        "content": "<blockquote>\n<p>6.7.2.2 Enumeration specifiers<br>\n[...]<br>\nConstraints<br>\nThe expression that defines the value of an enumeration constant shall be an integer constant expression that has a value representable as an int.<br>\n[...]<br>\nEach enumerated type shall be compatible with char, a signed integer type, or an unsigned integer type. The choice of type is implementation-defined, but shall be capable of representing the values of all the members of the enumeration.</p>\n</blockquote>\n<p>So the <code>enum</code> <em>discriminants</em> cannot be bigger than <code>int</code>s, but afterwards it is <em>implementation-defined</em> as to what the size of the so-defined <code>enum</code> is (which, for extra fun, does not affect the type of the <code>enum</code> <em>variants</em> themselves, which remain <code>int</code>s)</p>",
        "id": 227755586,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614254204
    },
    {
        "content": "<p>And since in the FFI world, we don't care about discriminants nor variants, just about the ABI of a type, we are left with an implementation-defined integral type (whose choice can depend on the discriminant values, of course)</p>",
        "id": 227756145,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1614254513
    },
    {
        "content": "<p>in practice they can be larger than ints too.</p>",
        "id": 227765519,
        "sender_full_name": "nagisa",
        "timestamp": 1614259354
    },
    {
        "content": "<p>In fact Rust here is stricter than most C implementations in that it does not allow repr(C) enums that have discriminants outside of <code>isize</code>.</p>",
        "id": 227765605,
        "sender_full_name": "nagisa",
        "timestamp": 1614259397
    },
    {
        "content": "<p>How does that work? I assume you don't mean an enum with 2^64 variants, so something like <code>enum Foo { A = 4000000000; }</code>?</p>",
        "id": 227766223,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614259665
    },
    {
        "content": "<p>or can variants be doubles or something crazy like that?</p>",
        "id": 227766378,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614259720
    },
    {
        "content": "<p>I'm pretty sure you just get an error if the literal is not isize. If the variants wrap, I think the discriminants wrap too?</p>",
        "id": 227766466,
        "sender_full_name": "nagisa",
        "timestamp": 1614259774
    },
    {
        "content": "<p>I mean in these nonconforming C implementations</p>",
        "id": 227766494,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1614259794
    },
    {
        "content": "<p>oh, so you can say <code>enum A { FOO = 42ull }</code> on a 32 bit target and get a 64-bit enum IIRC</p>",
        "id": 227766760,
        "sender_full_name": "nagisa",
        "timestamp": 1614259912
    },
    {
        "content": "<p>Idk what the behaviours are otherwise.</p>",
        "id": 227766846,
        "sender_full_name": "nagisa",
        "timestamp": 1614259935
    },
    {
        "content": "<p>I'm getting the feeling that Rust's <code>repr(align)</code> and GCC's <code>attribute((aligned))</code> are simply not the same thing, so the bug is written under an incorrect assumption... but let's see what the response is to <a href=\"https://github.com/rust-lang/rust/issues/82101#issuecomment-787067437\">this</a> question.</p>",
        "id": 228056355,
        "sender_full_name": "RalfJ",
        "timestamp": 1614429973
    }
]