[
    {
        "content": "<p>As can be seen in this <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=42e9cd668aceaced9c82401185c138c8\">playground</a> the struct <code>ArrayZero</code> has a array of <code>Self</code> with size 0. I would expect this code to compile fine because the size == 0 but it doesn't.<br>\nSo why does <code>[T; 0]</code> with <code>T</code> being recursive over himself trigger E0072 (infinite size) ?</p>",
        "id": 266963908,
        "sender_full_name": "Urgau",
        "timestamp": 1641403388
    },
    {
        "content": "<p>This seems to me that the compiler is not checking if the size is zero but I may be missing something here.</p>",
        "id": 266964095,
        "sender_full_name": "Urgau",
        "timestamp": 1641403472
    },
    {
        "content": "<p>I suspect that the compiler is first calculating the size of the array element type, and then multiplying it by the array size</p>",
        "id": 266964787,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641403883
    },
    {
        "content": "<p>instead of special-casing arrays with zero elements and skipping the calculation of the array element size</p>",
        "id": 266964912,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641403942
    },
    {
        "content": "<p>Were you just curious, or do you have a specific use-case in mind?</p>",
        "id": 266964947,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641403962
    },
    {
        "content": "<p>I do have a use case for it. I wanted to make <code>RawVec</code> const generic over a max stack size element (ie the maximum number of element than can be put on the stack) and give it a default to 0 so than it doesn't break existing code and handle recursive data type.</p>",
        "id": 266965392,
        "sender_full_name": "Urgau",
        "timestamp": 1641404177
    },
    {
        "content": "<p>Ah! <code>FIXME(#11924) Behavior undecided for zero-length vectors.</code> in <a href=\"https://github.com/rust-lang/rust/blob/181e91567c9f347e055b33b1d7e9894f769aafe3/compiler/rustc_ty_utils/src/representability.rs#L88\">compiler/rustc_ty_utils/src/representability.rs</a></p>",
        "id": 266966348,
        "sender_full_name": "Urgau",
        "timestamp": 1641404649
    },
    {
        "content": "<p>I wonder how this interacts with const generics.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">ArrayZero</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">S</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">field</span>: <span class=\"p\">[</span><span class=\"bp\">Self</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If we were to allow the example above, how do we emit errors when <code>S</code> isn't zero?</p>",
        "id": 267186621,
        "sender_full_name": "fee1-dead",
        "timestamp": 1641560911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"361356\">@fee1-dead</span> The <a href=\"https://github.com/rust-lang/rust/blob/181e91567c9f347e055b33b1d7e9894f769aafe3/compiler/rustc_ty_utils/src/representability.rs#L88\">code</a> that checks the representability of an type can simply evaluate the count and check if the count is != 0, like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">        </span><span class=\"n\">ty</span>::<span class=\"n\">Array</span><span class=\"p\">(</span><span class=\"n\">tya</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// A array of size 0 is always representable no matter what it contains</span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"p\">.</span><span class=\"n\">try_eval_usize</span><span class=\"p\">(</span><span class=\"n\">tcx</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">tcx</span><span class=\"p\">.</span><span class=\"n\">param_env</span><span class=\"p\">(</span><span class=\"n\">def_id</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">Representability</span>::<span class=\"n\">Representable</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">is_type_structurally_recursive</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">tcx</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">sp</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">def_id</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">seen</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">shadow_seen</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">representable_cache</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">tya</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"n\">force_result</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267187678,
        "sender_full_name": "Urgau",
        "timestamp": 1641561549
    },
    {
        "content": "<p>Then it wouldn't be able to allow the const generics case. Such recursive errors could only be caught in post monomorphization if we were to allow const generics</p>",
        "id": 267188045,
        "sender_full_name": "fee1-dead",
        "timestamp": 1641561793
    },
    {
        "content": "<p>I have tested this change with <code>ArrayZero</code> and const generic and it works perfectly.</p>",
        "id": 267188293,
        "sender_full_name": "Urgau",
        "timestamp": 1641561938
    },
    {
        "content": "<p>If possible, I would make <code>[Self; S]</code> error when <code>S</code> is generic, even if it <em>could</em> be <code>0</code>, precisely for the reasons pointed out by <span class=\"user-mention\" data-user-id=\"361356\">@fee1-dead</span></p>",
        "id": 267188322,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641561960
    },
    {
        "content": "<p>But for a hard-coded / non-generics-dependent <code>const</code> value then allowing things such as <code>[Self; 0]</code> or <code>[Self; A_CONST - ANOTHER]</code> seems very sensible <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 267188453,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1641562048
    },
    {
        "content": "<p>In my case this would defeat the all purpose of special casing it.<br>\nThe complete code that I want to allow is this one:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">ArrayZero</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">S</span>: <span class=\"kt\">usize</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">field</span>: <span class=\"p\">[</span><span class=\"bp\">Self</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which wouldn't be possible with your proposed restriction.</p>",
        "id": 267188871,
        "sender_full_name": "Urgau",
        "timestamp": 1641562288
    },
    {
        "content": "<p>What would be the alignment of <code>Foo</code> where <code>struct Foo([Foo; 0])</code>? Does it depend on the alignment of <code>Foo</code>?</p>",
        "id": 267189220,
        "sender_full_name": "fee1-dead",
        "timestamp": 1641562488
    },
    {
        "content": "<p>That a good question. Normally the alignment of <code>[Foo; 0]</code> is the alignment of <code>Foo</code> but in this case it's problematic because it will be an infinite recursion. I think that is what somewhat discuss in the tracking issue.</p>",
        "id": 267189666,
        "sender_full_name": "Urgau",
        "timestamp": 1641562778
    },
    {
        "content": "<p>Yah, just <a href=\"https://github.com/rust-lang/rust/issues/11924#issuecomment-298090502\">here</a> by <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 267189828,
        "sender_full_name": "Urgau",
        "timestamp": 1641562869
    },
    {
        "content": "<p>I don't see the issue here. This imposes a constraint that the alignment of Foo is at least the alignment of Foo, which is trivially satisfied. So the alignment would be the minimum alignment imposed by the other fields in the structure or the <code>#[align]</code> directive, else 1</p>",
        "id": 267212923,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1641574582
    }
]