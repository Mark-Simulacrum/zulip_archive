[
    {
        "content": "<p>Hello,</p>\n<p>Given the following code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;'</span><span class=\"na\">int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">int</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;</span><span class=\"n\">I</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"nc\">I</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">int</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">I</span>: <span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"o\">&lt;'</span><span class=\"na\">int</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Could you guys please point me any issue referring why HRTB is not allowed in this context?</p>\n<p>Couldn't find anything related in the Rust repository. I am trying to figure out if the above snippet is a design choice, a bug or an unimplemented feature.</p>\n<p>A plausible workaround  without top-level lifetimes would also be cool but I guess it is too much, heh :)</p>",
        "id": 277537944,
        "sender_full_name": "Caio",
        "timestamp": 1648916071
    },
    {
        "content": "<p>If <code>'int</code> doesn't appear in either the bounded type, nor the trait generics, then that bound becomes impossible to satisfy. A certain type <code>I</code> can only implement <code>Iterator</code> with a single specific <code>Item</code>, and that can be <code>Foo&lt;'a&gt;</code> for a specific lifetime <code>'a</code>, not every lifetime <code>'a</code>. So you basically end up requiring overlapping trait implementations, which are not allowed. Note that <code>I</code> can't reference the lifetime <code>'int</code> because it's declared outside the scope of <code>for&lt;'int&gt;</code></p>",
        "id": 277539128,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1648917507
    },
    {
        "content": "<p>I feel like you don't want <code>I</code> to be a specific type, but rather a family of types (for example the family of all <code>&amp;'a i32</code> for some lifetime <code>'a</code>). This is possible, but requires additional boilerplate and worse type inference.</p>",
        "id": 277539260,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1648917640
    }
]