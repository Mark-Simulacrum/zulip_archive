[
    {
        "content": "<p>Hopefully these questions aren't too loaded, but, would anyone have thoughts to spare on the following:</p>\n<ol>\n<li>In what circumstances might the <code>.to_string</code>'s generic implementation be used instead of the <code>impl ToString for str</code> definition? ( <a href=\"https://doc.rust-lang.org/src/alloc/string.rs.html#2388\">https://doc.rust-lang.org/src/alloc/string.rs.html#2388</a> )</li>\n<li>In these circumstances, why is it that <code>.to_string</code>'s usage of <code>formatter</code> might result in more allocations than <code>.to_owned</code>'s usage of <code>.clone()</code>? ( <a href=\"https://doc.rust-lang.org/src/alloc/borrow.rs.html#90\">https://doc.rust-lang.org/src/alloc/borrow.rs.html#90</a> )</li>\n</ol>\n<p>Context: I am curious about someone's claim that <code>.to_owned</code> can be ~10% faster than <code>.to_string</code> for scenarios where the type being converted from is <code>&amp;str</code>.  The claim mentions that, the performance cost is due to <code>.to_string</code>'s usage of <code>Formatter</code> potentially causing multiple allocations that <code>.to_owned</code> would otherwise avoid, and I'd like to understand, specifically, how this is the case, and in exactly which contexts does this hold true?</p>\n<p>Supporting evidence for the claim: <a href=\"https://medium.com/@ericdreichert/converting-str-to-string-vs-to-owned-with-two-benchmarks-a66fd5a081ce#:~:text=to_string()%20is%20the%20generic,the%20literal%20into%20the%20buffer\">https://medium.com/@ericdreichert/converting-str-to-string-vs-to-owned-with-two-benchmarks-a66fd5a081ce#:~:text=to_string()%20is%20the%20generic,the%20literal%20into%20the%20buffer</a>.</p>",
        "id": 276931969,
        "sender_full_name": "Darrow O'Lykos",
        "timestamp": 1648501957
    },
    {
        "content": "<p>Jan 2, 2016</p>",
        "id": 276932161,
        "sender_full_name": "Eh2406",
        "timestamp": 1648502047
    },
    {
        "content": "<p>So this is out of date advice. The blog post predates the specialization you linked to.<br>\nThey should have the same performance now that that specialization exists.</p>",
        "id": 276932805,
        "sender_full_name": "Eh2406",
        "timestamp": 1648502325
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120179\">@Eh2406</span> Oof, yeah the article is old. Things probably have changed by then. I wonder if the potential-extra-allocations are obvious to see in the 2016 version of this source code.</p>\n<p>In practice I'd just benchmark my project and make arbitrary changes and see which resulted in better perf, but I'm also a fan of building up some intuition around <em>\"hey, what kind of memory needs to be allocated when I use &lt;library feature&gt;\"</em></p>\n<p>thank you <span class=\"user-mention\" data-user-id=\"120179\">@Eh2406</span> , I appreciate it</p>",
        "id": 276932949,
        "sender_full_name": "Darrow O'Lykos",
        "timestamp": 1648502405
    },
    {
        "content": "<p>Without/Before specialization...<br>\nFundamentally <code>to_string</code> just calls <code>Formatter</code> which can potentially do a lot of different things. It processes an entire DSL as its first argument and then can pad strings and format numbers in several different notations and ... Furthermore it's some of the oldest code still in STD, and not the most optimized.<br>\nWhereas <code>to_owned</code>when it's done doing its desugaring is a specialized function for allocating a new string with the same contents as the old string. It's just an allocation and a memcopy.</p>",
        "id": 276933194,
        "sender_full_name": "Eh2406",
        "timestamp": 1648502571
    },
    {
        "content": "<p>And just to emphasize, this is <em>very</em> outdated advice.  The fix (<a href=\"https://github.com/rust-lang/rust/issues/32586\">#32586</a>) turns 6 years old on Friday.</p>\n<p>If you're curious stylistically, here's some old URLO threads that might be interesting:<br>\n<a href=\"https://users.rust-lang.org/t/to-string-vs-to-owned-for-string-literals/1441/6?u=scottmcm\">https://users.rust-lang.org/t/to-string-vs-to-owned-for-string-literals/1441/6?u=scottmcm</a><br>\n<a href=\"https://users.rust-lang.org/t/what-is-the-idiomatic-way-to-convert-str-to-string/12160/8?u=scottmcm\">https://users.rust-lang.org/t/what-is-the-idiomatic-way-to-convert-str-to-string/12160/8?u=scottmcm</a></p>",
        "id": 276933427,
        "sender_full_name": "scottmcm",
        "timestamp": 1648502690
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120179\">@Eh2406</span>  When you say \"specialization\", do you mean the scenarios where <code>impl ToString for str</code> is used as opposed to the default implementation? I believe the (probably outdated) advice mentioned something about the fact where <em>\"there are situations where the compiler essentially can't take advantage of the fact that the type really is an &amp;str\"</em> so I'd want to be sure that there isn't a nuance there that still matters -- for example, I'd want to be sure that the person making the claim isn't saying \"hey btw, that default ToString implementation that relies on <code>Formatter</code> ends up still getting used, even though the compiler SHOULD be able to just take advantage of the fact this is a &amp;str\" -- thanks again for the help</p>",
        "id": 276933641,
        "sender_full_name": "Darrow O'Lykos",
        "timestamp": 1648502813
    },
    {
        "content": "<p>\"specialization\" is the feature that lets you have more than one implementation depending on what type it is.<br>\nOne for a type <code>T</code> where the impl has <code>default fn </code><br>\nand a specialized one for type <code>str</code> for when <code>T</code> happens to equal <code>str</code>.<br>\nThis functionality works correctly and reliably. But it has not been stabilized (I.E. can only be used by STD) because it is possible to write safe code that leads to undefined behavior.</p>",
        "id": 276933912,
        "sender_full_name": "Eh2406",
        "timestamp": 1648502966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> nice, it would've been cool if I asked this Q 6 years on the dot :)<br>\nI see that article was published about 3 months older than that PR merge<br>\nthank you</p>",
        "id": 276934261,
        "sender_full_name": "Darrow O'Lykos [Rust Philly]",
        "timestamp": 1648503186
    },
    {
        "content": "<p>So STD gets to say \"in general use formatter, but if it's a simple string/str just do the clone\"<br>\nIf you try and do that you will get a \"conflicting implementations of trait\"<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=29be9c4f033d1413f78fd3e36fe14a47\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=29be9c4f033d1413f78fd3e36fe14a47</a></p>\n<p>Specialization is the name for letting us normal people write that code.</p>",
        "id": 276934593,
        "sender_full_name": "Eh2406",
        "timestamp": 1648503414
    },
    {
        "content": "<p>I wish I could write that as well. I have a type like <code>&amp;str</code> that can be just as efficiently turned into a <code>String</code>, but it's stuck with the default  impl using <code>Display</code> :(.</p>",
        "id": 276935174,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648503775
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Hey Connor, you have me curious, would you like to show your scenario in a Rust playground?</p>",
        "id": 276935246,
        "sender_full_name": "Darrow O'Lykos [Rust Philly]",
        "timestamp": 1648503830
    },
    {
        "content": "<p>It turns out the problems with specialization run deep. It's unlikely to get stabilized soon.</p>",
        "id": 276935309,
        "sender_full_name": "Eh2406",
        "timestamp": 1648503853
    },
    {
        "content": "<p>I can link some code on github faster.</p>",
        "id": 276935316,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648503859
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I'd appreciate that, thank you</p>",
        "id": 276935399,
        "sender_full_name": "Darrow O'Lykos [Rust Philly]",
        "timestamp": 1648503921
    },
    {
        "content": "<p><a href=\"https://github.com/LightningCreations/lccc/blob/main/xlang/xlang_abi/src/string.rs#L240..L271\">https://github.com/LightningCreations/lccc/blob/main/xlang/xlang_abi/src/string.rs#L240..L271</a></p>",
        "id": 276935414,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648503938
    },
    {
        "content": "<p>TL;DR is the type is <code>&amp;'a str</code>, but can safely be passed accross FFI bounderies and has a stable ABI.</p>",
        "id": 276935467,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648503971
    },
    {
        "content": "<p>So it is still true that <code>to_owned</code> or <code>into</code> can be faster then <code>to_string</code> on some types. But it is no longer true on STD's types. and that is &gt;90% of the problem.</p>",
        "id": 276935468,
        "sender_full_name": "Eh2406",
        "timestamp": 1648503971
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I've read about FFIs and ABIs at a high level, but have no real hands-on experience with them. Would you mind walking me through why the compiler is not able to treat your <code>StringView</code> as a <code>&amp;str</code> so that it'd use the less costly <code>.to_string</code> method (for <code>str</code>) as opposed to the the more costly <code>.to_string</code> method (for <code>T</code>)?</p>",
        "id": 276937183,
        "sender_full_name": "Darrow O'Lykos [Rust Philly]",
        "timestamp": 1648505319
    },
    {
        "content": "<p>The main issue is that there is a display impl for <code>StringView</code>, so the type itself gets the blanket impl of <code>ToString</code> from <code>core</code>, rather than forwarding via autoderef to <code>str</code>s impl.</p>",
        "id": 276937298,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648505410
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Ah, I see now that blanket implementation conflict you describe is what <span class=\"user-mention\" data-user-id=\"120179\">@Eh2406</span> demo'ed here: <a href=\"#narrow/stream/122651-general/topic/.26str.20.60.2Eto_string.60.20and.20.60.2Eto_owned.60/near/276934593\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/.26str.20.60.2Eto_string.60.20and.20.60.2Eto_owned.60/near/276934593</a></p>\n<p>So, I notice in your code you have a <code>impl&lt;'a&gt; AsRef&lt;str&gt; for StringView&lt;'a&gt;</code> as well as a <code>impl&lt;'a&gt; From&lt;&amp;'a str&gt; for StringView&lt;'a&gt;</code>, and I see that you're saying that the blanket impl of <code>ToString</code> prevents forwarding via autoderef to <code>str</code>'s impl.</p>\n<p>Could you help me understand why you wouldn't want to have an <code>impl&lt;'a&gt; From&lt;&amp;'a StringView&gt; for str</code>?<br>\nWould this successfully mitigate your dependency on the <code>Formatter</code> within <code>ToString</code>'s <code>impl for T</code>? (If not, why would it not?)</p>",
        "id": 276938687,
        "sender_full_name": "Darrow O'Lykos [Rust Philly]",
        "timestamp": 1648506525
    },
    {
        "content": "<p>If you look at STD, it only has overrides for <code>char</code> <code>u8</code> <code>i8</code> <code>str </code> and <code>String</code>. The specialization optimization only hits if you can make <code>T</code> one of those types. <code>From</code> has nothing to do with it.<br>\n<span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> is pointing out that if he did not have <a href=\"https://github.com/LightningCreations/lccc/blob/main/xlang/xlang_abi/src/string.rs#L309-L313\"><code>Display</code></a> for <code>StringView</code> then <code>StringView</code> would get <a href=\"https://github.com/LightningCreations/lccc/blob/main/xlang/xlang_abi/src/string.rs#L260-L271\"><code>defer</code></a>ed into an <code>str</code>, and hit the happy path. But that would have other negative implications, specifically that a <code>StringView</code> cannot be displayed, only a <code>&amp;*StringView</code>. Which is probably going to be really annoying when generics are involved.</p>",
        "id": 276940105,
        "sender_full_name": "Eh2406",
        "timestamp": 1648507836
    },
    {
        "content": "<p>Indeed. Although, it should definately have a <code>From&lt;StringView&lt;'a&gt;&gt; for &amp;'a str</code> impl. I think it didn't because it used to be MSRV 1.39 code, and coherence was far more restrictive then than it is today.</p>",
        "id": 276944281,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648511789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120179\">@Eh2406</span> Thank you, I see that the specialization optimization occurs if you can make <code>T</code> one of those types. I also see that you are clarifying that if <span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> did not implement <code>Display for StringView</code> that <code>StringView</code> would get <strong>automatically</strong> <code>deref</code>'ed into an <code>str</code>, and hit the happy path, but that doing so would have negative impact on the ergonomics of displaying a StringView when generics are involved. <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span></p>\n<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I'm curious, do you have any scenarios where you use <code>.to_string</code> to get yourself an owned <code>String</code>? If yes, then would adding a <code>impl From&lt;StringView&lt;'a&gt;&gt; for &amp;'a str</code> enable you to do something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">s</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">string_view</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">get_owned_s</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// or s.to_owned();</span>\n</code></pre></div>\n<p>help you mitigate some performance cost by letting you rely on the specialization optimization that exists for <code>ToString</code>? (Since the compiler won't need to use the <code>.to_string</code> method from the blanket <code>impl ToString for T</code> since the compiler knows <code>s</code> is specifically a <code>&amp;str</code>?</p>",
        "id": 276952178,
        "sender_full_name": "Darrow O'Lykos [Rust Philly]",
        "timestamp": 1648521702
    },
    {
        "content": "<p>I don't know off the top of my head. The codebase is fairly large and some parts of it I haven't looked at in a couple months.</p>",
        "id": 276952386,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648522022
    }
]