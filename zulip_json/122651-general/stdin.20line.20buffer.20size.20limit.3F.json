[
    {
        "content": "<p>I have code that looks like:</p>\n<div class=\"codehilite\"><pre><span></span><code>            let mut input = String::new();\n            std::io::stdin().read_to_string(&amp;mut input).unwrap();\n</code></pre></div>\n<p>If I run this, and try to type more than 1024 ASCII characters without any newlines, it just... doesn't let me. I can do this fine in my shell and Python's REPL, and I've also tried multiple terminal emulators. Why would this be occurring, is this a std issue?</p>",
        "id": 264232936,
        "sender_full_name": "Winter",
        "timestamp": 1639004069
    },
    {
        "content": "<p>What operating system are you on? On macOS I can't enter more than 1024 characters in one line with e.g. <code>cat &gt; test.txt</code>either. This is a hard-coded limit of macOS terminals in canonical mode. On Linux that limit is 4096 characters (input after that limit is silently discarded). Bash and the Python REPL get around it by disabling the canonical mode and implementing specialized terminal handling in non-canonical mode.<br>\nYou can get around this in canonical mode by pressing Ctrl-D after typing part of the line. This will flush the current line buffer to the program. Ctrl-D will only send EOF if the line buffer is empty.</p>",
        "id": 264270378,
        "sender_full_name": "Hans Kratz",
        "timestamp": 1639039342
    },
    {
        "content": "<blockquote>\n<p>You can get around this in canonical mode by pressing Ctrl-D after typing part of the line. This will flush the current line buffer to the program. Ctrl-D will only send EOF if the line buffer is empty.</p>\n</blockquote>\n<p>Interesting, I didn't know that!</p>",
        "id": 264582416,
        "sender_full_name": "Noah Lev",
        "timestamp": 1639254048
    }
]