[
    {
        "content": "<p>I'm trying to figure out when should I use slices and when should I use Iterators,</p>\n<p>Iterator pros:</p>\n<ul>\n<li>you can wrap and unwrap types without reallocating (using maps)</li>\n<li>you can use non contiguous memory sources.</li>\n</ul>\n<p>Iterator cons:</p>\n<ul>\n<li>no random access.</li>\n</ul>\n<p>Slices pros:</p>\n<ul>\n<li>random access.</li>\n<li>obvious memcpys (the compiler will probably do that with iterators too: <a href=\"https://godbolt.org/z/v8Kx3os8W\">https://godbolt.org/z/v8Kx3os8W</a>)</li>\n</ul>\n<p>Slices cons:</p>\n<ul>\n<li>You have to reallocate if you want to wrap/unwrap types in safe rust.</li>\n</ul>\n<p>From this list it seems like as long as you don't need random access memory then you should use Iterators, that way you can convert a <code>impl Iterator&lt;Item=u8&gt;</code> to <code>impl Iterator&lt;Item=NonZeroU8&gt;</code> in safe rust without re-allocating.</p>\n<p>But then I look at the standard library, and the <code>Write</code> trait is <code>fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;</code> and not <code>fn write(&amp;mut self, buf: impl Iterator&lt;Item=u8&gt;) -&gt; Result&lt;usize&gt;;</code></p>\n<p>What is the reason for that? And why are slices used all over the ecosystem and equivalent iterator APIs aren't so prevalent?</p>",
        "id": 264010348,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1638888088
    },
    {
        "content": "<p>Are you asking about slices/iterators of <code>u8</code> specifically or for any T?</p>",
        "id": 264014368,
        "sender_full_name": "The 8472",
        "timestamp": 1638889923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/Idiomatic.3A.20slices.20vs.20Iterators/near/264014368\">said</a>:</p>\n<blockquote>\n<p>Are you asking for slices/iterators of <code>u8</code> specifically or for any T?</p>\n</blockquote>\n<p>Is there a meaningful difference here? I used <code>u8</code> here just because of the <code>Write</code> trait</p>",
        "id": 264014662,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1638890075
    },
    {
        "content": "<p>Yes, there's a meaningful difference.</p>",
        "id": 264014707,
        "sender_full_name": "The 8472",
        "timestamp": 1638890099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/Idiomatic.3A.20slices.20vs.20Iterators/near/264014707\">said</a>:</p>\n<blockquote>\n<p>Yes, there's a meaningful difference.</p>\n</blockquote>\n<p>Would love to hear :) when should I use slices vs iterators in each of them?</p>",
        "id": 264019992,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1638892257
    },
    {
        "content": "<p>I'd say that slices are a better starting point, but iterators are a better working point. By that I mean that if someone is going to offer to let me look at a slice or an iterator, I'd rather the slice, because I can make an iterator from that if what I needed was an iterator, but I can't do the reverse. And that said, 95% of the time what I want is the iterator form, so I will end up doing that. However, sometimes I want to cast the slice's element type or split a chunk off the front or something that you can't do with the iterator.</p>",
        "id": 264026270,
        "sender_full_name": "Lokathor",
        "timestamp": 1638894507
    },
    {
        "content": "<p><code>[u8]</code> are used for several reasons:</p>\n<ul>\n<li>OS APIs want a pointer and length, they don't understand language-specific iterator protocols</li>\n<li>can be reused, avoiding allocations</li>\n<li>you can do some zero-copy type punning, e.g. to <code>&amp;str</code> </li>\n<li>also casting to SIMD types!</li>\n<li>optimizing iterators over tiny types (<code>Iterator&lt;Item = u8&gt;</code> -&gt;  you only get 1 byte per step) is expensive. std goes to great lengths to make llvm understand those loops and optimize them, but you still pay for it in compile times and they don't always optimize perfectly</li>\n<li>you're more likely to keep them in contiguous data structures anyway. it's not like you have a <code>HashMapM&lt;_, u8&gt;</code> and need an iterator over its values to build a byte stream from that, simply because it would be inefficient. At a minimum you would be dealing with an iterator of slices, maybe from some kind of rope data structure</li>\n<li>shared views into raw data</li>\n<li>sources that only generate one byte at a time aren't all that common</li>\n</ul>\n<p>And as <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>  says you can always make an iterator from a slice.</p>\n<p>And for streaming large amounts of bytes there are the <code>Read</code> and <code>Write</code> traits that are often used to abstract over compressors, encryption and other byte-stream things.</p>\n<p>For larger structs most of those things don't apply or do so less frequently. E.g. they may contain slice references, so they already function as a large batch of data for example.</p>",
        "id": 264032578,
        "sender_full_name": "The 8472",
        "timestamp": 1638896521
    },
    {
        "content": "<p>The biggest reason to use byte iterator is when the dagfrekkin spec demands that you iterate a byte at a time (sometimes less than that at a time)</p>",
        "id": 264032798,
        "sender_full_name": "Lokathor",
        "timestamp": 1638896586
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/122651-general/topic/Idiomatic.3A.20slices.20vs.20Iterators/near/264014662\">said</a>:</p>\n<blockquote>\n<p>I used <code>u8</code> here just because of the <code>Write</code> trait</p>\n</blockquote>\n<p>The big difference to me is that <code>u8</code> is extremely often not used as something that's individually-useful.  And if you need to read <em>multiple</em> at once, then slices (or <code>Read</code> or ...) tends to be better.</p>\n<p>For comparison on the other end, I find it somewhat rare to strictly <em>need</em> a slice of <code>String</code>.  For them, handling them one at a time is often reasonable, and thus consuming them via iterators is more reasonable.</p>",
        "id": 264045926,
        "sender_full_name": "scottmcm",
        "timestamp": 1638900602
    },
    {
        "content": "<p>Yeah that's a general theme. You don't <code>flatten</code> or <code>partition</code> individual bytes for example. Operations on raw bytes often look different compared to what you do to a collection of structs.<br>\nE.g. when you're working on pixels then you reinterpret a bytes as rows and columns and apply kernels across multiple rows which wouldn't be possible with a dumb iterator examining a byte at a time.</p>",
        "id": 264048391,
        "sender_full_name": "The 8472",
        "timestamp": 1638901508
    },
    {
        "content": "<p>Part of me wishes that <code>byte</code> existed as a type distinct from <code>u8</code> or <code>i8</code> (albeit layout-equivalent).  Because what I do with bytes is generally so different from what I do with <em>numbers</em>.</p>",
        "id": 264056633,
        "sender_full_name": "scottmcm",
        "timestamp": 1638904547
    },
    {
        "content": "<p>type alias? sure.<br>\ndistinct type where rustc tells me i'm wrong if i mix them up? no thanks.</p>\n<p>but you can always newtype u8 as \"byte\" if you want in your own code ;3</p>",
        "id": 264067236,
        "sender_full_name": "Lokathor",
        "timestamp": 1638909061
    },
    {
        "content": "<p>Yeah, that's the part of me that's overly-persnickety.  Same part that doesn't like <code>count_ones</code> on signed numbers.</p>\n<p>Definitely not something I'd actually propose :P</p>",
        "id": 264073499,
        "sender_full_name": "scottmcm",
        "timestamp": 1638911926
    },
    {
        "content": "<p>I don't understand why count_ones wouldn't be available on a signed value</p>",
        "id": 264169805,
        "sender_full_name": "Lokathor",
        "timestamp": 1638976819
    },
    {
        "content": "<p>probably because it would be confusing whether the sign bit contributes to the count as well? you can just do <code>(-1i8 as u8).count_ones()</code> though.</p>",
        "id": 264195141,
        "sender_full_name": "fee1-dead",
        "timestamp": 1638986658
    }
]