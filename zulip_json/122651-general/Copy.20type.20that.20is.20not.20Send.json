[
    {
        "content": "<p>Is there a Copy type that is not Send ? (i.e. T: Copy + !Send) ?</p>",
        "id": 248324828,
        "sender_full_name": "hannahE2",
        "timestamp": 1628067076
    },
    {
        "content": "<p>Yes there is, <code>RefCell</code>.</p>",
        "id": 248325254,
        "sender_full_name": "hannahE2",
        "timestamp": 1628067362
    },
    {
        "content": "<p><code>*mut T</code>, <code>*const T</code> and <code>NonNull&lt;T&gt;</code> are <code>Copy</code> but not <code>Send</code> nor <code>Sync</code></p>",
        "id": 248325312,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1628067382
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248325254\">said</a>:</p>\n<blockquote>\n<p>Yes there is, <code>RefCell</code>.</p>\n</blockquote>\n<p><code>RefCell</code> is <code>Send</code> but not <code>Sync</code></p>",
        "id": 248325351,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1628067413
    },
    {
        "content": "<p>Why aren't <code>*mut T</code>, <code>*const T</code> and <code>NonNull&lt;T&gt;</code> <code>Send</code> ?</p>\n<p>They can be sent across threads without issues, or I have misunderstood something fundamental about rust.</p>",
        "id": 248355626,
        "sender_full_name": "hannahE2",
        "timestamp": 1628086570
    },
    {
        "content": "<p>Yeah, it is _sound_ to send <code>*mut T</code> across threads - as in: it is impossible to cause UB by doing that _without using <code>unsafe</code> code_. This is so weird.</p>\n<p>Are there any <code>T: Copy + !Send</code> types, that can't be <code>Send</code> for _soundness_ ?</p>",
        "id": 248355717,
        "sender_full_name": "hannahE2",
        "timestamp": 1628086618
    },
    {
        "content": "<p>It's more of a lint against doing that: <a href=\"https://doc.rust-lang.org/nomicon/send-and-sync.html#send-and-sync\">https://doc.rust-lang.org/nomicon/send-and-sync.html#send-and-sync</a></p>",
        "id": 248356299,
        "sender_full_name": "Smittyvb",
        "timestamp": 1628086879
    },
    {
        "content": "<p>You can implement those lints in clippy or as a warning, but it makes no sense to have to create a wrapper type to just make a raw pointer Send. </p>\n<p>I just fixed this in my Rust fork.</p>\n<p>Looking at the github issue history, it seems that this was changed without going through the RFC process.</p>",
        "id": 248358182,
        "sender_full_name": "hannahE2",
        "timestamp": 1628087624
    },
    {
        "content": "<blockquote>\n<p>You can implement those lints in clippy or as a warning, but it makes no sense to have to create a wrapper type to just make a raw pointer Send. </p>\n<p>I just fixed this in my Rust fork.</p>\n<p>Looking at the github issue history, it seems that this was changed without going through the RFC process.</p>\n</blockquote>\n<p>It allows stably writing wrappers like Rc that are not Send as well</p>",
        "id": 248358502,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628087754
    },
    {
        "content": "<p>Users can't unimplement auto traits, so if *mut T was Send for any T, then there isn't a way to opt-out directly for Rc&lt;T&gt;, or any kind of thread-local handle types.</p>",
        "id": 248358673,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628087823
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/21689\">https://github.com/rust-lang/rust/pull/21689</a> made this not-send and not-sync without any discussion.</p>",
        "id": 248358945,
        "sender_full_name": "hannahE2",
        "timestamp": 1628087920
    },
    {
        "content": "<blockquote>\n<p>Users can't unimplement auto traits, so if *mut T was Send for any T, then there isn't a way to opt-out directly for Rc&lt;T&gt;, or any kind of thread-local handle types.</p>\n</blockquote>\n<p>There are many ways to solve that problem. Making raw pointers !Send and !Sync is a very poor solution.</p>",
        "id": 248359048,
        "sender_full_name": "hannahE2",
        "timestamp": 1628087958
    },
    {
        "content": "<p>None that can be done as easily, and it's also a foot gun if you have to explicitly opt-in to being <code>!Send + !Sync</code>.</p>",
        "id": 248359214,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088014
    },
    {
        "content": "<p>As easy as <code>NonSendPtr&lt;T&gt;</code></p>",
        "id": 248359306,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088055
    },
    {
        "content": "<p>It makes no sense to pessimize the use of raw pointers _everywhere_ to make one single use case - putting them inside structs that _sometimes_ should not be send - simpler.</p>",
        "id": 248359411,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088101
    },
    {
        "content": "<p>If I write <code>struct Slice&lt;T&gt;(*mut T, usize)</code> I want <code>Slice</code> to be <code>Send</code> and <code>Sync</code>.</p>",
        "id": 248359538,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088142
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"s\">\"C\"</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">some_thread_unsafe_api_constructor</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c_void</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">some_thread_unsafe_api</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"n\">c_void</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt;  <span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">SafeWrapper</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">c_void</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">SafeWrapper</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"bp\">Self</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"n\">some_thread_unsafe_api_constructor</span><span class=\"p\">()})</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">some_api</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">         </span><span class=\"k\">unsafe</span><span class=\"p\">{</span><span class=\"n\">some_thread_unsafe_api</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// Oops, we're Send+Sync</span>\n</code></pre></div>",
        "id": 248359575,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088158
    },
    {
        "content": "<p>so ? the <code>unsafe</code> there is at fault</p>",
        "id": 248359664,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088201
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248359538\">said</a>:</p>\n<blockquote>\n<p>If I write <code>struct Slice&lt;T&gt;(*mut T, usize)</code> I want <code>Slice</code> to be <code>Send</code> and <code>Sync</code>.</p>\n</blockquote>\n<p>In what cases for <code>T</code> though? There is not one correct answer when raw pointers are involved.</p>",
        "id": 248359700,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088221
    },
    {
        "content": "<p>For all cases. When I use <code>Slice</code> I need to use <code>unsafe</code>, and I can use <code>atomics</code> to make those uses safe.</p>",
        "id": 248359791,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088246
    },
    {
        "content": "<p>To me, it only makes sense to ban this if allowing it is unsound. </p>\n<p>But allowing it is sound.</p>",
        "id": 248359876,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088292
    },
    {
        "content": "<p>The argument \"but if then people use <code>unsafe</code> they can shoot themselves in the foot\" is pretty moot</p>",
        "id": 248359928,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088311
    },
    {
        "content": "<p>Either don't use <code>unsafe</code>, or use it properly</p>",
        "id": 248359945,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088319
    },
    {
        "content": "<p>That rationale can be applied to <code>unsafe</code> as a whole</p>",
        "id": 248359977,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088328
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248359791\">said</a>:</p>\n<blockquote>\n<p>For all cases. When I use <code>Slice</code> I need to use <code>unsafe</code>, and I can use <code>atomics</code> to make those uses safe.</p>\n</blockquote>\n<p>That's your case and you can express this.<br>\nWhat about a case where <code>Slice&lt;T&gt;</code> is Send iff T: Send, and Sync iff T: Sync</p>",
        "id": 248360007,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088347
    },
    {
        "content": "<p>Then the <code>impls</code> can propagate this.</p>",
        "id": 248360069,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088364
    },
    {
        "content": "<p>I can provie a <code>Slice&lt;T&gt;::read</code> even if <code>T: !Send</code> though</p>",
        "id": 248360155,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248359945\">said</a>:</p>\n<blockquote>\n<p>Either don't use <code>unsafe</code>, or use it properly</p>\n</blockquote>\n<p>The point of unsafe rust is to make it easier to use properly. As it stands, unsafe rust is still easier to get right than C or C++. Saying that raw pointers by default are always <code>Send+Sync</code> is a great way to hand people footguns.</p>",
        "id": 248360208,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088428
    },
    {
        "content": "<p>Learning <code>unsafe</code> is hard. Saying that raw pointers are not <code>Send+Sync</code> suggests that making them <code>Send+Sync</code> is _unsound_. Which it isn't. Which makes the language inconsistent and this particular part of the language harder to learn and use for everybody.</p>",
        "id": 248360395,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248360395\">said</a>:</p>\n<blockquote>\n<p>Learning <code>unsafe</code> is hard. Saying that raw pointers are not <code>Send+Sync</code> suggests that making them <code>Send+Sync</code> is _unsound_. Which it isn't. Which makes the language inconsistent and this particular part of the language harder to learn and use for everybody.</p>\n</blockquote>\n<p>It's not unsound on it's face, but making them so makes a very large amount of code unsound.</p>",
        "id": 248360469,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088521
    },
    {
        "content": "<p>And a lot of that code exists, so it definately won't be changed now.</p>",
        "id": 248360532,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088550
    },
    {
        "content": "<p>Right, which is why I've only fixed this in my fork.</p>",
        "id": 248360567,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088563
    },
    {
        "content": "<p>Fixing this would requre a new edition.</p>",
        "id": 248360628,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088591
    },
    {
        "content": "<p>(if this is fixable at all)</p>",
        "id": 248360708,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088613
    },
    {
        "content": "<p>Fixing it can't be done currently, since it's a stdlib breaking change. Even if it could though, I highly doubt it would. As I say, <code>unsafe</code> rust gives you the tools to shoot yourself in the foot, but it doesn't shove them in your face. 9 times out of 10, using a totally Send+Sync raw pointer is going to be wrong.</p>",
        "id": 248360880,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088691
    },
    {
        "content": "<p>More like 1 out of 10</p>",
        "id": 248361291,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088845
    },
    {
        "content": "<p>From the nomicon:</p>\n<blockquote>\n<p>However it's important that they aren't thread-safe to prevent types that contain them from being automatically marked as thread-safe. These types have non-trivial untracked ownership, and it's unlikely that their author was necessarily thinking hard about thread safety.</p>\n</blockquote>\n<p>Put another way, if  your <code>Slice</code> type, which contains raw pointers, is <code>Send</code> and <code>Sync</code>, it is because the compiler forced you to think about it and you made sure that it actually was <code>Send + Sync</code></p>",
        "id": 248361359,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628088874
    },
    {
        "content": "<p>Unless 90% of your time is spent writing type declarations, and only 10% of the time is spent actually writing programs that use them.</p>",
        "id": 248361372,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088881
    },
    {
        "content": "<p>The compiler did not force me to think about it. I did it on my own, because it was obvious that it was correct.</p>",
        "id": 248361456,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088927
    },
    {
        "content": "<p>The standard library implementation forced me to find a workaround.</p>",
        "id": 248361480,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088938
    },
    {
        "content": "<p>And to change my APIs from <code>*mut [T]</code> to <code>Slice</code> for no reason</p>",
        "id": 248361508,
        "sender_full_name": "hannahE2",
        "timestamp": 1628088954
    },
    {
        "content": "<p>No, my figure is correct. If <code>*mut T</code> was unconditionally <code>Send+Sync</code>, this would be wrong for:</p>\n<ul>\n<li><code>Box</code></li>\n<li><code>Rc</code></li>\n<li><code>Arc</code></li>\n<li><code>Vec</code></li>\n<li><code>BTreeMap</code></li>\n<li><code>HashMap</code></li>\n<li><code>String</code></li>\n<li>etc.</li>\n<li>Any user implementation of the above</li>\n</ul>",
        "id": 248361572,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628088969
    },
    {
        "content": "<p>So 90% of the time you spent programming is spent in <strong>creating</strong> those types ?</p>",
        "id": 248361618,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089000
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248361508\">said</a>:</p>\n<blockquote>\n<p>And to change my APIs from <code>*mut [T]</code> to <code>Slice</code> for no reason</p>\n</blockquote>\n<p>Raw pointers are difficult to use statically because they are difficult to use properly. Very little code should be using raw pointers except within some safe wrapper thereof</p>",
        "id": 248361699,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628089039
    },
    {
        "content": "<p>Because 99.999% of the time i spent is spent in <strong>using</strong> them. The time it takes me to create them is close to 0. So I spend most time just _using_ raw pointers, and almost 0 time creating wrappers for them.</p>",
        "id": 248361706,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089041
    },
    {
        "content": "<p>I give up. Have fun in your throne. </p>\n<p>You know what's best for me.</p>",
        "id": 248361888,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089100
    },
    {
        "content": "<p>Which is funny, since you say that you never use raw pointers, but simultaneously say that this footgun is super important, because you spent all your time writing code that would break without it.</p>",
        "id": 248361993,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089148
    },
    {
        "content": "<p>Fact is: sending a raw pointer to another thread is sound. </p>\n<p>The fact that you are too scared to use raw pointers is a bad argument for not making them Send.</p>",
        "id": 248362081,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089188
    },
    {
        "content": "<p>The argument that \"it's too late\" is probably true, but back then this was sweeped in without an RFC. There is zero discussion available about why this decision was made. And all points that, like all the other half-baked \"lints\" in the language (AssertUnwindSafe), this was a bad idea.</p>",
        "id": 248362341,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089262
    },
    {
        "content": "<p>I almost never use raw pointers outside of wrappers like those types. I use them internally in some places, but for very short lengths of code, where I can justify every single use by some locally satisfied invariant. I would think twice before making them a public api, and I have run accross the issue of <code>*mut (): !Sync</code> and needing a wrapper exclusively for that purpose, exactly once.</p>",
        "id": 248362356,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628089268
    },
    {
        "content": "<p>Thank you for your anecdotal evidence. As a king, therefore, no other programmers facing other issues exist.</p>",
        "id": 248362461,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089310
    },
    {
        "content": "<p>I face this enough in low-level programming to maintain my own rustc fork, that now fixes this for raw pointers. For the std lib types using it, I can just add negative impls: <code>impl&lt;T: ?Sized&gt; !Send for RawVec&lt;T&gt; {}</code>.</p>",
        "id": 248362618,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089381
    },
    {
        "content": "<p>What about user-defined types? Now any library that uses raw pointers and relies on the negative impls for soundness cannot be used on that fork.</p>",
        "id": 248362735,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628089428
    },
    {
        "content": "<p>Yep</p>",
        "id": 248362778,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089443
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248362341\">said</a>:</p>\n<blockquote>\n<p>The argument that \"it's too late\" is probably true, but back then this was sweeped in without an RFC. There is zero discussion available about why this decision was made. And all points that, like all the other half-baked \"lints\" in the language (AssertUnwindSafe), this was a bad idea.</p>\n</blockquote>\n<p>When was this decision made? Can you point me to the issue? I'm interested by the context <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 248362888,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628089484
    },
    {
        "content": "<p>It was implemented in this PR: <a href=\"https://github.com/rust-lang/rust/pull/21689\">https://github.com/rust-lang/rust/pull/21689</a></p>",
        "id": 248362933,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089504
    },
    {
        "content": "<p>Couple of months before 1.0 release</p>",
        "id": 248363033,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089546
    },
    {
        "content": "<p>There is an RFC here: <a href=\"https://github.com/rust-lang/rfcs/pull/127/files\">https://github.com/rust-lang/rfcs/pull/127/files</a></p>",
        "id": 248363225,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089625
    },
    {
        "content": "<p>Looks like raw pointers didn't implement <code>Send</code> and <code>Sync</code> even before <a href=\"https://github.com/rust-lang/rust/issues/21689\">#21689</a></p>",
        "id": 248363542,
        "sender_full_name": "Léo Lanteri Thauvin",
        "timestamp": 1628089768
    },
    {
        "content": "<p>Im pretty sure before you could decide, i.e., you could just add your own <code>unsafe impl&lt;T&gt; Send for *mut T {}</code> anywhere.</p>",
        "id": 248363917,
        "sender_full_name": "hannahE2",
        "timestamp": 1628089962
    },
    {
        "content": "<p>I don't believe raw pointers are fundamental, so I would assume not.</p>",
        "id": 248363981,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628089994
    },
    {
        "content": "<p>There was no fundamental back then.</p>",
        "id": 248364007,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090007
    },
    {
        "content": "<p>When you want some raw pointer to be Send/Sync (sometimes useful in FFI), common Rust usage is to wrap them in a type that does it for your use case, that way you can document invariants and sometimes even use assertions to ensure said invariants are not broken</p>",
        "id": 248364140,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090049
    },
    {
        "content": "<blockquote>\n<p>If *mut T was unconditionally Send+Sync, this would be wrong for:</p>\n<p>Box<br>\n   Rc<br>\n   Arc<br>\n   Vec</p>\n</blockquote>\n<p>Notice that if <code>*mut T</code> was unconditionally <code>Send</code>, this would be right for <code>Box</code>, <code>Arc</code>, <code>Vec</code>.</p>",
        "id": 248364169,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090061
    },
    {
        "content": "<p>Maintaining a whole fork of rustc just for that seems a little much</p>",
        "id": 248364190,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090068
    },
    {
        "content": "<p>The attribute didn't exist, but I assume the coherence rules did, at some level, and <code>*mut T</code> is treated as a foreign type, so you couldn't implement the foreign Send trait for the foreign <code>*mut T</code> type</p>",
        "id": 248364235,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628090094
    },
    {
        "content": "<blockquote>\n<p>When you want some raw pointer to be Send/Sync (sometimes useful in FFI), common Rust usage is to wrap them in a type that does it for your use case, that way you can document invariants and sometimes even use assertions to ensure said invariants are not broken</p>\n</blockquote>\n<p>I can't coerce <code>&amp;mut [T]</code> to <code>Slice&lt;T&gt;</code> easily, so this solution has a huge economic drawback for most of the code that I write.</p>",
        "id": 248364267,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090104
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248364169\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>If *mut T was unconditionally Send+Sync, this would be wrong for:</p>\n<p>Box<br>\n   Rc<br>\n   Arc<br>\n   Vec</p>\n</blockquote>\n<p>Notice that if <code>*mut T</code> was unconditionally <code>Send</code>, this would be right for <code>Box</code>, <code>Arc</code>, <code>Vec</code>.</p>\n</blockquote>\n<p>No it wouldn't still because then <code>Box&lt;T&gt;: Send</code>, even if <code>T: !Send</code>, by default</p>",
        "id": 248364329,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628090126
    },
    {
        "content": "<p>Right, all these types would need to opt in to conditional negative impls.</p>",
        "id": 248364497,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090190
    },
    {
        "content": "<blockquote>\n<p>I can't coerce <code>&amp;mut [T]</code> to <code>Slice&lt;T&gt;</code> easily, so this solution has a huge economic drawback for most of the code that I write.</p>\n</blockquote>\n<p>I think the layout are compatibles so transmute should be ok ? With a helper func/macro, it may be a little heavy at compile time but should not have any runtime cost</p>",
        "id": 248364529,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090209
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248364497\">said</a>:</p>\n<blockquote>\n<p>Right, all these types would need to opt in to conditional negative impls.</p>\n</blockquote>\n<p>And what about a user-defined <code>Box</code> type? Same issue.</p>",
        "id": 248364597,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628090239
    },
    {
        "content": "<p>You could probably just use a macro to simplify the making of structs with raw pointers that are <code>Send</code>/<code>Sync</code></p>",
        "id": 248364624,
        "sender_full_name": "Smittyvb",
        "timestamp": 1628090250
    },
    {
        "content": "<p>I'm complaining about the API overhead, the fact that I can't just pass a <code>&amp;mut [T]</code> where a slice is expected.</p>\n<blockquote>\n<p>And what about a user-defined Box type? Same issue.</p>\n</blockquote>\n<p>If <code>Box</code> was using raw pointers, sure. If its using <code>NonNull</code>, and that does it right, then it wouldn't have the same issue.</p>",
        "id": 248364736,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090300
    },
    {
        "content": "<p><code>NonNull&lt;T&gt;</code> doesn't have a correct default either.</p>",
        "id": 248364864,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628090349
    },
    {
        "content": "<blockquote>\n<p>NonNull&lt;T&gt; doesn't have a correct default either.</p>\n</blockquote>\n<p>Not yet. In my fork it does.</p>\n<blockquote>\n<p>You could probably just use a macro to simplify the making of structs with raw pointers that are Send/Sync</p>\n</blockquote>\n<p>I want to use <code>*mut [T]</code> in my APIs, and I want to be able to call them with <code>foo(x : &amp;mut [T])</code> and have that to just work.</p>",
        "id": 248364905,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090368
    },
    {
        "content": "<p>Having to use macros, wrappers, different types, etc. is something i'm not willing to put up with when for me the fix is simple.</p>",
        "id": 248364952,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090394
    },
    {
        "content": "<p>For api, wouldn’t making your functions generic over AsRef or Into be enough ?</p>",
        "id": 248364959,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090395
    },
    {
        "content": "<p>I wouldn’t call a fork of rustc simple</p>",
        "id": 248365025,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090410
    },
    {
        "content": "<p>A fork is trivial. Making the function generic, isn't. I don't want generic functions, I want functions.</p>",
        "id": 248365082,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248364905\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>NonNull&lt;T&gt; doesn't have a correct default either.</p>\n</blockquote>\n<p>Not yet. In my fork it does.</p>\n</blockquote>\n<p>What I mean is, code using <code>NonNull&lt;T&gt;</code> has the exact same issues as using <code>*mut T</code> directly, in that there is no singular correct default for the type. <code>NonNull&lt;T&gt;</code> can represent an owning, mutably borrowing, immutably borrowing, shared mutably borrowing, etc. pointer just as much as a raw pointer can.</p>",
        "id": 248365139,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628090468
    },
    {
        "content": "<blockquote>\n<p>I want to use <code>*mut [T]</code> in my APIs, and I want to be able to call them with <code>foo(x : &amp;mut [T])</code> and have that to just work.</p>\n</blockquote>\n<p>Without null checking ? That may work most of the time but have fun debugging any error due to UB on that</p>",
        "id": 248365177,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090487
    },
    {
        "content": "<p>Also these are not \"refs\", these are raw pointers for a reason, so treating them as references inside the function would be UB.</p>",
        "id": 248365192,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090497
    },
    {
        "content": "<p>A &amp;mut T is never null, no need to check that.</p>",
        "id": 248365215,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090514
    },
    {
        "content": "<p>I understood your sentence as « passing a pointer as a reference »</p>",
        "id": 248365314,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090548
    },
    {
        "content": "<p>passing a reference where a pointer is expected</p>",
        "id": 248365333,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090562
    },
    {
        "content": "<p><code>foo(x: &amp;mut [T])</code> is a function call with type ascription</p>",
        "id": 248365364,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090576
    },
    {
        "content": "<p>the signature of <code>foo</code> would be <code>fn foo(x: *mut [T])</code></p>",
        "id": 248365398,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090595
    },
    {
        "content": "<p>going from <code>&amp;mut [T]</code> to <code>*mut [T]</code> is ok, and works automatically</p>",
        "id": 248365445,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090617
    },
    {
        "content": "<p>the other way around isn't always sound</p>",
        "id": 248365473,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090629
    },
    {
        "content": "<blockquote>\n<p>A fork is trivial. Making the function generic, isn't. I don't want generic functions, I want functions.</p>\n</blockquote>\n<p>I disagree on that, but why do you want no generics ?</p>",
        "id": 248365563,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090663
    },
    {
        "content": "<p>Are you doing FII ?</p>",
        "id": 248365596,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090676
    },
    {
        "content": "<p>Because it makes no sense to make functions generic just for this.</p>",
        "id": 248365603,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090680
    },
    {
        "content": "<p>But generics are made especially for this type of problems, especially with traits</p>",
        "id": 248365680,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090710
    },
    {
        "content": "<p>Abstracting over common behavior of different types</p>",
        "id": 248365753,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090744
    },
    {
        "content": "<p>Generics are made for when you need a function to be generic, the function <code>foo</code> above doesn't have to be.</p>",
        "id": 248365768,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090752
    },
    {
        "content": "<p>You can misuse generics for this, but I don't want to do that.</p>",
        "id": 248365847,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090772
    },
    {
        "content": "<p>The consequence is slower compile-times, larger binary sizes, etc.</p>",
        "id": 248365874,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090788
    },
    {
        "content": "<p>Things I'm not willing to trade-off when the fix is simple.</p>",
        "id": 248365899,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090800
    },
    {
        "content": "<p>Specifically this no, but the Slice/[T] problem earlier is just that, hidden common behavior</p>",
        "id": 248365900,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090800
    },
    {
        "content": "<p>No, the problem is lack of user defined coercions.</p>",
        "id": 248365942,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090822
    },
    {
        "content": "<p>There are many ways to work around that. Making all your API generic is just one way with few pros and many cons.</p>",
        "id": 248366007,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090862
    },
    {
        "content": "<blockquote>\n<p>What I mean is, code using NonNull&lt;T&gt; has the exact same issues as using *mut T directly, in that there is no singular correct default for the type. NonNull&lt;T&gt; can represent an owning, mutably borrowing, immutably borrowing, shared mutably borrowing, etc. pointer just as much as a raw pointer can.</p>\n</blockquote>\n<p>A raw pointer isn't owning, not per se. You can build a Box type on top, and give it owning semantics if you want, but if some C API returns you an opaque raw pointer, it can be anything.</p>",
        "id": 248366192,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090943
    },
    {
        "content": "<p>Passing these pointers across threads is safe and sound.</p>",
        "id": 248366234,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090963
    },
    {
        "content": "<p>Giving extra meaning to these pointers, like ownership or borrowing, is the job of higher level types.</p>",
        "id": 248366256,
        "sender_full_name": "hannahE2",
        "timestamp": 1628090979
    },
    {
        "content": "<p>Deref, AsRef, Into, TryInto are all user defined coercions that exist today and would probably work for you, at the cost of a few seconds of compile time. Forking rustc and breaking pretty much every crate and the standard library by making pointers send and sync seems like a lot of work compared to that, especially if other people come to work on your project and they have to relearn the rules</p>",
        "id": 248366286,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1628090999
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248365899\">said</a>:</p>\n<blockquote>\n<p>Things I'm not willing to trade-off when the fix is simple.</p>\n</blockquote>\n<p>As mentioned, maintaining a fork of rust the language is not simple. For starters, you are no longer writing rust, you are writing hannahE2-rust, with different global invariants and requirements, and now you have to audit all of your unsafe code within the context of your own fork, including unsafe code you perhaps didn't write.</p>",
        "id": 248366364,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628091023
    },
    {
        "content": "<p>For me its simple.</p>",
        "id": 248366418,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091048
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248366192\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>What I mean is, code using NonNull&lt;T&gt; has the exact same issues as using *mut T directly, in that there is no singular correct default for the type. NonNull&lt;T&gt; can represent an owning, mutably borrowing, immutably borrowing, shared mutably borrowing, etc. pointer just as much as a raw pointer can.</p>\n</blockquote>\n<p>A raw pointer isn't owning, not per se. You can build a Box type on top, and give it owning semantics if you want, but if some C API returns you an opaque raw pointer, it can be anything.</p>\n</blockquote>\n<p>And that anything can including being owning. I use raw pointers a ton in C to represent an owned type. If you treated it as a shared type, you'd be incorrect and cause soundness issues. And in some cases, it's not sound to transfer to a different thread because the thing it's owning isn't sound to use on a different thread. Raw pointers don't communicate what they are (owning, borrowing, shared owning), but that doesn't mean it's none of those things, it means they can be any of those things.</p>",
        "id": 248366627,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628091140
    },
    {
        "content": "<p>Thus, the default for  them is the one that is the most correct, and the most noisy when it's incorrect.</p>",
        "id": 248366786,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628091223
    },
    {
        "content": "<blockquote>\n<p>you'd be incorrect and cause soundness issues. </p>\n</blockquote>\n<p>No, this _can't_ cause a soundness issue without an unsafe block somewhere.</p>",
        "id": 248366887,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091270
    },
    {
        "content": "<p>And its that <code>unsafe</code> block which cause the soundness bug, not this.</p>",
        "id": 248366912,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091282
    },
    {
        "content": "<p>You can write a <code>Unique</code>, <code>Shared</code>, etc. wrapper on top of raw pointers to give them more meaning. </p>\n<p>But sending a raw pointer to another thread is ok. Using it might always, never, or sometimes be ok, depending on runtime state. Those conditions should be checked before the <code>unsafe</code> block.</p>",
        "id": 248367440,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248366256\">said</a>:</p>\n<blockquote>\n<p>Giving extra meaning to these pointers, like ownership or borrowing, is the job of higher level types.</p>\n</blockquote>\n<p>As an aside, this would be an argument against using raw pointers extenrally.</p>",
        "id": 248367459,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628091567
    },
    {
        "content": "<p>Your argument could be applied to <code>NonNull</code> as well, i.e., if you ever use a raw pointer, it must not be null, therefore we only need <code>NonNull</code>, and we don't need raw pointers that can be null.</p>",
        "id": 248367522,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091601
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248367440\">said</a>:</p>\n<blockquote>\n<p>You can write a <code>Unique</code>, <code>Shared</code>, etc. wrapper on top of raw pointers to give them more meaning. </p>\n<p>But sending a raw pointer to another thread is ok. Using it might always, never, or sometimes be ok, depending on runtime state. Those conditions should be checked before the <code>unsafe</code> block.</p>\n</blockquote>\n<p>Some requirements can be hard to check and are easier to just through invariants.</p>",
        "id": 248367597,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628091622
    },
    {
        "content": "<p>The fact remains that it is still valuable to have pointers that are null or non-null dynamically, depending on context, and in the same way it is useful to have raw pointers, that have different ownership / borrowing semantics, depending on context, and in both cases it is useful to send these types across threads, and doing so is correct and sound.</p>",
        "id": 248367701,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091689
    },
    {
        "content": "<p>Checking what you have is a dynamic check that you have to do before using <code>unsafe</code>, otherwise you can get UB. </p>\n<p>You can avoid those checks by using wrappers that encode them statically, but the fact that you can write those wrappers does not mean that they solve all problems.</p>",
        "id": 248367821,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091738
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248367701\">said</a>:</p>\n<blockquote>\n<p>The fact remains that it is still valuable to have pointers that are null or non-null dynamically, depending on context, and in the same way it is useful to have raw pointers, that have different ownership / borrowing semantics, depending on context, and in both cases it is useful to send these types across threads, and doing so is correct and sound.</p>\n</blockquote>\n<p>That is true (though <code>Option&lt;NonNull&lt;T&gt;&gt;</code> expresses this much better than raw pointers). <br>\nMy argument is that apis that aren't low-level apis should typically not publically use pointers.</p>",
        "id": 248367876,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628091764
    },
    {
        "content": "<p>I agree with your argument. </p>\n<p>I think people that use raw pointers should know better, and have to deal with unsafe anyways.</p>\n<p>Adding hurdles to them that solve no problems makes no sense, particularly when doing so makes the notion of soundness in rust more complicated.</p>",
        "id": 248368075,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091843
    },
    {
        "content": "<p>And that if apis are not publically using pointers, there is little benefit to having them incorrectly default to being universally Send+Sync, and unwittingly opting a huge amount of unsafe code using them into that default which is more likely than not invalid for their type.</p>",
        "id": 248368154,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628091874
    },
    {
        "content": "<p>Is it sound to send a raw pointer in Rust? Yes, well, no, well depends: some code assumes that they are not Send for soundness, and rely on that, but the raw pointers themselves are sound to send, so just write a wrapper.</p>",
        "id": 248368195,
        "sender_full_name": "hannahE2",
        "timestamp": 1628091894
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Copy.20type.20that.20is.20not.20Send/near/248368195\">said</a>:</p>\n<blockquote>\n<p>Is it sound to send a raw pointer in Rust? Yes, well, no, well depends: some code assumes that they are not Send for soundness, and rely on that, but the raw pointers themselves are sound to send, so just write a wrapper.</p>\n</blockquote>\n<p>Users cannot opt-out as is (and negative impls have way too many open questions to consider stabilizing at this time IIRC). Even if they could, the fact that it's <code>!Send+!Sync</code> is very noisy when you try to (mis)use them, which makes it strictly better than having them default to <code>Send+Sync</code> which would silently break. It's fairly easy to misjustify things, especially surrounding thread safety, and there is no reason that a low-level piece of the rust language that should only ever be used internally should contribute to that.</p>",
        "id": 248368598,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628092091
    },
    {
        "content": "<p>(Also related, raw pointers are the only way to opt out of Send without having to embed a lifetime in your type)</p>",
        "id": 248368673,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628092133
    },
    {
        "content": "<p>Are there any other <code>Copy + !Send</code> types ? That's really weird the more I think about it.</p>",
        "id": 248369141,
        "sender_full_name": "hannahE2",
        "timestamp": 1628092389
    },
    {
        "content": "<p>Sure, <code>&amp;T</code> where <code>T: !Sync</code>, but that's also <code>!Sync</code>.<br>\nIn fact, any type that is <code>Sync+Copy</code> must logically be <code>Send</code>.</p>",
        "id": 248369539,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628092607
    },
    {
        "content": "<p>Right, so <code>&amp;T</code> is Copy, but if <code>T</code> is not <code>Sync</code> then <code>&amp;T</code> is not  <code>Send</code></p>",
        "id": 248370012,
        "sender_full_name": "hannahE2",
        "timestamp": 1628092821
    },
    {
        "content": "<p>Yup, since, by definition <code>T: Sync &lt;=&gt; &amp;T: Send</code></p>",
        "id": 248370155,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628092885
    },
    {
        "content": "<p><code>&amp;Cell&lt;T&gt;</code> is <code>Copy + !Send</code><br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9276550dbef4eabfb71948a1fdb88d78\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9276550dbef4eabfb71948a1fdb88d78</a></p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0277]: `Cell&lt;()&gt;` cannot be shared between threads safely\n --&gt; src/main.rs:4:5\n  |\n1 | fn foo&lt;T: Send + Copy&gt;() {}\n  |           ---- required by this bound in `foo`\n...\n4 |     foo::&lt;&amp;std::cell::Cell&lt;()&gt;&gt;();\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Cell&lt;()&gt;` cannot be shared between threads safely\n  |\n  = help: the trait `Sync` is not implemented for `Cell&lt;()&gt;`\n  = note: required because of the requirements on the impl of `Send` for `&amp;Cell&lt;()&gt;`\n</code></pre></div>",
        "id": 248380003,
        "sender_full_name": "matt1992",
        "timestamp": 1628097493
    },
    {
        "content": "<p>if you dislike non-Send pointers just wait till you notice that pointers don't impl Default.</p>",
        "id": 248384916,
        "sender_full_name": "Lokathor",
        "timestamp": 1628099900
    }
]