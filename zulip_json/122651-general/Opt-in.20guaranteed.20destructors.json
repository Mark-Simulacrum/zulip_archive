[
    {
        "content": "<p>I was chatting with embedded folks today, and we had this idea of adding an opt-in way to \"defeat\" the leakpocalypse. We would add the following to <code>core::mem</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"n\">auto</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Leak</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">PhantomPlug</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"n\">Leak</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">PhantomPlug</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p><code>Leak</code> represents types that may be safely leaked. It is implemented for <em>all</em> Rust types, unless they contain a <code>PhantomPlug</code> (real name tbd). Since no currently written Rust type contains <code>PhantomPlug</code>, <em>everything</em> will remain leakable, which avoids breakage.</p>\n<p>In addition to this, <code>T: Leak</code> would also have to become a default type parameter bound, similar to <code>T: Sized</code>. That way, every container on <a href=\"http://crates.io\">crates.io</a> and liballoc that leaks stuff remains sound, even in the presence of types that must not be leaked. Containers that have been sufficiently reviewed and would like to give the user a hard guarantee that they won't leak their contents can then remove the bound via <code>T: ?Leak</code>. Due to how auto-traits work, if I then have a <code>Box&lt;T: !Leak&gt;</code>, the <code>Box</code> also stops implementing <code>Leak</code>, so I feel like this <em>should</em> impose the right requirement at all times. <code>mem::forget</code> and <code>Rc</code> as well as <code>Arc</code> would not be able to lift the implicit <code>Leak</code> bound, because they <em>can</em> be used to leak data.</p>\n<p>Types that perform background I/O into a borrowed buffer would then add a <code>PhantomPlug</code> field, and could safely cancel or block on said I/O in their <code>Drop</code> implementation.</p>\n<p>Now this is clearly far too simple to be correct and sufficient, right? Can anyone tell me where this idea falls apart?</p>",
        "id": 211547326,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601325573
    },
    {
        "content": "<p>At the very least, current rough consensus as I interpret it in lang team is that another \"?Sized\" like trait is pretty high cost, and I think leak is unlikely to be seen as sufficiently interesting to warrant the cost</p>",
        "id": 211547717,
        "sender_full_name": "simulacrum",
        "timestamp": 1601325781
    },
    {
        "content": "<p>To give a bit of motivation as to why we want to fix this:</p>\n<p>On embedded systems, doing the same thing as ringbahn does (heap-allocating an owned backing buffer) would, as far as I understand, result in <em>doubling</em> memory usage of DMA buffers, which is not an acceptable trade-off there. The alternative would be to make almost every DMA API <code>unsafe</code>, which is also not appealing, and with async/await, that would be the <em>only</em> API, so that wouldn't be very good.</p>\n<p>Such APIs could work fine with <code>&amp;'static mut</code> buffers, but those have move semantics and need to be pre-allocated statically (or leaked from the heap â€“ and heap allocations are still unstable, and are generally undesirable; and if we could do this we might as well do what ringbahn does).</p>",
        "id": 211547758,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601325805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Ah, I see. That's understandable, <code>#[no_std]</code> async/await is still fairly new, and I think we (embedded WG) haven't really been doing a good job at communicating with the lang team.</p>",
        "id": 211547995,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601325949
    },
    {
        "content": "<p>Pretty unfortunate though, I don't really see us building usable DMA APIs without something like this...</p>",
        "id": 211548108,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601325993
    },
    {
        "content": "<p>(for more details see recentish comments on unsized types rfcs)</p>",
        "id": 211548182,
        "sender_full_name": "simulacrum",
        "timestamp": 1601326036
    },
    {
        "content": "<p>\"Introduce Pointee and DynSized\"?</p>",
        "id": 211548228,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601326064
    },
    {
        "content": "<p>I think so, not sure, let me track it down</p>",
        "id": 211548266,
        "sender_full_name": "simulacrum",
        "timestamp": 1601326082
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/pull/2984#issuecomment-694843100\">https://github.com/rust-lang/rfcs/pull/2984#issuecomment-694843100</a></p>",
        "id": 211548378,
        "sender_full_name": "simulacrum",
        "timestamp": 1601326131
    },
    {
        "content": "<p>I think Leak has a somewhat stronger motivation, but I don't think \"strong enough\"</p>",
        "id": 211548505,
        "sender_full_name": "simulacrum",
        "timestamp": 1601326201
    },
    {
        "content": "<p>The problem comes down to imposing the cost of thinking about it on everyone. I'd be interested to hear how languages like C or C++, Zig(?) etc solve this - my guess is the answer is external whole program analysis of some kind with manual annotations?</p>",
        "id": 211548672,
        "sender_full_name": "simulacrum",
        "timestamp": 1601326282
    },
    {
        "content": "<p>Or the language <em>doesn't</em> solve it, requiring the programmer to deal.</p>",
        "id": 211548846,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601326373
    },
    {
        "content": "<p>C and C++ don't solve the problem, you get the usual headache of having to manually ensure all buffers live long enough, complicated by the fact that there is now an arbitrary number of read/write accesses going on in the background via DMA.</p>",
        "id": 211549105,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601326495
    },
    {
        "content": "<p>If I understand correctly, the original motivation was that <code>static</code>, <code>Rc</code> and <code>ManuallyDrop</code> (and thus also <code>MaybeUninit</code>) can let you avoid dropping safely, without <code>mem::forget</code>.</p>\n<p>The latter two would soundly work with this thanks to their <code>Leak</code> bound, while <code>static</code>s and <code>Rc</code> could have this solved in a different way: specify that <code>!Leak</code> types <em>might actually not get dropped after all</em>, but the imaginary <code>mem::forget</code> there would happen <em>after</em> the <code>'static</code> lifetime.</p>",
        "id": 211549279,
        "sender_full_name": "Goat",
        "timestamp": 1601326578
    },
    {
        "content": "<p>The problem is that <code>forget</code> makes any external buffer borrowed by the forgotten object accessible to the program again (the borrow's lifetime ends), but the destructor that would stop the I/O is not run before that happens. Are you proposing to change how <code>mem::forget</code> and <code>Rc</code> interact with the borrow checker?</p>",
        "id": 211549644,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601326799
    },
    {
        "content": "<p><code>static</code> is not an issue by the way, it can't borrow any non-<code>'static</code> data</p>",
        "id": 211549738,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601326833
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"323980\">@Goat</span> ^</p>",
        "id": 211550739,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601327324
    },
    {
        "content": "<p>Circling back to the proposal: I agree that adding another implicit bound would come at a cost, but what RFC 2984 proposes affects the often misunderstood <code>Sized</code> trait itself, which may bleed into diagnostics etc. and so make sizedness of types even harder to understand.</p>\n<p>The <code>T: ?Leak</code> bound <em>would</em> show up in <code>std::collections</code> once they have been reviewed accordingly, but errors due to a missing <code>Leak</code> bound would only show up once the trait has been adopted by the ecosystem (so a while after stabilization).</p>",
        "id": 211551081,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601327473
    },
    {
        "content": "<p>I think the problem is that too, but it's even just the cost of \"every library defining a struct gets asked to add T: ?Leak\" basically, right?</p>",
        "id": 211551529,
        "sender_full_name": "simulacrum",
        "timestamp": 1601327744
    },
    {
        "content": "<p>Yeah, I can see that as a problem. Almost every type <em>can</em> add a <code>T: ?Leak</code> bound, after all, and if there's some fundamental io-uring type that doesn't implement <code>Leak</code> then that might bleed into large parts of the async ecosystem.</p>",
        "id": 211551652,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601327830
    },
    {
        "content": "<p>This is less of a problem in embedded because things are much much smaller there, and I don't expect people to often do more than just <code>.await</code> the transaction immediately, so only the executor would have to cope with <code>!Leak</code> types.</p>",
        "id": 211551729,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601327884
    },
    {
        "content": "<p>OTOH there isn't much to do with such an io-uring future other than <code>.await</code>ing it and using it with the <code>futures</code> combinators and possibly <code>std::collections</code>, so maybe the impact is fairly limited.</p>",
        "id": 211552445,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601328328
    },
    {
        "content": "<p>Hmm, now one question is how this would interact with trait objects. You'd often have <code>Box&lt;dyn Future&gt;</code> after all.</p>",
        "id": 211552491,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601328360
    },
    {
        "content": "<p>I think the other place the \"cost of another implicit-bound auto trait is too high\" conversation came up was with <code>?Move</code> for futures, but that's how we got <code>Pin</code> instead.</p>",
        "id": 211780089,
        "sender_full_name": "scottmcm",
        "timestamp": 1601480718
    },
    {
        "content": "<p>I also heard something about how <code>Pin</code> allows you to get guaranteed destructors as well, but I never got to fully understand how that'd work</p>",
        "id": 211780860,
        "sender_full_name": "Goat",
        "timestamp": 1601481039
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/pin/index.html#drop-guarantee\">https://doc.rust-lang.org/std/pin/index.html#drop-guarantee</a></p>\n<blockquote>\n<p>Notice that this guarantee does <em>not</em> mean that memory does not leak! It is still<br>\ncompletely okay not ever to call <code>drop</code> on a pinned element (e.g., you can still<br>\ncall <code>mem::forget</code> on a <code>Pin&lt;Box&lt;T&gt;&gt;</code>). In the example of the doubly-linked<br>\nlist, that element would just stay in the list. However you may not free or reuse the storage<br>\n<em>without calling <code>drop</code></em>.</p>\n</blockquote>",
        "id": 211781385,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601481245
    },
    {
        "content": "<blockquote>\n<p>I also heard something about how Pin allows you to get guaranteed destructors as well, but I never got to fully understand how that'd work</p>\n</blockquote>\n<p>It boils down to the unsafe contact of <code>Pin::new_unchecked</code> being leaky/impure. I.e. it's correctness does not only depend on the value you pass to <code>new_unchecked</code> but also on how the value this value dereferences to is used after <code>Pin</code> is <del>dropped</del> out of scope (potentially leaked). </p>\n<p>The most simple case is that you guaranteed that it's <em>not</em>  used in any place after the usage in <code>Pin</code>. Which is very similar to why embedded wants a guaranteed drop for DMA.</p>",
        "id": 211807393,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601493581
    },
    {
        "content": "<p>Since I forgot to state it alongside my earlier quote, my reading is that <code>Pin</code> does <strong>not</strong> guarantee that the destructor is run.</p>",
        "id": 211807844,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601493814
    },
    {
        "content": "<p>Yes, it doesn't.</p>",
        "id": 211807871,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601493833
    },
    {
        "content": "<p>It just guarantee that you don't reuse that memory <em>until</em> drop is run.</p>\n<p>So if you don't drop you can't reuse the memory.</p>\n<p>Which is where the \"leakyness\"/impurity of <code>Pin::new_unchecked</code> comes in, it makes you guarantees about the usage of the value you pinned through some pointer. </p>\n<p>And sure if you can guarantee the value is properly dropped you don't need to uphold any guarantees for it anymore and can reuse it's memory slot.</p>",
        "id": 211808669,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601494261
    },
    {
        "content": "<hr>\n<p>As far as I understand the thing embedded/DMA needs is the guarantee that the memory/buffer is not reused until the DMA operation started on it did finish or was successfully canceled (which might not happen in a <code>Drop</code> of some kind of handler type representing the DMA operation).</p>",
        "id": 211809479,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601494677
    },
    {
        "content": "<p>If that's the case and if I understand (the latter being less likely), then the fact that <code>Pin</code> really isn't _that_ special should be relevant. <code>Pin</code> is basically just a type-system marker to the programmer. It should be possible to create <code>MyPinLikeThing&lt;T&gt;</code> that has whatever desired semantics.</p>",
        "id": 211810119,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601495009
    },
    {
        "content": "<p>Yes, but it is <em>very</em> hard to get right.</p>\n<p>A lot of very clever people double and tipple checked <code>Pin</code> and we currently still have soundness holes in it (which currently probably can't be taken advantage of on stable).</p>\n<p>Mainly the way it interacts with <code>CoerceUnsized</code> is not fully sound and the interaction it has with how <code>fundamental types</code> works is potentially also not fully sound (but you seem to need the <code>CoerceUnsized</code> \"hole\" to take advantage of it? probably?).</p>\n<p>Furthermore the discussions around it doesn't give me any trust in that all or even most people involved do fully understand all implication derived from <code>Pin</code>'s unsafe contract and it's interaction with all other parts of rust (and that's not because of missing skill but of a lot of hidden complexity).</p>\n<p>Lastly it would mean that any <code>DMA</code> setup would need to use some unsafe code to do something like <code>Pin:new_unchecked</code> but in a way which might likely in the constraints of embedded be harder to abstract over and IMHO <code>Pin::new_unchecked</code> is probably the hardest to get right unsafe rust function I have seen.</p>",
        "id": 211811273,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601495561
    },
    {
        "content": "<p>I agree with all your points, but my main idea/thrust is that it can be prototyped outside of the standard library, like a lot of futures stuff was.</p>",
        "id": 211811449,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601495638
    },
    {
        "content": "<p>The problem we're trying to solve is isomorphic to building an asynchronous interface to completion-based I/O APIs like io-uring and IOCP, so the same problems and potential solutions apply</p>",
        "id": 211811589,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601495697
    },
    {
        "content": "<p>Sure, I also feel that with a stable <code>alloca</code>/<code>unsized types on stack</code> we might be able to have a <code>Pin</code> like API with proper safe abstractions around it for DMA.  </p>\n<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink</span> : Is there any kind of blog, rust user/internal forum thread which has more details about what exactly the problems with DMA are? I have hardly any embedded experience so I might very likely missguess what exactly is needed <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span> . EDIT: Wrote this before receiving/reading you last comment.</p>",
        "id": 211811897,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601495845
    },
    {
        "content": "<p>There are some fundamental shortcomings in the usual approaches taken for such an API, namely:</p>\n<ul>\n<li>An API may be built that uses <code>&amp;'static mut</code> buffers only, which have move semantics. The problem is that the DMA API then takes ownership of the buffer, and <em>somehow</em> needs to give it back to the caller, which results in awkward APIs, and the limitation to <code>'static</code> means that no on-stack buffers can be used.</li>\n<li>A blocking API can be used. The library code has full control over the entire duration of the transfer and works fine with on-stack buffers. Drawback: <em>Nothing</em> else can be done while the transfer is in progress, which is too limiting for embedded apps (with a framework like <a href=\"https://rtic.rs/\">RTIC</a> this operation can be preempted and other code can run, but this is still fairly limiting).</li>\n<li>An owned intermediate buffer can be used for all asynchronous I/O. I believe this is the approach that ringbahn takes, and it solves the problem by leaking the memory that is being accessed when the transfer type is leaked. This is impractical on embedded due to the increased (potentially doubled) memory usage.</li>\n</ul>\n<p>These are all approaches I am aware of. There might be more that I haven't seen yet.</p>",
        "id": 211812614,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601496174
    },
    {
        "content": "<p>Fundamentally, if you have an API like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">transfer</span><span class=\"p\">(</span><span class=\"n\">dest</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Callers are always free to drop or leak the <code>impl Future</code> after creating and polling it. This ends the borrow of <code>dest</code> and makes it accessible to the original owner again.</p>\n<p>I don't see any way of avoiding this other than language-level support for types whose destructors must run before they give back their loan on the borrowed data.</p>",
        "id": 211813088,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601496408
    },
    {
        "content": "<blockquote>\n<p>which have move semantics.</p>\n</blockquote>\n<p>You mentioned that earlier, but _everything_ has move semantics, so I'm lost.</p>",
        "id": 211813690,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601496686
    },
    {
        "content": "<p>And what's the ideal goal / API?</p>",
        "id": 211813918,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601496830
    },
    {
        "content": "<p><code>&amp;mut [u8]</code> doesn't due to reborrows, but <code>&amp;'static [u8]</code> always moves ownership of the reference</p>",
        "id": 211813933,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601496841
    },
    {
        "content": "<blockquote>\n<p>Callers are always free to drop or leak the impl Future after creating and polling it. This ends the borrow of dest and makes it accessible to the original owner again.</p>\n</blockquote>\n<p>Is the problem that if they drop the future that the DMA engine can still write to that memory? And some other Rust code might have since assumed it was immutable?</p>",
        "id": 211814583,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497120
    },
    {
        "content": "<p>If so, feels a lot like shared ownership / internal mutability.</p>",
        "id": 211814680,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497164
    },
    {
        "content": "<p>Do we have any stack-only <code>Rc</code>?</p>",
        "id": 211814821,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497211
    },
    {
        "content": "<p>Yes, the transfer just runs in the background and needs to be explicitly stopped or blocked on</p>",
        "id": 211814831,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497218
    },
    {
        "content": "<p>Why do you need <code>Rc</code>? Sounds more like something on top of <code>UnsafeCell</code> might help, but I don't immediately see how</p>",
        "id": 211814886,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497253
    },
    {
        "content": "<p>I'm thinking <code>Rc</code> mostly because I'd want to model it as \"owned by me / owned by DMA\"</p>",
        "id": 211814976,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497290
    },
    {
        "content": "<p>on the first <code>poll</code>, you mark it as owned by DMA</p>",
        "id": 211815005,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497311
    },
    {
        "content": "<p>and it it already was, you panic.</p>",
        "id": 211815018,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497319
    },
    {
        "content": "<p>You could already do that by moving an owned buffer into and out of the transfer</p>",
        "id": 211815088,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497343
    },
    {
        "content": "<p>Which, I guess, is the least awful API we can build right now, but still won't work with on-stack buffers at all</p>",
        "id": 211815132,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497375
    },
    {
        "content": "<p>This actually you can use Pin for:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">transfer</span><span class=\"p\">(</span><span class=\"n\">dest</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">MustFree</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">MustFree</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MustFree</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">abort</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"cm\">/* Not been freed */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 211815149,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601497382
    },
    {
        "content": "<p>but the moving back out is the ugly part of that, right?</p>",
        "id": 211815155,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497386
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"229913\">@HeroicKatora</span> I thought you were still allowed to not call <code>Drop</code> on that?</p>",
        "id": 211815236,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497437
    },
    {
        "content": "<p>Or would you have to, before the <code>&amp;mut MustFree</code> borrow ends?</p>",
        "id": 211815307,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497458
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Opt-in.20guaranteed.20destructors/near/211815155\">said</a>:</p>\n<blockquote>\n<p>but the moving back out is the ugly part of that, right?</p>\n</blockquote>\n<p>The worst part is probably that it doesn't work with on-stack buffers</p>",
        "id": 211815355,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497483
    },
    {
        "content": "<p>I would be fine with a slightly awkward API if it meant that it works with on-stack buffers</p>",
        "id": 211815394,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497508
    },
    {
        "content": "<p>I was thinking something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Thing</span>::<span class=\"n\">new</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">]);</span><span class=\"w\"></span>\n\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">transfer</span><span class=\"p\">(</span><span class=\"n\">dest</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Thing</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>And then you flip the cell inside when the poll starts and check the cell when you want the data.</p>",
        "id": 211815452,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497554
    },
    {
        "content": "<p>so <code>buf</code> is on the stack</p>",
        "id": 211815520,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497573
    },
    {
        "content": "<p>You could still leak the future and deallocate <code>buf</code> without stopping the transfer though</p>",
        "id": 211815782,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497706
    },
    {
        "content": "<p>Ah, I didn't realize that stopping it was an important goal. I thought it was more about preventing the memory unsafety.</p>",
        "id": 211815872,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497747
    },
    {
        "content": "<p>It feels like if you leak a value and your system locks up, that's more of a \"don't do that\" issue, but I understand wanting to get the compiler to do as much as possible.</p>",
        "id": 211815954,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497797
    },
    {
        "content": "<p>The unsafety arises when you reuse the array's memory later and DMA writes to it ;)</p>",
        "id": 211816019,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601497808
    },
    {
        "content": "<p>Took a while to check: If you don#t call drop on it, you must leak it</p>",
        "id": 211816061,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601497834
    },
    {
        "content": "<p>Which is precisely as strong as you need. The caller can either leak the buffer, aka. move ownership to the DMA.<br>\nOr they can choose to wait on getting it back and drop it, but then they can not leak it.</p>",
        "id": 211816184,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601497909
    },
    {
        "content": "<p>Now I've lost myself: what does leaking a future do with the stack frames within the future? I know I'm not using the terminology correctly, but I can't figure out how best to phrase it.</p>",
        "id": 211816329,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601497984
    },
    {
        "content": "<p>You can leak a future, as if leaving it just permanently pending. The 'stack frame' is just another struct, well it's more like an enum internally, so you'll also leak any of those resources. You don't want to do it but it would be sound. In this particular instance, the DMA could continue to write into the buffer without any real effect.</p>",
        "id": 211817264,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601498472
    },
    {
        "content": "<p>Right, that's the thing I'm stuck on. So you leak a future but the DMA writes to the futures \"stack frame\". When would that be unsound in the first place?</p>",
        "id": 211817591,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601498597
    },
    {
        "content": "<p>If you'd deallocate the frame and reuse the memory for something else.</p>",
        "id": 211817631,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601498623
    },
    {
        "content": "<p>Then the other side of the DMA would continue to write but, oh no, it now overwrites some arbitrary other object's data.</p>",
        "id": 211817723,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601498647
    },
    {
        "content": "<p>Now you've said deallocate though.</p>",
        "id": 211817925,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601498733
    },
    {
        "content": "<p>This dilemma makes it impossible to have an unpinned guard that somehow waits on the DMA transfer in its Drop.<br>\nIf something isn't pinned, I can skip its drop impl by leaking it, and then immediately pretend the guard's lifetime has ended.<br>\nPinning makes this an xor choice: Either leak it and preserve the guard forever, OR drop the guard.</p>",
        "id": 211818138,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601498810
    },
    {
        "content": "<p>Is it something like this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">start_dma</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">exercise</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">example</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">example</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 211818211,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601498850
    },
    {
        "content": "<p>Ah, okay, so you would have to pin the buffer before starting the I/O, not the returned future before polling it?</p>",
        "id": 211818523,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601498978
    },
    {
        "content": "<p>Pinning the buffer doesn't do anything.</p>",
        "id": 211818580,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601498996
    },
    {
        "content": "<p>The buffer is <code>[u8]</code> which just has an empty drop</p>",
        "id": 211818656,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601499010
    },
    {
        "content": "<p>You need to pin a _guard_ that _owns_ the buffer, and waits for completion in its drop.</p>",
        "id": 211818714,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601499039
    },
    {
        "content": "<p>Owning can be a temporary <code>&amp;mut [u8]</code>, that's fine</p>",
        "id": 211818801,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601499067
    },
    {
        "content": "<p>Yes</p>",
        "id": 211819028,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601499168
    },
    {
        "content": "<p>That seems like it would lead to a hard to use API though, having to unsafely pin buffers before doing I/O</p>",
        "id": 211819118,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601499207
    },
    {
        "content": "<p>You can pin on the stack.<br>\nThat's one very simple form of pinning that makes leaking impossible.</p>",
        "id": 211819241,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601499246
    },
    {
        "content": "<p>i.e. <code>pin_mut!</code>?</p>",
        "id": 211819278,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601499266
    },
    {
        "content": "<p>I believe that is what it's called in <code>pin-utils</code>, yes.</p>",
        "id": 211825875,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601499294
    },
    {
        "content": "<p><a href=\"https://docs.rs/futures/0.3.5/futures/macro.pin_mut.html\">and re-exported in futures</a></p>",
        "id": 211825927,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601499318
    },
    {
        "content": "<p>I wish it just had proper language support though, it's correct but always feels sketchy to rely on shadowing.</p>",
        "id": 211826094,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601499392
    },
    {
        "content": "<p>It's 100% sound though afaik, it's just a weird feeling</p>",
        "id": 211826167,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601499435
    },
    {
        "content": "<blockquote>\n<p>That's one very simple form of pinning that makes leaking impossible.</p>\n</blockquote>\n<p>nope, you can pin on the \"stack\" of an async fn and then leak its future</p>",
        "id": 211827234,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1601499992
    },
    {
        "content": "<p>FWIW I think moving pin_mut! into core/std is quite reasonable, it definitely feels like a foundation construct. I imagine someone could mostly just open a PR to that effect</p>",
        "id": 211827798,
        "sender_full_name": "simulacrum",
        "timestamp": 1601500310
    },
    {
        "content": "<p>You need to pin <em>both</em> the guard (which implements drop) and the buffer!</p>\n<ul>\n<li>Pin guard =&gt; to make sure it's only used iff drop is called</li>\n<li>Pin buffer =&gt; to make sure the buffer is not used until the guard's drop is called</li>\n</ul>\n<p>So you would have something like <code>struct DMABufffer { guard: Guard, buffer: [u8] }</code>  or  e.g. <code>struct DMABuffer&lt;'a&gt; { guard: Guard, buffer: Pin&lt;&amp;'a [u8]&gt;</code>.</p>\n<p>Then a <code>Pin&lt;&amp;mut DMABuffer&gt;</code> would give you the right guarantees and doesn't exclude the chance to re-use the given memory.</p>\n<p>But! How do we get the guarantee? =&gt; Through the <code>unsafe contract</code> of <code>Pin::new_unchecked</code>.</p>\n<p>This means we on a saftey level we either guarantee to not never use the memory  of <code>DMABuffer</code> again or to guarantee that drop will be called on <code>DMABuffer</code>!</p>\n<p>So the reason <code>Pin</code> works (for this) is because it's defined to only work if you already can guarantee it works...</p>\n<p>The think is DMA is like another liftime-wise unbound thread  having a reference to the data.</p>\n<p>Btw. I think I just realized that pinning any stack allocated future is technically braking the <code>Pin</code> unsafe-contract. It's just that because when we leak pin, drop the stack frame and reallocate the stack frame (defacto reusing memory) due to lifetimes we can't \"poke\" the leaked and not droped but mem-resued future anymore and as such can't exploit the contract breach. Uhm we might need to reformulate the unsafe-contract of <code>Pin</code>...</p>",
        "id": 211829395,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601501207
    },
    {
        "content": "<hr>\n<p>So I think for a API you needs:</p>\n<ul>\n<li>Something like the <code>DMABuffer</code> struct mentioned above but with another  <code>referenced: bool</code> field (or maybe <code>Cell&lt;bool&gt;</code> or similar)</li>\n<li>EDIT: Due to the stack frame drop and reallocation issues mentioned above the buffer <em>must not</em> be stack allocated except if you (through some unsafe contract) guarantee that the stack-frame it's one never get dropped. </li>\n<li>\n<p>A fallible way to turn a <code>&amp;mut DMABuffer</code> into a <code>Pin&lt;&amp;mut DMABuffer&gt;</code> which sets the <code>referenced</code> boolean  to <code>true</code> and<br>\n  fails if it already was set to true.</p>\n</li>\n<li>\n<p>Methods taking <code>Pin&lt;&amp;mut DMABuffer&gt;</code></p>\n</li>\n</ul>\n<p>With that you would guarantee to only handout a new <code>Pin&lt;&amp;mut DMABuffer&gt;</code> if the previous one was dropped and <code>Pin</code> would<br>\nprevent any strange move/reborrow problems.</p>",
        "id": 211830352,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601501736
    },
    {
        "content": "<p>The only two <em>big</em> drawback:</p>\n<ul>\n<li>\n<p>With <code>Leak</code> you have the guarantee that <code>Drop</code> was called</p>\n</li>\n<li>\n<p>With the API you don't, you just don't accidental re-use it but<br>\n  what can you do if you run into it being locked. Either retry after<br>\n  a moment or leak the memory forever or panic and restart. Non<br>\n  of which is really nice tbh. EDIT: And no stack allocated buffers.</p>\n</li>\n</ul>",
        "id": 211830649,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601501929
    },
    {
        "content": "<p>How would one construct a safe API like that ? The user can always safely mem::forget the future/pinned buffer and by the end of the scope the stack would be popped and DMA would write to another stack frame</p>",
        "id": 211830705,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601501976
    },
    {
        "content": "<p>Let's say the user provides the buffer and pins it on the stack with <code>pin_mut</code>, passes the <code>Pin&lt;&amp;mut Buffer&gt;</code> to the <code>Transfer</code>, and then forgets the transfer and leaves the stack frame</p>",
        "id": 211830894,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502079
    },
    {
        "content": "<p><span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span> I forgot the most important bullet point. I will edit it.</p>",
        "id": 211830914,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601502095
    },
    {
        "content": "<p>Is there something preventing it from just leaving the stack frame without calling Drop on the Transfer or anything for that matter ?</p>",
        "id": 211837534,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502128
    },
    {
        "content": "<p>Hmm, wait, maybe if you pin the transfer too with pin_mut</p>",
        "id": 211837683,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502229
    },
    {
        "content": "<p>As far as I know you can not make sure that the stack-frame the buffer is one is never dropped (besides putting it into a function which never exists outside of a hardware reset).</p>",
        "id": 211837960,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601502406
    },
    {
        "content": "<p>I think that's possible using both pinned Buffer and pinned Transfer on the stack with pin_mut, but then you're back to move semantics, i.e. the user gives all itz access to the buffer to the Transfer and the transfer has to give it back</p>",
        "id": 211838016,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502448
    },
    {
        "content": "<p><code>pin_mut</code> shadows the original thing, so the drop will be called by the end of the scope, but I don't see how this is better than a <code>&amp;'static [u8]</code></p>",
        "id": 211838171,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502535
    },
    {
        "content": "<p>You would need to make sure that there is no longer any ongoing DMA when the function exist or the stack will be clobbered by DMA.</p>",
        "id": 211838371,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601502653
    },
    {
        "content": "<p>We can do that on the drop of the Transfer type, if we only start it after having a <code>Pin&lt;&amp;mut Transfer&gt;</code>, and the Transfer would need to be !Unpin of course</p>",
        "id": 211838454,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502716
    },
    {
        "content": "<p>But we also need move semantics on the buffer, otherwise we could reuse the buffer (in the same stack frame) after calling forget on the <code>Pin&lt;&amp;mut Transfer&gt;</code></p>",
        "id": 211838562,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502773
    },
    {
        "content": "<p>Which gets us back to where we are now, asking for <code>StableDeref + 'static</code></p>",
        "id": 211838616,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601502817
    },
    {
        "content": "<p>There is no guarantee that a thing like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Transfer</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Will be dropped before anyone gets access to the buffer again, right ?</p>",
        "id": 211838944,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503008
    },
    {
        "content": "<p>Let me give a better example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">transfer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Transfer</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">transfer</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">transfer</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// transfer is Pin&lt;&amp;mut Transfer&gt;</span>\n<span class=\"n\">transfer</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Drop of transfer not guaranteed here, if so, data race...</span>\n<span class=\"n\">buf</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Transfer guaranteed to run drop here</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 211839424,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503283
    },
    {
        "content": "<p>I'm not sure I can fully follow your reasoning. Is the <code>Transfer</code> type a specific in-progress DMA operation?<br>\nI wrote something similar in parallel:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">stack_buffer</span>:  <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"c1\">// DMABase keeps track of all onging DMA operations</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">dma_base</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">DMABase</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">stack_buffer</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">//  Pin + guarantee that `dma_base` will not be leaked and always be dropped.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">dma_base</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">DMAPin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">dma_base</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 211839597,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601503401
    },
    {
        "content": "<p>The thing is the guarantee of <code>Pin</code> are not enough as it doesn't require <code>Transfer</code> to be dropped.<br>\n(Through in the example above it will do so.)</p>",
        "id": 211839709,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601503472
    },
    {
        "content": "<p>Yes, Transfer is what starts and manages a DMA peripheral and transfers</p>",
        "id": 211839743,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503500
    },
    {
        "content": "<p>But you have to follow the invariant of Pin which states that Drop must run if the thing gets deallocate (i.e. end of stack frame)</p>",
        "id": 211839797,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503545
    },
    {
        "content": "<p>Which pin_mut! complies with</p>",
        "id": 211839809,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503560
    },
    {
        "content": "<p>The problem is what if you example happens in a <code>async fn</code> ?</p>\n<p>In which case you can no longer guarantee that drop is run.</p>\n<p>E.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">transfer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Transfer</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">.]</span><span class=\"w\"> </span><span class=\"c1\">//pin transfer start it etc.</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// transfer can leak here</span>\n<span class=\"w\">    </span><span class=\"n\">something</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 211839874,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601503586
    },
    {
        "content": "<p>The problem is that the buffer can be used after the forget of the Pin&lt;&amp;mut Transfer&gt; buf before Transfer::drop</p>",
        "id": 211839887,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503596
    },
    {
        "content": "<p>Sorry, I edited the code, the transfer only starts after getting a Pin&lt;&amp;mut Transfer&gt; and calling start with it</p>",
        "id": 211839951,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503648
    },
    {
        "content": "<p>Yes, but once <code>await</code> is included transfer can always leak. (I edited the last block to make it more clear).</p>",
        "id": 211840037,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601503695
    },
    {
        "content": "<p>Sorry, I haven't used async that much, how could that go around the Pin invariant ?</p>",
        "id": 211840147,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503799
    },
    {
        "content": "<p>If it's on the stack and it's pinned the drop should run by the end of the stack frame</p>",
        "id": 211840216,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503835
    },
    {
        "content": "<p>But like I said, this alone isn't enough for DMA, because we need a guarantee that the drop will run before the user has access to the buffer again</p>",
        "id": 211840253,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503884
    },
    {
        "content": "<p>Which we can only do with move semantics on the buffer</p>",
        "id": 211840272,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601503906
    },
    {
        "content": "<blockquote>\n<p>But like I said, this alone isn't enough for DMA, because we need a guarantee that the drop will run before the user has access to the buffer again</p>\n</blockquote>\n<p>We maybe could do this with some different <code>unsafe</code> constructor/ type like <code>struct DMAPin&lt;T&gt;(Pin&lt;T&gt;)</code> and instead of<br>\n<code>pin_mut</code> have a macro which makes sure the buffer isn't available, maybe. </p>\n<p><em>But the problem is in a async function you don't have the guarantee that the anything after the first await runs.</em></p>",
        "id": 211840439,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601504043
    },
    {
        "content": "<p>Let me try to re-write my code above to be somewhat similar to what async maybe does (i.e. just conceptually similar).</p>",
        "id": 211840503,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601504092
    },
    {
        "content": "<p>But we do have a guarantee that its place in memory will remain there unused, no ?</p>",
        "id": 211840517,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601504101
    },
    {
        "content": "<p>No, give me a moment.</p>",
        "id": 211840548,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601504118
    },
    {
        "content": "<blockquote>\n<p>We maybe could do this with some different <code>unsafe</code> constructor/ type like <code>struct DMAPin&lt;T&gt;(Pin&lt;T&gt;)</code> and instead of <code>pin_mut</code> have a macro which makes sure the buffer isn't available, maybe. </p>\n</blockquote>\n<p>We would need to \"move\" the buffer in and give it back at the end of the transfer, which it's a bit cumbersome, we're doing this now btw, we use <code>StableDeref + 'static</code> for thath</p>",
        "id": 211840774,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601504268
    },
    {
        "content": "<p>Like, that async block will be turned into a future thaf must be pinned before being able to run, right ? If it's pinned at least once then we get the invariant that drop will run before that memory gets used by something else, no ?</p>",
        "id": 211841169,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601504580
    },
    {
        "content": "<p>[EDIT: deleted the futures async transformation pseudo code it turns out that it was well understood and the pseudo code just obfuscates the discussion]</p>\n<p>The point is that the future  could be leaked between it being polled initially (and Transfer being created, pinned and started) and it being polled often enough to complete it and reach the End state.</p>\n<p>With <code>?Leak</code> having a <code>?Leak</code> type in the future would make the future implicitly <code>?Leak</code>and as such you couldn't leak it anymore.</p>\n<p>With the API we discussed we would need to make it unsafe to use it in a future/async block. But the whole point of this is to make it usable in a embedded focused async/await runtime.</p>",
        "id": 211848773,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601505355
    },
    {
        "content": "<p>To complete the above example we could have:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">.]</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// A special block_on on a already pinned future</span>\n<span class=\"c1\">// which randomly stops before completing the future</span>\n<span class=\"n\">block_on_with_random_failure</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">//EDIT:  This doesn't work</span>\n<span class=\"c1\">// now dropping stack frame DMA is potentially still writing to</span>\n</code></pre></div>",
        "id": 211849070,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601505601
    },
    {
        "content": "<p>I'm logging out soon but two takaways from today:</p>\n<ul>\n<li>\n<p><del>DMA + async/await + stack based buffers <em>required</em> <code>?Leak</code> I (<em>now</em>) see no sane way around it.</del><br>\n   EDIT: No, it seems there is no way to safely leak a future on the stack???</p>\n</li>\n<li>\n<p>The <code>Pin</code>'s unsafe-contract wrt. drop guarantees  abstraction doesn't work with anything pinned and we might need to review that. But it seems that without something like DMA  this can't safety hole isn't a problem.</p>\n</li>\n</ul>",
        "id": 211849576,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601505991
    },
    {
        "content": "<hr>\n<blockquote>\n<p>Like, that async block will be turned into a future thaf must be pinned before being able to run, right ? If it's pinned at least once then we get the invariant that drop will run before that memory gets used by  something else, no ?</p>\n</blockquote>\n<p>If we take the description of the current unsafe-contract from std: Yes.</p>\n<p><del>But if we do so <code>pin_mut!</code> is unsafe and any form of \"pin something on the stack\" is unsafe.</del><br>\nEDIT: Or maybe not?</p>",
        "id": 211850010,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601506394
    },
    {
        "content": "<p>pin mut shadows the original thing so you can't call forget on it, so it would be dropped on the end of the stack frame that it was created</p>",
        "id": 211850346,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506711
    },
    {
        "content": "<p>Yes I just realized that  myself.</p>",
        "id": 211850381,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601506744
    },
    {
        "content": "<p>But again, it wouldn't be enough to DMA, because of the buffer</p>",
        "id": 211850391,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506755
    },
    {
        "content": "<p>It only gets dropped by the end of the stack frame, while you could re-use the buffer between mem::forget the transfer and the end of the stack frame</p>",
        "id": 211850514,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506793
    },
    {
        "content": "<p>So we would need to take \"ownership\" of the buffer</p>",
        "id": 211850605,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506812
    },
    {
        "content": "<p>It clearly is possible to leak heap allocated futures.</p>\n<p>But is it possible that because of the interactions between async/Pin etc. it's not possible to leak stack allocated futures?</p>",
        "id": 211850618,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601506819
    },
    {
        "content": "<p>The only way is if you have a divergent function, I think</p>",
        "id": 211850685,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506875
    },
    {
        "content": "<p>Otherwise you break Pin's invariant</p>",
        "id": 211850700,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506897
    },
    {
        "content": "<blockquote>\n<p>So we would need to take \"ownership\" of the buffer</p>\n</blockquote>\n<p>With <code>alloca</code> something like a stack allocated owned <code>DMABuffer</code> instance should be possible. (But then <code>alloca</code> is unstable)</p>",
        "id": 211850712,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601506905
    },
    {
        "content": "<p>What I actually use is <code>heapless::Box</code> it kinda works like a charm</p>",
        "id": 211850774,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506936
    },
    {
        "content": "<p>But it can be a bit wasteful on the resources</p>",
        "id": 211850790,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506959
    },
    {
        "content": "<p>It's a static allocated pool with fixed size allocations</p>",
        "id": 211850822,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601506985
    },
    {
        "content": "<p>So that way I can pass it to the Transfer and get it back after and just do my work anywhere and drop it</p>",
        "id": 211850864,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601507028
    },
    {
        "content": "<p>But yeah, no stack stuff</p>",
        "id": 211850921,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601507056
    },
    {
        "content": "<p>With <code>!Leak</code> we could have that</p>",
        "id": 211850946,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601507082
    },
    {
        "content": "<p>These are the traits we are using today to mark the buffer as safe for DMA APIs: <a href=\"https://docs.rs/embedded-dma/0.1.2/embedded_dma/\">https://docs.rs/embedded-dma/0.1.2/embedded_dma/</a></p>",
        "id": 211851149,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601507268
    },
    {
        "content": "<p>It's basically <code>StableDeref + 'static</code></p>",
        "id": 211851256,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601507355
    },
    {
        "content": "<p>But with some changes to also work with MaybeUninit</p>",
        "id": 211851273,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601507380
    },
    {
        "content": "<p>(Random thing: Is it just me or is <code>heapless::Box</code> missing a <code>Drop</code> implementation?)</p>",
        "id": 211851703,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601507717
    },
    {
        "content": "<p>=&gt; Turns out there are two <code>Box</code> types one with and one without drop <span aria-label=\"laughter tears\" class=\"emoji emoji-1f602\" role=\"img\" title=\"laughter tears\">:laughter_tears:</span>  I need to go to bed.</p>",
        "id": 211851926,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601507918
    },
    {
        "content": "<p>Heh, it's indeed a bit confusing the first time you look at it</p>",
        "id": 211852092,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601508042
    },
    {
        "content": "<p>I have been playing around with a API.</p>\n<p>Basically you will have something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[macro_export]</span><span class=\"w\"></span>\n<span class=\"n\">macro_rules</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"n\">ra_buffer_anchor</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$name</span>:<span class=\"nc\">ident</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"cp\">$init</span>:<span class=\"nc\">literal</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"cp\">$size</span>:<span class=\"nc\">literal</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">AccessType</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"cp\">$name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"cp\">$init</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"cp\">$size</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Safe: By putting the anchor on the same stack scope as the buffer</span>\n<span class=\"w\">        </span><span class=\"c1\">//       and by then pinning it in place and lastly shadowing the</span>\n<span class=\"w\">        </span><span class=\"c1\">//       buffer and unpinned anchor preventing other access to them</span>\n<span class=\"w\">        </span><span class=\"c1\">//       we can make sure that:</span>\n<span class=\"w\">        </span><span class=\"c1\">//       1. the anchor isn't moved away / leaked</span>\n<span class=\"w\">        </span><span class=\"c1\">//       2. no access to the buffer before anchor is dropped. (actually in this case the buffer can only be</span>\n<span class=\"w\">        </span><span class=\"c1\">//            accessed through the anchor).</span>\n<span class=\"w\">        </span><span class=\"c1\">//       3. anchor is dropped or the memory anchor is on is forever leaked</span>\n<span class=\"w\">        </span><span class=\"c1\">//</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"cp\">$name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">RABufferAnchor</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"cp\">$name</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"cp\">$name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"cp\">$name</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Which you can use like following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">ra_buffer_anchor</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">buffer1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1024</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">FakeDMA</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">//buffer1: RABufferHandle&lt;'a, FakeDMA&gt;</span>\n<span class=\"c1\">// buffer1 can be passed around</span>\n</code></pre></div>\n\n<p>An the buffer you can use roughly like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">operation</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fake_dma</span>::<span class=\"n\">start_copy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">buffer1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buffer2</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">operation</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// this will await completion of previous leaked DMA operation before</span>\n<span class=\"w\">    </span><span class=\"c1\">// starting a new one. (it will also hint to the previous operation to be</span>\n<span class=\"w\">    </span><span class=\"c1\">// canceled).</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">operation</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">fake_dma</span>::<span class=\"n\">start_copy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">buffer2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buffer1</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">operation</span><span class=\"p\">.</span><span class=\"n\">complete</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>Through the design isn't yet done.</p>\n<p>Also I had another design where the dma operation consumed the <code>RABufferHandle</code>  and<br>\nreturn it back once it completes, but I fare that would be really annoying to use.</p>",
        "id": 212086631,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601651175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209646\">Philipp Korber</span> <a href=\"#narrow/stream/122651-general/topic/Opt-in.20guaranteed.20destructors/near/211850618\">said</a>:</p>\n<blockquote>\n<p>It clearly is possible to leak heap allocated futures.</p>\n<p>But is it possible that because of the interactions between async/Pin etc. it's not possible to leak stack allocated futures?</p>\n</blockquote>\n<p>stack memory definitely gets deallocated when the function returns, so it must not be possible to leak anything that's stack-allocated an pinned unless the function diverges. everything else would violate the pinning contract.</p>",
        "id": 212166457,
        "sender_full_name": "RalfJ",
        "timestamp": 1601723408
    },
    {
        "content": "<blockquote>\n<p>Btw. I think I just realized that pinning any stack allocated future is technically braking the Pin unsafe-contract. It's just that because when we leak pin, drop the stack frame and reallocate the stack frame (defacto reusing memory) due to lifetimes we can't \"poke\" the leaked and not droped but mem-resued future anymore and as such can't exploit the contract breach. Uhm we might need to reformulate the unsafe-contract of Pin...</p>\n</blockquote>\n<p>could you elaborate? I don't understand how the contract is being violated here.</p>",
        "id": 212166462,
        "sender_full_name": "RalfJ",
        "timestamp": 1601723423
    },
    {
        "content": "<p>Doesnâ€™t Ralfâ€™s point expand beyond this embedded/DMA case?ï¿¼</p>",
        "id": 212168555,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601726785
    },
    {
        "content": "<blockquote>\n<p>so it must not be possible to leak anything that's stack-allocated an pinned unless the function diverges. everything else would violate the pinning contract.</p>\n</blockquote>",
        "id": 212168580,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601726856
    },
    {
        "content": "<p>Yeah sure. This mostly shows that sound stack pinning is really hard as you have to ensure the destructor gets called, because you know that memory is deallocated. That's why it needs this shadowing trick.</p>",
        "id": 212180427,
        "sender_full_name": "RalfJ",
        "timestamp": 1601744687
    },
    {
        "content": "<blockquote>\n<p>That's why it needs this shadowing trick.</p>\n</blockquote>\n<p>But is the shadowing even enough? Can't you do something like:</p>\n<ol>\n<li>start a poll of a future</li>\n<li>pin something on the \"stack\" (a.k.a. part of the generated enum)</li>\n<li>start the \"other\" code that will write to the stack address </li>\n<li>forget the pinned value</li>\n<li>finish the poll with <code>Pending</code></li>\n<li>poll the future again</li>\n<li>create something else on the stack that uses the address again</li>\n<li>the \"other\" actor finally writes to the stack space, and now it's unsafe</li>\n</ol>",
        "id": 212182302,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601747407
    },
    {
        "content": "<p>We ran into an issue with relying on shadowing a stack variable at some point, it was unsound in the presence of <code>yield</code>. In hindsight, maybe that isn't true, since generators are also <code>Pin</code>ned?</p>",
        "id": 212182574,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1601747791
    },
    {
        "content": "<blockquote>\n<p>could you elaborate? I don't understand how the contract is being violated here.</p>\n</blockquote>\n<p>I was confused, it isn't as there is no safe way to leak a value pinned to the stack.</p>",
        "id": 212189471,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601758538
    },
    {
        "content": "<blockquote>\n<p>forget the pinned value</p>\n</blockquote>\n<p>You can not forget the pinned value safely.</p>\n<p>If you use the standard way to pin things to the stack <code>pin_mut!()</code> it makes sure<br>\nthat you can't forget the pinned value by making sure it's owned and by shadowing it.<br>\nFurthermore pinning only affects the value de-referenced directly but not anything<br>\nde-referenced from the de-referenced value so a <code>Pin&lt;&amp;mut &amp;mut T&gt;</code> only pins<br>\nthe second <code>&amp;mut</code> but not the <code>T</code>. Which is important or else you could just use<br>\n<code>ManuallyDrop</code> to \"forget\" the pinned value.</p>",
        "id": 212189625,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601758704
    },
    {
        "content": "<p>It's likely that I'm missing something crucial, but I don't see why you can't do something of the general shape as this uncompiled/untested code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">a</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// pin this somehow</span>\n<span class=\"w\">    </span><span class=\"n\">future</span>::<span class=\"n\">poll_fn</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">ctx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">start_dma_transfer</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">b</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">future</span>::<span class=\"n\">poll_fn</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">ctx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 212189806,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601759015
    },
    {
        "content": "<p>E.g. following is unsafe as it violates the pin contract:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// breach of unsafe contract as you must make sure you don't forget x</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">pinned</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">pinned</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>But following is safe:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">pinned</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">pinned</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">pinned</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"c1\">// can't forget the T in pinned due to shadowing</span>\n<span class=\"p\">[</span><span class=\"o\">..</span><span class=\"n\">arbitrary</span><span class=\"w\"> </span><span class=\"n\">safe</span><span class=\"w\"> </span><span class=\"n\">code</span><span class=\"o\">..</span><span class=\"p\">.]</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 212189807,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759017
    },
    {
        "content": "<p>Effectively, I'm trying to show that the forget happens \"outside\" the stack frame where the pin occurs.</p>",
        "id": 212189847,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601759058
    },
    {
        "content": "<p>The problem is that  in that code:</p>\n<ul>\n<li><code>start_dma_transfer</code> must be <code>unsafe</code> as it must be guaranteed to last until dma is completed </li>\n<li>\n<p>you are stack allocating a buffer and passing that ref to a future, this won't work as the stack it's on<br>\n   will be dropped once the future is returned. (it also won't compile thanks to the borrow checked)</p>\n</li>\n<li>\n<p>to poll a future you need to pin it at which point you can not safely leak it anymore (without literally<br>\n   leaking the stack memory)</p>\n</li>\n</ul>",
        "id": 212189978,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759296
    },
    {
        "content": "<hr>\n<blockquote>\n<p>Effectively, I'm trying to show that the forget happens \"outside\" the stack frame where the pin occurs.</p>\n</blockquote>\n<p>Which isn't possible if the future is polled on the stack with safe code.</p>",
        "id": 212189999,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759330
    },
    {
        "content": "<p>There are only two things which can happen with memory onto which you pinned something:</p>\n<ul>\n<li>You properly run drop on the thing which was pinned.</li>\n<li>You leak that memory permanently.</li>\n</ul>\n<p>As you can't leak the stack permanently you must run drop.</p>\n<p>And luckily the way <code>Pin</code> is designed there is no safe way to forget the stack pinned value (assuming you<br>\nused <code>pin_mut!()</code>) without leaking the whole stack.</p>",
        "id": 212190156,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759539
    },
    {
        "content": "<blockquote>\n<p>without literally leaking the stack memory</p>\n</blockquote>\n<p>This may be a part of where I'm getting stuck. I think this may not literally mean \"stack\". My brain says that it's not <em>possible</em> to leak stack memory. When a function exits, the stack pointer is popped and the next function call uses it.</p>",
        "id": 212190162,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601759566
    },
    {
        "content": "<blockquote>\n<p>it's not possible to leak stack memory. When a function exits, the stack pointer is popped and the next function call uses it.</p>\n</blockquote>\n<p>This is why it's so important that there is no safe way to not drop a stack pinned value.</p>",
        "id": 212190173,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759605
    },
    {
        "content": "<p>As a side note if you pin something to the \"stack\" in a async function it not necessarily the function stack in the classical sense.</p>",
        "id": 212190224,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759645
    },
    {
        "content": "<p>I'm afraid that you are restating the same points back at me multiple times without my understanding changing. This may not be a good use of your time. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 212190233,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1601759680
    },
    {
        "content": "<p>Due to the way async transforms things a pin to the \"stack\" in a async function  might be a bit of memory in the create future which might be moved onto the heap before being pinned/sheduled.</p>",
        "id": 212190248,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759729
    },
    {
        "content": "<p>So e.g. in following code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">....</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\">  </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">pin</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">poll_boxed_future</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>The \"async stack\"  foo is pinned  to is actually on the heap when polling the future and as such we can leak it permanently.</p>",
        "id": 212190368,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601759900
    },
    {
        "content": "<p>To poll foo on the stack we would need to do:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">....</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">poll_pinned</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>In which case we shadow <code>future</code> and as such make sure it's dropped before the stack is potentially re-purposed.</p>\n<p>Alternatively we could do:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pin_mut</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">....</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"c1\">// in this unsafe-contract we guarantee not to \"forget\" future</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">pinned</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Pin</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">poll_pinned</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">pinned</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// this would be a breach of the unsafe contract</span>\n<span class=\"c1\">// drop(pinned); mem::forget(future);</span>\n</code></pre></div>",
        "id": 212190461,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601760104
    },
    {
        "content": "<p>I am currently not aware of any async executor which does poll futures on the stack as this <br>\nwould have a lot of limitations.</p>\n<p>E.g. all of <code>async-std</code>,<code>smol</code>,<code>tokio</code> do allocate memory on the heap and then move the future on the heap.</p>\n<p>Through I could imagine some ways to do a stack only executor for some embedded use cases.</p>",
        "id": 212190545,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601760243
    },
    {
        "content": "<hr>\n<p>I created this library draft: <a href=\"https://github.com/rustonaut/remote-accessed-buffer\">https://github.com/rustonaut/remote-accessed-buffer</a></p>\n<p>Which will become a no_std, no alloc way to have a stack allocated buffer which you can use in  e.g. DMA.</p>\n<p>Tomorrow I plane to add more documentation about the unsafe-contract and how it works this might<br>\nbe helpful for your understanding once it's done.</p>\n<p>(Currently it's just a (working?) draft, no README, no proper doc about the unsafe contract, no integration test, no CI, etc.)</p>",
        "id": 212190843,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601760724
    },
    {
        "content": "<p>Also the current design has some drawbacks:</p>\n<ul>\n<li>\n<p>The way to interact with the buffer is through a <code>Pin&lt;&amp;mut ...&gt;</code> but they don't automatically reborrow<br>\n   because of which they don't have the best UX</p>\n</li>\n<li>\n<p>The fact that there are two lifetimes makes it a bit annoying to use.</p>\n</li>\n<li>\n<p>Currently no good way for DMA (or similar) to get access to a <code>Waker</code> (I have a plan how to do it, but<br>\n   it's not yet implemented)</p>\n</li>\n<li>\n<p>No way to send the handle to the buffer to another thread (or Task) which is ok if the other target/source<br>\n   of the DMA operation is some special address we supply by pointer. But means no good way to do DMA<br>\n   between two of this buffers, fixing that is tricky without alloc <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>\n</li>\n<li>\n<p>Currently no existing DMA interface implementation (or similar) which uses this, I plan to add an example which uses a thread instead of DMA <span aria-label=\"stuck out tongue wink\" class=\"emoji emoji-1f61c\" role=\"img\" title=\"stuck out tongue wink\">:stuck_out_tongue_wink:</span></p>\n</li>\n</ul>",
        "id": 212190981,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1601760987
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> I think it would help if you tried to turn your non-compiling above into real code that compiles. I think you will find it does not work (without <code>unsafe</code>) and that should help explain why this is all safe.</p>\n<p>Specifically, I think there is a problem with this part:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">b</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">future</span>::<span class=\"n\">poll_fn</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">ctx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">poll</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;!-- cannot do this without first pinning `a`</span>\n<span class=\"w\">        </span><span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// &lt;!-- cannot do this when `a` is pinned</span>\n<span class=\"w\">        </span><span class=\"n\">Poll</span>::<span class=\"n\">Pending</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 212215074,
        "sender_full_name": "RalfJ",
        "timestamp": 1601804320
    },
    {
        "content": "<blockquote>\n<p>My brain says that it's not possible to leak stack memory. When a function exits, the stack pointer is popped and the next function call uses it.</p>\n</blockquote>\n<p>I feel like you are confusing the proof obligations here. It is the responsibility of whoever creates a <code>Pin&lt;&amp;mut T&gt;</code> to prove that the memory this points to will not be deallocated without the destructor being called. If that memory is stack memory, it follows that you have to prove that the stack frame will not be popped without the destructor being called.</p>\n<p>So to break this scheme you will have to find a way to create a pinned pointer to something on the stack, and then pop that stack frame without calling the destructor. That should be impossible and the general consensus seems to be that it indeed is impossible. However, this is tricky enough that we may indeed have missed some sneaky way to do that.</p>\n<p>One particularly tricky case here is the case where the stack frame it points to is not a real stack frame but a generator (<code>async fn</code>), which I think is what your example does. In that case it must be the case that the <code>async fn</code> whose stack frame contains pinned data, is itself demanding pinning from its caller, i.e., it must not be <code>Unpin</code>. This way the \"obligation to pin\" is propagated outwards. I don't know enough about the <code>async fn</code> desugaring to tell if this is the case, but I sincerely hope so. :)</p>",
        "id": 212215252,
        "sender_full_name": "RalfJ",
        "timestamp": 1601804647
    },
    {
        "content": "<p>Btw, there were some remarks made above that the <code>Pin</code> proof obligation is \"non-local\" in the sense that you have to promise something about future behavior. I think that however is mostly a matter of the framework you are using for reasoning. Sharing memory across multiple threads also has a \"non-local\" proof obligation because you must promise not to cause data races, and yet there are local ways to check this. I believe the same to be true for pinning -- with a sufficiently powerful logic, we can express these proof obligations in a local and modular way. In fact I believe the same underlying framework of <em>separation logic</em> that enables this for concurrency will also suffice for pinning.</p>",
        "id": 212215370,
        "sender_full_name": "RalfJ",
        "timestamp": 1601804807
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  At the risk of asking a PhD sized question, how would you actually model Pin? This has always looked a little shaky / tacked on to me, not least because it <em>was</em> tacked on, and I think there are still some open soundness problems IIRC, so I give decent odds that the concept doesn't actually survive formalization</p>",
        "id": 212219884,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1601812349
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Opt-in.20guaranteed.20destructors/near/212219884\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span>  At the risk of asking a PhD sized question, how would you actually model Pin? This has always looked a little shaky / tacked on to me, not least because it <em>was</em> tacked on, and I think there are still some open soundness problems IIRC, so I give decent odds that the concept doesn't actually survive formalization</p>\n</blockquote>\n<p>I'd say that's around 0.5 PhDs in size^^ I wrote some blog posts with rough ideas a while ago:</p>\n<ul>\n<li><a href=\"https://www.ralfj.de/blog/2018/04/05/a-formal-look-at-pinning.html\">https://www.ralfj.de/blog/2018/04/05/a-formal-look-at-pinning.html</a></li>\n<li><a href=\"https://www.ralfj.de/blog/2018/04/10/safe-intrusive-collections-with-pinning.html\">https://www.ralfj.de/blog/2018/04/10/safe-intrusive-collections-with-pinning.html</a></li>\n</ul>\n<p>the actual formal details as I imagine them however require quite a bit of background... as in, much of part I and II of <a href=\"https://people.mpi-sws.org/~jung/phd/thesis-screen.pdf\">my thesis</a> ;)<br>\nWe (mostly another PhD student and a former intern) have maybe around 80% of the formal work needed for this done; I still hope we can get back to it and complete that paper at some point.</p>",
        "id": 212221588,
        "sender_full_name": "RalfJ",
        "timestamp": 1601815185
    },
    {
        "content": "<blockquote>\n<p>I don't know enough about the <code>async fn</code> desugaring to tell if this is the case, but I sincerely hope so.</p>\n</blockquote>\n<p>The only way to abuse that would be by having a pinned <code>!Unpin</code> value survive an <code>.await</code> / <code>yield</code> point. But that automatically makes that field a member of the generator, (otherwise the value wouldn't exist when repolling). And given the way Rust types and auto-traits work, that automatically infects the generator with <code>Unpin</code> (no need  to know the exact unsugaring of the state machine, thus). So all is good <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> The worst thing that can happen is the generator being <em>overly restrictive</em> in that it may not be unpinned even \"when it could\" (same as <code>None::&lt;impl !Unpin&gt;</code> not being an unpinnable instance, <em>etc.</em>).</p>",
        "id": 212232646,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1601833053
    },
    {
        "content": "<blockquote>\n<p>And given the way Rust types and auto-traits work, that automatically infects the generator with Unpin (no need to know the exact unsugaring of the state machine, thus).</p>\n</blockquote>\n<p>Yes that is how I hoped things work. :) Thanks for confirming.</p>",
        "id": 212240636,
        "sender_full_name": "RalfJ",
        "timestamp": 1601843865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209646\">@Philipp Korber</span> How would you prevent drop not being called on the DMA operation before popping the stack ?</p>\n<p>I thought I had something, like, the operation being a future which borrows the buffer and on drop it stop the transfer, it was looking all nice, the borrow checker wouldn't let you use the buffer before the drop, even if you forgot the <code>Pin&lt;&amp;mut DMA&gt;</code>, but that would only work if the operation is on the stack</p>",
        "id": 212375682,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601947667
    },
    {
        "content": "<p>If you use <code>Box::pin</code> instead and forget that pin, all bets are off, you can immediately re-use the buffer or pop the stack</p>",
        "id": 212375735,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601947708
    },
    {
        "content": "<p>So I don't know how to do a safe interface with something like this</p>",
        "id": 212375741,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601947722
    },
    {
        "content": "<p>I haven't found a way of doing this if the transfer doesn't own the buffer memory, i.e. buffer memory only gets invalidated together with the transfer</p>",
        "id": 212375816,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601947806
    },
    {
        "content": "<p>Hmm, now I've looked at your code on github, it seems that in your case the buffer owns the transfer, right ? I think it might work, but it stumbles on the same inconvenience we have now with the transfer owning the buffer</p>",
        "id": 212377066,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601949491
    },
    {
        "content": "<p>Which is a lot of consuming and giving it back, which can be troublesome when using interrupts because you need to place things in static variables, so or you need two Options or an enum in the form of <code>Left</code>/<code>Right</code></p>",
        "id": 212377086,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601949559
    },
    {
        "content": "<p>And unfortunately in your case we would need the <code>Operation</code> back, since the DMA usually is a single resource modeled as a singleton</p>",
        "id": 212377162,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601949611
    },
    {
        "content": "<p>Ah, but your macro has one advantage, using stack buffers, which was similar to my ideia with pinning the transfer, but I don't see a way right now of doing without a macro</p>",
        "id": 212377690,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601950320
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> <a href=\"#narrow/stream/122651-general/topic/Opt-in.20guaranteed.20destructors/near/212375735\">said</a>:</p>\n<blockquote>\n<p>If you use <code>Box::pin</code> instead and forget that pin, all bets are off, you can immediately re-use the buffer or pop the stack</p>\n</blockquote>\n<p>If you forget the result of <code>Box::pin</code> you would just have a memory leak. There is no way to safely re-use the heap allocation.</p>",
        "id": 212418888,
        "sender_full_name": "bjorn3",
        "timestamp": 1601986849
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> The problem is when the type inside the <code>Pin&lt;Box&gt;</code> borrows a buffer on the stack, the compiler will let you re-use that buffer and pop that stack</p>",
        "id": 212436286,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601994804
    },
    {
        "content": "<p>If you require the buffer itself to be pinned, then that can't happen. Eg only allow <code>Pin&lt;Box&lt;[u8]&gt;&gt;</code> and <code>Pin&lt;&amp;[u8]&gt;</code>.</p>",
        "id": 212436503,
        "sender_full_name": "bjorn3",
        "timestamp": 1601994886
    },
    {
        "content": "<p>It doesn't make sense to allow <code>Pin&lt;Box&lt;&amp;[u8]&gt;&gt;</code>.</p>",
        "id": 212436552,
        "sender_full_name": "bjorn3",
        "timestamp": 1601994908
    },
    {
        "content": "<p>Does pinning <code>[u8]</code> even achieve anything, irregardless of what pointer you use to refer to it?<br>\nIt doesn't have any Drop impl in the first place.</p>",
        "id": 212437882,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601995428
    },
    {
        "content": "<p>Also it's <a href=\"https://doc.rust-lang.org/stable/std/marker/trait.Unpin.html#impl-Unpin-42\">Unpin</a> so, no.</p>",
        "id": 212438043,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1601995481
    },
    {
        "content": "<p>Even with separate pinnings, I don't think we can do this without either the transfer owning the buffer type or the buffer type owning the transfer</p>",
        "id": 212438167,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601995547
    },
    {
        "content": "<p>Even if you Pin the buffer or not, the stack will pop by the end of the scope together with the buffer, and if you put the transfer in a <code>Pin&lt;Box&gt;</code> and forget it you will have the same problem</p>",
        "id": 212438305,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601995608
    },
    {
        "content": "<p>Or the buffer type needs to have a way to stop the transfer on Drop or the transfer has to own the buffer memory, so if you leak the transfer you also leak the buffer memory</p>",
        "id": 212438399,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601995657
    },
    {
        "content": "<p>Either way you need a way to give or the buffer or the transfer back, the transfer manages singleton resources, so the user needs it back</p>",
        "id": 212438583,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1601995737
    },
    {
        "content": "<p>What about making the transfer itself <code>!Unpin</code> and requiring it to be pinned when starting it?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Transfer</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_unpin</span>: <span class=\"nc\">PhantomUnpin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Transfer</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">buf</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"cm\">/* ... */</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Transfer</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Transfer</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// ...</span>\n<span class=\"w\">            </span><span class=\"n\">buf</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_unpin</span>: <span class=\"nc\">PhantomUnpin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">start</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// start transfer if not already started or completed</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">cancel</span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// cancel transfer if started and not already completed</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Transfer</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// cancel transfer and wait until canceled or completed</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 212446499,
        "sender_full_name": "bjorn3",
        "timestamp": 1601998950
    },
    {
        "content": "<p>If you do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">transfer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">pin</span><span class=\"p\">(</span><span class=\"n\">transfer</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">transfer</span><span class=\"p\">.</span><span class=\"n\">start</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">transfer</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 212451923,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602001403
    },
    {
        "content": "<p>You can then re-use the buffer passed to transfer as &amp;mut and pop its stack</p>",
        "id": 212451992,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602001433
    },
    {
        "content": "<p>The thing that cancels the transfer in <code>Drop</code> must own the buffer, I think <em>then</em> having a <code>fn start(self: Pin&lt;&amp;mut Self&gt;)</code> would be sound (at least if I understood the earlier proposals correctly)</p>",
        "id": 212452321,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1602001579
    },
    {
        "content": "<p>It needs to be something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>struct Transfer {\n    buffer: [u8],\n}\n\nimpl Drop for Transfer {\n    fn drop(&amp;mut self) { /* Wait for transfer to be complete, or abort */ }\n}\n</code></pre></div>",
        "id": 212452507,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1602001676
    },
    {
        "content": "<p>And the caller is somehow responsible for creating this pinned Dst.</p>",
        "id": 212452593,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1602001702
    },
    {
        "content": "<p>mhmm</p>",
        "id": 212452604,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1602001709
    },
    {
        "content": "<p>It might be possible to do this by unsizing coercion.</p>",
        "id": 212452611,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1602001712
    },
    {
        "content": "<p><code>&amp;'static mut [u8]</code></p>",
        "id": 212452622,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602001719
    },
    {
        "content": "<p>I could see an API like <code>struct Transfer&lt;T: ?Sized + OwnedBuffer&gt;</code></p>",
        "id": 212452642,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1602001728
    },
    {
        "content": "<p>If we had <code>!Leak</code> then we probably could have borrowed buffers</p>",
        "id": 212452754,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602001789
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>use std::marker::PhantomPinned;\nuse std::pin::Pin;\n\npub struct TransferBuf&lt;T: ?Sized&gt; {\n    _unpin: PhantomPinned,\n    buf: T,\n}\n\npub struct Transfer {\n    buffer: [u8],\n}\n\nimpl&lt;T&gt; TransferBuf&lt;T&gt; {\n    pub fn new(buf: T) -&gt; Self {\n        TransferBuf { buf, _unpin: PhantomPinned }\n    }\n}\n\nimpl Transfer {\n    pub fn new(pin: Pin&lt;&amp;mut TransferBuf&lt;[u8]&gt;&gt;) -&gt; Pin&lt;&amp;mut Self&gt; {\n        unsafe {\n            let ptr = &amp;mut *(Pin::into_inner_unchecked(pin)\n                as *mut TransferBuf&lt;[u8]&gt; as *mut Self);\n            Pin::new_unchecked(ptr)\n        }\n    }\n}\n\nfn main() {\n    let mut buf = Box::pin(TransferBuf::new([0u8; 4]));\n    Transfer::new(buf.as_mut());\n}\n</code></pre></div>",
        "id": 212455106,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1602003109
    },
    {
        "content": "<p>At least that makes it safe for the caller.</p>",
        "id": 212455130,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1602003121
    },
    {
        "content": "<p>This means you can't turn any buffer into a transfer buf, it specificially needs to be made one when allocating it.<br>\nStack allocation <code>pin_mut</code> would count but this is not optimal at all.</p>",
        "id": 212455281,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1602003184
    },
    {
        "content": "<blockquote>\n<p>@Philipp Korber How would you prevent drop not being called on the DMA operation before popping the stack ?</p>\n</blockquote>\n<ul>\n<li>\n<p>The (not yet well documented, sorry) unsafe contract of the <code>RABufferAnchor::new_unchecked</code> constructor requires it to be directly pinned on the thread or async stack and that the buffer is on the same part of memory (for now let's just limit it to directly above the anchor on the (async or thread) stack.</p>\n</li>\n<li>\n<p>The DAM operation (a handle to it or something similar)  is moved into the <code>RABufferAnchor</code> (which has a bit of stack space reserved for it).</p>\n</li>\n<li>\n<p>Due to the guarantees of <code>Pin</code> and the unsafe contract we can make sure that <code>drop</code> is guaranteed to be called before the memory is re-purposed, even if it's normal stack memory (through it's mean to be pinned on the async stack).</p>\n</li>\n<li>\n<p>In the <code>Drop</code> constructor we make sure to sync- block until the operation is completed, something similar to <code>AsyncDrop</code> could help make this more efficient.</p>\n</li>\n<li>\n<p>You can directly await completion (or hint that it should be canceled) on the buffer handle (a <code>Pin&lt;&amp;mut RABufferAnchor&lt;...&gt;&gt;</code>).</p>\n</li>\n<li>\n<p>The returned <code>OperationHandle</code> can also be used to await cancelation, but you don't need to. The fact that it resolves to a new <code>Pin&lt;&amp;mut RABufferAnchor&lt;...&gt;&gt;</code> is just utility, it also could resolve to <code>()</code> and this would not change much.</p>\n</li>\n<li>\n<p>Before starting any new operation you must wait the end of the previous operation (a Noop if it already ended, there was none)</p>\n</li>\n<li>\n<p>While <code>Pin&lt;&amp;mut ...&gt;</code> doesn't automatically re-borrow you can manually re-borrow by using <code>.as_mut()</code>. With that you can mostly threat the <code>Pin&lt;&amp;mut RABufferAnchor&gt;</code> like a <code>&amp;mut</code> ref to the buffer.</p>\n</li>\n<li>\n<p>The handle to the operation which is stored in the anchore is as much pinned as the anchor and whatever writes/reads to/from the buffer can also write/read to/from it (but you must use some appropriate type of Cell). This allows handling <code>Waiter</code>'s  and similar.<br>\n(and the API needs some improvements around that).</p>\n</li>\n</ul>\n<blockquote>\n<p>If you use Box::pin instead and forget that pin, all bets are off, you can immediately re-use the buffer or pop the stack</p>\n</blockquote>\n<p>The unsafe contract requires stack pinning. So this is not a problem.</p>\n<blockquote>\n<p>Which is a lot of consuming and giving it back, which can be troublesome when using interrupts because you need to place things in static variables, so or you need two Options or an enum in the form of Left/Right</p>\n</blockquote>\n<p>It doesn't really consume the handle, or more specifically you can re-borrow it. Once I implement <code>async fn buffer_ref(...) -&gt; &amp;[V]</code> and <code>async fn buffer_mut(...) -&gt; &amp;mut [V]</code>.  You should be able to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">ra_buffer_anchor</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1024</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">DMAInteraction</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">foobar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// start the dma, we here don't use the `OperationHandle` at all</span>\n<span class=\"w\">   </span><span class=\"n\">dma</span>::<span class=\"n\">start_data_to_buffer_copy</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">as_mut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"p\">.).</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"n\">stuff</span><span class=\"o\">..</span><span class=\"p\">.]</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"c1\">// buffer_mut makes sure to wait for any ongoing DMA operation to complete before</span>\n<span class=\"w\">   </span><span class=\"c1\">// allowing access, lifetimes make sure you can't start a new DMA operation while the buffer</span>\n<span class=\"w\">   </span><span class=\"c1\">// is borrowed.</span>\n<span class=\"w\">   </span><span class=\"n\">modify_data_in_buffer</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">as_mut</span><span class=\"p\">().</span><span class=\"n\">buffer_mut</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">dma</span>::<span class=\"n\">start_data_from_buffer_copy</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">as_mut</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"n\">source</span><span class=\"w\"> </span><span class=\"n\">etc</span><span class=\"p\">.).</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<blockquote>\n<p>And unfortunately in your case we would need the Operation back, since the DMA usually is a single resource modeled as a singleton.</p>\n</blockquote>\n<p>Even with <code>Leak</code> you might need to adapt whatever you use to the DMA instructions, likely to a more low level DMA API. I'm completly sure that this can be done without any to big problems. But I don't know the exact underlying DMA API you  want to use.  I could loo into it if you link me some library or similar.</p>\n<blockquote>\n<p>but I don't see a way right now of doing without a macro</p>\n</blockquote>\n<p>Neither do I, at least without unsafe code.</p>\n<blockquote>\n<p>It doesn't make sense to allow <code>Pin&lt;Box&lt;&amp;[u8]&gt;&gt;.</code></p>\n</blockquote>\n<p>In my library the ownership of the buffer is semantically moved to the thing which does the DMA (or similar) operation.</p>\n<p>My design is similar to a <code>Pin&lt;&amp;mut Wrapper&lt;&amp;mut [u8]&gt;&gt;&gt;</code> except that  due to the unsafe constructor of <code>Wrapper</code> (or to be precise <code>RABufferAnchor</code> the right guarantees are expanded to the underlying buffer.  It's also not a problem as it doesn't implement <code>Deref</code> and has some requirements about what buffer can be passed in. For some time I considered only allowing the<br>\nbuffer to be directly passed in e.g. <code>::new_unchecked([0u8; 1024])</code> but this is overly restrictive given that we already have unsafety in the constructor and have a macro to safly abstract it away which works similar to <code>pin_mut!</code>.</p>",
        "id": 212482061,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602016462
    },
    {
        "content": "<blockquote>\n<p>I could see an API like <code>struct Transfer&lt;T: ?Sized + OwnedBuffer&gt;</code></p>\n</blockquote>\n<p>The thing is owning the buffer is not enough you need certain guarantees about the memory. On the otherhand with stack pinning a anchor which has a mutable reference to the buffer and a unsafe guarantee that the buffer \"lies\" on the same part of the stack you have everything you need without needing taking permanent ownership of the buffer and while making it work with VLA (even in their <em>very</em> restricted form we have in the current RFC around them).</p>\n<p>In the end I will use a macro to safely abstract over the \"anchor needs stack binning\" aspect anyway and if we have this anyway we can also extend to to handle the buffer creation so that we have a fully safe abstraction covering most use-cases.</p>\n<p>Furthermore you normally don't need to ever move the buffer out of the anchor as the anchor allows access via <code>&amp;mut [V]</code>,<code>&amp;[V]</code> as long as no operation is ongoing.</p>",
        "id": 212482995,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602016923
    },
    {
        "content": "<blockquote>\n<p>.as_mut() re-borrows</p>\n</blockquote>\n<p>I would really love if we could have some way to add automatic re-borrow behaviour at least for method calls to anything semantically wrapping a <code>&amp;mut T</code>...</p>",
        "id": 212487434,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602019239
    },
    {
        "content": "<blockquote>\n<p>Either way you need a way to give or the buffer or the transfer back, the transfer manages singleton resources, so the user needs it back</p>\n</blockquote>\n<p>Looking at the DMA API in <code>stm32g0xx_hal</code> you probably mean the DMA channels.</p>\n<p>I have a few ideas how this could be done. </p>\n<p>All are based on the idea to \"automatically place back the channel into some kind of slot\" once the work is done.</p>\n<p>The simplest one is to simple pass a <code>&amp;'long mut</code> reference of the channel to whatever starts the operation. Which should work as long as <code>'long</code> out-lifes the stack allocated buffer. I intentionally made sure that the operation handle which is lifted into the anchor does <em>not</em> need to be static. (It's also pinned and is only dropped after the operation completes so it allows some crazy stuff).</p>\n<p>I will also change <code>OperationHandle.completion().await</code> to no longer return the wrapped <code>Pin&lt;&amp;mut RABufferAnchor&lt;..&gt;&gt;</code> instead it will return a item defined by the operation, e.g. a hint weather or not the operation completed or failed to complete. </p>\n<p>There are also some open questions about how to best to task waking. Like can you call <code>waker.wake()</code> from a interrupt handler?  Probably not a good idea right as lock and cas-loops don't work well in interrupt handlers as far as I know?</p>\n<p>Well luckily for me handling <code>Waker</code> is part of the glue-code (the implementer of the <code>OperationInteraction</code> trait) still I should make sure to provided utilities to make writing this glue code easy.</p>",
        "id": 212495504,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602024461
    },
    {
        "content": "<blockquote>\n<p>Probably not a good idea right as lock and cas-loops don't work well in interrupt handlers as far as I know ?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"209646\">@Philipp Korber</span>  It's kinda of okay, if you choose your interrupt priorities carefully. The lock would be to (dynamically) increase the interrupt priority to the highest priority using the locked resource, CAS should also be okay, if your target supports it (most do).</p>\n<p>It's more like a design thing, today we have like a bunch of interrupts priorities, usually more than you could ask for.</p>",
        "id": 212516832,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602048692
    },
    {
        "content": "<p>Thanks, good to know.</p>",
        "id": 212606922,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602098521
    },
    {
        "content": "<p>For bare-metal on a single core target, I should add. On other cases it's usually a per case thing.</p>",
        "id": 212628773,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602110875
    },
    {
        "content": "<p>Given that you will anyway need some glue code between the buffer and a DMA API this should be fine.</p>\n<p>So far it looks good, I will next emulate a  fake <code>DMA</code> API (using a thread <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span>) similar to the one in <code>stm32g0xx_hal</code> to see how to best handle resource singletons.</p>",
        "id": 212632794,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602113865
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209646\">@Philipp Korber</span> I just had a quick look at the one on g0, it seems to not have a transfer type yet. The one on the f4xx-hal is using our new crate for buffer traits, but the DMA on the F4 has a lot of whistles, so the code is a bit bigger</p>",
        "id": 212639280,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602120741
    },
    {
        "content": "<p>The most interesting part would be the Transfer type by the end of the file (on the F4 HAL)</p>",
        "id": 212639304,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602120783
    },
    {
        "content": "<p>I have to think about this a bit more.</p>\n<p>But one think I was wondering about is: Given that we can have a <code>&amp;mut</code> to the <code>Transfer</code> while another thread (the DMA controller) writes to the buffer don't we need to store the buffer as <code>Option&lt;Cell&lt;BUF&gt;&gt;</code> due to aliasing rules?</p>\n<p>I guess for a <code>Vec&lt;&gt;</code> that would not be a problem due to the additional pointer indirection, but for a <code>&amp;mut [Word]</code> it might be??</p>",
        "id": 212640738,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602122598
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209646\">@Philipp Korber</span> hmm, not sure. We use compiler fences and pointer escapes to avoid certain problems with optimizations, I think it's kinda modeled as a FFI</p>",
        "id": 212832590,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602253613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> <a href=\"#narrow/stream/122651-general/topic/Opt-in.20guaranteed.20destructors/near/212375682\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"209646\">Philipp Korber</span> How would you prevent drop not being called on the DMA operation before popping the stack ?</p>\n<p>I thought I had something, like, the operation being a future which borrows the buffer and on drop it stop the transfer, it was looking all nice, the borrow checker wouldn't let you use the buffer before the drop, even if you forgot the <code>Pin&lt;&amp;mut DMA&gt;</code>, but that would only work if the operation is on the stack</p>\n</blockquote>\n<p>all of this reminds me a lot of the discussions around io_uring, and there IIRC <span class=\"user-mention\" data-user-id=\"256759\">@boats</span> concluded that pinning doesn't help. their ringbahn crate might thus be a good source of inspiration?</p>",
        "id": 212912681,
        "sender_full_name": "RalfJ",
        "timestamp": 1602330953
    },
    {
        "content": "<p>This is a long thread! If I was to implement an API like this, I would be implementing an executor: the executor itself would have a blocking API that would borrow a list of stack-allocated buffers as input, and would be able to ensure that all DMA operations are terminated before returning.</p>\n<p>The executor would be used something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">dma_executor</span><span class=\"p\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buffers</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">spawner</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">spawner</span><span class=\"p\">.</span><span class=\"n\">spwan</span><span class=\"p\">(</span><span class=\"n\">some_background_task</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">spawner</span><span class=\"p\">.</span><span class=\"n\">spwan</span><span class=\"p\">(</span><span class=\"n\">some_dma_task</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>The reason you are having such difficulty defining a safe API is that you seem to want the stack buffers to be allocated without outliving the  executor, and I don't think that's possible: the buffers must necessarily outlive the executor, because the stack will be unwound up to the executor's stack frame each time a future yields.</p>",
        "id": 212913351,
        "sender_full_name": "Diggsey",
        "timestamp": 1602332217
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211727\">Jonas Schievink</span> <a href=\"#narrow/stream/122651-general/topic/Opt-in.20guaranteed.20destructors/near/211547758\">said</a>:</p>\n<blockquote>\n<p>On embedded systems, doing the same thing as ringbahn does (heap-allocating an owned backing buffer) would, as far as I understand, result in <em>doubling</em> memory usage of DMA buffers, which is not an acceptable trade-off there. The alternative would be to make almost every DMA API <code>unsafe</code>, which is also not appealing, and with async/await, that would be the <em>only</em> API, so that wouldn't be very good.</p>\n</blockquote>\n<p>There doesn't seem to be much investigation of this assertion in this thread. Why can't you have an owned representation of the buffer without doubling memory usage? I don't know anything about DMA, but it seems suspect to me.</p>",
        "id": 212915452,
        "sender_full_name": "boats",
        "timestamp": 1602335619
    },
    {
        "content": "<p>It doesn't <em>need</em> to be a heap allocated buffer - it just needs to be a type that represents the only safe way to read/write to that memory again</p>",
        "id": 212915650,
        "sender_full_name": "boats",
        "timestamp": 1602335891
    },
    {
        "content": "<blockquote>\n<p>all of this reminds me a lot of the discussions around io_uring, and there IIRC @boats concluded that pinning doesn't help. their ringbahn crate might thus be a good source of inspiration?</p>\n</blockquote>\n<p>I'm pretty sure the think I'm <em>playing</em> around with here <a href=\"https://github.com/rustonaut/remote-accessed-buffer\">https://github.com/rustonaut/remote-accessed-buffer</a> actually does work and is sound with stack pinned buffers. (Note as it's just a playground for me there is currently no Readme/CI etc.)</p>\n<p>Through there are some <em>major</em> ergonomic drawbacks to it which for thinks like io-uring probably make no sense at all. Mainly it might hang (either async or even sync depending on the context) until the operation completes, which  with e.g. a bad implementation might be forever <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> So I think as long as you can just use heap allocations going with \"temporary leaking buffers while they are in use for completion based I/O\" is the better solution (which is I think was ringbahn does).</p>\n<p>But on embedded devices you might not have a heap.</p>\n<p>You can have a static buffer, or a static pool you allocate buffers on. </p>\n<p>The problem the static buffer will always be around which is really a problem for a low-memory situation where you for some time need a big buffer (or many buffers) but most times don't.</p>\n<p>Furthermore leaking a <code>static</code> buffer on a low-memory environment is also a big problem (I guess, tbh. I'm not that experienced with embedded programming).</p>\n<p>For me this is mainly a fun challenge, but I believe it might produce something use-full for the <code>no_std</code>, no <code>alloc</code> lowish-memory use-case.</p>",
        "id": 212922074,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602345678
    },
    {
        "content": "<p>(There also might be some problems with big writable static buffers and application images on some embedded targets , but I don't know anything about this so just widely spukualting that maybe that could be a thing.)</p>",
        "id": 212922146,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602345802
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> : With the current design of dma in stm32f4xx-hal you will have to pass in a <code>'static</code> memory based buffer (heap or static). The reason for this is the <code>'static</code> lifetime bound on <code>BUFF</code>.  This could probably be fixed in many ways, including moving the <code>'static</code> bound from the type to the <code>init</code> method and provide <code>unsafe fn init_non_static(...)</code> function (and then there would be glue code for the specific non static buffer type abstracting away that unsafe). (just random ideas)</p>\n<p>I also had some other ideas about alternate ways to do the <code>embedded_dma::Read/WriteBuffer</code> type in ways which works well for both <code>'static</code> leak based DMA buffers and other buffers. But I will first need try out how they work.</p>\n<p>One think I'm wondering is how is the interrupt handling done, is the <code>Transfer</code> moved to the interrupt or is it handle in ways where the normal code might wait on the interrupt and then call <code>free</code>/<code>next_transfer</code>?</p>",
        "id": 212922517,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602346329
    },
    {
        "content": "<p><a href=\"https://github.com/rustonaut/remote-accessed-buffer/blob/ca4033b1ae4ac5c02900935c11a6a0b36e103b78/src/lib.rs#L180\">https://github.com/rustonaut/remote-accessed-buffer/blob/ca4033b1ae4ac5c02900935c11a6a0b36e103b78/src/lib.rs#L180</a></p>\n<p>*upstream</p>",
        "id": 212922522,
        "sender_full_name": "bjorn3",
        "timestamp": 1602346341
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209646\">@Philipp Korber</span> the <code>Transfer</code> is usually moved to a static.</p>\n<p>About the 'static thing, we recently included an unsafe <code>StaticWriteBuffer</code> trait to embedded-dma, it's implemented for <code>WriteBuffer + 'static</code> but people can (unsafely) implement it for any type, we should change Transfer to use that</p>",
        "id": 212922796,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602346719
    },
    {
        "content": "<p>But it might not work well with your design</p>",
        "id": 212922807,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602346748
    },
    {
        "content": "<p>The transfer being on a static gives that ergonomic problem I was talking about when you need to consume resources, since you can't just consume a static, you need Option, etc</p>",
        "id": 212922889,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602346844
    },
    {
        "content": "<blockquote>\n<p>But it might not work well with your design</p>\n</blockquote>\n<p>Yes, the underlying buffer is still <code>'static</code>. And we can't have a <code>'static</code> handle/ref/pointer to a stack allocated buffer.</p>",
        "id": 212922905,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602346866
    },
    {
        "content": "<p>Like I said, you can unsafely implement the new trait to whatever type you have, but not sure if it would be possible to combine with your work and still create a safe api on top</p>",
        "id": 212922956,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602346928
    },
    {
        "content": "<p>Maybe if you implement it for <code>Pin&lt;...&gt;</code></p>",
        "id": 212922966,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602346952
    },
    {
        "content": "<p>The new <code>StaticWriteBuffer</code></p>",
        "id": 212922982,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602346974
    },
    {
        "content": "<p>Implementing it doesn't  really work as it would always break the unsafe contract of the <code>StaticWriteBuffer</code>, so this would not be sound on a library level, through I guess it could work by not ever exposing the <code>Transfer</code> type (so I would implement it for something like <code>struct UnsafeHanlde(Pin&lt;&amp;mu...&gt;)</code>).</p>",
        "id": 212923063,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602347075
    },
    {
        "content": "<p>Hmm, yeah, those traits probably don't cover all use cases</p>",
        "id": 212923146,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602347207
    },
    {
        "content": "<p>Through if I do that I probably would just implement <code>BufferRead</code> unsafely for a <code>Pin&lt;*mut ..&gt;</code> I think.  </p>\n<p>Using <code>Read/WriteBuffer</code> is I think better for <code>Transfer</code> as the guarantees for <code>StaticRead/WriteBuffer</code> are stronger then what <code>Transfer</code> needs.</p>",
        "id": 212923159,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602347241
    },
    {
        "content": "<p>One possibility would be to slightly extend the <code>unsafe</code> contract of <code>Read/WriteBuffer</code>. Basically just add a \"if this is implemented for a non 'static type that type must make sure that the memory isn't re-purposed until it is sure that the DMA operation completes\".</p>\n<p>And then <code>Transfer</code> could remove the <code>'static</code> bound. </p>\n<p>But then a non-static <code>Transfer</code> seems to be generally incompatible with how it's used wrt. interrupts.</p>",
        "id": 212923292,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602347426
    },
    {
        "content": "<p>I decided to create them because a lot of people (including me once) were forgetting the <code>+ 'static</code> bound</p>",
        "id": 212923294,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602347431
    },
    {
        "content": "<p>Also, it gives an escape hatch to anyone that just wants to do things unsafely in their end application</p>",
        "id": 212923302,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1602347459
    },
    {
        "content": "<p>Makes sense, that seems like something very easy to mess up wrt. unsafe code/ptr handling.</p>",
        "id": 212923320,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1602347509
    }
]