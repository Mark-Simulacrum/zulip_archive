[
    {
        "content": "<p>hey everyone, newbie question here.<br>\nThere is this annoying pattern with Read/Write traits where</p>\n<div class=\"codehilite\"><pre><span></span><code>fn read(&amp;mut self,  mut buf: &amp;mut [u8] ) -&gt; Result&lt;usize, Error&gt; {\n     let mut total_n = 0;\n     match something.read(&amp;mut buf) {\n      Ok(n) =&gt; total_n += n,\n      Err(err) =&gt; return Err(err);\n    }\n\n    match something_else.read(&amp;mut buf) {\n      Ok(n) =&gt; total_n += n,\n      Err(err) =&gt; return Err(err);\n    }\n\n   Ok(total_n)\n}\n</code></pre></div>\n<p>There must be an utility function to do the bookkeeping for me, like</p>\n<div class=\"codehilite\"><pre><span></span><code>fn read(&amp;mut self,  mut buf: &amp;mut [u8] ) -&gt; Result&lt;usize, Error&gt; {\n     read_many(something, something_else)\n}\n</code></pre></div>\n<p>Where can I find it?</p>",
        "id": 261835587,
        "sender_full_name": "Scorpil",
        "timestamp": 1637177464
    },
    {
        "content": "<p>well, uh, your description would have rather destructive behavior, but I think you mean <a href=\"https://doc.rust-lang.org/std/io/trait.Read.html#method.chain\">chain</a>?</p>",
        "id": 261835905,
        "sender_full_name": "The 8472",
        "timestamp": 1637177633
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> <code>chain</code> is what I was looking for. What do you mean by destructive behaviour?</p>",
        "id": 261836974,
        "sender_full_name": "Scorpil",
        "timestamp": 1637178104
    },
    {
        "content": "<p>it would call two readers successively reading into the same buffer, thus the 2nd read overwriting the results of the 1st one. And it would do that on every read.</p>",
        "id": 261837183,
        "sender_full_name": "The 8472",
        "timestamp": 1637178179
    },
    {
        "content": "<p>ah, right, because I didn't slice the output buffer. That was a mistake, idea was to append (like chain does)</p>",
        "id": 261837835,
        "sender_full_name": "Scorpil",
        "timestamp": 1637178444
    },
    {
        "content": "<p>even then it would still fail if the first reader returns a short read. it would be interleaving the data from both sources instead of appending them.</p>",
        "id": 261838065,
        "sender_full_name": "The 8472",
        "timestamp": 1637178519
    },
    {
        "content": "<p>noted</p>",
        "id": 261841527,
        "sender_full_name": "Scorpil",
        "timestamp": 1637179822
    },
    {
        "content": "<p>on a different not, what's the relation between the &amp;[T] and Vec&lt;T&gt;? Is it just that &amp;[T] doesn't allocate? So if I convert a Vec&lt;T&gt; to a &amp;[T], there is no actual conversion taking place, just a different \"view\" if the same memory on the heap, right? Other way around <code>&amp;[T}.as_vec()</code> must be more complicated (and expensive), since vector has the capacity and re-allocation rules. Besides, it would clone the data to heap if it's on a stack. Am I understanding this right?</p>",
        "id": 261843056,
        "sender_full_name": "Scorpil",
        "timestamp": 1637180517
    },
    {
        "content": "<p><a href=\"https://cheats.rs/#data-layout\">https://cheats.rs/#data-layout</a><br>\n<a href=\"https://doc.rust-lang.org/book/ch04-03-slices.html\">https://doc.rust-lang.org/book/ch04-03-slices.html</a><br>\nVec is an owned data structure, a slice is just a reference + length into some data structure</p>",
        "id": 261843744,
        "sender_full_name": "The 8472",
        "timestamp": 1637180820
    },
    {
        "content": "<p>a slice can reference something on the stack too, but if you take a slice from a vec then yeah it's referencing heap memory</p>",
        "id": 261844024,
        "sender_full_name": "The 8472",
        "timestamp": 1637180966
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> , you've been very helpful</p>",
        "id": 261899929,
        "sender_full_name": "Scorpil",
        "timestamp": 1637225098
    },
    {
        "content": "<p>See also: <a href=\"/user_uploads/4715/-OuwaoEU3pUa3uX6TJ1hbInx/image.png\">image.png</a> notice how <code>Vec&lt;T&gt;</code> contains a <code>ptr, len, cap</code> and how <code>&amp;[T]</code> contains a <code>ptr</code>, and thus how the <code>Deref</code> from the former to the latter is just as simple, machine-code-wise, as ignoring the <code>cap</code> field</p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/-OuwaoEU3pUa3uX6TJ1hbInx/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/-OuwaoEU3pUa3uX6TJ1hbInx/image.png\"></a></div>",
        "id": 261915469,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1637235311
    }
]