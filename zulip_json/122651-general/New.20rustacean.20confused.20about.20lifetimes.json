[
    {
        "content": "<p>Hello, Rust Community! I have started learning Rust recently (previous experience: x86 assemble, C, C++, Python), today I read about lifetimes and I am very confused. I wonder if there is anybody I can talk to about lifetimes? :)</p>",
        "id": 266619211,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641137762
    },
    {
        "content": "<p>The first problem I have with lifetimes is: as I understand, in some cases (which are described in The Book under Lifetime Elision section) the compiler and borrow checker can figure lifetimes out without my help. In other cases I have to specify them manually. As I saw from the examples in The Book, if I get the lifetimes wrong the compiler will still shout at me and refuse to compile the code. Is it always the case? That is, is it possible to get the lifetimes wrong, but in such a way that the compiler will not catch the error? If it is possible, then I guess that would violate Rust's guarantees about no dangling references, which seems to be \"impossible\" without unsafe. But if the compiler can catch any kind of \"the programmer messed the lifetimes up\" error, then wouldn't it be able to get them right without my help? Or is it the situation similar to some algorithmic problems being easy to check if the solution is good, but being hard to find the solution in general case? Like, the compiler will always catch the error if I mess the lifetimes up, but will not get them right without manual specifications unless the situation is trivial (three rules)?</p>",
        "id": 266619400,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641138074
    },
    {
        "content": "<p>Do you have a Discord account? Your questions would fit better on one of the Rust discord servers, since this Zulip is mainly about working on the language itself</p>",
        "id": 266619494,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138234
    },
    {
        "content": "<p>I'd be happy to answer your questions there</p>",
        "id": 266619530,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138243
    },
    {
        "content": "<p>I tried to get a Discord account, but Discord challenged me with various validations and tests, and at the end locked me out. Seems like my phone number is now associated with one of the partially created accounts, and I can't get the validation code for a seemingly-ok account, because the number is already in use. :(</p>",
        "id": 266619571,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641138337
    },
    {
        "content": "<p>Anyway, I will try again, if this question fits better in Discord</p>",
        "id": 266619621,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641138370
    },
    {
        "content": "<p>Is there more than one Discord server?</p>",
        "id": 266619625,
        "sender_full_name": "Laurențiu",
        "timestamp": 1641138383
    },
    {
        "content": "<p>I can answer it here if you're having problems</p>",
        "id": 266619628,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138387
    },
    {
        "content": "<p>Yes - there's the main Rust language server, and the Rust community server</p>",
        "id": 266619638,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138403
    },
    {
        "content": "<p>It seems like I do have problems with Discord, so if you don't mind, I would be very glad to get answers here)</p>",
        "id": 266619654,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641138447
    },
    {
        "content": "<p>There are a couple parts to the answer to your question</p>",
        "id": 266619656,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138449
    },
    {
        "content": "<p>Yeah, I just noticed</p>",
        "id": 266619657,
        "sender_full_name": "Laurențiu",
        "timestamp": 1641138450
    },
    {
        "content": "<p>One of the reasons that the compiler requires you to manually specify certain lifetimes is to separate the 'header' of a function from its body</p>",
        "id": 266619662,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138478
    },
    {
        "content": "<p>Here's an example. Consider these two functions:</p>",
        "id": 266619701,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138488
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">first</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">first_arg</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">second_arg</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">b</span> <span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">first_arg</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">second</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">first_arg</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">second_arg</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">second_arg</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266619718,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138543
    },
    {
        "content": "<p>The function <code>first</code> takes in two strings, which can have <em>different</em> lifetimes. It then returns a string with the lifetime of the <em>first</em> argument</p>",
        "id": 266619736,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138581
    },
    {
        "content": "<p>The function <code>second</code> takes in two strings, which must have the <em>same</em> lifetime. It then returns a string with that lifetime</p>",
        "id": 266619766,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138603
    },
    {
        "content": "<p>These functions impose different kind of restrictions on the caller</p>",
        "id": 266619791,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138635
    },
    {
        "content": "<p>So do I get it right, that lifetime annotations (either automatic, or manually provided) are strictly required on the call site, so they must be a part of declaration, even if the body would make everything clear?</p>",
        "id": 266619794,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641138650
    },
    {
        "content": "<p>Sort of</p>",
        "id": 266619798,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138664
    },
    {
        "content": "<p>If I had just written those function bodies (with no lifetimes specified), the compiler wouldn't know for sure what the lifetime of the return value should be</p>",
        "id": 266619817,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138709
    },
    {
        "content": "<p>It could try to infer that, based on which of the two arguments I returned</p>",
        "id": 266619822,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138719
    },
    {
        "content": "<p>However, that could make changing the body of the function break some callers of that function, making them stop compiling</p>",
        "id": 266619867,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138742
    },
    {
        "content": "<p>The function <code>first</code> can be called with any two strings - one could be short-lived and the other long-lived, for example</p>",
        "id": 266619879,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138766
    },
    {
        "content": "<p>By writing that down in the signature, the compiler will enforce that fact within the function</p>",
        "id": 266619892,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138802
    },
    {
        "content": "<p>So technically the body is enough to infer the lifetimes, but the lifetimes become part of the API contract, so I manually provide them to define the contract that I am okay with?</p>",
        "id": 266619897,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641138820
    },
    {
        "content": "<p>For example, it won't let me return <code>second_arg</code> from <code>first</code>, because it could have a different lifetime</p>",
        "id": 266619898,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138834
    },
    {
        "content": "<p>Essentially, yes. If you write a closure, the compiler will typically infer the lifetimes for you</p>",
        "id": 266619939,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138857
    },
    {
        "content": "<p>Here's a more concrete example:</p>",
        "id": 266619945,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138882
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">take_static</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Val: {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">take_any_str</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Val: {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">val</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266619952,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138913
    },
    {
        "content": "<p>At runtime, these two functions behave identically</p>",
        "id": 266619959,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138927
    },
    {
        "content": "<p>However, I can do more things with <code>val</code> inside <code>take_static</code>, since I know that it's a <code>&amp;'static str</code>. I could send it to another thread, or store it in a global variable, for example</p>",
        "id": 266619970,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138962
    },
    {
        "content": "<p>Thank you, I get it! And will the compiler always catch me if the lifetimes (either automatic or manually provided) do not align with either the function body or the calling context?</p>",
        "id": 266620016,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641138981
    },
    {
        "content": "<p>If you're only writing safe code, then yes</p>",
        "id": 266620021,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641138992
    },
    {
        "content": "<p>the compiler won't let you write lifetimes that would lead to unsoundness (use-after frees, memory corruption, etc)</p>",
        "id": 266620030,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139012
    },
    {
        "content": "<p>When you write <code>unsafe</code> code, you need to make sure that the lifetimes you write are actually correct</p>",
        "id": 266620039,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139027
    },
    {
        "content": "<p>since <code>unsafe</code> code lets you bypass some of the checks that the compiler has in place</p>",
        "id": 266620049,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139052
    },
    {
        "content": "<p>For example, you can never actually write a function like this in safe code:</p>",
        "id": 266620060,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139077
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">impossible_extend</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">???</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266620109,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139098
    },
    {
        "content": "<p>(You <em>should</em> never be able to, if you can, probably in a very convoluted way, it's a bug)</p>",
        "id": 266620122,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1641139137
    },
    {
        "content": "<p>I see. It is impossible to get 'static runtime from \"arbitrary\" lifetime in general case</p>",
        "id": 266620124,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641139142
    },
    {
        "content": "<p>In safe code, you can't pull a new <code>T</code> 'out of thin air', and you can't return an <code>&amp;'a T</code> where a <code>&amp;'static T</code> is expected</p>",
        "id": 266620127,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139144
    },
    {
        "content": "<p>In safe code, yes</p>",
        "id": 266620131,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139147
    },
    {
        "content": "<p>in unsafe code, it's a different story</p>",
        "id": 266620137,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139156
    },
    {
        "content": "<p>For example</p>",
        "id": 266620138,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139157
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">unsound_lifetime_extend</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266620145,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139187
    },
    {
        "content": "<p><code>transmute</code> lets you re-interpret the underlying bytes of one type as another type</p>",
        "id": 266620191,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139207
    },
    {
        "content": "<p>Actually using this function can lead to crashes and memory corruption</p>",
        "id": 266620229,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139218
    },
    {
        "content": "<p>The typical C-style \"do as I said\" situation :D</p>",
        "id": 266620261,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641139237
    },
    {
        "content": "<p>For example, I could write something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_string</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"Hello\"</span><span class=\"p\">.</span><span class=\"n\">to_string</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">evil_pointer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">unsound_lifetime_extend</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">my_string</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">my_string</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Memory get deallocated here</span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Oops: {:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">evil_pointer</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266620281,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139264
    },
    {
        "content": "<p>If you're not writing <code>unsafe</code> code, then you don't need to worry about that (as long as all of the <code>unsafe</code> code that you end up <em>using</em> is written correctly)</p>",
        "id": 266620311,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139305
    },
    {
        "content": "<p>Going back to the <code>take_static</code> and <code>take_any_str</code> example:</p>",
        "id": 266620364,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139346
    },
    {
        "content": "<p>Both of those functions have identical bodies, so the compiler couldn't know which lifetime you wanted just from looking at the body</p>",
        "id": 266620370,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139363
    },
    {
        "content": "<p>However, which lifetime you choose in that situation is very important</p>",
        "id": 266620384,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139386
    },
    {
        "content": "<p>Taking in an <code>&amp;'a str</code> gives the caller maximum flexibility - they can pass in any string that they want</p>",
        "id": 266620398,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139405
    },
    {
        "content": "<p>However, it limits the flexibility of the function body - the compiler will assume that the string can no longer be used after your functions returns, so you can't store the string in a global variable, etc.</p>",
        "id": 266620435,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139442
    },
    {
        "content": "<p>Conversely, taking in an <code>&amp;'static str</code> greatly limits the flexibility of the caller</p>",
        "id": 266620455,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139460
    },
    {
        "content": "<p>Great, thank you! I have one more question about lifetimes: so far the only \"named\" lifetime I have encountered is 'static. As I understand, if I use it in function signature, it basically serves the same purpose as generic lifetimes, except it matches only the references that are valid for the whole program run time. But what happens if I define a reference with this lifetime? There is an example in The Book:<br>\nlet s: &amp;'static str = \"I have a static lifetime.\";<br>\nI understand that string literals do have static lifetime in the meaning \"they exist while the program runs\". However, can I declare a reference to some other variable as having 'static lifetime? Will that ensure that the variable _does_ have 'static lifetime, or will it fail?</p>",
        "id": 266620457,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641139468
    },
    {
        "content": "<p>String literals and other constants are special</p>",
        "id": 266620476,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139502
    },
    {
        "content": "<p>when the compiler sees \"Hello, world\", it will reserve space in the output binary/library for that string</p>",
        "id": 266620491,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139519
    },
    {
        "content": "<p>and construct a pointer that points into that section of the binary</p>",
        "id": 266620497,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139526
    },
    {
        "content": "<p>that's what allows the lifetime to be <code>&amp;'static</code></p>",
        "id": 266620501,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139533
    },
    {
        "content": "<p>the compiler does a similar thing when you write <code>&amp;25</code> or <code>&amp;true</code></p>",
        "id": 266620508,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139548
    },
    {
        "content": "<p>since the value is known at compile-time, the compiler can reserve space for in the binary itself, and create a reference that will always be valid</p>",
        "id": 266620552,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139567
    },
    {
        "content": "<p>In essentially any other case, that is <em>not</em> true</p>",
        "id": 266620562,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139585
    },
    {
        "content": "<p>So the only objects that have 'static lifetime are the ones that are eventually compiled into the binary, such as various hardcoded literals?</p>",
        "id": 266620568,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641139597
    },
    {
        "content": "<p>There's a catch - you can leak memory at runtime to get something with a <code>'static</code> lifetime</p>",
        "id": 266620575,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139618
    },
    {
        "content": "<p>However, that's pretty rare in practice</p>",
        "id": 266620577,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139623
    },
    {
        "content": "<p>and you won't usually need to do that</p>",
        "id": 266620583,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139634
    },
    {
        "content": "<p>Does that involve unsafe?</p>",
        "id": 266620586,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641139637
    },
    {
        "content": "<p>Interestingly, no - leaking memory is considered safe</p>",
        "id": 266620592,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139647
    },
    {
        "content": "<p>See <a href=\"https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak\">https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak</a></p>",
        "id": 266620598,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139659
    },
    {
        "content": "<p>However, it's very very rare for that method to be what you actually want to use</p>",
        "id": 266620603,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139671
    },
    {
        "content": "<p>And after I leak memory, there is no way that the objects residing there are dropped, so they will live \"forever\" from that point in my program, so it is sort-of-static, right?</p>",
        "id": 266620650,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641139703
    },
    {
        "content": "<p>That's right</p>",
        "id": 266620656,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139708
    },
    {
        "content": "<p>The compiler won't let you make a static reference to a local variable, though:</p>",
        "id": 266620665,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139727
    },
    {
        "content": "<p>This code will not compile:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">my_val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bad_ref</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"kt\">bool</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">my_val</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ERROR</span>\n</code></pre></div>",
        "id": 266620668,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139744
    },
    {
        "content": "<p>that's because <code>my_val</code> is stored on the stack, which will get freed when the function returns</p>",
        "id": 266620684,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139774
    },
    {
        "content": "<p>When I was first learning Rust, it took me quite a bit of practice to get used to lifetimes</p>",
        "id": 266620752,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139838
    },
    {
        "content": "<p>At some point, after seeing enough compiler errors, you'll start to internalize some sense of why the compiler doesn't like your code :)</p>",
        "id": 266620770,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641139868
    },
    {
        "content": "<p>Thank you! And one final question: in The Book when the signature with manually specified lifetimes was first introduced, there was the following wording:<br>\n\"...<br>\nfn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {<br>\n...<br>\nThe function signature now tells Rust that for some lifetime 'a, the function takes two parameters, both of which are string slices that live at least as long as lifetime 'a. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime 'a.\"</p>\n<p>This wording confused me a bit, because I thought: \"if x and y have some lifetime that is at least 'a, and the return value also has some lifetime that is at least 'a, nothing guarantees that the lifetimes of x, y are at least as long as the lifetime of the return value\". Later I inferred from the examples, that this signature matches 'a to be the intersection of lifetimes of x, y and return value, and ensures that it is so both in the body and the call site. Is this understanding correct? And if I have x: &amp;'a, y: &amp;'b, return value: &amp;'a, than this basically guarantees nothing about y, since anything matches standalone 'b?</p>",
        "id": 266620994,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641140149
    },
    {
        "content": "<p>Would it then be right to say, that lifetime rules essentially are about the following:<br>\n\"whenever there are entities with the same lifetime parameter 'a, ensure that at the function body and at any call site the factual lifetimes have non-empty intersection\"?</p>",
        "id": 266621158,
        "sender_full_name": "Sergey A New Rustacean",
        "timestamp": 1641140339
    },
    {
        "content": "<blockquote>\n<p>This wording confused me a bit, because I thought: \"if x and y have some lifetime that is at least 'a, and the return value also has some lifetime that is at least 'a, nothing guarantees that the lifetimes of x, y are at least as long as the lifetime of the return value\".</p>\n</blockquote>\n<p>You're absolutely correctly - the return value can actually have a <em>longer</em> lifetime than <code>x</code> or <code>y</code></p>",
        "id": 266621221,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140410
    },
    {
        "content": "<p>For example:</p>",
        "id": 266621222,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140412
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">longest</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"s\">\"Hello\"</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 266621232,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140436
    },
    {
        "content": "<p>Here, the return <em>value</em> is \"Hello\", which has a lifetime of <code>'static</code></p>",
        "id": 266621246,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140456
    },
    {
        "content": "<p>I could have called this function with references to local variables</p>",
        "id": 266621270,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140520
    },
    {
        "content": "<p>in which case the arguments will <em>not</em> live forever, but the return <em>value</em> will</p>",
        "id": 266621313,
        "sender_full_name": "Aaron Hill",
        "timestamp": 1641140535
    }
]