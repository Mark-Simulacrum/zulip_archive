[
    {
        "content": "<p>At least once a month, somewhere on Zulip or GitHub someone claims that making a function <code>const</code> will somehow make it evaluated at compile time as part of the optimizer.  Typically this is not even stated as a hypothesis but as a fact -- somehow people are convinced that this is true, even though it isn't, it never was, and AFAIK it also is not true in any other language. <code>const fn</code> and <code>fn</code> are compiled exactly the same way. <code>const</code>ness of a <code>fn</code> has no effect at all on the optimizer. The <em>only</em> effect <code>const</code> has on a <code>fn</code> is that you may now call it in more places, namely in <code>const</code>/<code>static</code> initializers. But every program that compiles without the <code>const</code>, is unaffected by the <code>const</code>.</p>\n<p>Any idea where this common misconception is coming from? Are there docs that are ambiguous, or compiler messages, or so? Explaining this over and over clearly doesn't help.^^<br>\nCc <span class=\"user-group-mention\" data-user-group-id=\"1916\">@WG-const-eval</span></p>",
        "id": 208059113,
        "sender_full_name": "RalfJ",
        "timestamp": 1598425920
    },
    {
        "content": "<p>Is there a way to force const-eval? If I have <code>const fn foo(n: u8) -&gt; u32</code> and I want <code>let x = foo(42);</code> to be turned into a constant assignment, do I have to write <code>const x_const = foo(42); let x = x_const;</code>?</p>",
        "id": 208060073,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598426779
    },
    {
        "content": "<p>cc <a href=\"https://github.com/rust-lang/rust/pull/75894#discussion_r476480546\">https://github.com/rust-lang/rust/pull/75894#discussion_r476480546</a> where I stated that. I'm sorry if I claim it wrongly.</p>",
        "id": 208060760,
        "sender_full_name": "lzutao",
        "timestamp": 1598427326
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> are you asking to force const propagataion? const evaluation is never optional. so \"forcing\" just doesnt make sense as a concept here.</p>",
        "id": 208061421,
        "sender_full_name": "RalfJ",
        "timestamp": 1598427854
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209117\">@lzutao</span> it's okay, you're by far not the only one :)</p>",
        "id": 208061437,
        "sender_full_name": "RalfJ",
        "timestamp": 1598427868
    },
    {
        "content": "<p>but if you have any idea why you thought this was the case, that might be useful for preventing this misconception in the future</p>",
        "id": 208061471,
        "sender_full_name": "RalfJ",
        "timestamp": 1598427900
    },
    {
        "content": "<p>In a context like <code>const FOO = foo(42);</code> obviously rustc has to evaluate the function at compile time, but in <code>let x = foo(42);</code> it might put a call to <code>foo</code> there</p>",
        "id": 208061505,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598427927
    },
    {
        "content": "<p>the bodies of <code>const</code> and <code>static</code> items are computed at compile time. that is called const evaluation.</p>",
        "id": 208061524,
        "sender_full_name": "RalfJ",
        "timestamp": 1598427952
    },
    {
        "content": "<p>also, and this has nothing to do with const evaluation, the compiler will replace <code>2+2</code> by <code>4</code> in your code. this is an optimization called const <em>propagation</em>.</p>",
        "id": 208061587,
        "sender_full_name": "RalfJ",
        "timestamp": 1598427978
    },
    {
        "content": "<p>I mean, looking at the optimized LLVM IR or x86 asm, I may make that claim about optimizing <code>const fn</code>.</p>",
        "id": 208061620,
        "sender_full_name": "lzutao",
        "timestamp": 1598427997
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209117\">lzutao</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061620\">said</a>:</p>\n<blockquote>\n<p>I mean, looking at the optimized LLVM IR or x86 asm, I may make that claim about optimizing <code>const fn</code>.</p>\n</blockquote>\n<p>but the <code>const</code> has no effect on the LLVM IR. the program generates the exact same IR without <code>const</code>.</p>",
        "id": 208061636,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061505\">said</a>:</p>\n<blockquote>\n<p>In a context like <code>const FOO = foo(42);</code> obviously rustc has to evaluate the function at compile time, but in <code>let x = foo(42);</code> it might put a call to <code>foo</code> there</p>\n</blockquote>\n<p>right. the former is const evaluaton, the latter is const propagation. they have nothing to do with each other and happen in totally different phases of compilation.</p>",
        "id": 208061668,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428055
    },
    {
        "content": "<p>yeah, you're right about IR. Still I don't see the call of <code>foo(42)</code> in x86 asm.</p>",
        "id": 208061691,
        "sender_full_name": "lzutao",
        "timestamp": 1598428080
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> note that you might also have <code>let x = foo(some_runtime_value);</code>, even when <code>foo</code> is <code>const fn</code>. at that point clearly it is impossible to remove the <code>foo</code> call entirely (we can inline but it might not help much). Being <code>const fn</code> does not mean that all calls to this functions only contain consts!</p>",
        "id": 208061789,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428145
    },
    {
        "content": "<p>right</p>",
        "id": 208061797,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598428155
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209117\">lzutao</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061691\">said</a>:</p>\n<blockquote>\n<p>yeah, you're right about IR. Still I don't see the call of <code>foo(42)</code> in x86 asm.</p>\n</blockquote>\n<p>yeah, that's called the \"optimizer\" which tries to make your program go fast. ;) It has nothing to do with <code>const</code>/<code>static</code>/<code>const fn</code>.</p>",
        "id": 208061800,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428159
    },
    {
        "content": "<p>I'm just wondering if there is some way to say <code>let x = (const foo(42))</code> or something and be sure that it got inlined</p>",
        "id": 208061832,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598428196
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061832\">said</a>:</p>\n<blockquote>\n<p>I'm just wondering if there is some way to say <code>let x = (const foo(42))</code> or something and be sure that it got inlined</p>\n</blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FOO</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"mi\">32</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">FOO</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208061890,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428221
    },
    {
        "content": "<p>the only <em>guaranteed</em> compile-time evaluated code is const and static initializers</p>",
        "id": 208061903,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428233
    },
    {
        "content": "<p>there's an RFC to make such cases a bit easier to write: <a href=\"https://github.com/rust-lang/rfcs/pull/2920\">https://github.com/rust-lang/rfcs/pull/2920</a></p>",
        "id": 208061916,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428247
    },
    {
        "content": "<p>that's what I mean the misconception comes from. Mostly are from C/C++ devs like me who want to explore how fast Rust is.<br>\nThey inspect the asm and claim that.</p>",
        "id": 208061917,
        "sender_full_name": "lzutao",
        "timestamp": 1598428248
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209117\">lzutao</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061917\">said</a>:</p>\n<blockquote>\n<p>that's what I mean the misconception comes from. Mostly are from C/C++ devs like me who want to explore how fast Rust is.<br>\nThey inspect the asm and claim that.</p>\n</blockquote>\n<p>but C/C++ do the exact same thing as Rust here</p>",
        "id": 208061937,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428267
    },
    {
        "content": "<p>in C++ you also have functions being inlined and const-propagated without writing <code>constexpr</code> anywhere</p>",
        "id": 208061964,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428295
    },
    {
        "content": "<p>do you think it would be a bad idea to infer constness of constants and eagerly evaluate everything that can be?</p>",
        "id": 208061965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598428295
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061965\">said</a>:</p>\n<blockquote>\n<p>do you think it would be a bad idea to infer constness of constants and eagerly evaluate everything that can be?</p>\n</blockquote>\n<p>to me that sounds like a weird description of const propagation</p>",
        "id": 208061992,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428316
    },
    {
        "content": "<p>that is, infer that since <code>foo(42)</code> is valid in const context, it should always be const eval'd</p>",
        "id": 208062039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598428328
    },
    {
        "content": "<p>it is const propagation</p>",
        "id": 208062054,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598428340
    },
    {
        "content": "<p>no that doesnt make much sense IMO. \"valid in const context\" is something very different from \"can be propagated by the compiler\".</p>",
        "id": 208062069,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428350
    },
    {
        "content": "<p>for example const-prop can exploit the fact that if <code>ptr: &amp;i32</code>, then <code>let x = ptr as *const _ as usize</code> is always even, so <code>x % 2</code> is 0. thenw e can propgatae that 0 further.</p>",
        "id": 208062134,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428411
    },
    {
        "content": "<p>it's a bit weaker than const propagation in general (since that can handle <code>x * 0 ~&gt; 0</code> things), but also probably a bit stronger because it will evaluate functions even if the inliner thinks it might not be such a good idea</p>",
        "id": 208062148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598428419
    },
    {
        "content": "<p>this is clearly not valid in const context though as we do not know the value of <code>ptr</code>.</p>",
        "id": 208062155,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208062148\">said</a>:</p>\n<blockquote>\n<p>it's a bit weaker than const propagation in general (since that can handle <code>x * 0 ~&gt; 0</code> things), but also probably a bit stronger because it will evaluate functions even if the inliner thinks it might not be such a good idea</p>\n</blockquote>\n<p>fair. one could play with heuristics like that. there might be useful things to do there. but it requires careful design and hasn't happened yet, so while it could hyptoehtically help, it doesnt answer the question for why people claim <code>const</code> <em>already</em> has effects like that.</p>",
        "id": 208062247,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428482
    },
    {
        "content": "<p>one big problem with doing this naively is that the call <code>foo(42)</code> might panic or loop forever or so, and then we have to bail out and not touch it or we get <a href=\"https://github.com/rust-lang/const-eval/issues/53\">a huge amount of problems</a>.</p>",
        "id": 208062297,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428527
    },
    {
        "content": "<p>but I didn't want to discuss here how <code>const</code> might help guide runtime optimizations of code, I was asking why people think that it already somehow does this even though it doesn't. maybe people just look at assembly and didnt set up their experiments correctly and take wrong conclusions? like only testing with <code>const</code> and not without and thus not realizing that the <code>const</code> has no effect...</p>",
        "id": 208062494,
        "sender_full_name": "RalfJ",
        "timestamp": 1598428658
    },
    {
        "content": "<p>It is a natural assumption. \"<code>constexpr</code> all the things\" to get more CTFE is the big selling point in the first place. Without knowing how it is implemented, I would have given even odds on the behavior I described vs the behavior you are indicating. I wonder how much of peoples' impressions of the compiler are based on what they think it would be logical for it to do compared to what they have actually seen it do? <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 208063113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598429131
    },
    {
        "content": "<p>My guess is that they look at ASM, see that it was const-prop'd, and misunderstand that as being const-evaluated.</p>\n<p>I hope <code>const{}</code> will make this easier to talk about.</p>",
        "id": 208067620,
        "sender_full_name": "scottmcm",
        "timestamp": 1598432679
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> but the thing is, inlining and constprop happened in C++ way before it had <code>constexpr</code>. There's nothing new here when <code>foo(42)</code> disappears in the assembly. I really don't understand how attributing this to <code>const(expr)</code> is a \"natural assumption\".</p>\n<p>My guess is people set up a flawed experiment, like trying something with <code>constexpr</code> and seeing it const-propped, and forget to remove the <code>cosntexpr</code> to actually do a meaningful experiment of what <code>constexpr</code> does (not) do</p>",
        "id": 208071545,
        "sender_full_name": "RalfJ",
        "timestamp": 1598435419
    },
    {
        "content": "<p>And AFAIK not even C++ compilers use <code>constexpr</code> as an optimization hint, which to me says it is hard to get any meaningful speedup out of such a heuristic for real code. It seems logical on first sight to treat <code>const_fn(42)</code> specially but I am not convinced it is really that useful in practice.</p>",
        "id": 208071588,
        "sender_full_name": "RalfJ",
        "timestamp": 1598435469
    },
    {
        "content": "<p>I wonder if it's worth writing a blog post like \"CTFE != const-prop\"... but then I already discussed this in <a href=\"https://www.ralfj.de/blog/2018/07/19/const.html\">https://www.ralfj.de/blog/2018/07/19/const.html</a> which was widely read at the time, but new people show up all the time ( <span aria-label=\"tada\" class=\"emoji emoji-1f389\" role=\"img\" title=\"tada\">:tada:</span> ) and of course they don't know what it says in old blog posts.</p>",
        "id": 208071840,
        "sender_full_name": "RalfJ",
        "timestamp": 1598435644
    },
    {
        "content": "<p>that's why I was wondering if there's a good place in the docs to clarify this.</p>",
        "id": 208071850,
        "sender_full_name": "RalfJ",
        "timestamp": 1598435657
    },
    {
        "content": "<p><code>const</code> keyword docs in the stdlib docs plus a <code>Note:</code> in the reference.</p>",
        "id": 208071941,
        "sender_full_name": "isHavvy",
        "timestamp": 1598435743
    },
    {
        "content": "<p>We don't really have a good place to talk about the optimizations that the compiler does in practice.</p>",
        "id": 208072070,
        "sender_full_name": "isHavvy",
        "timestamp": 1598435841
    },
    {
        "content": "<p>If the doc must be changed for the const keyword and you don’t have the time ping me in the issue, I’ll do it <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 208072242,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1598435990
    },
    {
        "content": "<p>I think people see const expressions as supercharged const propagation</p>",
        "id": 208077346,
        "sender_full_name": "pachi",
        "timestamp": 1598439578
    },
    {
        "content": "<blockquote>\n<p>Any idea where this common misconception is coming from? Are there docs that are ambiguous, or compiler messages, or so? Explaining this over and over clearly doesn't help.^^</p>\n</blockquote>\n<p>I've definitely seen informal explanations of const functions in blog posts, Reddit comments, etc as \"code run at compile time\". I have no idea how to correct that other than when it pops up.</p>",
        "id": 208096797,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1598451402
    },
    {
        "content": "<p>Perhaps having a canonical explanation that <code>const</code> does not always mean \"run at compile time\" would make it easier to correct people as it can just be linked to and updated as appropriate.</p>",
        "id": 208096918,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1598451469
    },
    {
        "content": "<p>For my own edification, <code>const</code> does mean <em>is guaranteed that this <strong>can</strong> be run at compile time</em>, right? If so, it might be the mix of \"guarantee\" and \"can\".</p>",
        "id": 208105683,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598454966
    },
    {
        "content": "<p>It's not guaranteed that it will ever <em>succeed</em></p>",
        "id": 208105868,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598455059
    },
    {
        "content": "<p>i.e. it might panic, or something more nuanced?</p>",
        "id": 208106029,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598455111
    },
    {
        "content": "<p>Panic, infinite loop, infinite recursion</p>",
        "id": 208106111,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598455147
    },
    {
        "content": "<p>Yeah, I meant the class of anything that results in <code>-&gt; !</code></p>",
        "id": 208106163,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598455169
    },
    {
        "content": "<p>As a side note, I'm a tiny bit amused at \"a canonical explanation [...] linked to and updated as appropriate\". That's what duplicate marking on Stack Overflow basically is, and a surprising number of people hate you for it.</p>",
        "id": 208106667,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598455376
    },
    {
        "content": "<p>But! If someone wants to, Stack Overflow could be a place to put that information (you can self-ask-and-answer questions)</p>",
        "id": 208106796,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598455434
    },
    {
        "content": "<p>I must say actually i'm interested in seeing some form of partial evaluation support in Rust...  Though maybe some explicit syntax is needed ... <br>\nI imagine it useful to explicitly ask the compiler to auto-generate highly specialized version of a function on request, by lifting some argument to const generic position and perform dead code elimination and other partial evaluation techniques.</p>",
        "id": 208120981,
        "sender_full_name": "Charles Lew",
        "timestamp": 1598462257
    },
    {
        "content": "<p><a href=\"https://reddit.com/r/rust/comments/ih0cip/constany_convert_any_rust_function_to_const/\">https://reddit.com/r/rust/comments/ih0cip/constany_convert_any_rust_function_to_const/</a> case in point</p>",
        "id": 208123190,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1598463400
    },
    {
        "content": "<p>This popped just today, a few hours ago</p>",
        "id": 208123218,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1598463423
    },
    {
        "content": "<blockquote>\n<p>Constany: convert any rust function to const function</p>\n</blockquote>\n<p>Press <span aria-label=\"x\" class=\"emoji emoji-274e\" role=\"img\" title=\"x\">:x:</span> to doubt</p>",
        "id": 208123234,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598463436
    },
    {
        "content": "<blockquote>\n<p>the function marked as constany::const_fn and the main function will be compiled twice. For the first time, the value of the function will be recorded. For the second time, the function will be replaced by the value.</p>\n</blockquote>\n<p>Oh. They are in the camp of not caring about consistency :-)</p>",
        "id": 208123360,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598463495
    },
    {
        "content": "<p>I had this misconception as well until I saw this :). IIUC, <code>const x: i32 = some_function()</code> where <code>some_function</code> is a <code>const fn</code> will be evaluated at compile time, but <code>let x: i32 = some_function()</code> will not?</p>",
        "id": 208152722,
        "sender_full_name": "Noah Lev",
        "timestamp": 1598478078
    },
    {
        "content": "<p><code>const x: i32 = some_function()</code> will be guaranteed to be evaluated at compile time, whereas <code>let x = some_function()</code> may be evaluated at compile time, due to optimizations like const-propogation, but might not be, I believe is what RalfJ said earlier:<br>\n<span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061668\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208061505\">said</a>:</p>\n<blockquote>\n<p>In a context like <code>const FOO = foo(42);</code> obviously rustc has to evaluate the function at compile time, but in <code>let x = foo(42);</code> it might put a call to <code>foo</code> there</p>\n</blockquote>\n<p>right. the former is const evaluaton, the latter is const propagation. they have nothing to do with each other and happen in totally different phases of compilation.</p>\n</blockquote>",
        "id": 208153494,
        "sender_full_name": "jknodt",
        "timestamp": 1598478502
    },
    {
        "content": "<p>I think the reason it is so misunderstood is because <code>const fn</code> communicates (at least to me) that the function behaves the same as a <code>const FOO</code>; in other words, it's <em>always</em> evaluated at compile time. To me, I think it might be clearer as something like <code>pure fn</code>, but of course it wouldn't make sense to change at this point.</p>",
        "id": 208154943,
        "sender_full_name": "Noah Lev",
        "timestamp": 1598479441
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208071588\">said</a>:</p>\n<blockquote>\n<p>And AFAIK not even C++ compilers use <code>constexpr</code> as an optimization hint, which to me says it is hard to get any meaningful speedup out of such a heuristic for real code. It seems logical on first sight to treat <code>const_fn(42)</code> specially but I am not convinced it is really that useful in practice.</p>\n</blockquote>\n<p>it looks like sometimes <code>constexpr</code> can even <em>prevent</em> const propagation and inlining under <code>-O1</code></p>",
        "id": 208156158,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598480243
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Camelid</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208152722\">said</a>:</p>\n<blockquote>\n<p>I had this misconception as well until I saw this :). IIUC, <code>const x: i32 = some_function()</code> where <code>some_function</code> is a <code>const fn</code> will be evaluated at compile time, but <code>let x: i32 = some_function()</code> will not?</p>\n</blockquote>\n<p>that's how I would put it, yes. as others said, optimziations make this more complicated, but optimizations are not guaranteed to happen and have no observable effect other than making your code go faster.</p>",
        "id": 208185302,
        "sender_full_name": "RalfJ",
        "timestamp": 1598513183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208156158\">said</a>:</p>\n<blockquote>\n<p>it looks like sometimes <code>constexpr</code> can even <em>prevent</em> const propagation and inlining under <code>-O1</code></p>\n</blockquote>\n<p>oh wow... why does that happen?</p>",
        "id": 208185307,
        "sender_full_name": "RalfJ",
        "timestamp": 1598513195
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307537\">Camelid</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208154943\">said</a>:</p>\n<blockquote>\n<p>I think the reason it is so misunderstood is because <code>const fn</code> communicates (at least to me) that the function behaves the same as a <code>const FOO</code>; in other words, it's <em>always</em> evaluated at compile time. To me, I think it might be clearer as something like <code>pure fn</code>, but of course it wouldn't make sense to change at this point.</p>\n</blockquote>\n<p>but then why are people not surprised that they can call <code>const fn</code> from normal <code>fn</code> with non-const arguments? That would immediately show that it cannot be \"always evaluated at compile time\".</p>",
        "id": 208185331,
        "sender_full_name": "RalfJ",
        "timestamp": 1598513224
    },
    {
        "content": "<p>For me, it would be that if I did call it with non-const arguments, I would expect it would need to be called. If I call it with const arguments, I would always expect it to be evaluated at compile time</p>",
        "id": 208185497,
        "sender_full_name": "jknodt",
        "timestamp": 1598513351
    },
    {
        "content": "<p>yeah no it's nothing like that. the notion of a \"const argument\" is subtle, and even <em>with</em> const arguments the function can fail (panic, loop forever, ...) so we couln't always do this.</p>",
        "id": 208186082,
        "sender_full_name": "RalfJ",
        "timestamp": 1598513817
    },
    {
        "content": "<p>For cases where we <em>can</em> do it, why would we only do it for <code>const fn</code>? would be a shame to not optimize all the other functions as well.</p>",
        "id": 208186105,
        "sender_full_name": "RalfJ",
        "timestamp": 1598513840
    },
    {
        "content": "<p>Hm, I mean from the perspective of a user who wrote a specific function which they cannot see cases where it might overflow(arithmetic operations are probably the most common use case for const fns) or panic or loop forever, it seems plausible that that specific function would be evaluated at compile time. Thinking about how other functions are compiled is probably not on their mind as well. I think it's most likely a thing which needs counterexamples to demonstrate behaviour of when it won't be propagated, and also explicit mention that all functions can be const-propagated</p>",
        "id": 208186488,
        "sender_full_name": "jknodt",
        "timestamp": 1598514136
    },
    {
        "content": "<p><em>Obviously</em> we need a new keyword <code>nofail</code> for these functions that don't diverge. ;)  (Yes, I know why it'd never work)</p>",
        "id": 208187194,
        "sender_full_name": "isHavvy",
        "timestamp": 1598514793
    },
    {
        "content": "<p>Sorry, I'm also at fault here. For some reason I associated const with a subset of language features the compiler can - for sure - evaluate and so functions will be as well if their input is known at compile time.</p>\n<p>A bit of an off-topic, but what is needed for this to happen? I have some cases in a GH issue, that, from the perspective of a layperson seem like they should be evaluated, but aren't.</p>",
        "id": 208222635,
        "sender_full_name": "Dániel Buga",
        "timestamp": 1598537948
    },
    {
        "content": "<p>In theory, could a compiler use the constness of a function to automagically use memoization for complex functions? Aside from whether or not it would be a desirable feature, would the fact that a function is annotated with const be of  any use if we wanted the compiler to perform such an optimization?</p>",
        "id": 208232190,
        "sender_full_name": "Gerald E. Butler",
        "timestamp": 1598541745
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130459\">@Gerald E. Butler</span> I don’t think it matters, especially as the differences between normal fn and const fn are reduced</p>",
        "id": 208241303,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1598545527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208185307\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"249222\">Elichai Turkel</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208156158\">said</a>:</p>\n<blockquote>\n<p>it looks like sometimes <code>constexpr</code> can even <em>prevent</em> const propagation and inlining under <code>-O1</code></p>\n</blockquote>\n<p>oh wow... why does that happen?</p>\n</blockquote>\n<p>I see that I've forgot to link to godbolt, here: <a href=\"https://godbolt.org/z/EWG5bE\">https://godbolt.org/z/EWG5bE</a>. don't know why that happens</p>",
        "id": 208241475,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598545598
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"307289\">Poliorcetics</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208241303\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"130459\">Gerald E. Butler</span> I don’t think it matters, especially as the differences between normal fn and const fn are reduced</p>\n</blockquote>\n<p>Are you saying that the compiler can determine the constness of a function independent of the const annotation and so could perform const related optimizations regardless of the annotation and that the annotation is just a commitment by the API author that the fn will always be const (barring a major semver bump)?</p>",
        "id": 208243489,
        "sender_full_name": "Gerald E. Butler",
        "timestamp": 1598546563
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span> interesting -- and GCC does better in the <code>constexpr</code> case, looks inlined</p>",
        "id": 208252423,
        "sender_full_name": "cuviper",
        "timestamp": 1598550818
    },
    {
        "content": "<p>actually GCC inlines both, but still emits a <code>square</code> function in the non-const case</p>",
        "id": 208252617,
        "sender_full_name": "cuviper",
        "timestamp": 1598550900
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"130459\">@Gerald E. Butler</span> a const fn is a commitment by the api author(s) that the function will be usable in const context. Constant propagation and constant evaluation (I think you’re talking about that ?) are separate from that ^^</p>",
        "id": 208262739,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1598555542
    },
    {
        "content": "<p>Related Update: the RFC for const blocks has been accepted: <a href=\"https://github.com/rust-lang/rust/issues/76001\">https://github.com/rust-lang/rust/issues/76001</a></p>",
        "id": 208266747,
        "sender_full_name": "Lokathor",
        "timestamp": 1598557664
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> Apperantly in C++ <code>constexpr</code> is implicitly <code>inline</code>, so it's not exactly \"the same as regular function\" <br>\n<a href=\"https://twitter.com/shafikyaghmour/status/1299058963447595008/\">https://twitter.com/shafikyaghmour/status/1299058963447595008/</a><br>\n<a href=\"http://eel.is/c++draft/dcl.constexpr#1.sentence-3\">http://eel.is/c++draft/dcl.constexpr#1.sentence-3</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/shafikyaghmour/status/1299058963447595008/\"><img class=\"twitter-avatar\" src=\"https://pbs.twimg.com/profile_images/1200601050694082560/w4NubWzl_normal.jpg\"></a><p><a href=\"https://twitter.com/Elichai2\">@Elichai2</a> <a href=\"https://twitter.com/llvmorg\">@llvmorg</a> <a href=\"https://twitter.com/zygoloid\">@zygoloid</a> It has the same behavior as inline, which is consistent since constexpr functions are implicitly inline: <a href=\"https://t.co/c8pSl3Zu06\">http://eel.is/c++draft/dcl.constexpr#1.sentence-3</a>\n\nIt applies it during O2: <a href=\"https://t.co/070LJS4KYJ\">https://godbolt.org/z/oE76vn</a>\n\nSo it seems a purposeful decision but not sure why. <a href=\"https://t.co/Qajw255uAg\">https://twitter.com/shafikyaghmour/status/1299058963447595008/photo/1</a></p><span>- Shafik Yaghmour (@shafikyaghmour)</span><div class=\"twitter-image\"><a href=\"https://t.co/Qajw255uAg\"><img src=\"https://pbs.twimg.com/media/EgcvGhJVkAEWEQg.jpg:small\"></a></div></div></div>",
        "id": 208280543,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1598564741
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"249222\">@Elichai Turkel</span> interesting, I did not know that.</p>",
        "id": 208363519,
        "sender_full_name": "RalfJ",
        "timestamp": 1598631328
    },
    {
        "content": "<p>re: using <code>const</code> as an optimziation hint -- considering that this will still require non-trivial analyses, I think the main open question there is why one would restrict this to <code>const</code> fn. Not all <code>const fn</code> <em>successfully</em> evaluate to a constant that the compiler can just embed; if the compiler can determine that a fn call evaluates to a constant then why only do that for <code>const fn</code>?</p>",
        "id": 208363656,
        "sender_full_name": "RalfJ",
        "timestamp": 1598631383
    },
    {
        "content": "<p>personally I would be worried about losses in compile time</p>",
        "id": 208363761,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1598631449
    },
    {
        "content": "<p>even if const evaluation works perfectly and does everything right it still takes some amount of time to execute</p>",
        "id": 208363796,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1598631467
    },
    {
        "content": "<p>as more and more <code>fn</code> become <code>const fn</code>, the same argument applies there</p>",
        "id": 208363803,
        "sender_full_name": "RalfJ",
        "timestamp": 1598631471
    },
    {
        "content": "<p>we'll eventually be able to make almost all of libcore and liballoc <code>const fn</code>. or so we think.</p>",
        "id": 208363869,
        "sender_full_name": "RalfJ",
        "timestamp": 1598631494
    },
    {
        "content": "<p>yes, there are <a href=\"https://rust-lang.github.io/const-eval/\">grand plans</a> ;) but it'll take time</p>",
        "id": 208363941,
        "sender_full_name": "RalfJ",
        "timestamp": 1598631536
    },
    {
        "content": "<p>When will there be a lint that tells you a function can be const?</p>",
        "id": 208365719,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598632468
    },
    {
        "content": "<p>That should probably be disabled by default, since it's a semver break to change it back from const to non-const (thus you shouldn't blindly make everything <code>const</code> just because today they're implemented in a <code>const fn</code>-compatible way).</p>",
        "id": 208365918,
        "sender_full_name": "Laurențiu",
        "timestamp": 1598632566
    },
    {
        "content": "<p>There already is a lint: <a href=\"https://rust-lang.github.io/rust-clippy/master/index.html#missing_const_for_fn\">https://rust-lang.github.io/rust-clippy/master/index.html#missing_const_for_fn</a></p>",
        "id": 208366003,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1598632615
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208365719\">said</a>:</p>\n<blockquote>\n<p>When will there be a lint that tells you a function can be const?</p>\n</blockquote>\n<p>isn't the true question: with which edition will <code>const</code> become the default, and non-const operations require opting out? ;)</p>",
        "id": 208369717,
        "sender_full_name": "RalfJ",
        "timestamp": 1598634369
    },
    {
        "content": "<p>And on that day we really are Haskell</p>",
        "id": 208408145,
        "sender_full_name": "Lokathor",
        "timestamp": 1598661361
    },
    {
        "content": "<p><code>const fn</code> will have mutable state, so... not really I think^^</p>",
        "id": 208426524,
        "sender_full_name": "RalfJ",
        "timestamp": 1598695087
    },
    {
        "content": "<p>So does Haskell though</p>",
        "id": 208433809,
        "sender_full_name": "Lokathor",
        "timestamp": 1598707427
    },
    {
        "content": "<p>not in the same way. <code>const fn</code> has mutable state outside monads.</p>",
        "id": 208438376,
        "sender_full_name": "RalfJ",
        "timestamp": 1598713777
    },
    {
        "content": "<p>I am sorry that I was probably the one who caused this post, I never read this in any docs but I thought more power to const means better codegen but looks like it wasn't.</p>",
        "id": 208439271,
        "sender_full_name": "pickfire",
        "timestamp": 1598714953
    },
    {
        "content": "<p>Still, wouldn't later everyone use <code>const fn</code> rather than <code>fn</code> when possible? I wonder why wouldn't <code>const</code> be opt-in rather than opt-out like <code>mut</code> once it became fully compatible with <code>fn</code> later?</p>",
        "id": 208439338,
        "sender_full_name": "pickfire",
        "timestamp": 1598715027
    },
    {
        "content": "<p>There are API guarantees to take into account: by using <code>const fn</code> you are promising that future revisions of your API won't change the function to be non-const.</p>",
        "id": 208440491,
        "sender_full_name": "Amanieu",
        "timestamp": 1598716546
    },
    {
        "content": "<p>Wouldn't people usually want <code>const</code> rather than not? Is there any reason why people don't want a function to be <code>const</code>?</p>",
        "id": 208461209,
        "sender_full_name": "pickfire",
        "timestamp": 1598747637
    },
    {
        "content": "<p>What is the chance this will be evaluated at compile time? </p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expensive_const</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208467728,
        "sender_full_name": "Manmeet Singh",
        "timestamp": 1598761233
    },
    {
        "content": "<p>Const prop in MIR and LLVM, no guarantee though.</p>",
        "id": 208468043,
        "sender_full_name": "lzutao",
        "timestamp": 1598761932
    },
    {
        "content": "<p>Const prop should be guaranteed if all inputs are const and function is const</p>",
        "id": 208468421,
        "sender_full_name": "Manmeet Singh",
        "timestamp": 1598762708
    },
    {
        "content": "<p>It's possible that this is not correct either, consider a case where you have a fixed address and perform some read in a const fn. Even though it is a const fn with a const argument, it may not be correct if evaluated at compile time.</p>",
        "id": 208468811,
        "sender_full_name": "jknodt",
        "timestamp": 1598763532
    },
    {
        "content": "<p>if you want to force const evaluation to happen just use <code>const</code>...</p>",
        "id": 208468862,
        "sender_full_name": "nagisa",
        "timestamp": 1598763606
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302166\">Manmeet Mann</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208468421\">said</a>:</p>\n<blockquote>\n<p>Const prop should be guaranteed if all inputs are const and function is const</p>\n</blockquote>\n<p>what if there's an infinite loop? what if there's a panic? what if the computation is very expensive and there's many of them?<br>\noptimizations are basically never guaranteed. it would be hard to say what that even means, and it would often not even be a good idea.</p>",
        "id": 208471672,
        "sender_full_name": "RalfJ",
        "timestamp": 1598769714
    },
    {
        "content": "<p>Amusingly, I actually think the inability to define a const context without a const binding is tripping people up, because people grok unsafe { } vs. unsafe fn, but const fn is the only thing there, so they assume it carries an implicit const context, and don't quite realize that is what <code>const NAME = stuff();</code> implies.</p>\n<p>And I grasp that the automatic constant-folding is not exactly == CTFE but often I have to slow way down to keep track of  any difference in, er, context. I don't think people have really been messaged on it.</p>",
        "id": 208630974,
        "sender_full_name": "Jubilee",
        "timestamp": 1598918635
    },
    {
        "content": "<p>If that's the case, then the recently-approved <code>const {}</code> should help that group.</p>",
        "id": 208634134,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1598921720
    },
    {
        "content": "<p>Yeah! I really do suspect not having to use binding and also realizing there's an explicit const context expression will make a lot of people go \"<em>oh</em>\", and probably still confusedly flail a bit at stuff they don't quite understand, but confusedly flail in the right direction.</p>",
        "id": 208636480,
        "sender_full_name": "Jubilee",
        "timestamp": 1598924685
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> that sounds reasonable, let's hope you are right :)</p>",
        "id": 208652823,
        "sender_full_name": "RalfJ",
        "timestamp": 1598945432
    },
    {
        "content": "<p>(to be clear, they have been approved for implementation. stabilization is still ways off.)</p>",
        "id": 208652838,
        "sender_full_name": "RalfJ",
        "timestamp": 1598945446
    },
    {
        "content": "<p>Will <code>const {}</code> make it so I can <code>fn foo(bar: u32) -&gt; { bar + const { some_expensive_const_function(42) } }</code> and have the expensive function run at compile time?</p>",
        "id": 208682123,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1598964696
    },
    {
        "content": "<p>yes, <code>const</code> blocks will be evaluated at compiletime</p>",
        "id": 208682264,
        "sender_full_name": "lcnr",
        "timestamp": 1598964784
    },
    {
        "content": "<p>Does it just avoid having to add a temporary?</p>",
        "id": 208682428,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1598964867
    },
    {
        "content": "<p>const blocks are mostly identical to </p>\n<div class=\"codehilite\"><pre><span></span><code>fn foo(bar: u32) -&gt; {\n    const __INTERAL: ty = some_expensive_const_function(42);\n    bar + __INTERNAL\n}\n</code></pre></div>",
        "id": 208682727,
        "sender_full_name": "lcnr",
        "timestamp": 1598965061
    },
    {
        "content": "<p>so they mostly result in cleaner code</p>",
        "id": 208682802,
        "sender_full_name": "lcnr",
        "timestamp": 1598965090
    },
    {
        "content": "<p>not sure if they allow for anything which was previously not possible</p>",
        "id": 208682816,
        "sender_full_name": "lcnr",
        "timestamp": 1598965100
    },
    {
        "content": "<p>Well, that without the const block, right?</p>",
        "id": 208682822,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1598965109
    },
    {
        "content": "<p>I like recursive definitions as much as everyone else, though!</p>",
        "id": 208682938,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1598965179
    },
    {
        "content": "<p>I think they will eventually support a bit more, by being able to use generic parameters that are in-scope since they're an expression and not an item (like how a closure can use generic parameters from its enclosing function but a function cannot).  That needs some more type system implementation work though (some of the same stuff as non-min const generics) so it won't support that in the first part.</p>",
        "id": 208720720,
        "sender_full_name": "scottmcm",
        "timestamp": 1598981435
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208471672\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302166\">Manmeet Mann</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208468421\">said</a>:</p>\n<blockquote>\n<p>Const prop should be guaranteed if all inputs are const and function is const</p>\n</blockquote>\n<p>what if there's an infinite loop? what if there's a panic? what if the computation is very expensive and there's many of them?<br>\noptimizations are basically never guaranteed. it would be hard to say what that even means, and it would often not even be a good idea.</p>\n</blockquote>\n<p>maybe one good example is fib(100000000) implemented recursively :P</p>",
        "id": 208755842,
        "sender_full_name": "Santiago Pastorino",
        "timestamp": 1598998508
    },
    {
        "content": "<p>Yeah, you'd be compiling for years...</p>",
        "id": 208760436,
        "sender_full_name": "Noah Lev",
        "timestamp": 1599001752
    },
    {
        "content": "<p>Which I'd say is better than forcing the end user to run it for years...</p>",
        "id": 208761657,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1599002673
    },
    {
        "content": "<p>I wouldn't say that. The end user might be a super computer built for the purpose.</p>",
        "id": 208774880,
        "sender_full_name": "Monadic Cat",
        "timestamp": 1599015841
    },
    {
        "content": "<p>I have an idea! Tell the user if their computation is expensive! (Just kidding, I think that's the halting problem.)</p>",
        "id": 208775005,
        "sender_full_name": "Noah Lev",
        "timestamp": 1599015997
    },
    {
        "content": "<p>Making const evaluation guaranteed where all inputs to a const fn are constants would lead to me writing increasingly cursed things to try and suppress that behavior.</p>",
        "id": 208776120,
        "sender_full_name": "Monadic Cat",
        "timestamp": 1599017651
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"336395\">Ahmed Charles</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208682428\">said</a>:</p>\n<blockquote>\n<p>Does it just avoid having to add a temporary?</p>\n</blockquote>\n<p>yes</p>",
        "id": 208800556,
        "sender_full_name": "RalfJ",
        "timestamp": 1599039937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"334100\">Monadic Cat</span> <a href=\"#narrow/stream/122651-general/topic/Common.20misconception.3A.20.60const.20fn.60.20and.20its.20effect.20on.20codegen/near/208776120\">said</a>:</p>\n<blockquote>\n<p>Making const evaluation guaranteed where all inputs to a const fn are constants would lead to me writing increasingly cursed things to try and suppress that behavior.</p>\n</blockquote>\n<p>could you elaborate? when would you not want that to happen (assuming we can do it without excessive compile times)?</p>",
        "id": 208800638,
        "sender_full_name": "RalfJ",
        "timestamp": 1599039970
    },
    {
        "content": "<p>I mean, if you could do it without excessive compile times, then I suppose there's nothing. (I am assuming that such evaluation would never be allowed to change the observable behavior of a program at runtime, except timing, that is. Since platform specific stuff and IO are disallowed in const contexts, I believe that to be the case.)</p>\n<p>It's just that I don't really see how you'd make that guarantee without possibly incurring a massive compile time penalty on someone without their code changing at all.<br>\n(...is that a Crater run waiting to happen?)</p>\n<p>Okay, having done a bit more looking, there is already a mechanism for dealing with this: <a href=\"https://github.com/rust-lang/rust/issues/67217\">https://github.com/rust-lang/rust/issues/67217</a><br>\nIn the case of implicit const evaluation, would you make it so it silently gives up when that limit is reached?<br>\n<del><em>Or maybe run it to the limit and store the end state so the running program can pick up where const eval left off...</em></del></p>\n<p>On further reflection, the only thing I've written that feels like it'd be afflicted by the excessive compile times described above was this thing at involved <code>include_bytes!</code>-ing a giant block of data and doing stuff with it at program startup- since Miri is the big slow, I figured that I'd still prefer that to happen at runtime than in const evaluation.</p>\n<p>I've ended up feeling more ambivalent about this than I expected.</p>",
        "id": 208831871,
        "sender_full_name": "Monadic Cat",
        "timestamp": 1599056853
    },
    {
        "content": "<blockquote>\n<p>(I am assuming that such evaluation would never be allowed to change the observable behavior of a program at runtime, except timing, that is. Since platform specific stuff and IO are disallowed in const contexts, I believe that to be the case.)</p>\n</blockquote>\n<p>That is the case for <em>all</em> optimizations, including this one.</p>\n<blockquote>\n<p>It's just that I don't really see how you'd make that guarantee without possibly incurring a massive compile time penalty on someone without their code changing at all.</p>\n</blockquote>\n<p>I think so, too, which is why I don't think we should do something like this. But I was wondering what your reasoning is.</p>",
        "id": 208850547,
        "sender_full_name": "RalfJ",
        "timestamp": 1599063783
    }
]