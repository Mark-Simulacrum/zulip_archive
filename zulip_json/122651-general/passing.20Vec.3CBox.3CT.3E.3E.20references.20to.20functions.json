[
    {
        "content": "<p>What's the convention around Vec&lt;Box&lt;T&gt;&gt; and passing a reference to it to functions? If you do it naively, you get a <code>&amp;[Box&lt;T&gt;]</code>. Is that considered good style? Intuitively it seems like one would really want a <code>&amp;[&amp;T]</code>, but that's not easy to get.</p>",
        "id": 248438807,
        "sender_full_name": "BOB",
        "timestamp": 1628139761
    },
    {
        "content": "<p>why do you have Vec&lt;Box&lt;T&gt;&gt; anyway? that's two indirections, which is bad for performance</p>",
        "id": 248438837,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1628139791
    },
    {
        "content": "<p>it's necessary for interop with some other things - we get it from another API and making it a Vec&lt;T&gt; would require copying the whole vector</p>",
        "id": 248439051,
        "sender_full_name": "BOB",
        "timestamp": 1628140017
    },
    {
        "content": "<p>hmm, ok. I don't think you can do &amp;[&amp;T] without copying, because Box and &amp; have different layouts - <code>Box</code> stores an allocator and <code>&amp;</code> does not: <a href=\"https://doc.rust-lang.org/src/alloc/boxed.rs.html#176\">https://doc.rust-lang.org/src/alloc/boxed.rs.html#176</a></p>",
        "id": 248439490,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1628140650
    },
    {
        "content": "<p>you get <code>&amp;[Box&lt;T&gt;]</code> but that box will itself turn into <code>&amp;T </code> when necessary, so it's not a big deal if you're using them one at a time.</p>",
        "id": 248439854,
        "sender_full_name": "Lokathor",
        "timestamp": 1628141096
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/122651-general/topic/passing.20Vec.3CBox.3CT.3E.3E.20references.20to.20functions/near/248439490\">said</a>:</p>\n<blockquote>\n<p>hmm, ok. I don't think you can do &amp;[&amp;T] without copying, because Box and &amp; have different layouts - <code>Box</code> stores an allocator and <code>&amp;</code> does not: <a href=\"https://doc.rust-lang.org/src/alloc/boxed.rs.html#176\">https://doc.rust-lang.org/src/alloc/boxed.rs.html#176</a></p>\n</blockquote>\n<p><code>Box&lt;T, Global&gt;</code> is guaranteed to just be the same layout as a pointer. This has been around for a long time, and FFI uses it often</p>",
        "id": 248440741,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628142334
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/std/boxed/index.html#memory-layout\">https://doc.rust-lang.org/std/boxed/index.html#memory-layout</a></p>\n<p>So, I am fairly certain that <code>&amp;[Box&lt;T, Global&gt;]</code> =&gt; <code>&amp;[&amp;T]</code> is fine without copying.</p>",
        "id": 248441052,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628142805
    },
    {
        "content": "<p>Correct. But there's just not a safe way to do it in one step like that, at least not one I know of.</p>",
        "id": 248441115,
        "sender_full_name": "Lokathor",
        "timestamp": 1628142861
    },
    {
        "content": "<p>yeah, it needs unsafe.</p>",
        "id": 248441130,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1628142905
    },
    {
        "content": "<p>I will often use a <code>&amp;[impl Borrow&lt;T&gt;]</code> so you support lots of types like <code>&amp;[T]</code>, <code>&amp;[Box&lt;T&gt;]</code>, <code>&amp;[&amp;T]</code> etc</p>",
        "id": 248441997,
        "sender_full_name": "Kestrer",
        "timestamp": 1628143978
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/122651-general/topic/passing.20Vec.3CBox.3CT.3E.3E.20references.20to.20functions/near/248440741\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/122651-general/topic/passing.20Vec.3CBox.3CT.3E.3E.20references.20to.20functions/near/248439490\">said</a>:</p>\n<blockquote>\n<p>hmm, ok. I don't think you can do &amp;[&amp;T] without copying, because Box and &amp; have different layouts - <code>Box</code> stores an allocator and <code>&amp;</code> does not: <a href=\"https://doc.rust-lang.org/src/alloc/boxed.rs.html#176\">https://doc.rust-lang.org/src/alloc/boxed.rs.html#176</a></p>\n</blockquote>\n<p><code>Box&lt;T, Global&gt;</code> is guaranteed to just be the same layout as a pointer. This has been around for a long time, and FFI uses it often</p>\n</blockquote>\n<p>uhhh that's super concerning, because the docs say \"layout compatible\", but there is no <code>repr(transparent)</code> there</p>",
        "id": 248442038,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1628144027
    },
    {
        "content": "<p>so the compiler does _not_ guarentee it has the same layout as <code>Unique&lt;T&gt;</code></p>",
        "id": 248442060,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1628144043
    },
    {
        "content": "<p>the only way for that to be guarenteed is for the compiler to special-case the lang_item attribute, but that's some very non-local reasoning and I wouldn't be surprised if it regressed unless it's tested somehow</p>",
        "id": 248442215,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1628144244
    },
    {
        "content": "<p>The standard library is special, so it is allowed to rely on the current <code>repr(Rust)</code> layout</p>",
        "id": 248442361,
        "sender_full_name": "Kestrer",
        "timestamp": 1628144410
    },
    {
        "content": "<p>It relies on implementation details in many places actually</p>",
        "id": 248442369,
        "sender_full_name": "Kestrer",
        "timestamp": 1628144423
    },
    {
        "content": "<p>also, if it were to regress then like, wildly huge amounts of rust would break probably in the very next nightly release</p>",
        "id": 248442386,
        "sender_full_name": "Lokathor",
        "timestamp": 1628144447
    },
    {
        "content": "<p>From the <a href=\"https://doc.rust-lang.org/std/boxed/index.html#memory-layout\">docs</a>:</p>\n<blockquote>\n<p>For non-zero-sized values, a Box will use the Global allocator for its allocation. It is valid to convert both ways between a Box and a raw pointer allocated with the Global allocator, given that the Layout used with the allocator is correct for the type. More precisely, a value: <em>mut T that has been allocated with the Global allocator with Layout::for_value(&amp;</em>value) may be converted into a box using Box::&lt;T&gt;::from_raw(value). Conversely, the memory backing a value: <em>mut T obtained from Box::&lt;T&gt;::into_raw may be deallocated using the Global allocator with Layout::for_value(&amp;</em>value).<br>\n(...)<br>\nEven though Box&lt;T&gt; has the same representation and C ABI as a C pointer, this does not mean that you can convert an arbitrary T* into a Box&lt;T&gt; and expect things to work. Box&lt;T&gt; values will always be fully aligned, non-null pointers. Moreover, the destructor for Box&lt;T&gt; will attempt to free the value with the global allocator. In general, the best practice is to only use Box&lt;T&gt; for pointers that originated from the global allocator.</p>\n</blockquote>\n<p>I don't think that means it's layout compatible in the sense of <code>#[repr(transparent)]</code>. Just that we can convert between raw pointers and a Box using the <code>Box::&lt;T&gt;::from_raw(value)</code> and <code>Box::&lt;T&gt;::into_raw</code> methods. Note that the memory model for <code>Box&lt;T&gt;</code> is not set in stone yet, particularly in light of its aliasing rules: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/258\">https://github.com/rust-lang/unsafe-code-guidelines/issues/258</a> (I have no idea about which direction it will end up going in, but as long as it's being discussed, I don't think we can consider it as a stable guarantee :-) ) Even if we assume that <code>Box&lt;T&gt;</code> and <code>&amp;T</code> are layout compatible, converting between these using <code>unsafe</code> might have other unexpected implications (e.g. pointer provenance).</p>",
        "id": 248446158,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628148504
    },
    {
        "content": "<p>The aliasing rules of Box are separate from the layout of Box. Its layout is definitely specified to be equivalent to a pointer. The relavant quote is:</p>\n<blockquote>\n<p>So long as T: Sized, a Box&lt;T&gt; is guaranteed to be represented as a single pointer and is also ABI-compatible with C pointers (i.e. the C type T*).</p>\n</blockquote>\n<p>But yes, I would still be cautious about <code>&amp;[Box&lt;T&gt;] -&gt; &amp;[&amp;T]</code> because although it is guaranteed to work at an ABI level, aliasing rules are in flux and confusing. Especially when there are fully safe alternatives there's no point in discussing this :)</p>",
        "id": 248534431,
        "sender_full_name": "Kestrer",
        "timestamp": 1628196602
    },
    {
        "content": "<p>what is your fully safe alternative?</p>",
        "id": 248559774,
        "sender_full_name": "Lokathor",
        "timestamp": 1628216370
    },
    {
        "content": "<p><code>&amp;[Box&lt;T&gt;]</code> :P</p>",
        "id": 248560655,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628217433
    },
    {
        "content": "<p>That or <code>&amp;[impl Borrow&lt;T&gt;]</code></p>",
        "id": 248575218,
        "sender_full_name": "Kestrer",
        "timestamp": 1628230480
    },
    {
        "content": "<p>I fail to see how <code>&amp;Box</code> could carry aliasing information about that <code>Box</code>: if the <code>Box</code>, itself, is aliased / shared, then the <code>Box</code>'s pointee may very well be aliased as well, so the compiler can't assume any extra property between <code>&amp;Box&lt;T&gt;</code> and <code>&amp;&amp;T</code>.</p>\n<ul>\n<li>(this reminds me of the very interesting <code>&amp;'outer &amp;'inner mut T</code> reference type which is not a stronger but a weaker reference type than <code>&amp;'outer &amp;'inner T</code>, since you can't get a <code>&amp;'inner T</code> out of it).</li>\n</ul>",
        "id": 248589183,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1628242407
    },
    {
        "content": "<p>Uhm, if a function <em>you didn't write</em> takes <code>&amp;[&amp;T]</code> then nothing that any of yall said is a safe alternative way to call that function :P</p>",
        "id": 248619400,
        "sender_full_name": "Lokathor",
        "timestamp": 1628260852
    },
    {
        "content": "<p>Well that wasn't the question was it <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 248655625,
        "sender_full_name": "Kestrer",
        "timestamp": 1628277127
    },
    {
        "content": "<p>Here is a safe way to convert to <code>&amp;[&amp;T]</code>, but at the cost of an extra allocation :P <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=638bce27f83c8781dcbc66cad7a56847\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=638bce27f83c8781dcbc66cad7a56847</a></p>",
        "id": 248661739,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628280336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"431151\">dswijj</span> has marked this topic as resolved.</p>",
        "id": 248696155,
        "sender_full_name": "Notification Bot",
        "timestamp": 1628311681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"431151\">dswijj</span> has marked this topic as unresolved.</p>",
        "id": 248696158,
        "sender_full_name": "Notification Bot",
        "timestamp": 1628311682
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/passing.20Vec.3CBox.3CT.3E.3E.20references.20to.20functions/near/248589183\">said</a>:</p>\n<blockquote>\n<p>I fail to see how <code>&amp;Box</code> could carry aliasing information about that <code>Box</code>: if the <code>Box</code>, itself, is aliased / shared, then the <code>Box</code>'s pointee may very well be aliased as well, so the compiler can't assume any extra property between <code>&amp;Box&lt;T&gt;</code> and <code>&amp;&amp;T</code>.</p>\n<ul>\n<li>(this reminds me of the very interesting <code>&amp;'outer &amp;'inner mut T</code> reference type which is not a stronger but a weaker reference type than <code>&amp;'outer &amp;'inner T</code>, since you can't get a <code>&amp;'inner T</code> out of it).</li>\n</ul>\n</blockquote>\n<p>Here is a fun mind-experiment: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=1f92fb01ec19841a2d327bd52d501dc7\">https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=1f92fb01ec19841a2d327bd52d501dc7</a></p>\n<p>This is not undefined behavior under the current  Stacked Borrows implementation in Miri (try Tools &gt; Miri on the playground). Of course, this dirty code example relies on the assumption that <code>Box&lt;T&gt;</code> has the same size and layout as <code>*mut T</code> for <code>#[repr(Rust)]</code>, which is only guaranteed for the C ABI which gets invoked across FFI boundaries if I understand the <a href=\"https://doc.rust-lang.org/std/boxed/index.html#memory-layout\">documentation</a> over at <code>Box&lt;T&gt;</code> correctly. </p>\n<p>But, what exactly does <code>#[repr(Rust)]</code> mean for <code>Box&lt;T&gt;</code>? (From the official reference](<a href=\"https://doc.rust-lang.org/reference/type-layout.html#the-default-representation\">https://doc.rust-lang.org/reference/type-layout.html#the-default-representation</a>):</p>\n<blockquote>\n<p>Nominal types without a repr attribute have the default representation. Informally, this representation is also called the rust representation.</p>\n<p>There are no guarantees of data layout made by this representation.</p>\n</blockquote>\n<p>This agrees with the reading of the <code>Box&lt;T&gt;</code> documentation. However, unofficially the Rust Unsafe Code Guidelines Reference (disclaimer: these are just \"<a href=\"https://rust-lang.github.io/unsafe-code-guidelines/introduction.html\">recommendations</a>\" and not part of the official reference - yet), <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/layout/structs-and-tuples.html\">says the following</a> about <code>#[repr(Rust)]</code>:</p>\n<blockquote>\n<p><strong>Struct types</strong><br>\n(...)<br>\nIn terms of their layout, tuple structs can be understood as equivalent to a named struct with fields named 0..n-1<br>\n(...)<br>\n<strong>Single-field structs</strong><br>\nA struct with only one field has the same layout as that field.</p>\n<p><strong>Structs with 1-ZST fields</strong><br>\nFor the purposes of struct layout 1-ZST fields are ignored.</p>\n<p>In particular, if all but one field are 1-ZST, then the struct is equivalent to a single-field struct. In other words, if all but one field is a 1-ZST, then the entire struct has the same layout as that one field.</p>\n<p>Similarly, if all fields are 1-ZST, then the struct has the same layout as a struct with no fields, and is itself a 1-ZST.<br>\n(...)</p>\n</blockquote>\n<p>The type definition of <code>Box</code> is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span>: <span class=\"nc\">Allocator</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Global</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">Unique</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The <code>Global</code> allocator is a 1-ZST (i.e. a zero sized type which is aligned to a 1-byte boundary). So the layout of a <code>Box&lt;T, Global&gt;</code> then is the same as the layout of a <code>Unique&lt;T&gt;</code>, which is the only sized field of the tuple struct <code>Box&lt;T, Global&gt;</code>. The <a href=\"https://docs.rs/ptr/0.2.3/src/ptr/lib.rs.html#43-51\">type definition of <code>Unique</code></a> is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Unique</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ptr</span>: <span class=\"nc\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_marker</span>: <span class=\"nc\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Here, <code>PhantomData&lt;T&gt;</code> is again a 1-ZST, so <code>Unique&lt;T&gt;</code> has the same layout as <code>NonNull&lt;T&gt;</code> and transitively <code>Box&lt;T, Global&gt;</code> has the same layout as <code>NonNull&lt;T&gt;</code>. The <a href=\"https://doc.rust-lang.org/src/core/ptr/non_null.rs.html#50-52\">type definition of <code>NonNull</code></a> is:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(transparent)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pointer</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And it is <code>#[repr(transparent)]</code> with a raw pointer! Thus, if we follow the reasoning of the Unsafe Code Guidelines Reference, then <code>Box&lt;T, Global&gt;</code> has the same memory layout as a raw pointer. Again disclaimer: this could still change, as the guidelines state in its <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/introduction.html\">introduction</a>. And that is probably the reason why the official Rust reference doesn't claim this is defined behavior, so that the language designers have the freedom to make changes if needed :-)</p>\n<p>So what was the purpose of the code example at the beginning of this reply? Well, for science of course! And just to show that in today's compilation, it is possible to convert <code>&amp;[Box&lt;T&gt;]</code> to <code>&amp;[*mut T]</code> and <code>&amp;[&amp;T]</code> under the (unstable) assumptions of the Unsafe Code Guidelines and Stacked Borrows model. But because these guidelines are still unstable, it is also undefined behavior under the official Rust reference, even though it actually compiles and works as expected :)</p>",
        "id": 248706575,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628327800
    },
    {
        "content": "<blockquote>\n<p>The type definition of Box is:</p>\n</blockquote>\n<p>Those aren't public, so you wouldn't be allowed to use that information in your reasoning.</p>",
        "id": 248706923,
        "sender_full_name": "The 8472",
        "timestamp": 1628328457
    },
    {
        "content": "<p>That's a very good point. <code>Box</code>,  <code>PhantomData</code>, <code>NonNull</code>, the <code>Allocator</code> trait and <code>Global</code> are all public (the last 2 only behind a nightly feature gate <code>allocator_api</code>), but <code>Unique</code> is only available to the core/standard library :) Unless your manually import the <code>ptr</code> crate, but the standard library makes no external guarantees about the internal use of <code>Unique</code>, I believe, so that wouldn't make much sense indeed.</p>",
        "id": 248710929,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628334401
    },
    {
        "content": "<p>I meant the fields, those aren't public.</p>",
        "id": 248712784,
        "sender_full_name": "The 8472",
        "timestamp": 1628337295
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span> note: the reference isn't actually normative either</p>",
        "id": 248714953,
        "sender_full_name": "Lokathor",
        "timestamp": 1628340671
    },
    {
        "content": "<p>Isn't Box defined to have the same layout as *mut T?</p>",
        "id": 248715026,
        "sender_full_name": "Connor Horman",
        "timestamp": 1628340802
    },
    {
        "content": "<p>not for all T</p>",
        "id": 248718689,
        "sender_full_name": "The 8472",
        "timestamp": 1628346206
    },
    {
        "content": "<p>only for the Global allocator and for sized T</p>",
        "id": 248719037,
        "sender_full_name": "Lokathor",
        "timestamp": 1628346719
    },
    {
        "content": "<p>though i didn't mean that to any specific statement being wrong, just that the reference cannot be taken as any more correct than any other part of Rust.</p>",
        "id": 248719263,
        "sender_full_name": "Lokathor",
        "timestamp": 1628346990
    },
    {
        "content": "<p>Another option would just be to use: <code>impl Iterator&lt;Item=&amp;T&gt;</code> and then you can pass whatever you want (worse case you need to use<code>map</code> on it)</p>",
        "id": 248846650,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1628516215
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span> that's indeed an interesting example. To simplify, <code>&amp;&amp;mut T</code> is transmuted to a <code>&amp;*mut T</code> whereby the inner pointer is then used to perform a write-dereference (note how this avoids having to talk about <code>Box</code>es and their layout). Which is definitely a capability that <code>&amp;&amp;T</code> doesn't have (for <code>T : Freeze</code> at least). My gut tells me this operation can't be right precisely because <code>&amp;&amp;mut T</code> (or <code>&amp;Box</code>) is outer-aliased, and that this is infectious for references and boxes, and that miri just fails to detect this atm (false negative). <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> what do you think of this?</p>\n<hr>\n<p>Anyhow, for safe code out there, yielding a <code>&amp;'lt [&amp;'lt T]</code> out of a <code>&amp;'lt [Box&lt;T&gt;]</code> or a <code>&amp;'lt [&amp;'_ mut T]</code> (through a transmute / manual slice creation) ought to be always safe as the layouts involved don't change, and since the yielded value provides no extra capabilities.</p>",
        "id": 248874183,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1628527463
    },
    {
        "content": "<p>That's a nice thought <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> Are there any notes or minutes on the concepts of outer aliases and inner aliases? I've heard these terms a few times before, which makes me think there might be some material about it somewhere, although my Google skills did not come up with any <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  I've had an interesting talk with Ralf in the past about taking a SharedReadOnly reference to a SharedReadWrite pointer (the <em>type</em> <code>&amp;*mut T</code> - not the expression, e.g. <code>let example: &amp;*mut usize = &amp;core::ptr::NonNull::dangling().as_ptr();</code>). The outcome was that this is perfectly valid under stacked borrows because the reference only asserts that we don't mutate the pointer, but it's okay to mutate the pointee (although this is a slight simplification of what we discussed back then, in the full example that <code>*mut T</code> pointer was in a struct field and a shared reference was taken to the struct). I'm curious how this differs exactly when we talk about a <code>&amp;&amp;mut T</code> instead of a <code>&amp;*mut T</code>, because both inner pointers have write provenance under the current stacked borrows implementation.</p>",
        "id": 248894281,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628536644
    },
    {
        "content": "<p>Note that I have just \"invented\" the words that best suited my own view, I may very well be wrong, or there may be a more appropriate wording <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <br>\nSo, the thing is, that, indeed, there can be instance of the type <code>&amp;(*mut T)</code> which could be used to write through its inner pointer,  since the … \"propagation of aliasing\" (…?) cannot propagate through a raw pointer, so something such as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// this is a `&amp;(*mut i32)`</span>\n<span class=\"c1\">// vvvvvvvvvvvvvvvvvvvvvv</span>\n<span class=\"w\"> </span><span class=\"o\">**&amp;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n</code></pre></div>\n<p>ought to be fine.</p>\n<p>But I don't know what the situation is when the inner pointer is a \"high level\" / <code>dereferenceable</code> one, such as <code>&amp;T</code>, <code>&amp;mut T</code>, or <code>Box&lt;T&gt;</code>. I'd conservatively assume that the aliasing property or lack thereof could propagate through it, even though miri doesn't check for that, and the compiler itself may thus not even be exploiting that. So I really don't know <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 248898052,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1628538490
    },
    {
        "content": "<p>That's an interesting theory, I would be very curious to know the details about how it works now and how it <em>would</em> work in a perfect world <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 248906557,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628542422
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/passing.20Vec.3CBox.3CT.3E.3E.20references.20to.20functions/near/248874183\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> that's indeed an interesting example. To simplify, <code>&amp;&amp;mut T</code> is transmuted to a <code>&amp;*mut T</code> whereby the inner pointer is then used to perform a write-dereference (note how this avoids having to talk about <code>Box</code>es and their layout). Which is definitely a capability that <code>&amp;&amp;T</code> doesn't have (for <code>T : Freeze</code> at least). My gut tells me this operation can't be right precisely because <code>&amp;&amp;mut T</code> (or <code>&amp;Box</code>) is outer-aliased, and that this is infectious for references and boxes, and that miri just fails to detect this atm (false negative). <span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> what do you think of this?</p>\n<hr>\n<p>Anyhow, for safe code out there, yielding a <code>&amp;'lt [&amp;'lt T]</code> out of a <code>&amp;'lt [Box&lt;T&gt;]</code> or a <code>&amp;'lt [&amp;'_ mut T]</code> (through a transmute / manual slice creation) ought to be always safe as the layouts involved don't change, and since the yielded value provides no extra capabilities.</p>\n</blockquote>\n<p>what's a \"write-dereference\"? some concrete example code would be helpful :D</p>",
        "id": 248982058,
        "sender_full_name": "RalfJ",
        "timestamp": 1628603814
    },
    {
        "content": "<p>but Stacked Borrows doesnt really do anything with \"nested references\"</p>",
        "id": 248982138,
        "sender_full_name": "RalfJ",
        "timestamp": 1628603853
    },
    {
        "content": "<p>the aliasing requirements of the outer ptr in <code>&amp;usize</code> and <code>&amp; &amp;mut T</code> are the same</p>",
        "id": 248982173,
        "sender_full_name": "RalfJ",
        "timestamp": 1628603871
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> here is a minimal example that is able to \"fool\" Miri using <code>Box</code> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2c46f6ffa06369747c666b0fc525cd92\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=2c46f6ffa06369747c666b0fc525cd92</a> <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> and I were entertaining a thought about whether we could to the same for <code>&amp;&amp;mut T</code> (the linked example uses a<code>&amp;Box&lt;T&gt;</code> instead). After I was playing around a bit to make it compile with <code>&amp;&amp;mut T</code>, I realized that this is not possible because it is undefined behavior to write to a <code>*mut T</code> while there exists a (temporary) <code>&amp;mut T</code> to the same memory location on the stack (we can't reborrow the <code>&amp;mut T</code>, because there is only access to a <code>&amp;&amp;mut T</code>). However, currently Miri doesn't trigger when doing this to a <code>&amp;Box&lt;T&gt;</code> because internally <code>Box&lt;T&gt;</code> holds a <code>*mut T</code> and not a <code>&amp;mut T</code>. I wrote \"fool\" in double quotes, because it is not an entirely fair code example. The way I'm currently interpreting the <a href=\"https://doc.rust-lang.org/std/boxed/index.html#memory-layout\">documentation</a> for <code>Box</code>, it does not claim that it is defined behavior to recast a <code>Box&lt;T&gt;</code> to a <code>*mut T</code>, although I'm not sure my interpretation is correct. Also there already is an open issue about this peculiarity of <code>Box</code> I believe: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/258\">https://github.com/rust-lang/unsafe-code-guidelines/issues/258</a></p>",
        "id": 248987906,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628606211
    },
    {
        "content": "<p>p.s. this even seems to go under the radar when running <code>MIRIFLAGS=\"-Zmiri-track-raw-pointers\" cargo miri test</code>. If this somehow makes an interesting test case for Miri, let me know, I'll be happy to send in a PR <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 248990141,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628607348
    },
    {
        "content": "<blockquote>\n<p>currently Miri doesn't trigger when doing this to a &amp;Box&lt;T&gt; because internally Box&lt;T&gt; holds a *mut T</p>\n</blockquote>\n<p>That does not sound right; Miri treats <code>Box</code> specially so the internal <code>*mut</code> is irrelevant</p>",
        "id": 248992932,
        "sender_full_name": "RalfJ",
        "timestamp": 1628608595
    },
    {
        "content": "<p>There's nothing wrong with writing to a raw ptr that sits behind a shared ref so I think Miri accepting your testcase is completely fine. I cant see anyone being \"fooled\" here. ;)<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=71e4b9dd976bce8e2bd90e2fd2530345\">Mutable references behave exactly the same way</a>. Why do you say the same does not work with mutable references?</p>",
        "id": 248993306,
        "sender_full_name": "RalfJ",
        "timestamp": 1628608796
    },
    {
        "content": "<p>I was originally going to say that SB will let you copy <code>&amp;mut T</code> around by e.g. <code>transmute_copy</code>, and they will all act like the \"same\" reference and can be used interchangeably, but testing revealed that this is not the case and I think <span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span> 's hypothesis might be correct. I should try doing that with <code>Box&lt;T&gt;</code> as well</p>",
        "id": 248993566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628608921
    },
    {
        "content": "<p>No, <code>Box&lt;T&gt;</code> gives the same error. Here's the test case btw:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute_copy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// miri says this is \"no item granting write access\" UB</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ignore the double free here</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 248993976,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628609159
    },
    {
        "content": "<p>yes, Miri will perform retagging on the result of a function call that returns a reference or Box</p>",
        "id": 248997897,
        "sender_full_name": "RalfJ",
        "timestamp": 1628610970
    },
    {
        "content": "<p>aha, so wrapping in a tuple works then:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">,);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">,)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">read</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(with <code>Box</code> instead of <code>&amp;mut</code> this will also work provided you avoid the double free at the end)</p>",
        "id": 248998979,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628611446
    },
    {
        "content": "<p>What are the implications of that <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> ? Intuitively, I would say that there should not be two <code>&amp;mut u8</code> to the same memory location! But your last example has exactly that, neat <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 249122090,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628694850
    },
    {
        "content": "<p>I've been thinking a bit more about writing to a shared mutable reference <code>&amp;&amp;mut T</code> through casting it to a shared mutable pointer <code>&amp;*mut T</code> first. Giving it some more thought and processing the above comments, I guess that is fine because Miri treats that as a reborrow of the mutable reference.  <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=71e4b9dd976bce8e2bd90e2fd2530345\">An example to illustrate what I mean</a>. The fact that it sites behind a shared reference means nothing.</p>",
        "id": 249124259,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628695758
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span> This all requires unsafe code, but it's a good question whether the compiler is making assumptions that are violated by such an arrangement, because that would mean that stacked borrows (or at least its implementation, e.g. where retags are inserted) is not correct. For example, I can imagine a current or future compiler optimization constant propagating the read of <code>y</code> to read <code>2</code> directly, and that would be incorrect in this example, even though there is no UB in the source program according to SB or miri.</p>",
        "id": 249141747,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1628703403
    },
    {
        "content": "<p>Another relevant issue in the unsafe-code-guidelines repo that hasn’t been mentioned in this discussion AFAICT: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/270#issuecomment-761549965\">https://github.com/rust-lang/unsafe-code-guidelines/issues/270#issuecomment-761549965</a></p>",
        "id": 249143516,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1628704166
    },
    {
        "content": "<p>Thinking a bit further about why safe Rust doesn't allow writing to a <code>&amp;&amp;mut T</code>, I can think of a counter example that shows why. If <code>T: Sync</code> <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9bd6d2c8424c8e97d2fdd9f93c8199f0\">then <code>&amp;&amp;mut T</code> is <code>Send + Sync</code></a> and this could lead to data races when two threads try to write to the same <code>T</code> at the same time through the <code>&amp;&amp;mut T</code> <span aria-label=\"smile cat\" class=\"emoji emoji-1f638\" role=\"img\" title=\"smile cat\">:smile_cat:</span> An interesting case is where <code>T: !Sync</code>, though. Under Miri's current implementation of SB, it would be unsafe but sound to write to a <code>&amp;&amp;mut T</code> for <code>T: !Sync</code> if  (and only if) the inner <code>&amp;mut T</code> can be reborrowed as a <code>*mut T</code>, but without the use of <code>UnsafeCell&lt;T&gt;</code>! Then this essentially becomes semantically similar to <code>&amp;&amp;Cell&lt;T&gt;</code> which has safe interior mutability, but uses an <code>UnsafeCell&lt;T&gt;</code> internally. The fact that this would be possible without the use of <code>UnsafeCell&lt;T&gt;</code> might be a hint that this might not hold though. Reading through the <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/270#issuecomment-761544941\">link</a> that <span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span>  mentioned, Ralf says that:</p>\n<blockquote>\n<blockquote>\n<p>Is transmuting &amp;’a &amp;’b T to &amp;’a &amp;’b mut T sound or UB?</p>\n</blockquote>\n<p>FWIW, if we ignore Stacked Borrows, we even have a <a href=\"https://gitlab.mpi-sws.org/iris/lambda-rust/-/blob/master/theories/typing/lib/fake_shared.v\">proof of soundness</a> for this in RustBelt. (So @digama0's analysis at the beginning of this thread is right.) But of course this assumes the RustBelt semantic model. That said, there is already code out there which assumes this to be correct (<a href=\"http://www.frankmcsherry.org/serialization/2015/05/04/unsafe-at-any-speed.html\">code like this</a>, dubbed \"Abomonation\"), and the RustBelt model was designed the way it is specifically to support that kind of code.</p>\n</blockquote>\n<p>In other words, if it is sound to transmute a <code>&amp;&amp;T</code> to a <code>&amp;&amp;mut T</code> (proven using RustBelt nonetheless!), then it should surely not be sound to write to a <code>&amp;*mut T</code> unsafely derived from a <code>&amp;&amp;mut T</code> <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>  Otherwise this would open up a hole where we could transmute a <code>&amp;&amp;T</code> to a <code>&amp;&amp;mut T</code> and then to a <code>&amp;*mut T</code> to which it is valid to write to the inner <code>*mut T</code>. This last bit of information makes me think that Miri gives a false positive in my <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b23732823d9f9e9151041364ac8ec6d5\">last example</a>. Although I surely hope I'm wrong <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 249162386,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628712348
    },
    {
        "content": "<p>Just to illustrate what I mean by \"<em>Otherwise this would open up a hole where we could transmute a <code>&amp;&amp;T</code> to a <code>&amp;&amp;mut T</code> and then to a <code>&amp;*mut T</code> to which it is valid to write to the inner <code>*mut T</code></em>\", here is an example to take away any ambiguity that I may have uttered <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>  <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4605053c1ad318e52ea778fbde369cb9\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=4605053c1ad318e52ea778fbde369cb9</a> .</p>",
        "id": 249165015,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628713803
    },
    {
        "content": "<p>I guess the lesson learned is that Miri only detects undefined behavior and not <em>unsoundness without manifested undefined behavior</em>, such as in this <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=b23732823d9f9e9151041364ac8ec6d5\">previous example</a>. This was fun <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 249165295,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628713927
    },
    {
        "content": "<p>Yep, which is why I mentioned the <code>&amp;&amp;mut T</code> example since the very beginning: it can't be an always usable property, but, similar to provenance, it could be  property of some instance of such (nested) refs. I personally find it more confusing and error-prone than the simple: stuff is kind of transitive until a raw pointer is reached.</p>",
        "id": 249219707,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1628765592
    },
    {
        "content": "<p>Good call <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Indeed it is not immediately very intuitive.</p>\n<blockquote>\n<p>stuff is kind of transitive until a raw pointer is reached.</p>\n</blockquote>\n<p>Does that imply this is sound under all circumstances?  <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=844cdda6f6d1a873bd9ecfede00468d5\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=844cdda6f6d1a873bd9ecfede00468d5</a></p>\n<p>If so, then that would also imply that even though it is sound to transmute a <code>&amp;'a &amp;'b T</code> to <code>&amp;'a &amp;'b mut T</code>, it would be <em>unsound</em> to transmute a <code>&amp;'a &amp;'b T</code> to a <code>&amp;'a *mut T</code> (although technically speaking, you can't access the underlying <code>T</code> from safe code in that case, but it would become very hard for any unsafe code that uses <code>&amp;*mut T</code> for writing to <code>T</code> to defend against all possible forms of unsoundness <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span> ).</p>",
        "id": 249221914,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628767431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/122651-general/topic/passing.20Vec.3CBox.3CT.3E.3E.20references.20to.20functions/near/249221914\">said</a>:</p>\n<blockquote>\n<p>Does that imply this is sound …?</p>\n</blockquote>\n<p>To clarify my previous comment: what I mention is from a (SB-aware) user's point of view, not from a compiler engineer / language designer's point of view, so I may very well be missing the whole picture / a consistent theoretical model. So take what I say as suggestions / opinions <em>w.r.t.</em> apparent clarity; definitely not as normative or whatnot.</p>\n<p>That being said, in that Playground example of yours, since there is a raw pointer in the middle, indeed, to the best of my knowledge / understanding of SB, anything outside it doesn't matter (since we only need to <em>read</em> the address, shared read-only access to the pointer suffices). Then, when dereferencing the raw pointer, two things matter:</p>\n<ul>\n<li>whether there is a parallel (or, provenance-wise, concurrent / interleaved) access to the pointee, of which there is not;</li>\n<li>whether the point where the pointer was created / whence it originates (hence <em>provenance</em>) had the right to perform the dereference operation to begin with. Since it originated from a <code>ptr::addr_of_mut!</code> to a (<code>mut</code>able) place, the pointer has Shared Read-Write provenance (or even Unique) so the operation is correct.</li>\n</ul>\n<p>(To clarify the \"provenance-wise, concurrent/ interleaved\" caveat, imagine inserting a <code>drop(&amp;mut x);</code> statement after the creation of <code>y</code> and before the dereference: that would insert a <code>Unique</code> assertion on the <code>&amp;mut x</code> pointer, invalidating thenceforth the provenance of the <code>**y</code> pointer)</p>",
        "id": 249223229,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1628768386
    },
    {
        "content": "<p>That makes sense, thank you for the clarification <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span>  <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> I guess that means that transmuting a <code>&amp;'a &amp;'b T</code> to <code>&amp;'a *mut T</code> is at least semantically incorrect (because the provenance of the inner <code>*mut T</code>pointer from the resulting <code>&amp;*mut T</code> pointer has the wrong provenance: SharedReadOnly - while a <code>*mut T</code> should have a provenance of SharedReadWrite, semantically speaking). Is <em>semantically incorrect</em> interchangeable with <em>unsound</em> in this case, or are these two distinct concepts? I suspect that RustBelt would say that the transmutation from <code>&amp;&amp;T</code> to <code>&amp;*mut T</code> is unsound due to its emphasis on correct semantics, but that SB wouldn't care until the <code>&amp;*mut T</code> is actually dereferenced through SharedReadWrite provenance. A <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=38e0d0bae334328802a3d2d3948834c6\">quick test</a> confirms this for SB. When trying to do the same thing using an <code>UnsafeCell&lt;T&gt;</code> <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=release&amp;edition=2018&amp;gist=9e78aa9937b165e7c92cb7955ab6c5a2\">it fails Miri</a> due to the wrong provenance.</p>",
        "id": 249226733,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628770615
    },
    {
        "content": "<blockquote>\n<p>I suspect that RustBelt would say that the transmutation from &amp;&amp;T to &amp;*mut T is unsound due to its emphasis on correct semantics</p>\n</blockquote>\n<p><code>*const T</code> and <code>*mut T</code> are pretty much interchangeable. They only differences between them is that they are strictly speaking different types and have slightly different autoref rules. Casting between the two is sound and safe. This means that <code>&amp;&amp;T -&gt; &amp;*mut T</code> is just as sound as <code>&amp;&amp;T -&gt; &amp;*const T</code> which obviously should be allowed.</p>",
        "id": 249229305,
        "sender_full_name": "bjorn3",
        "timestamp": 1628772218
    },
    {
        "content": "<p>Interesting :)</p>",
        "id": 249229895,
        "sender_full_name": "Pointerbender",
        "timestamp": 1628772572
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400735\">@Pointerbender</span> yeah, since a raw pointer requires <code>unsafe</code> for any meaningful use of its API, it cannot be unsound: an operation (or rather, a non-<code>unsafe</code> API showcasing / exposing a certain operation) is unsound if safe code using it can cause UB with it. As <span class=\"user-mention\" data-user-id=\"133247\">@bjorn3</span> pointed out, since <code>&amp;T -&gt; *{const,mut} T</code> is safe (and thus sound, modulo compiler soundness bugs <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>), then <code>&amp;&amp;T -&gt; &amp;*{const,mut} T</code> must be sound as well. And indeed, consider:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// Look, no `unsafe`!</span>\n<span class=\"k\">fn</span> <span class=\"nf\">with_raw_inner</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">p</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">yield_</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"nb\">_</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nc\">R</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Granted, it's not the same pointer as input 😁</span>\n<span class=\"w\">    </span><span class=\"n\">yield_</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>Aside: this means it's actually sound to <code>impl Send</code> / <code>impl Sync</code> for raw pointers, since it can't be abused with non-<code>unsafe</code> code. But it would lead to way more error-prone code, obviously.</li>\n</ul>\n<p>In practice, <code>*const</code> <em>vs.</em> <code>*mut</code> is used to get correct (lack of) variance<del>, much like we have <a href=\"https://docs.rs/safer-ffi/0.0.6/safer_ffi/ptr/index.html\"><code>NonNull&lt;T&gt;</code> and <code>NonNullMut&lt;T&gt;</code></a></del> (<span aria-label=\"weary\" class=\"emoji emoji-1f629\" role=\"img\" title=\"weary\">:weary:</span>)</p>",
        "id": 249230238,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1628772758
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122651-general/topic/passing.20Vec.3CBox.3CT.3E.3E.20references.20to.20functions/near/249229305\">said</a>:</p>\n<blockquote>\n<p>They only differences between them is that they are strictly speaking different types and have slightly different autoref rules.</p>\n</blockquote>\n<p>They also <a href=\"https://doc.rust-lang.org/nomicon/subtyping.html#variance\">differ in variance</a>.</p>",
        "id": 249274469,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1628793161
    },
    {
        "content": "<blockquote>\n<p>aha, so wrapping in a tuple works then:</p>\n</blockquote>\n<p>currently it does, but there's no decision yet about this. earlier versions of Stacked Borrows would have complained about this code.</p>",
        "id": 249341301,
        "sender_full_name": "RalfJ",
        "timestamp": 1628848266
    },
    {
        "content": "<blockquote>\n<p>*const T and *mut T are pretty much interchangeable.</p>\n</blockquote>\n<p>True, with one big caveat: <em>casting</em> a <em>reference</em> to <code>*const T</code> vs <code>*mut T</code> is a very different operation. the former creates a ptr with SharedReadOnly permission, the latter creates a ptr with SharedReadWrite permission.</p>",
        "id": 249341585,
        "sender_full_name": "RalfJ",
        "timestamp": 1628848467
    }
]