[
    {
        "content": "<p><a href=\"https://stackoverflow.com/q/71771005/155423\">Why does moving a disjoint field capture into a closure differ when the type is a value vs a reference?</a></p>\n<p>TL;DR:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Wrapper</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">this_works</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">captured</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">value</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">captured</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">why_doesnt_this</span><span class=\"p\">(</span><span class=\"n\">captured</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Wrapper</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">value</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">captured</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278056652,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1649265353
    },
    {
        "content": "<p>I believe what happens is that the reference <code>captured</code> in the second example, the reference gets moved into the closure, which requires annotating the <code>impl FnOnce</code> with a lifetime to represent that reference.</p>\n<p>There's a little information here: <a href=\"https://github.com/rust-lang/reference/blob/44f6e1e20f40dddf1b5e9aa002d5cd6e7a629663/src/types/closure.md#capturing-references-in-move-contexts\">https://github.com/rust-lang/reference/blob/44f6e1e20f40dddf1b5e9aa002d5cd6e7a629663/src/types/closure.md#capturing-references-in-move-contexts</a></p>",
        "id": 278061032,
        "sender_full_name": "Eric Huss",
        "timestamp": 1649267391
    },
    {
        "content": "<blockquote>\n<p>the reference gets moved into the closure</p>\n</blockquote>\n<p>Sure, but why? The <em>owned</em> value isn't moved into the closure â€” rather the point of the feature.</p>",
        "id": 278061638,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1649267670
    },
    {
        "content": "<p>Yea, I'm not sure why. It seems like it could just copy the field and not capture the reference.  I'm looking through the rfc 2229 notes, but I'm not seeing where this particular case is discussed.</p>",
        "id": 278061869,
        "sender_full_name": "Eric Huss",
        "timestamp": 1649267777
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120518\">@Eric Huss</span> </p>\n<blockquote>\n<p>This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.</p>\n</blockquote>\n<p>Is this from a PR?</p>",
        "id": 278062042,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1649267879
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/reference/pull/1059\">https://github.com/rust-lang/reference/pull/1059</a></p>",
        "id": 278062737,
        "sender_full_name": "Eric Huss",
        "timestamp": 1649268182
    },
    {
        "content": "<p>Thinking about it some more, I think it makes sense to capture the reference.  Otherwise you could have a situation like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">why_doesnt_this</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">456</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">closure</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>If it didn't capture the reference, then the closure would have an old copy of the field (123).  It seems like it could lead to some ambiguity in what the author intended.</p>",
        "id": 278066449,
        "sender_full_name": "Eric Huss",
        "timestamp": 1649269670
    },
    {
        "content": "<p>A SO answer proposes that since a reference is moved in, so should any field derived from a reference (my re-wording).</p>",
        "id": 278069442,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1649271144
    },
    {
        "content": "<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// moves in the `&amp;i32`</span>\n</code></pre></div>\n<p>therefore</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Wrapper</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// moves in the `&amp;i32`</span>\n</code></pre></div>",
        "id": 278069587,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1649271214
    },
    {
        "content": "<p>I disagree with your example though, as it's not really compelling. You can have that behavior now</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">why_doesnt_this</span><span class=\"p\">(</span><span class=\"n\">captured</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Wrapper</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">captured</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">value</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278070405,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1649271602
    },
    {
        "content": "<p>We really need <strong>fine-frained <code>move</code></strong> annotations, not the current situation with the compiler's best-effort heuristics, which just can't be good enough in some cases:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">why_doesnt_this</span><span class=\"p\">(</span><span class=\"n\">captured</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Wrapper</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">move</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">captured</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">value</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278174876,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649342881
    },
    {
        "content": "<p>But yeah, the current heuristic, barring the new 2021-captures and its \"place optimizations\", is that the <code>move</code> modifier interacts with variable names <em>mentioned</em> inside the closure's body, \"no matter how\" (again, 2021 makes the situation even more complex). </p>\n<p>This effectively leads to what <span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Why.20do.20disjoint.20captures.20differ.20for.20refs.20and.20owned.20values.3F/near/278069587\">said</a>.</p>",
        "id": 278175472,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649343123
    }
]