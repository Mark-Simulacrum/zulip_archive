[
    {
        "content": "<p>I wanted to do some <code>chunks</code> of a <code>Vec&lt;T&gt;</code> but saw that we had no methods for that, only <code>std::slice</code> has does, and I needed specifically a <code>Vec</code>, my type was not <code>Clone</code>.</p>\n<p>I think that it is quite similiar to how <code>std::slice</code> can be <code>split</code>, but you can do that too with owned values in <code>Vec</code>, I'd like to know if there is any reason we could not have some kind of <code>vec_chunks</code> on <code>Vec</code> that consumes the Vec ? (If there is no reason apart \"nobody coded that\" I'l gladly do it !)</p>",
        "id": 207410414,
        "sender_full_name": "traxys",
        "timestamp": 1597845204
    },
    {
        "content": "<p>there's is no technical reason I can think of, but each returned vec would have to be a newly allocated vec, if you care about that part of it.</p>",
        "id": 207411346,
        "sender_full_name": "Lokathor",
        "timestamp": 1597845607
    },
    {
        "content": "<p>hm, it seems like with const generics if you're able to specify N at compile-time we could do Iterator::chunks which has Item = [T; N]</p>",
        "id": 207411418,
        "sender_full_name": "simulacrum",
        "timestamp": 1597845642
    },
    {
        "content": "<p>maybe that's what we should actually do instead of the array_chunks method that was recently unstably added...</p>",
        "id": 207411444,
        "sender_full_name": "simulacrum",
        "timestamp": 1597845659
    },
    {
        "content": "<p>I don't think adding <code>vec_chunks</code> is the best solution here.</p>\n<p>IMO it would be a good idea to add <code>Iterator::chunks</code> now that const generics is usable</p>",
        "id": 207411620,
        "sender_full_name": "lcnr",
        "timestamp": 1597845732
    },
    {
        "content": "<p>which returns the content of an iterator in <code>N</code> element chunks</p>",
        "id": 207411662,
        "sender_full_name": "lcnr",
        "timestamp": 1597845753
    },
    {
        "content": "<p>With a length in 0..=N elements for the last chunk I suppose</p>",
        "id": 207411737,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1597845794
    },
    {
        "content": "<p>Yeah I agree that Iterator::chunks would be the best, I was very conservative on only mirroring what <code>std::slice</code> was doing</p>",
        "id": 207411784,
        "sender_full_name": "traxys",
        "timestamp": 1597845820
    },
    {
        "content": "<p>it has to be an exact iterator, you can't return a partial array</p>",
        "id": 207411786,
        "sender_full_name": "simulacrum",
        "timestamp": 1597845821
    },
    {
        "content": "<p>yeah, probably with a method to consume the iter and return the final elements or something</p>",
        "id": 207411804,
        "sender_full_name": "lcnr",
        "timestamp": 1597845832
    },
    {
        "content": "<p>That is what <code>chunks_exact</code> does on slices yes</p>",
        "id": 207411895,
        "sender_full_name": "traxys",
        "timestamp": 1597845856
    },
    {
        "content": "<p>It's slightly more difficult here as we have to return a owned array</p>",
        "id": 207411989,
        "sender_full_name": "lcnr",
        "timestamp": 1597845900
    },
    {
        "content": "<p>and we don't have a nice way to support partially filled arrays in std</p>",
        "id": 207412036,
        "sender_full_name": "lcnr",
        "timestamp": 1597845919
    },
    {
        "content": "<p>Yeah I don't see how you would be able to know how many remains, the easiest way would be to allocate a Vec for the remaining</p>",
        "id": 207412085,
        "sender_full_name": "traxys",
        "timestamp": 1597845945
    },
    {
        "content": "<p>it does seem like the ideal is probably an arrayvec type</p>",
        "id": 207412099,
        "sender_full_name": "simulacrum",
        "timestamp": 1597845952
    },
    {
        "content": "<p>And about the allocations, that's already what <code>split_off</code> does on Vec, where slice::split* does only slice manipulations</p>",
        "id": 207412202,
        "sender_full_name": "traxys",
        "timestamp": 1597845984
    },
    {
        "content": "<p>I personnaly expect methods specific to vec that return elements in the front to allocate in some way</p>",
        "id": 207412294,
        "sender_full_name": "traxys",
        "timestamp": 1597846033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/122651-general/topic/chunks.20for.20Vec/near/207412099\">said</a>:</p>\n<blockquote>\n<p>it does seem like the ideal is probably an arrayvec type</p>\n</blockquote>\n<p>hmm yeah, I am not sure if we want that as part of std though, as it will remain fairly obscure. It might make more sense to convert the remaining elements into <code>array::IntoIter</code> and return that</p>",
        "id": 207412319,
        "sender_full_name": "lcnr",
        "timestamp": 1597846048
    },
    {
        "content": "<p>I mean array::IntoIter is like 85% of a arrayvec type :)</p>",
        "id": 207412365,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846077
    },
    {
        "content": "<p>true <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 207412429,
        "sender_full_name": "lcnr",
        "timestamp": 1597846085
    },
    {
        "content": "<p>but yes that seems fine</p>",
        "id": 207412436,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846089
    },
    {
        "content": "<p>So in conclusion it would be better to wait for const generics than to add a specific version for Vec ?</p>",
        "id": 207412622,
        "sender_full_name": "traxys",
        "timestamp": 1597846185
    },
    {
        "content": "<p>Const generics already works and can (probably) be used to implement this</p>",
        "id": 207412735,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1597846226
    },
    {
        "content": "<p>I personally think so, yes</p>\n<p>I want to stabilize <code>min_const_generics</code> before the 2021 edition so I don't even think that stabilizing a method on <code>Vec</code> will necessarily be faster than waiting for const generics here</p>",
        "id": 207412814,
        "sender_full_name": "lcnr",
        "timestamp": 1597846265
    },
    {
        "content": "<p>I don't think we want to stabilize something that needs to allocate every chunk separately anyway</p>",
        "id": 207412949,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846334
    },
    {
        "content": "<p>I would be interested in a chunks_exact on Iterator</p>",
        "id": 207412979,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846350
    },
    {
        "content": "<p>naming choices: we already have <code>array_chunks</code>, so I think we probably want to stick with that name here</p>",
        "id": 207413027,
        "sender_full_name": "lcnr",
        "timestamp": 1597846381
    },
    {
        "content": "<p>hm, we only chose that due to conflict with existing chunks_exact, right?</p>",
        "id": 207413071,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846409
    },
    {
        "content": "<p>I originally wanted to just use <code>iter.chunks</code> but I think that's confusing, so <code>array_chunks</code> is probably better for consistency</p>",
        "id": 207413086,
        "sender_full_name": "lcnr",
        "timestamp": 1597846419
    },
    {
        "content": "<p>hm <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> I find chunks_exact to not be too confusing, but I want the functionality more than the name :)</p>",
        "id": 207413241,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846473
    },
    {
        "content": "<p>i think <code>array_chunks</code> is more consistent here</p>",
        "id": 207413247,
        "sender_full_name": "lcnr",
        "timestamp": 1597846477
    },
    {
        "content": "<p>well my point is that we'd then deprecate and remove array::array_chunks</p>",
        "id": 207413354,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846527
    },
    {
        "content": "<p>with into_iter on arrays it becomes useless</p>",
        "id": 207413393,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846545
    },
    {
        "content": "<p>so we're not really being consistent with anything</p>",
        "id": 207413564,
        "sender_full_name": "simulacrum",
        "timestamp": 1597846636
    },
    {
        "content": "<p>You would have to do some <code>MaybeUninit</code> to implement that right ? because you have no way of knowing when the iterator is going to finish ?<br>\nSo for the remainder you would detect would had not filled the array, but what would you do ? you would pass that half-init array and the number of init elements to a custom Iterator impl ?</p>",
        "id": 207414052,
        "sender_full_name": "traxys",
        "timestamp": 1597846885
    },
    {
        "content": "<p>The remainder could probably converted to <code>array::IntoIter</code> and then used this way</p>",
        "id": 207414274,
        "sender_full_name": "lcnr",
        "timestamp": 1597846993
    },
    {
        "content": "<p>at least that's what I think is the best way</p>",
        "id": 207414299,
        "sender_full_name": "lcnr",
        "timestamp": 1597847010
    },
    {
        "content": "<blockquote>\n<p>well my point is that we'd then deprecate and remove array::array_chunks</p>\n</blockquote>\n<p>that's true, we could just use <code>arr.iter().chunked</code> for this and <code>arr.iter_mut().chunked</code> and remove <code>array_chunks</code></p>",
        "id": 207414468,
        "sender_full_name": "lcnr",
        "timestamp": 1597847083
    },
    {
        "content": "<p>As long as we don't get worse codegen from that this seems fine to me</p>",
        "id": 207414530,
        "sender_full_name": "lcnr",
        "timestamp": 1597847121
    },
    {
        "content": "<p><code>array_chunks</code> does have the advantage of allowing the user to access the remainder right from the start while <code>iter::Chunked</code> will only allow that once it is finished</p>",
        "id": 207414666,
        "sender_full_name": "lcnr",
        "timestamp": 1597847184
    },
    {
        "content": "<p>also, how deal <code>DoubleEndedIterator</code> work with <code>iter::Chunked</code>?</p>",
        "id": 207414726,
        "sender_full_name": "lcnr",
        "timestamp": 1597847216
    },
    {
        "content": "<p>we can have an impl for <code>ArrayChunks&lt;[T; N]&gt;</code> or something that provides slice and <code>into_rest() -&gt; array::IntoIter&lt;[T; N]&gt;</code> access to the remainder</p>",
        "id": 207414819,
        "sender_full_name": "simulacrum",
        "timestamp": 1597847272
    },
    {
        "content": "<p>not sure I follow, double ended iteration seems like it should work fine?</p>",
        "id": 207414890,
        "sender_full_name": "simulacrum",
        "timestamp": 1597847293
    },
    {
        "content": "<p>obviously you might end up with \"remainder\" being the middle or so</p>",
        "id": 207414914,
        "sender_full_name": "simulacrum",
        "timestamp": 1597847310
    },
    {
        "content": "<p>How would the <code>into_rest() -&gt; array::IntoIter&lt;[T; N]&gt;</code> work if you have more than <code>N</code> elements remaining ?</p>",
        "id": 207415220,
        "sender_full_name": "traxys",
        "timestamp": 1597847458
    },
    {
        "content": "<p>I would expect it to return an empty iterator</p>",
        "id": 207415431,
        "sender_full_name": "lcnr",
        "timestamp": 1597847563
    },
    {
        "content": "<p>would be nice to check that <code>into_rest</code> is only called once the iterator is empty as part of the typesystem</p>",
        "id": 207415457,
        "sender_full_name": "lcnr",
        "timestamp": 1597847578
    },
    {
        "content": "<p>but I don't think that's easily possible</p>",
        "id": 207415495,
        "sender_full_name": "lcnr",
        "timestamp": 1597847597
    },
    {
        "content": "<p>(for double iteration i'd say too the remainder should be in the middle,  though should inside a chunk for backwards order or not for back access ?)</p>",
        "id": 207415519,
        "sender_full_name": "traxys",
        "timestamp": 1597847611
    },
    {
        "content": "<p>You can return Option&lt;....&gt; to signify that ?</p>",
        "id": 207415551,
        "sender_full_name": "traxys",
        "timestamp": 1597847628
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"237671\">traxys</span> <a href=\"#narrow/stream/122651-general/topic/chunks.20for.20Vec/near/207415519\">said</a>:</p>\n<blockquote>\n<p>(for double iteration i'd say too the remainder should be in the middle,  though should inside a chunk for backwards order or not for back access ?)</p>\n</blockquote>\n<p>not sure what you mean here</p>",
        "id": 207415625,
        "sender_full_name": "lcnr",
        "timestamp": 1597847650
    },
    {
        "content": "<p>I think it would make the most sense to fill up the internal array \"backwards\" when using <code>next_back</code></p>",
        "id": 207415683,
        "sender_full_name": "lcnr",
        "timestamp": 1597847678
    },
    {
        "content": "<p>If you access the iterator from the back, say element <code>n</code> then <code>n-1</code> then <code>n-2</code> would you return<br>\n<code>[n, n-1, n-2, ...]</code> or <code>[n-k, n-(k+1), ... n -1, n]</code></p>",
        "id": 207415758,
        "sender_full_name": "traxys",
        "timestamp": 1597847724
    },
    {
        "content": "<p>I think <code>[n-k, n-(k+1), ... n -1, n]</code> is the \"correct\" choice here</p>",
        "id": 207415798,
        "sender_full_name": "lcnr",
        "timestamp": 1597847753
    },
    {
        "content": "<p>I think it's the least confusing yeah, but people would still asks themselves what is it I'd think</p>",
        "id": 207415929,
        "sender_full_name": "traxys",
        "timestamp": 1597847806
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> into_rest would consume the iterator, surely?</p>",
        "id": 207418661,
        "sender_full_name": "simulacrum",
        "timestamp": 1597849121
    },
    {
        "content": "<p>alternatively we'd have something like next_partial_chunk that gives you a (potentially) partial chunk, and always works</p>",
        "id": 207418708,
        "sender_full_name": "simulacrum",
        "timestamp": 1597849149
    },
    {
        "content": "<blockquote>\n<p>@lcnr into_rest would consume the iterator, surely?</p>\n</blockquote>\n<p>yeah I would expected it to</p>",
        "id": 207419232,
        "sender_full_name": "lcnr",
        "timestamp": 1597849389
    },
    {
        "content": "<p>Remainder can return a slice of the partial array, as a custom method can be borrowed (unlike <code>Iterator::next</code>). But this would only make sense once you've seen <code>None</code> to have read that far, unless we say that remainder also reads to end like last.</p>",
        "id": 207422894,
        "sender_full_name": "cuviper",
        "timestamp": 1597850989
    },
    {
        "content": "<p>I don't think <code>Iterator::chunks</code> is a replacement for <code>slice::array_chunks</code> though, as they're very different for borrowing</p>",
        "id": 207423567,
        "sender_full_name": "cuviper",
        "timestamp": 1597851292
    },
    {
        "content": "<p>e.g. <code>[&amp;T; 1_000_000]</code> vs <code>&amp;[T; 1_000_000]</code></p>",
        "id": 207423753,
        "sender_full_name": "cuviper",
        "timestamp": 1597851371
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> hm, that is an interesting point</p>",
        "id": 207432129,
        "sender_full_name": "simulacrum",
        "timestamp": 1597855590
    },
    {
        "content": "<p>hm actually I wonder, it seems like it would be valid to convert between those two types via ptr::read of each element, basically, right?</p>",
        "id": 207432321,
        "sender_full_name": "simulacrum",
        "timestamp": 1597855700
    },
    {
        "content": "<p>either way we'd need attached/streaming iterators so doesn't matter I guess</p>",
        "id": 207432376,
        "sender_full_name": "simulacrum",
        "timestamp": 1597855732
    },
    {
        "content": "<p>right, an <code>Iterator</code> adaptor can't invent an array reference, but <code>StreamingIterator</code> could</p>",
        "id": 207432574,
        "sender_full_name": "cuviper",
        "timestamp": 1597855819
    },
    {
        "content": "<p>I'm not sure how you mean to use <code>ptr::read</code></p>",
        "id": 207432585,
        "sender_full_name": "cuviper",
        "timestamp": 1597855827
    },
    {
        "content": "<p>FWIW, there's also <code>Itertools::chunks</code>, but that's a complicated beast with lazy grouping</p>",
        "id": 207432886,
        "sender_full_name": "cuviper",
        "timestamp": 1597855975
    },
    {
        "content": "<p><code>Itertools::tuples</code> is closer to what we want here</p>",
        "id": 207432925,
        "sender_full_name": "cuviper",
        "timestamp": 1597855994
    },
    {
        "content": "<p>(with homogenous tuples as a weak substitute for const-generic arrays)</p>",
        "id": 207433000,
        "sender_full_name": "cuviper",
        "timestamp": 1597856028
    },
    {
        "content": "<p>I mean that I <em>think</em> it is plausibly valid to go from <code>[&amp;T; N]</code> to <code>&amp;[T; N]</code>, copying out each element</p>",
        "id": 207433702,
        "sender_full_name": "simulacrum",
        "timestamp": 1597856370
    },
    {
        "content": "<p>Probably won't optimize away, but I've been surprised before</p>",
        "id": 207433814,
        "sender_full_name": "simulacrum",
        "timestamp": 1597856408
    },
    {
        "content": "<p>for <code>T: Copy</code>?</p>",
        "id": 207433862,
        "sender_full_name": "cuviper",
        "timestamp": 1597856434
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/122651-general/topic/chunks.20for.20Vec/near/207433702\">said</a>:</p>\n<blockquote>\n<p>I mean that I <em>think</em> it is plausibly valid to go from <code>[&amp;T; N]</code> to <code>&amp;[T; N]</code>, copying out each element</p>\n</blockquote>\n<p>I also thought so, but this breaks with interior mutability, doesn't it?</p>",
        "id": 207434224,
        "sender_full_name": "lcnr",
        "timestamp": 1597856583
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span> how so?</p>",
        "id": 207440861,
        "sender_full_name": "simulacrum",
        "timestamp": 1597859975
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138448\">@cuviper</span> no, in general. for T: Copy it is obviously true</p>",
        "id": 207440893,
        "sender_full_name": "simulacrum",
        "timestamp": 1597859987
    },
    {
        "content": "<p>for <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>'s point, I guess you need <code>T: Freeze</code></p>",
        "id": 207441057,
        "sender_full_name": "cuviper",
        "timestamp": 1597860072
    },
    {
        "content": "<p>If you have <code>[Cell&lt;u8&gt;] </code> and use <code>iter.chunks()</code> for this you have <code>[&amp;Cell(a)]</code> if you now copy this cell into a temporary array you have <code>&amp;[Cell(b)]</code>. We now mutate this copy. At this point the  original <code>Cell</code> still has the old value</p>",
        "id": 207441157,
        "sender_full_name": "lcnr",
        "timestamp": 1597860114
    },
    {
        "content": "<p>Right, and <code>Freeze</code> would exclude that type, but this is an internal-only trait</p>",
        "id": 207441346,
        "sender_full_name": "cuviper",
        "timestamp": 1597860185
    },
    {
        "content": "<p>Yeah</p>",
        "id": 207441360,
        "sender_full_name": "lcnr",
        "timestamp": 1597860191
    },
    {
        "content": "<p>I also think that this is dangerous with <code>Unpin</code> types</p>",
        "id": 207441380,
        "sender_full_name": "lcnr",
        "timestamp": 1597860203
    },
    {
        "content": "<p>as we could have a <code>Pin&lt;&amp;[UnpinTy]&gt;</code> which we can iterate over</p>",
        "id": 207441434,
        "sender_full_name": "lcnr",
        "timestamp": 1597860232
    },
    {
        "content": "<p>and then create a new copy of <code>UnpinTy</code> with a different address which is unsound</p>",
        "id": 207441509,
        "sender_full_name": "lcnr",
        "timestamp": 1597860255
    },
    {
        "content": "<p>aha, yeah, that's a good point</p>",
        "id": 207441519,
        "sender_full_name": "simulacrum",
        "timestamp": 1597860259
    },
    {
        "content": "<p>doesn't this also mess up the lifetime? who owns that array?</p>",
        "id": 207449231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597864246
    },
    {
        "content": "<p>if you copy out the element, you need at least <code>T: Clone</code>, even if in unsafe code, because the source <code>&amp;T</code>'s could be referenced elsewhere</p>",
        "id": 207449487,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597864389
    },
    {
        "content": "<p>that's why the array is referenced. Beyond pin and unsafecell this transform afaik is sound</p>",
        "id": 207449721,
        "sender_full_name": "simulacrum",
        "timestamp": 1597864511
    },
    {
        "content": "<p>well, \"who owns the array\" is still an issue for <code>Iterator</code></p>",
        "id": 207449775,
        "sender_full_name": "cuviper",
        "timestamp": 1597864545
    },
    {
        "content": "<p>I guess you'd transform independently, but you have to deal with that <code>[&amp;T; N]</code> value on your stack</p>",
        "id": 207449934,
        "sender_full_name": "cuviper",
        "timestamp": 1597864625
    },
    {
        "content": "<p>It sounds like you are creating a new array by copying <code>T</code>'s from different places to be all adjacent. This will be a local variable, and if your function's return type is <code>&amp;[T; N]</code> then you can't return it</p>",
        "id": 207449989,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597864656
    },
    {
        "content": "<p>yes, you'd need to stash it in a field of the struct. it's not insurmountable but definitely poses challenges</p>",
        "id": 207450114,
        "sender_full_name": "simulacrum",
        "timestamp": 1597864705
    },
    {
        "content": "<p>to me, this all says that <code>Iterator::chunks</code> and <code>slice::array_chunks</code> should co-exist</p>",
        "id": 207450144,
        "sender_full_name": "cuviper",
        "timestamp": 1597864722
    },
    {
        "content": "<p>that seems right, given this consideration</p>",
        "id": 207450160,
        "sender_full_name": "simulacrum",
        "timestamp": 1597864733
    },
    {
        "content": "<p>I'm still not exactly clear on what the type signature of <code>array_chunks</code> is</p>",
        "id": 207450202,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597864757
    },
    {
        "content": "<p>Well all this references would deny the usefullness of the method I'd say, as it won't return owned values</p>",
        "id": 207450206,
        "sender_full_name": "traxys",
        "timestamp": 1597864759
    },
    {
        "content": "<p>Iterator::chunks would have <code>Item = [T; N]</code> which is definitely useful</p>",
        "id": 207450242,
        "sender_full_name": "simulacrum",
        "timestamp": 1597864784
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.array_chunks\">https://doc.rust-lang.org/nightly/std/primitive.slice.html#method.array_chunks</a></p>",
        "id": 207450259,
        "sender_full_name": "cuviper",
        "timestamp": 1597864793
    },
    {
        "content": "<p>Ok, I had not understood</p>",
        "id": 207450309,
        "sender_full_name": "traxys",
        "timestamp": 1597864803
    },
    {
        "content": "<p>oh, this already exists? Which is the new one?</p>",
        "id": 207450368,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597864828
    },
    {
        "content": "<p>If we keep <code>slice::aray_chunks</code> I again prefer <code>array_chunks</code> as the name for the iterator <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 207450376,
        "sender_full_name": "lcnr",
        "timestamp": 1597864833
    },
    {
        "content": "<p>the benefit of array_chunks is that even by-reference iteration gives you <code>&amp;[T; N]</code> rather than <code>[&amp;T; N]</code></p>",
        "id": 207450380,
        "sender_full_name": "simulacrum",
        "timestamp": 1597864834
    },
    {
        "content": "<p>yeah naming is <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span> on my side :)</p>",
        "id": 207450405,
        "sender_full_name": "simulacrum",
        "timestamp": 1597864847
    },
    {
        "content": "<p>We want to add <code>Iterator::chunks_name_not_yet_finalized</code></p>",
        "id": 207450415,
        "sender_full_name": "lcnr",
        "timestamp": 1597864854
    },
    {
        "content": "<p>I'm really bad at naming</p>",
        "id": 207450434,
        "sender_full_name": "traxys",
        "timestamp": 1597864865
    },
    {
        "content": "<p>then let's just go with array_chunks <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 207450481,
        "sender_full_name": "lcnr",
        "timestamp": 1597864891
    },
    {
        "content": "<p>Why wouldn't we like <code>Iterator::chunks</code> ?</p>",
        "id": 207450654,
        "sender_full_name": "traxys",
        "timestamp": 1597864987
    },
    {
        "content": "<p>my concern is that both <code>slice::chunks</code> and <code>slice::array_chunks</code> already exist</p>",
        "id": 207450709,
        "sender_full_name": "lcnr",
        "timestamp": 1597865023
    },
    {
        "content": "<p>and this method would be a lot more similar to <code>array_chunks</code></p>",
        "id": 207450730,
        "sender_full_name": "lcnr",
        "timestamp": 1597865033
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"216206\">lcnr</span> <a href=\"#narrow/stream/122651-general/topic/chunks.20for.20Vec/near/207415457\">said</a>:</p>\n<blockquote>\n<p>would be nice to check that <code>into_rest</code> is only called once the iterator is empty as part of the typesystem</p>\n</blockquote>\n<p>aside: I see that <code>ArrayChunks::remainder</code> also says something along these lines. Why would this be desirable? What if you stop iterating early and want the remainder of the vector?</p>",
        "id": 207450829,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865064
    },
    {
        "content": "<p>I feel that most people don't know <code>array_chunks</code> where they would intutively understand <code>chunks</code></p>",
        "id": 207450833,
        "sender_full_name": "traxys",
        "timestamp": 1597865068
    },
    {
        "content": "<p>That would need allocations</p>",
        "id": 207450867,
        "sender_full_name": "traxys",
        "timestamp": 1597865085
    },
    {
        "content": "<p>it would also be polite not to create a collision with <code>Itertools::chunks</code></p>",
        "id": 207450870,
        "sender_full_name": "cuviper",
        "timestamp": 1597865086
    },
    {
        "content": "<p>Yeah true</p>",
        "id": 207450880,
        "sender_full_name": "traxys",
        "timestamp": 1597865096
    },
    {
        "content": "<p>yeah, array_chunks seems all around fine -- it'll still show up in search and whatnot.</p>\n<p>Note that this will not need allocation</p>",
        "id": 207450910,
        "sender_full_name": "simulacrum",
        "timestamp": 1597865113
    },
    {
        "content": "<p>We need allocations if we want to return remainder if <code>remainder.len() &gt; N</code></p>",
        "id": 207451002,
        "sender_full_name": "traxys",
        "timestamp": 1597865156
    },
    {
        "content": "<p>but it's still in the original allocation</p>",
        "id": 207451062,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865178
    },
    {
        "content": "<p>yeah we probably wouldn't ever support that, it'd be a pain because the impl must be in core not alloc and then you don't have vec etc</p>",
        "id": 207451124,
        "sender_full_name": "simulacrum",
        "timestamp": 1597865221
    },
    {
        "content": "<p><code>slice::array_chunks</code>, at least, operates on a slice. I don't see how it is any different from repeated <code>split_at</code></p>",
        "id": 207451182,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865250
    },
    {
        "content": "<p>but we can of course provide something like <code>Result&lt;Remainder&lt;T, N&gt;, impl Iterator&lt;Item = T&gt;&gt;</code></p>",
        "id": 207451189,
        "sender_full_name": "simulacrum",
        "timestamp": 1597865255
    },
    {
        "content": "<p>Ah but we are not talking about <code>Vec</code> anymore</p>",
        "id": 207451206,
        "sender_full_name": "traxys",
        "timestamp": 1597865268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> it returns arrays, rather than slices</p>",
        "id": 207451207,
        "sender_full_name": "simulacrum",
        "timestamp": 1597865268
    },
    {
        "content": "<p>there are two possibilities for \"remainder\"</p>\n<ul>\n<li>we read &lt;N items at the end, so here they are</li>\n<li>you want whatever the internal iterator has left, could be &gt;N</li>\n</ul>",
        "id": 207451259,
        "sender_full_name": "cuviper",
        "timestamp": 1597865285
    },
    {
        "content": "<p>We are talking about a generic <code>Iterator::array_chunk</code> that coalesces items from an Iterator into <code>[T; N]</code></p>",
        "id": 207451326,
        "sender_full_name": "traxys",
        "timestamp": 1597865321
    },
    {
        "content": "<p>Yeah the second is easy to support, just give back the wrapped iterator</p>",
        "id": 207451350,
        "sender_full_name": "traxys",
        "timestamp": 1597865335
    },
    {
        "content": "<p>well yes, you need unsafe magic to make that coercion work, so I see why <code>array_chunks</code> exists from a type signature point of view. But If you do repeated <code>split_at</code> then it is easy to support a \"remainder\" function returning whatever is left of the original slice</p>",
        "id": 207451355,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865337
    },
    {
        "content": "<p><code>split_at</code> is a slice thing, not for generic <code>Iterator</code>, so let's keep that separate</p>",
        "id": 207451436,
        "sender_full_name": "cuviper",
        "timestamp": 1597865386
    },
    {
        "content": "<p>aha, so that's what's new here</p>",
        "id": 207451451,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865398
    },
    {
        "content": "<p>(<code>slice::array_chunks</code> does the remainder already)</p>",
        "id": 207451461,
        "sender_full_name": "cuviper",
        "timestamp": 1597865402
    },
    {
        "content": "<p>If you are working over a <code>Vec</code>, then you don't have to do any gathering</p>",
        "id": 207451683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865510
    },
    {
        "content": "<p>For supporting the first i'd say some function along the lines of <code>Self::remainder(self) -&gt; Result&lt;array::IntoIter, Self&gt;</code>, that returns <code>Err(self)</code> if the iter has not yet finished, and <code>array::IntoIter</code> if it has finished</p>",
        "id": 207451855,
        "sender_full_name": "traxys",
        "timestamp": 1597865584
    },
    {
        "content": "<p>so you could have an iterator over the vec that does repeated <code>split_at_mut</code> from an <code>OwningRef&lt;Box&lt;[T]&gt;, [T]&gt;</code> to get a non-allocating vec version of <code>slice::array_chunks</code></p>",
        "id": 207451898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865608
    },
    {
        "content": "<p>Maybe not a <code>Result</code>, more something like <code>enum Remainder { Finished(....), NotFinshed(...)}</code></p>",
        "id": 207451983,
        "sender_full_name": "traxys",
        "timestamp": 1597865650
    },
    {
        "content": "<p>It's a much different conversation if we're only doing this on <code>Vec</code> and/or owned arrays as the source</p>",
        "id": 207452057,
        "sender_full_name": "cuviper",
        "timestamp": 1597865686
    },
    {
        "content": "<p>I agree, but according to <span class=\"user-mention\" data-user-id=\"216206\">@lcnr</span>  we can do it for <code>Iterator</code> with const-generics, and I agree that it's much better to have a generic impl than the one with Vec</p>",
        "id": 207452210,
        "sender_full_name": "traxys",
        "timestamp": 1597865768
    },
    {
        "content": "<p>(By that I mean it will be as long to stabilize the generic impl as the Vec one)</p>",
        "id": 207452319,
        "sender_full_name": "traxys",
        "timestamp": 1597865839
    },
    {
        "content": "<p>(sorry to be slow to the point) Regarding the version that polls an <code>Iterator&lt;Item=T&gt;</code> to return <code>[T; N]</code>, won't this be pretty move-heavy? <code>[T; N]</code> is a big type to wrap in an option</p>",
        "id": 207452373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865874
    },
    {
        "content": "<p>I'm in favor of doing something for all <code>Iterator</code></p>",
        "id": 207452457,
        "sender_full_name": "cuviper",
        "timestamp": 1597865898
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> you have the same \"big type\" consideration if you've moving arrays from a <code>Vec</code> too</p>",
        "id": 207452501,
        "sender_full_name": "cuviper",
        "timestamp": 1597865932
    },
    {
        "content": "<p>indeed, I don't know how these functions could ever be used well. You just have to hope they get optimized away</p>",
        "id": 207452566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597865979
    },
    {
        "content": "<p>just don't use them for big <code>N</code></p>",
        "id": 207452588,
        "sender_full_name": "cuviper",
        "timestamp": 1597865994
    },
    {
        "content": "<p>I would probably use this in places where I currently use <code>Itertools::tuples</code>, which only goes up to 4 anyway</p>",
        "id": 207452730,
        "sender_full_name": "cuviper",
        "timestamp": 1597866065
    },
    {
        "content": "<p>We could provide both an array version and a <code>Box&lt;[T]&gt;</code> version though ?</p>",
        "id": 207452787,
        "sender_full_name": "traxys",
        "timestamp": 1597866108
    },
    {
        "content": "<p>For cases where you have big <code>T</code> or chunk_size ?</p>",
        "id": 207452855,
        "sender_full_name": "traxys",
        "timestamp": 1597866130
    },
    {
        "content": "<p>(Where the Boxed would need quite a lot of allocations, but it's your choice)</p>",
        "id": 207452884,
        "sender_full_name": "traxys",
        "timestamp": 1597866156
    },
    {
        "content": "<p>or <code>Box&lt;[T; N]&gt;</code>, sure if you're willing to allocate for each</p>",
        "id": 207452894,
        "sender_full_name": "cuviper",
        "timestamp": 1597866160
    },
    {
        "content": "<p>that's only possible from <code>Vec</code> though -- array and <code>Iterator</code> are defined in <code>core</code></p>",
        "id": 207453071,
        "sender_full_name": "cuviper",
        "timestamp": 1597866251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/122651-general/topic/chunks.20for.20Vec/near/207453071\">said</a>:</p>\n<blockquote>\n<p>that's only possible from <code>Vec</code> though -- array and <code>Iterator</code> are defined in <code>core</code></p>\n</blockquote>\n<p>std is special, so while we can't do this for iterator we can implement stuff for arrays in std</p>",
        "id": 207453165,
        "sender_full_name": "lcnr",
        "timestamp": 1597866314
    },
    {
        "content": "<p><em>array is defined in the compiler not in core</em></p>",
        "id": 207453208,
        "sender_full_name": "lcnr",
        "timestamp": 1597866352
    },
    {
        "content": "<p>true, there could be an <code>array_alloc</code> lang item, like the existing <code>slice_alloc</code></p>",
        "id": 207453489,
        "sender_full_name": "cuviper",
        "timestamp": 1597866510
    },
    {
        "content": "<p>If people are intersted, here is what could an impl look like: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=af8bef8b27fdc701a2ac55712ea4965e\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=af8bef8b27fdc701a2ac55712ea4965e</a></p>",
        "id": 207456608,
        "sender_full_name": "traxys",
        "timestamp": 1597868131
    },
    {
        "content": "<p>Why did you use <code>transmute_copy</code> + <code>forget</code> instead of <code>transmute</code>?</p>",
        "id": 207458483,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597869196
    },
    {
        "content": "<p>You should be able to do this with only one bit-copy from <code>buffer</code> to the return slot</p>",
        "id": 207458649,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597869296
    },
    {
        "content": "<p><code>transmute</code> isn't supported for <code>[MaybeUninit&lt;T&gt;; N] -&gt; [T; N]</code> yet, so any case where <code>transmute</code> would make sense has to have <code>transmute_copy</code> for now</p>",
        "id": 207458684,
        "sender_full_name": "jknodt",
        "timestamp": 1597869329
    },
    {
        "content": "<p>I thought <code>transmute</code> could handle any types?</p>",
        "id": 207458777,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597869373
    },
    {
        "content": "<p>oh, I see, it's a rustc implementation issue</p>",
        "id": 207458891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597869480
    },
    {
        "content": "<p>is it possible to just call <code>memcpy</code> directly?</p>",
        "id": 207458957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597869514
    },
    {
        "content": "<p><code>transmute_copy</code> will do that</p>",
        "id": 207459003,
        "sender_full_name": "cuviper",
        "timestamp": 1597869547
    },
    {
        "content": "<p>or is the point that as long as you write <code>transmute_copy</code> llvm can pick up on the pattern</p>",
        "id": 207459018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597869560
    },
    {
        "content": "<p>I stole that idea from the <code>array::IntoIter::new</code> impl but it's more expensive that that, because it will be called repeatedly. Maybe the copy will be optimized away ?</p>",
        "id": 207498758,
        "sender_full_name": "traxys",
        "timestamp": 1597911326
    }
]