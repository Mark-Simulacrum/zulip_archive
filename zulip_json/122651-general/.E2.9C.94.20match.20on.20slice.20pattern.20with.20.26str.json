[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"368654\">AstOhm</span> has marked this topic as resolved.</p>",
        "id": 262317304,
        "sender_full_name": "Notification Bot",
        "timestamp": 1637587295
    },
    {
        "content": "<p>If the range is <code>A</code> to <code>Z</code> and you return <code>0</code> as default, this can be done with much fewer instructions (three plus constant generation):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">opt2</span><span class=\"p\">(</span><span class=\"n\">v</span>: <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0x659e00001dd77f4</span><span class=\"k\">u64</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">63</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">&gt;&gt;=</span><span class=\"w\"> </span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">63</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 262424449,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1637655498
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"437892\">@Falk Hüffner</span> Interesting approach. A double-shift-LUT. Mind elaborating how you derived the result and why it cannot set the default to 1?</p>",
        "id": 262483258,
        "sender_full_name": "Sofia",
        "timestamp": 1637686909
    },
    {
        "content": "<p>The <code>v &amp; 63</code> aligning the A-Z to 1-26 is a nice observation there. If you make that <code>v &amp; 0x1f</code>, it becomes case insensitive. If we range only A-Za-z, this is perfect. But this mask has a cost, unlike the <code>&amp; 63</code>.</p>",
        "id": 262484061,
        "sender_full_name": "Sofia",
        "timestamp": 1637687255
    },
    {
        "content": "<p>I used my superoptimizer which is based on z3 (<a href=\"https://github.com/falk-hueffner/sematrope\">https://github.com/falk-hueffner/sematrope</a>) plus some playing around. It doesn't work with 1 because, intuitively, producing 0 is easier in that it can be achieved with either a large shift count or long stretches of zeroes in the input (and more precisely because z3 does not find any 64 bit constant that would work).</p>",
        "id": 262484188,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1637687299
    },
    {
        "content": "<p>Ah a solver, nice cheat. :D</p>",
        "id": 262484280,
        "sender_full_name": "Sofia",
        "timestamp": 1637687351
    },
    {
        "content": "<p>TODO: play with z3. :)</p>",
        "id": 262484372,
        "sender_full_name": "Sofia",
        "timestamp": 1637687397
    },
    {
        "content": "<p>You did try with signed right shift, yes?</p>",
        "id": 262485060,
        "sender_full_name": "Sofia",
        "timestamp": 1637687719
    },
    {
        "content": "<p>Guess that wouldn't really help due to the rest of the ones being unwanted. Nice result either way. I wonder how efficient a dedicated derivation tool could be.</p>",
        "id": 262487940,
        "sender_full_name": "Sofia",
        "timestamp": 1637688913
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"437892\">@Falk Hüffner</span> Huh. Looking at the assembly, I see the costs of building your larger LUT outweigh it, so at least instruction count-wise you only save one instruction because it is case sensitive. If you replace the 63 with 0x1f, then you get the same number of instructions. (But I won't benchmark them or compare the dataflows)</p>\n<p><a href=\"https://godbolt.org/z/qqGeWYvW5\">https://godbolt.org/z/qqGeWYvW5</a></p>\n<p>Your larger LUT would win at least if we called the function multiple times and could reuse the constant stored in registers. Could probably also save more instructions by using more registers to construct the constant.</p>",
        "id": 262489698,
        "sender_full_name": "Sofia",
        "timestamp": 1637689605
    },
    {
        "content": "<p>Which would in turn yield better performance, especially on optimized cores.</p>",
        "id": 262489968,
        "sender_full_name": "Sofia",
        "timestamp": 1637689712
    },
    {
        "content": "<p>At least normally when optimizing match cases like this; we have low enum variant numbers. Not 26 cases. So would have a lot more freedom.</p>\n<p>Another trick I recently used, with a nice emergent (ironic?) relationship. The rotation of a u8 describing the 4-point unit circle, rotates the circle. <code>0b11100100u8.rotate_right(2)</code> where the low 2 bits describe the current direction.</p>",
        "id": 262491882,
        "sender_full_name": "Sofia",
        "timestamp": 1637690509
    },
    {
        "content": "<p>It seems generating constants is just super inefficient on RISC-V with clang (7 instructions??). Gcc just loads it from memory...</p>",
        "id": 262492137,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1637690620
    },
    {
        "content": "<p>Ah, yes, gcc does that. Probably better for real world hardware.</p>",
        "id": 262492755,
        "sender_full_name": "Sofia",
        "timestamp": 1637690916
    },
    {
        "content": "<p>After analyzing your solution. I'm pretty sure you can take the approach to a 32-bit constant. Might try to handwrite a constant tomorrow. o/</p>",
        "id": 262493112,
        "sender_full_name": "Sofia",
        "timestamp": 1637691112
    },
    {
        "content": "<p>It would be quite interesting to find a non-solver based way of finding constant for various mappings, but it seems hard... Please let me know if you find anything :-)</p>",
        "id": 262493663,
        "sender_full_name": "Falk Hüffner",
        "timestamp": 1637691395
    },
    {
        "content": "<p>Likewise :D</p>",
        "id": 262494583,
        "sender_full_name": "Sofia",
        "timestamp": 1637691873
    }
]