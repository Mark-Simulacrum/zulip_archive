[
    {
        "content": "<p>When the <code>target_feature(enable=\"fma\")</code> is not enabled the code gen from <code>mul_add</code> is less than adequate.<br>\nThis issue is present on both scalar(e.g. <code>f32</code>) and <code>Simd::mul_add</code>.</p>",
        "id": 274077715,
        "sender_full_name": "Jonathan",
        "timestamp": 1646366615
    },
    {
        "content": "<p>That just came up in this week's library team meeting.</p>",
        "id": 274077732,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646366640
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"457304\">Jonathan</span> <a href=\"#narrow/stream/122651-general/topic/Effect.20of.20fma.20disabled/near/274077715\">said</a>:</p>\n<blockquote>\n<p>When the <code>target_feature(enable=\"fma\")</code> is not enabled the code gen from <code>mul_add</code> is less than adequate.<br>\nThis issue is present on both scalar(e.g. <code>f32</code>) and <code>Simd::mul_add</code>.</p>\n</blockquote>\n<p>What would be your preferred codegen result, btw? Or rather...<br>\nI <strong>know</strong> it's bad, having done an extensive study of it myself, but what were you expecting the compiler to emit?</p>",
        "id": 274078596,
        "sender_full_name": "Jubilee",
        "timestamp": 1646367594
    },
    {
        "content": "<p>I was expecting the compiler to emit <code>mulss</code> and <code>addss</code> as if the compiler instead saw <code>(a * b) + c</code>.<br>\nwherever I use <code>mul_add</code> I end up having to use a <code>cfg!</code> macro like such:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"fm\">cfg!</span><span class=\"p\">(</span><span class=\"n\">target_feature</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"fma\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">mul_add</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>With a drop in replacement like this it produces predictable results and decent code gen.</p>",
        "id": 274078841,
        "sender_full_name": "Jonathan",
        "timestamp": 1646367855
    },
    {
        "content": "<p><em>nods</em></p>",
        "id": 274079055,
        "sender_full_name": "Jubilee",
        "timestamp": 1646368086
    },
    {
        "content": "<p>yeah ive done this a ton too. i pretty much never want mul_add to call libm::fmaf or whatever.</p>",
        "id": 274155460,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646412242
    },
    {
        "content": "<p>running an extremely informal poll here: <a href=\"https://twitter.com/workingjubilee/status/1499804915438215168\">https://twitter.com/workingjubilee/status/1499804915438215168</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/workingjubilee/status/1499804915438215168\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/b918d32b7ab0e274b678c4f5dfa1cb06074b0d52/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313335393238383834383733323138303438342f52675f333955665f5f6e6f726d616c2e6a7067\"></a><p>If you use Rust's f32::mul_add, do you expect the codegen to look like (in the absence of a known hardware FMA instruction):</p><span>- hyperðŸ’‰ðŸ’‰ðŸ’‰jubilee (@workingjubilee)</span></div></div>",
        "id": 274168845,
        "sender_full_name": "Jubilee",
        "timestamp": 1646418173
    },
    {
        "content": "<p>I'm not sure if people understand that it'll give different results? If you want the precision of mul_add you need the complex slow version, if you want the gotta go fast aspect, it'd be better not to compile at all and you can do the dynamic dispatch fast fma path yourself.</p>",
        "id": 274174764,
        "sender_full_name": "Josh Simmons",
        "timestamp": 1646420739
    },
    {
        "content": "<p>I actually think that people do understand that it is results-changing, I just think people expect the function itself to be \"allow this result-changing operation\".</p>",
        "id": 274175176,
        "sender_full_name": "Jubilee",
        "timestamp": 1646420952
    },
    {
        "content": "<p>time for a <code>f32::mul_add_yolo()</code> :')</p>\n<p>my argument would be that it's easy to fix a performance problem where all your multiplies are suddenly calling into libc, but hard to track down a correctness issue where some platforms subtly break the guarantees. (because either way <em>somebody</em> is going to want the other version)</p>",
        "id": 274175488,
        "sender_full_name": "Josh Simmons",
        "timestamp": 1646421093
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330867\">Josh Simmons</span> <a href=\"#narrow/stream/122651-general/topic/Effect.20of.20fma.20disabled/near/274175488\">said</a>:</p>\n<blockquote>\n<p>time for a <code>f32::mul_add_yolo()</code> :')</p>\n</blockquote>\n<p>I think this is especially the better answer because <code>mul_add</code> is <em>documented</em> today to be only one rounding, and thus it's entirely reasonable for someone to be relying on that fact.  That that's the case regardless of how many people would prefer the yolo semantics.</p>\n<p>If it wasn't then maybe we could get away with it, but even then I think the default being strict is the right answer.  The same way we have <code>sort</code> (stable) and <code>sort_unstable</code>, rather than the C++ way of <code>stable_sort</code> and <code>sort</code> (unstable), regardless of how often people want a stable sort.</p>\n<p>I'm also not certain that the function call is the right way to express the goal.  I feel like someone wanting that would also want operations to <code>contract</code> in other scenarios, so a type where the optimizer just does it for <code>a * b + c</code> <em>without</em> needing to write the method might be the better answer.  (The same way people might want reassociation in <code>Iterator::sum</code> some times.)</p>",
        "id": 274177253,
        "sender_full_name": "scottmcm",
        "timestamp": 1646422021
    },
    {
        "content": "<p>tbh, I think we should have both <code>fma</code> with the \"always 1 rounding\" and <code>mul_add</code> with the \"1 or 2 roundings\" semantics for the same reason LLVM has <code>fma</code> and <code>fmuladd</code> with those semantics, and historically Rust trying to fight the common name intuition has gone extremely poorly. :^)</p>\n<p>The docs are probably wrong to call it more accurate, though. It's more precise, which is not the same.</p>\n<p><code>mul_add_fast</code> doesn't work if the semantics are cfg-time because it's not actually faster to do a mul then add if FMA would be faster, and dynamic dispatch is not necessarily faster on the first few calls.</p>\n<p>I have actually seen quite a few programmers who have done extensive professional work writing math algorithms expect <code>mul_add</code> to mean something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"fm\">cfg!</span><span class=\"p\">(</span><span class=\"n\">target_feature</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"fma\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">mul_add</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274179331,
        "sender_full_name": "Jubilee",
        "timestamp": 1646423030
    },
    {
        "content": "<p>There's another thing, which is that fma instructions aren't necessarily any faster than regular mul + add anyway, it depends on the actual workload and uarch whether the latency penalty is worth the better throughput. So I'm not really sure how valuable the yolo fma is if you're not doing a higher level feature / cpu dispatch.</p>",
        "id": 274179691,
        "sender_full_name": "Josh Simmons",
        "timestamp": 1646423202
    },
    {
        "content": "<p>I think we can at least trust LLVM to do an okay job of isel, but yes, I feel really reluctant to attach a speed-related claim to anything.</p>",
        "id": 274179802,
        "sender_full_name": "Jubilee",
        "timestamp": 1646423277
    },
    {
        "content": "<p>IDK that this is a <em>good</em> api (its actually pretty jank IMO, altho it's growing on me), but do const generic defaults work for stuff like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">mul_add</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ROUNDING</span>: <span class=\"nc\">MulAddRounding</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MulAddRounding</span>::<span class=\"n\">Strict</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274183980,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646425417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> is this laughable or nah?</p>",
        "id": 274184572,
        "sender_full_name": "Jubilee",
        "timestamp": 1646425753
    },
    {
        "content": "<p>But like, <a href=\"https://docs.julialang.org/en/v1/base/math/#Base.fma\">https://docs.julialang.org/en/v1/base/math/#Base.fma</a><br>\n<a href=\"https://docs.julialang.org/en/v1/base/math/#Base.muladd\">https://docs.julialang.org/en/v1/base/math/#Base.muladd</a><br>\nIt's extremely bad to have the wrong name on a function everyone else agrees on the behavior of, tbh.</p>",
        "id": 274185236,
        "sender_full_name": "Jubilee",
        "timestamp": 1646426159
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/122651-general/topic/Effect.20of.20fma.20disabled/near/274183980\">said</a>:</p>\n<blockquote>\n<p>IDK that this is a <em>good</em> api (its actually pretty jank IMO, altho it's growing on me), but do const generic defaults work for stuff like</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">mul_add</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ROUNDING</span>: <span class=\"nc\">MulAddRounding</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MulAddRounding</span>::<span class=\"n\">Strict</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>no and neither do type defaults work in fns</p>",
        "id": 274185630,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1646426387
    },
    {
        "content": "<p><em>nods</em></p>",
        "id": 274185891,
        "sender_full_name": "Jubilee",
        "timestamp": 1646426550
    },
    {
        "content": "<p>swhat I thought.</p>",
        "id": 274185899,
        "sender_full_name": "Jubilee",
        "timestamp": 1646426558
    },
    {
        "content": "<p>imho if we're thinking of relaxing the guarantees of <code>mul_add</code>, we should instead replace <code>mul_add</code> with <code>fma</code> for accuracy and <code>mul_add_fast</code> (or similar) for speed, and just deprecate <code>mul_add</code>.</p>",
        "id": 274192498,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646430181
    },
    {
        "content": "<p>It's not obvious to me that we should not have <code>mul_add</code> refer to one or the other of those.</p>",
        "id": 274192786,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646430339
    },
    {
        "content": "<p>it would be fma, but deprecated because of the confusing naming. imho having mul_add be the fast variant is a breaking change that we shouldn't have, and would break some of my code (simple-soft-float's tests iirc), probably a bunch of other people's code too</p>",
        "id": 274197408,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646433054
    },
    {
        "content": "<p><em>clearly going utterly mad</em> change it over an edition!</p>",
        "id": 274197620,
        "sender_full_name": "Jubilee",
        "timestamp": 1646433211
    },
    {
        "content": "<p>have two symbols and</p>",
        "id": 274197646,
        "sender_full_name": "Jubilee",
        "timestamp": 1646433232
    },
    {
        "content": "<p>oh hey, <a href=\"https://github.com/rust-lang/rfcs/pull/3240\">https://github.com/rust-lang/rfcs/pull/3240</a></p>",
        "id": 274198736,
        "sender_full_name": "Jubilee",
        "timestamp": 1646433882
    },
    {
        "content": "<p>Symbol versioning is <em>fun</em>.</p>",
        "id": 274199133,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646434124
    },
    {
        "content": "<blockquote>\n<p><em>clearly going utterly mad</em> change it over an edition!</p>\n</blockquote>\n<p>that's not such a bad idea imho...Rust should gain a way to do something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">fma</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">factor</span>: <span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">term</span>: <span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">llvm_fma</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">factor</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">mul_add</span><span class=\"cp\">$</span><span class=\"mi\">2021</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">factor</span>: <span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">term</span>: <span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">fma</span><span class=\"p\">(</span><span class=\"n\">factor</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">mul_add</span><span class=\"cp\">$</span><span class=\"mi\">2024</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">factor</span>: <span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">term</span>: <span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">llvm_mul_add_f64</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">factor</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">term</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>when you access a symbol without specifying which edition to use, rust just picks the nearest option.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// in edition 2015, 2018, and 2021</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FMA</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f64</span>::<span class=\"n\">mul_add</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// in edition 2024 and later</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LLVM_MUL_ADD</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f64</span>::<span class=\"n\">mul_add</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// any edition</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">FMA</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f64</span>::<span class=\"n\">mul_add</span><span class=\"cp\">$</span><span class=\"mi\">2021</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// any edition</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">LLVM_MUL_ADD</span>: <span class=\"nc\">fn</span><span class=\"p\">(</span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">f64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">f64</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">f64</span>::<span class=\"n\">mul_add</span><span class=\"cp\">$</span><span class=\"mi\">2024</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274199236,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646434183
    },
    {
        "content": "<p>this is one of the listed rationales for reserving prefixed identifiers: instead of <code>mul_add$2021</code> we can do <code>e2021#mul_add</code></p>",
        "id": 274201250,
        "sender_full_name": "bstrie",
        "timestamp": 1646435371
    },
    {
        "content": "<p>extremely cute.</p>",
        "id": 274201707,
        "sender_full_name": "Jubilee",
        "timestamp": 1646435633
    },
    {
        "content": "<p>see also the C++ <code>abi_tag</code>, <a href=\"https://developers.redhat.com/blog/2015/02/05/gcc5-and-the-c11-abi\">https://developers.redhat.com/blog/2015/02/05/gcc5-and-the-c11-abi</a></p>",
        "id": 274201892,
        "sender_full_name": "cuviper",
        "timestamp": 1646435753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256342\">bstrie</span> <a href=\"#narrow/stream/122651-general/topic/Effect.20of.20fma.20disabled/near/274201250\">said</a>:</p>\n<blockquote>\n<p>this is one of the listed rationales for reserving prefixed identifiers: instead of <code>mul_add$2021</code> we can do <code>e2021#mul_add</code></p>\n</blockquote>\n<p>ah, yeah, i forgot that.</p>",
        "id": 274202406,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646436068
    },
    {
        "content": "<p>I might be misunderstanding the problem here but I don't think the feature proposed in <a href=\"https://github.com/rust-lang/rfcs/pull/3240\">https://github.com/rust-lang/rfcs/pull/3240</a> would help with an edition based change of behavior for <code>mul_add</code>. It's only meant to affect inference to add one edition based fallback not change method dispatch in general across editions.</p>",
        "id": 274202467,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1646436121
    },
    {
        "content": "<p>The edition based case it allows to compile in the edition a method is introduced in would only go so far as to become a hard error in the next edition, not change the method being selected.</p>",
        "id": 274202545,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1646436156
    },
    {
        "content": "<p>I know, I am just amused to observe it at the same time.</p>",
        "id": 274203134,
        "sender_full_name": "Jubilee",
        "timestamp": 1646436530
    },
    {
        "content": "<p>I don't think a \"fast\" version of <code>mul_add</code> implemented by itself would be worth it tbh since it wouldn't be fast at all (at least not for scalar). I like the idea of a generic implementation that Thom suggested since the semantics can be adjusted without breaking backwards compatibility.</p>",
        "id": 274220526,
        "sender_full_name": "Jonathan",
        "timestamp": 1646456579
    },
    {
        "content": "<p>doesn't really work.</p>",
        "id": 274267413,
        "sender_full_name": "Jubilee",
        "timestamp": 1646517877
    },
    {
        "content": "<p>I did say the poll is unscientific but I feel like I should note its results anyways: <br>\npeople really do expect it to be \"mul, then add\".<br>\n<a href=\"https://twitter.com/workingjubilee/status/1499804915438215168\">https://twitter.com/workingjubilee/status/1499804915438215168</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/workingjubilee/status/1499804915438215168\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/b918d32b7ab0e274b678c4f5dfa1cb06074b0d52/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313335393238383834383733323138303438342f52675f333955665f5f6e6f726d616c2e6a7067\"></a><p>If you use Rust's f32::mul_add, do you expect the codegen to look like (in the absence of a known hardware FMA instruction):</p><span>- hyperðŸ’‰ðŸ’‰ðŸ’‰jubilee (@workingjubilee)</span></div></div>",
        "id": 274591297,
        "sender_full_name": "Jubilee",
        "timestamp": 1646766865
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/122651-general/topic/Effect.20of.20fma.20disabled/near/274183980\">said</a>:</p>\n<blockquote>\n<p>IDK that this is a <em>good</em> api (its actually pretty jank IMO, altho it's growing on me), but do const generic defaults work for stuff like</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">mul_add</span><span class=\"o\">&lt;</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">ROUNDING</span>: <span class=\"nc\">MulAddRounding</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MulAddRounding</span>::<span class=\"n\">Strict</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>I personally would rather have default/named arguments instead of this. This probably makes inference harder, but I can't think of an example rn.</p>",
        "id": 275191203,
        "sender_full_name": "fee1-dead",
        "timestamp": 1647229327
    },
    {
        "content": "<p>It's definitely a way to hack around the lack of default arguments. Thing is, default arguments seem like a harder sell given that we already have default generic parameters &gt;_&gt;.</p>",
        "id": 275264265,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1647276280
    }
]