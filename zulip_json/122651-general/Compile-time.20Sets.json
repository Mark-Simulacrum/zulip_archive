[
    {
        "content": "<p>Hey has anyone ever had any luck with trying to hack together sets at compile time on stable? I have a procedural derive macro that essentially associates a unique identifier with a field in a struct and creates a list of those identifiers at compile time. I want to cause a compile error in the generated code if that list contains duplicates. I got this partially working with match (see below), but using a lint to cause the error won't work for derive macros.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[derive(PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"n\">A</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">B</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"n\">B</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">C</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"n\">C</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">foo</span>: <span class=\"nc\">Foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[forbid(unreachable_patterns)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208834608,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599057864
    },
    {
        "content": "<p>If <code>Foo</code> is not Copy, you can move out of a variable with mem::drop or something and that'll only work once</p>",
        "id": 208835717,
        "sender_full_name": "simulacrum",
        "timestamp": 1599058319
    },
    {
        "content": "<p>I think with shadowing and type annotations you could build a general solution too, but not sure</p>",
        "id": 208835824,
        "sender_full_name": "simulacrum",
        "timestamp": 1599058355
    },
    {
        "content": "<p>Maybe easiest is to declare a struct with those names as fields, and then you'll get an error</p>",
        "id": 208835879,
        "sender_full_name": "simulacrum",
        "timestamp": 1599058375
    },
    {
        "content": "<p>You've seen <a href=\"https://crates.io/crates/phf\">https://crates.io/crates/phf</a> I assume?</p>",
        "id": 208836514,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1599058591
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Declaring a struct and using the names is quite clever, I'll remember that.  Though in my case it's not enough, I need ensure the value not just the name is unique.</p>\n<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> I hadn't actually since like 2015 when it was really hard to use, I'll try it again though as it looks way easier to use. Thanks!</p>\n<p>I also quickly tried to see if I could make a <code>const fn</code> to check but unfortunately it's stopped by <code>PartialEq</code> not be available.</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">is_unique</span><span class=\"p\">(</span><span class=\"n\">set</span>: <span class=\"kp\">&amp;</span><span class=\"p\">[</span><span class=\"n\">Foo</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">needle</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">set</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"n\">set</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">needle</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">set</span><span class=\"p\">[</span><span class=\"n\">after</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"n\">after</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"n\">index</span><span class=\"w\"> </span><span class=\"o\">+=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kc\">true</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208841128,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599060187
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> Seems like phf won't work as it requires you to use a primitive type and I'm using a struct as my key.</p>",
        "id": 208845839,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599061853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219696\">@XAMPPRocky</span> <br>\nYou can compare it for equality like this:<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=068f77d25d2b6b81d4094dc0ac8f78d3\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=068f77d25d2b6b81d4094dc0ac8f78d3</a></p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[derive(Copy, Clone, PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">eq</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">other</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">other</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>(you can use any integer type there)</p>",
        "id": 208939373,
        "sender_full_name": "matt1992",
        "timestamp": 1599124037
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"138909\">@matt1992</span> Oh wow, that's perfect, thanks!</p>",
        "id": 208939523,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1599124152
    }
]