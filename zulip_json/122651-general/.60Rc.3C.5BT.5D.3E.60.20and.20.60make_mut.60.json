[
    {
        "content": "<p>I'm trying to use <code>Rc&lt;[T]&gt;</code> and <code>make_mut</code> but they don't go together. <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=12077508f9d509c4f149081a68d6268c\">Here</a> is an example. Am I overlooking something?</p>",
        "id": 271900882,
        "sender_full_name": "nnethercote",
        "timestamp": 1644878939
    },
    {
        "content": "<p>I guess I could instead use <code>get_mut</code>, and if it fails then I could manually clone the slice?</p>",
        "id": 271901071,
        "sender_full_name": "nnethercote",
        "timestamp": 1644879058
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>the trait `Clone` is not implemented for `[u32]`\n</code></pre></div>\n\n<p>well that's not surprising in general, but it's unfortunate here</p>",
        "id": 271901851,
        "sender_full_name": "cuviper",
        "timestamp": 1644879585
    },
    {
        "content": "<p>there's a similar case with cloning <code>Box&lt;[T]&gt;</code>, but we have an explicit <code>Clone</code> for that</p>",
        "id": 271902116,
        "sender_full_name": "cuviper",
        "timestamp": 1644879708
    },
    {
        "content": "<p>maybe we can add duplicate <code>make_mut</code> for the same reason?</p>",
        "id": 271902136,
        "sender_full_name": "cuviper",
        "timestamp": 1644879720
    },
    {
        "content": "<p>Hmm, and I guess <code>ToOwned</code> doesn't fix it here, since getting a <code>Vec&lt;T&gt;</code> isn't really what the implementation wants either.</p>",
        "id": 271902246,
        "sender_full_name": "scottmcm",
        "timestamp": 1644879772
    },
    {
        "content": "<p>with just a <code>todo!()</code> version added, duplicating the method does cause ambiguity already in existing tests</p>",
        "id": 271902691,
        "sender_full_name": "cuviper",
        "timestamp": 1644880037
    },
    {
        "content": "<p>so maybe call it <code>make_mut_slice</code> to be safe</p>",
        "id": 271902706,
        "sender_full_name": "cuviper",
        "timestamp": 1644880049
    },
    {
        "content": "<p>creating a new helper trait (with a generic implementation bound on <code>Clone</code>) and bounding <code>make_mut</code> on that trait instead of <code>Clone</code> might be reasonable?</p>",
        "id": 271902786,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644880085
    },
    {
        "content": "<p>maybe so</p>",
        "id": 271903085,
        "sender_full_name": "cuviper",
        "timestamp": 1644880278
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">DynClone</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">clone_into</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">target</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271903179,
        "sender_full_name": "cuviper",
        "timestamp": 1644880331
    },
    {
        "content": "<p>(although I think <code>MaybeUninit</code> is still <code>Sized</code>)</p>",
        "id": 271903244,
        "sender_full_name": "cuviper",
        "timestamp": 1644880373
    },
    {
        "content": "<p>that's roughly reinventing \"place\" again :)</p>",
        "id": 271903322,
        "sender_full_name": "cuviper",
        "timestamp": 1644880431
    },
    {
        "content": "<p>a less general approach could just feature a <code>fn(&amp;self) -&gt; Rc&lt;Self&gt;</code> method. And the same thing for <code>Arc</code>, potentially even as yet another trait. As long as the trait and its method is still unstable the details shouldn't matter anyways, right? Of course the additional capabilities of <code>make_mut</code> <em>would</em> be instantly stable, I suppose</p>",
        "id": 271903502,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644880543
    },
    {
        "content": "<p>I don't like the habit of perm-unstable stuff though</p>",
        "id": 271903599,
        "sender_full_name": "cuviper",
        "timestamp": 1644880605
    },
    {
        "content": "<p>if nothing else, it means 3rd-party code can't be generic in the same way</p>",
        "id": 271903621,
        "sender_full_name": "cuviper",
        "timestamp": 1644880623
    },
    {
        "content": "<p>(like <code>Pattern</code>, <code>Step</code>, <code>Try</code>, ...)</p>",
        "id": 271903657,
        "sender_full_name": "cuviper",
        "timestamp": 1644880660
    },
    {
        "content": "<p>not that those are definitely unstable forever, but it's been a long time</p>",
        "id": 271903724,
        "sender_full_name": "cuviper",
        "timestamp": 1644880692
    },
    {
        "content": "<blockquote>\n<p>that's roughly reinventing \"place\" again :)</p>\n</blockquote>\n<p>I was thinking of a ContainerBuilder that can produce Box, Arc, Rc and similar, with specific handling for [T]s. Initializing the value would be one part of that.</p>",
        "id": 271903742,
        "sender_full_name": "The 8472",
        "timestamp": 1644880715
    },
    {
        "content": "<p><code>Box</code> and it's stuff, <code>Unsize</code>, <code>CoerceUnsized</code>.<br>\nSide note, pls give <code>CoerceUnsized</code>.</p>",
        "id": 271903779,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644880745
    },
    {
        "content": "<p>Yes, certainly a general approach along the lines of what you propose seems desirable. The unstable stuff is just about what one <em>could</em> use as long as no eventually stabilizable general solution has been implemented yet. E. g. perhaps unions such as <code>MaybeUninit</code> will eventually support unsized types, etc.</p>",
        "id": 271903802,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644880756
    },
    {
        "content": "<p>I'm trying to write this <code>make_mut_slice</code>, I'm not sure if it can be done without <code>unsafe</code></p>",
        "id": 271904851,
        "sender_full_name": "nnethercote",
        "timestamp": 1644881486
    },
    {
        "content": "<p>huh, I forgot about that <code>write_clone_into_raw</code> optimization I added :)</p>",
        "id": 271910287,
        "sender_full_name": "cuviper",
        "timestamp": 1644885225
    },
    {
        "content": "<p>I think <code>make_mut_slice</code> will basically be the same as <code>make_mut</code>, just looping multiple of those write calls, and probably guarded to drop previous entries if a clone panics</p>",
        "id": 271910431,
        "sender_full_name": "cuviper",
        "timestamp": 1644885324
    },
    {
        "content": "<p>but yes, that will involve <code>unsafe</code></p>",
        "id": 271910463,
        "sender_full_name": "cuviper",
        "timestamp": 1644885351
    },
    {
        "content": "<p>oh, <code>MaybeUninit::write_slice_cloned</code> already does that guarded looping</p>",
        "id": 271912827,
        "sender_full_name": "cuviper",
        "timestamp": 1644887120
    },
    {
        "content": "<p>Here's a version that doesn't involve <code>unsafe</code>, but is ugly:</p>\n<div class=\"codehilite\"><pre><span></span><code>/// `Rc::make_mut` works with `Rc&lt;T&gt;` but not `Rc&lt;[T]&gt;`, so we do it ourselves\n/// here.\nfn make_mut_slice(words: &amp;mut Rc&lt;[Word]&gt;) -&gt; &amp;mut [Word] {\n    match Rc::get_mut(words) {\n        Some(_) =&gt; {}\n        None =&gt; *words = words.iter().cloned().collect(),\n    }\n    Rc::get_mut(words).unwrap()\n}\n</code></pre></div>",
        "id": 271929733,
        "sender_full_name": "nnethercote",
        "timestamp": 1644903677
    },
    {
        "content": "<p>(<code>Word</code> is just a typedef for <code>u64</code> in my case)</p>",
        "id": 271929788,
        "sender_full_name": "nnethercote",
        "timestamp": 1644903723
    },
    {
        "content": "<p>TIL <a href=\"https://doc.rust-lang.org/1.58.1/std/iter/trait.FromIterator.html#impl-FromIterator%3CT%3E-6\">https://doc.rust-lang.org/1.58.1/std/iter/trait.FromIterator.html#impl-FromIterator%3CT%3E-6</a></p>\n<p>I think that with that very tool, the solution is actually quite nice / elegant</p>",
        "id": 271949024,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644918367
    },
    {
        "content": "<p>hi all , has Rust a library for direct memory access and management?</p>",
        "id": 271957262,
        "sender_full_name": "theseus yang",
        "timestamp": 1644922829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/122651-general/topic/.60Rc.3C.5BT.5D.3E.60.20and.20.60make_mut.60/near/271902246\">said</a>:</p>\n<blockquote>\n<p>Hmm, and I guess <code>ToOwned</code> doesn't fix it here, since getting a <code>Vec&lt;T&gt;</code> isn't really what the implementation wants either.</p>\n</blockquote>\n<p>You could require <code>T: ToOwned</code> and <code>Self: From&lt;T::Owned&gt;</code> then use <code>Self::from(t.to_owned())</code>. This should cover the existing cases because <code>T: Clone</code> implied <code>T: ToOwned&lt;Owned=T&gt;</code> and <code>Rc&lt;T&gt;: From&lt;T&gt;</code> for sized <code>T</code>s (and <code>T: Clone</code> implies <code>T: Sized</code>). This is of course not ideal for performance, but I guess it could be improved with specialization.</p>",
        "id": 271966626,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1644928258
    }
]