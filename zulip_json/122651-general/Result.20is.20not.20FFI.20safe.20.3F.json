[
    {
        "content": "<p>I am wrapping the following C library, which has an API like this:</p>\n<div class=\"codehilite\"><pre><span></span><code>enum ErrorKind: uint32_t {\n    SUCCESS = 0,\n    ERROR0 = 1,\n    ERROR1 = 2,\n    ...,\n}\nErrorKind func();\n</code></pre></div>\n<p>And I want to wrap it as:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[repr(u32)]\n#[non_exhaustive]\nenum ErrorKind {\n    Error0 = 1,\n    Error1 = 2,\n    ...,\n}\n\ntype Result&lt;T&gt; = Result&lt;(), ErrorKind&gt;;\n\nextern &quot;C&quot; {\n    fn func() -&gt; Result&lt;()&gt;;\n}\n</code></pre></div>\n<p>but I am getting an error saying that <code>Result</code> is not FFI safe.</p>\n<p>I've added some tests (alignment, size using transmute, etc.) and my Result has the same size, alignment, etc. as ErrorKind, and they both have the same size, alignment, etc. as the C enum.</p>",
        "id": 253400895,
        "sender_full_name": "hannahE2",
        "timestamp": 1631707014
    },
    {
        "content": "<p>The only thing that could be different is the \"call ABI\", but I've looked at the assembly and they both appear to use the same calling convention (one 32-bit register).</p>",
        "id": 253400963,
        "sender_full_name": "hannahE2",
        "timestamp": 1631707055
    },
    {
        "content": "<p>Is this a bug in the FFI-safe lint and is it ok to use result like this? </p>\n<p>And if not, what's the problem and how do I fix it.</p>",
        "id": 253401042,
        "sender_full_name": "hannahE2",
        "timestamp": 1631707083
    },
    {
        "content": "<p>I want to say that because Result isn't annotated with <code>#[repr(C)]</code> then it is not FFI safe, but that's not true,<br>\n<code>Opion&lt;&amp;T&gt;</code> is FFI safe a guaranteed to have the safe layout of a pointer, even though Option is not annotated with <code>#[repr(C)]</code></p>\n<p>Even if Result was FFI safe then:</p>\n<ol>\n<li>there's no gurantee that <code>Ok(())</code> will be represented by the value 0 (actually if you try to transmute it you'll see you usually get the last variant + 1)</li>\n<li><code>non_exhusative</code> doesn't solve the UB of having a variant that isn't defined.</li>\n</ol>\n<p>so by current compiler you'll have to define all 1..2^32-1 cases in the enum for this to work as expected.</p>\n<p>but in short AFAIK <code>Result</code> isn't FFI safe exactly because it can't currently promise things like that as it tries to optimize as much as possible</p>",
        "id": 253403582,
        "sender_full_name": "Elichai Turkel",
        "timestamp": 1631708326
    },
    {
        "content": "<p>I can probably use <code>#[rustc_valid_range_start(1)]</code> to make <code>ErrorKind</code> only have a niche at 0</p>",
        "id": 253407074,
        "sender_full_name": "hannahE2",
        "timestamp": 1631710096
    },
    {
        "content": "<p>Is <code>Result&lt;(), NonZeroU32&gt;</code> FFI safe ?</p>",
        "id": 253407150,
        "sender_full_name": "hannahE2",
        "timestamp": 1631710142
    },
    {
        "content": "<p>I don't really see what <code>non_exhaustive</code> has to do with anything. AFAIK it does not impact layout in any way, and I am not trying to use it in that way, so I don't know what would be the point.</p>",
        "id": 253407360,
        "sender_full_name": "hannahE2",
        "timestamp": 1631710242
    },
    {
        "content": "<p>Result is not an FFI-safe type regardless of the type parameters it's instantiated with; you shouldn't use it for FFI signatures</p>",
        "id": 253410423,
        "sender_full_name": "simulacrum",
        "timestamp": 1631711526
    },
    {
        "content": "<p>Generally the way to go here is to define the extern function as returning an FFI safe type and then wrap it in a function that converts to a Rust type like Result. In theory, if the two types have a 1:1 relationship, this should be free, but is also safe if they don't.</p>",
        "id": 253410548,
        "sender_full_name": "simulacrum",
        "timestamp": 1631711586
    },
    {
        "content": "<p><code>Result&lt;(), NonZeroU32&gt;</code> naturally must be FFI safe because of the pidgeonhole principle</p>",
        "id": 253410636,
        "sender_full_name": "Lokathor",
        "timestamp": 1631711625
    },
    {
        "content": "<p>If a type is not repr(C) and there's not an explicit definition making it FFI safe, it is not guaranteed to keep that layout. Of course, you can depend on undocumented rules, but that's sort of always true (and in that case talking about ffi safety isn't really too reasonable)</p>",
        "id": 253410897,
        "sender_full_name": "simulacrum",
        "timestamp": 1631711730
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253410636\">said</a>:</p>\n<blockquote>\n<p><code>Result&lt;(), NonZeroU32&gt;</code> naturally must be FFI safe because of the pidgeonhole principle</p>\n</blockquote>\n<p>it's probably still legal to represent this as <code>{is_ok: bool, value: MaybeUninit&lt;NonZeroU32&gt;}</code></p>",
        "id": 253412595,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631712420
    },
    {
        "content": "<p>I'm not asking for portability across toolchains.</p>",
        "id": 253413375,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712708
    },
    {
        "content": "<p>Not sure if there is a way to test for the <code>call ABI</code> from Rust code, but I can test for <code>size</code>, <code>alignment</code>, and the niches being on the right place.</p>",
        "id": 253413492,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712738
    },
    {
        "content": "<p>There's no way to test niches in sound Rust code that I know of</p>",
        "id": 253413569,
        "sender_full_name": "simulacrum",
        "timestamp": 1631712769
    },
    {
        "content": "<p>(curious to hear more, though).</p>",
        "id": 253413584,
        "sender_full_name": "simulacrum",
        "timestamp": 1631712775
    },
    {
        "content": "<p><code>Option&lt;NonZeroU32&gt;</code> is FFI safe</p>",
        "id": 253413656,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712798
    },
    {
        "content": "<p>and <code>Result&lt;(), NonZeroU32&gt;</code> has the same size, and alignment as <code>Option&lt;NonZeroU32&gt;</code></p>",
        "id": 253413720,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712819
    },
    {
        "content": "<p>Building a <code>Result&lt;(), NonZeroU32&gt;::Ok</code> and transmuting that into an <code>Option&lt;NonZeroU32&gt;</code> produces an option with value <code>None</code></p>",
        "id": 253413856,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712856
    },
    {
        "content": "<p>AFAICT, that proves that the niche of <code>Result&lt;(), NonZeroU32&gt;::Ok</code> is the same as that of <code>Option&lt;NonZeroU32&gt;</code></p>",
        "id": 253413929,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712885
    },
    {
        "content": "<p>I'm not sure there's any documentation that suggests <code>Option&lt;NonZeroU32&gt;</code> is FFI safe. It's probably <em>currently true</em>, and is unlikely to change, but you can't really rely on it...</p>",
        "id": 253413973,
        "sender_full_name": "simulacrum",
        "timestamp": 1631712898
    },
    {
        "content": "<p>given their size in bits, they both can only have 1 bit pattern for the niche, and is the same.</p>",
        "id": 253413991,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712906
    },
    {
        "content": "<p>I found those docs in the docs for <code>Box</code>, using <code>Option&lt;Box&gt;</code> in FFI is documented as safe</p>",
        "id": 253414033,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712921
    },
    {
        "content": "<p>not sure if that extends to other types like <code>Option&lt;NonZeroU32&gt;</code></p>",
        "id": 253414096,
        "sender_full_name": "hannahE2",
        "timestamp": 1631712946
    },
    {
        "content": "<p>like, you're not \"wrong\" in the sense that this is unlikely to be wrong, but it isn't well defined.</p>\n<p>Option&lt;Box&lt;...&gt;&gt; and Option&lt;NonZeroU32&gt; are different types</p>",
        "id": 253414103,
        "sender_full_name": "simulacrum",
        "timestamp": 1631712949
    },
    {
        "content": "<p>given that the size of <code>Result&lt;(), NonZeroU32&gt;</code> is the same as that of <code>Option&lt;NonZeroU32&gt;</code> and <code>NonZeroU32</code>, and that's 32-bit, and <code>NonZeroU32</code> uses 2^32 - 1 bit patterns, only one is free for the niche and that's the 0x0 bitpattern. I can test for all this, e.g., by transmuting <code>Result&lt;(), NonZeroU32&gt;</code> to <code>u32</code> , and the same for <code>Option&lt;NonZeroU32&gt;</code> , and checking the value of that <code>u32</code></p>",
        "id": 253414412,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713058
    },
    {
        "content": "<p>AFAICT those tests are safe</p>",
        "id": 253414431,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713064
    },
    {
        "content": "<p>Also, I can pass a <code>&amp;NonZeroU32</code> around, and it doesn't matter whether that points to a type in an option or a result</p>",
        "id": 253414521,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713088
    },
    {
        "content": "<p>size and alignment is not the only indicator necessary for the ABI to be the same, though.</p>",
        "id": 253414579,
        "sender_full_name": "nagisa",
        "timestamp": 1631713110
    },
    {
        "content": "<p>So as long as the size of <code>Result&lt;(), NonZeroU32&gt;</code> and <code>NonZeroU32</code> are the same, that means that the <code>Result::Ok</code> variant is encoded as <code>0x0</code></p>",
        "id": 253414594,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713115
    },
    {
        "content": "<p>the compiler could very well be passing the state of the enum around as a flag in the flags register for example, or something similarly weird.</p>",
        "id": 253414632,
        "sender_full_name": "nagisa",
        "timestamp": 1631713133
    },
    {
        "content": "<blockquote>\n<p>size and alignment is not the only indicator necessary for the ABI to be the same, though</p>\n</blockquote>\n<p>I mentioned that above, and that I don't know of a way to test the <code>call ABI</code> in Rust</p>",
        "id": 253414641,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713135
    },
    {
        "content": "<p>what i do is roundtrip to C and back and verify the value, for all 32-bit patterns</p>",
        "id": 253414688,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713152
    },
    {
        "content": "<p>this test takes 5 seconds</p>",
        "id": 253414709,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713160
    },
    {
        "content": "<p>I would prefer to avoid doing this, and  have something that could be implemented as an static-assert</p>",
        "id": 253414791,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713188
    },
    {
        "content": "<p>tbh this result type is 1 32-bit register, so while this is technically an aggregate, passing it by memory would be nuts, given that we already do the register optimization for scalar pairs as well</p>",
        "id": 253415023,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713257
    },
    {
        "content": "<p>There's no way to assert two types have the same representation or call ABI today. Even that test doesn't really verify that, just tests a particular instance (we could in theory have different call ABIs for different functions for repr(rust) types if we wanted to, to my knowledge).</p>",
        "id": 253415154,
        "sender_full_name": "simulacrum",
        "timestamp": 1631713308
    },
    {
        "content": "<p>Not saying we <em>would</em> do that</p>",
        "id": 253415205,
        "sender_full_name": "simulacrum",
        "timestamp": 1631713322
    },
    {
        "content": "<p>but we could, in theory, and so I at least wouldn't rely on this in my code</p>",
        "id": 253415358,
        "sender_full_name": "simulacrum",
        "timestamp": 1631713371
    },
    {
        "content": "<p>So my tests currently cover:</p>\n<ul>\n<li>size and alignment of Result&lt;(), NonZeroU32&gt; which matches <code>NonZeroU32</code></li>\n<li>value of <code>Result&lt;(), NonZeroU32&gt;::Ok</code> which matches <code>0x0</code>, which is the only possible niche given the size</li>\n<li>round trip test through the C ABI for all 2^32 bit-patterns to test the call ABI</li>\n</ul>",
        "id": 253415375,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713376
    },
    {
        "content": "<p>Looking at LLVM IR might be a valid way to verify that the ABI looks okay for the specific compilation with the specific source code, flags, and the build of the toolchain. I'm not entirely sure if testing values exhaustively is the right way to go about this either.</p>",
        "id": 253415488,
        "sender_full_name": "nagisa",
        "timestamp": 1631713428
    },
    {
        "content": "<p>If we remove the niche optimization for result, then all of this breaks, and the tests catch this at compile time.</p>\n<p>If we change the call ABI, the runtime test catches it (hopefully, fingers crossed I guess).</p>",
        "id": 253415508,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713433
    },
    {
        "content": "<p>I wish we would just guarantee same call ABI, layout, alignment, niches, etc. for <code>Result&lt;(), T&gt;</code> and <code>Option&lt;T&gt;</code></p>",
        "id": 253415682,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713483
    },
    {
        "content": "<p>And then guarantee that if <code>Option&lt;T&gt;</code> is FFI safe, so is <code>Result&lt;(), T&gt;</code>.</p>",
        "id": 253415792,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713526
    },
    {
        "content": "<p>Not sure what the value is in not doing this.</p>",
        "id": 253415845,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713546
    },
    {
        "content": "<p>From looking at the <code>Result&lt;(), NonZeroU32&gt;</code> example, I can't see any optimization that we aren't already doing, and I don't see why we would ever want to do something worse here. We can't do better than having same size and alignment and call ABI as NonZeroU32 here. And there is only 1 niche that we can use here anyways.</p>",
        "id": 253416008,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713589
    },
    {
        "content": "<p>There are so many C APIs that return <code>-&gt; int</code> with <code>0 == success</code> otherwise error code, and using Result here directly is just so nice.</p>",
        "id": 253416207,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713655
    },
    {
        "content": "<p>It makes \"<code>unsafe</code> C FFI\" much easier to use.</p>",
        "id": 253416244,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713672
    },
    {
        "content": "<blockquote>\n<p>Even that test doesn't really verify that, just tests a particular instance (we could in theory have different call ABIs for different functions for repr(rust) types if we wanted to, to my knowledge).</p>\n</blockquote>\n<p>I just need the guarantee for <code>extern \"C\"</code></p>",
        "id": 253416431,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713733
    },
    {
        "content": "<p>When this is passed across <code>repr(Rust)</code>, all my <code>repr(Rust)</code> functions use the same type, so that should work independently of the call ABI used there.</p>",
        "id": 253416506,
        "sender_full_name": "hannahE2",
        "timestamp": 1631713757
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253415682\">said</a>:</p>\n<blockquote>\n<p>I wish we would just guarantee same call ABI, layout, alignment, niches, etc. for <code>Result&lt;(), T&gt;</code> and <code>Option&lt;T&gt;</code></p>\n</blockquote>\n<p>At most, I would guarantee that <code>Result&lt;(),T&gt;</code> has the same layout as <code>Option&lt;T&gt;</code> if <code>T</code> is one of the guaranteed-niche optimized types (<code>&amp;U</code>, <code>&amp;mut U</code>, <code>NonNull&lt;U&gt;</code>, <code>NonZero*</code>, and <code>Box&lt;U&gt;</code> or a transparent wrapper arround such). However, even then I'd be hesistent to guarantee that.</p>",
        "id": 253418162,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631714300
    },
    {
        "content": "<p>For example: \"<code>Result&lt;(),T&gt;</code> has the same layout as <code>Option&lt;T&gt;</code> if <code>T</code> has a niche.\" We don't really have to say where the niche of <code>T</code> comes from.</p>",
        "id": 253419291,
        "sender_full_name": "hannahE2",
        "timestamp": 1631714653
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"409057\">hannahE2</span> <a href=\"#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253415023\">said</a>:</p>\n<blockquote>\n<p>tbh this result type is 1 32-bit register, so while this is technically an aggregate, passing it by memory would be nuts, given that we already do the register optimization for scalar pairs as well</p>\n</blockquote>\n<p>On certain calling conventions any struct is passed on the stack, even if it only contains a single scalar field that fits in a register.</p>",
        "id": 253426114,
        "sender_full_name": "bjorn3",
        "timestamp": 1631717097
    },
    {
        "content": "<p>which of the <code>extern \"C\"</code> ones work like this?</p>",
        "id": 253430931,
        "sender_full_name": "hannahE2",
        "timestamp": 1631718791
    },
    {
        "content": "<p>I think this applies to the following targets:</p>\n<p>amdgpu: <a href=\"https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/amdgpu.rs#L17\">https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/amdgpu.rs#L17</a><br>\navr: <a href=\"https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/avr.rs#L43\">https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/avr.rs#L43</a><br>\nbpf: <a href=\"https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/bpf.rs#L14\">https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/bpf.rs#L14</a><br>\npowerpc: <a href=\"https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/powerpc.rs#L13\">https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/powerpc.rs#L13</a><br>\nwasm32-unknown-unknown: <a href=\"https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/wasm.rs#L81\">https://github.com/rust-lang/rust/blob/e846f9c44f1e17cac66d7b75e2ca099c87a2dfcb/compiler/rustc_target/src/abi/call/wasm.rs#L81</a></p>",
        "id": 253431997,
        "sender_full_name": "bjorn3",
        "timestamp": 1631719173
    },
    {
        "content": "<p>I wonder if we can fuzz abi in -Zrandomize-layout as well</p>",
        "id": 253432047,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631719195
    },
    {
        "content": "<p>Like sometimes make non-ffi-safe types be aggregate while it could be scalar.</p>",
        "id": 253432269,
        "sender_full_name": "Gary Guo",
        "timestamp": 1631719273
    },
    {
        "content": "<p>Thanks bjorn, so i think if we guarantee the same layout as option, and therefore <code>repr(transparent)</code>, then on those targets, these <code>Result</code> types would either need to be passed as scalars, or you could not use them in C FFI where a <code>u32</code> is expected.</p>",
        "id": 253435258,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720367
    },
    {
        "content": "<p>I suppose <code>Option&lt;Box&lt;T: Sized&gt;&gt;</code> does not get passed as an aggregate on those, since we guarantee that you can put it where C expects a raw pointer.</p>",
        "id": 253435542,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720461
    },
    {
        "content": "<p>that's descriptivist reasoning. the issue is that compiler optimizations are written by prescriptivists. \"is there anything in the standard forbidding this?\" - \"no\" - \"ok, let's do crazy thing X\"</p>",
        "id": 253435545,
        "sender_full_name": "The 8472",
        "timestamp": 1631720461
    },
    {
        "content": "<p>Its not, it's just a consequence of matching the layout of <code>Option</code>.</p>",
        "id": 253435592,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720484
    },
    {
        "content": "<p>If we say that we want <code>Result&lt;(), T&gt;</code> to match the layout of <code>Option&lt;T&gt;</code> when <code>T</code> has a niche, then a change in the call ABI to match option is just a consequence of that.</p>",
        "id": 253435729,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720531
    },
    {
        "content": "<p>Except that this is about ABI, not just layout. And result isn't <code>repr(transparent)</code> anyway.</p>",
        "id": 253435768,
        "sender_full_name": "The 8472",
        "timestamp": 1631720550
    },
    {
        "content": "<p>ABI is part of Layout in Rust</p>",
        "id": 253435790,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720559
    },
    {
        "content": "<p>Matching <code>Option&lt;T&gt;</code> layout includes matching its <code>call ABI</code> by definition.</p>",
        "id": 253435882,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720596
    },
    {
        "content": "<p>ehh, maybe from the backend perspective. not when transmutes are concerned for example.</p>",
        "id": 253435885,
        "sender_full_name": "The 8472",
        "timestamp": 1631720596
    },
    {
        "content": "<p>transmutes are just memcpy, so they don't interact with call ABI at all</p>",
        "id": 253435927,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720609
    },
    {
        "content": "<p>they don't interact with niches either</p>",
        "id": 253435989,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720639
    },
    {
        "content": "<p>or even alignment</p>",
        "id": 253436034,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720644
    },
    {
        "content": "<p>I'm saying that \"layout\" as considered by transmutes is different than what function calls consider</p>",
        "id": 253436103,
        "sender_full_name": "The 8472",
        "timestamp": 1631720667
    },
    {
        "content": "<p>transmutes do not consider layout, only \"size'</p>",
        "id": 253436133,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720680
    },
    {
        "content": "<p>which is one of the many things that make a layout</p>",
        "id": 253436164,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720694
    },
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html\">https://doc.rust-lang.org/stable/std/alloc/struct.Layout.html</a></p>",
        "id": 253436307,
        "sender_full_name": "The 8472",
        "timestamp": 1631720741
    },
    {
        "content": "<p>fsvo layout. this kind of layout is just size and alignment.</p>",
        "id": 253436333,
        "sender_full_name": "The 8472",
        "timestamp": 1631720753
    },
    {
        "content": "<p>that a standard library type called layout that does not match the meaning of layout in rust, the language</p>",
        "id": 253436392,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720764
    },
    {
        "content": "<p>yes, that's my point. different definitions of the same word.</p>",
        "id": 253436448,
        "sender_full_name": "The 8472",
        "timestamp": 1631720780
    },
    {
        "content": "<p>so you have to be careful when saying \"same layout\"</p>",
        "id": 253436488,
        "sender_full_name": "The 8472",
        "timestamp": 1631720791
    },
    {
        "content": "<p>i'm talking about Rust, the language</p>",
        "id": 253436492,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720792
    },
    {
        "content": "<p>when I mean layout, i mean _layout_ in Rust, the language</p>",
        "id": 253436524,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720804
    },
    {
        "content": "<p>I can create a <code>enum Layout { }</code> inhabited type, yet I'm not referring to that here</p>",
        "id": 253436579,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720825
    },
    {
        "content": "<p>From the <em>Rust language reference</em>:</p>\n<blockquote>\n<p>Structs and enums with this representation have the same layout and ABI as the single non-zero sized field.</p>\n</blockquote>\n<p>Layout and ABI are considered distinct concepts..</p>",
        "id": 253436741,
        "sender_full_name": "The 8472",
        "timestamp": 1631720884
    },
    {
        "content": "<p>that looks like a bug in the docs</p>",
        "id": 253436865,
        "sender_full_name": "hannahE2",
        "timestamp": 1631720941
    },
    {
        "content": "<p>Often people only care about the bit representation to match so they can transmute. So ABI matches don't fall out of that automatically.</p>",
        "id": 253438453,
        "sender_full_name": "The 8472",
        "timestamp": 1631721450
    },
    {
        "content": "<p>This is not true, since the whole point of this guarantee, both for <code>Option&lt;T&gt;</code> (which we already guarantee) and in this case also for <code>Result&lt;(), T&gt;</code> is to allow its use in C FFI.</p>",
        "id": 253438679,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721516
    },
    {
        "content": "<p>Our docs explicitly say so.</p>",
        "id": 253438767,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721547
    },
    {
        "content": "<p>See <a href=\"https://doc.rust-lang.org/std/boxed/index.html#memory-layout\">https://doc.rust-lang.org/std/boxed/index.html#memory-layout</a>  , and how we include there the ABI in the meaning of layout in this context.</p>",
        "id": 253438856,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721577
    },
    {
        "content": "<blockquote>\n<p>So long as T: Sized, a Box&lt;T&gt; is guaranteed to be represented as a single pointer and is also ABI-compatible with C pointers (i.e. the C type T<em>). This means that if you have extern “C” Rust functions that will be called from C, you can define those Rust functions using Box&lt;T&gt; types, and use T</em> as corresponding type on the C side.</p>\n</blockquote>",
        "id": 253439086,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721633
    },
    {
        "content": "<blockquote>\n<p>Note also that the nullable argument to foo_delete is represented in Rust as Option&lt;Box&lt;Foo&gt;&gt;, since Box&lt;Foo&gt; cannot be null.</p>\n</blockquote>",
        "id": 253439165,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721664
    },
    {
        "content": "<p>Yes, that's an existing guarantee for Option. I mean that if someone happened to define somewhere that you can transmute an <code>Option&lt;T&gt;</code> into <code>Result&lt;(), T&gt;</code> the same guarantee for FFI-safety wouldn't automatically fall out of it. It would require something more explicit.</p>",
        "id": 253439382,
        "sender_full_name": "The 8472",
        "timestamp": 1631721704
    },
    {
        "content": "<p>Nobody is arguing about that.</p>",
        "id": 253439490,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721733
    },
    {
        "content": "<p>Nobody is suggesting to define that you can transmute one into the other either.</p>",
        "id": 253439556,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721757
    },
    {
        "content": "<p>So I don't really know who you are replying to in this particular thread.</p>",
        "id": 253439593,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721768
    },
    {
        "content": "<p>You would be right, if the strawman you are building were not a strawman.</p>",
        "id": 253439635,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721784
    },
    {
        "content": "<p>Anyways, just muted you, so i can't see anything else you write, cause you don't seem to let it go, and keep going back to this thread with the same issue, that has already been resolved, adding noise.</p>\n<p>AFAICT, this comment properly addresses your concern about what it is meant by layout in this particular thread: <a href=\"#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253435729\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253435729</a></p>",
        "id": 253439851,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721857
    },
    {
        "content": "<p><span aria-label=\"angry\" class=\"emoji emoji-1f620\" role=\"img\" title=\"angry\">:angry:</span></p>",
        "id": 253440033,
        "sender_full_name": "The 8472",
        "timestamp": 1631721919
    },
    {
        "content": "<p>Hypothetical situations in which we mean something else by layout are out of scope for this discussion AFAICT.</p>",
        "id": 253440087,
        "sender_full_name": "hannahE2",
        "timestamp": 1631721936
    },
    {
        "content": "<p>Anyway, for other observers... I disagree with \"nobody is arguing that\" since earlier arguments sortof looked like \"tests show bit representation are the same, therefore this should be safe\" and further used \"layout\" as argument even though layout can mean many things. I wanted to press for precise language.</p>",
        "id": 253440634,
        "sender_full_name": "The 8472",
        "timestamp": 1631722128
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253413973\">said</a>:</p>\n<blockquote>\n<p>I'm not sure there's any documentation that suggests <code>Option&lt;NonZeroU32&gt;</code> is FFI safe. It's probably <em>currently true</em>, and is unlikely to change, but you can't really rely on it...</p>\n</blockquote>\n<p>The enum optimization in question is part of the language semantics, and it's something people can rely on, ust like <code>Option&lt;&amp;X&gt;</code> using NULL for None.</p>",
        "id": 253468034,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631732029
    },
    {
        "content": "<p>That's separate from whether any given type is declared as FFI-safe.</p>",
        "id": 253468194,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631732081
    },
    {
        "content": "<p>Independently from that, there's the question of what niche will get used. <a href=\"https://github.com/rust-lang/rust/pull/87794\">https://github.com/rust-lang/rust/pull/87794</a> just made the change to use the zero niche when available, but that PR didn't make it a language guarantee, just something we do.</p>",
        "id": 253468378,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631732147
    },
    {
        "content": "<p>It'd be worth considering whether that <em>should</em> be a language guarantee.</p>",
        "id": 253468409,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631732157
    },
    {
        "content": "<p>I think it'd be perfectly reasonable for <code>Result&lt;(), NonZeroU32&gt;</code> or similar to be declared FFI-safe. And if we made the use of the zero niche guaranteed, then we could also make <code>Result&lt;(), SomeReprCEnumWithNoZero&gt;</code> FFI-safe.</p>",
        "id": 253468606,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631732223
    },
    {
        "content": "<p>The <code>Option</code> variants are language items, the <code>Result</code> variants aren't.</p>",
        "id": 253476750,
        "sender_full_name": "nagisa",
        "timestamp": 1631735503
    },
    {
        "content": "<p>EDIT: Okay, I was wrong, both are special. Ignore me.</p>",
        "id": 253476912,
        "sender_full_name": "nagisa",
        "timestamp": 1631735572
    },
    {
        "content": "<p>If this were to be guaranteed it should be done so for all enums that match the shape of option/result. They shouldn't have special assurances an otherwise equivalent user type doesn't also get.</p>",
        "id": 253478085,
        "sender_full_name": "Lokathor",
        "timestamp": 1631736061
    },
    {
        "content": "<p>I believe all enums with a similar shape to <code>Option</code> are defined as having this niche filling optimization.</p>",
        "id": 253478158,
        "sender_full_name": "bjorn3",
        "timestamp": 1631736090
    },
    {
        "content": "<p>I don't think this is precisely spelled out anywhere except for Option. Even the UCG call it non-normative because the boundaries of the niche optimization aren't specified anywhere, it's more a documentation of current behavior.</p>",
        "id": 253480702,
        "sender_full_name": "The 8472",
        "timestamp": 1631737021
    },
    {
        "content": "<p>I would like to keep it non-normative, or at least, the guaranteed set less than what rustc does. For example, I wouldn't want to see <code>Option&lt;Option&lt;&amp;Align2&gt;&gt;</code> guaranteed to use <code>1</code> as a None, and <code>0</code> as <code>Some(None)</code>.  <br>\nHowever, my opinion is that it would be fine and reasonable if <code>Result&lt;(),NonZeroU8&gt;</code> were guaranteed. <br>\nThough my question would be whether it should only apply to <code>T=()</code>, <code>E=GuaranteedNicheType</code>, or if it should also apply to <code>T=GuaranteedNicheType</code>, <code>E=()</code>.</p>",
        "id": 253484073,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631738384
    },
    {
        "content": "<p>That may be significantly more complex to specify, though I wouldn't necessarily have any issues with that either.</p>",
        "id": 253484233,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631738445
    },
    {
        "content": "<p>The only thing I'd be inclined to specify explicitly, for now, would be that if you have <code>Option&lt;T&gt;</code> or <code>Result&lt;(), T&gt;</code> where T has a niche of <code>0</code> available, <code>None</code> or <code>Ok(())</code> will be <code>0</code>, and that those types are FFI-safe if <code>T</code> is.</p>",
        "id": 253501003,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631746761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> That's specifically with <code>Option</code>, not just option-like?</p>",
        "id": 253502152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631747405
    },
    {
        "content": "<p>An example of a function with <code>Result&lt;T, ()&gt;</code>-like behavior is <code>malloc</code></p>",
        "id": 253502295,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631747494
    },
    {
        "content": "<p>Or better yet <code>Result&lt;T, AllocErr&gt;</code> where <code>AllocErr</code> is a ZST</p>",
        "id": 253502564,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631747632
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I'd be comfortable making the size and 0 guarantee about any similar type. I would have to think harder about the implications of declaring any similar type FFI-safe.</p>",
        "id": 253504317,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1631748644
    },
    {
        "content": "<p>That makes sense. You should at least need some kind of <code>repr</code> to opt in to FFI safety, but I guess that <code>repr(C)</code> is exactly the wrong thing here since it will remove the niche optimization</p>",
        "id": 253504633,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631748843
    },
    {
        "content": "<p>I think the question would be of what \"has a niche of <code>0</code> available\" means. Is it exactly the text currently present for <code>Option</code>, or would it include Enums that don't have the discriminant zero applied.</p>\n<p>For example, in the <a href=\"https://hackmd.io/@wSaA8OrrSQ2SlegMvA6e6A/SJ1TeE0y_#reprRust-enums\">lcrust abi</a> (used and defined for lccc's rust frontend), the latter currently would not fall under that specification, it specifies that the first Niche of an enum's discrimant type (and thus the enum) is the maximum discriminant+1, and doesn't consider the minimum discriminant at all (of course, in the compiler itself, the <code>nonzero</code> xir scalar attribute exists separately from min/max attributes, and is preferred over the latter, so it would merely be a wording change from my side - I wouldn't anticipate any issues in implementing it).</p>",
        "id": 253513054,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631754706
    },
    {
        "content": "<p>I think that...</p>\n<ul>\n<li>Any repr(rust) option-like type should have the guarantee, including Result&lt;T, ZST&gt; and Result&lt;ZST, T&gt;, as well as any similar user defined type.</li>\n<li>Any repr(rust) ZST should be equivalent to specifically using ().</li>\n<li>To start, this can apply to <strong>only</strong> the standard library \"0 is forbidden\" types (&amp;T, &amp;mut T, NonNull&lt;T&gt;, NonZeroInt) as well as any repr(transparent) wrapper over said types. The non-payload case would always specifically be 0, even if other niche's might exist (as is the case with &amp;T and &amp;mut T if the alignment of T is more than 1).</li>\n</ul>\n<p>Particularly, it shouldn't matter if it's Result&lt;T, ZST&gt; or Result&lt;ZST, T&gt;. The compiler shouldn't know that one side or the other of Result is a \"success\" outcome and the other is an \"error\" outcome. At least not for this layout stuff it shouldn't.</p>",
        "id": 253514872,
        "sender_full_name": "Lokathor",
        "timestamp": 1631756130
    },
    {
        "content": "<p>Should it be any ZST or just 1-ZSTs?</p>",
        "id": 253515214,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631756376
    },
    {
        "content": "<p>Excellent question. I think in the long term a ZST with an alignment &lt;= the alignment of the \"payload\" type should probably all be the same, but starting with only 1-ZST would be sufficient.</p>\n<p>I highly suspect that greater aligned ZSTs are extremely rare, so if they exist they can probably wait a bit.</p>",
        "id": 253515672,
        "sender_full_name": "Lokathor",
        "timestamp": 1631756675
    },
    {
        "content": "<p>Also, there is a question about the order of the variants (I believe that the <code>Err</code> variant is second in rustc's defintion, as the <code>Some</code> variant is likewise, which is where the special-casing comes, rather than <code>Result</code> knowing the \"sideness\" of Result. In theory, this could be significant in the implementation of Niche-optimization.</p>",
        "id": 253515893,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631756838
    },
    {
        "content": "<p>(Both leave the discrimant value equal to the bytes of the entire value, which could be used by the implementation)</p>",
        "id": 253516000,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631756903
    },
    {
        "content": "<p>well, if we take option-like to mean</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">OptionLike</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">NoPayload</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">Payload</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>then the order than you write down those two variants shouldn't matter. And if you have a Result-like type with either side as a ZST, then it becomes option-like.</p>",
        "id": 253516029,
        "sender_full_name": "Lokathor",
        "timestamp": 1631756940
    },
    {
        "content": "<p>Like if we say that option-like enums get this property, but <em>only if</em> you write it down in the order we expect, that's super footgun</p>",
        "id": 253516072,
        "sender_full_name": "Lokathor",
        "timestamp": 1631756989
    },
    {
        "content": "<p>The order could matter, though, is what I'm saying, in what is currently a valid implementation of niche-optimization.</p>",
        "id": 253516138,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631757016
    },
    {
        "content": "<p>Because it could implement it by laying it out as</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">union</span> <span class=\"nc\">OptionLike</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">discriminant_none</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"nb\">Some</span>: <span class=\"nc\">T</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where discriminant_none is written with <code>discriminant::&lt;Option&lt;T&gt;&gt;(&amp;None)</code></p>",
        "id": 253516240,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631757116
    },
    {
        "content": "<p>(I don't know of any implementations that do this, or would do this, but it is currently a valid implementation and may have advantages, particularily in complexity)</p>",
        "id": 253516313,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631757162
    },
    {
        "content": "<p>did you really mean usize there? like what if T is a u8?</p>",
        "id": 253516550,
        "sender_full_name": "Lokathor",
        "timestamp": 1631757361
    },
    {
        "content": "<p>sorry, a NonZeroU8</p>",
        "id": 253516595,
        "sender_full_name": "Lokathor",
        "timestamp": 1631757371
    },
    {
        "content": "<p>The <code>usize</code> applies to the nullable pointers and NonZeroUSize. For other mandatory-niche types, it would use the appropriately sized discriminant type.</p>",
        "id": 253516982,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631757644
    },
    {
        "content": "<p>Okay, well if my suggestion of making it order-agnostic were to become accepted, the implementation would simply be required to sort the NoPayload discriminant to be 0, and then it could still use the union thing.</p>",
        "id": 253518928,
        "sender_full_name": "Lokathor",
        "timestamp": 1631759188
    },
    {
        "content": "<p>can discriminants be reordered like that?</p>",
        "id": 253519432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631759634
    },
    {
        "content": "<p>I thought they had to go sequentially</p>",
        "id": 253519480,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631759653
    },
    {
        "content": "<p>I believe the default is yes (unless the user sets discriminant values explicitly)</p>",
        "id": 253520232,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631760322
    },
    {
        "content": "<p>definitely c-style enums cant be implicitly reordered (unless they keep their <code>as &lt;int&gt;</code> values)</p>",
        "id": 253520757,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631760786
    },
    {
        "content": "<p>Connor is correct for repr(rust), and Thom is correct for repr(C).</p>\n<p>In this case, \"option-like optimization\" would have to be assuming that the enum is repr(rust).</p>",
        "id": 253526588,
        "sender_full_name": "Lokathor",
        "timestamp": 1631765793
    },
    {
        "content": "<p>Would it be possible to have a niche optimization for <code>Result&lt;&amp;T, ()&gt;</code> and similar types such that the null variant is stored as zero but it still has <code>Discriminant(1)</code>? Even if it's not guaranteed to be stable I think that it is valuable to keep the ordering sane when at all possible</p>",
        "id": 253526912,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631766093
    },
    {
        "content": "<p>More generally, I think the <code>std::mem::discriminant()</code> function should always return the same discriminant values you would get for <code>_ as usize</code> on an equivalent repr(C) enum if you removed the payloads</p>",
        "id": 253527158,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631766319
    },
    {
        "content": "<p>By the way, I was just surprised to learn that <code>mem::size_of::&lt;Discriminant&lt;Option&lt;NonZeroU8&gt;&gt;&gt;() == 8</code></p>",
        "id": 253527667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631766841
    },
    {
        "content": "<blockquote>\n<p>Would it be possible to have a niche optimization for <code>Result&lt;&amp;T, ()&gt;</code> and similar types such that the null variant is stored as the all-zero bit pattern but it still has <code>Discriminant(1)</code>? Even if it's not guaranteed to be stable I think that it is valuable to keep the ordering sane when at all possible</p>\n</blockquote>\n<p>Sure, I don't see a reason it couldn't be implemented (in fact, the abi I linked previously mandates it, and I believe current rustc does it that way). My main point is that it is currently a valid implementation of the required niche-optimizations (tbh we need a better name, since it's no longer an optimization when it's mandatory - I think I've heard and used discriminant elision), that is order sensitive, and that such an implementation could be reasonable, or even beneficial (note: to be clear, my intention is this is more of a persuasive argument then a \"don't rule this implementation out\" argument).</p>",
        "id": 253557523,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631787293
    },
    {
        "content": "<p>i think <code>std::mem::discriminant</code> should match with <code>val as usize</code>, but if the enum is repr rust I don't think either of them should necessarily be any particular ordering of tag values.</p>\n<p>If you want a specific ordering you must say so to the compiler in some way.</p>",
        "id": 253581030,
        "sender_full_name": "Lokathor",
        "timestamp": 1631798818
    },
    {
        "content": "<p>I think saying \"so and so is FFI safe\" is a fairly weighty guarantee and we should be very careful about exposing anything but <code>#[repr(C)]</code> to FFI, especially when we are currently not even warning on explicit ABI violations: <a href=\"https://github.com/rust-lang/rust/issues/89003\">https://github.com/rust-lang/rust/issues/89003</a></p>",
        "id": 253630418,
        "sender_full_name": "Jubilee",
        "timestamp": 1631817895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253519432\">said</a>:</p>\n<blockquote>\n<p>can discriminants be reordered like that?</p>\n</blockquote>\n<p>If it is a typical repr(Rust) enum? Yes, part of the reason it's considered naughty to depend on vagaries of layout for most repr(Rust) types is that reordering like this is totally permitted.</p>",
        "id": 253632728,
        "sender_full_name": "Jubilee",
        "timestamp": 1631818779
    },
    {
        "content": "<p>I understand why we don't want to promise this, but I don't see a compelling reason to not follow the usual C enum discriminant rules for determining what <code>discriminant()</code> and <code>_ as usize</code> do, in the same way that <code>struct A { a: Foo, b: Bar }</code> and  <code>struct B { a: Foo, b: Bar }</code> should have the same layout because there isn't any compelling reason not to, even though this isn't a stable guarantee by any means</p>",
        "id": 253633763,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631819116
    },
    {
        "content": "<p>There is a difference between the tag/niche and the discriminant. The latter follows the C rules AFAIK and is what is directly exposed to the user. The former concerns the representation in memory and is <strong>not</strong> guaranteed to match the discriminant except in case of <code>#[repr(C)]</code>. Currently in case of a tag it does match I think, but in case of niches it doesn't always match.</p>",
        "id": 253634648,
        "sender_full_name": "bjorn3",
        "timestamp": 1631819453
    },
    {
        "content": "<p>For reference in case of a tagged enum layout there is a an int (the tag) indicating which variant you have followed by the actual data. In case of niche filling the data of one of the variants has one or more \"niches\". If at the location of the niches one of the niche values is used, the enum is the corresponding variant. If not, it is the variant whose data contains the niches.</p>",
        "id": 253635170,
        "sender_full_name": "bjorn3",
        "timestamp": 1631819656
    },
    {
        "content": "<p>Right. I'm talking about the <em>discriminant</em>, which has to be extracted by some function from the actual bits (the <em>niche</em>) anyway, so there isn't that much difference, code-wise, between having the discriminant corresponding to the all-zero niche be 1 or 0 (I guess it would be something like a <code>load</code> and <code>setnz</code> vs <code>load</code> and <code>setz</code>) for option-like enums</p>",
        "id": 253635512,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631819808
    },
    {
        "content": "<p>so I would imagine that for <code>Result&lt;(), T&gt;</code> and <code>Option&lt;T&gt;</code> the zero niche would have discriminant 0 and in <code>Result&lt;T, ()&gt;</code> it would have discriminant 1</p>",
        "id": 253635629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631819860
    },
    {
        "content": "<p>It could depend on the target.</p>",
        "id": 253635907,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631819977
    },
    {
        "content": "<p>Turning a bunch of zeroes into a bunch of zeroes is more generally easy w/o branches.</p>",
        "id": 253636042,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820022
    },
    {
        "content": "<p>It could. I'd really rather it didn't</p>",
        "id": 253636061,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820030
    },
    {
        "content": "<p>not as a user level promise, again, just as a compiler predictability thing</p>",
        "id": 253636105,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820055
    },
    {
        "content": "<p>What a CPU can do easily inherently is CPU dependant.</p>",
        "id": 253636133,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820071
    },
    {
        "content": "<p><code>discriminant()</code> is user-visible</p>",
        "id": 253636169,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820091
    },
    {
        "content": "<p>Well, the result of discriminant isn't. Doesn't it return an opaque type?</p>",
        "id": 253636225,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820116
    },
    {
        "content": "<p>I just tested, and what I described appears to match reality (on my machine, at least)</p>",
        "id": 253636289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820125
    },
    {
        "content": "<p>you can debug print it</p>",
        "id": 253636320,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820137
    },
    {
        "content": "<p>Debug isn't stable.</p>",
        "id": 253636338,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820145
    },
    {
        "content": "<p>I know</p>",
        "id": 253636348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820149
    },
    {
        "content": "<p>I never said anything about stability</p>",
        "id": 253636360,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820156
    },
    {
        "content": "<p>What I had described previously was a valid, simple implementation, in which order does matter.</p>",
        "id": 253636400,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820174
    },
    {
        "content": "<p>It's not any existing implementation as far as I know, but it's presently valid, and there might be a legitimate reason to use it.</p>",
        "id": 253636590,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820249
    },
    {
        "content": "<p>I think we're talking past each other. I'm aware this is in no way a stable guarantee, but I think that unless there is a very good reason (e.g. some weird CPU that takes lots of extra cycles for the discriminant implementation) it should not differ from this simple, predictable rule for discriminant labeling</p>",
        "id": 253636639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820275
    },
    {
        "content": "<p>Plus, it looks like this is what we do currently: <code>Result&lt;&amp;u8, ()&gt;</code> is niche-optimized, and has a discriminant of 1 for the all-zero niche</p>",
        "id": 253636857,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820366
    },
    {
        "content": "<p>I do agree there, especially a simple implementation would not do anything fancy, but it would preclude using the 1 discriminant for niches because it either stores the discrimant, or the niche-collapsed variant (note: in the particular implementation).</p>",
        "id": 253636879,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820377
    },
    {
        "content": "<p>plus the discriminant is not even the same size as the niche-optimized type (see the example above where the discriminant of <code>Option&lt;NonZeroU8&gt;</code> is 8 bytes)</p>",
        "id": 253637130,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820484
    },
    {
        "content": "<p>zx is typically easy.</p>",
        "id": 253637186,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820508
    },
    {
        "content": "<p>it's not zero extend though?</p>",
        "id": 253637216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820522
    },
    {
        "content": "<p>it's setz</p>",
        "id": 253637234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820529
    },
    {
        "content": "<p>On x86 sure.</p>",
        "id": 253637250,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820537
    },
    {
        "content": "<p>I mean, it's not like you are taking a bit out of the type</p>",
        "id": 253637279,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820549
    },
    {
        "content": "<p>But fundamentally, turning a u8 into a usize is a zero extension.</p>",
        "id": 253637290,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820556
    },
    {
        "content": "<p>you are taking a niche out of the type, which requires a zero test</p>",
        "id": 253637335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820579
    },
    {
        "content": "<p><em>inserts branch</em></p>",
        "id": 253637378,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820600
    },
    {
        "content": "<p>and after the branch, set reg to x or to y</p>",
        "id": 253637503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820646
    },
    {
        "content": "<p>and the values of x and y are basically unconstrained</p>",
        "id": 253637528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820659
    },
    {
        "content": "<p>Except that I can save cycles by not setting the register.</p>",
        "id": 253637623,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820703
    },
    {
        "content": "<p>you have to set the register on at least one branch</p>",
        "id": 253637709,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820725
    },
    {
        "content": "<p>On w65, for example, I'd have to load into the register I'd use anyways (though I then have to store to memory because <code>usize</code> is 4 bytes because why). If the value is zero and the discriminant is zero, I don't have to lda imm, which is 3 saved cycles</p>",
        "id": 253637783,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820764
    },
    {
        "content": "<p>On the nonzero path, I'd have to, yes, but swapping them means I always lose those cycles.</p>",
        "id": 253637884,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820806
    },
    {
        "content": "<p>you can also xor 1, I have no idea if that is faster</p>",
        "id": 253638272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631820970
    },
    {
        "content": "<p>xor is 3 cycles as well.</p>",
        "id": 253638309,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631820986
    },
    {
        "content": "<p>but it seems a bit too hypothetical for me. Most of the time this will be in a branch anyway and then you can orient the comparisons however you like (the discriminant probably won't even be materialized)</p>",
        "id": 253638396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631821021
    },
    {
        "content": "<p>(Yes, I care about being able to save 3 cycles - 3 cycles are 3 cycles, that's like, just over 1/20th of a scanline)</p>",
        "id": 253638469,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631821055
    },
    {
        "content": "<p>how often are you using <code>discriminant()</code> for niche optimized enums though?</p>",
        "id": 253638596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631821088
    },
    {
        "content": "<p>probably you would use <code>is_some()</code> or <code>is_none()</code> instead and then your hand is forced</p>",
        "id": 253638639,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631821106
    },
    {
        "content": "<p><span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 253638660,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631821114
    },
    {
        "content": "<p>honestly, if I found myself writing for such a ridiculously constrained platform I would just use assembly</p>",
        "id": 253638902,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631821213
    },
    {
        "content": "<p>but you do you</p>",
        "id": 253638961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631821239
    },
    {
        "content": "<p>This isn't necessarily a necessary optimization, but I'd rather save 3 cycles in some cases than not save 3 cycles.</p>",
        "id": 253639644,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631821524
    },
    {
        "content": "<p>(It's not memset using <code>,X</code> vs. <code>jsl __add_int32</code>)</p>",
        "id": 253639933,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631821645
    },
    {
        "content": "<p>One way you could desugar it is that <code>discriminant()</code> is a pattern matching function like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">None</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">_</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and it's not an especially privileged one (the user could also write a similar function themselves, with different numbers). Some choices of numbers will optimize better than others, but that's all there is to it</p>",
        "id": 253640121,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631821727
    },
    {
        "content": "<p>hmmm, possibly I misspoke?</p>",
        "id": 253645294,
        "sender_full_name": "Jubilee",
        "timestamp": 1631823908
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/122651-general/topic/Result.20is.20not.20FFI.20safe.20.3F/near/253526588\">said</a>:</p>\n<blockquote>\n<p>Connor is correct for repr(rust), and Thom is correct for repr(C).</p>\n</blockquote>\n<p>I mean enums with no data (that's what I meant by C-style enums). I believe I'm correct for repr(Rust) and repr(C) (and repr(int)). In</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Baz</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Quux</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the value of <code>Foo::Bar as usize</code> is well defined, even though it's not specified in the source. I <em>strongly</em> believe this would be a breaking change (of entirely safe code) to adjust, so even if it's not specified anywhere (and I suspect it <em>is</em>, or it's an oversight if it is not) it cannot be changed.</p>",
        "id": 253660063,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1631830920
    },
    {
        "content": "<p>Yes, this is <a href=\"https://doc.rust-lang.org/stable/reference/items/enumerations.html#custom-discriminant-values-for-fieldless-enumerations\">fully documented in the reference</a> for \"C-style\" (fieldless) enums.<br>\nTo be precise, their exact repr is actually still somewhat ambiguous as the compiler is allowed to use \"whatever works\" (tho it can't use bigger than an isize without a specific repr) but the <code>as</code> cast is well-defined.</p>",
        "id": 253674770,
        "sender_full_name": "Jubilee",
        "timestamp": 1631841171
    },
    {
        "content": "<p>A truly demonic interpretation of the reference may allow e.g. writing the current discriminant in ASCII if a specific <code>repr</code> is not attached to the enum, but it would still have to convert correctly under the <code>as</code> cast.</p>",
        "id": 253674889,
        "sender_full_name": "Jubilee",
        "timestamp": 1631841256
    },
    {
        "content": "<p>so, don't leave fieldless enums underspecified if the thought of the compiler notating them in EBCDIC or whatever gives you the heebie jeebies, but you can at least type-convert it reliably.</p>",
        "id": 253675321,
        "sender_full_name": "Jubilee",
        "timestamp": 1631841638
    }
]