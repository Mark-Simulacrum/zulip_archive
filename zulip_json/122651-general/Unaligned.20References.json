[
    {
        "content": "<p>Hi, I wanted to ask about an issue that concerns pointers/references to objects with non-default alignment. At present, accessing memory that is not sufficiently aligned is unsound, but if Rust had alignment specifiers as part of the type, the correct LLVM IR could be emitted to make this work. This came up in the context of references to fields of packed structs: <a href=\"https://github.com/rust-lang/rust/issues/27060\">https://github.com/rust-lang/rust/issues/27060</a>, in particular <a href=\"https://github.com/rust-lang/rust/issues/27060#issuecomment-1079947107\">https://github.com/rust-lang/rust/issues/27060#issuecomment-1079947107</a>. I was wondering what the Rust team's stance is on the issue and whether an RFC to add such a language feature would be welcomed.</p>",
        "id": 276852183,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648462553
    },
    {
        "content": "<p>Well, one can use raw pointers, if necessary.</p>\n<p>Can you say more about what \"alignment as part of the type\" means? What would the alignment of <code>&amp;T</code> be for some generic <code>T</code>?</p>",
        "id": 276878693,
        "sender_full_name": "Lokathor",
        "timestamp": 1648476702
    },
    {
        "content": "<p>If you have a <code>#[repr(packed)] struct Foo { x: u8, y: u32 }</code>, the <code>y</code> is at an odd address and the reference to <code>y</code> would have a type like <code>&amp;align(1) u32</code>, which carries the information that <code>y</code> is not aligned properly</p>",
        "id": 276886796,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648479835
    },
    {
        "content": "<p><code>&amp;T</code> is then just equivalent to <code>&amp;align(std::mem::align_of::&lt;T&gt;()) T</code></p>",
        "id": 276887661,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648480146
    },
    {
        "content": "<p>That wouldn't really interact well with most of the rest of the rust universe, since it's a separate type. Most code would still only be for naturally aligned references</p>",
        "id": 276887727,
        "sender_full_name": "Lokathor",
        "timestamp": 1648480179
    },
    {
        "content": "<p>That depends. If the alignment specifier is part of the reference then that's true, but it doesn't have to be.<br>\nIf it were part of the referencee type, then <code>&amp;T</code> can be unified with <code>&amp;align(N) U</code>.</p>",
        "id": 276888488,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648480493
    },
    {
        "content": "<p>but <code>align(1)u32</code> is still also a separate type from <code>u32</code>, giving the same problem</p>",
        "id": 276888711,
        "sender_full_name": "Lokathor",
        "timestamp": 1648480596
    },
    {
        "content": "<p>It is, but on the top-level the alignment specifier isn't really very meaningful since values are copied anyway. Do you have something in mind where this could be an issue?</p>",
        "id": 276888890,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648480679
    },
    {
        "content": "<p>Well like you wouldn't be able to use += on a &amp;mut_align(1)u32 unless it was generated as a separate trait instance</p>",
        "id": 276889254,
        "sender_full_name": "Lokathor",
        "timestamp": 1648480824
    },
    {
        "content": "<p>so that takes more compiler time and complexity to generate all these extra instances and functions as necessary.</p>",
        "id": 276889394,
        "sender_full_name": "Lokathor",
        "timestamp": 1648480901
    },
    {
        "content": "<p>and any function that does <code>unsafe</code> stuff can't automatically have the variants because the unsafe might rely on the alignment, which limits how much you can do this quite a bit</p>",
        "id": 276889497,
        "sender_full_name": "Lokathor",
        "timestamp": 1648480949
    },
    {
        "content": "<p>I really think the easiest solution is to just make a <code>read_unaligned!</code> macro that takes a field and then uses <code>addr_of!</code> and then reads the pointer unaligned. And similar for a <code>write_unaligned!</code> macro.</p>",
        "id": 276889670,
        "sender_full_name": "Lokathor",
        "timestamp": 1648481040
    },
    {
        "content": "<p>Hmm, you are right that <code>+=</code> on a <code>&amp;mut align(1) u32</code> wouldn't work as is, though that can of course be fixed by making the code generic on alignment, but I agree that's not ideal<br>\nThen again, I don't know why you would want to do that in the first place, since these underaligned values are meant mainly for use with packed structs, which usually aren't the data that you perform computation with</p>",
        "id": 276889854,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648481127
    },
    {
        "content": "<p>It seems that Rust already has <a href=\"https://doc.rust-lang.org/std/ptr/fn.read_unaligned.html\">https://doc.rust-lang.org/std/ptr/fn.read_unaligned.html</a></p>",
        "id": 276890004,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648481191
    },
    {
        "content": "<p>Yes, the only complication is getting the pointer correctly, which addr_of does</p>",
        "id": 276890728,
        "sender_full_name": "Lokathor",
        "timestamp": 1648481503
    },
    {
        "content": "<p>anyone can make the proposed <code>read_unaligned!</code> macro in normal library code using things the stdlib already provides</p>",
        "id": 276890853,
        "sender_full_name": "Lokathor",
        "timestamp": 1648481542
    },
    {
        "content": "<p>adding a new reference type is a hard sell, especially when a macro will do</p>",
        "id": 276891146,
        "sender_full_name": "mejrs",
        "timestamp": 1648481659
    },
    {
        "content": "<p>note that when <code>addr_of!</code> was added it was done rather than stabilizing <code>&amp;raw</code></p>",
        "id": 276891286,
        "sender_full_name": "mejrs",
        "timestamp": 1648481732
    },
    {
        "content": "<p>Well like I said, I would not put the alignment on the reference, but on the referenced type, so that regular references work as is</p>",
        "id": 276891332,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648481758
    },
    {
        "content": "<p>I suppose you could look at is as packed structs implicitly adding <code>align(1)</code> to the type of all fields</p>",
        "id": 276891661,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648481891
    },
    {
        "content": "<p>But they'd be different types, right? You shouldn't be able to pass <code>&amp;align(1) u32</code> to a function that expects <code>&amp;u32</code>.</p>",
        "id": 276891879,
        "sender_full_name": "mejrs",
        "timestamp": 1648481998
    },
    {
        "content": "<p>That's correct, you couldn't pass a <code>&amp;align(1) u32</code> to a function expecting <code>&amp;u32</code>, but you could pass it to a generic function that expects <code>&amp;T</code>.</p>",
        "id": 276892445,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648482253
    },
    {
        "content": "<p>Hmm I wonder whether that'd work. There's probably quite a bit of code out there relying on <code>T</code> being properly aligned</p>",
        "id": 276893019,
        "sender_full_name": "mejrs",
        "timestamp": 1648482505
    },
    {
        "content": "<p>I definitely expect &amp;T to have <code>align_of::&lt;T&gt;()</code> and have written unsafe code that would be broken if that failed to hold.</p>",
        "id": 276893285,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648482642
    },
    {
        "content": "<p>I suppose in this case perhaps <code>T</code> is <code>align(1) u32</code> though?</p>",
        "id": 276893339,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648482674
    },
    {
        "content": "<p>Oh yeah, I meant that in the case of passing <code>&amp;align(1) u32</code> to a generic function taking <code>&amp;T</code>, the <code>T</code> would take on the type <code>align(1) u32</code></p>",
        "id": 276893504,
        "sender_full_name": "Markus Grech",
        "timestamp": 1648482744
    },
    {
        "content": "<p>Having the alignment on the reference is the right place to do this.  It's like how <code>transmute&lt;[u8; 4], u32&gt;</code> is fine despite the different alignments, but <code>transmute&lt;&amp;[u8; 4], &amp;u32&gt;</code> isn't -- it's the indirection that makes the alignment relevant.</p>\n<p>You could certainly imagine a world where there was even subtyping or coercions to allow you to pass an extra-aligned reference to something expecting a lower-aligned reference.  And then you could have <code>Simd::as_array</code> return an over-aligned reference to the <code>[T; N]</code>, for example.</p>\n<p>But realistically, this isn't going to happen.  Just use a <code>&amp;Packed&lt;u32&gt;</code> with <code>#[repr(packed)] struct Packed(T);</code> if you really want that, or make a newtype around a pointer that has a const-generic alignment guarantee.</p>",
        "id": 276893622,
        "sender_full_name": "scottmcm",
        "timestamp": 1648482790
    },
    {
        "content": "<p>Yeah this feels like it would be a huge addition to the language</p>",
        "id": 276893678,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648482821
    },
    {
        "content": "<p>that doesn't seem sufficiently motivated (since this kind of code is rare)</p>",
        "id": 276893694,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648482828
    }
]