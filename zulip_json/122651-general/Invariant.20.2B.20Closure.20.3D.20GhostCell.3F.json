[
    {
        "content": "<p>Heya! I've been in the weeds for a new data structure I'm making that uses the same \"branding\" idea from the GhostCell paper. It seems that the minimal implementation requires a <code>for&lt;'a&gt;</code> closure as well as an invariant reference. What's interesting to me is I \"feel\" like that invariant reference itself would be enough to use lifetimes for equality comparisons, I'm trying to wrap my head around what that's the case. The generic-lifetime closures seems to be a key here and I don't understand all of its properties. The only thing I can think of is something with the contravariance of closures? Is it because the closure is a \"jail\" that prevents values from leaving it?</p>",
        "id": 277552447,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1648934585
    },
    {
        "content": "<blockquote>\n<p>I \"feel\" like that invariant reference itself would be enough to use lifetimes for equality comparisons</p>\n</blockquote>\n<p>It is enough for that, but you also want a way to produce lifetimes that can't be replicated, and this is generally not possible since they can be arbitrarily shortened before being \"locked\". Generic-lifetime closures (i.e. closures with <code>for&lt;'a&gt;</code> bounds, also called HRTB - Higher rank trait bounds) solve this by requiring the closure to be valid for any lifetime <code>'a</code>, and thus they can't assume that lifetime will be equal or longer than some other lifetime, thus effectively being \"unique\". AFAIK there's another way to solve this: by using macros that create short lived lifetimes that end before the user can even create other lifetimes, thus always being different.</p>",
        "id": 277599841,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1648976516
    },
    {
        "content": "<p>Oooh awesome. Thank you so much for this clarification, that makes a lot more sense!</p>",
        "id": 277658177,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649016085
    },
    {
        "content": "<p>You can have an example of branding lifetimes implemented using a macro instead of a higher-order callback in <a href=\"https://crates.io/crates/generativity/1.0.0\">https://crates.io/crates/generativity/1.0.0</a></p>",
        "id": 277763978,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649092283
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/Invariant.20.2B.20Closure.20.3D.20GhostCell.3F/near/277763978\">said</a>:</p>\n<blockquote>\n<p>You can have an example of branding lifetimes implemented using a macro instead of a higher-order callback in <a href=\"https://crates.io/crates/generativity/1.0.0\">https://crates.io/crates/generativity/1.0.0</a></p>\n</blockquote>\n<p>Oh sweet this is awesome!</p>",
        "id": 277783543,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649101330
    },
    {
        "content": "<p>Kinda uhh, spooky question, but is there a way to turn a <code>T: ?Sized + 'id</code> into a <code>T: ?Sized + 'static</code> at compile time? I'm looking to do <code>TypeId::of</code> and I think with branding it's actually acceptable to get the type ID in this case?</p>",
        "id": 277784591,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649101964
    },
    {
        "content": "<p>Not really; but you could always provide you own helper trait:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">BrandedAny</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">id</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">unbranded_type_id</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span>-&gt; <span class=\"nc\">TypeId</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">BrandedAny</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">MyBrandedType</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">unbranded_type_id</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span>-&gt; <span class=\"nc\">TypeId</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">TypeId</span>::<span class=\"n\">of</span>::<span class=\"o\">&lt;</span><span class=\"n\">MyBrandedType</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and so on</p>",
        "id": 277915203,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649179827
    }
]