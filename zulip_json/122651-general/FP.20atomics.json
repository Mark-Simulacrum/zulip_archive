[
    {
        "content": "<p>Do we have floating point atomics somewhere ?</p>",
        "id": 252190635,
        "sender_full_name": "hannahE2",
        "timestamp": 1630941682
    },
    {
        "content": "<p>No, but you can use <code>to_bits</code>/<code>from_bits</code> to losslessly convert it to an integer.</p>",
        "id": 252192716,
        "sender_full_name": "Amanieu",
        "timestamp": 1630942757
    },
    {
        "content": "<p>That won't work for rmw operations like <code>fetch_add</code>, etc.</p>",
        "id": 252193166,
        "sender_full_name": "hannahE2",
        "timestamp": 1630943003
    },
    {
        "content": "<p>you can always use the CAS loop (i.e. <a href=\"https://doc.rust-lang.org/core/sync/atomic/struct.AtomicU64.html#method.fetch_update\"><code>fetch_update()</code></a>)</p>",
        "id": 252195342,
        "sender_full_name": "kennytm",
        "timestamp": 1630944239
    },
    {
        "content": "<p>there is also an <a href=\"https://docs.rs/atomic_float/0.1.0/atomic_float/\"><code>atomic_float</code></a> package. (its <code>fetch_add</code> is implemented using <code>fetch_update</code>)</p>",
        "id": 252195624,
        "sender_full_name": "kennytm",
        "timestamp": 1630944426
    },
    {
        "content": "<p>that sounds horrible</p>",
        "id": 252201212,
        "sender_full_name": "hannahE2",
        "timestamp": 1630947843
    },
    {
        "content": "<p>at least on hardware with floating point atomics support</p>",
        "id": 252201276,
        "sender_full_name": "hannahE2",
        "timestamp": 1630947894
    },
    {
        "content": "<p>what ISA has atomic floating point instructions <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 252202007,
        "sender_full_name": "kennytm",
        "timestamp": 1630948256
    },
    {
        "content": "<p>There is no hardware that I know of with FP atomic support.</p>",
        "id": 252202271,
        "sender_full_name": "Amanieu",
        "timestamp": 1630948398
    },
    {
        "content": "<p>all gpus in existence ?</p>",
        "id": 252202461,
        "sender_full_name": "hannahE2",
        "timestamp": 1630948501
    },
    {
        "content": "<p>e.g. amdgpu has floating point atomics</p>",
        "id": 252202498,
        "sender_full_name": "hannahE2",
        "timestamp": 1630948516
    },
    {
        "content": "<p>and have had this for as long as I can remember</p>",
        "id": 252202518,
        "sender_full_name": "hannahE2",
        "timestamp": 1630948530
    },
    {
        "content": "<p>those targets can provide their own <code>core::arch</code> intrinsics. the wrapper types can then opt to use by <code>#[cfg]</code></p>",
        "id": 252202678,
        "sender_full_name": "kennytm",
        "timestamp": 1630948617
    },
    {
        "content": "<p>ah so the <code>AtomicF32</code> and <code>AtomicF64</code> are just not implemented yet for those targets, but it is ok to just add them ?</p>",
        "id": 252202826,
        "sender_full_name": "hannahE2",
        "timestamp": 1630948702
    },
    {
        "content": "<p>I think you could do something like that using <code>asm!</code> as an addition to <code>atomic_float</code> package, if you can detect the configuration using <code>#[cfg]</code></p>",
        "id": 252202834,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630948707
    },
    {
        "content": "<p>I'm not sure <code>asm!</code> is right for this, since you probably want to generate LLVM-IR to avoid blocking optimizations</p>",
        "id": 252202872,
        "sender_full_name": "hannahE2",
        "timestamp": 1630948732
    },
    {
        "content": "<p>you could, if it's available, but that requires LLVM support</p>",
        "id": 252202899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630948754
    },
    {
        "content": "<p>yes llvm has supported these since forever</p>",
        "id": 252202949,
        "sender_full_name": "hannahE2",
        "timestamp": 1630948791
    },
    {
        "content": "<p><a href=\"https://llvm.org/docs/LangRef.html#atomicrmw-instruction\">https://llvm.org/docs/LangRef.html#atomicrmw-instruction</a></p>",
        "id": 252203946,
        "sender_full_name": "Amanieu",
        "timestamp": 1630949327
    },
    {
        "content": "<p>Apparently atomic <code>fadd</code>/<code>fsub</code> is a thing, huh.</p>",
        "id": 252203978,
        "sender_full_name": "Amanieu",
        "timestamp": 1630949346
    },
    {
        "content": "<p>I think it would be reasonable to add <code>AtomicF32</code>/<code>AtomicF64</code> types since it is natively supported in at least some hardware and we can always lower it to a cmpxchg loop otherwise.</p>",
        "id": 252204244,
        "sender_full_name": "Amanieu",
        "timestamp": 1630949506
    },
    {
        "content": "<p>I'd rather only have these on platforms on which they make sense</p>",
        "id": 252206366,
        "sender_full_name": "hannahE2",
        "timestamp": 1630950929
    },
    {
        "content": "<p>When using the atomics, getting a CAS loop generated isn't something I'd expect</p>",
        "id": 252206531,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951030
    },
    {
        "content": "<p>It changes the progress condition</p>",
        "id": 252206726,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951164
    },
    {
        "content": "<p>e.g. a \"malevolent\" scheduler can schedule all threads in a CAS loop such that the program deadlocks</p>",
        "id": 252206763,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951195
    },
    {
        "content": "<p>The whole point of the types is to allow portable code. If you want types that only exist on some architectures, they should exist elsewhere, like in <code>core::arch</code></p>",
        "id": 252206842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630951213
    },
    {
        "content": "<p>These types are already not portable, and only usable in archs that support them</p>",
        "id": 252206899,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951244
    },
    {
        "content": "<p>In particular, I don't think that the atomics make any wait freedom guarantees, specifically to allow CAS loop implementations</p>",
        "id": 252206921,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630951260
    },
    {
        "content": "<p>We don't use locks and guarantee so much</p>",
        "id": 252206948,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951280
    },
    {
        "content": "<p>as opposed to, e.g., C++ atomics that can use locks internally</p>",
        "id": 252206958,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951289
    },
    {
        "content": "<p>From the doc (emphasis mine):</p>\n<blockquote>\n<p>All atomic types in this module are guaranteed to be lock-free <em>if theyâ€™re available</em>.... Atomic types and operations are not guaranteed to be wait-free.</p>\n</blockquote>",
        "id": 252207052,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630951344
    },
    {
        "content": "<blockquote>\n<p>All atomic types in this module are guaranteed to be [lock-free] if they're<br>\navailable. This means they don't internally acquire a global mutex. Atomic<br>\ntypes and operations are not guaranteed to be wait-free. This means that<br>\noperations like <code>fetch_or</code> may be implemented with a compare-and-swap loop.</p>\n<p>Atomic operations may be implemented at the instruction layer with<br>\nlarger-size atomics. For example some platforms use 4-byte atomic<br>\ninstructions to implement <code>AtomicI8</code>. Note that this emulation should not<br>\nhave an impact on correctness of code, it's just something to be aware of.</p>\n<p>The atomic types in this module may not be available on all platforms. The<br>\natomic types here are all widely available, however, and can generally be<br>\nrelied upon existing. Some notable exceptions are:</p>\n<ul>\n<li>PowerPC and MIPS platforms with 32-bit pointers do not have <code>AtomicU64</code> or<br>\n<code>AtomicI64</code> types.</li>\n<li>ARM platforms like <code>armv5te</code> that aren't for Linux only provide <code>load</code><br>\n  and <code>store</code> operations, and do not support Compare and Swap (CAS)<br>\n  operations, such as <code>swap</code>, <code>fetch_add</code>, etc. Additionally on Linux,<br>\n  these CAS operations are implemented via [operating system support], which<br>\n  may come with a performance penalty.</li>\n<li>ARM targets with <code>thumbv6m</code> only provide <code>load</code> and <code>store</code> operations,<br>\n  and do not support Compare and Swap (CAS) operations, such as <code>swap</code>,<br>\n<code>fetch_add</code>, etc.</li>\n</ul>\n<p>[operating system support]: <a href=\"https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt\">https://www.kernel.org/doc/Documentation/arm/kernel_user_helpers.txt</a></p>\n<p>Note that future platforms may be added that also do not have support for<br>\nsome atomic operations. Maximally portable code will want to be careful<br>\nabout which atomic types are used. <code>AtomicUsize</code> and <code>AtomicIsize</code> are<br>\ngenerally the most portable, but even then they're not available everywhere.<br>\nFor reference, the <code>std</code> library requires pointer-sized atomics, although<br>\n<code>core</code> does not.</p>\n</blockquote>",
        "id": 252207085,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951364
    },
    {
        "content": "<p>The docs already say that some operations may use a CAS loop.</p>",
        "id": 252207112,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951378
    },
    {
        "content": "<p>And that they might not be available on all platforms.</p>",
        "id": 252207132,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951391
    },
    {
        "content": "<p>Indeed, then nvm, these atomic types are useless to me. I need wait-free atomics.</p>",
        "id": 252207149,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951402
    },
    {
        "content": "<p>The doc promise seems very reasonable to me: if you aren't getting wait-free atomics, then it is impossible to do so because the hardware doesn't support it</p>",
        "id": 252207235,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1630951447
    },
    {
        "content": "<p>I'd rather use a lock, and design my algorithm differently, than a CAS loop.</p>",
        "id": 252207259,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951468
    },
    {
        "content": "<p>So the atomics I need, need to fail to compile if there is no wait-free implementation.</p>",
        "id": 252207298,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951505
    },
    {
        "content": "<p>I wonder if std could support that with a cfg flag.</p>",
        "id": 252207351,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951551
    },
    {
        "content": "<p>I think having atomics that are not wait free, and or use locks internally, are abstractions that make sense.</p>",
        "id": 252207447,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951608
    },
    {
        "content": "<p>Yes, but probably not in std.</p>",
        "id": 252207474,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951632
    },
    {
        "content": "<p>You can build such abstractions on top of wait-free atomic memory ops, but you can't build wait-free atomic memory ops on top of such abstractions.</p>",
        "id": 252207476,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951634
    },
    {
        "content": "<blockquote>\n<p>Yes, but probably not in std.</p>\n</blockquote>\n<p>Maybe? It wouldn't be necessary, but it is a common enough thing to want.</p>",
        "id": 252207594,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951699
    },
    {
        "content": "<p>I guess the \"not in std\" argument can be made about <code>AtomicI32</code> as well....</p>",
        "id": 252207624,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951726
    },
    {
        "content": "<p>You can implement <code>AtomicI32</code> as a library if you had atomic memory operations...</p>",
        "id": 252207642,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951743
    },
    {
        "content": "<p>but the other way around is not true...</p>",
        "id": 252207651,
        "sender_full_name": "hannahE2",
        "timestamp": 1630951752
    },
    {
        "content": "<p>Well, the current atomic types appeal to the majority of use cases.</p>",
        "id": 252207805,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951866
    },
    {
        "content": "<p>And actually provide stronger guarantees than C++.</p>",
        "id": 252207838,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951888
    },
    {
        "content": "<p>Guaranteed wait-free atomics is a much less common requirement.</p>",
        "id": 252207859,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630951911
    },
    {
        "content": "<blockquote>\n<p>Well, the current atomic types appeal to the majority of use cases.</p>\n</blockquote>\n<p>Is there a poll of all programmers in the world about this somewhere? Most programers never use atomics, and most code using atomics that I see in the wild still uses <code>volatile</code> over atomics...</p>",
        "id": 252208269,
        "sender_full_name": "hannahE2",
        "timestamp": 1630952164
    },
    {
        "content": "<blockquote>\n<p>And actually provide stronger guarantees than C++.</p>\n</blockquote>\n<p>C++ <code>atomic_ref</code> provides more guarantees that Rust atomic types, is more flexible since it exposes memory operations, etc.</p>",
        "id": 252208319,
        "sender_full_name": "hannahE2",
        "timestamp": 1630952199
    },
    {
        "content": "<blockquote>\n<p>Is there a poll of all programmers in the world about this somewhere? </p>\n</blockquote>\n<p>Sorry, should have added a \"probably\" there.</p>",
        "id": 252209126,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1630952707
    },
    {
        "content": "<p>I recently learned that even <code>Atomic*::load</code> may be lowered to a CAS by llvm, I was very much surprised by that.</p>",
        "id": 252209815,
        "sender_full_name": "The 8472",
        "timestamp": 1630953165
    },
    {
        "content": "<p>It can be loaded to CAS, but not to a CAS loop</p>",
        "id": 252210931,
        "sender_full_name": "hannahE2",
        "timestamp": 1630953892
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">sync</span>::<span class=\"n\">atomic</span>::<span class=\"p\">{</span><span class=\"n\">AtomicU64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">atomic_min</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">AtomicU64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">u64</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u64</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">fetch_min</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span>::<span class=\"n\">Relaxed</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is compiled to <code>atomicrmw umin</code> in LLVM</p>\n<div class=\"codehilite\" data-code-language=\"LLVM\"><pre><span></span><code><span class=\"k\">define</span> <span class=\"kt\">i64</span> <span class=\"vg\">@_ZN10playground10atomic_min17h4230d9a8926eda10E</span><span class=\"p\">(</span><span class=\"nv\">%\"std::sync::atomic::AtomicU64\"</span><span class=\"p\">*</span> <span class=\"k\">nocapture</span> <span class=\"k\">align</span> <span class=\"m\">8</span> <span class=\"k\">dereferenceable</span><span class=\"p\">(</span><span class=\"m\">8</span><span class=\"p\">)</span> <span class=\"nv\">%a</span><span class=\"p\">,</span> <span class=\"kt\">i64</span> <span class=\"nv\">%b</span><span class=\"p\">)</span> <span class=\"k\">unnamed_addr</span> <span class=\"vg\">#0</span> <span class=\"p\">{</span>\n<span class=\"nl\">start:</span>\n  <span class=\"nv\">%_5.i</span> <span class=\"p\">=</span> <span class=\"k\">getelementptr</span> <span class=\"k\">inbounds</span> <span class=\"nv\">%\"std::sync::atomic::AtomicU64\"</span><span class=\"p\">,</span> <span class=\"nv\">%\"std::sync::atomic::AtomicU64\"</span><span class=\"p\">*</span> <span class=\"nv\">%a</span><span class=\"p\">,</span> <span class=\"kt\">i64</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"kt\">i32</span> <span class=\"m\">0</span><span class=\"p\">,</span> <span class=\"kt\">i64</span> <span class=\"m\">0</span>\n  <span class=\"nv nv-Anonymous\">%0</span> <span class=\"p\">=</span> <span class=\"k\">atomicrmw</span> <span class=\"k\">umin</span> <span class=\"kt\">i64</span><span class=\"p\">*</span> <span class=\"nv\">%_5.i</span><span class=\"p\">,</span> <span class=\"kt\">i64</span> <span class=\"nv\">%b</span> <span class=\"k\">monotonic</span>\n  <span class=\"k\">ret</span> <span class=\"kt\">i64</span> <span class=\"nv nv-Anonymous\">%0</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n<p>which is compiled to a loop in x86_64.</p>\n<div class=\"codehilite\" data-code-language=\"GAS\"><pre><span></span><code><span class=\"nl\">playground:</span><span class=\"err\">:</span><span class=\"nl\">atomic_min:</span>\n    <span class=\"nf\">mov</span> <span class=\"no\">rax</span><span class=\"p\">,</span> <span class=\"no\">qword</span> <span class=\"no\">ptr</span> <span class=\"p\">[</span><span class=\"no\">rdi</span><span class=\"p\">]</span>\n\n<span class=\"nl\">.LBB0_1:</span>\n    <span class=\"nf\">cmp</span> <span class=\"no\">rax</span><span class=\"p\">,</span> <span class=\"no\">rsi</span>\n    <span class=\"nf\">mov</span> <span class=\"no\">rcx</span><span class=\"p\">,</span> <span class=\"no\">rsi</span>\n    <span class=\"nf\">cmovbe</span>  <span class=\"no\">rcx</span><span class=\"p\">,</span> <span class=\"no\">rax</span>\n    <span class=\"na\">lock</span>        <span class=\"nf\">cmpxchg</span> <span class=\"no\">qword</span> <span class=\"no\">ptr</span> <span class=\"p\">[</span><span class=\"no\">rdi</span><span class=\"p\">],</span> <span class=\"no\">rcx</span>\n    <span class=\"nf\">jne</span> <span class=\"no\">.LBB0_1</span>\n    <span class=\"nf\">ret</span>\n</code></pre></div>",
        "id": 252212369,
        "sender_full_name": "kennytm",
        "timestamp": 1630954903
    },
    {
        "content": "<p>rmw obviosuly have to be lowered to CAS loop if they are not natively supported, but <span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> is talking about load.</p>",
        "id": 252212810,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630955178
    },
    {
        "content": "<p>AtomicU128 on AArch64 uses a loop for load: <a href=\"https://rust.godbolt.org/z/hWz5hWdbE\">https://rust.godbolt.org/z/hWz5hWdbE</a></p>",
        "id": 252228103,
        "sender_full_name": "Amanieu",
        "timestamp": 1630966576
    },
    {
        "content": "<p>Does this mean ldxp performs two atomic 64-bit reads instead of an atomic 128 bit read, so stxp is used to confirm that indeed nothing happens in between these two reads?</p>",
        "id": 252228332,
        "sender_full_name": "Gary Guo",
        "timestamp": 1630966805
    },
    {
        "content": "<p>Yes, essentially.</p>",
        "id": 252228845,
        "sender_full_name": "Amanieu",
        "timestamp": 1630967340
    },
    {
        "content": "<p>Though on ARMv8.4 (not sure about the exact version) this is no longer needed and <code>ldp</code> (load pair) is guaranteed to be atomic.</p>",
        "id": 252228873,
        "sender_full_name": "Amanieu",
        "timestamp": 1630967388
    },
    {
        "content": "<p>Right, but that's because AArch64 &lt; v8.4 (1) does not support 128-bit atomics properly, and (2) we work around it using something that can be super expensive and implicitly changes the progress guarantees of user programs when going from, e.g., x64 to aarch64 &lt; 8.4...</p>",
        "id": 252261111,
        "sender_full_name": "hannahE2",
        "timestamp": 1630998671
    },
    {
        "content": "<p>If your algorithm requires wait-free atomics for correctness, and you test it on x64 and don't realize this, then on aarch64 your algorithm might \"break\" (probably not in a way that it introduces UB, but in a way that makes it useless for what it aimed to do).</p>",
        "id": 252261299,
        "sender_full_name": "hannahE2",
        "timestamp": 1630998799
    },
    {
        "content": "<p>Most people don't reason about the progress guarantees of their algos, but rather just test them properly on the hardware they have available and hope for the best.</p>",
        "id": 252261574,
        "sender_full_name": "hannahE2",
        "timestamp": 1630998969
    },
    {
        "content": "<p>AFAIK there is no algorithm that actually requires wait-free atomics for correctness. Lock-free is enough in all cases.</p>",
        "id": 252268280,
        "sender_full_name": "Amanieu",
        "timestamp": 1631002830
    },
    {
        "content": "<p>right, <span class=\"user-mention\" data-user-id=\"125254\">@kennytm</span>  when doing a load, on some hardware you can emit both an atomic load instruction, but also a <code>old = CAS(val, val)</code> (a CAS that does not modify the source). </p>\n<p>LLVM can generate CAS instead of load in some cases to improve, e.g., stack frame alignment, etc.</p>",
        "id": 252447348,
        "sender_full_name": "hannahE2",
        "timestamp": 1631102422
    }
]