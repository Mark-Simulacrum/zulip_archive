[
    {
        "content": "<p>Hi Folks,<br>\nI have a use case where I need to embed a Url in a data structure. This Url is static. <a href=\"https://docs.rs/url/2.2.2/url/struct.Url.html#method.parse\">Url::parse()</a> is fallible and not <code>const</code> so right now I'm performing the parse as part of a runtime call. Ideally I'd like this to fail at compile time if for some reason this Url starts to not parse for some reason. Does anyone know of options for this? My fallback idea was a unit test with an assert on a Url::parse() of the candidate Url stored as a const str.</p>",
        "id": 260731084,
        "sender_full_name": "Blake Johnson",
        "timestamp": 1636412300
    },
    {
        "content": "<p>Big Bad Idea ahead: </p>\n<p>a proc macro <code>const_url!(input)</code> that calls <code>Url::parse</code>, checks and displays eventual errors, then emits <code>Url::parse(input)</code> as the macro output (so the Url is still parsed at runtime, but was checked at compile time)</p>",
        "id": 260806348,
        "sender_full_name": "Antoine Martin",
        "timestamp": 1636468775
    },
    {
        "content": "<p>(it's ugly and I don't think it's worth the additional compilation guarantees though <span aria-label=\"grimacing\" class=\"emoji emoji-1f62c\" role=\"img\" title=\"grimacing\">:grimacing:</span> )</p>",
        "id": 260806485,
        "sender_full_name": "Antoine Martin",
        "timestamp": 1636468817
    },
    {
        "content": "<p>you could parse the URL in <code>build.rs</code> and panic if the URL doesn't parse, which would explode out into a compile error.</p>",
        "id": 260820940,
        "sender_full_name": "Lokathor",
        "timestamp": 1636474387
    },
    {
        "content": "<p>The simplest approach here would be to auto-generate a (doc-)test that parses the Url. The more proper approach would be to submit a PR to <code>::url</code> with a <code>const fn</code> version of the parsing, or, if you don't want to go that far, to use a proc-macro to call <code>Url::parse()</code> at its runtime. Or a <code>build.rs</code>, where it's easier to write the code, but the call-sites would become way more cumbersome.</p>\n<p>Here is an example of option 1, which can be implemented as simply as with just a <code>macro_rules!</code> macro:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">test_checked_url</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$url</span>:<span class=\"nc\">literal</span><span class=\"w\"> </span><span class=\"cp\">$(,</span><span class=\"p\">)</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">({</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[doc = concat!(</span><span class=\"s\">\"```rust</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"cp\">, stringify! {</span>\n<span class=\"cp\">        let _ = ::url::Url::parse($url).unwrap_or_else(|err| {</span>\n<span class=\"cp\">            panic!(</span><span class=\"s\">\"Failed to parse {:?} as a URL: {}\"</span><span class=\"cp\">, $url, err);</span>\n<span class=\"cp\">        });</span>\n<span class=\"cp\">    }, </span><span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\">```\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span>::<span class=\"n\">url</span>::<span class=\"n\">Url</span>::<span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"cp\">$url</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">})}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43a7c53b70b9745821d8b1a9fa608766\">Playground</a></li>\n</ul>",
        "id": 260856325,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636489865
    },
    {
        "content": "<p>Or if you want to go extra fancy: implement a custom lint pass (dylint) that would detect <code>Url::parse(&lt;incorrect literal&gt;)</code> invocations <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 260856862,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636490122
    },
    {
        "content": "<p>sounds a lot like the old compile-time <code>regex!</code> macro</p>",
        "id": 260867465,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1636494929
    },
    {
        "content": "<p>thanks for the answers and ideas folks - wanted to add as well that I found an issue on the <code>url</code> crate that discusses why this is not functionality that it provides now <a href=\"https://github.com/servo/rust-url/issues/652\">https://github.com/servo/rust-url/issues/652</a></p>",
        "id": 261086175,
        "sender_full_name": "Blake Johnson",
        "timestamp": 1636598370
    },
    {
        "content": "<p>If anyone is curious â€” a main reason is that <code>Url</code>s contain the url string as a <code>String</code> inside them, so parsing requires allocation</p>",
        "id": 261091968,
        "sender_full_name": "Nathaniel",
        "timestamp": 1636604674
    }
]