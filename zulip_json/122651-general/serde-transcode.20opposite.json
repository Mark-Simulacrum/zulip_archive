[
    {
        "content": "<p>Is there something like opposite of serde-transcode? Serde transcode can transform one serialized format to other one without going through intermediate structure, ie. Deserialize -&gt; serialize. I want to transform one struct into another through serde, ie. Serialize -&gt; deserialize. Basically I am looking for JSON.parse(JSON.stringify(val)) equivalent, without going through the serialized string.</p>",
        "id": 262191872,
        "sender_full_name": "panstromek",
        "timestamp": 1637426020
    },
    {
        "content": "<p><code>.clone()</code>?</p>",
        "id": 262193110,
        "sender_full_name": "The 8472",
        "timestamp": 1637427569
    },
    {
        "content": "<p>No, the point is that the input structure is different than the output one</p>",
        "id": 262193511,
        "sender_full_name": "panstromek",
        "timestamp": 1637427925
    },
    {
        "content": "<p>That's also the case in the JavaScript version btw.</p>",
        "id": 262193602,
        "sender_full_name": "panstromek",
        "timestamp": 1637428046
    },
    {
        "content": "<p>I'm not sure if that's possible <code>Deserialize</code> implementations can specify that they borrow bytes from the serialized form so the borrow has to come from somewhere which normally is the &amp;[u8]</p>",
        "id": 262195677,
        "sender_full_name": "The 8472",
        "timestamp": 1637430782
    },
    {
        "content": "<p>If you use serde_json, such code can't borrow it from somewhere either.</p>",
        "id": 262198227,
        "sender_full_name": "bjorn3",
        "timestamp": 1637433739
    },
    {
        "content": "<p>Why do you want to use serde for this? (instead of converting between the structs directly)</p>",
        "id": 262211219,
        "sender_full_name": "Félix Saparelli",
        "timestamp": 1637451673
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"453559\">Félix Saparelli</span> <a href=\"#narrow/stream/122651-general/topic/serde-transcode.20opposite/near/262211219\">said</a>:</p>\n<blockquote>\n<p>Why do you want to use serde for this? (instead of converting between the structs directly)</p>\n</blockquote>\n<p>It's more like an idea I was curious about. I implemented Serialize for Sqlite row, which allows me to quickly serialize it without going through intermediate Rust struct, which I don't need most of the time. So the idea is that I could use something like this if I actually want rust struct, just by defining the struct with derive(Deserialize) and  running the Sqlite row through serialize-deserialize chain.</p>",
        "id": 262226825,
        "sender_full_name": "panstromek",
        "timestamp": 1637479639
    },
    {
        "content": "<p>The \"right\" way to do this would be to implement Deserializer for Sqlite row directly (which is what <code>serde-wasm-bindgen</code> does, I think, that's a similar idea).</p>",
        "id": 262226883,
        "sender_full_name": "panstromek",
        "timestamp": 1637479771
    },
    {
        "content": "<p>but <code>serde-transcode</code> opposite would be more general solution</p>",
        "id": 262226938,
        "sender_full_name": "panstromek",
        "timestamp": 1637479866
    },
    {
        "content": "<p>Because both <code>Serialize</code> and <code>Deserialize</code> are internal functions they can't be directly plugged into one another. <code>serde-transcode</code> works because <code>Deserializer</code> is an external API, so it can easily become <code>Serialize</code>, an internal API, simply by writing the driver code. There could also theoretically be another crate that wraps an implementation of <code>Serializer</code> and implements <code>Deserialize</code>, though I don't know if it exists. Either way, to bridge the two internal functions you would need to use channels, or an intermediary data structure. Or alternatively you could implement <code>Deserializer</code> on that data structure and then pass it to that function.</p>",
        "id": 262510388,
        "sender_full_name": "Kestrer",
        "timestamp": 1637699862
    },
    {
        "content": "<p>I couldn't resist and tried to implement this by implementing Serializer-Deserializer pair (Deserializer calls <code>input.serialize()</code> and passes custom Serializer to it, which calls visitor methods like <code>serialize_bool -&gt; visitor.deserialize_bool</code>). It works for simple cases like primitive types, but for anything nested and more complicated the lifetimes just make it impossible without intermediate data structure. Even a simple case like <code>serialize_some -&gt; visit_some</code> turned out to be difficult to implement this way.</p>",
        "id": 262558577,
        "sender_full_name": "panstromek",
        "timestamp": 1637742958
    },
    {
        "content": "<p>I tried, too. The problem is - I think - that both the <code>Serialize</code> and <code>Deserialize</code> implementation each can use their own stack frame(s) throughout the entire duration of the (de)serialization process. So to connect the two, you'd need two separate threads that communicate over some channel, or some form of green-thread (some ways to have two stacks and cooperative multitasking between them). Or an <code>async</code> trait equivalent of serde's traits. The alternative is to use an intermediate in-memory representation, so you can do the full serialization first, and deserialization only afterwards.</p>",
        "id": 262562181,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1637745022
    }
]