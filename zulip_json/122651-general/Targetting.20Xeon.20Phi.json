[
    {
        "content": "<p>A friend of mine is letting me try his Xeon Phi, and I'm trying to figure out if it's possible to target it with Rust. He said that it uses a K1OM architecture, and runs uLinux. What steps can I take to figure out how to compile for it?</p>",
        "id": 259398403,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1635431971
    },
    {
        "content": "<p>Does LLVM even support that?</p>",
        "id": 259399271,
        "sender_full_name": "Lauren»õiu",
        "timestamp": 1635432303
    },
    {
        "content": "<p>It might not, I'm trying to figure out where to look. I suppose it would be good to start looking there <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 259400067,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1635432592
    },
    {
        "content": "<p>You need the right -Ctarget-cpu value I believe.</p>",
        "id": 259403263,
        "sender_full_name": "bjorn3",
        "timestamp": 1635433794
    },
    {
        "content": "<p>Which generation of Phi?</p>",
        "id": 259409894,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1635436519
    },
    {
        "content": "<p>The model is 71s1p I believe</p>",
        "id": 259413087,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1635437775
    },
    {
        "content": "<p>So \"Knight's Corner\" I think?</p>",
        "id": 259413763,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1635438093
    },
    {
        "content": "<p>I can find a knl target cpu (knights landing) but that is too new. I can't find any other xeon phi target cpu.</p>",
        "id": 259440364,
        "sender_full_name": "bjorn3",
        "timestamp": 1635449574
    },
    {
        "content": "<p>for reference: <a href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86.td\">https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86.td</a></p>",
        "id": 259440394,
        "sender_full_name": "bjorn3",
        "timestamp": 1635449589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122651-general/topic/Targetting.20Xeon.20Phi/near/259440394\">said</a>:</p>\n<blockquote>\n<p>for reference: <a href=\"https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86.td\">https://github.com/llvm/llvm-project/blob/main/llvm/lib/Target/X86/X86.td</a></p>\n</blockquote>\n<p>cheers, I'll check this out. I'm playing around on it now, so I'm seeing where I can get.</p>",
        "id": 259446564,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1635452449
    },
    {
        "content": "<p>Hello Everyone <br>\nHow to write a pass in rust compiler ?<br>\nThanks in Advance.</p>",
        "id": 259486632,
        "sender_full_name": "Soham Dixit",
        "timestamp": 1635488022
    },
    {
        "content": "<p>So my friend has been playing more with the Phi, and has gotten C code to compile for it, and has also compiled Python to run on it. His current technique involves using a custom version of GCC that is designed to target the Phi, and compiling stuff with that. Right now, he's trying to get Rust to compile to it by using the GCC backend instead of LLVM, and is using a project called mrustc as a test. But I'm wondering if it should be possible to swap in GCC as the backend using <code>rustc_codegen_gcc</code>: <a href=\"https://github.com/rust-lang/compiler-team/issues/442\">https://github.com/rust-lang/compiler-team/issues/442</a></p>\n<p>He wrote a blog post for more context: <a href=\"https://aidancrowther.com/project/xeonphi\">https://aidancrowther.com/project/xeonphi</a></p>",
        "id": 260663022,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1636381494
    },
    {
        "content": "<p>cg_gcc requires a couple of patches to libgccjit. It may be possible to backport them to whatever old version of gcc k1om-mpss-linux-gcc is, but I have no idea how hard it will be. The not yet landed patches can be found at <a href=\"https://github.com/antoyo/gcc\">https://github.com/antoyo/gcc</a>. I believe there is also one patch that has already landed upstream. cc <span class=\"user-mention\" data-user-id=\"404242\">@antoyo</span></p>",
        "id": 260711703,
        "sender_full_name": "bjorn3",
        "timestamp": 1636402206
    },
    {
        "content": "<p>Update: we have Rust compiled to WASM running on the Phi, we're going to play around with this a bit and see what cool stuff we can do on it</p>",
        "id": 260858720,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1636491029
    },
    {
        "content": "<p>(currently it's just using a WASM interpreter I think, but the proof of concept is going well)</p>",
        "id": 260859022,
        "sender_full_name": "Forest Anderson [he/him]",
        "timestamp": 1636491183
    },
    {
        "content": "<p>Just wanted to pipe up to say that I am following this message chain, thanks for all the tips</p>",
        "id": 260939594,
        "sender_full_name": "Aidan Crowther",
        "timestamp": 1636514123
    },
    {
        "content": "<p>I also have a Knight's corner xeon phi and was hoping to get rust to target it. There was at one point a fork of llvm that worked for knc and I think it might have been in this repo: <a href=\"https://github.com/ispc/ispc\">https://github.com/ispc/ispc</a> but it's been awhile since investigating.</p>\n<p>I would just like to be able to target x86_64 but cut out the instructions that are incompatible with knc like the cmov instruction. I don't know how to make llvm do that however.</p>",
        "id": 262158978,
        "sender_full_name": "Evan Richter",
        "timestamp": 1637378223
    },
    {
        "content": "<p>It's not the ideal target, but you could use 486.</p>",
        "id": 262167092,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1637390735
    },
    {
        "content": "<p>do we have a 486 target or just 586</p>",
        "id": 262167304,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637391119
    },
    {
        "content": "<p><code>rustc --print target-list | grep 486</code> is empty</p>",
        "id": 262167356,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637391154
    },
    {
        "content": "<p>Target spec files for <code>i386-unknown-linux-gnu</code> and <code>i486-unknown-linux-gnu</code> were added in <a href=\"https://github.com/rust-lang/rust/issues/80662\">#80662</a> but never referenced.</p>",
        "id": 262167763,
        "sender_full_name": "Hans Kratz",
        "timestamp": 1637391762
    },
    {
        "content": "<p>hm, presumably thats a bug?</p>",
        "id": 262169087,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1637393904
    },
    {
        "content": "<p>The downside to i486 is that it can only address 4Gb of the 16Gb of memory available since it's 32 bit. I will definitely try at least and report back.</p>\n<p>As long as I can dispatch handwritten knc instructions (the pre avx-512 kind) from a 32-bit process that would be a good start</p>",
        "id": 262174053,
        "sender_full_name": "Evan Richter",
        "timestamp": 1637401335
    },
    {
        "content": "<p>Would something silly like 486 + SSE + ... work?</p>",
        "id": 262174482,
        "sender_full_name": "The 8472",
        "timestamp": 1637402084
    },
    {
        "content": "<p>Why not just x86_64 -cmov?</p>",
        "id": 262188123,
        "sender_full_name": "cuviper",
        "timestamp": 1637420939
    },
    {
        "content": "<p>(You'll need cargo <code>-Zbuild-std</code> to remove the feature everywhere.)</p>",
        "id": 262188221,
        "sender_full_name": "cuviper",
        "timestamp": 1637421079
    },
    {
        "content": "<blockquote>\n<p>Would something silly like 486 + SSE + ... work?</p>\n</blockquote>\n<p>Not for the 512 bit instructions, since the encodings differ from avx-512. And I think usize will be u32 and not u64.</p>\n<blockquote>\n<p>Why not just x86_64 -cmov?</p>\n</blockquote>\n<p>Might have been an llvm bug I experienced ~ a year ago, but that never actually disabled cmov. Might have been because cmov is part of the base x64 spec</p>",
        "id": 262188222,
        "sender_full_name": "Evan Richter",
        "timestamp": 1637421081
    },
    {
        "content": "<p>It's certainly worth another shot since rustc has upgraded llvm a few times since last I tried</p>",
        "id": 262188281,
        "sender_full_name": "Evan Richter",
        "timestamp": 1637421138
    },
    {
        "content": "<p>Ah, I only checked that it's accepted as a feature, not whether it works. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 262188284,
        "sender_full_name": "cuviper",
        "timestamp": 1637421149
    }
]