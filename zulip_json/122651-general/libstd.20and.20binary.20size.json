[
    {
        "content": "<p>I was reading <a href=\"https://github.com/johnthagen/min-sized-rust#optimize-libstd-with-build-std\">https://github.com/johnthagen/min-sized-rust#optimize-libstd-with-build-std</a> and found this tidbit: \"It's not possible to remove portions of libstd that are not used in a particular application\".</p>\n<p>I'm wondering why this is the case? I have the impression that linkers are generally smart enough to discard things that are not needed in the final binary. What stops that from happening in Rust?</p>",
        "id": 253565722,
        "sender_full_name": "Wei Liu",
        "timestamp": 1631791680
    },
    {
        "content": "<p>It is a slightly confusing statement. These portions of libstd are reachable, but only in exceptional cases. Take for example</p>\n<blockquote>\n<p>Remove panic String Formatting with panic_immediate_abort</p>\n</blockquote>\n<p>This removes part of libstd that is used to format panic messages when panicking. Your program likely won't panic, but there is no guarantee and as such the compiler is not allowed to remove this, because doing so would change behavior in the case that a panic does happen.</p>",
        "id": 253569095,
        "sender_full_name": "bjorn3",
        "timestamp": 1631793365
    },
    {
        "content": "<p>Note that even a program with an empty <code>main</code> function can panic. For example if libc were to call into <code>main</code> twice, this assertion would fire:</p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys_common/thread_info.rs#L40\">https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys_common/thread_info.rs#L40</a></p>\n<p>Or libc could return a nonsensical page size:</p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys/unix/thread.rs#L452\">https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys/unix/thread.rs#L452</a></p>\n<p>Or it could return an error from any of the pthread functions in the same file.</p>",
        "id": 253569670,
        "sender_full_name": "bjorn3",
        "timestamp": 1631793629
    },
    {
        "content": "<p>It is unlikely to happen, but the compiler can't remove the panic message formatting code just in case it does happen.</p>",
        "id": 253569812,
        "sender_full_name": "bjorn3",
        "timestamp": 1631793697
    },
    {
        "content": "<p>min-sized-rust also suggests using <code>#![no_std]</code> which will disable certain safety mechanisms of libstd like adding a guard page to prevent stack clash attacks, add a SIGSEGV signal handler to give a nice message when a stack overflow happens. Santizing fds to ensure that if the invoking process closed stdin, stdout or stderr attempts to read from/write to any of these won't cause a file opened by the current process to be read from/written to instead, which can be a security issue. Libstd also prevents SIGPIPE from killing the current process.</p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys_common/rt.rs#L14-L26\">https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys_common/rt.rs#L14-L26</a></p>\n<p><a href=\"https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys/unix/mod.rs#L53-L125\">https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/library/std/src/sys/unix/mod.rs#L53-L125</a></p>",
        "id": 253570427,
        "sender_full_name": "bjorn3",
        "timestamp": 1631794008
    },
    {
        "content": "<p>These are basically the reasons min-sized-rust is not the default, but if you are willing to accept these limitations, it is completely fine to use it to reduce binary size.</p>",
        "id": 253570626,
        "sender_full_name": "bjorn3",
        "timestamp": 1631794119
    },
    {
        "content": "<blockquote>\n<p>libstd also prevents SIGPIPE from killing the current process?</p>\n</blockquote>\n<p>Wouldn't that impact something like <code>cat</code>, that relies on the signal to terminate the stream early if you send an infinite stream to a finite output (such as <code>cat /dev/random | head -c 64</code>)? Or is that handled by <code>std::io</code>?</p>",
        "id": 253578123,
        "sender_full_name": "Connor Horman",
        "timestamp": 1631797638
    },
    {
        "content": "<p>In that case EPIPE is returned by the stdout write. <code>println!()</code> panics on errors during writing.</p>",
        "id": 253580189,
        "sender_full_name": "bjorn3",
        "timestamp": 1631798505
    },
    {
        "content": "<p>And yes, you will get a panic instead of silent abort due to this code.</p>",
        "id": 253580294,
        "sender_full_name": "bjorn3",
        "timestamp": 1631798536
    }
]