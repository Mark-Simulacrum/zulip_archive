[
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"cp\">$v</span>:<span class=\"nc\">vis</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">m</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>fails with</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error: unexpected end of macro invocation\n --&gt; src/lib.rs:4:1\n  |\n1 | macro_rules! m {\n  | -------------- when calling this macro\n...\n4 | m!();\n  | ^^^^ missing tokens in macro arguments\n</code></pre></div>\n<p>even though the <code>vis</code> fragment is allowed to match nothing. Is this intended behavior for when it is standing alone like this?</p>",
        "id": 278182379,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1649345711
    },
    {
        "content": "<p>Or rather it seems this is the behavior when a vis fragment is at the end of the matcher in general, that is</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">m</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"cp\">$v</span>:<span class=\"nc\">vis</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">{};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">m</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>also fails. I assume this could be intentional, but I figured I'd better ask before noting that down in the little book of rust macros.</p>",
        "id": 278182583,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1649345780
    },
    {
        "content": "<p>Parsing a <code>vis</code> might need tokens after it.</p>",
        "id": 278239925,
        "sender_full_name": "fee1-dead",
        "timestamp": 1649374491
    },
    {
        "content": "<p>Yeah, <code>:vis</code> is really intended to be followed by a keyword or something, <em>Ã  la</em> <code>struct, enum, union, fn</code> <em>etc.</em> For instance <code>$pub:vis $ident:ident</code> will be ambiguous as well, since <code>pub</code> could be part of the <code>:vis</code>, or it could be an empty <code>:vis</code> followed by the <code>ident</code> <code>pub</code>.</p>\n<p>So, if you are not in a \"classic\" <code>:vis</code> situation, using <code>$(pub $(( $($vis:tt)* ))?)?</code> may be better (it will have the drawback not to be usable by other macros that already parsed a <code>:vis</code>, however. <em>e.g.</em>, good luck trying to feed a <code>$pub</code> of the <code>:vis</code> kind to <code>lazy_static!</code>)</p>",
        "id": 278290863,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649417573
    },
    {
        "content": "<blockquote>\n<p>For instance $pub:vis $ident:ident will be ambiguous as well, since pub could be part of the :vis, or it could be an empty :vis followed by the ident pub.</p>\n</blockquote>\n<p>That's not quite true, <code>pub</code> isn't an ident so that would parse as <code>vis</code> and then fail matching due to no tokens being left for matching up with the <code>ident</code> fragment.</p>\n<p>But ye, it's not a problem I ran into per se, just an interesting behavior I found when trying to investigate a bug in rust-analyzer revolving around this special behaving fragment type.</p>",
        "id": 278291292,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1649417838
    },
    {
        "content": "<p><code>pub</code> is an <code>:ident</code>. macro <code>:ident</code> / <code>TokenTree::Ident</code> are actually the backing token for both keywords and non-keyword identifiers (the latter being the intuition that we may have of identifiers).</p>\n<p>This is what leads to the very disheartenening situation of <code>$(mut)? $varname:ident</code> being an ambiguous parsing rule as well, for instance.</p>\n<p>That being said, some testing does suggest that, to my surprsise,<code>:vis</code> may be a case (the only one that I know of) of \"greedy matching\" in the <code>macro_rules</code> world, thence avoiding the ambiguity when followed up by an <code>:ident</code>. I guess I mixed up the situation with <code>mut</code>, my bad</p>",
        "id": 278291915,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649418178
    },
    {
        "content": "<p>Ye right, I forgot as well that keywords count as idents for macros. Tested the mentioned ambiguity which worked so I assumed different.</p>\n<p>That is the exact weirdness I was wondering about, previously I explained <code>vis</code> as being an implicit optional repetition but it really doesn't behave like that at all as it turns out.</p>",
        "id": 278292335,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1649418412
    },
    {
        "content": "<p>I've expanded the <code>vis</code> section in the fragment specifier chapter a bit more, <a href=\"https://veykril.github.io/tlborm/decl-macros/minutiae/fragment-specifiers.html#vis\">https://veykril.github.io/tlborm/decl-macros/minutiae/fragment-specifiers.html#vis</a> I think it should cover all the oddities of it now</p>",
        "id": 278295080,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1649420056
    },
    {
        "content": "<p>I've also found a way to make rust emit a fun error with this yesterday: <a href=\"https://github.com/rust-lang/rust/issues/95778\">https://github.com/rust-lang/rust/issues/95778</a></p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>error: no rules expected the token ``\n</code></pre></div>",
        "id": 278295261,
        "sender_full_name": "Lukas Wirth",
        "timestamp": 1649420171
    },
    {
        "content": "<p>Haha, an opaque token with empty contents <span aria-label=\"ok\" class=\"emoji emoji-1f44c\" role=\"img\" title=\"ok\">:ok:</span></p>",
        "id": 278359790,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1649450624
    }
]