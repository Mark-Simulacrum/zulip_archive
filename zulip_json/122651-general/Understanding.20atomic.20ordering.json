[
    {
        "content": "<p><a href=\"https://doc.rust-lang.org/core/sync/atomic/fn.fence.html#examples\">https://doc.rust-lang.org/core/sync/atomic/fn.fence.html#examples</a><br>\nShouldn't the spinlock use Release ordering to make sure that it notifies other threads of lock acquiring and Acquire to make sure it has the most recent flag?<br>\nSynchronization is only guaranteed on release store + acquire read (at least that's what I understand from <a href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\">C11 memory ordering</a>)</p>",
        "id": 207561701,
        "sender_full_name": "Soveu",
        "timestamp": 1597950440
    },
    {
        "content": "<p>The example uses release/acquire fences, not loads and stores. I don't see anything on the cppreference page about release fences but it might be a factor</p>",
        "id": 207565414,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597952378
    },
    {
        "content": "<p><a href=\"https://llvm.org/docs/Atomics.html#atomic-instructions\">LLVM</a> says:</p>\n<blockquote>\n<p>A fence provides Acquire and/or Release ordering which is not part of another operation; it is normally used along with Monotonic memory operations. A Monotonic load followed by an Acquire fence is roughly equivalent to an Acquire load, and a Monotonic store following a Release fence is roughly equivalent to a Release store.</p>\n</blockquote>\n<p>Note that a \"monotonic load\" is rust's <code>load(Relaxed)</code> and \"monotonic store\" is <code>store(_, Relaxed)</code></p>",
        "id": 207566911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597953215
    },
    {
        "content": "<p>By the way, I think the documentation and diagram in <a href=\"https://doc.rust-lang.org/core/sync/atomic/fn.fence.html\">https://doc.rust-lang.org/core/sync/atomic/fn.fence.html</a> is not very good.</p>\n<blockquote>\n<p>A fence 'A' which has (at least) <code>Release</code> ordering semantics, synchronizes with a fence 'B' with (at least) <code>Acquire</code> semantics, if and only if there exist operations X and Y, both operating on some atomic object 'M' such that A is sequenced before X, Y is synchronized before B and Y observes the change to M. This provides a happens-before dependence between A and B.</p>\n</blockquote>\n<p>None of the terms used in this paragraph are defined or linked except for doc links for <code>Ordering::Release</code> and <code>Ordering::Acquire</code>. It is followed by a diagram with two arrows and no explanation of what those arrows represent</p>",
        "id": 207567724,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597953631
    },
    {
        "content": "<p>ideally we would link to a section in the rust book on memory ordering but I think there is no such thing</p>",
        "id": 207567853,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597953694
    },
    {
        "content": "<p>linking to cppreference or llvm docs would be a reasonable stopgap</p>",
        "id": 207567961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597953726
    },
    {
        "content": "<p>Yeah, LLVM does better explain the memory orderings than C11 docs, because it literally says what optimizer can and can't do</p>",
        "id": 207569248,
        "sender_full_name": "Soveu",
        "timestamp": 1597954445
    },
    {
        "content": "<p>I'm hoping that the unsafe code guidelines group eventually gets around to defining this memory model better than C++ did. I thought my C++ language lawyering days were over</p>",
        "id": 207569875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597954865
    },
    {
        "content": "<p>C11 memory ordering docs say, that this code</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">// Thread 1</span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span>::<span class=\"n\">Release</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">43</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span>::<span class=\"n\">Relaxed</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// Thread 2, later</span>\n<span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">Ordering</span>::<span class=\"n\">Acquire</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>most probably should print <code>42</code>, meanwhile I had been sure that it would be <code>43</code>, because I thought <code>Acquire</code> would look for newest write</p>\n<p>Another example:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">// Thread 1</span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span>::<span class=\"n\">Release</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">43</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span>::<span class=\"n\">Relaxed</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// Thread 2, later</span>\n<span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{}&quot;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">Ordering</span>::<span class=\"n\">Relaxed</span><span class=\"p\">));</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>According to docs, this should be randomly 42 or 43, but I thought that <code>Release</code> would force threads to update this value (so more probably 42 should be printed)</p>",
        "id": 207570025,
        "sender_full_name": "Soveu",
        "timestamp": 1597954977
    },
    {
        "content": "<p>I think both of them could print 42 or 43</p>",
        "id": 207570692,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597955392
    },
    {
        "content": "<p>even if everything was <code>SeqCst</code> you would still have 42 or 43</p>",
        "id": 207570762,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597955406
    },
    {
        "content": "<p>I don't think you can meaningfully reason about probabilities here, it really is just a set of options that the compiler / hardware is allowed to pick from</p>",
        "id": 207570895,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597955479
    },
    {
        "content": "<p><del>Well, that would be kinda unsound, imagine locking a spinlock and then second thread comes and sees it as unlocked</del><br>\nNevermind, in spinlocks no one should use relaxed ordering anyway</p>",
        "id": 207571183,
        "sender_full_name": "Soveu",
        "timestamp": 1597955625
    },
    {
        "content": "<p>the second thread could be seeing it unlocked because the first thread hasn't run yet</p>",
        "id": 207571314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597955693
    },
    {
        "content": "<p>The ordering guaranteed by <code>SeqCst</code> doesn't have to match wall clock time</p>",
        "id": 207571396,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597955760
    },
    {
        "content": "<p><code>Aquire</code>/<code>Release</code> only really are useful in combination with each other if you only have an <code>Aquire</code> but no <code>Release</code> or the other way around you can treat them <em>roughly</em> as relaxed as long as no <code>SeqCst</code> is involved. Always use them as a pair. </p>\n<p>Also as long as you don't know really well what you do your should always try to avoid <code>Relaxed</code> memory ordering, tbh. I would prefer an example in the rust did which doesn't use <code>Relaxed</code> ordering. But then (simple) fences usage are mainly optimizations where you do a less strict load/cas/etc. then you normally could but then \"fix\" that with an fence. If I remember correctly a good real world example is the usage of fences in <code>Arc</code>.</p>",
        "id": 207592635,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1597972669
    },
    {
        "content": "<p>I remember a talk who one of the people which designed the C++ atomic rules mentions that they originally didn't want to add relaxed ordering at all but then had to do so for some optimizations for ARM and I think PowerPc. Sadly I haven't bookmarked it.</p>",
        "id": 207592720,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1597972795
    },
    {
        "content": "<p>Isn't <code>Relaxed</code> the correct ordering when you just want to avoid UB on data races?</p>",
        "id": 207594422,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597975366
    },
    {
        "content": "<p>I recall the reference count on an <code>Arc</code> being a classic example of <code>Relaxed</code>, since it's not actually synchronizing with anything else</p>",
        "id": 207594443,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1597975423
    },
    {
        "content": "<p>The reference count on an <code>Arc</code> can't be used with <code>Relaxed</code> when dropping: <a href=\"https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/library/alloc/src/sync.rs#L1329\">https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/library/alloc/src/sync.rs#L1329</a> <code>clone</code> can use <code>Relaxed</code> though: <a href=\"https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/library/alloc/src/sync.rs#L1055\">https://github.com/rust-lang/rust/blob/b51651ae9d0161967617be930415705b2e4d5faf/library/alloc/src/sync.rs#L1055</a></p>",
        "id": 207610817,
        "sender_full_name": "bjorn3",
        "timestamp": 1597998891
    },
    {
        "content": "<p><a href=\"https://godbolt.org/z/M5j47M\">https://godbolt.org/z/M5j47M</a><br>\nWhy load/store with <code>SeqCst</code> have fences on both sides?</p>",
        "id": 207614873,
        "sender_full_name": "Soveu",
        "timestamp": 1598002345
    },
    {
        "content": "<p>Arm and RISC-V have much weaker memory models then x86, meaning that those fences are necessary to guarantee sequential consistency. If there was only a fence at once side, a memory operation could be re-ordered between the fence and the memory operation the fence is next to.</p>",
        "id": 207621405,
        "sender_full_name": "bjorn3",
        "timestamp": 1598007256
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Release</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">compiler_fence</span><span class=\"p\">(</span><span class=\"n\">SeqCst</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">Acquire</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>This could be reordered by hardware to</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">Acquire</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Release</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>?</p>",
        "id": 207623244,
        "sender_full_name": "Soveu",
        "timestamp": 1598008918
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207594443\">said</a>:</p>\n<blockquote>\n<p>I recall the reference count on an <code>Arc</code> being a classic example of <code>Relaxed</code>, since it's not actually synchronizing with anything else</p>\n</blockquote>\n<p>Yeah, this is kinda tricky to understand, but there is no situation where <code>Relaxed</code> would be incorrect to use inside <code>clone</code> :D</p>",
        "id": 207623464,
        "sender_full_name": "Soveu",
        "timestamp": 1598009125
    },
    {
        "content": "<p><a href=\"https://github.com/Soveu/stacc/blob/master/src/stacc_lockfree_hp.rs\">https://github.com/Soveu/stacc/blob/master/src/stacc_lockfree_hp.rs</a><br>\nThis is my first lock-free stack, feel free to criticize :)</p>",
        "id": 207627068,
        "sender_full_name": "Soveu",
        "timestamp": 1598012232
    },
    {
        "content": "<blockquote>\n<p>Sadly I haven't bookmarked it.</p>\n</blockquote>\n<p>I think it is mentioned in Herb Sutter's \"atomic Weapons\" <a href=\"https://www.youtube.com/watch?v=A8eCGOqgvH4\">https://www.youtube.com/watch?v=A8eCGOqgvH4</a> and <a href=\"https://www.youtube.com/watch?v=KeLBd2EJLOU\">https://www.youtube.com/watch?v=KeLBd2EJLOU</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"KeLBd2EJLOU\" href=\"https://www.youtube.com/watch?v=KeLBd2EJLOU\"><img src=\"https://i.ytimg.com/vi/KeLBd2EJLOU/default.jpg\"></a></div><div class=\"youtube-video message_inline_image\"><a data-id=\"A8eCGOqgvH4\" href=\"https://www.youtube.com/watch?v=A8eCGOqgvH4\"><img src=\"https://i.ytimg.com/vi/A8eCGOqgvH4/default.jpg\"></a></div>",
        "id": 207633633,
        "sender_full_name": "Eh2406",
        "timestamp": 1598016472
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207569248\">said</a>:</p>\n<blockquote>\n<p>Yeah, LLVM does better explain the memory orderings than C11 docs, because it literally says what optimizer can and can't do</p>\n</blockquote>\n<p>While such examples are helpful to understand memory orderings, keep in mind that their actual underlying specification is <em>not</em> in terms of what the compiler can and cannot do. There is a spec of what the <em>program</em> can and cannot do when  being executed (the possible behaviors of the program), and the compiler can only do things that do not change program behavior. Thus, a really smart compiler can do way more than what these simple examples might suggest. for example, if the compiler can prove that an atomic location is only used from a single thread, it may replace all atomic accesses by non-atomic accesses.</p>",
        "id": 207727925,
        "sender_full_name": "RalfJ",
        "timestamp": 1598108262
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207570895\">said</a>:</p>\n<blockquote>\n<p>I don't think you can meaningfully reason about probabilities here, it really is just a set of options that the compiler / hardware is allowed to pick from</p>\n</blockquote>\n<p>indeed. this is <em>non-determinism</em>, which is very distinct from randomness. it just means that every execution will make one of the allowed choices, but says nothing about which choice is observed how often when you execute the program many times. this distribution is entirely unspecified and can be affected by random hardware effects (e.g. alignment of the memory involved), compiler optimizations, indirect interactions with other code running in parallel, ...</p>",
        "id": 207728055,
        "sender_full_name": "RalfJ",
        "timestamp": 1598108436
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> By the way, I've been thinking of writing a precise memory model, probably in blog like form at first (although I don't have a blog), that can eventually serve as our replacement for \"we do what C++11 does\" because that's a terrible way to specify anything, and after reading <a href=\"https://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf\">several</a> <a href=\"https://people.mpi-sws.org/~viktor/papers/oopsla2013-rsl.pdf\">papers</a> on mathematizing the C++11 concurrency spec, it turns out they messed up pretty badly when it comes to relaxed atomics, allowing causal loops that make it impossible to prove anything about program behavior while still not being UB.</p>\n<p>I have a background in formal proof assistants and formal verification, but I haven't actually participated in WG-UCG before. Where would be a good place to build such information?</p>",
        "id": 207736335,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598120959
    },
    {
        "content": "<p>yeah, the C11 model has many problems, but so far no clearly superior model has surfaced despite many years of research. there are some exciting proposals though, I really like the \"promising semantics\" (<a href=\"https://people.mpi-sws.org/~viktor/papers/popl2017-promising.pdf\">original paper</a>, <a href=\"http://www.cse.iitd.ac.in/~soham/publications/promising2.pdf\">this years follow-up</a>).</p>",
        "id": 207774675,
        "sender_full_name": "RalfJ",
        "timestamp": 1598191193
    },
    {
        "content": "<p>regarding your last question, not sure -- blog posts are a great start.</p>",
        "id": 207774821,
        "sender_full_name": "RalfJ",
        "timestamp": 1598191324
    },
    {
        "content": "<p>eventually putting it into paper format for peer review might also be a good idea, but that's probably still ways off ;)</p>",
        "id": 207774834,
        "sender_full_name": "RalfJ",
        "timestamp": 1598191345
    },
    {
        "content": "<p>If I could only understand this language <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> <a href=\"/user_uploads/4715/CpQTqpE4mXx78y5Hm-3SM_pX/Screenshot-from-2020-08-23-16-47-27.png\">Screenshot-from-2020-08-23-16-47-27.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/CpQTqpE4mXx78y5Hm-3SM_pX/Screenshot-from-2020-08-23-16-47-27.png\" title=\"Screenshot-from-2020-08-23-16-47-27.png\"><img src=\"/user_uploads/4715/CpQTqpE4mXx78y5Hm-3SM_pX/Screenshot-from-2020-08-23-16-47-27.png\"></a></div>",
        "id": 207776721,
        "sender_full_name": "Soveu",
        "timestamp": 1598194113
    },
    {
        "content": "<p>I find it beautiful while still not understanding a word of what is written in the screenshot</p>",
        "id": 207780722,
        "sender_full_name": "Poliorcetics",
        "timestamp": 1598200426
    },
    {
        "content": "<p>Yeah, this looks similar to notation in other compiler/language related papers (like in the Ralf's paper about LLVM <code>no_alias</code>)</p>",
        "id": 207784042,
        "sender_full_name": "Soveu",
        "timestamp": 1598205318
    },
    {
        "content": "<p>I think a good next step in this area is a description of a semantics with good formal properties, which is understandable to mere mortals. The \"pages of fractions\" are important for formal folks but a sound underapproximation under certain assumptions (e.g. SC-DRF, use message passing like this and don't touch atomics and you will be fine, etc.). Even a fully precise model should be describable in prose in a few pages at most (the C++ committee always manages to screw this part up)</p>",
        "id": 207785961,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598208353
    },
    {
        "content": "<p>After some reading I think there has been enough legwork done on better C11 semantics already, I doubt I can do a better job</p>",
        "id": 207786008,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598208422
    },
    {
        "content": "<p>but explaining what already exists in one place would still be very useful</p>",
        "id": 207786015,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598208445
    },
    {
        "content": "<p>RISC-V has nice and simple atomics</p>",
        "id": 207788397,
        "sender_full_name": "Soveu",
        "timestamp": 1598212186
    },
    {
        "content": "<p>(oops, when I said don't touch atomics I meant relaxed atomics. Guess you can't edit posts here?)</p>",
        "id": 207790022,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598214741
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207785961\">said</a>:</p>\n<blockquote>\n<p>I think a good next step in this area is a description of a semantics with good formal properties, which is understandable to mere mortals. The \"pages of fractions\" are important for formal folks but a sound underapproximation under certain assumptions (e.g. SC-DRF, use message passing like this and don't touch atomics and you will be fine, etc.). Even a fully precise model should be describable in prose in a few pages at most (the C++ committee always manages to screw this part up)</p>\n</blockquote>\n<p>Part of the problem is that sequential consistency is not enough to write the highest-performance concurrent data structures. It's harder (but still quite possible) to specify semantics allowing for concurrency that doesn't force SC.</p>",
        "id": 207790431,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598215437
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207790022\">said</a>:</p>\n<blockquote>\n<p>(oops, when I said don't touch atomics I meant relaxed atomics. Guess you can't edit posts here?)</p>\n</blockquote>\n<p>only for an hour I think</p>",
        "id": 207790573,
        "sender_full_name": "bjorn3",
        "timestamp": 1598215612
    },
    {
        "content": "<p>Right, I'm really thinking of semantics for \"the land below SC\". SC itself is fairly well understood</p>",
        "id": 207791591,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598217111
    },
    {
        "content": "<p>My impression of the field matches up with what Ralf said. C11 semantics is <a href=\"https://fzn.fr/readings/c11comp.pdf\">known to be broken</a>, and there are several proposals for alternatives which fix many of the issues, but every proposal invalidates some compiler or hardware technique (which shouldn't be too surprising because the whole business is currently inconsistent), so we have to figure out which things we are willing to part with</p>",
        "id": 207791757,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598217359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> The fundamental premise of the C11 semantics were \"what people are doing is OK, so how do we specify it\". Any potential replacement would need to start with the same premise, or people who need to continue doing what they're doing cannot use that replacement.</p>",
        "id": 207794245,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598221783
    },
    {
        "content": "<p>A better model may allow more compiler techniques without breaking programs, but the premise should always be \"how can we allow more optimization without invalidating programs that work on real hardware\", not \"which additional valid programs are we willing to start rejecting\".</p>",
        "id": 207794323,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598221916
    },
    {
        "content": "<p>Of course. The problem is that because there was not a rigid specification of what the contract was, different optimizations make different assumptions and the result is an unambiguously buggy combination of individually okay-looking things. Any attempt to put a coherent global structure on this is going to have to reject one of those things</p>",
        "id": 207794363,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598221932
    },
    {
        "content": "<p>I think I'm missing something. Going by the title and abstract of the paper you linked, it sounds like C11 has specified semantics, those semantics just disallow certain compiler optimizations.</p>",
        "id": 207794376,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598221994
    },
    {
        "content": "<p>Or am I misunderstanding the paper?</p>",
        "id": 207794380,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222011
    },
    {
        "content": "<p>They disallow optimizations that were explicitly intended to be okay by the designers of the C11 standard</p>",
        "id": 207794382,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222037
    },
    {
        "content": "<p>in other words, they failed to meet their own criteria</p>",
        "id": 207794423,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222050
    },
    {
        "content": "<p>Ah, <em>that</em> is the information I was missing, thank you.</p>",
        "id": 207794429,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222060
    },
    {
        "content": "<p>which is why I am comfortable saying that the standard is broken without further qualification</p>",
        "id": 207794432,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222077
    },
    {
        "content": "<p>In the abstract, it would have helped to change \"and that are deemed to be correct\" to \"and that were intended to be allowed by the C11 model\".</p>",
        "id": 207794439,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222100
    },
    {
        "content": "<p>For example, in the Herb Sutter talk linked above, there is explicit reference to so called \"roach motel reorderings\" that were proven invalid in that paper</p>",
        "id": 207794452,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222151
    },
    {
        "content": "<p>Also I haven't found a direct reference but the papers seem to suggest that SC-DRF is known to not hold in C11</p>",
        "id": 207794506,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222222
    },
    {
        "content": "<p><em>That</em> much is entirely intended, as far as I know. The C11 semantics are not supposed to be limited to sequential consistency.</p>",
        "id": 207794515,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222236
    },
    {
        "content": "<p>When using relaxed atomics, I mean.</p>",
        "id": 207794525,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222279
    },
    {
        "content": "<p>No, I mean if you use SC atomics</p>",
        "id": 207794526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222279
    },
    {
        "content": "<p>Of course if you use relaxed atomics you get what you deserve, but SC atomics aren't properly SC</p>",
        "id": 207794565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222302
    },
    {
        "content": "<p>this is the sort of basic coherence failure that indicates that the model has gone horribly wrong somewhere</p>",
        "id": 207794572,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222336
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207794526\">said</a>:</p>\n<blockquote>\n<p>No, I mean if you use SC atomics</p>\n</blockquote>\n<p>Now <em>that's</em> weird; I'd love to see some details on that.</p>",
        "id": 207794582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222357
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207794565\">said</a>:</p>\n<blockquote>\n<p>Of course if you use relaxed atomics you get what you deserve, but SC atomics aren't properly SC</p>\n</blockquote>\n<p>Please don't denigrate non-SC code with comments like \"you get what you deserve\"; relaxed atomics exist for a reason, to support valid program implementations.</p>",
        "id": 207794586,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222370
    },
    {
        "content": "<p>I'm being tongue in cheek. Of course I would like to have good support for relaxed atomics, so I can use them and know what they mean. C11 relaxed atomics are magical time travelers</p>",
        "id": 207794707,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222532
    },
    {
        "content": "<p><a href=\"https://people.mpi-sws.org/~dreyer/papers/scfix/paper.pdf\">https://people.mpi-sws.org/~dreyer/papers/scfix/paper.pdf</a> has a big section on problems with SC atomics</p>",
        "id": 207794710,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222552
    },
    {
        "content": "<p>For a little background here, to provide some context for why this is a sensitive topic: when the C11 model was being introduced, it was very much a tooth-and-nail uphill battle against folks who basically said anything that isn't sequential consistency is just flatly unacceptable and wrong.</p>",
        "id": 207794768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598222670
    },
    {
        "content": "<p>I don't know if release-acquire is the best primitive for message passing but it's at least somewhat comprehensible. It would also be nice if there was an \"unsynchronized read/write\" primitive that you can compile to plain (atomic) reads and writes. I'm still reading the promising papers but it does seem to solve a lot of problems</p>",
        "id": 207794904,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598222897
    },
    {
        "content": "<p>SC is a nice model, but it unfortunately doesn't really reflect hardware at all. They basically get compiled to fences after every instruction on most architectures</p>",
        "id": 207794966,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598223013
    },
    {
        "content": "<p>/me nods to that last bit.</p>",
        "id": 207794967,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598223020
    },
    {
        "content": "<p>To the best of my knowledge, the semantics of relaxed atomics are <em>supposed</em> to be, roughly, that there won't be any load-tearing or store-tearing (you'll get the old or the new value), and that any given thread that reads the new value won't start reading the old value again, and otherwise there's no ordering guarantee unless you separately apply additional barriers.</p>",
        "id": 207794978,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598223072
    },
    {
        "content": "<p>LLVM actually has an \"even more relaxed\" atomic operation called <code>Unordered</code>, where \"relaxed\" is <code>Monotonic</code>. The main difference is that relaxed writes to the same location are totally ordered by the \"modification order\" to that location</p>",
        "id": 207795026,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598223151
    },
    {
        "content": "<p>That is, if two threads A and B relaxed write to location X, it is not possible for threads C and D to each see both writes in opposite orders</p>",
        "id": 207795128,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598223305
    },
    {
        "content": "<p>but with unordered writes that's possible</p>",
        "id": 207795142,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598223330
    },
    {
        "content": "<p>Fair enough. The concurrent algorithms I work with tend to care more about relaxed reads, and tend to synchronize writes; the idea of racing two relaxed writes against each other doesn't seem nearly as common.</p>",
        "id": 207795204,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598223459
    },
    {
        "content": "<p>(Such programs still use relaxed writes, but do so inside critical sections.)</p>",
        "id": 207795465,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598223750
    },
    {
        "content": "<p>I don't like that the C11 primitives have such complicated codegen. I would like the lowest level operations to lower to individual reads, writes and fences if possible.</p>",
        "id": 207795558,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598223929
    },
    {
        "content": "<p>unfortunately that sort of thing is not very portable</p>",
        "id": 207795562,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598223950
    },
    {
        "content": "<p>Definite agreement there.</p>",
        "id": 207795615,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598223984
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207791591\">said</a>:</p>\n<blockquote>\n<p>Right, I'm really thinking of semantics for \"the land below SC\". SC itself is fairly well understood</p>\n</blockquote>\n<p>SC on its own is. Mixing SC and \"lower\" atomic accesses on the same location is actually very poorly understood (and there were some bugs there that the next C++ will fix).</p>",
        "id": 207931082,
        "sender_full_name": "RalfJ",
        "timestamp": 1598339668
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"328907\">Soveu</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207788397\">said</a>:</p>\n<blockquote>\n<p>RISC-V has nice and simple atomics</p>\n</blockquote>\n<p>unfotunately that does not help when specifying a <em>language</em> memory model. when it comes to concurrency, hardware and language models are entirely different beasts.</p>",
        "id": 207931094,
        "sender_full_name": "RalfJ",
        "timestamp": 1598339693
    },
    {
        "content": "<p>hardware model tend to take into account syntactic dependencies (\"if an operation has this register as an input, it counts as being data-dependent on the last thing that wrote to that register\"). this is a trick that is impossible to pull in language models where compilers routinely optimize <code>x*0</code> to <code>0</code>, thus removing such data dependencies.</p>",
        "id": 207931128,
        "sender_full_name": "RalfJ",
        "timestamp": 1598339741
    },
    {
        "content": "<p>this is why the C++11 \"consume\" ordering is entirely broken -- nobody knows how to say anything precise about it</p>",
        "id": 207931142,
        "sender_full_name": "RalfJ",
        "timestamp": 1598339756
    },
    {
        "content": "<p>if we didnt care for relaxed, we'd have a <em>beautiful</em> model already, the SRA model: <a href=\"https://plv.mpi-sws.org/sra/paper.pdf\">https://plv.mpi-sws.org/sra/paper.pdf</a></p>",
        "id": 207931230,
        "sender_full_name": "RalfJ",
        "timestamp": 1598339843
    },
    {
        "content": "<p>this has an axiomatic and an operational model (proven equivalent), both are reaosnably simple, there are coq proofs of all relevant reorderings. While we don't have a fully \"canonical\" program logic yet, but we do have several years of work across various papers that build program logics for semantics like this, including one that shows soundness of a bunch of core Rust abstractions (<a href=\"https://people.mpi-sws.org/~dreyer/papers/rbrlx/paper.pdf\">https://people.mpi-sws.org/~dreyer/papers/rbrlx/paper.pdf</a>).<br>\nas that last paper shows we even know how to extend this reasonably well with a form of relaxed accesses that is strictly weaker than release/acquire. but these relaxed accesses still do not allow one key optimization (load buffering I think), and it is adding that optimization which kills <em>everything</em>. of course this also means that the only \"sensible\" relaxed semantics we have (in terms of having a not-completely-crazy spec and a reasonable program logic) cannot be compiled without fences -- so some might not call it \"sensible\" after all.</p>",
        "id": 207931430,
        "sender_full_name": "RalfJ",
        "timestamp": 1598340046
    },
    {
        "content": "<p>(I should also note that these are my opinion are not necessarily consensus in my research community. ;) there are various contenders for relaxed semantics, not just the crazy complicated \"promising\" semantics, but the others are very axiomatic in their style so I have a hard time really building any intuition for what they <em>mean</em>. AFAIK none of them comes with a program logic.)</p>",
        "id": 207931671,
        "sender_full_name": "RalfJ",
        "timestamp": 1598340257
    },
    {
        "content": "<p>After reading the \"promising\" papers, I agree that it is a very nice model. The fact that it is very operational is a bit of a downside though</p>",
        "id": 207932336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598340873
    },
    {
        "content": "<p>Ideally you would have both styles and a proof of equivalence. I don't know whether that's a prerequisite, but it's a big plus</p>",
        "id": 207932398,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598340947
    },
    {
        "content": "<p>Do you know whether the promising model's RA fragment matches the SRA model?</p>",
        "id": 207932553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598341075
    },
    {
        "content": "<p>My reading list has grown once again :)</p>",
        "id": 207932676,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598341178
    },
    {
        "content": "<p>I consider being operational a big advantage. I never was able to wrap my head around these axiomatic models. The first time I understood RA was when reading the SRA paper. ;)</p>",
        "id": 207974059,
        "sender_full_name": "RalfJ",
        "timestamp": 1598367610
    },
    {
        "content": "<p>IMO the axiomatic models are nice properties to show about an operational model, but I feel that the \"ground truth\" of <em>program execution</em> should be operational. It's supposed to reflect a computation after all.</p>",
        "id": 207974121,
        "sender_full_name": "RalfJ",
        "timestamp": 1598367639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Understanding.20atomic.20ordering/near/207932553\">said</a>:</p>\n<blockquote>\n<p>Do you know whether the promising model's RA fragment matches the SRA model?</p>\n</blockquote>\n<p>No, AFAIK it matches a slight tweak of the SRA model to make it equivalent to C++11 RA. It's easy to adjust SRA accordingly, which is useful when selling this to people that are already sold on C++11 RA (so, good for getting things published) -- but I think SRA is the nicer model, as they convincingly demonstrated.^^<br>\nSo, SRA vs \"weak\" (normal) RA is a decision that's orthogonal to handling relaxed accesses. If I recall correctly, both the operational and axiomatic model are easy to tweak one way or the other.</p>",
        "id": 207974165,
        "sender_full_name": "RalfJ",
        "timestamp": 1598367662
    },
    {
        "content": "<p>I think an operational model loses some advantage when it (like the promising model) is performing arbitrary amounts of counterfactual computation on every step and also filling in bits of the \"past\" and \"future\" as it goes. (Given the way Stacked Borrows is defined, I already inferred that you have a great preference for operational models.) A declarative model is useful for being able to tell what properties hold globally, but operational models help with setting up an order to prove properties, and providing a reliable direction of \"time\" that can be reasoned about. But like I said it is best when you have both views, so you can exploit the advantages of each.</p>\n<p>On that note, is there a nondeterministic model of stacked borrows? It would be easier to see the stack as lifetimes again if the machine could nondeterministically end a borrow at appropriate points, and having all these stacks on memory locations might be good for an interpreter like miri but is like looking at a program in CPS, everything seems to be inside out from the regular way things are viewed. (For example, lifetimes quantify over future times when a value will be destroyed, but your <code>Shr</code> nodes instead store a point in the past when the lifetime was first established.)</p>",
        "id": 207981965,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598371251
    },
    {
        "content": "<p>If the operational model has to do crazy things like hypothetical executions (is that what you mean by \"counterfactual\"?), then that just shows that the semantics are crazy. The axiomatic model has all the same craziness, it's just hidden better. Hiding craziness is not an advantage, it's a flaw of the axiomatic model that prevents actually understanding what happens, at least for me.</p>",
        "id": 208059278,
        "sender_full_name": "RalfJ",
        "timestamp": 1598426061
    },
    {
        "content": "<p>I agree it is best to have both views, so I can ignore the axiomatic model as I do not understand it, but I can still talk to people that prefer that view. ;)</p>",
        "id": 208059311,
        "sender_full_name": "RalfJ",
        "timestamp": 1598426111
    },
    {
        "content": "<p>Also as a matter of principle, when it comes to <em>defining</em> the very meaning of \"executing a Rust program\", I would not accept anything axiomatic. Executing a program is an operational affair.</p>",
        "id": 208059373,
        "sender_full_name": "RalfJ",
        "timestamp": 1598426174
    },
    {
        "content": "<blockquote>\n<p>On that note, is there a nondeterministic model of stacked borrows? It would be easier to see the stack as lifetimes again if the machine could nondeterministically end a borrow at appropriate points, and having all these stacks on memory locations might be good for an interpreter like miri but is like looking at a program in CPS, everything seems to be inside out from the regular way things are viewed. (For example, lifetimes quantify over future times when a value will be destroyed, but your Shr nodes instead store a point in the past when the lifetime was first established.)</p>\n</blockquote>\n<p>I don't know of such a model, and I doubt I'd be able to build it as that's just not how my intuition works.<br>\nAlso I do not see the relationship to CPS at all, Stacked Borrows doesn't invert control (or anything else) in any way that I can see? My stack items track which lifetimes are still active, and I keep all lifetimes active as long as possible. IMO that's exactly the regular way to view lifetimes -- figuring out which of them are still alive.</p>",
        "id": 208059408,
        "sender_full_name": "RalfJ",
        "timestamp": 1598426240
    },
    {
        "content": "<blockquote>\n<p>I don't know of such a model, and I doubt I'd be able to build it as that's just not how my intuition works.</p>\n</blockquote>\n<p>Okay, then I think I have an upcoming blog post for you :)</p>",
        "id": 208060288,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598426974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I talked with a friend on the C and C++ standards committee today.</p>",
        "id": 208272160,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598560330
    },
    {
        "content": "<p>He was familiar with both of the papers you'd linked to.</p>",
        "id": 208272188,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598560346
    },
    {
        "content": "<p>The paper \"Repairing  Sequential  Consistency  in  C/C++11\" accurately describes a bug in the C11 memory model, specifically in regards to POWER, which will be fixed in C20.</p>",
        "id": 208272297,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598560418
    },
    {
        "content": "<p>For the other paper, those issues are a subject of ongoing discussion in the C standards committee.</p>",
        "id": 208272383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598560444
    },
    {
        "content": "<p>There's some work happening in that area, but it sounds less likely that it'll be addressed soon.</p>",
        "id": 208272420,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598560465
    },
    {
        "content": "<p>It also sounds like part of the problem is that the C11 memory model was lax enough to allow some excessively aggressive optimizations by compiler authors, and some of those folks are fighting to keep that despite it breaking real-world programs.</p>",
        "id": 208272541,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598560532
    },
    {
        "content": "<p>(On the flip side, there are some programs that legitimately want such optimizations, and either don't care about parallelism or don't care about security, and for some reason don't want to have to pass a compiler option enabling that.)</p>",
        "id": 208272666,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1598560576
    },
    {
        "content": "<p>Yeah, I think some of this warrants a <code>--ftimey-wimey</code> compiler flag to turn on dubious optimizations that people can't bear to part with but have no reasonable semantic meaning, analogous to <code>--ffast-math</code></p>",
        "id": 208278525,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598563499
    }
]