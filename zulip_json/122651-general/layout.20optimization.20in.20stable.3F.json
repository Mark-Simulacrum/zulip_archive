[
    {
        "content": "<p>What are the blockers for having stable layout optimizations? Is it just a question of \"what syntax and semantics are we prepared to commit to\", or is there some more fundamental issue?</p>",
        "id": 213473537,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602788976
    },
    {
        "content": "<p>If we added a simplified niche-specification syntax, would that be something that could potentially be stabilized?</p>",
        "id": 213473639,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789012
    },
    {
        "content": "<p>my knowledge is that we may want to use const generics for this, so it would be blocked on that</p>",
        "id": 213473655,
        "sender_full_name": "lcnr",
        "timestamp": 1602789025
    },
    {
        "content": "<p>That's what I meant by \"simplified\": is there some reason that the simple version <em>needs</em> const generics?</p>",
        "id": 213473701,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789051
    },
    {
        "content": "<p>I personally don't think we should stabilize something like the current attributes used in the compiler</p>",
        "id": 213473727,
        "sender_full_name": "lcnr",
        "timestamp": 1602789064
    },
    {
        "content": "<p>as they will become outdated in a few years, but I also don't value this feature too highly so it seems fine to me to wait a bit here.</p>",
        "id": 213473835,
        "sender_full_name": "lcnr",
        "timestamp": 1602789114
    },
    {
        "content": "<p>When you mention using const generics for this, do you mean creating new types to define this, or do you mean providing a way to specify this for user-defined types using const generics?</p>",
        "id": 213473921,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789139
    },
    {
        "content": "<p>I previously quickly mentioned this in <a href=\"#narrow/stream/122651-general/topic/NonZero*.20layout.20optimization/near/213445435\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/NonZero*.20layout.20optimization/near/213445435</a></p>",
        "id": 213474016,
        "sender_full_name": "lcnr",
        "timestamp": 1602789191
    },
    {
        "content": "<p>but I am thinking of adding newtype wrappers for the basic integers</p>",
        "id": 213474048,
        "sender_full_name": "lcnr",
        "timestamp": 1602789213
    },
    {
        "content": "<p>so user defined types can then be built using these newtypes</p>",
        "id": 213474080,
        "sender_full_name": "lcnr",
        "timestamp": 1602789233
    },
    {
        "content": "<p>That would certainly be helpful, but I'm wondering if that needs to be the <em>only</em> stable interface to niches.</p>",
        "id": 213474232,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789299
    },
    {
        "content": "<p>The whole \"start\" and \"end\" mechanism for valid ranges doesn't seem like the mechanism we should stabilize, but I'm wondering if a \"mask/bits\" pattern would be reasonable.</p>",
        "id": 213474480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789407
    },
    {
        "content": "<p>Straw syntax, semantics are the important bit here: <code>#[valid_values(mask=0b111, valid=0)]</code> would say \"this must be a multiple of 8\".</p>",
        "id": 213474677,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789503
    },
    {
        "content": "<p><code>mask</code> would be optional and default to the size of the type, and you could specify either <code>valid</code> or <code>invalid</code>.</p>",
        "id": 213474734,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789530
    },
    {
        "content": "<p>This would <em>benefit</em> from const generics, in that it'd be nice to use const generics and const evaluation for the mask and valid/invalid values, but initially it could just accept literals.</p>",
        "id": 213475002,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789670
    },
    {
        "content": "<p>This would work for aligned pointers, or floats with NaN-boxing, or Linux-kernel-style \"valid pointers can't be -1 to -4095 so you can return pointer-or-negative-errno\"...</p>",
        "id": 213475571,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602789951
    },
    {
        "content": "<p>I believe the compiler currently has no way of optimizing within the compiler on e.g. aligned pointers due to lack of \"I will never take a reference to this\"</p>",
        "id": 213475696,
        "sender_full_name": "simulacrum",
        "timestamp": 1602790001
    },
    {
        "content": "<p>we need invalid values, not bit-ranges, in some sense</p>",
        "id": 213475758,
        "sender_full_name": "simulacrum",
        "timestamp": 1602790033
    },
    {
        "content": "<p>yeah the layout code currently just tracks an invalid range of values for each type (and its position)</p>",
        "id": 213475990,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1602790131
    },
    {
        "content": "<p>it tracks only the largest niche</p>",
        "id": 213476034,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1602790144
    },
    {
        "content": "<p>we <em>could</em> use alignment to get a slightly larger niche though (if we don't already)</p>",
        "id": 213476129,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1602790192
    },
    {
        "content": "<p>I know that's what the compiler currently takes advantage of. In theory, we don't need \"I will never take a reference\" to be able to optimize further; we could alternatively just rely on people not caring what enum discriminants are, and do global optimization. :)</p>",
        "id": 213476284,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602790257
    },
    {
        "content": "<p>For that, you don't need \"I will never take a reference\", just \"I will never care about the exact bit pattern\".</p>",
        "id": 213476383,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602790318
    },
    {
        "content": "<p>(That said, \"I will never take a reference\" would be useful anyway, for things like packed structs, so having it seems like a good idea.)</p>",
        "id": 213476468,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602790345
    },
    {
        "content": "<p>I think what I'm wondering is whether it'd be unreasonable to add a mechanism that gives us more information than we can <em>currently</em> use.</p>",
        "id": 213476554,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602790393
    },
    {
        "content": "<p>The current attributes give us <em>exactly</em> as much information as we can use.</p>",
        "id": 213476574,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602790406
    },
    {
        "content": "<p>How would you do range based validity with this? Like an enum that only goes up to 42</p>",
        "id": 213483001,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602793740
    },
    {
        "content": "<p>How about being able to say \"<code>a..b</code> are valid/invalid\" with some precedence order</p>",
        "id": 213483289,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602793874
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Sorry, my syntax straw-proposal was a little unclear on that front. I intended for valid and invalid to accept ranges, not just single values, but I didn't give any examples to that effect.</p>",
        "id": 213484470,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602794412
    },
    {
        "content": "<p>Oh, my impression was that the ranges in your proposal are of the form e.g. <code>0b1011xx1x0</code></p>",
        "id": 213484576,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602794461
    },
    {
        "content": "<p>or do you mean something else by \"mask\"?</p>",
        "id": 213484613,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602794484
    },
    {
        "content": "<p>of course, it is also annoying to specify a mask pattern like that as a range, although I don't know if there are any anticipated uses for it</p>",
        "id": 213484807,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602794552
    },
    {
        "content": "<p>Masks would be numbers (<code>0b</code> or <code>0x</code> syntax typically, though not required) where the 1 bits select the value bits relevant for valid/invalid.</p>",
        "id": 213484827,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602794557
    },
    {
        "content": "<p>And you're right, that syntax isn't ideal to specify ranges.</p>",
        "id": 213484906,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602794623
    },
    {
        "content": "<p>you could have <code>valid(...)</code> and <code>invalid(...)</code> attrs to make it more ergonomic</p>",
        "id": 213485031,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602794684
    },
    {
        "content": "<p>True.</p>",
        "id": 213485105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602794716
    },
    {
        "content": "<p>and also have the default interpretation of bits not covered by a range be the opposite of the first specified range</p>",
        "id": 213485108,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602794718
    },
    {
        "content": "<p>so that <code>#[valid(a..b)]</code> and <code>#[invalid(a..b)]</code> are opposites when alone on a type decl</p>",
        "id": 213485250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602794767
    },
    {
        "content": "<p>I'd change \"first specified range\" to \"previous specified range for those bits\", but otherwise, yeah.</p>",
        "id": 213485252,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602794768
    },
    {
        "content": "<p>Not that this is likely, but that would allow <code>#[valid(1..=10)] #[invalid(2..=9)] #[valid(3..=8)]</code>, which would mean that valid values are <code>1, 3, 4, 5, 6, 7, 8, 10</code>.</p>",
        "id": 213485382,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602794827
    },
    {
        "content": "<p>Thinking about it, I think \"valid/invalid ranges with optional masks, applied sequentially in the order specified \" would suffice for most cases.</p>",
        "id": 213485465,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602794861
    },
    {
        "content": "<p>I think of it as a decision tree,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">..=</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">..=</span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">..=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">      </span><span class=\"kc\">true</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>where the last <code>false</code> is <code>false</code> because the first range in the list was a <code>valid</code></p>",
        "id": 213485727,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602794997
    },
    {
        "content": "<p>Ah, I see!</p>",
        "id": 213485805,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795029
    },
    {
        "content": "<p>Yeah, I think we're saying the same thing, except that you're also explicitly stating what the top-level implicit default is, which is good to specify. :)</p>",
        "id": 213485842,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795052
    },
    {
        "content": "<p>When you said \"bits not covered by a range\", I was thinking you meant \"not covered by one of the ranges\", but I think you meant \"bits not covered by <em>any</em> range\"?</p>",
        "id": 213485930,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795103
    },
    {
        "content": "<p>yes</p>",
        "id": 213485949,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795114
    },
    {
        "content": "<p>Then I agree. If your first attribute is <code>valid</code> then unspecified bits are invalid; if your first attribute is <code>invalid</code> then unspecified bits are valid.</p>",
        "id": 213486038,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795140
    },
    {
        "content": "<p>actually I think it needs to cascade the other way around,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"o\">..=</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kc\">true</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"o\">..=</span><span class=\"mi\">9</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"o\">..=</span><span class=\"mi\">10</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kc\">true</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kc\">false</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 213486327,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795263
    },
    {
        "content": "<p>so that later patterns take precedence</p>",
        "id": 213486364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795288
    },
    {
        "content": "<p>otherwise it only works when the ranges nest</p>",
        "id": 213486416,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795314
    },
    {
        "content": "<p>I'm not sure how your masking works though</p>",
        "id": 213486565,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795371
    },
    {
        "content": "<p>(Right. The original was hard to read because of the formatting, and I didn't go back and look at it again after it was formatted. ;) )</p>",
        "id": 213486826,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795478
    },
    {
        "content": "<p>Masks would be applied to a value before testing its range.</p>",
        "id": 213486969,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795530
    },
    {
        "content": "<p><code>#[valid(range, mask=m)]</code> would become <code>if x &amp; m in range</code>.</p>",
        "id": 213487033,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795571
    },
    {
        "content": "<p>(so would <code>invalid</code>, just with a <code>false</code> inside the if body rather than a <code>true</code>. :) )</p>",
        "id": 213487091,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602795601
    },
    {
        "content": "<p>oh I see, each clause does both jobs</p>",
        "id": 213487318,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795700
    },
    {
        "content": "<p>That looks pretty flexible to me, and as long as the easy cases are easy people probably don't have to learn the general case</p>",
        "id": 213487534,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795805
    },
    {
        "content": "<p>although you have invented an interesting CS problem: find the largest contiguous niche in a validity predicate so defined. :)</p>",
        "id": 213487715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602795897
    },
    {
        "content": "<p>We were recently talking about a use case for this in Fuchsia. Our syscall return codes are <code>i32</code>s and we were thinking of reserving half of that range for application level errors. I'd love to be able to do that while using idiomatic Rust ADTs.</p>",
        "id": 213489448,
        "sender_full_name": "tmandry",
        "timestamp": 1602796812
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> Does Fuschia always return <code>i32</code> on all platforms, even 64-bit ones?</p>",
        "id": 213490590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602797551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> yes</p>",
        "id": 213491133,
        "sender_full_name": "tmandry",
        "timestamp": 1602797823
    },
    {
        "content": "<p>Is it <em>always</em> an error code, never \"file descriptor or error\" or similar?</p>",
        "id": 213491198,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602797859
    },
    {
        "content": "<p>well the return value is a 32-bit error code, and we use out params for things like file descriptors (everything is a handle on fuchsia)</p>",
        "id": 213491364,
        "sender_full_name": "tmandry",
        "timestamp": 1602797945
    },
    {
        "content": "<p>e.g. <a href=\"https://fuchsia.dev/fuchsia-src/reference/syscalls/handle_duplicate\">zx_handle_duplicate</a></p>",
        "id": 213491392,
        "sender_full_name": "tmandry",
        "timestamp": 1602797963
    },
    {
        "content": "<p>if you're curious, here are <a href=\"https://fuchsia-docs.firebaseapp.com/rust/fuchsia_zircon/index.html\">docs for our idiomatic Rust wrapper</a></p>",
        "id": 213491529,
        "sender_full_name": "tmandry",
        "timestamp": 1602798027
    },
    {
        "content": "<p>Awesome. Thanks for doing the sensible thing. :)</p>",
        "id": 213491598,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1602798076
    },
    {
        "content": "<p>sure but I can't take credit for it :)</p>",
        "id": 213491624,
        "sender_full_name": "tmandry",
        "timestamp": 1602798096
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I think the question can be split as well -- we could offer restricted-validity types while still leaving any layout optimizations as not guaranteed.</p>",
        "id": 213496981,
        "sender_full_name": "scottmcm",
        "timestamp": 1602801724
    },
    {
        "content": "<p>I think a big part of why we haven't looked at it yet, though, is that the first thing everyone always wants with this is <code>Integer&lt;MIN, MAX&gt;</code>.</p>",
        "id": 213497037,
        "sender_full_name": "scottmcm",
        "timestamp": 1602801764
    },
    {
        "content": "<p>This gets to that same conversation we had about alignment, and how it's a bit weird for the attributes to be reading const generic parameters that aren't actually defined yet.</p>",
        "id": 213497147,
        "sender_full_name": "scottmcm",
        "timestamp": 1602801846
    },
    {
        "content": "<p>I don't think we should promise any niche optimizations, because it should be possible for a compliant rust compiler to not support them or choose not to e.g. from a flag</p>",
        "id": 213526381,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602833223
    },
    {
        "content": "<p>But I like the vocabulary aspect of this; if we have a stable way to describe restricted validity types and let it propagate into the ecosystem than any niche improvements won't be so niche :)</p>",
        "id": 213526568,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1602833321
    },
    {
        "content": "<p>We already promise <code>Option&lt;&amp;T&gt;</code> is ABI compatible with a pointer that is either null or valid</p>",
        "id": 213549587,
        "sender_full_name": "simulacrum",
        "timestamp": 1602849266
    },
    {
        "content": "<p>Yeah but that would be easier for a new implementation to special case than to implement general niche optimization.</p>",
        "id": 213579923,
        "sender_full_name": "tmandry",
        "timestamp": 1602864294
    },
    {
        "content": "<p>I'd be fine with not making guarantees personally, as long as it's tested to work in rustc in release mode.</p>",
        "id": 213579934,
        "sender_full_name": "tmandry",
        "timestamp": 1602864300
    },
    {
        "content": "<p>I think I'd want to see where people end up <em>wanting</em> it as a guarantee.  IIRC people have wanted to do things like <code>Result&lt;Positive32, Negative32&gt;</code> in FFI (<code>HRESULT</code>).  And then we could talk about tradeoffs between general guarantees vs more specific cases, or whether these are better done with other features (like custom patterns, or...)</p>",
        "id": 213594098,
        "sender_full_name": "scottmcm",
        "timestamp": 1602871294
    },
    {
        "content": "<p>I've wanted an <code>IsOddN</code> for 32 and 64 before</p>",
        "id": 213625994,
        "sender_full_name": "Lokathor",
        "timestamp": 1602893198
    },
    {
        "content": "<p>We can't layout optimize based on that today.</p>",
        "id": 213626762,
        "sender_full_name": "scottmcm",
        "timestamp": 1602894429
    },
    {
        "content": "<p>well you asked what people wanted ;P</p>",
        "id": 213630410,
        "sender_full_name": "Lokathor",
        "timestamp": 1602900098
    },
    {
        "content": "<p>We're also going to have positive values mean success and negatives ones mean errors, but it will always be a status of some kind.</p>\n<p>If we're expanding the wish list, it would be cool (but challenging) to represent the entire status space with enums. We'd need to have some support for unrecognized values in enums (e.g. new error codes), while still bounding the set of possible values. We <em>might</em> even want to specify a particular layout for embedded integers (say, values 128-256 are all encoded as variant <code>Status::RemainingToRead(RangedU8&lt;1, 129&gt;)</code>).</p>\n<p>Otherwise we'll just represent it as a newtype'd ranged integer with helper methods. That would still fulfill the constraint of letting application code wrap a status in its own ADTs without increasing the size of the type.</p>",
        "id": 213632084,
        "sender_full_name": "tmandry",
        "timestamp": 1602903262
    },
    {
        "content": "<p>I feel like some of these cases are better handled with some sort of custom pattern support, rather than fitting them into layout optimizations.</p>",
        "id": 213633837,
        "sender_full_name": "scottmcm",
        "timestamp": 1602906944
    },
    {
        "content": "<p><code>IsOddN</code> can be a newtype around <code>NonZeroN</code> to get one niche, at least, while the compiler only deals with contiguous niche ranges.</p>",
        "id": 213656678,
        "sender_full_name": "cuviper",
        "timestamp": 1602948189
    },
    {
        "content": "<p><code>IsEvenN</code> can do the same wrapping something like <code>!x</code> or <code>x^1</code></p>",
        "id": 213656727,
        "sender_full_name": "cuviper",
        "timestamp": 1602948248
    },
    {
        "content": "<p>besides supporting more niches in the compiler and letting the user define niches, there are also some open issues around using our existing niches better</p>",
        "id": 213698391,
        "sender_full_name": "RalfJ",
        "timestamp": 1603014006
    },
    {
        "content": "<p>primarily, <a href=\"https://github.com/rust-lang/rust/issues/46213\">https://github.com/rust-lang/rust/issues/46213</a></p>",
        "id": 213698409,
        "sender_full_name": "RalfJ",
        "timestamp": 1603014065
    },
    {
        "content": "<p>While I don't think we are in a position to actually improve this right now, I would like to see (1) nested enums sharing a tag field (2) multiple tags or bools stuffed into one byte, for example <code>sizeof::&lt;Option&lt;Result&lt;(bool, (), bool), bool&gt;&gt;&gt;() == 1</code>, supported using write-back for references.</p>",
        "id": 213698548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603014299
    },
    {
        "content": "<p>I don't know if we would ever want to <em>promise</em> such complex layouts though</p>",
        "id": 213698630,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603014404
    },
    {
        "content": "<p>The logical endpoint of this is of course \"entropy encoding\", where you count up the number of possible values of the type and stuff them into the minimum number of bytes that have that many values. Clearly a pipe dream, but still an interesting thought experiment</p>",
        "id": 213698774,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603014626
    },
    {
        "content": "<blockquote>\n<p>write-back for references</p>\n</blockquote>\n<p>I think that's not possible... too much code already assumes how \"writing to a mutable ref\" works, e.g. <code>mem::swap</code></p>",
        "id": 213701517,
        "sender_full_name": "RalfJ",
        "timestamp": 1603019060
    },
    {
        "content": "<p>such things are only possible with \"no-reference\" fields I think</p>",
        "id": 213701525,
        "sender_full_name": "RalfJ",
        "timestamp": 1603019082
    },
    {
        "content": "<p>but it'd be great to have them that way!</p>",
        "id": 213701530,
        "sender_full_name": "RalfJ",
        "timestamp": 1603019090
    },
    {
        "content": "<p>Actually, it seems like we could write a <code>WriteBack&lt;T&gt;</code> even today, like so (sprinkle <code>unsafe</code> to taste):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PhantomData</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">WriteBack</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PhantomData</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">DerefMut</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">deref_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n<p>This doesn't work for all types, in particular anything that needs to be Pin, but as long as you can move the type it seems like a trick like this can be used to extract a field and present a uniform interface as a <code>&amp;mut bool</code> or whatever, packing the result when the <code>WriteBack</code> is dropped</p>",
        "id": 213701872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603019653
    },
    {
        "content": "<p>That needs <code>ManuallyDrop</code> for the first field and <code>std::ptr::write</code> in the drop impl and even then it doesn't prevent things like the following:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">wb</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"o\">*</span><span class=\"n\">wb</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"> </span><span class=\"c1\">// first drop of `a`</span>\n<span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">wb</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// second drop of `a`</span>\n</code></pre></div>",
        "id": 213702328,
        "sender_full_name": "bjorn3",
        "timestamp": 1603020517
    },
    {
        "content": "<p>What's the <code>ManuallyDrop</code> for? After the <code>drop</code> function runs, <code>self.0</code> should be moved out of</p>",
        "id": 213702460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603020771
    },
    {
        "content": "<p>or maybe that just wouldn't compile, and the replacement that does (<code>ptr::write</code>) doesn't have the moved out behavior?</p>",
        "id": 213702496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603020844
    },
    {
        "content": "<blockquote>\n<p>or maybe that just wouldn't compile</p>\n</blockquote>\n<p>Correct drop takes <code>&amp;mut self</code>, so you can't move out of it.</p>\n<blockquote>\n<p>and the replacement that does (ptr::write) doesn't have the moved out behavior?</p>\n</blockquote>\n<p>That one doesn't behave differently wrt <code>self.0</code> it only prevents <code>*self.1</code> from getting dropped, as you moved it in <code>new</code>. (that one needs to use <code>std::ptr::read</code> by the way, as <code>*ptr</code> only works for <code>Copy</code> types)</p>",
        "id": 213702616,
        "sender_full_name": "bjorn3",
        "timestamp": 1603021080
    },
    {
        "content": "<p>yeah, I'm writing in C style rust for sketch purposes</p>",
        "id": 213702672,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603021144
    },
    {
        "content": "<p>but the drop issue is a big problem; I suspected something like that would happen from the guaranteed destructors thread. If this were part of an advanced enum optimization, I would expect the compiler/borrow checker to be tracking these specially, such that <code>forget</code> actually runs the drop impl instead</p>",
        "id": 213702758,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603021319
    },
    {
        "content": "<p>We are back at <code>Drop</code> alone not being a reliable scoping pattern. But with a callback that pattern would work:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">ManuallyDrop</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"cm\">/* House */</span><span class=\"w\"> </span><span class=\"n\">MD</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">MD</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PhantomData</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">with_new</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">with</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">with</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}.</span><span class=\"n\">into</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PhantomData</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">DerefMut</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">deref_mut</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">WriteBack</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mf\">1.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">MD</span>::<span class=\"n\">take</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 213702827,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1603021411
    },
    {
        "content": "<p>wait, with that version does it even need to be a Drop impl? You could just call <code>with</code> and then write back after the function call</p>",
        "id": 213703002,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603021686
    },
    {
        "content": "<p>That could work. I tried to think of a way that <code>std::mem::swap(&amp;mut wb1, &amp;mut wb2)</code> could be misused, but I can't find any way.</p>",
        "id": 213703009,
        "sender_full_name": "bjorn3",
        "timestamp": 1603021716
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/layout.20optimization.20in.20stable.3F/near/213703002\">said</a>:</p>\n<blockquote>\n<p>wait, with that version does it even need to be a Drop impl? You could just call <code>with</code> and then write back after the function call</p>\n</blockquote>\n<p>It does need it because of <code>panic!()</code>.</p>",
        "id": 213703010,
        "sender_full_name": "bjorn3",
        "timestamp": 1603021724
    },
    {
        "content": "<p>I was wondering about that as well. If we <code>panic!</code>, there are lots of invariants that could be broken, certainly anything relying on a Drop impl, and so catching panics is very restricted. I was hoping that would be sufficient to skip the write back</p>",
        "id": 213703077,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603021811
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">vec</span><span class=\"o\">!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"n\">std</span>::<span class=\"n\">panic</span>::<span class=\"n\">catch_unwind</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">panic</span>::<span class=\"n\">AssertUnwindSafe</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">WriteBack</span>::<span class=\"n\">with_new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">panic</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">});</span><span class=\"w\"> </span><span class=\"c1\">// first drop in the drop glue of `WriteBack`</span>\n<span class=\"p\">});</span><span class=\"w\"></span>\n<span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// second drop</span>\n</code></pre></div>",
        "id": 213703157,
        "sender_full_name": "bjorn3",
        "timestamp": 1603021966
    },
    {
        "content": "<p>wait, why is <code>AssertUnwindSafe</code> not unsafe?</p>",
        "id": 213703239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603022092
    },
    {
        "content": "<p><code>UnwindSafe</code> only exists to prevent breaking logic invariants. It is not for preventing UB when unwinding. I believe there have even been calls to completely remove the <code>UnwindSafe</code> trait.</p>",
        "id": 213703297,
        "sender_full_name": "bjorn3",
        "timestamp": 1603022229
    },
    {
        "content": "<p>This thread shows there are interests in the subject but that there are different complexity level needed by different use case. Personally I think it would be great to have some sort of basic layout optimization support in stable, around valid/invalid values as discussed early in the thread.</p>",
        "id": 213703492,
        "sender_full_name": "marmeladema",
        "timestamp": 1603022589
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/layout.20optimization.20in.20stable.3F/near/213703002\">said</a>:</p>\n<blockquote>\n<p>wait, with that version does it even need to be a Drop impl? You could just call <code>with</code> and then write back after the function call</p>\n</blockquote>\n<p>You could simplify that to a <code>: FnOnce(&amp;mut T)</code> callback, and have <code>WriteBack</code> constituents (the separate <code>MD&lt;T&gt;</code> instance, and the <code>*mut T</code>) as function locals, but you'd always need a drop-pable or to <code>catch_unwind(); cleanup; resume_unwind()</code> to be unwind-safe. For that task, <a href=\"https://docs.rs/scopeguard\">https://docs.rs/scopeguard</a> can be quite handy:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">with_write_back</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">ptr</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">with</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"nb\">_</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span>: <span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">instance</span>: <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">read</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">instance_with_drop</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>::<span class=\"n\">scopeguard</span>::<span class=\"n\">guard</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Deref{,Mut}</span>\n<span class=\"w\">        </span><span class=\"n\">instance</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// on drop</span>\n<span class=\"w\">        </span><span class=\"o\">|</span><span class=\"n\">instance</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">with</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">instance_with_drop</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 213706092,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1603027130
    },
    {
        "content": "<p>Of course the present version, where you trade a <code>&amp;mut T</code> for another <code>&amp;mut T</code> is kind of useless; the real power of this is that the input to the write_back can be a getter/setter pair instead of a <code>&amp;mut T</code>. In the enum optimization case that would be the pack/unpack functions for extracting a field from a densely packed type like a bitfield</p>",
        "id": 213706794,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1603028244
    },
    {
        "content": "<p>Yes, I think we can agree that <code>&amp;mut T -&gt; &amp;mut T</code> is not the most interesting transformation <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>, but a more advanced <code>&amp;mut LayoutOptimizedOuter -&gt; &amp;mut Inner</code> using this pattern could indeed be useful <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 213706885,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1603028381
    }
]