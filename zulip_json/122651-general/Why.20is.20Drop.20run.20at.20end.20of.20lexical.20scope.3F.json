[
    {
        "content": "<p>This is a sort of general language question but I was wondering if anyone has a clear example / explanation of why Drop is done at the end of a lexcial scope rather than eagerly when a value stops being live? It seems to be related to ~unsafe~ code but I have a hard time understanding what code would be sound with drop at the end of a lexical scope and unsound otherwise..</p>",
        "id": 246835016,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626953754
    },
    {
        "content": "<p>A simple example would be drop guards.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_guard</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mutex</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"c1\">// critical section</span>\n<span class=\"w\">  </span><span class=\"c1\">// ...</span>\n<span class=\"w\">  </span><span class=\"c1\">// end, guard dropped here</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246836230,
        "sender_full_name": "The 8472",
        "timestamp": 1626954681
    },
    {
        "content": "<p>hmm ok, but that pattern seems to happen <em>because</em> drop runs at the end of a scope. if we had it run 'eagerly' then we could do things like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">mutex</span><span class=\"p\">.</span><span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n\n<span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 246836485,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626954850
    },
    {
        "content": "<p>Alternatives exist, but existing code has to keep working.</p>",
        "id": 246836619,
        "sender_full_name": "The 8472",
        "timestamp": 1626954963
    },
    {
        "content": "<ul>\n<li>It is more predictable, so it avoids potential footguns. </li>\n<li>Before NLLs this didn't make much sense (even borrows lasted until the end of the scope), now it is a breaking change (not that we really want that)</li>\n</ul>",
        "id": 246836667,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626954984
    },
    {
        "content": "<p>I think I have seen some proposal allowing more eager drops in some circumstances. I think it was with an annotation or something? But I can't find it right now.</p>",
        "id": 246836738,
        "sender_full_name": "The 8472",
        "timestamp": 1626955037
    },
    {
        "content": "<p>That gets annoying if you have multiple resources (two locks, two open files etc.) because you end up nesting closures.</p>",
        "id": 246836750,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626955040
    },
    {
        "content": "<p>tying functional behaviour to borrowck would also prevent improvements to borrowck in the first place.</p>",
        "id": 246836790,
        "sender_full_name": "nagisa",
        "timestamp": 1626955068
    },
    {
        "content": "<p>Closure APIs are also annoying when you need to e.g. initialize a local variable</p>",
        "id": 246836869,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955098
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"338379\">Giacomo Stevanato</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246836869\">said</a>:</p>\n<blockquote>\n<p>Closure APIs are also annoying when you need to e.g. initialize a local variable</p>\n</blockquote>\n<p>Or an early <code>return</code>.</p>",
        "id": 246836888,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626955123
    },
    {
        "content": "<p>I'm sure we'd come up with something like <code>with</code> statement in python if we needed a nice way to extend liveness of a resource.</p>",
        "id": 246836951,
        "sender_full_name": "nagisa",
        "timestamp": 1626955184
    },
    {
        "content": "<p>or perhaps just tell people to put <code>drop(x)</code> in the right places.</p>",
        "id": 246836965,
        "sender_full_name": "nagisa",
        "timestamp": 1626955196
    },
    {
        "content": "<p>(my personal opinion is that you want <code>drop(...)</code> anyway where it matters, even if it doesn't make a functional difference _right now_)</p>",
        "id": 246837068,
        "sender_full_name": "nagisa",
        "timestamp": 1626955225
    },
    {
        "content": "<p>these are all good and convincing arguments</p>",
        "id": 246837115,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955264
    },
    {
        "content": "<p>Anyway an example of <code>unsafe</code> code that's currently sound but would be unsound if variables were eagerly dropped:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// Now `v` is no longer used, can it be dropped?</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// This would be unsound if `v` was already dropped</span>\n</code></pre></div>",
        "id": 246837120,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955267
    },
    {
        "content": "<p>I was curious because it seems like the consequence of the current drop approach is that actually implementing Drop means you are riding the knife's edge of soundness</p>",
        "id": 246837149,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955297
    },
    {
        "content": "<p>since you may be interacting with data that has already been deallocated (ie <code>may_dangle</code>)</p>",
        "id": 246837170,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955314
    },
    {
        "content": "<p><code>may_dangle</code> is a promise you're not interacting with that data</p>",
        "id": 246837241,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955336
    },
    {
        "content": "<p>yea but its not enforced by the compiler, right?</p>",
        "id": 246837268,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955351
    },
    {
        "content": "<p>Also, it's unstable and requires an <code>unsafe impl</code></p>",
        "id": 246837287,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955364
    },
    {
        "content": "<p>No, but it's an <code>unsafe</code> contract,</p>",
        "id": 246837324,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626955397
    },
    {
        "content": "<p>yea, of course, but then someone like me has to go prove it sound <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 246837485,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955501
    },
    {
        "content": "<p>If <code>drop</code> was called eagerly you would have to prove that a lot more code is sound though</p>",
        "id": 246837628,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955572
    },
    {
        "content": "<p>6 of one, half a dozen of the other...</p>",
        "id": 246837649,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955600
    },
    {
        "content": "<p>Well, you still have to prove it, but it would become more difficult and error prone</p>",
        "id": 246837653,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955604
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246837649\">said</a>:</p>\n<blockquote>\n<p>6 of one, half a dozen of the other...</p>\n</blockquote>\n<p>?</p>",
        "id": 246837670,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955618
    },
    {
        "content": "<p>well i feel like if drop were eager the rules governing its safety would be simpler</p>",
        "id": 246837678,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"338379\">Giacomo Stevanato</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246837670\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246837649\">said</a>:</p>\n<blockquote>\n<p>6 of one, half a dozen of the other...</p>\n</blockquote>\n<p>?</p>\n</blockquote>\n<p>haha, just joking that by making drop 'simpler' to formalize it complicates other things :P</p>",
        "id": 246837714,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955658
    },
    {
        "content": "<p>And, as mentioned and demonstrated, a lot of existing code can be easily proven to be unsound with easy drop.<br>\nI also think that eager drop is more complicated, because my model of destructors is scope-length guards</p>",
        "id": 246837781,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626955698
    },
    {
        "content": "<p>ah interesting</p>",
        "id": 246837802,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955715
    },
    {
        "content": "<p>Technically you're only making <code>#[may_dangle]</code> simplier to formalize</p>",
        "id": 246837804,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955718
    },
    {
        "content": "<p>yea but if you formalize drop you want to formalize the complete version</p>",
        "id": 246837822,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246837781\">said</a>:</p>\n<blockquote>\n<p>And, as mentioned and demonstrated, a lot of existing code can be easily proven to be unsound with easy drop.<br>\nI also think that eager drop is more complicated, because my model of destructors is scope-length guards</p>\n</blockquote>\n<p>interesting, because to me it's more intuitive that destructors would be run as soon as a value is dead. And I agree that there is a lot of <em>current</em> code that would be unsound in that setup but if rust had made the eager-drop choice then that code would never have been written</p>",
        "id": 246837943,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955821
    },
    {
        "content": "<p>And with that model, I'd be more prone to writing code that relies on it, including for soundness. I inherited this model from C++, and I can imagine others coming from C++ may have similar ideas.</p>",
        "id": 246837951,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626955827
    },
    {
        "content": "<p>yea. that also explains a lot / makes sense since Rust does value familiarity with existing languages</p>",
        "id": 246838004,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955869
    },
    {
        "content": "<p>Even if people wrote unsafe code with the different drop in mind it would still be more error prone since it would be harder to determine the actual drop location of something</p>",
        "id": 246838115,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955951
    },
    {
        "content": "<p>Yeah. Rust has many differences from C++, but, for the most part, it makes those differences loud and obnoxious, rather than silent and \"Oh no my code is fundamentally broken\".</p>",
        "id": 246838123,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626955963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"338379\">Giacomo Stevanato</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246838115\">said</a>:</p>\n<blockquote>\n<p>Even if people wrote unsafe code with the different drop in mind it would still be more error prone since it would be harder to determine the actual drop location of something</p>\n</blockquote>\n<p>this is a good point since liveness analysis is not always super intuitive</p>",
        "id": 246838150,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626955988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"338379\">Giacomo Stevanato</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246837120\">said</a>:</p>\n<blockquote>\n<p>Anyway an example of <code>unsafe</code> code that's currently sound but would be unsound if variables were eagerly dropped:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// Now `v` is no longer used, can it be dropped?</span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"> </span><span class=\"c1\">// This would be unsound if `v` was already dropped</span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Take this for example, it not clear whether <code>v.as_mut_ptr()</code> keeps <code>v</code> alive or not</p>",
        "id": 246838154,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626955991
    },
    {
        "content": "<p>yea</p>",
        "id": 246838249,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956053
    },
    {
        "content": "<p>In any case, there is an <a href=\"#narrow/stream/243200-t-lang.2Fmajor-changes/topic/MCP.3A.20Allowing.20the.20compiler.20to.20eagerly.20drop.20val.E2.80.A6.20lang-team.2386\">open lang-team MCP</a> for this, but many of the objections presented here would apply to that (and a few others).</p>",
        "id": 246838271,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626956074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246837943\">said</a>:</p>\n<blockquote>\n<p>interesting, because to me it's more intuitive that destructors would be run as soon as a value is dead.</p>\n</blockquote>\n<p>Well, to be strict about it, the value is not dead until the destructor finishes with it. So that's a self-supporting argument that the destructor is run exactly when it should be</p>",
        "id": 246838348,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956136
    },
    {
        "content": "<p>true</p>",
        "id": 246838420,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956165
    },
    {
        "content": "<p>And of course, the compiler is free to reuse the storage when possible</p>",
        "id": 246838598,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956296
    },
    {
        "content": "<p>the compiler is free to reuse storage before the drop is run?</p>",
        "id": 246838669,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956365
    },
    {
        "content": "<p>I think that's only true if there is no drop</p>",
        "id": 246838698,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956385
    },
    {
        "content": "<p>ok, phew...</p>",
        "id": 246838766,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956409
    },
    {
        "content": "<p>I don't see why not (assuming <code>drop</code> doesn't touch it). But I guess that only covers some trivial cases.</p>",
        "id": 246838771,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956411
    },
    {
        "content": "<p>couldn't drop read the fields being dropped?</p>",
        "id": 246838798,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956432
    },
    {
        "content": "<p>Is there an annotation for that? It seems pretty hard for a drop impl to not read the data</p>",
        "id": 246838811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956442
    },
    {
        "content": "<p><code>#[may_dangle]</code> is about whether you touch the parameters of the type, not the type itself (which is always assumed to be touched)</p>",
        "id": 246838866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956476
    },
    {
        "content": "<p>But there are definitely dropless types that can become ill formed before the end of their scope, which makes formalization hard</p>",
        "id": 246838970,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956540
    },
    {
        "content": "<p>and I think some dropful types can have <code>drop</code> called when they are currently ill formed, which is even harder (this is what <code>@[may_dangle]</code> is about)</p>",
        "id": 246839075,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246838798\">said</a>:</p>\n<blockquote>\n<p>couldn't drop read the fields being dropped?</p>\n</blockquote>\n<p>If the drop implementation doesn't, and the compiler can prove it, it could theoretically reuse the storage of a live value of that type.</p>",
        "id": 246839086,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626956625
    },
    {
        "content": "<p>Yeah, that's what I meant, but that's probably not a very useful <code>drop</code></p>",
        "id": 246839164,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956653
    },
    {
        "content": "<p>is that admissible in the rust semantics?</p>",
        "id": 246839175,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956659
    },
    {
        "content": "<p>I think that's the general setting that <code>#[may_dangle]</code> is working under: the function nominally takes a <code>&amp;mut self</code>, but some of the fields are invalid and cannot be touched</p>",
        "id": 246839220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956688
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"203546\">Laurențiu</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246839164\">said</a>:</p>\n<blockquote>\n<p>Yeah, that's what I meant, but that's probably not a very useful <code>drop</code></p>\n</blockquote>\n<p>Scope guards that just run a (stateless) closure at exit.</p>",
        "id": 246839226,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626956694
    },
    {
        "content": "<p>You shouldn't be able to observe it unless you leak a pointer outside the scope and dereference it (which is unsafe)</p>",
        "id": 246839228,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246839226\">said</a>:</p>\n<blockquote>\n<p>Scope guards that just run a (stateless) closure at exit.</p>\n</blockquote>\n<p>Yeah, we already excluded that use case in favor of closure-taking APIs.</p>",
        "id": 246839270,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956725
    },
    {
        "content": "<p>not sure what you mean there</p>",
        "id": 246839307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956753
    },
    {
        "content": "<p>Which, as mentioned, can become incredibly tedious to work with.</p>",
        "id": 246839314,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626956757
    },
    {
        "content": "<p>you can still do drop based guards</p>",
        "id": 246839361,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956767
    },
    {
        "content": "<p>they aren't as airtight though because of leakpocalypse</p>",
        "id": 246839383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956785
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246839361\">said</a>:</p>\n<blockquote>\n<p>you can still do drop based guards</p>\n</blockquote>\n<p>With eager drop? How?</p>",
        "id": 246839408,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956807
    },
    {
        "content": "<p>Well, those are one of the arguments against eager drops</p>",
        "id": 246839417,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626956814
    },
    {
        "content": "<p>couldn't you also perform a side-effect without reading at all?</p>",
        "id": 246839443,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956835
    },
    {
        "content": "<p>I think that's what connor meant</p>",
        "id": 246839458,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956852
    },
    {
        "content": "<p>though I suppose you would extend 'doesn't read' to 'doesn't read and is pure'</p>",
        "id": 246839463,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626956857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246839314\">said</a>:</p>\n<blockquote>\n<p>Which, as mentioned, can become incredibly tedious to work with.</p>\n</blockquote>\n<p>Yeah, I mean not being able to use <code>return</code> would be a deal-breaker.</p>",
        "id": 246839475,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956868
    },
    {
        "content": "<p>I don't think it has to be pure, it's guaranteed to be called exactly once</p>",
        "id": 246839485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956880
    },
    {
        "content": "<p>*at most once</p>",
        "id": 246839526,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626956887
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246839443\">said</a>:</p>\n<blockquote>\n<p>couldn't you also perform a side-effect without reading at all?</p>\n</blockquote>\n<p>You can, but then it doesn't matter if the storage was reused or not</p>",
        "id": 246839532,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"203546\">Laurențiu</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246839475\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246839314\">said</a>:</p>\n<blockquote>\n<p>Which, as mentioned, can become incredibly tedious to work with.</p>\n</blockquote>\n<p>Yeah, I mean not being able to use <code>return</code> would be a deal-breaker.</p>\n</blockquote>\n<p>The nesting too, and the other restrictions on closures that aren't present with a scope-based api.</p>",
        "id": 246839564,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626956924
    },
    {
        "content": "<p>And not being able to do early drops</p>",
        "id": 246839622,
        "sender_full_name": "Laurențiu",
        "timestamp": 1626956966
    },
    {
        "content": "<p>Closures can't partially borrow values, IIRC, so if you mutably borrow a field of self to invoke the closure, then you can't touch anything else inside <code>self</code> during the closure</p>",
        "id": 246839698,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626957004
    },
    {
        "content": "<p>coming 2021</p>",
        "id": 246839739,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957026
    },
    {
        "content": "<p>well the good news (for me) is that my verification tool currently doesn't handle drop and just forbids any <code>Drop</code> impls</p>",
        "id": 246839852,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957120
    },
    {
        "content": "<p>much simpler that way :P</p>",
        "id": 246839896,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957125
    },
    {
        "content": "<p>I think Drop is currently uncharted territory in rust formalization</p>",
        "id": 246839925,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957149
    },
    {
        "content": "<p>I'd disagree, it's probably one of the easiest things to specify.</p>",
        "id": 246839944,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626957168
    },
    {
        "content": "<p>yea its currently unformalized in RustBelt because of may_dangle (in part at least)</p>",
        "id": 246840010,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957213
    },
    {
        "content": "<p>The fact that <code>drop</code> is a magic function that can't be called multiple times and lies about its type signature is one major issue</p>",
        "id": 246840023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957216
    },
    {
        "content": "<p>^</p>",
        "id": 246840038,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957225
    },
    {
        "content": "<p>but also the fact that you have 'borrowed ownership' of things that aren't there but claim (through their types) to be</p>",
        "id": 246840094,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246840023\">said</a>:</p>\n<blockquote>\n<p>The fact that <code>drop</code> is a magic function that can't be called multiple times and lies about its type signature is one major issue</p>\n</blockquote>\n<blockquote>\n<p>The function <code>Drop::drop</code> or an implementation thereof shall not be named by the program.</p>\n</blockquote>",
        "id": 246840124,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626957277
    },
    {
        "content": "<p>this is incompatible with how RustBelt (for example) currently represents ownership.. not insurmountable ofc</p>",
        "id": 246840141,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957292
    },
    {
        "content": "<p>Your type can also have lifetime arguments that have expired</p>",
        "id": 246840171,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957316
    },
    {
        "content": "<p>in vanilla rustbelt that's not an issue</p>",
        "id": 246840196,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957329
    },
    {
        "content": "<p>why is that?</p>",
        "id": 246840226,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957351
    },
    {
        "content": "<p>oh just that rustbelt doesn't assume that the lifetimes mentioned in types are always alive</p>",
        "id": 246840381,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957430
    },
    {
        "content": "<p>but to use borrows you have to prove the lifetime is alive</p>",
        "id": 246840415,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957452
    },
    {
        "content": "<p>I would really like to know what the \"real\" type signature of Drop::drop is, rustbelt style. In particular you have to be able to change the state of the object to some state that is not normally representable in the type: for example you can transition the guard to one that isn't guarding anymore, even though the type's invariant says that it guards a thing, and <code>drop</code> takes a <code>&amp;mut T</code> so seemingly you need it to still be a valid <code>T</code> when you are done</p>",
        "id": 246840541,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957514
    },
    {
        "content": "<p>yea thats the challenge</p>",
        "id": 246840586,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957546
    },
    {
        "content": "<p>because at somepoint you 'deallocate' which in rustbelt produces a value of type <code>uninit</code> but you need to recover a <code>T</code> from that</p>",
        "id": 246840622,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957577
    },
    {
        "content": "<p>Didn't rustbelt prove Arc sound, or something like that? Surely they would have had to tackle Drop to do that</p>",
        "id": 246840731,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957638
    },
    {
        "content": "<p>or maybe they just leaked everything</p>",
        "id": 246840740,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957647
    },
    {
        "content": "<p>Rustbelt proved Arc sound? That's kinda suprising.</p>",
        "id": 246840786,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626957681
    },
    {
        "content": "<p>there's a <code>drop_arc</code> and <code>drop_weak</code> function</p>",
        "id": 246840806,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957707
    },
    {
        "content": "<p>(See the atomic bomb for the reason)</p>",
        "id": 246840834,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626957723
    },
    {
        "content": "<p>why can't drop have the type <code>drop(self) {}</code>? It's still a little magic but it seems easier to understand on all fronts</p>",
        "id": 246840930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957773
    },
    {
        "content": "<p>it would be a LOT nicer tbh (on paper)</p>",
        "id": 246840971,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957799
    },
    {
        "content": "<p>What happens to <code>self</code>? Also, <code>Pin</code>.</p>",
        "id": 246840979,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626957803
    },
    {
        "content": "<p>oh wait, that wouldn't work for <code>drop_in_place</code></p>",
        "id": 246840985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957806
    },
    {
        "content": "<p>and pin</p>",
        "id": 246840994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957810
    },
    {
        "content": "<p>self magically disappears at the end of the function</p>",
        "id": 246841021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957832
    },
    {
        "content": "<p>What happens if you pass <code>self</code> into another function that takes ownership?</p>",
        "id": 246841089,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626957856
    },
    {
        "content": "<p>ok so... the type of <code>arc_drop</code> is different than what it would be in rust</p>",
        "id": 246841119,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957879
    },
    {
        "content": "<p><code>(fn(∅; arc ty) → option ty)</code> ie it's <code>drop(Arc&lt;T&gt;) -&gt; Option T</code></p>",
        "id": 246841154,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626957903
    },
    {
        "content": "<p>I guess in that case it would be dropped or leaked by that function</p>",
        "id": 246841170,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626957911
    },
    {
        "content": "<p>what a magical function</p>",
        "id": 246841373,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626958008
    },
    {
        "content": "<p>but the general model is that the ownership is passed around, and if you don't write <code>drop(x)</code>  at the end of the function the compiler inserts a regular call to the <code>drop</code> function. The only magical part is that the end of the <code>drop</code> impl is where deallocation happens</p>",
        "id": 246841377,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958012
    },
    {
        "content": "<p>well... you can definitely deallocate parts of the value during drop</p>",
        "id": 246841455,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626958060
    },
    {
        "content": "<p>In a formalization, I would say that the bottom of the drop impl is a call to <code>free(x)</code> that passes ownership back to the allocator</p>",
        "id": 246841469,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958071
    },
    {
        "content": "<p>yea thats probably what it should be in a formalized model</p>",
        "id": 246841529,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1626958087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246841469\">said</a>:</p>\n<blockquote>\n<p>In a formalization, I would say that the bottom of the drop impl is a call to <code>free(x)</code> that passes ownership back to the allocator</p>\n</blockquote>\n<p>How would this work arround things that just <code>drop</code> things in-place (<code>Rc</code>, <code>Arc</code>), or drop things then explicitly deallocate them (like <code>Box</code>)</p>",
        "id": 246841626,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626958154
    },
    {
        "content": "<p>The thing that is getting freed is just the memory of <code>x</code> itself. Other stuff like Box::drop would be handled by compiler inserted drop calls, and Rc and Arc are doing their own memory management</p>",
        "id": 246841817,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958247
    },
    {
        "content": "<p>maybe it's less mind bending to say that <code>drop</code> has the type <code>drop(&amp;move T) {}</code></p>",
        "id": 246841932,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958318
    },
    {
        "content": "<p>it's still behind a pointer, but it's passing ownership into the function and at the end of the function the memory pointed to is freed</p>",
        "id": 246842034,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958353
    },
    {
        "content": "<p>actually I guess it would just be uninit stack memory most of the time</p>",
        "id": 246842124,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958393
    },
    {
        "content": "<p>And when it isn't, what happens then? What exactly does it mean to implicitly free memory that may be managed explicitly?</p>",
        "id": 246842483,
        "sender_full_name": "Connor Horman",
        "timestamp": 1626958580
    },
    {
        "content": "<p>On second thought, it's not really a call to <code>free</code> at all. It's just passing ownership of the raw memory to whoever the ambient memory manager is, for example the stack frame or the box in which this value is contained. <code>Box::drop</code> will actually call <code>free</code> , but that's because it explicitly says so in the drop impl, not because of compiler magic</p>",
        "id": 246842683,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958688
    },
    {
        "content": "<p>Hm, I wonder how that works for Box. The call to free has to happen after the contents of the box are dropped, because the allocator wants to receive only raw memory, not a <code>T</code>. Does <code>#[may_dangle]</code> affect whether the call to <code>Box&lt;T&gt;::drop</code> happens before or after <code>T::drop</code>?</p>",
        "id": 246842985,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958845
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[stable(feature = </span><span class=\"s\">\"rust1\"</span><span class=\"cp\">, since = </span><span class=\"s\">\"1.0.0\"</span><span class=\"cp\">)]</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"cp\">#[may_dangle]</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span>: <span class=\"nc\">Allocator</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// FIXME: Do nothing, drop is currently performed by compiler.</span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>welp</p>",
        "id": 246843120,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626958911
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246842985\">said</a>:</p>\n<blockquote>\n<p>Hm, I wonder how that works for Box. The call to free has to happen after the contents of the box are dropped, because the allocator wants to receive only raw memory, not a <code>T</code>. Does <code>#[may_dangle]</code> affect whether the call to <code>Box&lt;T&gt;::drop</code> happens before or after <code>T::drop</code>?</p>\n</blockquote>\n<p><code>Box</code> is special cased in the compiler because you can actually move out of a box and then move back in, or even partially move out of it. The compiler keeps track of its contents as if they were in a local binding. When the <code>Box</code> goes out of scope it will make sure to drop only what is currently initialized and then it will call <code>free</code> (technically it's <code>Allocator::deallocate</code>).</p>",
        "id": 246845868,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626960329
    },
    {
        "content": "<p>After some testing, it seems like in <code>A&lt;B&lt;C&gt;&gt;</code>, it will first call <code>A::drop</code> then <code>B::drop</code> then <code>C::drop</code>, then <code>free(c)</code> then <code>free(b)</code> then <code>free(a)</code> (assuming there are heap allocations like Vec or Box in between)</p>",
        "id": 246846190,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626960480
    },
    {
        "content": "<p>and <code>may_dangle</code> doesn't affect drop order</p>",
        "id": 246846233,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626960489
    },
    {
        "content": "<p>So the state that <code>A::drop</code> is supposed to leave the object in is a bit mysterious to me. It needs to have cleaned up its invariants, but not any nested invariants for <code>B</code> and <code>C</code> because their drop impls haven't been called yet... but they might not even be valid if <code>may_dangle</code> is set...</p>",
        "id": 246846531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626960628
    },
    {
        "content": "<p>I guess you could say that <code>A::drop</code> should leave the type in a state that matches the nominal type of <code>A</code> as perceived by the compiler, i.e. the conjunction of all the fields of the struct, which the compiler knows how to deal with, but not things like outstanding reference counts that are invariants of the type not represented explicitly in the type system</p>",
        "id": 246846957,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626960841
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Why.20is.20Drop.20run.20at.20end.20of.20lexical.20scope.3F/near/246846531\">said</a>:</p>\n<blockquote>\n<p>So the state that <code>A::drop</code> is supposed to leave the object in is a bit mysterious to me. It needs to have cleaned up its invariants, but not any nested invariants for <code>B</code> and <code>C</code> because their drop impls haven't been called yet... but they might not even be valid if <code>may_dangle</code> is set...</p>\n</blockquote>\n<p>AFAIK <code>may_dangle</code> doesn't allow <code>B&lt;C&gt;</code> to become invalid if it has drop machinery</p>",
        "id": 246884825,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626977385
    },
    {
        "content": "<p>It pretty much asserts the the <code>Drop</code> implementation in which it is used will only move or drop values of the type marked with <code>#[may_dangle]</code> thus if they have <code>drop</code> machinery that still counts as an use and those types must be valid then</p>",
        "id": 246885087,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1626977509
    }
]