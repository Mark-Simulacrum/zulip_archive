[
    {
        "content": "<p>I find myself puzzled by the fact that I can't create a <code>std::ffi::CStr</code> from a buffer, if I don't already know where the NUL byte is located.</p>\n<p>For example,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">buffer</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">some_c_function</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">buffer</span><span class=\"p\">.</span><span class=\"n\">len</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">CStr</span>::<span class=\"n\">from_bytes_with_nul</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">buffer</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This code returns an error with <code>kind = InteriorNul</code>, because <code>from_bytes_with_nul()</code> expects that the caller has passed in a slice with the NUL byte at the end of the slice.</p>\n<p>I find this strange-- if I just got back a nul-terminated string from some FFI function, I probably don't know where the NUL byte is.</p>\n<p>There's also <code>CStr::from_ptr</code>, but that's an unsafe function that will happily read past the end of the buffer if a NUL byte isn't there.</p>\n<p>I am wishing that <code>Cstr</code> had another constructor that would:</p>\n<ul>\n<li>Accept <code>&amp;[u8]</code> as input</li>\n<li>Scan for the first NUL byte and return the <code>Cstr</code> that spans the correct sub-slice</li>\n<li>Return an error if no NUL byte is found within the input slice</li>\n</ul>\n<p>Various people on the internet <a href=\"https://stackoverflow.com/questions/42066381/how-to-get-a-str-from-a-nul-terminated-byte-slice-if-the-nul-terminator-isnt\">have constructed such a function</a>. This seems like it would be a very common need, so asking users to hand-code it themselves seems kind of tedious.</p>\n<p>Am I missing something obvious, or would this be a useful addition to std?</p>",
        "id": 275326581,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1647316087
    },
    {
        "content": "<p>Seems useful</p>",
        "id": 275326681,
        "sender_full_name": "Mark Drobnak",
        "timestamp": 1647316249
    },
    {
        "content": "<p>Yeah, <code>from_bytes_with_internal_nul</code> seems generally useful.</p>",
        "id": 275327044,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1647316731
    },
    {
        "content": "<p>Would it make sense for me to try this as a first contribution? What would my first step be?</p>",
        "id": 275327777,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1647317590
    },
    {
        "content": "<p>First draft code that implements this: <a href=\"https://github.com/rust-lang/rust/pull/94984\">https://github.com/rust-lang/rust/pull/94984</a></p>",
        "id": 275454323,
        "sender_full_name": "Eric Seppanen",
        "timestamp": 1647390605
    }
]