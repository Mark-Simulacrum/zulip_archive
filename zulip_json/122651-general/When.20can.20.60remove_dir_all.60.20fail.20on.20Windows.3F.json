[
    {
        "content": "<p>I'm looking at <a href=\"https://github.com/rust-lang/rust/issues/29497\">https://github.com/rust-lang/rust/issues/29497</a> and the <code>remove_dir_all</code> crate that was apparently created in response to this bug. I'm not really sure in which circumstances this bug can occur though, or how <code>remove_dir_all</code> avoids it in <a href=\"https://github.com/XAMPPRocky/remove_dir_all/blob/master/src/fs.rs\">https://github.com/XAMPPRocky/remove_dir_all/blob/master/src/fs.rs</a>, since it never retries deleting the directory. Can anyone shed some light on this?</p>\n<p>(I'm asking because I'd really like to avoid pulling in all of rayon just to delete a single directory containing a single file)</p>",
        "id": 250008166,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629389286
    },
    {
        "content": "<p>I believe the answer is \"spuriously\". As in, if you keep creating a directory with some files within and removing said directory, you will eventually encounter this problem. The comments on the thread suggest however that the crate is not the complete fix either.</p>",
        "id": 250009091,
        "sender_full_name": "nagisa",
        "timestamp": 1629389731
    },
    {
        "content": "<p>okay then I think I'm just going to ignore the error if that crate doesn't even fully fix it</p>",
        "id": 250009395,
        "sender_full_name": "Jonas Schievink  [he/him]",
        "timestamp": 1629389876
    },
    {
        "content": "<p>Essentially the problem is, with Win32 filesystem semantics, a file is marked for deletion but isn't actually deleted until all file handles are closed. And a directory can't be deleted until all files within are deleted. Additionally if you try to operate on a file after it is marked for deletion you'll get <code>ERROR_ACCESS_DENIED</code> (the NT kernel reports it as pending deletion but for some reason the win32 subsystem translates that to access denied).</p>\n<p>Putting this all together, if you try to delete a directory that isn't (yet) empty it'll fail. If you try to delete a file that's already pending deletion, it will fail.</p>",
        "id": 250010930,
        "sender_full_name": "Chris Denton",
        "timestamp": 1629390656
    },
    {
        "content": "<p>another factor may be services like defender that may touch files in the background, extending their lifespan a bit beyond what the program creating and destroying files expects</p>",
        "id": 250025335,
        "sender_full_name": "The 8472",
        "timestamp": 1629396893
    },
    {
        "content": "<p>This is often seen when using the pattern where a new file is created and then moved instead of overwriting an existing file. Whenever new files are created windows defender or a 3rd party antivirus will start scanning and that will \"lock\" the file. In the case of move, my regular fix is to do a retry loop with a short wait, something like 100-200ms.</p>\n<p>As others have said, remove is trickier as a retry might result in spurious access denied errors. When this happens the file/folder will be in limbo. It can't be removed because it's already pending removal and a new folder with the same name can't be created because it's not really removed yet.</p>\n<p>Tools like process explorer or handle from sysinternals can locate open handles based on a path and force close them but I don't think that's a good solution, more of a desperate workaround.</p>\n<p>The best way to avoid the situation is to try and control the patterns of use, e.g. Generate random names if possible, make sure to kill any sub process that might be using the folder and things like that.<br>\nIf it's caused by AV software the folder should disappear once they close their open file handles.</p>",
        "id": 250200211,
        "sender_full_name": "Pär Björklund",
        "timestamp": 1629526358
    }
]