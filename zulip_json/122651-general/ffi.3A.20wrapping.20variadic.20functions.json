[
    {
        "content": "<p>I'm probably going down the wrong road here, but I wanted to make sure I wasn't missing anything. I'm working on a library that wraps C functions that are provided by device firmware.</p>\n<p>Say I wanted to wrap a C function that is defined as <code>extern \"C\" fn test(x: u64, ...) -&gt; u64</code> in Rust. All of the varargs are expected to be the same type. The first thing I tried was defining the wrapper function as <code>extern \"C\" fn wrap_test(x: u64, varargs: ...) -&gt; u64</code> and simply passing the arguments through to the C function. This works, but it doesn't seem to accomplish much that using the external function directly wouldn't. It also feels strange to have an <code>extern \"C\"</code> wrapper that is only ever called from Rust code. </p>\n<p>Ideally, I would be able to define a normal Rust function such as <code>fn wrap_test(x: u64, varargs: &amp;[T]) -&gt; u64</code> that would then be able to unpack and build the function arguments from the <code>varargs</code> slice(similar to C++14's <code>std::apply</code>), but from what I've read this isn't (currently) possible. </p>\n<p>For fun, I implemented a version of the wrapper that does accept a slice and uses some wildly unsafe and abi-specific inline asm to unpack the slice and place the arguments in the correct registers and on the stack in the proper order(if needed), calls the C function, and then cleans up the stack. It works,  but I feel this isn't even remotely a good idea and I'd never include it in anything that might be used by someone else.</p>\n<p>Is there something similar to C++14's <code>std::apply</code> that I've missed?</p>",
        "id": 258501059,
        "sender_full_name": "Timothy Roberts",
        "timestamp": 1634802165
    },
    {
        "content": "<p>Defining vararg functions is currently unstable and thus requires nightly.</p>",
        "id": 258512421,
        "sender_full_name": "bjorn3",
        "timestamp": 1634807771
    },
    {
        "content": "<p>It should work otherwise, though.</p>",
        "id": 258572739,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634832387
    },
    {
        "content": "<p>Testing greatly appreciated.</p>",
        "id": 258572752,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634832393
    },
    {
        "content": "<p>I am already using the c_variadic feature in nightly, I guess a better question would be, is it possible to construct a VaList manually and pass that to the ffi function?</p>",
        "id": 258583593,
        "sender_full_name": "Timothy Roberts",
        "timestamp": 1634836515
    },
    {
        "content": "<p>I don't think so.</p>",
        "id": 258587900,
        "sender_full_name": "bjorn3",
        "timestamp": 1634838235
    },
    {
        "content": "<p>C doesn't support this either AFAICT: <a href=\"https://en.cppreference.com/w/cpp/header/cstdarg\">https://en.cppreference.com/w/cpp/header/cstdarg</a></p>",
        "id": 258588075,
        "sender_full_name": "bjorn3",
        "timestamp": 1634838305
    },
    {
        "content": "<p>C and C++ don't support a runtime-dynamic number of arguments to a variadic function, so I doubt that <code>&amp;[T]</code> could ever work</p>",
        "id": 258590405,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1634839178
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"451918\">@Timothy Roberts</span> If you're looking for that, I think you want the libffi library.</p>",
        "id": 258593036,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634840187
    },
    {
        "content": "<p>It supports constructing calls dynamically.</p>",
        "id": 258593049,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1634840192
    }
]