[
    {
        "content": "<p>I think <code>&amp;mut</code> should only be used if it's needed. It doesn't look like it's needed here. The effect of using <code>&amp;mut</code> would be to force the caller to have exclusive access to the <code>State</code>, which doesn't seem necessary since the locked data is the only field. However, if you plan to add more fields outside the lock then you might want to consider if this function will need exclusive access to the new fields.</p>",
        "id": 260402144,
        "sender_full_name": "Mike Leany",
        "timestamp": 1636117522
    },
    {
        "content": "<p>We don't need exclusive access at all. What we thought about was to use <code>&amp;mut</code> to ensure const-correctness.</p>",
        "id": 260404746,
        "sender_full_name": "Marcin Mielniczuk",
        "timestamp": 1636118867
    },
    {
        "content": "<p>I'm not sure what \"const-correctness\" means in this case. The compiler already enforces that you can't modify an immutable reference.</p>",
        "id": 260405659,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636119388
    },
    {
        "content": "<p>Generally, the correct thing is to not give mutable access when shared (non-<code>mut</code>) access will suffice. The point of interior mutability is to allow shared access to the container, meaning that <code>mut</code> isn't required. In summary, I think you should probably stick with the shared reference since you don't need exclusive access.</p>",
        "id": 260410548,
        "sender_full_name": "Mike Leany",
        "timestamp": 1636121726
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> the point here is that if I initialize the state as <code>let state = State::default()</code>, then the compiler should reject the call <code>state.update_data(...)</code> since <code>state</code> is an immutable variable and <code>update_data</code> mutates the state.</p>",
        "id": 260412520,
        "sender_full_name": "Marcin Mielniczuk",
        "timestamp": 1636122645
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"455523\">@Marcin Mielniczuk</span> <a href=\"https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html\">https://docs.rs/dtolnay/0.0.9/dtolnay/macro._02__reference_types.html</a></p>",
        "id": 260413033,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636122905
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232545\">@Joshua Nelson</span> Thanks. With this understanding, using <code>&amp;self</code> seems a perfect fit; however, if we understand <code>&amp;</code>/<code>&amp;mut</code> as shared/exclusive references, then it means that Rust doesn't really have a way to ensure const-correctness of methods.</p>",
        "id": 260416823,
        "sender_full_name": "Marcin Mielniczuk",
        "timestamp": 1636124513
    },
    {
        "content": "<p>That is true, there is no way to enforce that a type doesn't have interior mutability.</p>",
        "id": 260417451,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636124760
    },
    {
        "content": "<p>Hrm, with auto traits that should be possible, no?</p>",
        "id": 260422099,
        "sender_full_name": "The 8472",
        "timestamp": 1636126860
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"330154\">@The 8472</span> I'm not sure that actually meets their goal though - they have a function that takes <code>&amp;self</code> and they want to prevent calling it only in certain contexts</p>",
        "id": 260422170,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1636126900
    },
    {
        "content": "<p>\"<code>const</code>-correctness\", here, would have to be encoded/expressed by having descriptive names and/or descriptive docs, since, indeed, contrary to popular's belief / what the Rust book says, <code>&amp;</code> and <code>&amp;mut</code> do not have the semantics of  immutable and mutable references, respectively, but the semantics of shared and exclusive references. The latter is a stronger property than that of mutability, so it entails it, but the former has to interact with the question of shared mutability to know if it is an immutable reference or not.</p>\n<p>In this instance, given that you have <em>shared ownership</em> over the data, and that the <code>State</code> is thus just a \"handle\", unique access to a shared ownership is an oxymoron, and you should thus just be featuring <code>&amp;</code>-based APIs.</p>\n<p>If you really wanted <code>const</code>-correctness, you could express in the docs that your type has no shared mutability over the meaningful data it contains, and make the <code>Arc&lt;RwLock&lt;&gt;&gt;</code> layer be added by users of your type. That way, on top of <code>&amp;mut</code> = unique/exclusive =&gt; mutable ref, you'd have \"back\" the idea that <code>&amp;</code> =&gt; immutable thanks to the lack of shared ownership.</p>\n<p>Generally, the latter pattern is common for (some) public types, whereas the former (<code>Arc&lt;RwLock&lt;&gt;&gt;</code> inside) is very common for private types, as a way to reduce boilerplate when that private type is shared all around <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 260663276,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636381607
    }
]