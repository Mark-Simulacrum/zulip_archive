[
    {
        "content": "<p>Is it safe to transmute <code>&amp;[T]</code> to <code>&amp;[MaybeUninit&lt;T&gt;]</code>? I feel like it should be since T has strictly stronger invariants, but MaybeUninit is tricksy.</p>",
        "id": 268418086,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642523404
    },
    {
        "content": "<p>How about &amp;[&amp;[T]] to &amp;[&amp;[MaybeUninit&lt;T&gt;]] ? Unlike the one dimensional case, I don't see a way to make this conversion without transmuting</p>",
        "id": 268418216,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642523467
    },
    {
        "content": "<p>I'm only actually interested in T = u8, but I doubt it makes a difference</p>",
        "id": 268418924,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642523715
    },
    {
        "content": "<p>And you do specifically mean a <em>slice</em> not an <em>array</em>, right?</p>",
        "id": 268419858,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524112
    },
    {
        "content": "<p>yes</p>",
        "id": 268420101,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642524215
    },
    {
        "content": "<p>Is there ever a time where you can't immediately \"undo\" a transmute? That is, if you go from <code>T</code> -&gt; <code>U</code>, you gotta be able to immediately go back to <code>U</code> -&gt; <code>T</code>.</p>",
        "id": 268420109,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524217
    },
    {
        "content": "<p>And since <a href=\"https://doc.rust-lang.org/std/mem/union.MaybeUninit.html#method.slice_assume_init_ref\"><code>slice_assume_init_ref</code></a> exists, it seems like you can go back.</p>",
        "id": 268420287,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524278
    },
    {
        "content": "<p>Any time that the initial transmute itself is invalid (IE. <code>core::mem::transmute::&lt;u8,NonZeroU8&gt;(0)</code>)</p>",
        "id": 268420308,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642524287
    },
    {
        "content": "<p>Ah, good point, I was implicitly assuming a valid initial transmute.</p>",
        "id": 268420388,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524321
    },
    {
        "content": "<p>Note that the implementation of <code>slice_assume_init_ref</code> is not a <code>transmute</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"p\">(</span><span class=\"n\">slice</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"bp\">Self</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">])</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 268420484,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524360
    },
    {
        "content": "<p>I'd be hesitant to use <code>transmute</code> itself on a slice as it's a fat pointer / <code>repr(Rust)</code>.</p>",
        "id": 268420582,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524390
    },
    {
        "content": "<p>Feels like you should be able to use <code>std::slice::from_raw_parts</code> to do the nested case though.</p>",
        "id": 268420940,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524554
    },
    {
        "content": "<p>If the transmute is bad, then the nested case, which also relies on the layout of <code>&amp;[MaybeUninit&lt;T&gt;]</code> matching <code>&amp;[T]</code>, is also bad.</p>",
        "id": 268421102,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642524609
    },
    {
        "content": "<p>does repr(Rust) mean its unsound to transmute? Seems like it should be ok as long as the left and right side are both the same layout?</p>",
        "id": 268421171,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642524649
    },
    {
        "content": "<p>It's ok in that case. What makes it unsound is that it is not guaranteed it will be.</p>",
        "id": 268421284,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642524710
    },
    {
        "content": "<blockquote>\n<p>When transmuting between different compound types, you have to make sure they are laid out the same way! If layouts differ, the wrong fields are going to get filled with the wrong data, which will make you unhappy and can also be UB (see above).</p>\n<p>So how do you know if the layouts are the same? For repr(C) types and repr(transparent) types, layout is precisely defined. But for your run-of-the-mill repr(Rust), it is not. Even different instances of the same generic type can have wildly different layout. Vec&lt;i32&gt; and Vec&lt;u32&gt; might have their fields in the same order, or they might not. The details of what exactly is and is not guaranteed for data layout are still being worked out over at the UCG WG.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://doc.rust-lang.org/nomicon/transmutes.html\">https://doc.rust-lang.org/nomicon/transmutes.html</a></li>\n</ul>",
        "id": 268421407,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524757
    },
    {
        "content": "<p>TBH, slice pointers should at least be guaranteed to be layout-and-abi-compatible for abi-compatible types, because I don't see a reason not to, but they currently aren't.</p>",
        "id": 268421595,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642524826
    },
    {
        "content": "<p>And <code>MaybeUninit</code> is <code>#[repr(transparent)]</code>, so that's a good step.</p>",
        "id": 268421786,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642524894
    },
    {
        "content": "<p><code>struct Foo(u8, u8, u8)</code> and <code>struct Bar(u16, u8)</code> are both passed in a single register on x86_64 (with the systemv call conv), but they have a different alignment and thus aren't layout compatible.</p>",
        "id": 268421885,
        "sender_full_name": "bjorn3",
        "timestamp": 1642524937
    },
    {
        "content": "<p>abi-compatible here implies layout-compatible.</p>",
        "id": 268422023,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642524983
    },
    {
        "content": "<p>(So ig layout-and-abi-compatible is rundant)</p>",
        "id": 268422121,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642525024
    },
    {
        "content": "<p>Yeah, in practice, I don't think the compiler will ever make &amp;[T] and &amp;[U] have different layouts if T and U have the same layouts.  Using from_raw_parts here seems like ceremony</p>",
        "id": 268422324,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642525106
    },
    {
        "content": "<p>So <code>&amp;[T]</code> and <code>&amp;[Wrapper&lt;T&gt;]</code> (where <code>Wrapper&lt;T&gt;</code> is transparent over <code>T</code>) would be as-if they were <code>repr(transparent)</code> wrappers arround the same type basically.</p>",
        "id": 268422351,
        "sender_full_name": "Connor Horman",
        "timestamp": 1642525116
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> just make sure to put that assumption you just said into the <code>// SAFETY:</code> comment so you can recheck it in the future. :-)</p>",
        "id": 268422422,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642525146
    },
    {
        "content": "<p>Yeah, I can't see that comment coming back to haunt me in the future, nope, not at all.</p>",
        "id": 268422513,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642525186
    },
    {
        "content": "<p>Moving up a level, why do you want to do these transmutes in the first place?</p>",
        "id": 268422910,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1642525315
    },
    {
        "content": "<p>Implementing a buffer for vectored io where the internal repr is &amp;mut[&amp;mut [MaybeUninit&lt;u8&gt;]] and it can be initialised from &amp;mut[&amp;mut[u8]]</p>",
        "id": 268423158,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642525404
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/slices.20and.20MaybeUninit/near/268421786\">said</a>:</p>\n<blockquote>\n<p>And <code>MaybeUninit</code> is <code>#[repr(transparent)]</code>, so that's a good step.</p>\n</blockquote>\n<p>But its members are private, therefore you're not allowed to use the repr for reasoning. But you don't have to, the API contract already says</p>\n<blockquote>\n<p>MaybeUninit&lt;T&gt; is guaranteed to have the same size, alignment, and ABI as T:</p>\n</blockquote>",
        "id": 268427751,
        "sender_full_name": "The 8472",
        "timestamp": 1642527126
    },
    {
        "content": "<p>If you're doing that, Nick, you probably should just use &lt;<a href=\"https://doc.rust-lang.org/nightly/std/mem/union.MaybeUninit.html#method.slice_assume_init_mut\">https://doc.rust-lang.org/nightly/std/mem/union.MaybeUninit.html#method.slice_assume_init_mut</a>&gt;, and thus side-step any conversation about transmutes.  Hopefully more readable to have the method, too.</p>\n<p>(And it sounds like you're only talking about <em>validity</em>, so you're doing the necessary checks, but here's the obligatory mention that both directions of <code>&amp;mut [MaybeUninit&lt;T&gt;]</code> &lt;-&gt; <code>&amp;mut [T]</code> in general is a violation of <em>safety</em> invariants.)</p>",
        "id": 268428366,
        "sender_full_name": "scottmcm",
        "timestamp": 1642527377
    },
    {
        "content": "<p>slice_assume_init_mut is going the wrong way. I want to go from u8s to MaybeUninits</p>",
        "id": 268430127,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642528178
    },
    {
        "content": "<p>Why does it violate safety invariants to go from &amp;mut [T] to &amp;mut [MaybeUninit&lt;T&gt;]</p>",
        "id": 268430247,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642528227
    },
    {
        "content": "<p>?</p>",
        "id": 268430256,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642528230
    },
    {
        "content": "<p>(Oh, I see.  Odd that we don't have methods for the other direction too.)</p>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/122651-general/topic/slices.20and.20MaybeUninit/near/268430247\">said</a>:</p>\n<blockquote>\n<p>Why does it violate safety invariants to go from &amp;mut [T] to &amp;mut [MaybeUninit&lt;T&gt;]</p>\n</blockquote>\n<p>Because you can write an <code>uninit</code> into the array of supposed-to-be-initialized things.</p>",
        "id": 268430565,
        "sender_full_name": "scottmcm",
        "timestamp": 1642528373
    },
    {
        "content": "<p>That only becomes a problem once you start accessing the <code>&amp;mut [T]</code> again, or is it insta-UB?</p>",
        "id": 268430916,
        "sender_full_name": "The 8472",
        "timestamp": 1642528531
    },
    {
        "content": "<p>Oh right of course, I forgot that we'll still have a reference to the original. I guess that is just a safety requirement on the use of that type rather than the transmute (this is already done in std)</p>",
        "id": 268431872,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642528899
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/slices.20and.20MaybeUninit/near/268430916\">said</a>:</p>\n<blockquote>\n<p>That only becomes a problem once you start accessing the <code>&amp;mut [T]</code> again, or is it insta-UB?</p>\n</blockquote>\n<p>I don't <em>think</em> it's insta-UB, because afaik the model doesn't have typed memory.  So all memory can be considered potentially-uninitializable.  (Well, except frozen statics, but there the problem is the write in the first place; the fact that it's uninit doesn't really matter.)</p>\n<p>And right, Nick, just a safety invariant not a validity one.</p>",
        "id": 268433862,
        "sender_full_name": "scottmcm",
        "timestamp": 1642529822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span>  see <a href=\"https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.as_uninit\">https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.as_uninit</a> : it could be an issue if <code>T</code> has interior mutability and if <code>MaybeUninit</code> and <code>UnsafeCell</code> were allowed to commute</p>",
        "id": 268435939,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642530801
    },
    {
        "content": "<p>But for <code>Freeze</code> types such as <code>u8</code>, the <em>conversion</em> is sound. Now, the conversion ought to favor using <code>slice_from_raw_parts()</code> since the layout of references to slices is <code>#[repr(Rust)]</code>, and thus allowed to change across choices of (modulo-regions-)distinct types</p>",
        "id": 268436642,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642531140
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> Thanks all!</p>",
        "id": 268439338,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642532390
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/slices.20and.20MaybeUninit/near/268435939\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span>  see <a href=\"https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.as_uninit\">https://docs.rs/uninit/0.5.0/uninit/out_ref/struct.Out.html#method.as_uninit</a> : it could be an issue if <code>T</code> has interior mutability and if <code>MaybeUninit</code> and <code>UnsafeCell</code> were allowed to commute</p>\n</blockquote>\n<p>EDIT: given the safety invariants of <a href=\"https://doc.rust-lang.org/1.58.1/core/mem/union.MaybeUninit.html#safety-3\"><code>MaybeUninit::assume_init_ref</code></a>, we can now positively say that <code>Cell</code> and <code>MaybeUninit</code> do not commute / it is <em>unsound</em> for them to do so, as proved by <span class=\"user-mention\" data-user-id=\"210267\">@Nemo157</span>'s snippet:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"p\">{</span><span class=\"n\">cell</span>::<span class=\"n\">Cell</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">MaybeUninit</span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"sd\">/// This is *unsound*, as showcased below.</span>\n<span class=\"k\">fn</span> <span class=\"nf\">swap_mb_uninit_and_cell</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"nc\">Cell</span><span class=\"o\">&lt;</span><span class=\"n\">MaybeUninit</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Safety: both `Cell` and `MaybeUninit` are `#[repr(transparent)]`</span>\n<span class=\"w\">        </span>::<span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Safety: we just constructed it initialized</span>\n<span class=\"w\">        </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">assume_init_ref</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">swap_mb_uninit_and_cell</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">).</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">MaybeUninit</span>::<span class=\"n\">uninit</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=044c8e074ccc54a04a6f14c5a230b63a\">Playground</a> (run with miri top-right to check)</li>\n</ul>\n<p>cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 270555960,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643898137
    },
    {
        "content": "<p>I feel like this is fundamentally just a consequence of <code>Cell</code> being invariant over <code>T</code>.</p>",
        "id": 270563679,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1643900931
    },
    {
        "content": "<p>I share the feeling <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 270711708,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643980089
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"338379\">Giacomo Stevanato</span> <a href=\"#narrow/stream/122651-general/topic/slices.20and.20MaybeUninit/near/270563679\">said</a>:</p>\n<blockquote>\n<p>I feel like this is fundamentally just a consequence of <code>Cell</code> being invariant over <code>T</code>.</p>\n</blockquote>\n<p>Out of curiosity, how does invariance play into this? Other invariant wrappers like <code>UnsafeCell</code> (requires <code>unsafe</code>) or <code>AtomicUsize</code> (can't set uninit bytes) don't seem to have this problem. I guess if there existed an <code>Atomic&lt;T&gt;</code> then it would have this issue, too, though!</p>",
        "id": 270954615,
        "sender_full_name": "Pointerbender",
        "timestamp": 1644227716
    },
    {
        "content": "<p>Cell is the only invariant type that:</p>\n<ul>\n<li>a)  Is transparent over its field, supplied by a type parameter, and</li>\n<li>b) provides safe access</li>\n</ul>\n<p>I'd argue that it's likewise fundamentally unsound for <code>UnsafeCell</code>, but this unsoundness doesn't manifest outside of an unsafe api. That is, it's still unsound to transpose <code>UnsafeCell</code> and <code>MaybeUninit</code>, and it's perfectly valid to create a safe interface for <code>UnsafeCell</code> that assumes this (assuming other invariants are upheld).</p>",
        "id": 270989918,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644245987
    },
    {
        "content": "<p>It's also unsound  for RefCell, but the unsoundness is more obvious given that a RefCell isn't just an UnsafeCell&lt;T&gt;, and is repr(Rust) (thus the layout of <code>MaybeUninit&lt;RefCell&lt;T&gt;&gt;</code> and <code>RefCell&lt;MaybeUninit&lt;T&gt;&gt;</code> can be different)</p>",
        "id": 270990204,
        "sender_full_name": "Connor Horman",
        "timestamp": 1644246064
    },
    {
        "content": "<p>That makes sense, thanks!</p>",
        "id": 271007054,
        "sender_full_name": "Pointerbender",
        "timestamp": 1644252554
    },
    {
        "content": "<blockquote>\n<p>Out of curiosity, how does invariance play into this?</p>\n</blockquote>\n<p>Because converting a <code>&amp;Cell&lt;T&gt;</code> to a <code>&amp;Cell&lt;MaybeUninit&lt;T&gt;&gt;</code> has the same problem as converting from a <code>&amp;Cell&lt;&amp;'long T&gt;</code> to a <code>&amp;Cell&lt;&amp;'short T&gt;</code> (which invariance exist to prevent from): it allows you to write a value that has less invariants than what was originally expected. </p>\n<blockquote>\n<p>Other invariant wrappers like UnsafeCell (requires unsafe) or AtomicUsize (can't set uninit bytes) don't seem to have this problem.</p>\n</blockquote>\n<p><code>UnsafeCell</code> requires <code>unsafe</code> to write through a shared reference (and that's what triggers the problem, because otherwise you can only mutate through <code>&amp;mut UnsafeCell&lt;T&gt;</code> which is already invariant). <code>AtomicUsize</code> doesn't have any generic parameter, so variance is not a thing there.</p>",
        "id": 271059277,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1644276803
    },
    {
        "content": "<blockquote>\n<p>it allows you to write a value that has less invariants than what was originally expected.</p>\n</blockquote>\n<p>Thanks! This is a really nice way of explaining it, that really clicked for me.</p>",
        "id": 271090297,
        "sender_full_name": "Pointerbender",
        "timestamp": 1644305603
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> interesting example. :D<br>\nBut this is not <em>too</em> surprising, after all, <code>Cell&lt;Option&lt;T&gt;&gt;</code> and <code>Option&lt;Cell&lt;T&gt;&gt;</code> are also very different types -- and <code>MaybeUninit</code> is basically <code>Option</code> but without runtime tracking of the <code>None</code> case.</p>",
        "id": 271101093,
        "sender_full_name": "RalfJ",
        "timestamp": 1644312530
    }
]