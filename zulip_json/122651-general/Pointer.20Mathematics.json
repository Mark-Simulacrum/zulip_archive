[
    {
        "content": "<p>I have been experiencing some weird results from pointer mathematics. I know that they should be avoided when possible, but in my particular use-case it is necessary. When performing the following subtraction:</p>\n<div class=\"codehilite\"><pre><span></span><code>  0x7ffd2541f67e\n- 0x00000000000e\n</code></pre></div>\n<p>I would expect the result to be <code>0x7ffd2541f670</code>. However, the result is sporadically different. Does the <code>.sub()</code> function for <code>*mut &lt;T&gt;</code> and <code>*const &lt;T&gt;</code> perform non-standard hexadecimal subtraction?</p>",
        "id": 253139336,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631558682
    },
    {
        "content": "<p>Where do the pointer and offset come from? I don't think <code>sub</code> is doing anything non-standard.</p>",
        "id": 253140207,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631559013
    },
    {
        "content": "<p>What does the code look like?</p>",
        "id": 253140221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559017
    },
    {
        "content": "<p>Oh weird, I was <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ab47b41ed911f6ae7586b4ed26d47b26\">able to confim</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0x7ffd2541f67e</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mh\">0x00000000000e</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">sub</span><span class=\"p\">(</span><span class=\"n\">off</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{:x?} - {:x?} = {:x?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">off</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// 0x7ffd2541f67e - e = 0x7ffd2541f67e</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 253140894,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559292
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3f43b276ca9c20d9e14e9dc8cbdcd385\">Example Code</a></p>",
        "id": 253141174,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631559383
    },
    {
        "content": "<p>I know that dereferencing a pointer can caused UB, but in this case I know it will only be used against a specific architecture. I feel like this is less of a problem with UB as much as it is with the <code>.sub()</code> function.</p>",
        "id": 253141351,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631559456
    },
    {
        "content": "<p>Like <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> mentioned, it is reproducible outside of my particular example.</p>",
        "id": 253141383,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631559473
    },
    {
        "content": "<blockquote>\n<p>Both the starting and resulting pointer must be either in bounds or one byte past the end of the same allocated object</p>\n</blockquote>\n<p>I was skimming <a href=\"https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\">https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html</a>, but it's right there in the docs for <code>sub</code></p>",
        "id": 253141627,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631559571
    },
    {
        "content": "<p>So I am getting undefined behavior because the memory is too far apart?</p>",
        "id": 253141871,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631559649
    },
    {
        "content": "<p>I don't know in your case. In <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> that's UB because the code pulls a pointer out of the thin air</p>",
        "id": 253142019,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631559716
    },
    {
        "content": "<p><a href=\"https://kristerw.blogspot.com/2016/03/c-pointers-are-not-hardware-pointers.html\">https://kristerw.blogspot.com/2016/03/c-pointers-are-not-hardware-pointers.html</a> is a good read</p>",
        "id": 253142034,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631559721
    },
    {
        "content": "<p>That's not UB if there is something there</p>",
        "id": 253142091,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559736
    },
    {
        "content": "<p>and the compiler can't know that there isn't in this case</p>",
        "id": 253142117,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559749
    },
    {
        "content": "<p>so I don't see how it can miscompile here</p>",
        "id": 253142152,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559769
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"203546\">@Laurențiu</span> There is a value at the location provided, so while a good read, I don't know that it directly relates to this.</p>",
        "id": 253142239,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631559816
    },
    {
        "content": "<blockquote>\n<p>Similarly, subtraction of pointers are only allowed for array objects, and both pointers must point into the same array object (or the byte following the object).</p>\n</blockquote>",
        "id": 253142300,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631559842
    },
    {
        "content": "<p>The crazy optimizations usually only happen when you use a pointer to <code>malloc</code> or a local or something, so that the compiler can reason about whether they are in fact in separate allocations</p>",
        "id": 253142353,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559851
    },
    {
        "content": "<p>I assume it's similar in Rust</p>",
        "id": 253142358,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631559853
    },
    {
        "content": "<p>There very well might be an array object at the target location, the compiler can't know whether this is the case</p>",
        "id": 253142413,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559882
    },
    {
        "content": "<p>By the way, that quote doesn't sound like Rust</p>",
        "id": 253142501,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559933
    },
    {
        "content": "<p>in Rust you can do arbitrary arithmetic on pointers within the bounds of an allocation, there is no \"typed memory\" like in C/C++</p>",
        "id": 253142548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631559961
    },
    {
        "content": "<p>That was my understanding, as well</p>",
        "id": 253142655,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631559992
    },
    {
        "content": "<p>But the value in the snippet above is not inside an allocation</p>",
        "id": 253142797,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631560056
    },
    {
        "content": "<p>how can you know that?</p>",
        "id": 253142820,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560065
    },
    {
        "content": "<p>it might have been created in another thread</p>",
        "id": 253142863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560077
    },
    {
        "content": "<p>But it wasn't</p>",
        "id": 253142936,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631560098
    },
    {
        "content": "<p>I mean in the example that's obviously not the case but you get the point</p>",
        "id": 253142955,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560107
    },
    {
        "content": "<p>you would need global program analysis to determine it for sure</p>",
        "id": 253142996,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560130
    },
    {
        "content": "<p>Under normal conditions that analysis isn't even possible, so compilers have to be conservative</p>",
        "id": 253143044,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560155
    },
    {
        "content": "<blockquote>\n<p>This kind of provenance also exists in C/C++, but Rust is more permissive by (a) providing a way to do pointer arithmetic across allocation boundaries without causing immediate UB (though, as we have seen, the resulting pointer still cannot be used for locations outside the allocation it originates), and (b) by allowing pointers to always be compared safely, even if their provenance differs.</p>\n</blockquote>\n<p>Interesting</p>",
        "id": 253143056,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631560162
    },
    {
        "content": "<p>which means that \"wild\" pointers act basically like hardware pointers in C/C++/Rust</p>",
        "id": 253143095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560178
    },
    {
        "content": "<p>Also, as an aside, performing the same task in C behaves as expected.</p>",
        "id": 253143256,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631560233
    },
    {
        "content": "<p><a href=\"https://rust.godbolt.org/z/nT7M5W98E\">https://rust.godbolt.org/z/nT7M5W98E</a> nice</p>",
        "id": 253143327,
        "sender_full_name": "Laurențiu",
        "timestamp": 1631560267
    },
    {
        "content": "<p>Note that <code>wrapping_sub</code> has fewer requirements than <code>sub</code>, so if there is a UB issue this might make a difference, but in this case it acts the same</p>",
        "id": 253143383,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560287
    },
    {
        "content": "<p>Oh <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></p>",
        "id": 253143446,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560319
    },
    {
        "content": "<p><code>()</code> is a zst</p>",
        "id": 253143502,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560325
    },
    {
        "content": "<p>so offsetting adds a multiple of 0</p>",
        "id": 253143528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560338
    },
    {
        "content": "<p>if you use <code>*const u8</code> it acts as expected</p>",
        "id": 253143667,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560409
    },
    {
        "content": "<p>The issue in your code <span class=\"user-mention\" data-user-id=\"433828\">@Larry Dewey</span> seems to be similar: you are using <code>*const u64</code> so the offset takes you 8 times further than expected</p>",
        "id": 253144153,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560657
    },
    {
        "content": "<p>By the way that <code>offsetof!</code> macro is UB</p>",
        "id": 253144433,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560786
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Can you explain this a bit, or provide a link to some docs? I was under the impression that <code>e / 14</code> was the value regardless of type.</p>",
        "id": 253144467,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631560802
    },
    {
        "content": "<p>It's like pointer arithmetic in C</p>",
        "id": 253144535,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560818
    },
    {
        "content": "<p>if you have <code>T* x</code> then <code>x + i</code> has a numerical value of <code>(size_t)x + i*sizeof(T)</code></p>",
        "id": 253144875,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560905
    },
    {
        "content": "<p>that is, <code>i</code> is actually some number of multiples of the size of the type</p>",
        "id": 253145039,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560931
    },
    {
        "content": "<p>so that the desugaring <code>&amp;x[i] = (&amp;x + i)</code> makes sense</p>",
        "id": 253145149,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631560957
    },
    {
        "content": "<p>This is mentioned in the <a href=\"https://doc.rust-lang.org/std/primitive.pointer.html#method.sub\">docs</a>:</p>\n<blockquote>\n<p>Calculates the offset from a pointer (convenience for <code>.offset((count as isize).wrapping_neg())</code>).</p>\n<p><code>count</code> is in units of T; e.g., a <code>count</code> of 3 represents a pointer offset of <code>3 * size_of::&lt;T&gt;()</code> bytes.</p>\n</blockquote>",
        "id": 253145409,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631561071
    },
    {
        "content": "<p>Oh gotcha. That makes a lot more sense. I was using assuming <code>.sub()</code> was performing standards hex subtraction, not performing offset, as well.</p>",
        "id": 253145752,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631561211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Pointer.20Mathematics/near/253144433\">said</a>:</p>\n<blockquote>\n<p>By the way that <code>offsetof!</code> macro is UB</p>\n</blockquote>\n<p>I am aware of that, but it is the standard fallback for the Linux kernel. I am open to suggestions.</p>",
        "id": 253146137,
        "sender_full_name": "Larry Dewey",
        "timestamp": 1631561386
    },
    {
        "content": "<p>I would suggest using the <a href=\"https://crates.io/crates/memoffset\"><code>memoffset</code></a> crate, or its implementation, which uses a pointer to an unitialized stack local (relying on dead code elimination to remove it) instead of the null pointer</p>",
        "id": 253147174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1631561813
    }
]