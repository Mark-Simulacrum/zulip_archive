[
    {
        "content": "<p>I was looking at the assembly generated for accessing <code>thread_local!</code> variables (on Linux amd64), and noticed that the assembly was ever so slightly different depending on whether the thread-local variable was defined inside the executable directly (e.g. inside <code>src/bin/my_executable.rs</code>), or inside the library (e.g. inside <code>src/lib.rs</code>), even if the library is statically linked to the executable (as far as I understand).</p>\n<p>In short, accessing the executable's thread local generates:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">mov</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">fs</span>:<span class=\"o\">-</span><span class=\"mh\">0x48</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Whereas accessing the library's thread local generates:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">mov</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">fs</span>:<span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"n\">mov</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mh\">0x40</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The thing is, as far as I am aware, the value at <code>%fs:0</code> is just the value in <code>%fs</code> itself, under <a href=\"https://www.akkadia.org/drepper/tls.pdf\">TLS models for ELF</a>. If that is true, then accessing the library's thread local should similarly be a single <code>mov %fs:-0x40,%rax</code>.</p>\n<p>Unfortunately, I cannot replicate the behaviour on Godbolt, as it invokes <code>rustc</code> on a single file (as far as I can tell), or the Rust playground, which either compiles a shared library or an executable (depending on whether a <code>main</code> function is defined). But I have created a self-contained Cargo project that anyone can clone and look at: <a href=\"https://github.com/Raekye/rust-tlstest\">https://github.com/Raekye/rust-tlstest</a> . The README also contains the <code>objdump</code> commands to look at the generated assembly on your local artifacts yourself</p>",
        "id": 276140077,
        "sender_full_name": "Raekye",
        "timestamp": 1647919977
    },
    {
        "content": "<p>that doesn't sound unusual. they're statically linked but are two crates in one case, so the codegen is done separately, and LTO must have whiffed on this one.</p>",
        "id": 276140198,
        "sender_full_name": "Jubilee",
        "timestamp": 1647920129
    },
    {
        "content": "<p>The thing is it <em>knows</em> that it can access the thread local by a fixed offset from the TLS/TCB structure at <code>%fs:0</code>, but it hasn't realized that the word at <code>%fs:0</code> is always just <code>%fs</code>. If you look at the TLS models in <a href=\"https://www.akkadia.org/drepper/tls.pdf\">TLS models for ELF</a>, you can see that both the code snippets (for the library thread local access and executable thread local access) are for the \"local exec\" model; it first shows the longer version (the 2 instructions generated for the library), then says \"or shorter\" followed by the 1-instruction sequence (section 4.4.6)</p>",
        "id": 276140485,
        "sender_full_name": "Raekye",
        "timestamp": 1647920436
    },
    {
        "content": "<p>In the library case rustc should use the global dynamic TLS model. The linker can optimize it to local exec I think.</p>",
        "id": 276145582,
        "sender_full_name": "bjorn3",
        "timestamp": 1647927407
    },
    {
        "content": "<p>The more I look into it, the more I am convinced - <strong>both</strong> the library and binary <strong>are</strong> using local exec, but the code generated for the library just is the longer (but computationally identical) version in <a href=\"https://www.akkadia.org/drepper/tls.pdf\">ELF Handling for TLS</a> (section 4.4.6)</p>\n<p>One can easily see all 4 models being used in C: <a href=\"https://godbolt.org/z/a19zoqc3E\">https://godbolt.org/z/a19zoqc3E</a> . Note that there is nothing that looks like the assembly for the library function:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">mov</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">fs</span>:<span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"n\">mov</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"mh\">0x40</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n</code></pre></div>\n<p>because it can be simply <code>mov %fs:-0x40,%rax</code>, since <code>%fs:0</code> is <code>%fs</code> [*].</p>\n<p>Basically, regardless of there being a library crate + binary crate, rustc/llvm has figured out to use the local exec (most optimal) model, but it just... doesn't use the optimal instruction sequence (unless someone can correct me about <code>%fs:0</code> being <code>%fs</code> [*]).</p>\n<p>Here are a couple other sources about TLS: <a href=\"https://maskray.me/blog/2021-02-14-all-about-thread-local-storage\">blog</a> and <a href=\"https://lists.llvm.org/pipermail/llvm-dev/2017-November/118887.html\">llvm mailing list</a></p>\n<p>[*] To be clear, <code>mov %fs:0,%rax</code>is (AFAIK) \"load the word at offset 0 from <code>%fs</code>\", which is not obviously the same as <code>%fs</code>. But in ELF the word at <code>%fs:0</code> is always set to the value of <code>%fs</code>; it's basically a pointer to itself. And I'm trying to say that if you know the constant offset you want to access, which at some point/by the end rustc/llvm does (presumably link time), there's no reason to use the two instructions instead of one</p>",
        "id": 276183442,
        "sender_full_name": "Raekye",
        "timestamp": 1647953603
    },
    {
        "content": "<p>You can try playing around with the <code>-Z tls-model</code> option to see how it affects codegen.</p>",
        "id": 276183984,
        "sender_full_name": "Amanieu",
        "timestamp": 1647953866
    },
    {
        "content": "<p>Rustc uses global dynamic, not local exec for libraries. If you look at the unlinked object files you will see <code>__tls_get_addr</code> together with a whole lot of unnecessary prefixes to pad the whole sequence. This allows the linker to relax it to local exec when linking.</p>",
        "id": 276185287,
        "sender_full_name": "bjorn3",
        "timestamp": 1647954439
    },
    {
        "content": "<p>I have; here is a Godbolt showing local-exec and initial-exec (local and global dynamic are not relevant here/I didn't want to crowd the panes): <a href=\"https://rust.godbolt.org/z/xov6P75oY\">https://rust.godbolt.org/z/xov6P75oY</a> (note that I'm calling <code>Cell::replace</code> so that it doesn't get optimized to a constant, so there is a <code>mov</code> to load and a <code>mov</code> to store). The codegen for the initial-exec model looks nothing like what's generated above, and the codegen for local-exec is the 1-instruction sequence. It's only when the TLS is defined (privately) in a library statically linked to a binary that it uses the 2-instruction sequence</p>\n<p>(I don't mean to be a freak over literally just 1 extra instruction; I was initially looking at the assembly to see/understand if another TLS model was being used for my code, but at my current understanding of what's going on, the codegen seems unsatisfying)</p>",
        "id": 276185317,
        "sender_full_name": "Raekye",
        "timestamp": 1647954454
    },
    {
        "content": "<p>TLS inside a binary makes rustc use local-exec so when writing the object file you already have the shorter sequence. When in a library global-dynamic is used, causing the linker to rewrite the sequence when linking into a binary. This rewriting in the linker probably doesn't know about the shorter sequence.</p>",
        "id": 276185952,
        "sender_full_name": "bjorn3",
        "timestamp": 1647954745
    },
    {
        "content": "<p>(To be clear, in my test project <a href=\"https://github.com/Raekye/rust-tlstest\">https://github.com/Raekye/rust-tlstest</a> I am looking at the final binary object file (with the library code statically linked). I did look at the library .rlib archive before. Specifically, <code>objdump --disassemble=get_lib_tl target/release/libtlstest.rlib</code> shows the following, which isn't quite what bjorn3 said (maybe because it's just the .rlib and I didn't tell it to created a shared object?), though it certainly looks like a placeholder)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mi\">0000000000000000</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">&gt;</span>:\n   <span class=\"mi\">1</span>:   <span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">    </span><span class=\"n\">lea</span><span class=\"w\">    </span><span class=\"mh\">0x0</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rip</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"w\">        </span>#<span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">+</span><span class=\"mh\">0x8</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"mi\">8</span>:   <span class=\"nc\">e8</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">          </span><span class=\"n\">call</span><span class=\"w\">   </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">+</span><span class=\"mh\">0xd</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276186220,
        "sender_full_name": "Raekye",
        "timestamp": 1647954895
    },
    {
        "content": "<p>get_lib_tl calls some other function it seems. This function does the actual TLS access.</p>",
        "id": 276186384,
        "sender_full_name": "bjorn3",
        "timestamp": 1647954969
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122651-general/topic/Assembly.20generated.20for.20thread-local.20access.20.28on.20Linux.20amd64.29/near/276185952\">said</a>:</p>\n<blockquote>\n<p>TLS inside a binary makes rustc use local-exec so when writing the object file you already have the shorter sequence. When in a library global-dynamic is used, causing the linker to rewrite the sequence when linking into a binary. This rewriting in the linker probably doesn't know about the shorter sequence.</p>\n</blockquote>\n<p>This makes sense. Now is this even related to rustc, or is it entirely the llvm linker (I'm guessing?)?</p>",
        "id": 276186659,
        "sender_full_name": "Raekye",
        "timestamp": 1647955102
    },
    {
        "content": "<p>It is whatever linker you use. Binutils ld, gold, lld, mold or any other elf linker.</p>",
        "id": 276186905,
        "sender_full_name": "bjorn3",
        "timestamp": 1647955206
    },
    {
        "content": "<p>I didn't configure anything linker related; would the default be llvm's lld (I'm guessing since rustc uses llvm)?</p>",
        "id": 276187034,
        "sender_full_name": "Raekye",
        "timestamp": 1647955275
    },
    {
        "content": "<p>Not yet. You are probably using ld from binutils as this is what gcc uses by default.</p>",
        "id": 276187256,
        "sender_full_name": "bjorn3",
        "timestamp": 1647955364
    },
    {
        "content": "<p>I realized my code paste for <code>get_lib_tl</code> in <code>libtlstest.rlib</code> was cut off, here is the full code (not that it makes much sense to me):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mi\">0000000000000000</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">&gt;</span>:\n   <span class=\"mi\">0</span>:   <span class=\"mi\">50</span><span class=\"w\">                      </span><span class=\"n\">push</span><span class=\"w\">   </span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"mi\">1</span>:   <span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">    </span><span class=\"n\">lea</span><span class=\"w\">    </span><span class=\"mh\">0x0</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rip</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"w\">        </span>#<span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">+</span><span class=\"mh\">0x8</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"mi\">8</span>:   <span class=\"nc\">e8</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">          </span><span class=\"n\">call</span><span class=\"w\">   </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">+</span><span class=\"mh\">0xd</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">d</span>:   <span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">80</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">    </span><span class=\"n\">mov</span><span class=\"w\">    </span><span class=\"mh\">0x0</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"mi\">14</span>:   <span class=\"mi\">59</span><span class=\"w\">                      </span><span class=\"n\">pop</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">rcx</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"mi\">15</span>:   <span class=\"nc\">c3</span><span class=\"w\">                      </span><span class=\"n\">ret</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(The call, as far as I can tell, is just the address of the next instruction in <code>get_lib_tl</code>. But as mentioned, it's presumably just placeholder (meta)data)</p>",
        "id": 276187451,
        "sender_full_name": "Raekye",
        "timestamp": 1647955467
    },
    {
        "content": "<p>You can pass -r to see relocations.</p>",
        "id": 276187681,
        "sender_full_name": "bjorn3",
        "timestamp": 1647955569
    },
    {
        "content": "<p>I see, thanks! I can see the <code>__tls_get_addr</code> now (pasted for completeness)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mi\">0000000000000000</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">&gt;</span>:\n   <span class=\"mi\">0</span>:   <span class=\"mi\">50</span><span class=\"w\">                      </span><span class=\"n\">push</span><span class=\"w\">   </span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"mi\">1</span>:   <span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">    </span><span class=\"n\">lea</span><span class=\"w\">    </span><span class=\"mh\">0x0</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rip</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rdi</span><span class=\"w\">        </span>#<span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">+</span><span class=\"mh\">0x8</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"mi\">4</span>: <span class=\"nc\">R_X86_64_TLSLD</span><span class=\"w\">       </span><span class=\"n\">_ZN7tlstest6LIB_TL7__getit3VAL17he76855629effc2fcE</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"mh\">0x4</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"mi\">8</span>:   <span class=\"nc\">e8</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">          </span><span class=\"n\">call</span><span class=\"w\">   </span><span class=\"n\">d</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">+</span><span class=\"mh\">0xd</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"mi\">9</span>: <span class=\"nc\">R_X86_64_PLT32</span><span class=\"w\">       </span><span class=\"n\">__tls_get_addr</span><span class=\"o\">-</span><span class=\"mh\">0x4</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">d</span>:   <span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">80</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\">    </span><span class=\"n\">mov</span><span class=\"w\">    </span><span class=\"mh\">0x0</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">                        </span><span class=\"mi\">10</span>: <span class=\"nc\">R_X86_64_DTPOFF32</span><span class=\"w\">   </span><span class=\"n\">_ZN7tlstest6LIB_TL7__getit3VAL17he76855629effc2fcE</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"mi\">14</span>:   <span class=\"mi\">59</span><span class=\"w\">                      </span><span class=\"n\">pop</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">rcx</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"mi\">15</span>:   <span class=\"nc\">c3</span><span class=\"w\">                      </span><span class=\"n\">ret</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276188294,
        "sender_full_name": "Raekye",
        "timestamp": 1647955837
    },
    {
        "content": "<p>Just wanted to share my findings... To start here is the full code for <code>get_lib_tl</code> in the binary:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"mi\">0000000000007710</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">get_lib_tl</span><span class=\"o\">&gt;</span>:\n    <span class=\"mi\">7710</span>:       <span class=\"mi\">50</span><span class=\"w\">                      </span><span class=\"n\">push</span><span class=\"w\">   </span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">7711</span>:       <span class=\"mi\">66</span><span class=\"w\"> </span><span class=\"mi\">66</span><span class=\"w\"> </span><span class=\"mi\">66</span><span class=\"w\"> </span><span class=\"mi\">64</span><span class=\"w\"> </span><span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">04</span><span class=\"w\">    </span><span class=\"n\">data16</span><span class=\"w\"> </span><span class=\"n\">data16</span><span class=\"w\"> </span><span class=\"n\">data16</span><span class=\"w\"> </span><span class=\"n\">mov</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"n\">fs</span>:<span class=\"mh\">0x0</span><span class=\"p\">,</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">7718</span>:       <span class=\"mi\">25</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"> </span><span class=\"mi\">00</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">771</span><span class=\"n\">d</span>:       <span class=\"mi\">48</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"mi\">80</span><span class=\"w\"> </span><span class=\"n\">c0</span><span class=\"w\"> </span><span class=\"n\">ff</span><span class=\"w\"> </span><span class=\"n\">ff</span><span class=\"w\"> </span><span class=\"n\">ff</span><span class=\"w\">    </span><span class=\"n\">mov</span><span class=\"w\">    </span><span class=\"o\">-</span><span class=\"mh\">0x40</span><span class=\"p\">(</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"p\">),</span><span class=\"o\">%</span><span class=\"n\">rax</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">7724</span>:       <span class=\"mi\">59</span><span class=\"w\">                      </span><span class=\"n\">pop</span><span class=\"w\">    </span><span class=\"o\">%</span><span class=\"n\">rcx</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"mi\">7725</span>:       <span class=\"nc\">c3</span><span class=\"w\">                      </span><span class=\"n\">ret</span><span class=\"w\"></span>\n</code></pre></div>\n<p><a href=\"https://github.com/llvm/llvm-project/blob/main/lld/ELF/Arch/X86_64.cpp#L430\">Here</a> is the <code>lld</code> code for \"relax tls gd (global dynamic) to le (local exec)\". It doesn't look quite like our end code. I notice that the relocation in the latest dump for <code>get_lib_tl</code> in <code>libtlstest.rlib</code> is <code>R_X86_64_TLSLD</code> (notice the \"LD\" presumably for \"local dynamic\" instead of \"GD\"). <a href=\"https://github.com/llvm/llvm-project/blob/main/lld/ELF/Arch/X86_64.cpp#L555-L584\">Here</a> is the code for \"relax tls ld to le\". Indeed, we see it start with three <code>0x66</code>/<code>data16</code> nops (and the rest of the hardcoded bytes).</p>\n<p>(As mentioned in the comment in <code>relaxTlsLdToLe</code>) table 11.9 (under \"Alternate Code Sequences for Security\") in <a href=\"https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf\">this document</a> shows the general transformation from GD/LD to LE, which has <code>mov %fs:0,%rax</code>and requires 1 more <code>mov</code> with the static offset not shown. I'm still not sure why it cannot be transformed to a single <code>mov</code>, but in any case this seems like it's outside of the scope of the rust compiler. I'll ask the llvm/linker guys if I'm feeling adventurous later</p>",
        "id": 276193095,
        "sender_full_name": "Raekye",
        "timestamp": 1647957851
    },
    {
        "content": "<p>Could linker-plugin LTO make a difference here?</p>",
        "id": 276244780,
        "sender_full_name": "The 8472",
        "timestamp": 1647978461
    },
    {
        "content": "<p>Any kind of LTO can as it forces codegen to happen in the context of the main crate.</p>",
        "id": 276244862,
        "sender_full_name": "bjorn3",
        "timestamp": 1647978503
    },
    {
        "content": "<p>I tried building with different values for <code>lto</code> (<a href=\"https://doc.rust-lang.org/cargo/reference/profiles.html\">these cargo profile settings</a>). <code>false</code> (\"thin local lto\") and <code>\"thin\"</code> produce the 2 instruction sequence (<code>mov %fs:0,%rax</code>, <code>mov -0x40(%rax),%rax</code>). I  thought I tested <code>\"fat\"</code> before, but I must have forgot the results because it actually produces a single <code>mov %fs:&lt;OFFSET&gt;,%rax</code> \"as desired\". For completeness, <code>\"off\"</code> produces a call into <code>std</code> (makes sense since it's a separate crate). If you follow the code through <code>std::thread::LocalKey</code>, you eventually get to the same 2 instruction sequence (<code>mov %fs:0,%rax</code>, <code>mov -0x40(%rax),%rax</code>), which I guess makes sense</p>\n<p>So my current understanding is in general rustc uses global dynamic or local dynamic (not sure which one; bjorn3 says global dynamic, but the code I looked at seemed more like local dynamic. Does it have to do with the visibility?) for thread locals inside any library crate. But the <a href=\"https://github.com/llvm/llvm-project/blob/main/lld/ELF/Arch/X86_64.cpp#L48-L55\">linker can optimize it</a> if the library crates are statically linked to an executable. But for reasons I don't understand the linker relaxation always uses the longer (2 instruction) sequence for local exec (<a href=\"https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf\">section 11.1.2</a>, <a href=\"https://www.akkadia.org/drepper/tls.pdf\">section 4.4.6</a>). But you can make it produce a single instruction with \"fat\" lto</p>\n<p>Idk if others are interested in continuing this (largely pedantic) discussion, but I don't really understand how fat lto changes it, in the sense that:</p>\n<ol>\n<li>linker relaxation <em>always</em> transforms GD/LD to the 2 instruction sequence, as far as I can tell</li>\n<li>Unless fat lto actually changes compilation of the library to produce non GD/LD thread local access, the linker relaxation will produce 2 instructions as per previous point. But fat lto is... link time right? Shouldn't affect compilation? [*]</li>\n<li>You can observe that even completely disabling lto (<code>\"off\"</code>) still lets the linker relax the thread local access to local exec (it just won't inline functions from std into your crate). So it \"knows\" it can do local exec regardless of lto</li>\n<li>I'm not aware of any reason to use the 2 instruction sequence over the single instruction for local exec</li>\n</ol>\n<p>[*] I tried to <code>objdump</code> the library rlib compiled with fat lto, but it says</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">objdump</span>: <span class=\"nc\">tlstest</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"n\">a856feac2c81915</span><span class=\"p\">.</span><span class=\"n\">tlstest</span><span class=\"p\">.</span><span class=\"mi\">6</span><span class=\"n\">eb0fa7f</span><span class=\"o\">-</span><span class=\"n\">cgu</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">rcgu</span><span class=\"p\">.</span><span class=\"n\">o</span>: <span class=\"nc\">file</span><span class=\"w\"> </span><span class=\"n\">format</span><span class=\"w\"> </span><span class=\"n\">not</span><span class=\"w\"> </span><span class=\"n\">recognized</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 276249372,
        "sender_full_name": "Raekye",
        "timestamp": 1647980674
    },
    {
        "content": "<p>This is the default tls model: <a href=\"https://github.com/rust-lang/rust/blob/bce19cf7f19ee5729defaccc86b068cc3c206c9c/compiler/rustc_target/src/spec/mod.rs#L1463\">https://github.com/rust-lang/rust/blob/bce19cf7f19ee5729defaccc86b068cc3c206c9c/compiler/rustc_target/src/spec/mod.rs#L1463</a></p>",
        "id": 276251360,
        "sender_full_name": "bjorn3",
        "timestamp": 1647981790
    },
    {
        "content": "<p>All LTO kinds except linker plugin LTO happen as part of rustc.</p>",
        "id": 276251511,
        "sender_full_name": "bjorn3",
        "timestamp": 1647981861
    },
    {
        "content": "<blockquote>\n<p>I'm not aware of any reason to use the 2 instruction sequence</p>\n</blockquote>\n<p>If my understanding is correct, this is something you should bring up to the linker maintainers, not to rustc. LTO actually happens before the linker itself runs I'm pretty sure - it works by storing llvm bitcode in object files instead of ELF, so I think what's happening is fat LTO makes llvm do the optimization before the linker sees it.</p>",
        "id": 276316201,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648033200
    }
]