[
    {
        "content": "<p>I mentioned this in  <a class=\"stream\" data-stream-id=\"233931\" href=\"/#narrow/stream/233931-t-compiler.2Fmajor-changes\">#t-compiler/major changes</a> (<a href=\"#narrow/stream/233931-t-compiler.2Fmajor-changes/topic/Accept.20.60pc.60.20in.20place.20of.20.60unknown.60.20and.20.60un.E2.80.A6.20compiler-team.23441\">compilter-team #441</a>, but I find that cargo build scripts are lacking, in terms of usefulness in doing some of the similar things that other build scripts (autotools/cmake) typically do.</p>\n<blockquote>\n<p>(Although imo cargo build scripts are unsuited for some of the typical tasks a standard autotools or cmake build script will do, but that's a completely orthogonal discussion)</p>\n</blockquote>\n<p>There are a couple of reasons I think this, mostly either based on something being difficult, or just something not being exposed. <br>\nOne thing is that cargo build scripts aren't the easiest to perform feature detection from - even just figuring out what \"$RUSTC\" is and determining basic properties takes almost <a href=\"https://github.com/LightningCreations/cargo-autobuild/blob/main/src/tests.rs\">1000 lines of rust</a> (note: Some of this was finding the <code>rustc</code> program, which is not necessary in the case of cargo build scripts. This also does some stuff for figuring out the <code>$TARGET</code> which is likewise unecessary).</p>",
        "id": 254792779,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632530240
    },
    {
        "content": "<p>One of the main issues is that rust isn't the cleanest language to perform trial compilations with - this is necessary for feature detection, and the alternative is assuming features from the version string. Imo, this a poor idea, it doesn't consider new cases that support particular features. <br>\nThis is clear for C compilers, if you use a gcc option like <code>-std=c18</code>, and you ask for the gcc version string to determine whether  you can pass it, succesfully, this won't work if <code>$CC</code> is <code>clang</code> even if it  would accept and correctly handle it. It's better to attempt to compile a program with checks for known-correct behaviour passing the flag in and inspect the result. </p>\n<p>Rust crates already do this in practice (<a href=\"https://github.com/rust-lang/libc/blob/master/build.rs#L9\">https://github.com/rust-lang/libc/blob/master/build.rs#L9</a>, <a href=\"https://github.com/Lokathor/bytemuck/commit/f3e16c7051b561b027c797823b3ca16e7133028d\">https://github.com/Lokathor/bytemuck/commit/f3e16c7051b561b027c797823b3ca16e7133028d</a> (removed in following commit)), presumably partially related to the increased difficulty of performing actual feature tests (checking whether features are available, and enabling them in the code if not). When writing autotools or cmake build scripts, the latter is fairly easy (taking merely one cmake command or one autoconf macro, which is also <a href=\"https://github.com/chorman0773/rust-autotools/blob/027ada3cf0a73372345f0a6bd89983cf0b71acfa/m4/lcrust_prog_rustc.m4#L423..L435\">fairly easy to implement</a>).</p>",
        "id": 254792800,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632530258
    },
    {
        "content": "<p>cargo also does somewhat play a part in this - for example, it doesn't expose the set of flags to pass to <code>$RUSTC</code> invocations in <code>$RUSTFLAGS</code>. When working on the build script for lccc's libcore, I thought about setting a cfg based on the compilation abi version (and whether layout randomization is enabled). <br>\nFrom autotools, this was as easy as:</p>\n<div class=\"codehilite\"><pre><span></span><code>echo &#39;#![no_std]&#39; &gt; comptest.rs\n$RUSTC $RUSTFLAGS -Z extra-emit-flags --crate-name comptest --crate-type rlib --emit manifest=comptest.rmanifest comptest.rs &gt; /dev/null 2&gt;config.log\nif $? \\= 0\nthen\n    &lt;do some magic to parse the binary file and extract qword starting at the 8th byte&gt;\nfi\n</code></pre></div>\n<p>When trying to figure out how to do it in a cargo build script (for, among other things, <code>-Z build-std</code>), I couldn't come up with an easy answer as cargo doesn't give all of the <code>RUSTFLAGS</code> to the build script (albeit it gives enough unless someone is just directly running <code>cargo rustc</code> in the library source directory. parsing the variable from rust, though, is a nightmare).</p>",
        "id": 254792811,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632530270
    },
    {
        "content": "<p>(CC <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>)</p>",
        "id": 254793087,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632530436
    },
    {
        "content": "<p>(Configuration is also a fun topic, but that's a whole other rant)</p>",
        "id": 254793407,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632530746
    },
    {
        "content": "<p>So, FWIW, I think in the vast majority of cases \"trial compilation\" is not an especially useful construct anymore.</p>",
        "id": 254970256,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632697990
    },
    {
        "content": "<p>If your code is written in C11, use the C11 option, and error if it isn't supported. If your code <em>isn't</em> written in C11, it's not worth having \"optional\" support for it; just use whatever you'd have used as the fallback until you're ready to require C11.</p>",
        "id": 254970334,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632698047
    },
    {
        "content": "<p>There are some rare cases where that's not true; for instance, at one point it seemed useful to conditionally use <code>u128</code> support, when that hadn't been out long. But in general, I'd favor putting in appropriate feature dependencies for that.</p>",
        "id": 254970377,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632698096
    },
    {
        "content": "<p>Beyond that, we have <code>min-rust-version</code> in Cargo.</p>",
        "id": 254970390,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632698114
    },
    {
        "content": "<p>I'm not a <em>fan</em> of version detection, and I prefer providing sufficient mechanisms for feature detection, but I'd still prefer version detection over the \"trial compilation\" approach.</p>",
        "id": 254970411,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632698145
    },
    {
        "content": "<p>And even for something like <code>u128</code>, I think it was useful to just expose that as a Cargo feature, so that the project depending on yours could specify whether to enable it.</p>",
        "id": 254970514,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632698231
    },
    {
        "content": "<p>I've seen what projects look like when they have extensive use of <code>#ifdef COMPILER_SUPPORTS_FOO</code>, and on balance I don't think it's worthwhile. If you have support for not using foo, just use that. Otherwise, just require foo.</p>",
        "id": 254970618,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1632698340
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/122651-general/topic/Cargo.20build.20scripts.20vs.2E.20autotools/near/254970334\">said</a>:</p>\n<blockquote>\n<p>If your code is written in C11, use the C11 option, and error if it isn't supported. If your code <em>isn't</em> written in C11, it's not worth having \"optional\" support for it; just use whatever you'd have used as the fallback until you're ready to require C11.</p>\n</blockquote>\n<p>Well, the question for something like C is which option to use. Obviously this is less useful in rust, where the CLI is also stable when you're in cargo world.</p>\n<p>Also, for feature detection, it can be useful internally. If you need to decide how to implement a feature, that's where trial compliation comes in. Sure, you <em>can</em> use cfg's in rust, but that rules out new platforms that have apis that otherwise just work on one of the existing sets, but it doesn't think so because it doesn't know it can base on a set of hardcoded rules.</p>",
        "id": 254970641,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632698380
    },
    {
        "content": "<p>There can also be internals reasons for this. If there is a more optimal implementation, or maybe just a sound one that was previously impossible but necessary, I'd prefer to detect that I can use it, rather than check a version string.</p>",
        "id": 254970754,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632698510
    },
    {
        "content": "<blockquote>\n<p>Also, for feature detection, it can be useful internally. If you need to decide how to implement a feature, that's where trial compliation comes in. Sure, you can use cfg's in rust, but that rules out new platforms that have apis that otherwise just work on one of the existing sets, but it doesn't think so because it doesn't know it can base on a set of hardcoded rules.</p>\n</blockquote>\n<p>As an example, I do this in lccc's stdlib to figure out what thread (et. al) implementation to use. I don't hardcode unix=pthread, windows=winapi, linux=specialized. I have a list of implementations, and I check which one works. The first one in order that does, I use. That way, if some new platform comes along, and emulates one of those apis, but may not present the same cfg interface, it will just work: nothing new needs to be added.</p>",
        "id": 254970868,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632698630
    },
    {
        "content": "<p>Another use case for trial-compliation feature detection would be for <a href=\"https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369\">https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369</a> in MSRV'd crates. <br>\nIf I need a pointer-sized integer (or the index size integer type depending on what direction that ends up going), but can't use <code>uptr</code>, I'd prefer asking the C compiler the size of <code>uintptr_t</code> to hardcoding cfgs for specific platforms.</p>",
        "id": 255126863,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632779888
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/Cargo.20build.20scripts.20vs.2E.20autotools/near/254970641\">said</a>:</p>\n<blockquote>\n<p>Also, for feature detection, it can be useful internally. If you need to decide how to implement a feature, that's where trial compliation comes in. Sure, you <em>can</em> use cfg's in rust, but that rules out new platforms that have apis that otherwise just work on one of the existing sets, but it doesn't think so because it doesn't know it can base on a set of hardcoded rules.</p>\n</blockquote>\n<p>I think that was more useful when there were a hundred different variants of UNIX that worked mostly similarly, and there was enough commonality that \"this header exists and this function seems to be callable with this signature\" was a useful guess.</p>",
        "id": 255628112,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633028045
    },
    {
        "content": "<p>These days, we have fewer systems, and less new ones cropping up, and it's more a matter of porting to the handful of systems out there, which are often different enough that they <em>do</em> need different code paths.</p>",
        "id": 255628236,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633028102
    },
    {
        "content": "<p>Also, compile-based detection tends more towards the \"try compiling it and if it compiles it might work, your mileage may vary, don't count on it working\" style of support.</p>",
        "id": 255628367,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633028160
    },
    {
        "content": "<p>If people are going to count on something working, then supporting a new platform needs to be a more <em>deliberate</em> decision.</p>",
        "id": 255628521,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633028207
    },
    {
        "content": "<p>Even if it's just \"yeah, this is a UNIX variant, let's send it down the UNIX code paths\".</p>",
        "id": 255628561,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633028225
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/Cargo.20build.20scripts.20vs.2E.20autotools/near/255126863\">said</a>:</p>\n<blockquote>\n<p>If I need a pointer-sized integer (or the index size integer type depending on what direction that ends up going), but can't use <code>uptr</code>, I'd prefer asking the C compiler the size of <code>uintptr_t</code> to hardcoding cfgs for specific platforms.</p>\n</blockquote>\n<p>For that specific case, I'd prefer asking the Rust compiler how big <code>*mut ()</code> is.</p>",
        "id": 255628801,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633028297
    },
    {
        "content": "<p>For that, yeah. Though I'd need to ask the C compiler for <code>size_t</code> anyways, so I don't have to deal with whatever that thread decides is the best path, and are fine either way.</p>",
        "id": 255630619,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633028994
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/122651-general/topic/Cargo.20build.20scripts.20vs.2E.20autotools/near/255628521\">said</a>:</p>\n<blockquote>\n<p>If people are going to count on something working, then supporting a new platform needs to be a more <em>deliberate</em> decision.</p>\n</blockquote>\n<p>Not necessarily. Platforms may have shared apis because one may attempt compatibility with another platform, but they may deliberately not report the same names. In that case, imo, supporting the target should be as simple as setting <code>--host new-fancy-target</code> or <code>--target new-fancy-target</code> if everything necessary matches, rather than forcing someone to dig through mountains of config or source files just to add a target that's a no-op. Obviously, \"it works properly\" and \"it is officially supported\" are two different things (but should be fairly close), but the former should be sufficient to build and run properly, imo.</p>",
        "id": 255632723,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633029849
    },
    {
        "content": "<p>(And of course, you can always write more comprehensive checks. For example, both gcc and clang's respective build scripts do a lot of behaviour checks on various functions)</p>",
        "id": 255633040,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633029977
    },
    {
        "content": "<p>As a user, I'd very much not want autotools-style \"let's compile these 5000 programs and see if they work\" checks.</p>",
        "id": 255694857,
        "sender_full_name": "Laurențiu",
        "timestamp": 1633068449
    },
    {
        "content": "<p>Yeah that's just a good way to explode the compile time.</p>\n<p>Particularly if separate crates don't share the info and each compile their own set of 5000 programs.</p>",
        "id": 255703719,
        "sender_full_name": "Lokathor",
        "timestamp": 1633074290
    },
    {
        "content": "<p>And in good Autotools tradition, they don't test for what they need, they take some kitchen-sink list of tests and use it.</p>",
        "id": 255704082,
        "sender_full_name": "Laurențiu",
        "timestamp": 1633074519
    },
    {
        "content": "<p>That is certainly a fair argument, however, at the program level (especally for this particular program) I find having broad support is incredibly useful, and I shouldn't be required to know every single possible system a user might compile as a target or host system, especialy if 99% of them will just work out of the box, but wouldn't if an inferior set is hardcoded.</p>",
        "id": 255725597,
        "sender_full_name": "Connor Horman",
        "timestamp": 1633086028
    },
    {
        "content": "<p>The disadvantage of not hard coding a list of targets is that maintainers will not know on which targets work and will thus probably break it in minor or even patch releases as they start using new functions available on all systems they are actively testing.</p>",
        "id": 255726031,
        "sender_full_name": "bjorn3",
        "timestamp": 1633086250
    }
]