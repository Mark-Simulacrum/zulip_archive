[
    {
        "content": "<p>Hi! I'm hitting an issue when trying to write a trait impl for a type which implements <code>FnOnce</code> because the arguments are unconstrained.</p>\n<p>Specifically, I have a trait:</p>\n<div class=\"codehilite\"><pre><span></span><code>trait Resolve {\n  fn resolve(self) -&gt; bool;\n}\n</code></pre></div>\n<p>I would like to write the following impl:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl &lt;A, F : FnOnce&lt;A&gt;&gt; Resolve for F {\n...\n}\n</code></pre></div>\n<p>But I get :</p>\n<div class=\"codehilite\"><pre><span></span><code>error[E0207]: the type parameter `Args` is not constrained by the impl trait, self type, or predicates\n  --&gt; creusot-contracts/src/std/fun.rs:75:6\n   |\n75 | impl&lt;Args, F : FnOnce&lt;Args&gt;&gt; crate::Resolve for F {\n   |      ^^^^ unconstrained type parameter\n</code></pre></div>\n<p>Which makes <em>sense</em>, in that I understand I'm what rule I'm breaking and how but I can't think of a way to work around it</p>",
        "id": 273980238,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646317736
    },
    {
        "content": "<p>This is rather frustrating as, in general it also seems to mean writing instances for <code>Fn</code> types is impossible?</p>",
        "id": 273980460,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646317829
    },
    {
        "content": "<p>i really wish i could just write instances for closure types directly....</p>",
        "id": 273980761,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646317939
    },
    {
        "content": "<p>This might work?</p>\n<div class=\"codehilite\"><pre><span></span><code>trait Resolve&lt;A = Self&gt; {\n  fn resolve(self) -&gt; bool;\n}\nimpl &lt;A, F : FnOnce(A) -&gt; ()&gt; Resolve&lt;A&gt; for F {\n    fn resolve(self) -&gt; bool { true }\n}\n</code></pre></div>",
        "id": 273983982,
        "sender_full_name": "detrumi",
        "timestamp": 1646319331
    },
    {
        "content": "<p>(maybe with <code>resolve(a: A)</code> instead so it makes more sense)</p>",
        "id": 273984510,
        "sender_full_name": "detrumi",
        "timestamp": 1646319533
    },
    {
        "content": "<p>i'd rather not change the trait artificially, especially since its defined for many other types than functions</p>",
        "id": 273987438,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646320787
    },
    {
        "content": "<p>(in fact it should be defined for every rust type)</p>",
        "id": 273987471,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646320799
    },
    {
        "content": "<p>but I suppose if its unavoidable...</p>",
        "id": 273987517,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646320804
    },
    {
        "content": "<p>So, the issue is that closures can technically be overloaded: you could have <code>F : FnOnce() + FnOnce(i32)</code>, for instance.</p>\n<p>While that example is contrived and can currently only be featured on nightly, using manual impls, on stable Rust we have overloaded <code>FnOnce</code> impls the moment we have a higher-order signature:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"c1\">// i.e.</span>\n<span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">any</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nb\">FnOnce</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">any</span><span class=\"w\"> </span><span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">,</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is actually an infinite range of concrete <code>FnOnce(&amp;'any str)</code> impls that <code>F</code> meets.</p>\n<hr>\n<p>If what you need is for the trait to be implemented at least once, I think you'd need to use a <code>#[marker]</code> trait, using the unstable <code>market_trait_attr</code> feature:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[marker]</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">IsSomeFnOnce</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"o\">&lt;</span><span class=\"n\">Args</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">IsSomeFnOnce</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span>: <span class=\"nc\">IsSomeFnOnce</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Resolve</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n</code></pre></div>\n<p>But:</p>\n<ul>\n<li><code>#[marker]</code> traits, for some reason, can't handle unconstrained params yet (<em>that is silly</em>);</li>\n<li>you'd, in practice, encounter a lot of blanket impl issues with that <code>F : IsSomeFnOnce</code>, since you can't tell the coherence checker the \"reverse\" condition for <code>IsSomeFnOnce</code>.</li>\n</ul>",
        "id": 274005571,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646327726
    },
    {
        "content": "<p>If <code>Resolve</code> is defined for many non-function types, then how would it even be possible to add such a blanket impl? After all, other impls can't use negative reasoning to assert the type is not <code>FnOnce</code></p>",
        "id": 274011863,
        "sender_full_name": "LegionMammal978",
        "timestamp": 1646330118
    },
    {
        "content": "<p>It can since the <code>Fn</code> traits are <code>#[fundamental]</code>.</p>",
        "id": 274020545,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646333713
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/Writing.20an.20instance.20for.20a.20.60Fn.60.20trait/near/274005571\">said</a>:</p>\n<blockquote>\n<p>So, the issue is that closures can technically be overloaded: you could have <code>F : FnOnce() + FnOnce(i32)</code>, for instance.</p>\n<p>While that example is contrived and can currently only be featured on nightly, using manual impls, on stable Rust we have overloaded <code>FnOnce</code> impls the moment we have a higher-order signature:</p>\n</blockquote>\n<p>Yea, I get that, its the downside of universally quantifying the input parameters. It just particularily sucks because there's no other way to even <em>approximately</em> name a closure type.</p>\n<blockquote>\n<p>If what you need is for the trait to be implemented at least once, I think you'd need to use a <code>#[marker]</code> trait, using the unstable <code>market_trait_attr</code> feature:<br>\n</p>\n</blockquote>\n<p>Yea, that would be good enough, I just need to be able to give an instance which covers each closure. The 'correct' solution would be one instance per closure type, but that's impossible even with the rustc apis... If i could at least give a blanket impl, then my backend is capable of recognizing it and emitting the correct code secretly..</p>",
        "id": 274024932,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646335419
    },
    {
        "content": "<p>oh my god, I hate zulip's chat window...</p>",
        "id": 274025596,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646335678
    },
    {
        "content": "<p>I found a way to get the result I need using <code>min_specialization</code>, all I have to do is define a default instance for <code>T</code>, and then I can override it for types other than closures</p>",
        "id": 274146697,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1646408417
    }
]