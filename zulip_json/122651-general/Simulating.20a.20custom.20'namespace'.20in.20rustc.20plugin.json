[
    {
        "content": "<p>Does anyone have advice on how to simulate a custom 'namespace' for identifiers in a rustc plugin (on top of the existing value / macro / type namespaces)? </p>\n<p>I'd like to simulate the presence of a namespace 'foo' so that I could have a definition of <code>len</code> in <code>foo</code> and one in <code>ValueNS</code> which can't collide. </p>\n<p>My current approach is for a proc-macro to append a nonce to the end of <code>len</code> so i get an identifier like <code>len_______foo</code>, and rewrite relevant calls, but this generates poor error messages...</p>",
        "id": 266668164,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1641203467
    },
    {
        "content": "<p>I'd like see if there's some way I can generate nice error messages, but intuitively this would require somehow extending resolution...</p>",
        "id": 266668208,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1641203511
    },
    {
        "content": "<p>there's <code>#[tool::attribute]</code>s you can use</p>",
        "id": 266879518,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1641339487
    },
    {
        "content": "<p>those require using <code>#![feature(register_plugin)]</code> though</p>",
        "id": 266879528,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1641339495
    },
    {
        "content": "<p>sorry for the delayed respone. </p>\n<p>I'm already using tool attributes (and attribute macros), but here hte issue is I'm trying to enable having two definitions with the same name co-existing:</p>\n<div class=\"codehilite\"><pre><span></span><code>#[custom_namespace]\nfn len(..) -&gt; .. { }\n\nfn len(..) -&gt; .. { }\n</code></pre></div>\n<p>and preserve the diagnostics so that Resolution talks about <code>len</code> and not <code>len_mangled</code></p>",
        "id": 268005752,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642162507
    },
    {
        "content": "<p>The immediate issue is that <code>rustc</code> emits errors directly to stdout so I have no opportunity to intercept and modify them to my convenience</p>",
        "id": 268005806,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642162560
    },
    {
        "content": "<p>You could use <code>rustc_driver::RunCompiler.set_emitter()</code> when invoking the rustc driver to intercept the location to write diagnostics too and then replace say <code>____custom_namespace__</code> with an empty string.</p>",
        "id": 268009696,
        "sender_full_name": "bjorn3",
        "timestamp": 1642165094
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> isn't that something that <code>def_site()</code> hygiene already achieves?</p>\n<ul>\n<li><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=629f818fb073f073cfca235ec22777fb\">Playground</a></li>\n</ul>",
        "id": 268020849,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642170719
    },
    {
        "content": "<p>first of all: wow amazing playground link. This seems awfully close to what I need but i need definitions to conflict <em>within</em> the custom namespace, ie: </p>\n<div class=\"codehilite\"><pre><span></span><code>#[custom_namespace]\nfn foo ()\n{}\n\n#[custom_namespace]\nfn foo ()\n{}\n</code></pre></div>\n<p>should be an error since they are both <code>custom_namespace</code>.</p>",
        "id": 268021592,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642171086
    },
    {
        "content": "<p>Also TIL we can have blocks on the RHS of an enum (i assume any const exp?)</p>",
        "id": 268021637,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642171113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122651-general/topic/Simulating.20a.20custom.20'namespace'.20in.20rustc.20plugin/near/268009696\">said</a>:</p>\n<blockquote>\n<p>You could use <code>rustc_driver::RunCompiler.set_emitter()</code> when invoking the rustc driver to intercept the location to write diagnostics too and then replace say <code>____custom_namespace__</code> with an empty string.</p>\n</blockquote>\n<p>that seems like it would do the trick!</p>",
        "id": 268021708,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642171153
    },
    {
        "content": "<p>I was wondering about the double <code>custom_namespace</code> invocation, hence why I explicitly spelled out that case. (hidden) name mangling then seems more adequate indeed</p>",
        "id": 268021818,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642171215
    },
    {
        "content": "<p>yea I'm truly trying to add a 4th namespace to rustc (on top of the existing value, macro and type ones)</p>",
        "id": 268021870,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642171251
    },
    {
        "content": "<p>the secret use case is that it maps to 'logical functions' for my verification tool</p>",
        "id": 268021896,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642171268
    },
    {
        "content": "<p>which cannot be called from program code nor can they call program code</p>",
        "id": 268021911,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642171279
    },
    {
        "content": "<p>I'm trying to make rustc error when users accidentally write a call which crosses the boundary (it currently errors much later and less clear)</p>",
        "id": 268022058,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642171367
    },
    {
        "content": "<p>Well, if calling the <code>macro</code> macro only once, so that it produces one special defsite-imbued span, then a helper macro can be defined which \"captures\" that. Here is a demo, this time simplified to <code>m! {}</code> expanding to <code>enum Foo {}</code>, and seeing whether it conflicts with itself and/or with an explicit <code>enum Foo {}</code>.<br>\nAnswer: it does the desired thing: it won't conflict with an explicit <code>enum Foo {}</code>, but conflicts with itself.</p>\n<p>This could further be developed to define, atop <code>m!</code>, another macro, say <code>n!</code>, which also captured that same identifier, and which would thus be able to \"back-resolve\" a given name into your \"namespace\", by tainting it back with the hygiene of the captured token.</p>\n<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=758a469a8f4f6285f0ea2840fa692728\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=758a469a8f4f6285f0ea2840fa692728</a></p>",
        "id": 268126226,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642253926
    },
    {
        "content": "<p>Here is a snippet with no <code>#[macro_export]</code>: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8027114ff856b770e5fa62b3dc2511c1\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=8027114ff856b770e5fa62b3dc2511c1</a>. While <code>private::m! {}</code> works, doing <code>use private::m; m! {}</code>, on the other hand, triggers an ICE <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 268126374,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642254239
    },
    {
        "content": "<p>Oh wow this is some dark magic</p>",
        "id": 268193494,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642349961
    },
    {
        "content": "<p>Unfortunately it doesn’t seem applicable to my use case at least I can’t see how I can twist it to work</p>",
        "id": 268193508,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642350001
    },
    {
        "content": "<p>But it’s truly impressive</p>",
        "id": 268193549,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642350006
    },
    {
        "content": "<p>I think you can let <code>macro_rules! $m</code> take an ident as argument and then make it expand to a proc macro call with this ident as argument and <code>Foo</code> as argument. The proc macro can change the span of the first argument to resolve at the span of <code>Foo</code>.</p>",
        "id": 268195116,
        "sender_full_name": "bjorn3",
        "timestamp": 1642352141
    },
    {
        "content": "<p>Yep, that would be the way to generalize <span aria-label=\"100\" class=\"emoji emoji-1f4af\" role=\"img\" title=\"100\">:100:</span></p>",
        "id": 268199354,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642357202
    },
    {
        "content": "<p>Yes but I need to expose that proc macro in a crate, and I can’t do that</p>",
        "id": 268240592,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642408458
    },
    {
        "content": "<p>I’m using a lot of attribute macros</p>",
        "id": 268240661,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642408524
    },
    {
        "content": "<p>There’s no way to wrap an attribute macro with a decl macro, is there?</p>",
        "id": 268240862,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642408616
    },
    {
        "content": "<p>Just for clarity: the input looks like this currently:</p>\n<p><a href=\"https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/vector/02_gnome.rs#L8-L18\">https://github.com/xldenis/creusot/blob/master/creusot/tests/should_succeed/vector/02_gnome.rs#L8-L18</a></p>",
        "id": 268245182,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642410941
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>#[predicate]\nfn sorted_range&lt;T: Ord&gt;(s: Seq&lt;T&gt;, l: Int, u: Int) -&gt; bool {\n    pearlite! {\n        forall&lt;i : Int, j : Int&gt; l &lt;= i &amp;&amp; i &lt; j &amp;&amp; j &lt; u ==&gt; s[i] &lt;= s[j]\n    }\n}\n\n#[predicate]\nfn sorted&lt;T: Ord&gt;(s: Seq&lt;T&gt;) -&gt; bool {\n    sorted_range(s, 0, s.len())\n}\n</code></pre></div>\n<p>And I'm trying to make <code>#[predicate]</code> act like a standalone namespace</p>",
        "id": 268245254,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642410968
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/vqvGZ_R5H_CdBDpbbT4dEaKI/Screen-Shot-2022-01-18-at-13.54.31.png\">Screen-Shot-2022-01-18-at-13.54.31.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/vqvGZ_R5H_CdBDpbbT4dEaKI/Screen-Shot-2022-01-18-at-13.54.31.png\" title=\"Screen-Shot-2022-01-18-at-13.54.31.png\"><img src=\"/user_uploads/4715/vqvGZ_R5H_CdBDpbbT4dEaKI/Screen-Shot-2022-01-18-at-13.54.31.png\"></a></div><ul>\n<li>\n<p><a href=\"https://asciinema.org/a/oqW8Fmi8LQ4yWSDjlUTjyNJIJ\">Demo</a></p>\n</li>\n<li>\n<p>No compiler/rustc was tweaked/harmed during this recording, only proc-macro with <code>Span::def_site()</code> shenanigans <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>\n</li>\n</ul>",
        "id": 268386475,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642510593
    },
    {
        "content": "<p>So, in your case, the <code>#[custom_namespace]</code> attribute of that crate, alone, ought to already suit you; and I've even demo'd being able to let users define even more namespaces.<br>\nRegarding how it works,</p>\n<ol>\n<li><code>#[custom_namespace(something_interestingly_spanned)]</code> overrides the <code>resolve_at</code> span of the annotated item with that of the attribute arg;</li>\n<li><code>with_unique_ident!</code> is a helper (proc-macro) which invokes the given (pseudo) \"macro rule\" with a \"fresh\" <code>def-site()</code> identifier: this allows repeating it within that scope (<em>e.g.</em>, <code>let $foo = 42; let x = $foo;</code> works), but a <code>$foo</code> from one invocation is seen as distinct from that from another invocation.</li>\n<li>With both such tools, one can define their own \"custom namespacer macro\" by writing what I've written for <code>my_new_namespace</code> (basically use a <code>with_unique_ident!</code> scope (and thus, ident) to define a macro that calls <code>#[custom_namespace(that_ident)]</code> on its arg).</li>\n<li>Finally, my crate does step <code>3.</code> on its own for some hidden macro, and then <code>#[custom_namespace]</code> (no args) defaults to calling that hidden macro</li>\n</ol>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// in my crate</span>\n<span class=\"n\">with_unique_ident</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$my_ns</span>:<span class=\"nc\">unique_ident</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[doc(hidden)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[macro_export]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">macro_rules!</span><span class=\"w\"> </span><span class=\"n\">__custom_namespaced__</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$item</span>:<span class=\"nc\">item</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">#[$crate::custom_namespace($my_ns)]</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cp\">$item</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)}</span><span class=\"w\"></span>\n<span class=\"p\">)}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// within the logic of `#[custom_namespace]`:</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">namespace</span>: <span class=\"nc\">Span</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">it</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">namespace</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"nb\">Ok</span><span class=\"p\">(</span><span class=\"n\">quote</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span>::<span class=\"n\">demo</span>::<span class=\"n\">__custom_namespaced__</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span>#<span class=\"n\">input</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and <em>voilà</em></p>",
        "id": 268387713,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642511213
    },
    {
        "content": "<p>FWIW, <code>with_unique_ident</code> alone is quite powerful, and the most explicit one, if a bit verbose. It has a nifty feature, which is that the name of the <code>:unique_ident</code> metavariable is also the actual symbol picked for the specially-spanned parameter:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">with_unique_ident</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$Foo</span>:<span class=\"nc\">unique_ident</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">enum</span> <span class=\"cp\">$Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// typename::&lt;$Foo&gt;() == \"path::to::Foo\"</span>\n<span class=\"p\">)}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so this makes:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">with_unique_ident</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$ns</span>:<span class=\"nc\">unique_ident</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[custom_namespace($ns)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">)}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>literally equivalent to:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">with_unique_ident</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{(</span><span class=\"w\"> </span><span class=\"cp\">$bar</span>:<span class=\"nc\">unique_ident</span><span class=\"w\"> </span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"cp\">$bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"p\">)}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>if that makes sense?</p>",
        "id": 268388389,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642511567
    },
    {
        "content": "<p>Oh my god</p>",
        "id": 268402143,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642517646
    },
    {
        "content": "<p>You’re incredible</p>",
        "id": 268402162,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642517653
    },
    {
        "content": "<p>I’ll take 3 of you please, and thank you</p>",
        "id": 268402194,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642517668
    },
    {
        "content": "<p>And I assume that once I modify the resolve_at span, that interacts with hygiene so you can see other methods defined in the same span?</p>",
        "id": 268402520,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642517795
    },
    {
        "content": "<p>Hyyyyype</p>",
        "id": 268402549,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642517806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"312719\">Xavier Denis</span> <a href=\"#narrow/stream/122651-general/topic/Simulating.20a.20custom.20'namespace'.20in.20rustc.20plugin/near/268402520\">said</a>:</p>\n<blockquote>\n<p>And I assume that once I modify the resolve_at span, that interacts with hygiene so you can see other methods defined in the same span?</p>\n</blockquote>\n<p>Yes, that's the part missing in my PoC: a macro to reverse the process <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 268403018,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642517981
    },
    {
        "content": "<p>What do you mean, reverse?</p>",
        "id": 268403415,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642518090
    },
    {
        "content": "<p>To allow items defined in the custom namespace to be accessible outside?</p>",
        "id": 268403450,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642518105
    },
    {
        "content": "<p>Or accessible between each other</p>",
        "id": 268403464,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642518114
    },
    {
        "content": "<p>I figured that if <code>à</code> and <code>b</code> have the same spans then they would be able to see each other (which is how the conflict would potentially occur)</p>",
        "id": 268403669,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642518174
    },
    {
        "content": "<p>I mean something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[custom_namespace]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[custom_namespace]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- how do we make this work?</span>\n<span class=\"w\">    </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>We'd need a way to say that <code>foo()</code> call, there, has to resolve using the <code>custom_namespace</code>. So it's not \"reverse\" in that it's still about imbuing a given identifier with a custom namespace's span, but it's reverse in that it's used for a <em>use</em> / <em>call</em> rather than a <em>definition</em>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[custom_namespace]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">baz</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">custom_namespace</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)();</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- works for simple cases (such as yours, I believe)</span>\n<span class=\"w\">    </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[custom_namespace]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">i32</span> <span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">custom_namespace</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kt\">i32</span> <span class=\"p\">}</span><span class=\"w\"> </span><span class=\"c1\">// wouldn't work because of Rust grammar</span>\n</code></pre></div>",
        "id": 268435365,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642530506
    },
    {
        "content": "<p>ah i thought that the whole body of <code>baz</code> would inherit the namespace</p>",
        "id": 268437673,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531642
    },
    {
        "content": "<p>because yea, that is reptty essential, to have <code>foo()</code> work but not<code>bar()</code></p>",
        "id": 268437731,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531672
    },
    {
        "content": "<p>It could, but then <code>bar()</code> wouldn't resolve, I suspect</p>",
        "id": 268437732,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642531672
    },
    {
        "content": "<p>that's good</p>",
        "id": 268437749,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531681
    },
    {
        "content": "<p>these namespaces can't interact</p>",
        "id": 268437806,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531693
    },
    {
        "content": "<p>Oh, then yeah, it's quite easy to make my <code>#[custom_namespace]</code> macro override <em>everything</em>. This would allow not even depending on <code>syn</code>, then, since it wouldn't need to locate the function name</p>",
        "id": 268437887,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642531735
    },
    {
        "content": "<p>Will soon publish this PoC so that you can directly toy with it <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 268437917,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642531753
    },
    {
        "content": "<p>i already have syn for other reasons</p>",
        "id": 268437949,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531764
    },
    {
        "content": "<p>so that's no issue</p>",
        "id": 268437965,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531771
    },
    {
        "content": "<p>I'm already doing plenty of proc macro hackery, extending the syntax of 'rust' expressions etc...</p>",
        "id": 268438019,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531793
    },
    {
        "content": "<p>trying to fit a whole other language into rust is no easy feat</p>",
        "id": 268438131,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531833
    },
    {
        "content": "<p>But a satisfying one (I imagine)</p>",
        "id": 268438163,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642531852
    },
    {
        "content": "<p>oh yes, nothing is more satisfying than finding some awful hack which <em>works</em></p>",
        "id": 268438207,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531870
    },
    {
        "content": "<p>it all works cross-crate too which is exciting for me</p>",
        "id": 268438264,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531899
    },
    {
        "content": "<p>it means you can export formally verified crates and use them in projects! seamlessly!</p>",
        "id": 268438309,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642531918
    },
    {
        "content": "<p>did you actually implement <code>with_unique_ident</code>? seems like a pretty powerful / rich macro</p>",
        "id": 268448219,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642536414
    },
    {
        "content": "<p>I was going to implement a simpler macro which just returned a random def_site identifier</p>",
        "id": 268448316,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642536464
    },
    {
        "content": "<p>just realizing something, the <code>def_site</code> approach can't support modules, can it?</p>",
        "id": 268467256,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642546115
    },
    {
        "content": "<p>ie: </p>\n<div class=\"codehilite\"><pre><span></span><code>#[custom_namespace]\nfn f() { ... }\nmod a {\n  #[custom_namespace]\n  fn f() { ... }\n}\n</code></pre></div>",
        "id": 268467299,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642546157
    },
    {
        "content": "<p>I'm pretty sure that should work just fine. You got the custom span, but also a different defpath (<code>crate::a::f</code> vs <code>crate::f</code>).</p>",
        "id": 268471309,
        "sender_full_name": "bjorn3",
        "timestamp": 1642548386
    },
    {
        "content": "<p>Sorry to bother you again after all your help, but I can't seem to get calls within the custom_namespace to work</p>",
        "id": 268531791,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642595653
    },
    {
        "content": "<p>I've tried replacing the resolution span of all the tokens in the item</p>",
        "id": 268531820,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642595674
    },
    {
        "content": "<p>but that doesn't seem to do the trick either</p>",
        "id": 268531833,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642595681
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122651-general/topic/Simulating.20a.20custom.20'namespace'.20in.20rustc.20plugin/near/268471309\">said</a>:</p>\n<blockquote>\n<p>I'm pretty sure that should work just fine. You got the custom span, but also a different defpath (<code>crate::a::f</code> vs <code>crate::f</code>).</p>\n</blockquote>\n<p>yea I guess i still don't fully understand rust macro hygiene but this works</p>",
        "id": 268531907,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642595723
    },
    {
        "content": "<p>I figured that setting the resolve span would have been the same as if we placed all the item tokens within a shared <code>mod</code></p>",
        "id": 268531959,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642595752
    },
    {
        "content": "<p>Ah, seems like maybe <code>def_site</code> is not appropriate? I don't understand how the resolution process for <em>defintions</em> differs from the process for <em>uses</em></p>",
        "id": 268532468,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642596035
    },
    {
        "content": "<p>Sorry, have been a bit busy, will resume these experiments and publish them this w-e, probably. Each <code>Span::def_site()</code> is <em>unique</em> per <em>invocation</em> of the proc-macro wherein the <code>Span::def_site()</code> call occurs. This is how I created the <code>with_unique_ident!</code> macro.<br>\nThen the key idea is that once you get hold of one such span, you no longer call <code>Span::def_site()</code> (or <code>with_unique_ident!</code>) anymore, just that one time, at which point you \"gift\" that span to other macros to use (this is how <code>#[custom_namespace]</code> is defined).</p>\n<p>So, in my PoC, all the <code>#[custom_namespace]</code> invocations use the one <code>Span::def_site()</code> that got instanced, and so, when performing look-ups, ought to be able to see each other. That being said, I haven't tested that part too much yet, and there may be some quirks in that regard (I've, for instance, noticed that a <code>macro_rules!</code> sometimes can't perform a fully hygienic lookup (even when given a defsite-imbued identifier, I mean), so maybe you've hit that situation).</p>\n<p>More <span aria-label=\"detective\" class=\"emoji emoji-1f575\" role=\"img\" title=\"detective\">:detective:</span> this weekend</p>",
        "id": 268628278,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1642641579
    },
    {
        "content": "<p>I think that’s the issue I’m encountering because I wrote a macro which returns a macro-rules macro containing a def_site span</p>",
        "id": 268657815,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642667451
    },
    {
        "content": "<p>Basically I wrote a macro which hard codes your invocation of with_unique_ident</p>",
        "id": 268657873,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642667480
    },
    {
        "content": "<p>I’m fairly certain it’s all working as I can trigger conflicts within the custom namespace which are separate from the normal namespace</p>",
        "id": 268658263,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642667719
    },
    {
        "content": "<p>But I’m still unable to resolve calls</p>",
        "id": 268658323,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642667750
    },
    {
        "content": "<p>I have a sneaking suspicion that the generated <code>macro_rules!</code> ends up creating a new <code>Span</code> at each invocation, even though it should just be copying a single token...</p>\n<p>Printing the token at each invocation of <code>custom_namespace</code> gives: </p>\n<div class=\"codehilite\"><pre><span></span><code>TokenStream [Ident { ident: &quot;__creusot__&quot;, span: #14 bytes(10935360..10935394) }]\nTokenStream [Ident { ident: &quot;__creusot__&quot;, span: #23 bytes(10935360..10935394) }]\n</code></pre></div>\n<p>at the sametime the actual <em>definitions</em> can conflict so the spans must be overlapping at least for definition resolution...</p>",
        "id": 268708954,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642692450
    },
    {
        "content": "<p>I'm sort of taking notes out-loud, anyone passing by should feel free to correct me.</p>\n<p>I think i'm starting to get a better grasp of how proc macro and decl macro hygiene interacts, and also why that the current approach can't  resolve calls to other <code>custom_namespace</code> functions. </p>\n<p>Each time a decl macro is invoked, it creates a new syntax context for all tokens, including any that were 'interestingly spanned'. Its within this context we end up declaring functions. However, that means that successive calls to the macro containing the 'def_site' token will continuously give it new contexts, with no relation between them. </p>\n<p>What doesn't fit with my understanding of these contexts / spans is how function resolution can conflict? Shouldn't never conflict if they're within different contexts?</p>\n<p>The crux of the issue will be finding a way to recover a span that has the same syntax context across invocations, yet is different from the root context <code>#0</code></p>",
        "id": 268828839,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1642764394
    }
]