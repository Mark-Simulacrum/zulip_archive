[
    {
        "content": "<p>I'm implementing an error handling system for a recursive descent parser. I have a struct that has generic arguments for whether it is handled in different ways, but when it's \"thrown\" using the ? operator I want it to revert to the unhandled state. This means I only want ? to exist for one type, and FromResidual to only exist for another. Is this possible? <a href=\"/user_uploads/4715/VaruVYuOck5oJcuK0NhlvroH/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/VaruVYuOck5oJcuK0NhlvroH/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/VaruVYuOck5oJcuK0NhlvroH/image.png\"></a></div>",
        "id": 272465991,
        "sender_full_name": "Sawyer Bergeron",
        "timestamp": 1645222823
    },
    {
        "content": "<p>That's the second unresolved question from the RFC <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span>  <a href=\"https://github.com/rust-lang/rust/issues/84277\">https://github.com/rust-lang/rust/issues/84277</a></p>",
        "id": 272484756,
        "sender_full_name": "scottmcm",
        "timestamp": 1645236846
    },
    {
        "content": "<p>But yes, for now a <code>Try</code>-implementing type can <em>always</em> be rebuilt after being split up.</p>\n<p>(And, in fact, the stable <code>Iterator::try_fold</code> method depends on being able to do that.  Though of course a hypothetical different type could just not support <code>try_fold</code> if we changed the trait structure.)</p>",
        "id": 272484884,
        "sender_full_name": "scottmcm",
        "timestamp": 1645236980
    },
    {
        "content": "<p>Replied to the RFC a little earlier with use case, I don't quite follow what you mean by being able to be rebuilt after being split up though,</p>",
        "id": 272490254,
        "sender_full_name": "Sawyer Bergeron",
        "timestamp": 1645242603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"298448\">Sawyer Bergeron</span> <a href=\"#narrow/stream/122651-general/topic/try-trait-asymmetric-residual/near/272490254\">said</a>:</p>\n<blockquote>\n<p>rebuilt after being split up though,</p>\n</blockquote>\n<p>You can think of it like <code>try { x? }</code> being a NOP.</p>\n<p>If you can <code>branch</code> it into its parts, you can re-create the original value.</p>",
        "id": 272491030,
        "sender_full_name": "scottmcm",
        "timestamp": 1645243389
    },
    {
        "content": "<p>Can you elaborate on what you mean by \"handled\" here?</p>",
        "id": 272491043,
        "sender_full_name": "scottmcm",
        "timestamp": 1645243421
    },
    {
        "content": "<p>Note that the current design <em>does</em> make it possible to return something that's not <code>?</code>-able while still using <code>?</code> in that method.</p>",
        "id": 272491181,
        "sender_full_name": "scottmcm",
        "timestamp": 1645243569
    },
    {
        "content": "<p>So you could make <code>foo()?</code> not work but allow <code>foo().handle()?</code> if you wanted.</p>",
        "id": 272491187,
        "sender_full_name": "scottmcm",
        "timestamp": 1645243583
    },
    {
        "content": "<p>So I have the type from above, and two impl blocks near it. One defines <code>join()</code> which only exists for GuardResult&lt;_, Unjoined, _&gt;, and outputs a &lt;...Joined...&gt; type value. That one takes a reference to the current rule context (each function in the parser has one at the top) and aligns its token stream to the point that the GuardResult reached. The other impl block defines <code>catch()</code> which only exists for GuardResult&lt;_, _, Uncaught&gt; and returns one with a param of Caught. That checks if the object is able to be handled by the passed context (i.e. if there is an error inside, that context has the next token in the input stream in the set of tokens it's looking for next). I'd like to prevent the user from calling join or catch twice, but want to force dealing with each of those parts of the process before any function is allowed to ? the result. This prevents just blindly forwarding any error up the chain without putting a little bit of thought into ignoring/accepting stream alignment or how to 'catch' the error</p>",
        "id": 272491574,
        "sender_full_name": "Sawyer Bergeron",
        "timestamp": 1645244115
    },
    {
        "content": "<p>When I apply the ? operator, I want it to switch those type parameters back to being uncaught and unjoined, so the next function up has to ack them as well</p>",
        "id": 272491602,
        "sender_full_name": "Sawyer Bergeron",
        "timestamp": 1645244159
    }
]