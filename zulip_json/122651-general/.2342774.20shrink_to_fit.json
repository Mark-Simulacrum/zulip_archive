[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> are you online ?</p>",
        "id": 146855899,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541498643
    },
    {
        "content": "<p>yeah but i'm in a mtg right now; it should be over i think in 60min</p>",
        "id": 146856000,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541498808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> let me know</p>",
        "id": 146857044,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541500339
    },
    {
        "content": "<p>okay mtg is over</p>",
        "id": 146857787,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541501606
    },
    {
        "content": "<p>lets update the topic to point to the issue where we've been talking</p>",
        "id": 146857790,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541501618
    },
    {
        "content": "<p>(oh, wait, I don't know if such links work for repos outside rust-lang/rust ...)</p>",
        "id": 146857822,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541501644
    },
    {
        "content": "<p>((they don't))</p>",
        "id": 146857873,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541501719
    },
    {
        "content": "<p>(((apart from polonius and chalk, according to <span class=\"user-mention\" data-user-id=\"116107\">@davidtwco</span> )))</p>",
        "id": 146857878,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541501735
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> ^</p>",
        "id": 146858030,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541501917
    },
    {
        "content": "<p>I can at least point us at the Tracking issue for custom allocators; that is better than nothing. (Even though our dialogue thus far has instead been on <a href=\"https://github.com/alexcrichton/jemallocator/pull/64\" target=\"_blank\" title=\"https://github.com/alexcrichton/jemallocator/pull/64\">https://github.com/alexcrichton/jemallocator/pull/64</a></p>",
        "id": 146858066,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541501975
    },
    {
        "content": "<p>so I think I see your point, and I am unsure whether you are right for jemalloc or not</p>",
        "id": 146858139,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502014
    },
    {
        "content": "<p>but I see your point in general that a general allocator might want to error from shrink_to_fit, e.g., if it shrinks to a different size-class even if it doesn't move the allocation</p>",
        "id": 146858176,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502053
    },
    {
        "content": "<p>Exactly</p>",
        "id": 146858186,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502063
    },
    {
        "content": "<p>however, <code>xallocx</code> to the best of my knowledge never does that</p>",
        "id": 146858192,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502068
    },
    {
        "content": "<p>(i've asked for clarification in jemalloc's gitter)</p>",
        "id": 146858200,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502086
    },
    {
        "content": "<p>that is, <code>xallocx</code> never moves an allocation to a different size class when shrinking/growing in place</p>",
        "id": 146858206,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502109
    },
    {
        "content": "<p>in particular, when shrinking, the returned size is always &gt;= new_size</p>",
        "id": 146858254,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502131
    },
    {
        "content": "<p>right; it just returs the current size, right?</p>",
        "id": 146858257,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502139
    },
    {
        "content": "<p>which means it never errors (errors are reported by returned a size smaller than the requested one)</p>",
        "id": 146858259,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502148
    },
    {
        "content": "<p>my point is that that will subseuqently casue dealloc to fail</p>",
        "id": 146858260,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502150
    },
    {
        "content": "<p>(where \"fail\" in this case means \"leak\")</p>",
        "id": 146858263,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502161
    },
    {
        "content": "<p>no, it returns the usable_size, and that's the thing, dealloc must work for sizes in [requested, usable_size]</p>",
        "id": 146858270,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502173
    },
    {
        "content": "<p>otherwise usable_size would be useless</p>",
        "id": 146858271,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502182
    },
    {
        "content": "<p>that is, xallocx, when shrinking, always returns <code>&gt;= new_size</code>, and the size can be <code>&gt;= old_size</code> too, and all sizes in [new_size, usable_size] can be used with sdallocx</p>",
        "id": 146858286,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502219
    },
    {
        "content": "<p>all sizes in <code>[new_size, usable_size]</code> can be used with sdallocx ?</p>",
        "id": 146858327,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502247
    },
    {
        "content": "<p>this <code>[requested_sz, usable_size]</code> range for <code>Alloc::dealloc</code> is a guarantee of the <code>Alloc</code> trait too</p>",
        "id": 146858329,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502248
    },
    {
        "content": "<p>what if <code>new_size</code> is in a different (smaller) size class?</p>",
        "id": 146858340,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502268
    },
    {
        "content": "<p>that's the scenario that I thought was outlined in <a href=\"https://github.com/rust-lang/rfcs/pull/1398#issuecomment-164988117\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/1398#issuecomment-164988117\">https://github.com/rust-lang/rfcs/pull/1398#issuecomment-164988117</a></p>",
        "id": 146858348,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502291
    },
    {
        "content": "<p>that's a good question, it appears to work</p>",
        "id": 146858351,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502295
    },
    {
        "content": "<p>\"work\" as in \"does not assert-fail\" ?</p>",
        "id": 146858361,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502306
    },
    {
        "content": "<p>or \"work\" as in \"does not leak memory\" ?</p>",
        "id": 146858364,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502311
    },
    {
        "content": "<p>wait, I'll send a PR with a test, so that you can see the code (it doesn't change anything in <code>shrink_to_fit</code>, just adds a test for it</p>",
        "id": 146858373,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502341
    },
    {
        "content": "<p>i.e. the above linked issue comment said that such a scenario would have the deallocation require be silently ignored</p>",
        "id": 146858376,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502344
    },
    {
        "content": "<p>... okay. But I'm not 100% sure we can readily check for memory leak scenarios</p>",
        "id": 146858418,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502364
    },
    {
        "content": "<p>(we used to have valgrind tests that would catch leaks but I don't know if they are part of what bors requires for things to past)</p>",
        "id": 146858424,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502390
    },
    {
        "content": "<p>In any case I definitely think that the documentation for <code>Alloc</code> trait needs some exposition on this detail</p>",
        "id": 146858443,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541502443
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> i've set valgrind in jemallocators CI, but only for memory errors, no leak detection I think, shouldn't be hard to add</p>",
        "id": 146858584,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502620
    },
    {
        "content": "<p>i've asked in jemalloc upstream precisely for what happens in this case, whether we can dealloc with size <code>1</code> even if <code>xallocx</code> returns the original size</p>",
        "id": 146858622,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502680
    },
    {
        "content": "<p><a href=\"https://github.com/alexcrichton/jemallocator/pull/92\" target=\"_blank\" title=\"https://github.com/alexcrichton/jemallocator/pull/92\">https://github.com/alexcrichton/jemallocator/pull/92</a></p>",
        "id": 146858625,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541502689
    },
    {
        "content": "<p>maybe mark that PR as WIP for now?</p>",
        "id": 146860235,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> it fails, so indepentendly of what happens upstream, the answer will be that we have to change shrink_in_place implementation</p>",
        "id": 146860278,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505243
    },
    {
        "content": "<p>the correct way to do this is to say that an allocation shrinks only if its usable_size shrinks, and otherwise to error</p>",
        "id": 146860288,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505277
    },
    {
        "content": "<p>okay. So I take that to mean that I was right to start asking questions here. <span class=\"emoji emoji-263a\" title=\"smile\">:smile:</span></p>",
        "id": 146860290,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505289
    },
    {
        "content": "<blockquote>\n<p>the correct way to do this is to say that an allocation shrinks only if its usable_size shrinks, and otherwise to error</p>\n</blockquote>\n<p>are you suggesting that the client should be forced to query <code>usable_size</code> after calling <code>shrink_to_fit</code>??  ... no, you're just saying that's a way to describe the <em>specification</em> of <code>shrink_to_fit</code>, right?</p>",
        "id": 146860309,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> no, I think that we have to do two things:</p>\n<ul>\n<li>\n<p>detect whether <code>new_size == Layout::size()</code> and return <code>Ok(())</code> early,</p>\n</li>\n<li>\n<p>if the usable_size of the new allocation block is not smaller than the old size, return <code>Err</code></p>\n</li>\n</ul>",
        "id": 146860418,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505491
    },
    {
        "content": "<p>okay. So those are changes to the implementation of the <code>Alloc</code> for jemalloc.</p>",
        "id": 146860432,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505531
    },
    {
        "content": "<p>Do you think that the API for the <code>fn shrink_to_fit</code> in the <code>Alloc</code> trait needs changing, apart from clarifying its documentation?</p>",
        "id": 146860447,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505557
    },
    {
        "content": "<p>yes, the docs of <code>shrink_in_place</code> already say that the <code>new_size</code> can be equal to <code>Layout::size()</code> - in the docs, we have to explain better what <code>CannotReallocInPlace</code> means.</p>",
        "id": 146860454,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505583
    },
    {
        "content": "<p>For example, if you allocate some requested size, you can \"grow\"/\"shrink\" it in place as much as you want inside the same bin, at least for jemalloc, and <code>Alloc::usable_size()</code> lets you grow it.</p>",
        "id": 146860546,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505642
    },
    {
        "content": "<p>however, when shrinking, while one could shrink inside the same bin, the allocation itself doesn't change, and we consider it an error</p>",
        "id": 146860562,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505681
    },
    {
        "content": "<p>that is, grow_in_place inside the same bin returns success, but shrink_in_place inside the same bin returns error because the usable_size of the allocation did not change</p>",
        "id": 146860576,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505716
    },
    {
        "content": "<p>And your point is that <code>shrink_in_place</code> inside the same bin should return <code>Ok</code>, right?</p>",
        "id": 146860620,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505740
    },
    {
        "content": "<p>(as in, the subsequent <code>dealloc</code> call will work)</p>",
        "id": 146860626,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505755
    },
    {
        "content": "<p>i don't know, we can't implement this efficiently with jemalloc, and <code>Alloc::</code> does not have a method to query the \"minimum size of allocations inside this bin\"</p>",
        "id": 146860630,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505775
    },
    {
        "content": "<p>usable_size returns a lower bound doesn't it? That's meant to represent that minimum size of such allocations; that's why we added that lower bound.</p>",
        "id": 146860644,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505813
    },
    {
        "content": "<p>(that is, <code>usable_size</code> returns <code>(l, h)</code>)</p>",
        "id": 146860651,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505823
    },
    {
        "content": "<p>yeah, but it does not have to be accurate</p>",
        "id": 146860662,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505836
    },
    {
        "content": "<p>...</p>",
        "id": 146860700,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505843
    },
    {
        "content": "<p>as in, it is typically the requested size, and the largest size is computed e.g. via <code>nallocx</code></p>",
        "id": 146860706,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505866
    },
    {
        "content": "<p>oh okay</p>",
        "id": 146860710,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505872
    },
    {
        "content": "<p>sure, if the underlying allocator doesn't give a way to observe the lower bound, then you can't do anything about it. okay.</p>",
        "id": 146860714,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541505893
    },
    {
        "content": "<p>yeah, there is another fundamental problem with <code>shrink_in_place</code> that <code>grow_in_place</code> does not have</p>",
        "id": 146860781,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541505977
    },
    {
        "content": "<p><code>grow_in_place</code> lets you specify a size, and you get an allocation &gt;= than new_size, but with <code>shrink_in_place</code> you also get an allocation &gt;= new_size, but it can be much larger to the point of this not being useful</p>",
        "id": 146860803,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541506027
    },
    {
        "content": "<p>So the two ways I could imagine to address that are:</p>",
        "id": 146860861,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541506086
    },
    {
        "content": "<p>1. Change the API of <code>shrink_in_place</code> to include such info about the resulting size category for the \"new\" state  of the given block</p>",
        "id": 146860871,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541506119
    },
    {
        "content": "<p>or</p>",
        "id": 146860873,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541506121
    },
    {
        "content": "<p>2. Tell clients that they may want to query <code>usable_size</code> after calling <code>shrink_in_place</code> ...</p>",
        "id": 146860885,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541506144
    },
    {
        "content": "<p>(and accept that <code>usable_size</code> doesn't always provide the most precise answers)</p>",
        "id": 146860896,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541506160
    },
    {
        "content": "<p>((but it should <em>always</em> provide conservatively <em>correct</em> answers...))</p>",
        "id": 146860913,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541506180
    },
    {
        "content": "<p>in some sense, it is implied that if you can dealloc the new smaller allocation resulting from <code>shrink_in_place</code>, it will be in the same size class at leat - so this might not be as bad as I put it. </p>\n<p>Note also that <code>xallocx</code> returns the <code>usable_size</code>, and that we could use this information in <code>RawVec</code> for example, so that we would have to add <code>shrink/grow_in_place_excess</code> methods as well. It might be worth it to just change the signatures of these to always return the <code>Excess</code>.</p>",
        "id": 146860976,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541506227
    },
    {
        "content": "<p>I implemented a new <code>mallocx</code>-like API in jemalloc that always returns Excess for a C++ paper that proposes sized allocation, and this has been merged in jemalloc upstream already - so the whole \"should we have _excess variants of all methods\" discussion might be worth revisiting once <code>jemallcator</code> supports this API (there is an open PR about bumping the jemalloc version to the dev branch again)</p>",
        "id": 146861080,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541506345
    },
    {
        "content": "<p>Cool! Can you provide a pointer to the jemalloc PR? just curious.</p>",
        "id": 146861154,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541506453
    },
    {
        "content": "<p><a href=\"https://github.com/jemalloc/jemalloc/pull/1270\" target=\"_blank\" title=\"https://github.com/jemalloc/jemalloc/pull/1270\">https://github.com/jemalloc/jemalloc/pull/1270</a></p>",
        "id": 146861325,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541506759
    },
    {
        "content": "<p>i've pushed a commit to fix <code>shrink_in_place</code> to <a href=\"https://github.com/alexcrichton/jemallocator/pull/92\" target=\"_blank\" title=\"https://github.com/alexcrichton/jemallocator/pull/92\">https://github.com/alexcrichton/jemallocator/pull/92</a></p>",
        "id": 146861382,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541506821
    },
    {
        "content": "<p>we'll see if tests pass everywhere now or not</p>",
        "id": 146861384,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541506831
    },
    {
        "content": "<p>FWIW, the general recommendation is that <code>Alloc::usable_size</code> is a bad idea and I think we should remove it.</p>",
        "id": 146861413,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541506901
    },
    {
        "content": "<p>It basically makes it impossible to gather statistics about memory requests. If someone wants to introspect this, <code>jemallocator::ffi::nallocx</code> and friends can be used, but it shouldn't be a \"general purpose tool\", and it should not be widely used</p>",
        "id": 146861492,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507002
    },
    {
        "content": "<p>okay, reading over the comment you added to <a href=\"https://github.com/alexcrichton/jemallocator/pull/92\" target=\"_blank\" title=\"https://github.com/alexcrichton/jemallocator/pull/92\">https://github.com/alexcrichton/jemallocator/pull/92</a>, I think I <em>finally</em> understand the scenario you are describing</p>",
        "id": 146861560,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507129
    },
    {
        "content": "<p>I understand the drawback you describe, in terms of not being able to observe memory requests. My memory of the original motivation (for <code>Alloc::usable_size</code>) is that some people were concerned about being forced to round-trip requests through the allocator. Fundamentally I think that concern is inherently at odds with a desire to observe memory requests.</p>",
        "id": 146861651,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507250
    },
    {
        "content": "<p>i've shared that with the jemalloc devs, maybe they have a better recommendation, but the underlying problem here is that <code>xallocx</code> is basically <code>realloc_in_place</code>, which is what we used to have and worked \"as expected\" for that API, however, when that got adapted to <code>grow</code>/<code>shrink_in_place</code>, things got messy</p>",
        "id": 146861663,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507266
    },
    {
        "content": "<p>To be honest (and this may be obvious to you), I have not been driving the <code>trait Alloc</code> design for quite some time now; I'm not a stakeholder in whether it has <code>realloc_in_place</code> vs <code>grow/shrink_in_place</code>. I assume you've already read the comment threads discussing that split.</p>",
        "id": 146861743,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507346
    },
    {
        "content": "<p>yes, the split was motivation is good: its possible to provide different paths for both, and <code>realloc_in_place</code> mixes them inside one function</p>",
        "id": 146861758,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507387
    },
    {
        "content": "<p>now that we have some experience with <code>grow_in_place</code>/<code>shrink_in_place</code>, we have learned new things, and just because they don't work \"perfectly\" with <code>jemalloc</code> does not mean that's the fault of these APIs</p>",
        "id": 146861818,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507450
    },
    {
        "content": "<p>Your mentioning of <code>_excess</code> methods above does lead me to wonder whether indeed adding the info about <code>Excess</code> to the <code>Result::Ok</code> of <code>shrink_in_place</code> could be a way to kill two birds with one stone here</p>",
        "id": 146861837,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507482
    },
    {
        "content": "<p>if anything, the problem here is that <code>xallocx</code> returns <code>usable_size &lt; new_size</code> as error while growing, but <code>usable_size = original_size</code> as error while shrinking</p>",
        "id": 146861845,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507504
    },
    {
        "content": "<p>and the error while shrinking is sometimes \"success\"</p>",
        "id": 146861853,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507521
    },
    {
        "content": "<p>so just so I have this right: if I request a <code>new_size</code> where <code>new_size &lt; original_size</code>and it happens to be in the same size bin in as <code>original_size</code>, jemalloc is allowed to return <code>original_size</code> from <code>xallocx</code> ?</p>",
        "id": 146861916,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507593
    },
    {
        "content": "<p>if original_size is the usable_size of the bin, then yes</p>",
        "id": 146861924,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507627
    },
    {
        "content": "<p>I guess we could check that with  <code>original_bin_usable_size = nallocx(original_size)</code></p>",
        "id": 146861978,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507673
    },
    {
        "content": "<p>but if we don't inline jemalloc into Rust, that could make things slightly more expensive (and in rare pathological cases way more expensive) for little win</p>",
        "id": 146862006,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507715
    },
    {
        "content": "<p><code>nallocx</code> is computed at the beginning of <code>xallocx</code> to find the size class of the original allocation, so if we inline jemalloc into Rust, doing that becomes free</p>",
        "id": 146862030,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507751
    },
    {
        "content": "<p>sorry to be pedantic here, but I just want to really make sure I understand</p>",
        "id": 146862093,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507790
    },
    {
        "content": "<p>don't worry, what i mentioned might be slightly incorrect</p>",
        "id": 146862098,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507810
    },
    {
        "content": "<p>if the original_size is the usable size of the bin, then this is always the case</p>",
        "id": 146862112,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507829
    },
    {
        "content": "<p>if the original_size is not the usable_size of the bin, then I don't know what happens</p>",
        "id": 146862116,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507842
    },
    {
        "content": "<p>if i request a <code>new_size</code> where <code>new_size &lt; original_size</code> and the resize attempt <em>fails</em>, it will <em>again</em> return <code>original_size</code>, right?</p>",
        "id": 146862123,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507856
    },
    {
        "content": "<p>jemalloc's docs don't mention it, and I don't think all code paths do the same thing here</p>",
        "id": 146862128,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507860
    },
    {
        "content": "<p>I suppose this is exactly what you said above</p>",
        "id": 146862133,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507868
    },
    {
        "content": "<p>So what I take from this is that what <em>jemalloc</em> expects/wants us to do is to not expect to be able to request a size <code>S</code> and, on success, subsequently always be able to use <code>S</code> as the size in a subsequent <code>dealloc</code></p>",
        "id": 146862188,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507943
    },
    {
        "content": "<p>let's put it 100% clear - if <code>new_size &lt; original_size</code> is requested and shrinking fails then what <code>xallocx</code> returns is not documented anywhere.  <code>xallocx</code> always returns an <code>usable_size</code> as far as I can tell from reading the code and the docs, but it might return the original_size here sometimes as well - obviously, if the original size is the usable size of the bin, then both match, but I don't know if both have to match</p>",
        "id": 146862207,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541507987
    },
    {
        "content": "<p>but instead, you can request a size <code>S1</code>, and <code>xmallocx</code> will return some size <code>S2</code> (where <code>S1 &lt;= S2 &lt;= original_size</code>), and you are expected to subsequently use <code>S2</code> for the dealloc</p>",
        "id": 146862213,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541507994
    },
    {
        "content": "<p>yes, that's correct</p>",
        "id": 146862258,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508017
    },
    {
        "content": "<p>okay</p>",
        "id": 146862261,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508022
    },
    {
        "content": "<p>but I don't know if this is intended, because this is the only api where it happens, and only when shrinking</p>",
        "id": 146862266,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508036
    },
    {
        "content": "<p>Should we then consider changing the API of <code>shrink_in_place</code> to return that <code>S2</code> ?</p>",
        "id": 146862277,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508052
    },
    {
        "content": "<p>in all other APIs, you can use the [requested, usable] range of sizes to deallocate</p>",
        "id": 146862278,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508054
    },
    {
        "content": "<p>the problem is when shall we error</p>",
        "id": 146862306,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508110
    },
    {
        "content": "<p>well other Allocators would then have the option of erroring</p>",
        "id": 146862354,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508123
    },
    {
        "content": "<p>while jemaloc would now always succeed, as you originally suggested</p>",
        "id": 146862359,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508132
    },
    {
        "content": "<p>that is, if we return the size that <code>xallocx</code> returns, when is that value \"success\" and when is it \"error\" ? we would just be pushing that to <code>Alloc</code> users</p>",
        "id": 146862362,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508141
    },
    {
        "content": "<p>the crucial detail is the idea of returning the \"new\" size class to be used</p>",
        "id": 146862365,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508143
    },
    {
        "content": "<p>yes, the error condition might not be important here</p>",
        "id": 146862388,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508209
    },
    {
        "content": "<p>Indeed, it is pushing the obligation to call dealloc with the correct value (S2) onto the client, rather than letting them assume that S1 will always work</p>",
        "id": 146862394,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508220
    },
    {
        "content": "<p>I mean, what can one do with the error of <code>grow</code>/<code>shrink</code> in place ?</p>",
        "id": 146862395,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508222
    },
    {
        "content": "<p>give up and try a different value</p>",
        "id": 146862399,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508235
    },
    {
        "content": "<p>or bubble the failure out</p>",
        "id": 146862402,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508240
    },
    {
        "content": "<p>try a different value \"in place\" ?</p>",
        "id": 146862448,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508266
    },
    {
        "content": "<p>sure</p>",
        "id": 146862453,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508271
    },
    {
        "content": "<p>I'm just spit-balling here</p>",
        "id": 146862460,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508274
    },
    {
        "content": "<p>I don't know what best practices would be</p>",
        "id": 146862470,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508293
    },
    {
        "content": "<p>yeah, so I could imagine that if these fail, one moves to doing this out-of-place, but realloc works in place if it can</p>",
        "id": 146862472,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508299
    },
    {
        "content": "<p>so that use case makes no sense</p>",
        "id": 146862482,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508309
    },
    {
        "content": "<p>in the sense that if <code>shrink_in_place</code> always succeeds (for <em>jemalloc</em>) then realloc will behave in unexpected ways?</p>",
        "id": 146862559,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508371
    },
    {
        "content": "<p>Its not like jemalloc couldn't override the implementation of <code>realloc</code> if that makes sense for jemalloc's impl of <code>Alloc</code> ...</p>",
        "id": 146862572,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508413
    },
    {
        "content": "<p>nono, in the sense that if you want to shrink in place, but are ok with shrinking \"out of place\" if that fails, you can just use <code>realloc</code> directly instead since it will do exactly that</p>",
        "id": 146862575,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508417
    },
    {
        "content": "<p>oh oh oh</p>",
        "id": 146862587,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508427
    },
    {
        "content": "<p>no need to first call shrink_in_place, then realloc</p>",
        "id": 146862590,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508433
    },
    {
        "content": "<p>yes you are right</p>",
        "id": 146862591,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508437
    },
    {
        "content": "<p>but I'm not a good resource to ask about the use cases for this method</p>",
        "id": 146862643,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508484
    },
    {
        "content": "<p>so i am going to wait till we clarify with upstream whether <code>xallocx</code> always returns the usable size of the original bin on failure - if that's the case, we can use <code>nallocx</code> to be \"perfectly\" accurate</p>",
        "id": 146862649,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508490
    },
    {
        "content": "<p>and then we can fix things, and maybe jemalloc's dev suggest adding apis for these use cases or not, or maybe there is a better way to do all of this</p>",
        "id": 146862665,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508525
    },
    {
        "content": "<p>in the sense that you would make <code>shrink_in_place</code> react to the return value of <code>original_size</code> by then checking if the requested size falls into the current size class (via <code>nallocx</code>), and if so, still return <code>Ok(())</code> (and if it doesn't fall into the current size class, <em>then</em> return <code>Err(_)</code> ?)</p>",
        "id": 146862783,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508656
    },
    {
        "content": "<p>kind of, I'll update the PR right now under that assumption, because I am pretty confident that if <code>xallocx</code> does not always return the <code>usable_size</code> then that's a bug in jemalloc.</p>",
        "id": 146862854,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541508730
    },
    {
        "content": "<p>I ask because I originally thought you were suggesting that we call <code>nallocx</code> <em>first</em>, before <code>xallocx</code>, which would then mean you could always just treat a return value of the <code>orignal_size</code> as an error, and you wouldn't have to make any queries upstream.</p>",
        "id": 146862855,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508733
    },
    {
        "content": "<p>but I'm guessing you don't want to add that overhead to the hot path?</p>",
        "id": 146862860,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508749
    },
    {
        "content": "<p>(where its \"only\" overhead if the code to call <code>xallocx</code> isn't not inlined and then the two inlined calls to <code>nallocx</code> are CSE optimized into a single expression...)</p>",
        "id": 146862871,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508781
    },
    {
        "content": "<p>Sorry; I really feel like I'm belaboring the same points you already laid out, but I just want to make sure I understand the plan</p>",
        "id": 146862945,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508866
    },
    {
        "content": "<p>((which is strange because, as I said above, I'm really not one of the stakeholders here anymore))</p>",
        "id": 146862959,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541508888
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> i've pushed a commit that should make it accurate at the cost of an extra <code>nallocx</code> call in the case in which the allocation is not shrunk</p>",
        "id": 146863530,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541509589
    },
    {
        "content": "<p>cool thanks</p>",
        "id": 146863539,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541509602
    },
    {
        "content": "<p>It sounds to me like that should be both safe (in terms of ensuring the subsequent calls to dealloc will be correct) and nearly as fast as what we had before ... we'll just be paying, at most, in code size if the code is insufficiently inlined. Right?</p>",
        "id": 146863580,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541509682
    },
    {
        "content": "<p>(i mean, the internal cost of the extra <code>nallocx</code> call sounds negligible compared to the external cost of returning <code>Err</code> when <code>Ok</code> would have worked!)</p>",
        "id": 146863619,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541509715
    },
    {
        "content": "<p>probably, i'd rather just get this correct first, I think its not the first time these have been amended, but I also think that we regressed previous bug fixes here when the <code>GlobalAlloc</code> refactors were merged (things were fixed in jemallocator but not in rust-lang/rust and then rust-lang/rust code was copy-pasted back)</p>",
        "id": 146863728,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541509837
    },
    {
        "content": "<p>I agree, get it right first is the way to go</p>",
        "id": 146863755,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541509888
    },
    {
        "content": "<p>Wow I hadn't noticed that the original code used <code>size &gt;= new_layout.size() </code> instead of <code>size &gt; new_layout.size() </code>. That's pretty egregious.</p>",
        "id": 146865138,
        "sender_full_name": "pnkfelix",
        "timestamp": 1541511514
    },
    {
        "content": "<blockquote>\n<p>Wow I hadn't noticed that the original code used size &gt;= new_layout.size()  instead of size &gt; new_layout.size() . That's pretty egregious.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> I think that the code using <code>realloc_in_place</code> back then might have been correct, but since the split was made both grow/shrink in place have always been at least partially broken. I've just merged a PR to fix <code>grow_in_place</code>. The <code>jemalloc</code> devs still have not commented about <code>shrink_in_place</code>.</p>",
        "id": 146872444,
        "sender_full_name": "gnzlbg",
        "timestamp": 1541518841
    }
]