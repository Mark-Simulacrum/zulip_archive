[
    {
        "content": "<p>Hello! I’m curious if anyone has feedback for either the content or form of the rfc I opened a few days ago: <a href=\"https://github.com/rust-lang/rfcs/pull/3199\">https://github.com/rust-lang/rfcs/pull/3199</a></p>",
        "id": 263386688,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638412700
    },
    {
        "content": "<p>Well, I, at least, quite like the idea! ...I don't have any specific feedback right now though.</p>",
        "id": 263388545,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638415067
    },
    {
        "content": "<p>I still appreciate the read through!</p>",
        "id": 263389353,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638416132
    },
    {
        "content": "<p>Using reference syntax for unsafe ops seems ... not great. Someone suggested <code>*aligned const</code>, that seems more clear to me</p>",
        "id": 263389707,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638416580
    },
    {
        "content": "<p>Also I only skimmed the RFC, but I don't understand how it could be safe to write to the address but not safe to read from it</p>",
        "id": 263389801,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638416681
    },
    {
        "content": "<p>Since if it's been deallocated it's UB to write to it</p>",
        "id": 263389828,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638416712
    },
    {
        "content": "<p>It’s not safe to write to, because assigning to a variable through a 'unsafe reference, and assigning to a value whose type is instantiated with the 'unsafe lifetime is unsafe is unsafe</p>",
        "id": 263392228,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638419992
    },
    {
        "content": "<p>I would imagine it to have slightly different SB behaviour than <code>*aligned const T</code> - it would enforce that no <code>&amp;mut T</code>s also exist to the same location.</p>",
        "id": 263399468,
        "sender_full_name": "Kestrer",
        "timestamp": 1638428093
    },
    {
        "content": "<p>I don't understand why <code>'unsafe</code> is supposed to be shorter than all lifetimes. Doesn't that mean it's already invalid? How does that work? Also, does \"all lifetimes\" include <code>'unsafe</code>? Is <code>'unsafe</code> shorter than itself? That also seems bad. It is also not clear whether or not it is valid to substitute <code>'unsafe</code> for a generic lifetime. The rationale seems to suggest that it should be possible, since we want to use it for data structures and functions out of our control declared with lifetime arguments, but the rule for unsafe blocks doesn't work in that case:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// simplified example from the RFC</span>\n<span class=\"k\">fn</span> <span class=\"nf\">store</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">unsafe</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// assigning to val, not through val.</span>\n<span class=\"w\">    </span><span class=\"c1\">// unsafe due to rule 4. If we were assigning through it would be rule 3.</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">store_generic</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">evil</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">unsafe</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">store_generic</span>::<span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// look ma, no unsafe</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Rule 1.5 also seems to contradict the rationale, since it suggests that calls like <code>store_generic::&lt;'unsafe&gt;</code> are not legal (with or without an unsafe block), but in that case there is no point in constructing a <code>std::slice::Iter&lt;'unsafe, T&gt;</code> since you can't call any functions on it.</p>",
        "id": 263404188,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638432853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232545\">Joshua Nelson</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263389707\">said</a>:</p>\n<blockquote>\n<p>Using reference syntax for unsafe ops seems ... not great. Someone suggested <code>*aligned const</code>, that seems more clear to me</p>\n</blockquote>\n<p>It would have the advantage of \"compositionality\" (if that isn't a word you get what I meant); it incidentally reminds me a bit of the super subtle <code>#[may_dangle]</code> attribute. So, when thinking about it, being compositional is not necessarily always a good thing, at least for a fully opaque API: chances are that by promoting an <code>'unsafe</code> version of it to become \"alive\". Maybe the RFC should thus mention that it <em>should</em> (as in recommended, not mandatory) only be used with types defined in the same crates, or types of dependencies <em>provided</em> they properly document their lifetime-related properties.</p>\n<p>For instance, one should be very aware of the <em>variance</em> of a type before using <code>'unsafe</code> in it, so the defined type better guarantee it. This is different from the current <em>status quo</em>, whereby if somebody incorrectly relies on the variance of an external type, or if the variance of that type changes, the borrow checker will be there to catch the error.</p>",
        "id": 263417521,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638440972
    },
    {
        "content": "<p>Regarding the explanation, and this may be related to <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>'s example, I think the whole model could be simplified, by a lot. The key idea is to think of that lifetime as <code>'empty</code> / <code>'void</code> / <code>'bottom</code>:</p>\n<h4>an <code>'unsafe</code> lifetime acts as an expired lifetime <em>anywhere</em> it appears (but for the type itself being well-formed enough to be nameable)</h4>\n<ul>\n<li>The type itself can be named / passed around</li>\n<li>Generic lifetime parameters in <em>functions</em> (and any other operation, <em>e.g.</em>, a dereference) cannot be instanced with the <code>'unsafe</code> lifetime without <code>unsafe</code>.</li>\n</ul>\n<p>And that's it. Anything else follows from variance or lack thereof:</p>\n<p>Take <code>store_generic</code>, above:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">store_generic</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>that one already doesn't compile, <strong>thanks to invariance of <code>type T&lt;'a&gt; = &amp;'whatever &amp;'a usize;</code></strong>, unless the same lifetime appears on the right:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">//                                      Bound added to make it compile</span>\n<span class=\"c1\">//                                      vvvvvvv</span>\n<span class=\"k\">fn</span> <span class=\"nf\">store_generic</span><span class=\"o\">&lt;'</span><span class=\"na\">val</span>: <span class=\"o\">'</span><span class=\"na\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">r</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">val</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">r</span> <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(The <code>'val : 'val</code> is just to make it an early-bound / non-higher-order lifetime parameter which can thus be turbofished)</li>\n</ul>\n<p>Then, <em>even assuming a non-<code>unsafe</code> usage of the <code>'unsafe</code> lifetime in a function's generic parameter</em>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">evil</span><span class=\"o\">&lt;'</span><span class=\"na\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">val</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">unsafe</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">r</span> <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"n\">store_generic</span>::<span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">unsafe</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">r</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>does indeed compile, but that shouldn't be a surprise:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">evil</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// look motherboard, no unsafe!</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Indeed, <code>&amp;mut &amp;'unsafe usize</code> can only be constructed off a <code>&amp;'unsafe usize</code> to begin with, it can't be obtained by subtyping / variance. And if somebody has a <code>&amp;'unsafe usize</code> they indeed to dereference later on, then they better dont feed a <code>&amp;mut</code> reference to it to an unknown API, much like you wouldn't do that with a <code>*const usize</code>.</p>\n<p>But now imagine that <code>store_generic</code> were to double-dereference-read its first argument. Then calling it with an <code>'unsafe</code> lifetime would be unsound. Hence why that call, independently of the function's implementation, would have to be <code>unsafe</code>.</p>\n<p>Construction of a self-referential struct using <code>'unsafe</code> would thus be easy: by covariance any short-lived instance of a self-reference can be coerced to <code>'unsafe</code>, and then stored within the type. It is the usage / dereference of such potentially-dangling \"references\" which would need <code>unsafe</code>, as it should.</p>",
        "id": 263420921,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638442973
    },
    {
        "content": "<p>I think I agree with your model <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> , but the source of \"unsafety\" is still unclear to me. Here's a simpler example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read_generic</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">evil2</span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">unsafe</span> <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">read_generic</span>::<span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Clearly we want the call to <code>read_generic</code> to be unsafe, but is it the construction of <code>read_generic::&lt;'unsafe&gt;</code> that is unsafe, or the call operator? I recall having an aha moment when reading the rustbelt paper, when they observed that all lifetime parameters in a function call implicitly have outlives bounds over a lifetime you could call <code>'fn</code> which is the lifetime of the call itself (or the lifetime of the call stack allocation, if you will). In this case, <code>'unsafe</code> clearly does not outlive <code>'fn</code>, but depending on whether you consider this where bound to be early or late bound you could either have the function construction or the call to be unsafe. (Actually, with rust as it exists today, this isn't just unsafe, it's an error. You can't circumvent borrow check errors with an unsafe block, so there needs to be some other mechanism here.)</p>",
        "id": 263422392,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638443842
    },
    {
        "content": "<p>Now, there is one thing that irks me with this design (or in other words, <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>, I'm starting to disagree with my own model <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span>) now:</p>\n<p>Given <code>&amp;'val mut &amp;'unsafe usize</code>: should <code>'val</code> be (constrained to be) <code>'unsafe</code>?</p>\n<p>Well technically yes:</p>\n<ul>\n<li><code>'inner : 'outer</code> =&gt; <code>'unsafe : 'val</code> (<strong>unless we made an exception for the <code>'inner = 'unsafe</code> case? ughhh</strong>)</li>\n<li>But <code>for &lt;'any&gt; 'any : 'unsafe</code> =&gt; <code>'val : 'unsafe</code>.<br>\nHence <code>'val = 'unsafe</code>.</li>\n</ul>\n<p>And that's a big bummer: <code>fn get (it: &amp;'_ (i32, &amp;'unsafe ())) -&gt; &amp;'_ i32</code> now would become <code>fn get (it: &amp;'unsafe (i32, &amp;'unsafe ())) -&gt; &amp;'unsafe i32</code> just because of that inner <code>'unsafe</code> appearing in an obviously unrelated field! This would totally defeat the point of self-referential structs.</p>\n<p>So my previous suggestion doesn't work, or not directly: <code>'unsafe</code> does not represent a stale lifetime, or not exactly, it just represents a hack for the \"compositionality\" I was talking about:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">type</span> <span class=\"nc\">Ref</span><span class=\"o\">&lt;'</span><span class=\"na\">lt</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">lt</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"cp\">#[magic]</span><span class=\"w\"></span>\n<span class=\"k\">type</span> <span class=\"nc\">Ref</span><span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ptr</span>::<span class=\"n\">NonNullAndWellAligned</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where the RHS would be the genuine \"current\" Rust types, and the lhs would be sugared to <code>&amp;T</code>. So variance no longer plays that much of a role: any time we'd see <code>&amp;'unsafe …</code> it would just be an alias for a raw pointer, just so that <code>Iter&lt;'lt, T&gt;</code> can become <code>Iter&lt;'unsafe, T&gt;</code> automagically (with all of its API made <code>unsafe</code>).</p>\n<ul>\n<li>To be more rigorous, imagine, in an HKT world: <code>Iter_&lt;MaybeLifetimedRef&lt;_&gt;, T&gt; { slice: MaybeLifetimedRef&lt;T&gt;, … }</code> then <code>Iter&lt;'lt, T&gt;</code> would be <code>Iter_&lt;&amp;'lt, T&gt;</code>, and and <code>Iter&lt;'unsafe, T&gt;</code> would be <code>Iter_&lt;ptr::NonNullAndAligned, T&gt;</code>.</li>\n</ul>\n<hr>\n<p>All in all, I think there is potential with some idea along these lines, but I have to admit that I find it oh so subtle: using <code>Pin</code> in comparison would be a children's game!</p>",
        "id": 263422592,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638443982
    },
    {
        "content": "<p>One way around that is to allow types like <code>&amp;'a &amp;'unsafe T</code> or even <code>&amp;'a &amp;'b T</code> where <code>'b</code> does not outlive <code>'a</code>; it is just unsafe to access in the same way as <code>&amp;'unsafe T</code> (whatever that is; I'm still trying to grok that part). Unfortunately this doesn't play well with implied bounds though</p>",
        "id": 263422891,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638444136
    },
    {
        "content": "<p>Maybe the \"exception to the implicit outlives rule\", despite how ugly, is the only way forward. Back to the <code>read_generic</code> example, what if the author, who knows they aren't <code>'a</code>-dereferencing stuff, wanted to opt into making their function safe to call even with <code>'unsafe</code>, by having to write <code>'unsafe</code>-aware code?</p>\n<p>Then that's where we connect with <code>#[may_dangle]</code>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read_generic</span><span class=\"o\">&lt;</span><span class=\"cp\">#[may_dangle]</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">r</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">r</span> <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">val</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// OK (but any `**val` dereference would be forbidden in safe code).</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">some_caller</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">val</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">unsafe</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">read_generic</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">some_ref</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// OK, no `unsafe`</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That's all I wanted to mention on the topic, although the implied bounds question is annoying.</p>",
        "id": 263423838,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638444776
    },
    {
        "content": "<p>FWIW, another interesting mention <em>w.r.t.</em> RFC would be the instance of atomic decrements being refactored into its own API making stuff technically UB <em>w.r.t.</em> <code>dereferenceable</code> <span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 263423864,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638444796
    },
    {
        "content": "<p>On the topic of &amp;'val mut &amp;'unsafe, this is legal due to point 2 in the reference level explanation. “The check that a reference does not outlive borrowed content is skipped when the borrowed content has 'unsafe lifetime.”</p>",
        "id": 263439511,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638453175
    },
    {
        "content": "<p>The *aligned const approach doesn’t solve the core problem which is that there is no way to store a type which is generic over a lifetime the borrow checker doesn’t understand (most often self reference lifetime)</p>",
        "id": 263439986,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638453381
    },
    {
        "content": "<p>The place where the unsafety of this lifetime primarily comes from is the relaxation of the “reference must outlive borrowed content” check when the borrowed content uses 'unsafe”. We need to have some unavoidable part of the usage process be an unsafe operation, so we make it the variable assignment.<br>\nIf you don’t assign a variable to it you don’t need to worry about the lifetime being valid when the value is dropped. Coercion of values into unsafe lifetimes is safe, as you know the lifetime is valid at the time of coercion (for example calling a function with an unsafe lifetime in the function definition) but storing that value is not safe because that’s when you are ascribing a scope to it, and therefore a lifetime it is expected to be alive for. You can only assign if you know the variable into which you are assigning will be dropped while the &amp;'unsafe references within are valid.</p>",
        "id": 263442181,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638454318
    },
    {
        "content": "<p>Just want to chime in and say that this feature would have been pretty useful when I was implementing my actor model, as I was having to force moving by value because of that <code>T: `static</code> catch.</p>",
        "id": 263469289,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1638464828
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> I don't think this is actually <em>that</em> complicated. If I understand correctly, what you're suggesting is this:</p>\n<ol>\n<li><code>'a: 'unsafe</code> for all <code>'a</code>.</li>\n<li><code>T&lt;'unsafe&gt;: 'static</code></li>\n<li>\n<p>Dereferencing a <code>&amp;'unsafe T</code> is instant UB, which implies:<br>\n       3.1.  Instantiating any lifetime parameters in scope for a function with <code>'unsafe</code> is instant UB. This resolves the <code>dereferencable</code> issue, I think.</p>\n</li>\n<li>\n<p>Besides that, it works like all other lifetimes</p>\n</li>\n</ol>\n<p>Then, annotating the example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">ArrayIter</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">buffer</span>: <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// Requires `T: 'unsafe` which is trivially met</span>\n<span class=\"w\">    </span><span class=\"c1\">// But is `'static`, so if `T: 'a` then `ArrayIter&lt;T&gt;: 'a`</span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>: <span class=\"nc\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">ArrayIter</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// this function needs no `unsafe`</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">buffer</span>: <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">32</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Fake syntax to allow giving this lifetime a name.</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">buffer</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">iter</span>: <span class=\"nc\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">primitive</span>::<span class=\"n\">slice</span>::<span class=\"n\">iter</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// This compiles because of subtyping</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">unsafe_iter</span>: <span class=\"nc\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">iter</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// `'a` may now expire here</span>\n<span class=\"w\">        </span><span class=\"n\">ArrayIter</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">buffer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"c1\">// No longer borrowed</span>\n<span class=\"w\">            </span><span class=\"n\">iter</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"sd\">/// SAFETY: `self` has not been moved since being constructed</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">next</span><span class=\"o\">&lt;'</span><span class=\"na\">outer</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">outer</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">outer</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Fake syntax again. Implies `'outer: 'a`</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">unsafe_ref</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">iter</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// This would be UB and is rejected by the compiler</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"o\">&gt;</span>::<span class=\"n\">next</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// ERROR</span>\n<span class=\"w\">        </span><span class=\"c1\">// Instead, we transmute the lifetime out first</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">safe_ref</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">outer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"c1\">// SAFETY: The iterator is valid until at least the end of the</span>\n<span class=\"w\">            </span><span class=\"c1\">// function because `self` has not been moved</span>\n<span class=\"w\">            </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">unsafe_ref</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Now this is ok</span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">outer</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span>::<span class=\"n\">next</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">safe_ref</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Of course, its possible to add in syntax sugar to do the equivalent of the transmute, but the rules at least seem reasonably simple like this.</p>",
        "id": 263506423,
        "sender_full_name": "Jake",
        "timestamp": 1638482670
    },
    {
        "content": "<p>On the drop thing: could it be simplified to have the same kind of requirements as unions?  So unless the thing is <code>Copy</code>, you can only have the thing with <code>'unsafe</code> in a <code>ManuallyDrop</code>.</p>",
        "id": 263512515,
        "sender_full_name": "scottmcm",
        "timestamp": 1638486384
    },
    {
        "content": "<p>If this is encouraging transmuting lifetimes, I would encourage it to include a specific function that can <em>only</em> do that.  <code>transmute</code> is a big hammer; a special <code>lifetime_transmute</code> could check that the two types are the same except for the lifetimes to make that less scary.</p>",
        "id": 263512852,
        "sender_full_name": "scottmcm",
        "timestamp": 1638486596
    },
    {
        "content": "<p>One thing that scares me -- though I don't have a concrete example -- is that lifetimes are designed to be erased, so it feels really odd to have one that changes the available operations so thoroughly that it can't be treated like just another lifetime that happens to be shorter.  Our one other specially-namable lifetime what a primary source for specialization unsoundness, for example.</p>",
        "id": 263513204,
        "sender_full_name": "scottmcm",
        "timestamp": 1638486790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jake</span> yes, that's how I was viewing it initially (minimum lifetime; needs <code>unsafe</code> to be used to be dereferenced or fed to a lifetime-generic API (unless it has, itself, <code>#[may_dangle]</code>on that lifetime parameter).<br>\nBut the part about skipping the \"inner lifetime does not need to outlive (live at least as long as) the outer one\", as mentioned by <span class=\"user-mention\" data-user-id=\"461427\">@Mason Boeman</span>, would not only be an exception to the lifetime rule; which can be bearable (for the sake of the feature, say), but then the whole \"call a generic-over-a-lifetime API with <code>unsafe</code>\" would have to go. As <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span>, we can't have Rust deal with <code>'a : 'b unless 'a is 'unsafe</code> bounds. So, yes, a <code>.transmute_lifetime_unbounded</code> and <code>.transmute_lifetime(&amp;thing)</code> would be the ways to remove the <code>'unsafe</code>, which would have to be done in order to be able to call a lifetime-generic API.</p>\n<p>I guess I tunnel-visioned too much <em>w.r.t</em> calling lifetime-generic APIs, when that is so incompatible with the special \"no outlives rule\" that <code>'unsafe</code> needs. Incidentally, or actually relatedly, <span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span>, that would solve the \"lifetime erasure\" issue, since <code>T&lt;'unsafe&gt;</code> would be a genuinely distinct type from <code>T&lt;'lt&gt;</code>.</p>\n<p>In that regard, a nit would be that, there wouldn't be a question of covariance or of <code>'a : 'unsafe</code> : <code>'unsafe</code> would just be a special state / value for a lifetime parameter. With this vision the proposal is consistent, and the no-outlives \"special\" rule is no longer a weird exception, since it's just a matter of sugar. Heck, when I think about it, maybe we should remove the <code>'</code> in it to remove all confusion: the \"<code>unsafe</code> lifetime override\": <code>&amp;unsafe T</code>, <code>Iter&lt;unsafe, T&gt;</code>, _etc._</p>",
        "id": 263518231,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638490021
    },
    {
        "content": "<p>In that sense <code>'unsafe</code> should basically be read as <code>erased</code> and (if we had that keyword reserved) that would maybe even be a good name for it. This also makes many of the features around this very intuitive; obviously you can't dereference something with an erased lifetime, and lifetime-generic APIs need real, not erased, lifetimes to be called with. <code>transmute_lifetime</code> then becomes <code>unerase_lifetime</code> which is obviously unsafe.</p>",
        "id": 263519235,
        "sender_full_name": "Jake",
        "timestamp": 1638490797
    },
    {
        "content": "<p>I do really like the “erased” name. Possibly it could go with another suggestion of removing the tick, so just &amp;erased.</p>\n<p>One delicate thing is that erasing something’s lifetime is dangerous with types that impl Drop as you need to construct a lifetime at drop time.</p>\n<p>Maybe what it should be is </p>\n<p>Unsafe fn erase_lifetime(…)<br>\nUnsafe fn unerase_lifetime(…).</p>\n<p>The reason the first one needs to be unsafe is that you could erase a lifetime and call a drop function which relies on the erased lifetime after it expires, entirely in safe code otherwise.</p>",
        "id": 263519802,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638491189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461427\">@Mason Boeman</span> yeah, unfortunately <code>erased</code> on its own won't work, since in <code>T&lt;erased, U&gt;</code> its not clear whether <code>erased</code> is the special lifetime or the unfortunately not uppercase name of some type, and figuring this out would require knowing what the kinds of the generics on <code>T</code> are, which I assume is too context sensitive for Rust.</p>",
        "id": 263519960,
        "sender_full_name": "Jake",
        "timestamp": 1638491320
    },
    {
        "content": "<p>I think leaving the <code>'</code> might still be best.  If you have <code>struct Foo&lt;'a, T, A = GlobalAlloc&gt;(...);</code> then <code>Foo&lt;'A, B&gt;</code> and <code>Foo&lt;A, B&gt;</code> are both legal.</p>\n<p>(Now, as you said, <code>unsafe</code> is a keyword so it's not actually ambiguous there, but...)</p>",
        "id": 263520163,
        "sender_full_name": "scottmcm",
        "timestamp": 1638491485
    },
    {
        "content": "<p>With regards to the drop issue, I think that Scott's suggestion basically works here. In particular, we can require that you're never allowed to drop a <code>T&lt;'erased&gt;</code>. So either <code>T</code> is <code>Copy</code>, or the <code>T&lt;'erased&gt;</code> gets moved into a <code>ManuallyDrop</code> at some point</p>",
        "id": 263520233,
        "sender_full_name": "Jake",
        "timestamp": 1638491531
    },
    {
        "content": "<p>I don’t fully understand this. Is there precedent for saying “If your struct contains a 'unsafe lifetime, you must impl drop” and “if your struct is instantiated with the unsafe lifetime it must be copy or moved into a ManuallyDrop”</p>",
        "id": 263520485,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638491744
    },
    {
        "content": "<p>You would need both</p>",
        "id": 263520488,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638491750
    },
    {
        "content": "<p>Although you actually have a third out, if you impl drop for T&lt;'unsafe&gt; instead of T&lt;'a&gt; then you can drop it as normal, but that might just make it more confusing and the other two options are more simple</p>",
        "id": 263520749,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638491966
    },
    {
        "content": "<p>You would not be required to <code>impl Drop</code> for your struct if it contains a <code>T&lt;'erased&gt;</code> for <code>T: !Copy</code>; the requirement would just be that your struct may not contain <code>T&lt;'erased&gt;</code>, and must instead contain <code>ManuallyDrop&lt;T&lt;'erased&gt;&gt;</code>.</p>",
        "id": 263520894,
        "sender_full_name": "Jake",
        "timestamp": 1638492074
    },
    {
        "content": "<p>Ooooooooooohhhhh that’s actually much nicer</p>",
        "id": 263520928,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638492109
    },
    {
        "content": "<p>So if you want to drop the <code>T</code>, then you need to <code>impl Drop</code> yourself and run the drop there using the appropriate <code>unsafe</code></p>",
        "id": 263521023,
        "sender_full_name": "Jake",
        "timestamp": 1638492190
    },
    {
        "content": "<p>This is modulo interaction with <code>#[may_dangle]</code> which actually sounds like it'll make this situation lots easier, since you actually can drop <code>T&lt;'erased&gt;</code> for <code>T&lt;#[may_dangle] 'a&gt;</code> if I'm not mistaken</p>",
        "id": 263521335,
        "sender_full_name": "Jake",
        "timestamp": 1638492451
    },
    {
        "content": "<p>I’m unclear on the function/purpose of <code>#[may_dangle]</code></p>",
        "id": 263521433,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638492525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263520928\">said</a>:</p>\n<blockquote>\n<p>Ooooooooooohhhhh that’s actually much nicer</p>\n</blockquote>\n<p>Yeah, I was very happy when that was proposed for <code>union</code>s.  It makes it so much simpler than what the rules otherwise would have had to be, so hopefully the same trick can help here <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 263521532,
        "sender_full_name": "scottmcm",
        "timestamp": 1638492623
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461427\">@Mason Boeman</span> It's no longer relevant now that we are no longer talking of generics</p>",
        "id": 263522177,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638493132
    },
    {
        "content": "<p>I think it still is actually. If <code>T&lt;'a&gt;</code> has <code>#[may_dangle]</code> in its drop impl, it should be sound to drop <code>T&lt;'erased&gt;</code>, therefore not requiring the <code>ManuallyDrop</code></p>",
        "id": 263522279,
        "sender_full_name": "Jake",
        "timestamp": 1638493204
    },
    {
        "content": "<p>But I also only 75% understand <code>#[may_dangle]</code>, so am very open to being wrong</p>",
        "id": 263522364,
        "sender_full_name": "Jake",
        "timestamp": 1638493235
    },
    {
        "content": "<p>This possibly even opens the door for adding <code>#[may_dangle]</code> on things that aren't <code>impl Drop</code>, although maybe that's a door better left shut</p>",
        "id": 263522735,
        "sender_full_name": "Jake",
        "timestamp": 1638493485
    },
    {
        "content": "<p>(where <code>#[may_dangle]</code> is read <code>#[may_be_erased]</code>)</p>",
        "id": 263522781,
        "sender_full_name": "Jake",
        "timestamp": 1638493515
    },
    {
        "content": "<p>So with this it’s actually totally safe to assign a value T&lt;'a&gt; to a variable T&lt;'unsafe&gt;, because the variable is not allowed to be dropped unless it’s put in a manuallydrop</p>",
        "id": 263523118,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638493771
    },
    {
        "content": "<p>Yeah, and I feel like that simplifies a lot of the proposal, since creating, moving, referencing, etc. stuff with erased lifetimes is now entirely safe and all works as expected. Its just that using stuff with erased lifetimes is a compiler error unless you <code>unsafe</code>ly un-erase the lifetime</p>",
        "id": 263523415,
        "sender_full_name": "Jake",
        "timestamp": 1638493980
    },
    {
        "content": "<p>I will update the RFC to reflect this tonight.</p>",
        "id": 263523583,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638494091
    },
    {
        "content": "<p>Hmm, doesn't this actually clean some things in the other direction? If I'm not misunderstanding,</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"o\">&lt;</span><span class=\"cp\">#[may_dangle]</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>could now actually be spelled</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&lt;'</span><span class=\"na\">erased</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>which feels <em>much</em> better and seems to make very clear what the semantics of drop checking and that are. In particular, that impl does not need <code>unsafe</code> anymore. Its completely ok to write as long as the check for \"don't drop/call methods for things that are <code>U&lt;'erased&gt;</code>\" continues to pass; in other words, if <code>T</code> contains a <code>&amp;'a U</code>, then the <code>drop</code> impl will not be allowed to dereference that on the basis of it now being a <code>&amp;'erased U</code></p>",
        "id": 263525553,
        "sender_full_name": "Jake",
        "timestamp": 1638495601
    },
    {
        "content": "<p>Yeah that is much better. I think I need to read more on may dangle before I can form a solid opinion on that</p>",
        "id": 263525797,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638495799
    },
    {
        "content": "<p>Yeah, this is definitely a bit of a side-issue, and I don't understand dropck well enough to actually be sure about this. I would be very interested in seeing what someone who does understand it thinks about this though</p>",
        "id": 263525895,
        "sender_full_name": "Jake",
        "timestamp": 1638495888
    },
    {
        "content": "<p>(I'll add some comments about this on the RFC once you've updated it as well, so that even if this isn't part of the proposal its at least documented somewhere more permanent than a zulip stream)</p>",
        "id": 263530009,
        "sender_full_name": "Jake",
        "timestamp": 1638499931
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263518231\">said</a>:</p>\n<blockquote>\n<p>there wouldn't be a question of covariance or of <code>'a : 'unsafe</code> : <code>'unsafe</code> would just be a special state / value for a lifetime parameter</p>\n</blockquote>\n<p>This hadn't really clicked at first, but this is actually a good point and pretty critical to the proposal; <code>T&lt;'a&gt;</code> can always turn into <code>T&lt;'erased&gt;</code> regardless of variance, and when the conversion back from <code>T&lt;'erased&gt;</code> to <code>T&lt;'b&gt;</code> happens, its on that conversion to check that the requirements for the variance are being obeyed.</p>",
        "id": 263531075,
        "sender_full_name": "Jake",
        "timestamp": 1638501096
    },
    {
        "content": "<p>I think the ability to use a 'a in place of a 'unsafe is critical because it’s the simplest way to construct one of these things. Especially if you have multiple lifetime parameters, only some of which have been erased</p>",
        "id": 263532730,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638503338
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263532730\">said</a>:</p>\n<blockquote>\n<p>I think the ability to use a 'a in place of a 'unsafe is critical because it’s the simplest way to construct one of these things. Especially if you have multiple lifetime parameters, only some of which have been erased</p>\n</blockquote>\n<p>What do you mean?</p>",
        "id": 263533059,
        "sender_full_name": "Jake",
        "timestamp": 1638503751
    },
    {
        "content": "<p>If I have a T&lt;'a, 'b&gt; and I want to store a T&lt;'unsafe, 'b&gt; I just store it. The fact that 'a: 'unsafe for all 'a makes it trivial to acquire them.</p>",
        "id": 263533203,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638503923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263533203\">said</a>:</p>\n<blockquote>\n<p>If I have a T&lt;'a, 'b&gt; and I want to store a T&lt;'unsafe, 'b&gt; I just store it. The fact that 'a: 'unsafe for all 'a makes it trivial to acquire them.</p>\n</blockquote>\n<p>Ah, yes. That being said, I actually sort of agree with <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> 's explanation that <code>'erased</code> isn't so much a lifetime as it is a special state to assign to a lifetime parameter. <code>'erased</code> doesn't represent a lifetime; instead it represents a \"missing\" lifetime, and you're free to \"remove\" the lifetime anytime you want</p>",
        "id": 263534224,
        "sender_full_name": "Jake",
        "timestamp": 1638505046
    },
    {
        "content": "<p>I think that probably comes down to a borrow checker implementation detail and we’re mostly on the same page. The main reason I think unsafe is a better lifetime choice is because it’s reserved</p>",
        "id": 263535216,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638506218
    },
    {
        "content": "<p>The complexity of adding this to the language seems extremely high. It's mentioned in the RFC that one could do all this by just using raw pointers, but that plan is rejected because \"that would be hard\". Except that the standard library is gaining more and more raw pointer support all the time, and just the other day a PR for a raw pointer iteration type was opened: <a href=\"https://github.com/rust-lang/rust/pull/91390\">https://github.com/rust-lang/rust/pull/91390</a></p>\n<p>So, I think that not using raw pointers should be much more strongly justified in the RFC text.</p>",
        "id": 263537811,
        "sender_full_name": "Lokathor",
        "timestamp": 1638509562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263537811\">said</a>:</p>\n<blockquote>\n<p>The complexity of adding this to the language seems extremely high. It's mentioned in the RFC that one could do all this by just using raw pointers, but that plan is rejected because \"that would be hard\". Except that the standard library is gaining more and more raw pointer support all the time, and just the other day a PR for a raw pointer iteration type was opened: <a href=\"https://github.com/rust-lang/rust/pull/91390\">https://github.com/rust-lang/rust/pull/91390</a></p>\n<p>So, I think that not using raw pointers should be much more strongly justified in the RFC text.</p>\n</blockquote>\n<p>The issue here isn't that raw pointers are annoying to deal with, but rather that if I'm using foreign types, I can't convert them to raw pointers without re-implementing all the associated functionality. Being able to iterate over raw pointers doesn't get me anything if the actual type I'm storing demands to have a reference. The <code>slice::Iter</code> example here is a bit of a bad one in that sense, since that is one we could actually replace easily with raw pointers, especially after that RFC. But for general foreign types, this is not possible</p>",
        "id": 263538009,
        "sender_full_name": "Jake",
        "timestamp": 1638509769
    },
    {
        "content": "<p>But swapping out <code>&amp;'a T</code> for <code>&amp;'unsafe T</code> is a lie in most cases, so you can't really use the code anyway</p>",
        "id": 263538060,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638509849
    },
    {
        "content": "<p>this operation of taking some code that was written for references and hoping that it works for pointers is abstraction-breaking, because the original code assumes some lifetime constraints that were upheld by the borrow checker when it was compiled, and you are passing in something that potentially violates those constraints, resulting in who-knows-what proof obligations that the upstream author has not approved</p>",
        "id": 263538234,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638510036
    },
    {
        "content": "<p>That means that internal non-breaking changes could cause UB in downstream code, which is bad for maintainers</p>",
        "id": 263538259,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638510098
    },
    {
        "content": "<p>So on the whole I think that having to have a separate raw-pointer API is actually the right answer here</p>",
        "id": 263538322,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638510152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538234\">said</a>:</p>\n<blockquote>\n<p>this operation of taking some code that was written for references and hoping that it works for pointers is abstraction-breaking, because the original code assumes some lifetime constraints that were upheld by the borrow checker when it was compiled, and you are passing in something that potentially violates those constraints, resulting in who-knows-what proof obligations that the upstream author has not approved</p>\n</blockquote>\n<p>With the version of the suggestion above, this would not be possible. You can't call any lifetime-generic code with an <code>'unsafe</code> lifetime; it's statically prevented and is a compiler error. However, you can <em>store</em> things with a <code>'unsafe</code> lifetime, and then later <code>unsafe</code>ly convert that lifetime to an actual <code>'a</code>, at which point you may once more use the value</p>",
        "id": 263538348,
        "sender_full_name": "Jake",
        "timestamp": 1638510214
    },
    {
        "content": "<p>so the issue is layout compatibility between the reference and pointer versions of the data structure?</p>",
        "id": 263538419,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638510287
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538419\">said</a>:</p>\n<blockquote>\n<p>so the issue is layout compatibility between the reference and pointer versions of the data structure?</p>\n</blockquote>\n<p>No, the issue is the non-existence of a pointer version. There's no way to name \"<code>T&lt;'a&gt;</code> but store a pointer where the reference goes.\" That's, under some interpretation, the point of this proposal as I see it</p>",
        "id": 263538533,
        "sender_full_name": "Jake",
        "timestamp": 1638510437
    },
    {
        "content": "<p>the solution to that problem is \"simple\" (requires no language changes): make a pointer version. I think that is <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> 's proposed alternative</p>",
        "id": 263538548,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638510480
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538548\">said</a>:</p>\n<blockquote>\n<p>the solution to that problem is \"simple\" (requires no language changes): make a pointer version. I think that is <span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> 's proposed alternative</p>\n</blockquote>\n<p>This is not at all \"simple\"; you're proposing that <em>every</em> type in the Rust ecosystem that internally stores a reference provide a pointer alternative instead</p>",
        "id": 263538624,
        "sender_full_name": "Jake",
        "timestamp": 1638510555
    },
    {
        "content": "<p>It has to be opt-in, yes. I don't think that doing it for every type makes sense</p>",
        "id": 263538643,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638510595
    },
    {
        "content": "<p>maybe I'm just not clear on the killer use cases here; <code>std::slice::Iter</code> isn't that complicated of an example</p>",
        "id": 263538714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638510683
    },
    {
        "content": "<p>Yeah the fact that the intent for this change is specifically so that users can fudge lifetime stuff in types <em>from other crates</em> makes me all kinds of nervous.</p>",
        "id": 263538903,
        "sender_full_name": "Lokathor",
        "timestamp": 1638510914
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538714\">said</a>:</p>\n<blockquote>\n<p>maybe I'm just not clear on the killer use cases here; <code>std::slice::Iter</code> isn't that complicated of an example</p>\n</blockquote>\n<p>Yeah, the RFC should pick a better one. Let me try and give here a more \"abstract\" example, maybe that will be helpful: Consider any type, in any crate you don't own (call it <code>T&lt;'a&gt;</code>) that stores internally a <code>&amp;'a mut U</code>. Now imagine that you want to use this to create a self-referencing data structure:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">MyType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">owned</span>: <span class=\"nc\">U</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">t</span>: <span class=\"nc\">T</span><span class=\"o\">&lt;?</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>You wish to initialize it so that the <code>&amp;'a mut U</code> reference in <code>T</code> refers to <code>owned</code>; of course, this means that you can't move <code>MyType</code>, but let that be your problem (many people have had uses for self-referencing data). The problem that we are looking to solve is what do you make the lifetime parameter on <code>T</code>. You have no named lifetime parameter in scope to put there, and adding it to <code>MyType</code> will make the whole thing positively useless, since one of its fields will <em>always</em> be borrowed for the entire duration of its existence. But if you make it <code>'static</code>, then you also require that <code>U: 'static</code>, and you may not want that either. There's no good way out.</p>\n<p>The important thing here is that there is no requirement on what <code>T</code> might reasonably be. Data structures would be a common, but by far not the only, possibility.</p>",
        "id": 263539284,
        "sender_full_name": "Jake",
        "timestamp": 1638511291
    },
    {
        "content": "<p>And switching to a pointer version is not possible without the crate defining <code>T</code> duplicating it to a new <code>TWithPointer</code> that has no lifetime parameter and has all its methods marked <code>unsafe</code></p>",
        "id": 263539362,
        "sender_full_name": "Jake",
        "timestamp": 1638511388
    },
    {
        "content": "<p><code>MyType</code> in your example has no lifetime arguments, so surely <code>U: 'static</code> anyway</p>",
        "id": 263539462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638511525
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263539462\">said</a>:</p>\n<blockquote>\n<p><code>MyType</code> in your example has no lifetime arguments, so surely <code>U: 'static</code> anyway</p>\n</blockquote>\n<p>Yeah, I've adjusted the example</p>",
        "id": 263539585,
        "sender_full_name": "Jake",
        "timestamp": 1638511684
    },
    {
        "content": "<p>if we're fudging lifetimes anyway, one way to do that is to have <code>MyType</code> take a <code>'a</code> parameter which satisfies <code>U: 'a</code>. This isn't the actual lifetime of the reference, so it can be instantiated to some top level thing, or <code>'static</code> if <code>U</code> turns out to be static</p>",
        "id": 263539714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638511858
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263539714\">said</a>:</p>\n<blockquote>\n<p>if we're fudging lifetimes anyway, one way to do that is to have <code>MyType</code> take a <code>'a</code> parameter which satisfies <code>U: 'a</code>. This isn't the actual lifetime of the reference, so it can be instantiated to some top level thing, or <code>'static</code> if <code>U</code> turns out to be static</p>\n</blockquote>\n<p>How do I actually instantiate this struct then? eg in</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">my_api</span><span class=\"p\">(</span><span class=\"n\">u</span>: <span class=\"nc\">U</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// here</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>In order to create such an <code>'a</code> (that gives that bound), I'd need to actually borrow <code>U</code> for <code>'a</code>, but thats not an option. Maybe there's a trick I'm missing here</p>",
        "id": 263540114,
        "sender_full_name": "Jake",
        "timestamp": 1638512390
    },
    {
        "content": "<p>Assuming that <code>U</code> is a concrete type there, you take <code>'a</code> to be <code>'static</code>, and to satisfy the requirements you construct a <code>T&lt;'a, U&gt;</code> (where <code>'a</code> is a function-local lifetime) and transmute it to a <code>T&lt;'static, U&gt;</code></p>",
        "id": 263540267,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638512551
    },
    {
        "content": "<p>that's what I meant by fudging lifetimes</p>",
        "id": 263540277,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638512577
    },
    {
        "content": "<p>This requires that U is 'static</p>",
        "id": 263540286,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638512603
    },
    {
        "content": "<p>Yes, I'm assuming that at the point of <code>my_api</code> you know what type <code>U</code> is and that it is <code>'static</code>. If not, you keep bubbling the constraint up</p>",
        "id": 263540306,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638512642
    },
    {
        "content": "<p>Agh, I left out the generic param again. Sorry, let me fix</p>",
        "id": 263540355,
        "sender_full_name": "Jake",
        "timestamp": 1638512659
    },
    {
        "content": "<p>so it would be <code>pub fn my_api&lt;'a, U&gt;(u: U) where U: 'a {}</code></p>",
        "id": 263540357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638512666
    },
    {
        "content": "<p>I just updated the rfc btw to reflect our conversations here</p>",
        "id": 263540370,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638512679
    },
    {
        "content": "<p>I'm not saying this is a great solution, but I'm pretty sure it works, and I have used things like it with self referential structs before</p>",
        "id": 263540395,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638512718
    },
    {
        "content": "<p>I have a use case in a self referential struct which is not possible in current rust</p>",
        "id": 263540414,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638512754
    },
    {
        "content": "<p>Give me a minute</p>",
        "id": 263540417,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638512760
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263540357\">said</a>:</p>\n<blockquote>\n<p>so it would be <code>pub fn my_api&lt;'a, U&gt;(u: U) where U: 'a {}</code></p>\n</blockquote>\n<p>That would be an exceptionally weird constraint to have in a public API.</p>",
        "id": 263540457,
        "sender_full_name": "Jake",
        "timestamp": 1638512766
    },
    {
        "content": "<p>well, it would be great if <code>'lifetime_of(U)</code> was a thing, but we have to make do</p>",
        "id": 263540472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638512803
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538903\">said</a>:</p>\n<blockquote>\n<p>Yeah the fact that the intent for this change is specifically so that users can fudge lifetime stuff in types <em>from other crates</em> makes me all kinds of nervous.</p>\n</blockquote>\n<p>Yeah, this was actually my initial reaction too. The thing that comforts me with the most recent version of this is that there is a hard rule of \"no lifetime-generic code may ever be instantiated with an <code>'unsafe</code> lifetime\". That should very categorically prevent any issues with this; I'm more worried about being able to detect local issues caused by the new lifetime</p>",
        "id": 263540595,
        "sender_full_name": "Jake",
        "timestamp": 1638512945
    },
    {
        "content": "<p>Actually my example is essentially what Jake just commented on. You can’t be generic over non 'static types and also not require a meaningless lifetime specifier at the same time</p>",
        "id": 263540598,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638512952
    },
    {
        "content": "<p>And be self referential</p>",
        "id": 263540654,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638513008
    },
    {
        "content": "<p>Actually that constraint is unnecessary, since rust can discharge it fine:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">u</span>: <span class=\"nc\">U</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">U</span>: <span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">u</span>: <span class=\"nc\">U</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 263540842,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638513243
    },
    {
        "content": "<p>In functions it can be dropped but The problem is storing it.</p>",
        "id": 263541169,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638513602
    },
    {
        "content": "<p>You can’t drop the lifetime param by wrapping the struct or some other technique</p>",
        "id": 263541218,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638513629
    },
    {
        "content": "<p>right, the idea here is to keep the lifetime parameter in the struct and only eliminate it from functions that don't use the struct</p>",
        "id": 263541629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1638514090
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263535216\">said</a>:</p>\n<blockquote>\n<p>I think that probably comes down to a borrow checker implementation detail and we’re mostly on the same page. The main reason I think unsafe is a better lifetime choice is because it’s reserved</p>\n</blockquote>\n<p>I'm not arguing so much about the name, I think there is a difference of interpretation. What I will try and do later tonight is do a full-writeup of the interpretation of this that I am thinking about, just to document it (and two explanations is always better than one)</p>",
        "id": 263541655,
        "sender_full_name": "Jake",
        "timestamp": 1638514140
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263541218\">said</a>:</p>\n<blockquote>\n<p>You can’t drop the lifetime param by wrapping the struct or some other technique</p>\n</blockquote>\n<p>Hmm, what if you indirect via GATs?</p>\n<p>Sketch of the idea:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TypeGen</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Type</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">IterGen</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TypeGen</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">IterGen</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Type</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">slice</span>::<span class=\"n\">Iter</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">FunkyHolder</span><span class=\"o\">&lt;</span><span class=\"n\">G</span>: <span class=\"nc\">TypeGen</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">unsafe_val</span>: <span class=\"nc\">ManuallyDrop</span><span class=\"o\">&lt;&lt;</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">TypeGen</span><span class=\"o\">&gt;</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">G</span>: <span class=\"nc\">TypeGen</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FunkyHolder</span><span class=\"o\">&lt;</span><span class=\"n\">G</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">real</span>: <span class=\"o\">&lt;</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">TypeGen</span><span class=\"o\">&gt;</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// 'static is a lie, but we only let unsafe callers look at it.</span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"bp\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">unsafe_val</span>: <span class=\"nc\">ManuallyDrop</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">real</span><span class=\"p\">))</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">get_with_unchecked_lifetime</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">&lt;</span><span class=\"n\">G</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">TypeGen</span><span class=\"o\">&gt;</span>::<span class=\"n\">Type</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"n\">ManuallyDrop</span>::<span class=\"n\">into_inner</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">unsafe_val</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>\n</code></pre></div>",
        "id": 263541939,
        "sender_full_name": "scottmcm",
        "timestamp": 1638514480
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> that does not compile  with an error that suggests adding \"consider adding a where clause: <code>where T: 'a</code>\" to the <code>impl TypeGen for IterGen</code></p>",
        "id": 263542383,
        "sender_full_name": "Jake",
        "timestamp": 1638514948
    },
    {
        "content": "<p>That would be solved by making <code>TypeGen</code> generic over <code>T</code>. All this is getting pretty close to:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263422592\">said</a>:</p>\n<blockquote>\n<ul>\n<li>To be more rigorous, imagine, in an HKT world: <code>Iter_&lt;MaybeLifetimedRef&lt;_&gt;, T&gt; { slice: MaybeLifetimedRef&lt;T&gt;, … }</code> then <code>Iter&lt;'lt, T&gt;</code> would be <code>Iter_&lt;&amp;'lt, T&gt;</code>, and and <code>Iter&lt;'unsafe, T&gt;</code> would be <code>Iter_&lt;ptr::NonNullAndAligned, T&gt;</code>.</li>\n</ul>\n</blockquote>\n<p>but for GAT being the implementation of the HKT semantics.</p>\n<hr>\n<p>Back to the original issue, if we were to be \"fudging lifetimes\", then what we'd be missing here would be a \"<code>'lifetime_of!</code>\" kind of operator. For the sake of the explanation, I'll imagine it written as <code>'T</code> for some type parameter <code>T</code> (although it could be shadowed by an explicit <code>bad_style</code> parameter <code>&lt;'T&gt;</code>, for the sake of retro-compat). The semantics would be those of the \"existential\" pattern <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> was talking about: <code>&lt;T&gt;</code> (and use <code>'T</code>) would be equivalent to <code>&lt;'T, T : 'T&gt;</code>, except for that <code>'T</code> swept under the rug, so that <code>&amp;'T T</code> always works. That way we could \"hide the existential genericity\" of the struct, which is the main ergonomics of self-referential stuff:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">U</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// vs.</span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;'</span><span class=\"na\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">U</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>That being said, this whole thing would be lying about lifetimes since the beginning, which is unsound as per Stacked Borrows model:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span>::<span class=\"n\">new_uninit</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">at_u</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">thing</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">().</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">().</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">offset_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"p\">)).</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">at_u</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">at_u</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">U</span> <span class=\"nc\">U</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">at_ut</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Fudging lifetimes</span>\n<span class=\"n\">thing</span><span class=\"p\">.</span><span class=\"n\">as_mut_ptr</span><span class=\"p\">().</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">().</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">offset_of</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"mi\">1</span><span class=\"p\">)).</span><span class=\"n\">cast</span>::<span class=\"o\">&lt;&amp;'</span><span class=\"na\">U</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">().</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">at_u</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"o\">&lt;</span><span class=\"n\">Pin</span><span class=\"o\">&lt;</span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;&gt;&gt;</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"nb\">Box</span>::<span class=\"n\">assume_init</span><span class=\"p\">(</span><span class=\"n\">thing</span><span class=\"p\">))</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The issue is that the moment a <code>Box&lt;Foo&lt;U&gt;&gt;</code> is constructed, it asserts lack of aliasing of the pointee <code>Foo&lt;U&gt;</code>, and of all of its constituents, thus invalidating the generated <code>at_u</code>, which is rendered unusable (lest we trigger UB —under the SB model—).</p>\n<p>Now, making <code>at_u</code> a raw pointer, either in an <em>ad-hoc</em>  fashion (using <code>ptr::NonNull&lt;U&gt;</code>),  or in the suggested more general approach here (using <code>&amp;unsafe U</code> (I'm sticking to no tick to avoid confusion)), would not solve the problem alone, but it would already help with the symmetrical situation (existence of a <code>at_u: &amp;[mut] U</code> asserting stuff about <code>U</code> which forbids us from ever touching <code>U</code>). Indeed, if you combine that with replacing the outer <code>Box</code> with an <a href=\"https://docs.rs/aliasable\"><code>::aliasable</code></a> one, you'd now finally achieve a sound self-referential type.</p>",
        "id": 263557634,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638526062
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263538903\">said</a>:</p>\n<blockquote>\n<p>Yeah the fact that the intent for this change is specifically so that users can fudge lifetime stuff in types <em>from other crates</em> makes me all kinds of nervous.</p>\n</blockquote>\n<p>Yes, this ought to be the main concern: fudging lifetimes in other types should not de done unless the type itself properly documented its safety invariants (or rather, lack thereof):</p>\n<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263417521\">said</a>:</p>\n<blockquote>\n<p>Maybe the RFC should thus mention that it <em>should</em> (as in recommended, not mandatory) only be used with types defined in the same crates, or types of dependencies <em>provided</em> they properly document their lifetime-related properties.</p>\n</blockquote>",
        "id": 263558271,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638526393
    },
    {
        "content": "<p>another approach, which would enable this with extreme unsafety in exchange for very minimal changes to the language is a const function like <code>core::mem::size_of</code> which is allowed to ignore generic parameters.</p>\n<p>here's a playground exploring the idea:<br>\n<a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=430355b2705e7d84e5ba23e16cf5aba8\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=430355b2705e7d84e5ba23e16cf5aba8</a></p>",
        "id": 263722025,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638640396
    },
    {
        "content": "<p>Iirc specialization allows types to have extra fields depending on parameters. So <code>Iter&lt;'static&gt;</code> could have a different size than <code>Iter&lt;'some_concrete_lifetime_that_is_not_static&gt;</code> and that approach falls apart.</p>",
        "id": 263723196,
        "sender_full_name": "The 8472",
        "timestamp": 1638641595
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md#interaction-with-lifetimes\">https://github.com/rust-lang/rfcs/blob/master/text/1210-impl-specialization.md#interaction-with-lifetimes</a></p>\n<p>according to the rfc this is explicitly not possible</p>",
        "id": 263724104,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638642495
    },
    {
        "content": "<p>Well, that might be a fault in the current implementation then. The layout can depend on a trait and the trait in turn can be selectively implemented for 'static. The rules say you must not do that, but you can. I thought the plan was to fix the unsafety that arises from that. But maybe it'll be fixed by detecting and forbidding it reliably.</p>",
        "id": 263724688,
        "sender_full_name": "The 8472",
        "timestamp": 1638643320
    },
    {
        "content": "<p>How do you add fields to something by specializing trait impls</p>",
        "id": 263724815,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638643447
    },
    {
        "content": "<p>I don’t understand how the memory layout can be effected by it at all</p>",
        "id": 263724828,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638643468
    },
    {
        "content": "<p>iter::Zip used to do that, let me find the PR that changed that</p>",
        "id": 263724871,
        "sender_full_name": "The 8472",
        "timestamp": 1638643500
    },
    {
        "content": "<p>here's the PR that introduced it. It's using an associated type as a struct member and the type varies based on specialization.</p>",
        "id": 263725082,
        "sender_full_name": "The 8472",
        "timestamp": 1638643746
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/33090/files\">https://github.com/rust-lang/rust/pull/33090/files</a></p>",
        "id": 263725084,
        "sender_full_name": "The 8472",
        "timestamp": 1638643750
    },
    {
        "content": "<p>It still doesn’t really make sense to me how something can specialize over 'static since those can be coerced into non 'static</p>",
        "id": 263725164,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638643846
    },
    {
        "content": "<p>Unless the type is invariant</p>",
        "id": 263725397,
        "sender_full_name": "The 8472",
        "timestamp": 1638644117
    },
    {
        "content": "<p>but yeah, that's basically the problem why specialization is an incomplete feature</p>",
        "id": 263725499,
        "sender_full_name": "The 8472",
        "timestamp": 1638644174
    },
    {
        "content": "<p>it seems like their stated intention is for that to be illegal, so shouldn’t that mean the transmute-into-bytes approach should be fine?</p>",
        "id": 263725553,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638644270
    },
    {
        "content": "<p>hrm, probably</p>",
        "id": 263725625,
        "sender_full_name": "The 8472",
        "timestamp": 1638644345
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263725553\">said</a>:</p>\n<blockquote>\n<p>it seems like their stated intention is for that to be illegal, so shouldn’t that mean the transmute-into-bytes approach should be fine?</p>\n</blockquote>\n<p>This approach is only ok if a <code>&amp;mut T</code> to <code>usize</code> transmute is not UB, and I believe the most recent state of things was that this probably <em>is</em> UB (cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> )</p>",
        "id": 263726197,
        "sender_full_name": "Jake",
        "timestamp": 1638644922
    },
    {
        "content": "<p>If you transmute back before doing anything with it where is it possible for UB to come in</p>",
        "id": 263726298,
        "sender_full_name": "Mason Boeman",
        "timestamp": 1638645017
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263726298\">said</a>:</p>\n<blockquote>\n<p>If you transmute back before doing anything with it where is it possible for UB to come in</p>\n</blockquote>\n<p>I believe the issue was that the original transmute is instantly UB, no matter what you end up doing after, for provenance reasons (in particular turning a pointer into an integer is not a no-op on the abstract machine)</p>",
        "id": 263726358,
        "sender_full_name": "Jake",
        "timestamp": 1638645123
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263725164\">said</a>:</p>\n<blockquote>\n<p>It still doesn’t really make sense to me how something can specialize over 'static since those can be coerced into non 'static</p>\n</blockquote>\n<p>That example is exactly why <code>feature(specialization)</code> is unsound, yes <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 263732570,
        "sender_full_name": "scottmcm",
        "timestamp": 1638653491
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"461427\">@Mason Boeman</span> I've thought about this quite a bit today and yesterday. In my opinion, there's an aspect of this that is way under-specified and probably a massive issue, and that is the implications of this for type checking. Thinking in terms of the type system for a second, its clear that <code>'unsafe</code> can't actually mean \"the shortest lifetime\" because that would be incredibly unsound for contra-variant lifetimes. Instead, it has to be some kind of non-lifetime that can be used in place of a lifetime, but isn't a lifetime at all. What does this mean for type checking though? Consider, for example</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Assoc</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">**</span><span class=\"bp\">self</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">v</span>: <span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span>::<span class=\"n\">Assoc</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">s</span>: <span class=\"nc\">S</span><span class=\"o\">&lt;'</span><span class=\"na\">unsafe</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"c1\">// what happens here?</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>How is the behavior of the type checker meant to change in the body of <code>f</code>? In the past, it would have been allowed to use <code>S&lt;'unsafe&gt;</code> being well-formed to conclude that <code>&lt;&amp;'unsafe i32 as A&gt;::Assoc</code> is well-formed, and hence <code>&amp;'unsafe i32: A</code>. But that's not the case! In other words, getting this kind of change through requires fundamentally changing the rules for type checking, at least around this <code>'unsafe</code> lifetime, and exactly how that is to work needs to be 1) a part of the RFC, and 2) designed with <em>extreme</em> care to ensure safety guarantees are upheld</p>",
        "id": 263751403,
        "sender_full_name": "Jake",
        "timestamp": 1638683194
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jake</span> I'd say that it should compile fail with <code>A is not implemented for &amp;unsafe i32</code></p>",
        "id": 263762109,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638701314
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> but when do you want that error? When naming <code>S&lt;'unsafe&gt;</code> as a type? That isn't really an option, since <code>S</code> can be a foreign type with private fields so now you can never use any <code>T&lt;'unsafe&gt;</code>. What's the alternative?</p>",
        "id": 263764041,
        "sender_full_name": "Jake",
        "timestamp": 1638704190
    },
    {
        "content": "<p>Indeed, there should be an opt-in way to allow for <code>'unsafe</code> substitution.<br>\nAnd even then, we have a problem: if <code>&amp;unsafe T</code> is a distinct type from <code>&amp;'a T</code> (which it should), then through type-assoc indirection <code>Foo&lt;unsafe&gt;</code> and <code>Foo&lt;'a&gt;</code> may not have the same layout, breaking the back-and-forth</p>",
        "id": 263764514,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638704992
    },
    {
        "content": "<p>Making unsafe opt-in on types is probably a non-starter for this idea, since the background is that we want to be able to erase the lifetime on arbitrary foreign types that don't necessarily care about <code>'unsafe</code></p>",
        "id": 263764788,
        "sender_full_name": "Jake",
        "timestamp": 1638705422
    },
    {
        "content": "<p>Also I don't think the layout thing is an actual problem. <code>&amp;'a T</code> and <code>&amp;'b T</code> are already different types, and <code>Foo&lt;'a&gt;</code> and <code>Foo&lt;'b&gt;</code> cannot have different layouts</p>",
        "id": 263764862,
        "sender_full_name": "Jake",
        "timestamp": 1638705546
    },
    {
        "content": "<p>To be clear, as far as I can tell, I don't think you can actually achieve any unsoundness with the example I posted above. Even if you manage to trick the compiler into believing what is not true, at the latest when you do impl matching when monomorphizing, you'll find no matching impl for <code>&amp;'unsafe i32: A</code> and ICE. The problem is just that I don't see how to write a correct type checker in the face of this</p>",
        "id": 263765074,
        "sender_full_name": "Jake",
        "timestamp": 1638705774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jake</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263764862\">said</a>:</p>\n<blockquote>\n<p>Also I don't think the layout thing is an actual problem. <code>&amp;'a T</code> and <code>&amp;'b T</code> are already different types, and <code>Foo&lt;'a&gt;</code> and <code>Foo&lt;'b&gt;</code> cannot have different layouts</p>\n</blockquote>\n<p>Because until now you couldn't talk of a non-<code>'static</code> lifetime without talking of all the lifetimes together, hence having coherence prevent the different layouts for <code>Foo&lt;'a&gt;</code> and <code>Foo&lt;'b&gt;</code>. But now <code>'unsafe</code> represents another distinct and nameable lifetime, and one which is not covered by <code>&lt;'a&gt;</code> genericity (we went over this the first time I mentioned dropping the tick; for this very reason btw):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">type</span> <span class=\"nc\">Assoc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">();</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"w\"> </span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"o\">&gt;</span>::<span class=\"n\">Assoc</span><span class=\"w\"> </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"c1\">// what is `Foo&lt;unsafe&gt;`?</span>\n</code></pre></div>\n<p>Either those two first impls don't overlap, and thus we can't guarantee same layout, or they do, but then <code>for&lt;'a&gt; fn(&amp;'a i32) -&gt; i32</code> ought to be callable with a <code>&amp;unsafe i32</code> parameter, which then leads to its own can of worms (outlives rule, <em>etc.</em>)</p>",
        "id": 263766335,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638707674
    },
    {
        "content": "<p>So two thoughts. It's 1) not absolutely necessary to allow <code>impl A for &amp;unsafe i32</code>, and 2) <code>impl A for &amp;unsafe i32</code> can mean <code>impl&lt;'a&gt; A for &amp;unsafe i32 + &amp;'a i32</code>. This is actually why I think the <code>'erased</code> name is more clear, because it makes this second thing more obvious</p>",
        "id": 263766582,
        "sender_full_name": "Jake",
        "timestamp": 1638708074
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"461427\">Mason Boeman</span> <a href=\"#narrow/stream/122651-general/topic/Unsafe.20Lifetime.20RFC/near/263726298\">said</a>:</p>\n<blockquote>\n<p>If you transmute back before doing anything with it where is it possible for UB to come in</p>\n</blockquote>\n<p>transmuting <code>0x03u8</code> to <code>bool</code> and back is UB (and <a href=\"https://www.ralfj.de/blog/2020/07/15/unused-data.html\">this is why</a>).<br>\ntransmuting a reference to a <code>usize</code> and back might be UB in a similar way, though the reasons are complicated...<br>\n<code>MaybeUninit&lt;u8/usize&gt;</code> would be more suited as a \"general type holding arbitrary data\".</p>",
        "id": 264169959,
        "sender_full_name": "RalfJ",
        "timestamp": 1638976872
    },
    {
        "content": "<p><code>MaybeUninit&lt;usize&gt;</code> isn't any more suitable than <code>usize</code> as a thing to transmute pointers to...it generates the exact same llvm ir:<br>\n<a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=907d437c45653ba2afb31a8e5cd698d5\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=907d437c45653ba2afb31a8e5cd698d5</a></p>",
        "id": 264201132,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638989057
    },
    {
        "content": "<p>Correction, it generates the exact same LLVM IR on this particular compiler today. UB is allowed to generate anything, including the code you intended. So generating the code you intended is not proof of defined behavior.</p>",
        "id": 264205416,
        "sender_full_name": "Eh2406",
        "timestamp": 1638990847
    },
    {
        "content": "<p>I was attempting to prove that it has undefined behavior...assuming that transmuting pointers to integers is undefined behavior.</p>",
        "id": 264206116,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1638991149
    },
    {
        "content": "<p>well that just means we have to change the LLVM IR generation if we chose this way to clarify our semantics.<br>\nLLVM is currently internally inconsistent, so until they resolved that problem there is not really a way to do correct translation.<br>\n(and they are still in the 'denial' stage as far as I can see from the discussions around the byte type, so first they need to be convinced that there is a problem before there is any hope of fixing it)</p>",
        "id": 264393926,
        "sender_full_name": "RalfJ",
        "timestamp": 1639101111
    }
]