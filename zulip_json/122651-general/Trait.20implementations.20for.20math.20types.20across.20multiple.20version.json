[
    {
        "content": "<p>Hello, I have a series of crates for computer graphics that are wrappers around C++ libraries. One pretty common thing to need to do is to pass 3D vectors/points and bounding boxes and slices thereof from Rust to C++ and vice versa, e.g.</p>\n<div class=\"codehilite\"><pre><span></span><code>impl Mesh {\n    pub fn set_points_attribute(&amp;mut self, points: &amp;[Vec3f32]) {\n        unsafe { sys::Mesh_set_points_attribute(self.0, points.as_ptr() as *const _ as *const sys::Vec3_t };\n    }\n}\n</code></pre></div>\n<p>Since I don't want to bake a particular math crate into the API, I want to be generic over the particular math crate used (e.g. cgmath, glam etc). Note that I don't care about the semantic properties of the math types, just their memory layout, since I'm only interested in making sure that if I pass a slice of points to C++ then those will indeed be an array of e.g. <code>len * 3 * f32</code> values. Note that this also means that mint is not suitable for this use case as <code>Into&lt;mint::Vector3&lt;f32&gt;&gt;</code> makes no promises about the memory layout of the implemting type.</p>\n<p>I thought I'd solved this with a crate that just defines a series of traits that promises the implementor is of the correct layout, e.g.: <a href=\"https://github.com/vfx-rs/imath-traits/blob/main/src/vec.rs\">https://github.com/vfx-rs/imath-traits/blob/main/src/vec.rs</a> - the dependent crates then just take an <code>impl Vec3&lt;f32&gt;</code> where they need a 3d vector or slice thereof and use features to enable the implementations for each math crate they want in imath-traits. Then users can just pass a slice of their favourite vector type and everything  just works transparently. e.g.</p>\n<div class=\"codehilite\"><pre><span></span><code>impl Mesh {\n    pub fn set_points_attribute&lt;V: imath_traits::Vec3&lt;f32&gt;&gt;(&amp;mut self, points: &amp;[V]) { /*... */ }\n}\n</code></pre></div>\n<div class=\"codehilite\"><pre><span></span><code>let points = vec![glam::Vec3::new(1.0, 2.0, 3.0), ... ];\nmesh.set_points_attribute(&amp;points);\n</code></pre></div>\n<p>This works perfectly, but only as long as the versions match. If imath-traits depends on glam 0.17 but a dependent crate specifies glam 0.18 for example, then the user is prevented with a cryptic error about 'Vec3&lt;f32&gt; is not implemented for glam::Vec3`, presumably because Rust is treating the types from different glam versions as unique types. This gets even more complicated if I have one crate that depends on another and both depend on imath-traits then the depdendencies for all need to be updated to match math crate versions, which is a massive PITA.</p>\n<p>So my question is, is there any way to work around this? Is there some way to have imath-traits apply its traits across all versions in the dependency tree for a crate? </p>\n<p>So far the other workarounds I've thought of:</p>\n<ol>\n<li>Copy-paste the implementation of imath-traits into each crate that needs it for the API, rather than depending on it. I guess this would work, but leads to a lot of code duplication and maintenance burden if we want to add more traits</li>\n<li>Make a PR to each math crate to add imath-traits imlementations there, similar to what mint does. This add maintenance burden to those crate maintainers, and is potentially quite unnattractive to have two features that do 'almost the same thing but not quite'. Although I could change the way imath-traits works to make it much more specifcally about memory layout, e.g.</li>\n</ol>\n<div class=\"codehilite\"><pre><span></span><code>pub trait VectorLayout {\n    type ComponentType;\n    const NUM_COMPONENTS: usize;\n}\n\nimpl VectorLayout for glam::Vec3 {\n    type ComponentType = f32;\n    const NUM_COMPONENTS: usize = 3;\n}\n</code></pre></div>\n<ol start=\"3\">\n<li>Just use mint in the API. This will work but does force the user to cast slices to their favourite math type with e.g. bytemuck. A little ugly but not the end of the world, and what I'm leaning towards currently.</li>\n</ol>",
        "id": 261554528,
        "sender_full_name": "Anders Langlands",
        "timestamp": 1637008068
    },
    {
        "content": "<p>Hmm, one alternative is to relax the version constraints on imath-traits so it can use either 0.17 or 0.18</p>",
        "id": 261555884,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637008806
    },
    {
        "content": "<p>I wouldn't use <code>*</code> since you don't know if the API will break in the future, but it shouldn't be super hard to add new versions one at a time as glam releases updates</p>",
        "id": 261555957,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1637008852
    },
    {
        "content": "<p>Thanks you're right that will work. As you say just have to keep on top of new versions. That becomes increasingly problematic the more crates we support though, but probably preferable to having it randomly break if the crate changes type names (even though I would assume that's very unlikely)</p>",
        "id": 261565576,
        "sender_full_name": "Anders Langlands",
        "timestamp": 1637013528
    },
    {
        "content": "<p>Yeah, the issue is that the dependency hierarchy is inverted, in your case: you don't see <code>serde</code> trying to implement its traits for all the possible implementors, it's the other way around! Since your request seems quite sensible, you could submit PRs suggesting that these upstream crates implement the trait you provided, or something analogous, such as <code>::bytemuck</code>'s <code>Pod</code>.</p>\n<hr>\n<p>Aside: your trait ought to be <code>unsafe</code> if you happen to rely on a property of the API not constrained by the type. For instance, your <code>.as_ptr()</code> method is unusable, in a generic context, in a sound manner, since anybody could come and implement <code>Vec3</code> as yielding a <code>ptr::null_mut()</code>. Either the trait needs to be <code>unsafe</code>, or you need to limit yourself to type-constrained invariants, such as the <code>.as_slice()</code> and <code>from_slice()</code> elements (you can then call C++ doing <code>.as_slice().as_ptr()</code>).</p>",
        "id": 261625005,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1637060705
    }
]