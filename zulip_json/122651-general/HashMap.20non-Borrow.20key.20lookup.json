[
    {
        "content": "<p>I think I found a way to allow looking up values in a <code>HashMap</code> with keys that can't be <code>Borrow</code>ed from the map's key type. It's a trait I'm calling <code>HashEq&lt;Rhs&gt;</code>, and an implementation of it means that the implementor and <code>Rhs</code> have comparable hash values (specifically, if <code>T: HashEq&lt;U&gt; + PartialEq&lt;U&gt;</code> and <code>t == u</code>, the hash of <code>t</code> should be the same as the hash of <code>u</code>).</p>\n<p>This can of course be done with the raw entry API, but this version has the advantages of being more type-safe (as only types implementing the <code>HashEq</code> trait can be used this way), possibly allowing implementing <code>PartialEq</code> on <code>HashMap</code>s/<code>HashSet</code>s with different key types as long as they are <code>HashEq</code> and <code>PartialEq</code>, and potentially allowing <code>Index</code>ing <code>HashMap</code>s with non-<code>Borrow</code> keys. </p>\n<p>I've written a small library for this at <a href=\"https://github.com/goose121/hash_eq/tree/no-hash-eq-method\">https://github.com/goose121/hash_eq/tree/no-hash-eq-method</a>, but would there be interest in an RFC for this being included in <code>std</code> so that the trait impls, standard-library functions, <code>HashSet</code> (as it doesn't support the raw entry API), and the rest of the ecosystem would be able to accept a wider variety of keys, or is the current interface considered \"good enough\" and this should remain its own library?</p>\n<p>It could also be made backwards compatible with the current <code>Borrow</code>-based interface by adding a blanket <code>impl</code> as follows (assuming the interface my library uses, where <code>Q: HashEq&lt;K&gt; + PartialEq&lt;K&gt;</code> is the new type constraint on hash table lookups):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span>: <span class=\"nc\">Borrow</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">HashEq</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 267393296,
        "sender_full_name": "Morgan Hager",
        "timestamp": 1641786618
    },
    {
        "content": "<p>It does have an unfortunate interaction with <code>Borrow</code>, however, in that you would presumably also want an impl like <code>impl&lt;T, B: Borrow&lt;T&gt;&gt; HashEq&lt;B&gt; for T {}</code> to allow lookups where <code>Q: Borrow&lt;K&gt;</code> (which is not allowed by the current implementation, but would ideally be possible), but that conflicts with the previously mentioned impl necessary for backwards compatibility. This could be worked around by just manually adding the reverse impl for every <code>Borrow</code> type, but that is somewhat less elegant than it could be.</p>",
        "id": 267393653,
        "sender_full_name": "Morgan Hager",
        "timestamp": 1641787126
    },
    {
        "content": "<p>That's similar to what <code>indexmap</code> uses:<br>\n<a href=\"https://docs.rs/indexmap/latest/indexmap/trait.Equivalent.html\">https://docs.rs/indexmap/latest/indexmap/trait.Equivalent.html</a></p>",
        "id": 267394999,
        "sender_full_name": "cuviper",
        "timestamp": 1641789185
    },
    {
        "content": "<p>Oh, that does seem quite similar; the main difference seems to be that this solution just uses the existing <code>PartialEq</code> implementation for comparisons, which would make the extension of <code>PartialEq</code> to <code>HashMap</code>/<code>HashSet</code>s with differing key types more intuitive, given that all other container types use <code>PartialEq</code> to compare their elements rather than a separate trait (and indeed, it seems that <code>indexmap</code> only supports <code>PartialEq</code> comparisons between maps with the same key type, which isn't as useful, although it beats <code>HashMap</code> by allowing comparisons between maps with different state and value types).<br>\nAlso, this kind of functionality seems kind of orthogonal to <code>indexmap</code>'s goals and seems like for the most part just a more general version of the current <code>HashMap</code> interface with no apparent drawbacks that would reduce user error by replacing one of the main uses of the rather low-level and unchecked raw entry API with the safer high-level <code>HashMap</code> APIs, at the cost of a minimal increase in complexity (i.e. the addition of one new marker trait).</p>",
        "id": 267396336,
        "sender_full_name": "Morgan Hager",
        "timestamp": 1641791053
    },
    {
        "content": "<p>Perhaps an RFC/patch for this could also include the expanded value and state types for the <code>PartialEq</code> implementation</p>",
        "id": 267396970,
        "sender_full_name": "Morgan Hager",
        "timestamp": 1641791918
    }
]