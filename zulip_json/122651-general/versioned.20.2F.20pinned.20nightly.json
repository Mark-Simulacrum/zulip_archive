[
    {
        "content": "<p>This is kind of a \"fork\" off <a href=\"#narrow/stream/122651-general/topic/News.3A.20Progress.20in.20Rust.20as.202nd.20language.20for.20the.20Linux.20kernel\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/News.3A.20Progress.20in.20Rust.20as.202nd.20language.20for.20the.20Linux.20kernel</a> since it mentioned a topic I've been thinking about for a while now: there is a big reluctance to people using <code>RUSTC_BOOTSTRAP=1</code>, and I'd say it's a pretty fair / legitimate feeling, for most use cases: if you want <code>nightly</code> / unstable features, then \"don't lie with a <code>stable</code> toolchain and commit to using <code>nightly</code>\" would be a way to put it, I guess (feel free to correct me here, I'm not trying to strawman or anything).</p>\n<p>That being said, there is currently a pattern for which, I've observed, <code>RUSTC_BOOTSTRAP=1</code> is a better fit than nightly. To quote other people:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"123856\">Vadim Petrochenkov</span> <a href=\"#narrow/stream/122651-general/topic/News.3A.20Progress.20in.20Rust.20as.202nd.20language.20for.20the.20Linux.20kernel/near/264107793\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/122651-general/topic/News.3A.20Progress.20in.20Rust.20as.202nd.20language.20for.20the.20Linux.20kernel/near/264101999\">said</a>:</p>\n<blockquote>\n<p>Version pinning</p>\n</blockquote>\n<p>+, stable is the best nightly</p>\n</blockquote>\n<p><a href=\"/user_uploads/4715/vyNTgoeSzJOV-k6nHLraaqpp/image.png\">image.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/vyNTgoeSzJOV-k6nHLraaqpp/image.png\" title=\"image.png\"><img src=\"/user_uploads/4715/vyNTgoeSzJOV-k6nHLraaqpp/image.png\"></a></div><p>That is, <strong>AFAIK</strong> (I'd love to be wrong here!), there is no <code>nightly-1.55.0</code>, and so on. In <code>git</code> parlance, one can operate off <code>stable</code>'s <code>HEAD</code>, <code>nightly</code>'s <code>HEAD</code>, or <code>stable</code>'s <em>named tags</em>. But one can't use \"named tags\" for the <code>nightly</code> branch!</p>\n<h3>Why have a versioned <code>nightly</code></h3>\n<p>And precisely because <code>nightly</code> features represent an unstable environment, it's <em>the</em> area that hints the most at using a \"controlled commit updates\" / controlled toolchain bumps approach! So whenever a production environment wants to use (some) nightly features, such as <code>generic_associated_types</code>, it's highly recommended that a <code>rust-toolchain</code> file be used to pin <code>nightly</code>, but due to the lack of \"named tags\", one can only pin with commits / precise dates.</p>\n<p>And this becomes problematic when dependencies, use \"version detection\" to enable the most up-to-date (<code>HEAD</code>) nightly features when it detects that the current toolchain is a <code>nightly</code> one:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Click to see a concrete example</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"go\">   Compiling proc-macro2 v1.0.33</span>\n<span class=\"go\">error[E0658]: use of unstable library feature 'proc_macro_is_available'</span>\n<span class=\"go\">  --&gt; /var/lib/buildkite-agent/.cargo/registry/src/github.com-1ecc6299db9ec823/proc-macro2-1.0.33/src/detection.rs:28:21</span>\n<span class=\"go\">   |</span>\n<span class=\"go\">28 |     let available = proc_macro::is_available();</span>\n<span class=\"go\">   |                     ^^^^^^^^^^^^^^^^^^^^^^^^</span>\n<span class=\"go\">   |</span>\n<span class=\"go\">   = note: see issue #71436 &lt;https://github.com/rust-lang/rust/issues/71436&gt; for more information</span>\n<span class=\"go\">   = help: add `#![feature(proc_macro_is_available)]` to the crate attributes to enable</span>\n</code></pre></div>\n<p>the heuristic for that dependency to enable such a feature or not is based off:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">version</span><span class=\"p\">.</span><span class=\"n\">minor</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"w\"> </span><span class=\"mi\">57</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"cargo:rustc-cfg=no_is_available\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><a href=\"https://github.com/dtolnay/proc-macro2/blob/bf7f11678ede77790b35ea833d8dd083d4539118/build.rs#L95-L97\">Link</a></li>\n</ul>\n<p>Note that I am not picking up on dependencies that do this, quite the opposite! I find this approach a very nice way to keep featuring a low MSRV, so kudos for that effort <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>\n<p>So now we can see how, if somebody were to have a <code>nightly</code> that happened to be pinned to a commit before <code>1.57.0</code>'s stabilization of <code>proc_macro_is_available</code>, they're kind of \"screwed\", now having to enforce pinned dependencies, which is painful, and dooming the dep tree to freeze (we all know how Cargo dep tree is not made to have upper-bounded deps / how a <code>cargo update --precise …</code> will eventually be unable to solve all the constraints) —aside: having <code>cargo install</code> not be <code>--locked</code> by default is quite a footgun in that regard—.</p>\n</div></div>\n<p>This makes sense: one can't expect \"version detection\" to figure out if the commit of a <code>nightly</code> is <code>&gt; …</code>; it doesn't really make sense for a branch / tag-less / <code>HEAD</code>-based approach to do that (although technically the nightlies have <em>date</em> labelling within <code>rustc -V</code>, so that technically could be another approach).</p>\n<p>Hence why a <strong>versioned nightly</strong> can be a useful thing to have.</p>\n<h3>How to achieve a versioned <code>nightly</code> as of today</h3>\n<p>The only way, AFAIK, is to use a versioned <code>stable</code> approach, and then use <code>RUSTC_BOOTSTRAP=1</code> to imbue it with nightly / experimental capabilities. Again, seeing this as \"stable\" is a misnomer:</p>\n<ul>\n<li><code>rust-toolchain</code></li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"mf\">1.57.0</span>\n</code></pre></div>\n<ul>\n<li><code>.cargo/config</code></li>\n</ul>\n<div class=\"codehilite\" data-code-language=\"TOML\"><pre><span></span><code><span class=\"k\">[env]</span>\n<span class=\"n\">RUSTC_BOOTSTRAP</span> <span class=\"o\">=</span> <span class=\"s\">\"1\"</span>\n</code></pre></div>\n<p>so as to achieve the semantics of:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">[</span><span class=\"n\">rust</span><span class=\"o\">-</span><span class=\"n\">toolchain</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"n\">channel</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"nightly-1.57.0\"</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So my question is: what do you people think of this pattern? Even though the \"means\" are hacky, the \"end\" (versioned nightly) is actually less hacky than a commit-pinned nightly! Shouldn't we thus agree this is a <em>legitimate</em> use of <code>RUSTC_BOOTSTRAP</code>?</p>\n<p>And now: if <code>RUSTC_BOOTSTRAP</code> is so frowned upon, shouldn't there then be a proper alternative / way to achieve <code>nightly</code> versioning?</p>",
        "id": 264145560,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638965230
    },
    {
        "content": "<p>To clarify nightly-1.57.0 is the same as stable-1.57.0 except configured as nightly? And not just the source of nightly at the moment beta-1.57.0 branches?</p>",
        "id": 264146232,
        "sender_full_name": "bjorn3",
        "timestamp": 1638965744
    },
    {
        "content": "<p>That's how I'd see it yes: dependencies would treat your toolchain as <code>stable-1.57.0</code> (which makes sense when we consider the motivating example), and you'd just happen to personally have access to some <code>nightly</code> features within your own layer. So, having a \"later <code>nightly</code>\" would be a bit weird / inconsistent, I think</p>",
        "id": 264146470,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1638965902
    },
    {
        "content": "<p>Isn't it up to those who want unstable features but not deal with the churn to take care of their own needs? Pin a specific commit/build date, store artifacts somewhere etc? I mean it's explicitly non-guaranteed, why offer more guarantees? That's kind of missing the point.</p>",
        "id": 264149512,
        "sender_full_name": "The 8472",
        "timestamp": 1638967658
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"330154\">The 8472</span> <a href=\"#narrow/stream/122651-general/topic/versioned.20.2F.20pinned.20nightly/near/264149512\">said</a>:</p>\n<blockquote>\n<p>Isn't it up to those who want unstable features but not deal with the churn to take care of their own needs? Pin a specific commit/build date, store artifacts somewhere etc? I mean it's explicitly non-guaranteed, why offer more guarantees? That's kind of missing the point.</p>\n</blockquote>\n<p>I would agree with this, but I'm also inclided to agree with making not using RUSTC_BOOTSTRAP easier. If this idea of pinned nightlies would do that, I think it's at least a good idea to consider. Personally, I'd like to see RUSTC_BOOTSTRAP die as early as possible outside of rustc itself (in the rust compiler I'm working on, lccc, I have plans to explicitly error if RUSTC_BOOTSTRAP is set to anything other than an empty string).</p>",
        "id": 264152269,
        "sender_full_name": "Connor Horman",
        "timestamp": 1638969162
    },
    {
        "content": "<p>This is <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span>'s suggestion of having two compilers built from the same commit (one stable and one allowing unstable features) and letting distros choose which they want to package.</p>\n<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> I think it would be a good match for your use case, but I don't know that it would help <span class=\"user-mention\" data-user-id=\"303710\">@Gary Guo</span> in the Linux kernel, because it requires the distro to package a compiler named \"nightly\". I don't know how packaging works really - maybe this isn't a big deal? The main difference is that it's closer to the llvm-11/llvm-12 situation, distros can't assume they can upgrade the compiler version without upgrading the packages depending on it.</p>",
        "id": 264161767,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1638973453
    },
    {
        "content": "<p>I could built a <code>rust-nightly</code> package from stable sources, and it would be fairly trivial if that was synced with the normal <code>rust</code> package, as I could just use that in tandem for bootstrap. But specific version pinning would create a big hassle between what the kernel wants vs. the rest of the distro.</p>",
        "id": 264200244,
        "sender_full_name": "cuviper",
        "timestamp": 1638988670
    },
    {
        "content": "<p>IOW, that doesn't really solve the problem versus using <code>RUSTC_BOOTSTRAP</code></p>",
        "id": 264200436,
        "sender_full_name": "cuviper",
        "timestamp": 1638988747
    },
    {
        "content": "<p>But you have to stick to a specific, tested version anyway because upgrading stable rustc doesn't break regular crates, but it does break crates using unstable code.</p>",
        "id": 264203033,
        "sender_full_name": "The 8472",
        "timestamp": 1638989887
    },
    {
        "content": "<p>So what is the benefit of using a stable version unstably?</p>",
        "id": 264203412,
        "sender_full_name": "The 8472",
        "timestamp": 1638990018
    },
    {
        "content": "<p>Less bugs most of the time.</p>",
        "id": 264203603,
        "sender_full_name": "bjorn3",
        "timestamp": 1638990087
    },
    {
        "content": "<blockquote>\n<p>but it does break crates using unstable code.</p>\n</blockquote>\n<p>in the distro, I'd mark it <code>CLOSED NOTABUG</code></p>",
        "id": 264203741,
        "sender_full_name": "cuviper",
        "timestamp": 1638990127
    },
    {
        "content": "<p>circling back, the kernel folks were citing distro use as a reason for pinning stable + <code>RUSTC_BOOTSTRAP</code> rather than pinning nightly. I'm arguing that this is not sufficient.</p>",
        "id": 264203997,
        "sender_full_name": "cuviper",
        "timestamp": 1638990247
    }
]