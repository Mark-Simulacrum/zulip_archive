[
    {
        "content": "<p>I have made some progress towards implementing enum variant types (<a href=\"https://github.com/rust-lang/rfcs/pull/2593\">https://github.com/rust-lang/rfcs/pull/2593</a>), but before I continue I was wondering what the best path forward would be?</p>\n<p>My initial plan was to get it a bit further along and clean up the branch, but I saw<br>\nthe RFC PR was closed. Want to make sure I'm not doing anything that won't be accepted or is based on outdated assumptions.</p>",
        "id": 256334568,
        "sender_full_name": "zhamlin",
        "timestamp": 1633476203
    },
    {
        "content": "<p>It was closed as \"postpone\", not \"close\".</p>",
        "id": 256371045,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633506234
    },
    {
        "content": "<p>I don't think folks are opposed in principle.</p>",
        "id": 256371104,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633506249
    },
    {
        "content": "<p>I do think we would need a revived proposal, and I don't think you should do too much work before getting a design approval.</p>",
        "id": 256371152,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633506278
    },
    {
        "content": "<p>Where is the place to start a revised proposal?<br>\nI'm not sure I'd have much to add as I'm still fairly new to rust, but would love to help get things moving along.</p>",
        "id": 256412218,
        "sender_full_name": "zhamlin",
        "timestamp": 1633527448
    },
    {
        "content": "<p>So, new efforts similar to this should probably use an MCP, but in this case with an RFC already written, I think it would work to just pick that up and update it based on the thread.</p>",
        "id": 256425722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633532434
    },
    {
        "content": "<p>After looking over the RFC and the github thread I don't think I have anything to add or change really. The implementation I have is roughly aligned with the RFC.</p>\n<p>The biggest question I have is what the next step is?<br>\nIs there more discussion needed, or does there need to be a working prototype first, etc?</p>",
        "id": 256489473,
        "sender_full_name": "zhamlin",
        "timestamp": 1633556543
    },
    {
        "content": "<p>Btw I'm actually super excited for this feature. I can't guarantee I'll be tons of help, but feel free to ping me at any point.</p>",
        "id": 256492590,
        "sender_full_name": "Jack Huey",
        "timestamp": 1633558226
    },
    {
        "content": "<p>Since this is kind of both a language and compiler heavy change, it's probably good to file both a <a href=\"https://github.com/rust-lang/lang-team/issues/new?assignees=&amp;labels=major-change%2C+T-lang&amp;template=initiative_proposal.md&amp;title=%28My+initiative+proposal%29\">lang team initiative proposal</a> and a <a href=\"https://github.com/rust-lang/compiler-team/issues/new?assignees=&amp;labels=major-change%2C+T-compiler&amp;template=major_change.md&amp;title=%28My+major+change+proposal%29\">compiler MCP</a>. The initiative will probably be more about what the feature is, why it's important, what ergonomic issues it solves. This will probably be pretty close to the RFC.  The MCP will probably be more of the technical \"how is this implemented\". In either case, I don't think there would be anything wrong with opening a draft PR to get feedback (but certainly not required).</p>",
        "id": 256493102,
        "sender_full_name": "Jack Huey",
        "timestamp": 1633558496
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400323\">@zhamlin</span> for your implementation, what would something like this (likely not-exactly-correct) code report?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Alpha</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">One</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1024</span><span class=\"p\">]),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Two</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nc\">Alpha</span>::<span class=\"n\">Two</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of_val</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 256792818,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1633721269
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Enum.20Variant.20Types/near/256792818\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"400323\">zhamlin</span> for your implementation, what would something like this (likely not-exactly-correct) code report?</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Alpha</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">One</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1024</span><span class=\"p\">]),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Two</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"nc\">Alpha</span>::<span class=\"n\">Two</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of_val</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">a</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>1025</p>",
        "id": 256832066,
        "sender_full_name": "zhamlin",
        "timestamp": 1633747003
    },
    {
        "content": "<p>Gotcha. That means it’s not really a solution for the cases that I hoped to use it in. Thanks!</p>",
        "id": 256862320,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1633778282
    },
    {
        "content": "<p>Although it's likely that <code>Alpha::Two</code> could become a ZST in the future, once the core feature works.</p>",
        "id": 256890745,
        "sender_full_name": "Noah Lev",
        "timestamp": 1633805659
    },
    {
        "content": "<p>I'm torn on this. It definitely saves space if <code>Alpha::Two</code> is a ZST, but that will mean that <code>Box&lt;Alpha::Two&gt;</code> cannot be converted to <code>Box&lt;Alpha&gt;</code>.</p>",
        "id": 256894265,
        "sender_full_name": "Gary Guo",
        "timestamp": 1633808978
    },
    {
        "content": "<p>We probably don't want a separate variance rules for variant type subtyping. If we use existing rules then the fact that <code>Alpha::Two &lt;: Alpha</code> and that <code>Box&lt;T&gt;</code> is covariant over <code>T</code> indicates that <code>Box&lt;Alpha::Two&gt;</code> to <code>Box&lt;Alpha&gt;</code> conversion needs to work.</p>",
        "id": 256894651,
        "sender_full_name": "Gary Guo",
        "timestamp": 1633809358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303710\">Gary Guo</span> <a href=\"#narrow/stream/122651-general/topic/Enum.20Variant.20Types/near/256894265\">said</a>:</p>\n<blockquote>\n<p>I'm torn on this. It definitely saves space if <code>Alpha::Two</code> is a ZST, but that will mean that <code>Box&lt;Alpha::Two&gt;</code> cannot be converted to <code>Box&lt;Alpha&gt;</code>.</p>\n</blockquote>\n<p>Hmm, that's a good point.</p>",
        "id": 256894924,
        "sender_full_name": "Noah Lev",
        "timestamp": 1633809611
    },
    {
        "content": "<p>I think it'd be alright if that conversion wasn't trivial.</p>",
        "id": 257027250,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633939278
    },
    {
        "content": "<p>I like the idea of not using more memory than the variant needs.</p>",
        "id": 257027271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633939290
    },
    {
        "content": "<p>That would mean you can pull out a small variant of a large enum and pass it around more cheaply.</p>",
        "id": 257027323,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633939317
    },
    {
        "content": "<p>Perhaps we could supply a From?</p>",
        "id": 257027449,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1633939376
    },
    {
        "content": "<p>having the conversion between <code>Enum::Variant</code> and <code>Enum</code> be trivial seems extremely important if we want to allow turning <code>&amp;Enum::Variant</code> to <code>&amp;Enum</code></p>",
        "id": 257027956,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1633939661
    },
    {
        "content": "<p>given that you could already accomplish \"make each of these variants be structs\" with a proc macro it seems more useful as a langauge feature if \"enum variant types\" is more like a limited form of refinement typing (i.e. <code>Enum::Variant</code> as a type being sugar for <code>Enum is Enum::Variant(..)</code>)</p>",
        "id": 257028336,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1633939899
    },
    {
        "content": "<p>I think this discussion needs to also touch on the “enums where you can’t take a reference to the internals” idea that pops up sometimes. I think they are highly related.</p>",
        "id": 257054004,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1633953872
    },
    {
        "content": "<p>Is there any links to prior discussion about that? I've not come across it before</p>",
        "id": 257054758,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1633954261
    },
    {
        "content": "<p>There <em>are</em> links, but I’m on mobile and can’t find them quickly 😅</p>",
        "id": 257055159,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1633954480
    },
    {
        "content": "<blockquote>\n<p>if we want to allow turning <code>&amp;Enum::Variant</code> to <code>&amp;Enum</code></p>\n</blockquote>\n<p>It basically allows people to opt out of that, and of references to any fields of an enum. It’s similar to <code>repr(packed)</code>. It would allow more aggressive usage of niches. </p>\n<p>I’m sure there are downsides to it that I’m unaware of.</p>",
        "id": 257056766,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1633955304
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/122651-general/topic/Enum.20Variant.20Types/near/257054758\">said</a>:</p>\n<blockquote>\n<p>Is there any links to prior discussion about that? I've not come across it before</p>\n</blockquote>\n<p>Here's one I remember from a few months ago: <a href=\"https://internals.rust-lang.org/t/towards-even-smaller-structs/14686/3?u=scottmcm\">https://internals.rust-lang.org/t/towards-even-smaller-structs/14686/3?u=scottmcm</a></p>\n<p>I'd love to see someone work on this.  There's a ton of things that people expect to get optimized but that can't without this.  And for <code>Copy</code> fields the downsides are pretty slim.</p>\n<p>One problem that jumps out to me: for fields that aren't <code>Copy</code>, how do you <code>mem::replace</code> them to get a field out?</p>",
        "id": 257796231,
        "sender_full_name": "scottmcm",
        "timestamp": 1634354523
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/122651-general/topic/Enum.20Variant.20Types/near/257056766\">said</a>:</p>\n<blockquote>\n<p>It basically allows people to opt out of that, and of references to any fields of an enum. It’s similar to <code>repr(packed)</code>. It would allow more aggressive usage of niches. </p>\n</blockquote>\n<p>Is this what you've talked about: <a href=\"https://github.com/rust-lang/rfcs/issues/3166\">https://github.com/rust-lang/rfcs/issues/3166</a>?</p>",
        "id": 258818032,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1634987731
    },
    {
        "content": "<p>From the text of the <a href=\"https://github.com/rust-lang/lang-team/issues/122\">proposal</a>:</p>\n<blockquote>\n<p>Variant types, unlike most user-defined types are subject to the following restriction:</p>\n<ul>\n<li>Variant types may not have inherent impls, or implemented traits. That means <code>impl Enum::Variant</code><br>\nand <code>impl Trait for Enum::Variant</code> are forbidden. This dissuades inclinations to implement<br>\nabstraction using behaviour-switching on enums (for example, by simulating inheritance-based<br>\nsubtyping, with the enum type as the parent and each variant as children), rather than using traits<br>\nas is natural in Rust.</li>\n</ul>\n</blockquote>\n<p>This, on its own, doesn't prohibit \"implementing abstraction using behaviour-switching on enums\" because you can use <code>Unrelated: Trait&lt;T&gt;</code> bounds:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">EnumVariantName</span><span class=\"o\">&lt;</span><span class=\"n\">This</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">NAME</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">enum</span> <span class=\"nc\">Either</span><span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Left</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Right</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">EnumVariantName</span><span class=\"o\">&lt;</span><span class=\"n\">Either</span>::<span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span>::<span class=\"n\">Left</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">NAME</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"left\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">EnumVariantName</span><span class=\"o\">&lt;</span><span class=\"n\">Either</span>::<span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span>::<span class=\"n\">Right</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">NAME</span>: <span class=\"kp\">&amp;</span><span class=\"kt\">str</span> <span class=\"o\">=</span><span class=\"w\"> </span><span class=\"s\">\"right\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">variant_name</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">static</span> <span class=\"kt\">str</span>\n<span class=\"nc\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">()</span>: <span class=\"nc\">EnumVariantName</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">EnumVariantName</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span>::<span class=\"n\">NAME</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 258818454,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1634988381
    },
    {
        "content": "<p>Another question about this restriction is whatever the traits implemented for \"outer type\" are also implemented for the \"inner types\"?</p>\n<p>This is especially interesting, considering some build-in traits:</p>\n<h1><code>Copy</code></h1>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(Copy, Clone)]</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">AB</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">AB</span>::<span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">AB</span>::<span class=\"n\">A</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Q0: does this work?</span>\n<span class=\"c1\">// Q2: what type is a2? AB::A or AB?</span>\n<span class=\"c1\">// Q3: what about a.clone()?</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a2</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">*&amp;</span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<h1><code>Send</code>/<code>Sync</code></h1>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Hmm</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Zst</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Shared</span><span class=\"p\">(</span><span class=\"n\">MutexGuard</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"c1\">// !Send + Sync</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Q4: Is this !Send + !Sync (no traits), !Send + Sync (inherited) or Send + Sync (ZST default)</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">zst</span>: <span class=\"nc\">Hmm</span>::<span class=\"n\">Zst</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Hmm</span>::<span class=\"n\">Zst</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<h1><code>Drop</code></h1>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Defer</span><span class=\"o\">&lt;</span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">D</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">E</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">F</span>: <span class=\"nb\">FnOnce</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Defer</span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">drop</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"Running deferred function\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">Defer</span>::<span class=\"n\">D</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">mem</span>::<span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Defer</span>::<span class=\"n\">E</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Q5: does this coerce Defer::E -&gt; Defer and run Defer::drop?</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Defer</span>::<span class=\"o\">&lt;</span><span class=\"k\">fn</span><span class=\"p\">()</span><span class=\"o\">&gt;</span>::<span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Defer</span>::<span class=\"n\">E</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 258819215,
        "sender_full_name": "Waffle Lapkin",
        "timestamp": 1634989802
    }
]