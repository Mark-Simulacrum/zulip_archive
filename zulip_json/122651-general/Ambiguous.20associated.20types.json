[
    {
        "content": "<p>Hi everyone I have been investigating some test cases around qualified paths and this one has me a little confused: <a href=\"https://github.com/rust-lang/rust/blob/master/src/test/ui/qualified/qualified-path-params-2.rs\">https://github.com/rust-lang/rust/blob/master/src/test/ui/qualified/qualified-path-params-2.rs</a></p>\n<p>The associated path &lt;S as Tr&gt;::A on its own will resolve to unit-struct S so when the final segment of ::f&lt;u8&gt; i would have assumed this would have resolved to the type of the impl function f substituted with u8. I don't see why this ambiguous.</p>",
        "id": 250958178,
        "sender_full_name": "Philip Herron",
        "timestamp": 1630082146
    },
    {
        "content": "<p>First of all, given <code>impl S { fn f&lt;T&gt;… }</code>, <code>S::f::&lt;u8&gt;</code> does not refer to a type, but to a value, that of the function <code>f</code> instantiated with <code>u8</code>. While it could also be used to refer to the (singleton) type of that value, it hasn't done that to begin with, and it would thus be a breaking change if it did (maybe through an edition boundary?).</p>\n<p>Then, we can't write <code>impl S { type Assoc; }</code> in stable Rust, we currently need the unstable <code>inherent_associated_types</code> feature. But when we do use that, even something as simple as <code>S::Assoc</code> does not work. Mainly, <strong>to even <em>mention</em> an associated type in Rust, a <code>as Trait</code> disambiguator is needed</strong> (which thus makes <code>inherent_associated_types</code> quite useless, I'd say).</p>\n<p>And so that is mainly the error you see: a path such as <code>S::…</code> is not <em>semantically</em> allowed to refer to a type. The reason for this appears to be technical, see <a href=\"https://github.com/rust-lang/rust/issues/38078#issuecomment-268284794\">this comment</a> and the surrounding discussion for more context <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 251210283,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1630319654
    },
    {
        "content": "<p>So overall the QualifiedPathInType should only ever be able to refer to associated types?</p>",
        "id": 251210602,
        "sender_full_name": "Philip Herron",
        "timestamp": 1630319891
    },
    {
        "content": "<p>Regarding the:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>QualifiedPathInType :\n   QualifiedPathType (:: TypePathSegment)+\n</code></pre></div>\n<p>I'd say that the <code>::TypePathSegment</code> part cannot, in practice, occur more than once, yes. Maybe once <code>inherent_associated_types</code> is fully implemented it will be able to work?</p>",
        "id": 251211754,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1630320710
    },
    {
        "content": "<p>ah ok thats what i was looking for, I have been trying to find examples with more than 1 segment for testing. another thing i just wrote a test like:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn foo() {}\n\ntype a = foo;\n</code></pre></div>\n<p>which fails because foo is not a type but a function. I was assuming type declarations like this take the type of the function. So overall maybe multiple segments will rely on inherent_associated_types like you mention. I think from the grammar allowing multiple segments makes this confusing for me but this helps. thanks.</p>",
        "id": 251212077,
        "sender_full_name": "Philip Herron",
        "timestamp": 1630320949
    },
    {
        "content": "<blockquote>\n<p>which thus makes inherent_associated_types quite useless, I'd say</p>\n</blockquote>\n<p>Oh hey, someone's talking about my feature!</p>\n<p>Yup, when I worked on the feature I wanted to go the entire way and be able to get an associated type without the <code>as Trait</code> syntax, but I got stalled, and I haven't gotten back to it since.</p>",
        "id": 251412381,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1630426441
    },
    {
        "content": "<p>From what I remember, the main problem (aside from my lack of familiarity with the compiler) was that the machinery for processing qualified paths is split in two (one for getting associated functions / constants and one for getting associated type), and the one that handles associated type is built in a way that fundamentally assumes that the left side of a qualified path is either a generic parameter or a disambiguated path. (Again, saying this from memory, I don't remember the code that well)</p>",
        "id": 251413104,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1630426702
    },
    {
        "content": "<p>I remember thinking that the code needed a full refactor to handle associated type resolution in a recursive way, and I kinda gave up at that point.</p>",
        "id": 251413223,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1630426744
    },
    {
        "content": "<p>Thanks for your reply, I've been a bit stumped with this in regards to my work on gccrs. But this helps a lot.</p>",
        "id": 251551840,
        "sender_full_name": "Philip Herron",
        "timestamp": 1630500662
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/122651-general/topic/Ambiguous.20associated.20types/near/251210283\">said</a>:</p>\n<blockquote>\n<p>And so that is mainly the error you see: a path such as <code>S::…</code> is not <em>semantically</em> allowed to refer to a type. The reason for this appears to be technical, see <a href=\"https://github.com/rust-lang/rust/issues/38078#issuecomment-268284794\">this comment</a> and the surrounding discussion for more context <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>\n</blockquote>\n<p>I'm not super convinced by this. I think it's reasonable to ask <code>resolve</code> to give a first \"associated item or variant\" lookup or something. <br>\nIf it's resolved without ambiguity, an error should not be emitted to the user.</p>\n<p>This kind of resolution is easy victim to upstream associated item changes. However for ergonomics it might be worth it?</p>",
        "id": 252762158,
        "sender_full_name": "Charles Lew",
        "timestamp": 1631268453
    }
]