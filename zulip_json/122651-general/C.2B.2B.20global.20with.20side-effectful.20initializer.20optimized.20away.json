[
    {
        "content": "<p>I'm linking to some generated C++ code that uses the initializer of a never-accessed global variable to perform some setup (in this case, register something in a global map). However, sometimes the linker optimizes the global variable away,  and the initialization never occurs.</p>\n<p>I'm not sure whether this is a bug; this pattern seems sketchy at best. I'm more interested in how to work around it. Currently, I'm emitting a <code>-uMY_GLOBAL_SYMBOL</code> flag to the linker in <code>build.rs</code> (using Cargo's <code>-Zrustc-link-arg</code>. However, I want to use this crate as a library, and linker flags emitted this way don't propagate to parent crates. </p>\n<p>What would you do here?</p>",
        "id": 254584184,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632422671
    },
    {
        "content": "<p><code>#[used]</code> doesn't work with <code>extern static</code>s, btw.</p>",
        "id": 254584536,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632422828
    },
    {
        "content": "<p>Maybe the best choice is to modify the generated C++ to add <code>__atttribute__((used))</code></p>",
        "id": 254584875,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632422979
    },
    {
        "content": "<p>Some C++ implementations only run the initializers for globals on the first access, rather than at startup.</p>",
        "id": 254585707,
        "sender_full_name": "nagisa",
        "timestamp": 1632423319
    },
    {
        "content": "<p>could it be that?</p>",
        "id": 254585713,
        "sender_full_name": "nagisa",
        "timestamp": 1632423323
    },
    {
        "content": "<p>I in the past approached this by calling a function in rust that simply accessed the C++ global (the function itself was defined on the C++ side)</p>",
        "id": 254586113,
        "sender_full_name": "nagisa",
        "timestamp": 1632423429
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254586113\">said</a>:</p>\n<blockquote>\n<p>I in the past approached this by calling a function in rust that simply accessed the C++ global (the function itself was defined on the C++ side)</p>\n</blockquote>\n<p>I'll give that a try. I have a set of C++ shims for CXX bindings anyway, so that's pretty simple.</p>",
        "id": 254589042,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632424522
    },
    {
        "content": "<p>Note: That's called deffered initialization, and is only permitted until at the latest, the first statement that odr-uses anything in the same translation unit. You could also solve it by placing a function in the source file that does nothing, but is called by the rust code.</p>",
        "id": 254589083,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632424546
    },
    {
        "content": "<p>(Alternatively, you can avoid the headache that is C++ global variable dynamic initialization, and place the side-effect inducing global inside a function as a function-local static)</p>",
        "id": 254589179,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632424580
    },
    {
        "content": "<p>I think something similar happened to the <code>inventory</code> crate <a href=\"https://github.com/dtolnay/inventory/issues/32\">https://github.com/dtolnay/inventory/issues/32</a></p>",
        "id": 254592153,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1632425772
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254589083\">said</a>:</p>\n<blockquote>\n<p>Note: That's called deffered initialization, and is only permitted until at the latest, the first statement that odr-uses anything in the same translation unit. You could also solve it by placing a function in the source file that does nothing, but is called by the rust code.</p>\n</blockquote>\n<p>The function doesn't even have to access the global?</p>",
        "id": 254592800,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632426038
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254589179\">said</a>:</p>\n<blockquote>\n<p>(Alternatively, you can avoid the headache that is C++ global variable dynamic initialization, and place the side-effect inducing global inside a function as a function-local static)</p>\n</blockquote>\n<p>function-local statics aren't eligible for deferred initialization then?</p>",
        "id": 254592881,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632426078
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254586113\">said</a>:</p>\n<blockquote>\n<p>I in the past approached this by calling a function in rust that simply accessed the C++ global (the function itself was defined on the C++ side)</p>\n</blockquote>\n<p>This works, although I ended up just taking its address on the rust-side since the global in question is <code>extern \"C\"</code>. It feels a bit brittle <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 254593078,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632426158
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"338379\">Giacomo Stevanato</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254592153\">said</a>:</p>\n<blockquote>\n<p>I think something similar happened to the <code>inventory</code> crate <a href=\"https://github.com/dtolnay/inventory/issues/32\">https://github.com/dtolnay/inventory/issues/32</a></p>\n</blockquote>\n<p>Rust was only missing life-before-main before it could become truly great.</p>",
        "id": 254593366,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632426268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254592800\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254589083\">said</a>:</p>\n<blockquote>\n<p>Note: That's called deffered initialization, and is only permitted until at the latest, the first statement that odr-uses anything in the same translation unit. You could also solve it by placing a function in the source file that does nothing, but is called by the rust code.</p>\n</blockquote>\n<p>The function doesn't even have to access the global?</p>\n</blockquote>\n<p>Nope. Just has to be in the same translation unit</p>",
        "id": 254597310,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632428019
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254592881\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254589179\">said</a>:</p>\n<blockquote>\n<p>(Alternatively, you can avoid the headache that is C++ global variable dynamic initialization, and place the side-effect inducing global inside a function as a function-local static)</p>\n</blockquote>\n<p>function-local statics aren't eligible for deferred initialization then?</p>\n</blockquote>\n<p>So, function-local statics have a different form of initialization - the dynamic initialization occurs the first time you pass over the initializer while executing the function, like a once-cell (yes, it's thread safe in C++11 - if multiple threads enter the initialization, all block and only one of them actually intializes the static).</p>",
        "id": 254597684,
        "sender_full_name": "Connor Horman",
        "timestamp": 1632428148
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254597310\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"118594\">Dylan MacKenzie (ecstatic-morse)</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254592800\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/122651-general/topic/C.2B.2B.20global.20with.20side-effectful.20initializer.20optimized.20away/near/254589083\">said</a>:</p>\n<blockquote>\n<p>Note: That's called deffered initialization, and is only permitted until at the latest, the first statement that odr-uses anything in the same translation unit. You could also solve it by placing a function in the source file that does nothing, but is called by the rust code.</p>\n</blockquote>\n<p>The function doesn't even have to access the global?</p>\n</blockquote>\n<p>Nope. Just has to be in the same translation unit</p>\n</blockquote>\n<p>Fascinating, this does seem to be the case. I was surprised that I wasn't calling anything in the same translation by pure chance, but it seems like the function that looks up the plugin is in a separate header file, not the generated code, and it's the first thing the program does.</p>",
        "id": 254599054,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632428630
    },
    {
        "content": "<p>Thanks everybody</p>",
        "id": 254602656,
        "sender_full_name": "Dylan MacKenzie (ecstatic-morse)",
        "timestamp": 1632430104
    }
]