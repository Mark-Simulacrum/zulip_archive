[
    {
        "content": "<p>Are there any useful cases where a function would have extern \"C\" but not no_mangle, or vice versa?</p>",
        "id": 261602351,
        "sender_full_name": "jsha",
        "timestamp": 1637043873
    },
    {
        "content": "<p>Only <code>extern \"C\"</code> could be used when for example passing a callback to C code as function pointer. Only <code>#[no_mangle]</code> is used inside libstd (to break a circular dependency I believe) but is not generaly useful.</p>",
        "id": 261603700,
        "sender_full_name": "bjorn3",
        "timestamp": 1637045506
    },
    {
        "content": "<p>I have both cases in oxide enzyme/example.<br>\nHowever, it's still under dev, so I might be able to drop at least the [no-mangle] only case.<br>\nI use [no-mangle] to spot on LLVM-IR level functions for which I want to generate gradients and based on the generated functions I create an archive which I link against some extern blocks. It works well, but I'm looking into dropping to [no-mangle] too, not sure if I can do the (de)mangeling in my build script.</p>",
        "id": 261604087,
        "sender_full_name": "Manuel Drehwald",
        "timestamp": 1637045979
    },
    {
        "content": "<p>#[no_mangle] without extern \"C\" will work for many C-compatible function signatures and you can go quite a number of months before noticing that technically you wrote it incorrectly.</p>",
        "id": 261610305,
        "sender_full_name": "Lokathor",
        "timestamp": 1637051545
    },
    {
        "content": "<p><code>no_mangle</code> alone is also useful for Rust plugins, like the compiler's <code>load_backend_from_dylib</code> that wants:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">__rustc_codegen_backend</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">CodegenBackend</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261727669,
        "sender_full_name": "cuviper",
        "timestamp": 1637107942
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/122651-general/topic/extern.20.22C.22.20and.20no_mangle/near/261727669\">said</a>:</p>\n<blockquote>\n<p><code>no_mangle</code> alone is also useful for Rust plugins, like the compiler's <code>load_backend_from_dylib</code> that wants:</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[no_mangle]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">__rustc_codegen_backend</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">CodegenBackend</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Imagine needing <code>#[no_mangle]</code> to interact with dylib symbols.</p>",
        "id": 261732365,
        "sender_full_name": "Connor Horman",
        "timestamp": 1637111779
    },
    {
        "content": "<p>imo, at the point where you are privileged to be able to FFI-call an <code>extern\"Rust\"</code> function, <code>#[no_mangle]</code> isn't really necessary, so much as a convience - you probably know the mangling scheme in use by the compiler and can probably at least dynamically manufacture a symbol name. Although I'm coming from a position of using a mangling scheme deliberately designed to be reasonable to manufacture.</p>",
        "id": 261732721,
        "sender_full_name": "Connor Horman",
        "timestamp": 1637112111
    },
    {
        "content": "<p>mangling include crate information, but this symbol can be provided by multiple crates: <code>rustc_codegen_cranelift</code>, <code>rustc_codegen_gcc</code>, or possibly something external.</p>",
        "id": 261733896,
        "sender_full_name": "cuviper",
        "timestamp": 1637113264
    },
    {
        "content": "<p>maybe you could guess that from the filename or other metadata, but why bother?</p>",
        "id": 261733919,
        "sender_full_name": "cuviper",
        "timestamp": 1637113306
    },
    {
        "content": "<p>True. I mostly use this in proc_macros, where I have access to the crate path (and can just check the rmanifest crate header in a dylib section to get the crate's prefix component), or  in <code>proc_macro</code> where the prefix is <code>proc_macro</code>.  When I'm working with codegen plugins I'm not privileged to use <code>extern\"Rust\"</code> let alone <code>#[no_mangle]</code>.</p>",
        "id": 261734858,
        "sender_full_name": "Connor Horman",
        "timestamp": 1637114301
    },
    {
        "content": "<p>why <em>wouldn't</em> that use no_mangle? the symbol can come from arbitrary crates loaded as dylibs into rustc, rustc has zero way to guess what the mangled name will be</p>",
        "id": 261894829,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1637221163
    },
    {
        "content": "<p>although rustc gets to do some special stuff since its rustc and the dylib wont load if it uses a different version of rustc</p>",
        "id": 261894855,
        "sender_full_name": "Riccardo D'Ambrosio",
        "timestamp": 1637221197
    }
]