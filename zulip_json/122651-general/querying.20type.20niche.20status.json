[
    {
        "content": "<p>Given a type <code>T</code>, is it possible to find out (through any means, stable or not) what kinds of niche optimizations are available for it? I.e. <code>Box&lt;T&gt;</code> is known to be nonzero by the compiler, so it can optimize <code>Option&lt;Box&lt;T&gt;&gt;</code> to have the same size, but <code>Option&lt;Box&lt;T&gt;&gt;</code> does not have the same niche, so <code>Option&lt;Option&lt;Box&lt;T&gt;&gt;&gt;</code> would have to be larger. What even are the possible niche structures that the compiler tracks?</p>",
        "id": 208738596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598989894
    },
    {
        "content": "<p>You can use <code>#[rustc_layout(abi)]</code> -- <a href=\"https://doc.rust-lang.org/nightly/unstable-book/language-features/rustc-attrs.html\">https://doc.rust-lang.org/nightly/unstable-book/language-features/rustc-attrs.html</a></p>",
        "id": 208748270,
        "sender_full_name": "cuviper",
        "timestamp": 1598994230
    },
    {
        "content": "<p>for a type you aren't defining yourself, like <code>Box</code>, just put it in a wrapper</p>",
        "id": 208748348,
        "sender_full_name": "cuviper",
        "timestamp": 1598994259
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=4ad274185ce1ec73b8cbf6e429140f61\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=4ad274185ce1ec73b8cbf6e429140f61</a></p>\n<div class=\"codehilite\"><pre><span></span><code>error: abi: Scalar(Scalar { value: Pointer, valid_range: 1..=18446744073709551615 })\n</code></pre></div>",
        "id": 208748393,
        "sender_full_name": "cuviper",
        "timestamp": 1598994289
    },
    {
        "content": "<p>whereas <code>Wrapper(Option&lt;Box&lt;i32&gt;&gt;)</code> gives:</p>\n<div class=\"codehilite\"><pre><span></span><code>error: abi: Scalar(Scalar { value: Pointer, valid_range: 1..=0 })\n</code></pre></div>",
        "id": 208748588,
        "sender_full_name": "cuviper",
        "timestamp": 1598994387
    },
    {
        "content": "<p>the range wraps, for whatever reason</p>",
        "id": 208748631,
        "sender_full_name": "cuviper",
        "timestamp": 1598994411
    },
    {
        "content": "<p>oh wow, that's really nice</p>",
        "id": 208749154,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598994630
    },
    {
        "content": "<p><code>#[rustc_layout(debug)]</code> is probably more what you want, with the <code>largest_niche</code> field</p>",
        "id": 208749217,
        "sender_full_name": "cuviper",
        "timestamp": 1598994658
    },
    {
        "content": "<p>I will make sure to abuse this in my <code>unsafe</code> code ;P</p>",
        "id": 208749261,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1598994687
    },
    {
        "content": "<p>note that, in general, these details are not stable</p>",
        "id": 208751121,
        "sender_full_name": "simulacrum",
        "timestamp": 1598995567
    },
    {
        "content": "<p>some specific optimizations are guaranteed by the language though</p>",
        "id": 208751132,
        "sender_full_name": "simulacrum",
        "timestamp": 1598995579
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208749261\">said</a>:</p>\n<blockquote>\n<p>I will make sure to abuse this in my <code>unsafe</code> code ;P</p>\n</blockquote>\n<p>definitely please do not do that. consult <a href=\"https://rust-lang.github.io/unsafe-code-guidelines/\">the docs</a> for what niches are actually guaranteed, and be mindful of the notes in those docs for things that are not RFC'd yet -- they cannot be relied upon either.</p>",
        "id": 208800927,
        "sender_full_name": "RalfJ",
        "timestamp": 1599040198
    },
    {
        "content": "<p>I am of course aware of the instability of <code>repr(Rust)</code>, although it would be great if I could static assert that a repr rust type has a particular abi so that I can at least know when it's going to work. The usual time I find myself doing these dirty hacks is when I want to expose some private state in another crate, because I need to make a small tweak to the library and don't want to copy paste and fork the whole crate.</p>",
        "id": 208804720,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599042938
    },
    {
        "content": "<p>Actually the example that prompted this question was just when I wanted to double check that <code>Option&lt;Arc&lt;T&gt;&gt;</code> is no bigger than <code>Arc&lt;T&gt;</code> for my own understanding, no unsafe needed</p>",
        "id": 208805014,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599043123
    },
    {
        "content": "<p>I guess I would say that the wobbly <code>repr(Rust)</code> ABI goes against the idea of systems programming giving the programmer control of the hardware (rather than the language/compiler keeping that control for itself). I know why it is the way it is but that doesn't mean I have to like it.</p>",
        "id": 208805481,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599043421
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208805481\">said</a>:</p>\n<blockquote>\n<p>I guess I would say that the wobbly <code>repr(Rust)</code> ABI goes against the idea of systems programming giving the programmer control of the hardware (rather than the language/compiler keeping that control for itself). I know why it is the way it is but that doesn't mean I have to like it.</p>\n</blockquote>\n<p>That's a bit like saying that compiler optimizations go against \"the idea of system programming\" because the programmer cannot control what exactly the assembly is that is being produced.</p>",
        "id": 208849927,
        "sender_full_name": "RalfJ",
        "timestamp": 1599063485
    },
    {
        "content": "<p>If you want <em>full</em> control, use assembly. If you want a higher-level language than that, there's an inherent trade-off between giving guarnatees and being able to make code go faster. Rust offers both options, that's why we have <code>repr(Rust)</code> and <code>repr(C)</code>.</p>",
        "id": 208850009,
        "sender_full_name": "RalfJ",
        "timestamp": 1599063542
    },
    {
        "content": "<p>If you decide against using <code>repr(C)</code>, you get the benefits and the cost of \"wobbly\" <code>repr(Rust)</code>. It's your choice, but there's no way to provide the benefits without the costs. You can have all the control you want, you just have to ask the compiler (and possibly library author, if it's not your type) for it.</p>",
        "id": 208850067,
        "sender_full_name": "RalfJ",
        "timestamp": 1599063569
    },
    {
        "content": "<blockquote>\n<p>That's a bit like saying that compiler optimizations go against \"the idea of system programming\" because the programmer cannot control what exactly the assembly is that is being produced.</p>\n</blockquote>\n<p>Well, they do. The point is that in a good systems language I can tell the compiler, in a targeted way, \"don't touch my code <em>here</em>\". That includes things like the <code>volatile</code> keyword and inline assembly. I think it is a false dichotomy to say that I should go write in assembly if I want that kind of control, because C is a classic example of bridging that gap.</p>\n<blockquote>\n<p>If you decide against using repr(C), you get the benefits and the cost of \"wobbly\" repr(Rust). It's your choice, but there's no way to provide the benefits without the costs. You can have all the control you want, you just have to ask the compiler (and possibly library author, if it's not your type) for it.</p>\n</blockquote>\n<p>I definitely see ways that we could have our cake and eat it too in this department. I can already write target specific code using <code>#[cfg(windows)]</code> and <code>#[cfg(x86)]</code> and the like, but I can't write code that is tailored to the compiler's possible layout options. The standardization process around repr(Rust) has been going nowhere for years and so I'm forced to write to the compiler as it exists rather than the spec I would like to have (which is very common in C circles but something I try to avoid in Rust because the standardization process has been better in most areas).</p>\n<p>C++ standards guys can say \"but that's UB\" until they are blue in the face but that won't stop people from exploiting compiler behavior because the standard isn't meeting their needs. Until the next compiler version comes out, people's code breaks, and everyone is disappointed.</p>",
        "id": 208896090,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599085448
    },
    {
        "content": "<p>It's not at all clear why you're saying <code>#[repr(C)]</code> doesn't work for you. That's the mechanism to say \"lay this out in a specific standard way\".</p>",
        "id": 208896553,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599085778
    },
    {
        "content": "<p>When you say \"The standardization process around repr(Rust) has been going nowhere for years\", that implies there's a standardization process, as opposed to a deliberate decision to not stabilize that repr's layout.</p>",
        "id": 208896609,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599085803
    },
    {
        "content": "<p>The usual place this comes up is when I want to work with someone else's library without changing their code</p>",
        "id": 208896629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599085807
    },
    {
        "content": "<p>I can pin down their library by not upgrading or doing it consciously but I lack the tools to pin down the compiler</p>",
        "id": 208896702,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599085848
    },
    {
        "content": "<p>What kinds of things would you like to do that depend on structure layout?</p>",
        "id": 208896768,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599085887
    },
    {
        "content": "<p>getting access to private fields is a classic example</p>",
        "id": 208896811,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599085909
    },
    {
        "content": "<p>That's not making a good case for why the compiler should <em>want</em> to enable this. ;)</p>",
        "id": 208896900,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599085936
    },
    {
        "content": "<p>yeah it's a horrible hack, but that doesn't mean rust should be actively trying to break my code</p>",
        "id": 208896910,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599085940
    },
    {
        "content": "<p>But also, that <em>is</em> something that you can do without relying on the layout of repr(Rust).</p>",
        "id": 208896926,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599085950
    },
    {
        "content": "<p>Declare another structure with exactly the same fields, and transmute.</p>",
        "id": 208896936,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599085965
    },
    {
        "content": "<p>Then you're not counting on the layout, only counting on Rust to lay out two identical structures identically, which is not as much of an assumption.</p>",
        "id": 208896961,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599085988
    },
    {
        "content": "<p>That's one of many reasonable things that is being deliberately not committed to</p>",
        "id": 208896972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599085997
    },
    {
        "content": "<p>True. The moment there's a useful optimization that would depend on breaking that assumption, where on the one side of the balance we have \"optimize Rust code for everyone\" and on the other side we have \"break hacks used to access private fields from a third-party crate\", it's not hard to imagine which way that goes.</p>",
        "id": 208897086,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086064
    },
    {
        "content": "<p>reading <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/11\">https://github.com/rust-lang/unsafe-code-guidelines/issues/11</a> has been an exercise in frustration</p>",
        "id": 208897110,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086086
    },
    {
        "content": "<p>You might be better off forking the third-party crate, adding the changes you want, and using the fork.</p>",
        "id": 208897137,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086106
    },
    {
        "content": "<p>The thing is, I'm okay writing crazy macro stuff if it means I can make my hack work reliably, but rust doesn't seem to want to work with that</p>",
        "id": 208897228,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086166
    },
    {
        "content": "<p>Like I said, I'm not opposed to letting rust retain flexibility in data layout, but it should expose some of what it's doing to unsafe code that is forced to rely on it to make <code>transmute</code> stuff work</p>",
        "id": 208897296,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086230
    },
    {
        "content": "<p>I think that immediately backing off with \"you are on your own because you wrote <code>unsafe</code>\" is the wrong approach here</p>",
        "id": 208897393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086283
    },
    {
        "content": "<p>/me is re-reading that issue now.</p>",
        "id": 208897406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086291
    },
    {
        "content": "<p>It occurs to me that safe-transmute would make it possible for the compiler to confirm for you at the type level that two types have the same layout.</p>",
        "id": 208897617,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086442
    },
    {
        "content": "<p>And safe-transmute has the concept of \"stability\", which is something that <em>can</em> be bypassed to get at private fields.</p>",
        "id": 208897646,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086470
    },
    {
        "content": "<p>So that might be the path to what you want.</p>",
        "id": 208897657,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086477
    },
    {
        "content": "<p>(That said, I still think any structure for which you care about layout should use <code>repr(C)</code>.)</p>",
        "id": 208897680,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086492
    },
    {
        "content": "<p>I think the limiting case of what I'm talking about is something like compile time reflection of data layouts, i.e. functions like <code>size_of</code> but for ABI details</p>",
        "id": 208897764,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086527
    },
    {
        "content": "<p>So, for instance, <code>offset_of</code>?</p>",
        "id": 208897851,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086588
    },
    {
        "content": "<p>that would be great</p>",
        "id": 208897913,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086636
    },
    {
        "content": "<p>that's good enough for extracting private fields, not quite good enough for safe transmute of complex types</p>",
        "id": 208897972,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086662
    },
    {
        "content": "<p>A trait based approach to safe transmute is likely to not be powerful enough in general</p>",
        "id": 208898035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086707
    },
    {
        "content": "<p>I can imagine some turing complete stuff sneaking in here, so a const fn approach seems a bit more general</p>",
        "id": 208898086,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086743
    },
    {
        "content": "<p>Clarification: <code>offset_of</code> likely won't be enough to access private fields, because you (hopefully) wouldn't be able to use it on a field you couldn't access.</p>",
        "id": 208898102,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086761
    },
    {
        "content": "<p>I figured</p>",
        "id": 208898160,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086778
    },
    {
        "content": "<p>I'd be curious to have an example of a third-party crate for which you have a reason to access a private field, and for which fixing the crate isn't an option.</p>",
        "id": 208898191,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086811
    },
    {
        "content": "<p>These things usually work themselves out eventually, so the dirty hacks don't make it into production, but sometimes I'm too impatient for my PR to land :)</p>",
        "id": 208898230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086860
    },
    {
        "content": "<p>and if not I can always fork</p>",
        "id": 208898249,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599086874
    },
    {
        "content": "<p>/me has, many times, cloned a crate locally, and used a <code>path</code> dependency to test it.</p>",
        "id": 208898298,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086887
    },
    {
        "content": "<p>But in any case, I think for that kind of hack it'd be \"reasonable\" to just count on the compiler to not reorder, and watch the release notes to see if that's going to change. ;)</p>",
        "id": 208898338,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599086927
    },
    {
        "content": "<p>I agree. Which is why I find the stubborn lack of any guarantees for repr(Rust) structs so frustrating. (Aside: one person mentioned that they thought that it would be surprising that reordering the fields of a struct with named fields would break the ABI, citing things like alphabetizing field names. Is this sentiment common? I find the opposite surprising.)</p>",
        "id": 208898581,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599087118
    },
    {
        "content": "<p>I think it's reasonable to treat the order of <em>pub</em> fields in a pub <code>repr(C)</code> struct as part of the ABI.</p>",
        "id": 208898643,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087156
    },
    {
        "content": "<p>But also, I think it's counterproductive to call someone not doing what you want \"stubborn\". There are reasons, whether you like those reasons or not.</p>",
        "id": 208898682,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087211
    },
    {
        "content": "<p>The compiler provides <code>repr(C)</code> for a reason.</p>",
        "id": 208898758,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087256
    },
    {
        "content": "<p>I'd also say that once we have <code>offset_of</code>, it'd be reasonable to use it on public fields and rely on it, but not reasonable (for instance) to expect field offsets not to change.</p>",
        "id": 208898784,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087282
    },
    {
        "content": "<p>I think it is not okay to make the rust compiler adversarial, using fuzzing and things to attempt to break my code while also not providing the means to play along and choose an appropriate course of action based on layout decisions. That's not a fair fight</p>",
        "id": 208899041,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599087483
    },
    {
        "content": "<p>Nobody is making it adversarial.</p>",
        "id": 208899157,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087590
    },
    {
        "content": "<p>The randomization stuff is pretty adversarial</p>",
        "id": 208899239,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599087606
    },
    {
        "content": "<p>I did see the discussions about randomized layout in the issue you linked, but I don't believe those were about being adversarial towards the <em>developer</em>. That's about being adversarial towards <em>bugs</em> or <em>attacks</em>.</p>",
        "id": 208899276,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087624
    },
    {
        "content": "<p>(Also, I'd personally oppose having randomized structure layout by default, though I'd support having an option for it.)</p>",
        "id": 208899303,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087643
    },
    {
        "content": "<p>I realize that, but it's inadvertently ending up adversarial to the developer in this instance</p>",
        "id": 208899329,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599087660
    },
    {
        "content": "<p>In general, I tend to be one of the strongest advocates for \"let's not break existing code, even if that code is using undefined behavior, and <em>especially</em> without a transition plan and an alternative to offer\".</p>",
        "id": 208899426,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087722
    },
    {
        "content": "<p>I would like to be able to write <em>correct</em> unsafe hackery</p>",
        "id": 208899472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599087751
    },
    {
        "content": "<p>rust gives me correct and it gives me unsafe but apparently not at the same time</p>",
        "id": 208899503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599087771
    },
    {
        "content": "<p>I think you're rather unfairly maligning the compiler's intentions here.</p>",
        "id": 208899518,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087788
    },
    {
        "content": "<p>Rust gives you plenty of ways to write correct unsafe code.</p>",
        "id": 208899529,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087802
    },
    {
        "content": "<p>Such as <code>repr(C)</code> for instance.</p>",
        "id": 208899590,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087842
    },
    {
        "content": "<p>What if I <em>want</em> Rust to lay out my struct</p>",
        "id": 208899638,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599087870
    },
    {
        "content": "<p>Your use case of \"I want to access the private fields of a third-party type that doesn't use <code>repr(C)</code>, and rely on its layout to do so\" is firmly in the realm where I'd argue that we shouldn't <em>gratuitously</em> break that, but we shouldn't commit to it working at the expense of future optimizations either.</p>",
        "id": 208899675,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599087910
    },
    {
        "content": "<p>If you want Rust to lay out your struct in a specific well-defined way, you should tell Rust to do that. Rust has a way to do exactly that.</p>",
        "id": 208899815,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088011
    },
    {
        "content": "<p>I know that rust wants layout freedom and I'm on board with that, but I don't think <code>repr(C)</code> is the answer because most types are not <code>repr(C)</code></p>",
        "id": 208899818,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088014
    },
    {
        "content": "<p>nor should they be, Rust is good at using tricks to do good layouts and I have no desire to get in the way of that</p>",
        "id": 208899876,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088063
    },
    {
        "content": "<p>but I think it should be possible for the programmer to write code that depends on data layout in a more complex way than simple field access</p>",
        "id": 208900021,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088157
    },
    {
        "content": "<p>I agree that it should be possible. I think that <code>offset_of</code> for public fields makes sense, and I think that it should be possible to <em>tell</em> the compiler to lay out a structure in a precise way.</p>",
        "id": 208900071,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088194
    },
    {
        "content": "<p>I think safe transmute is just one instance of this, my private field extraction is another example</p>",
        "id": 208900078,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088196
    },
    {
        "content": "<p>I also think it'd be possible to support the use case you're looking for via safe-transmute.</p>",
        "id": 208900131,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088207
    },
    {
        "content": "<p>By the way, is there a particular preferred safe-transmute proposal right now? I feel like I've read several, none with clear support</p>",
        "id": 208900331,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088345
    },
    {
        "content": "<p>Going back to a much earlier point: I <em>do</em> think the compiler should have ways of allowing you to specify \"do exactly what I say here\". <code>repr(C)</code> is one such mechanism. And when you <em>don't</em> use those mechanisms, I think it's reasonable for the compiler to have more flexibility.</p>",
        "id": 208900333,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088348
    },
    {
        "content": "<p>Yes, there is: <a href=\"https://github.com/rust-lang/rfcs/pull/2981\">https://github.com/rust-lang/rfcs/pull/2981</a></p>",
        "id": 208900351,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088367
    },
    {
        "content": "<p>(Just a note in advance: going there and trying to advocate for the use case of accessing private fields is probably not going to go over well.)</p>",
        "id": 208900379,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088389
    },
    {
        "content": "<p>;)</p>",
        "id": 208900403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088420
    },
    {
        "content": "<p>I just want Rust to be a better C</p>",
        "id": 208900418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088439
    },
    {
        "content": "<p>So do many of us, myself included, but I think that there are many different ideas on what \"a better C\" means.</p>",
        "id": 208900616,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088519
    },
    {
        "content": "<p>I don't want Rust to be \"a better portable assembler\" by default, though it should have some options to help with such use cases. ;)</p>",
        "id": 208900648,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088534
    },
    {
        "content": "<p>As one random example of something I'd like to have that involves structure layout: I'd love to be able to have the compiler detect that of all the code being compiled, absolutely nothing ever reads a field, and nothing ever transmutes the structure from something else, so the field effectively doesn't exist and all writes to it could be ignored.</p>",
        "id": 208900841,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599088677
    },
    {
        "content": "<p>That's another thing that having an explicit layout API would help with</p>",
        "id": 208900937,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088740
    },
    {
        "content": "<p>since the compiler can see that you called <code>size_of::&lt;T&gt;()</code> instead of just <code>24</code></p>",
        "id": 208900978,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088769
    },
    {
        "content": "<p>actually, it occurs to me that a much simpler way to achieve what I'm talking about is to just be able to override privacy annotations</p>",
        "id": 208901011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088802
    },
    {
        "content": "<p>Though that would be inherently unstable, and unsafe, I don't necessarily see a reason <em>not</em> to allow it.</p>",
        "id": 208901103,
        "sender_full_name": "simulacrum",
        "timestamp": 1599088858
    },
    {
        "content": "<p>Of course I know that won't go over well, and obviously such uses should come with lots of explicit warning flags because it's not a recommended thing, but it solves a lot of problems</p>",
        "id": 208901116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088873
    },
    {
        "content": "<p>it is your program's data, after all</p>",
        "id": 208901126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599088889
    },
    {
        "content": "<p>I would personally be unsure about how we'd communicate the lack of stability there -- seems dangerous to Rust's stability as a whole</p>",
        "id": 208901288,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089022
    },
    {
        "content": "<p>how so?</p>",
        "id": 208901304,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089034
    },
    {
        "content": "<p>I think of it like a crate \"friend\"</p>",
        "id": 208901357,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089055
    },
    {
        "content": "<p>you gain access to the internals of the crate in return for having to upgrade as a unit</p>",
        "id": 208901390,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I wouldn't object as long as both sides had to declare it.</p>",
        "id": 208901398,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089102
    },
    {
        "content": "<p>right, I'm saying that you need that \"unit upgrade\" piece</p>",
        "id": 208901403,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089104
    },
    {
        "content": "<p>which we don't currently have, but there's a bunch of reasons to want \"friend crates\" that don't involve this</p>",
        "id": 208901419,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089120
    },
    {
        "content": "<p>(The reason I'd want both sides to declare it is that it would allow violating the safety assumptions of a crate, not just stability.)</p>",
        "id": 208901451,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089150
    },
    {
        "content": "<p>(For instance, a field might be private to maintain an invariant.)</p>",
        "id": 208901460,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089158
    },
    {
        "content": "<p>Well if crate A upgrades and B is a friend of A then it doesn't have to upgrade if it doesn't touch its toml file</p>",
        "id": 208901464,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089159
    },
    {
        "content": "<p>(you might have to specify a particular version in B's toml file)</p>",
        "id": 208901536,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089182
    },
    {
        "content": "<p>You mean <code>=</code> dependencies rather than normal <code>^</code> semver-compat deps?</p>",
        "id": 208901563,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089203
    },
    {
        "content": "<p>yes</p>",
        "id": 208901570,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089208
    },
    {
        "content": "<p>rustc can't know if you're using <code>=</code> dependencies today though, and that would be \"hard\"</p>",
        "id": 208901606,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089233
    },
    {
        "content": "<p>because semver-compat deps can break or change internal invariants</p>",
        "id": 208901608,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089235
    },
    {
        "content": "<p>I don't follow</p>",
        "id": 208901623,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089248
    },
    {
        "content": "<p>rustc has no idea what version crates are, that's a cargo concern</p>",
        "id": 208901644,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089266
    },
    {
        "content": "<p>right, but rustc also doesn't deal with upgrades</p>",
        "id": 208901705,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089289
    },
    {
        "content": "<p>and presumably we'd want rustc to forbid reading details of a foreign crate without it being declared as a = dep</p>",
        "id": 208901711,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089294
    },
    {
        "content": "<p>(e.g., you'd never be able to do this for std)</p>",
        "id": 208901719,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089302
    },
    {
        "content": "<p>because I think if you were able, then we'd likely end up in a world where std's structs are de-facto stable and that seems really bad</p>",
        "id": 208901752,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089325
    },
    {
        "content": "<p>no, I think rustc should only require that you say <code>unsafe friend_of extern crate std;</code> or something</p>",
        "id": 208901761,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089332
    },
    {
        "content": "<p>and if you do, then you must also tie yourself to a particular version in the cargo file</p>",
        "id": 208901789,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089360
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> And then you upgrade rustc, which changes the layout of std's internal data structures, and your code breaks.</p>",
        "id": 208901795,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089371
    },
    {
        "content": "<p>Cargo has no way right now to express a versioned dependency on std.</p>",
        "id": 208901810,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089384
    },
    {
        "content": "<p>And also, the declaration you suggested gives no indication of version.</p>",
        "id": 208901820,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089394
    },
    {
        "content": "<p>the version would go in the cargo file</p>",
        "id": 208901899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089431
    },
    {
        "content": "<p>rustc doesn't read that cargo file</p>",
        "id": 208901905,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089438
    },
    {
        "content": "<p>how does rustc get the std lib?</p>",
        "id": 208901930,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089457
    },
    {
        "content": "<p>loads from sysroot</p>",
        "id": 208901960,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089479
    },
    {
        "content": "<p>do the library files come bundled with the compiler?</p>",
        "id": 208901962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089483
    },
    {
        "content": "<p>today, yes</p>",
        "id": 208901969,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089487
    },
    {
        "content": "<p>(though they don't have to)</p>",
        "id": 208901975,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089497
    },
    {
        "content": "<p>so a given version of rustc sees a given version of std</p>",
        "id": 208901986,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089511
    },
    {
        "content": "<p>and they always upgrade together</p>",
        "id": 208902027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089522
    },
    {
        "content": "<p>And where does the declaration of what version of std you're relying on the internal data structures of go?</p>",
        "id": 208902078,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089554
    },
    {
        "content": "<p>in which case if you friend std then you are stuck with a particular version of rustc, or more likely you are friends with the dev team or watching changes</p>",
        "id": 208902095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089569
    },
    {
        "content": "<p>I think any solution needs to address somehow the problem that if we permit reaching into std internals, it becomes a conversation of \"well how much code will we break in practice\" every time we change those.</p>",
        "id": 208902099,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> If we even <em>considered</em> this, which I don't think we should, it should go hand in hand with saying we <em>don't</em> have to consider that.</p>",
        "id": 208902123,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089599
    },
    {
        "content": "<p>By doing this you definitely opt out of any stability guarantees with that crate</p>",
        "id": 208902135,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089609
    },
    {
        "content": "<p>Sure, but my point is that we <em>have</em> said that e.g. for type inference or breaking itertools due to \"adding a method to Iterator\" or \"TryFrom/Into\" and all of those... have caused us to back away</p>",
        "id": 208902163,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089632
    },
    {
        "content": "<p>That's more a political problem</p>",
        "id": 208902214,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089654
    },
    {
        "content": "<p>Welcome to Rust, we care about social problems and community. ;)</p>",
        "id": 208902238,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089676
    },
    {
        "content": "<p>It is still a problem that must be addressed, perhaps even more so because of that.</p>",
        "id": 208902239,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089677
    },
    {
        "content": "<p>if my awesome crate that is a friend of yours becomes big and important, then you may well make decisions based on how my crate responds, but that seems like a second order effect</p>",
        "id": 208902270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089705
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> Your phrasing seems like it's describing the fundamental problem. Friendship is not unilateral.</p>",
        "id": 208902372,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089774
    },
    {
        "content": "<p>This is like being friends with a youtube celeb :)</p>",
        "id": 208902397,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089802
    },
    {
        "content": "<p>Yes, and they don't let you get at their private details either. ;)</p>",
        "id": 208902416,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089816
    },
    {
        "content": "<p>My problem is that if the friend relationship is not mutual then you end up in a pretty unfortunate world of everyone needing to think \"well who am I going to break in practice\" and I think that's unfortunate and, personally, might be a dealbreaker for stabilization at least.</p>",
        "id": 208902418,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089817
    },
    {
        "content": "<p>Though perhaps not for forever-nightly.</p>",
        "id": 208902450,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089848
    },
    {
        "content": "<p>That's probably fair</p>",
        "id": 208902476,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089866
    },
    {
        "content": "<p>That said, I think friend crates are <em>very</em> much desired for a number of reasons that are somewhat orthogonal to this</p>",
        "id": 208902478,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089867
    },
    {
        "content": "<p>e.g., being able to <code>impl ForeignType { .. }</code> for a friend crate</p>",
        "id": 208902530,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089885
    },
    {
        "content": "<p>I don't have a good understanding of the roles that stable/beta/nightly play but this does seem like a good candidate for never-stable</p>",
        "id": 208902553,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599089901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Now <em>that</em> is something I'd really like to have, if we can deal with coherence issues.</p>",
        "id": 208902582,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089920
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> If you don't mind using nightly, what about a <code>-Z struct-layout-xyz</code> option to specify struct layout?</p>",
        "id": 208902605,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089940
    },
    {
        "content": "<p>Right, yes, the \"friend crate\" is the enabler for bypassing coherence, basically placing a set of crates into a single coherence context, IMO.</p>",
        "id": 208902625,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089952
    },
    {
        "content": "<p>Though I'm sure there's a ton of details to work out.</p>",
        "id": 208902632,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089964
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> e.g. <code>-Z struct-layout-Rust-like-C</code>.</p>",
        "id": 208902636,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599089964
    },
    {
        "content": "<p>If you're fine with it being unstable, then you can already query type layout with -Zprint-type-sizes or <code>#[rustc_layout(debug)]</code> and then manually access it</p>",
        "id": 208902667,
        "sender_full_name": "simulacrum",
        "timestamp": 1599089997
    },
    {
        "content": "<p>obviously it's, well, \"keep your compiler and deps pinned\"</p>",
        "id": 208902732,
        "sender_full_name": "simulacrum",
        "timestamp": 1599090023
    },
    {
        "content": "<p>Well I can always just <code>*(p+8)</code> too</p>",
        "id": 208902741,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090030
    },
    {
        "content": "<p>I personally would agree with <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> that we're highly unlikely to ever randomly re-order structs on you without opt-in</p>",
        "id": 208902773,
        "sender_full_name": "simulacrum",
        "timestamp": 1599090057
    },
    {
        "content": "<p>I'm just hoping to ultimately find something more correct than that</p>",
        "id": 208902795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090070
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> To try and understand -- what would you expect instead of that? Something like <code>bypass_privacy!(p.foo)</code>?</p>",
        "id": 208902851,
        "sender_full_name": "simulacrum",
        "timestamp": 1599090111
    },
    {
        "content": "<p>I think it's going to be a pretty hard sell given the \"easy edit\" nature of most Rust dependencies</p>",
        "id": 208902914,
        "sender_full_name": "simulacrum",
        "timestamp": 1599090132
    },
    {
        "content": "<p>I was thinking the privacy bypass would be at the top level, like <code>bypass_privacy! use other_crate::foo;</code></p>",
        "id": 208902973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090175
    },
    {
        "content": "<p>at which point it becomes \"as if\" you were writing code inside that module</p>",
        "id": 208903011,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090209
    },
    {
        "content": "<p>also gotta throw an <code>unsafe</code> in there to appease the masses</p>",
        "id": 208903035,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090235
    },
    {
        "content": "<p><code>#![unsafe_invade(other_crate::foo)]</code></p>",
        "id": 208903126,
        "sender_full_name": "Monadic Cat",
        "timestamp": 1599090286
    },
    {
        "content": "<p>That feels worse than a local bypass, personally, and I'm not sure what benefit a global one brings.</p>",
        "id": 208903150,
        "sender_full_name": "simulacrum",
        "timestamp": 1599090307
    },
    {
        "content": "<p>Maybe require it noted at the top level, and still require access via a macro locally?</p>",
        "id": 208903193,
        "sender_full_name": "Monadic Cat",
        "timestamp": 1599090339
    },
    {
        "content": "<p>I don't think that crate boundaries can be meaningfully bypassed \"just a little\"</p>",
        "id": 208903196,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090340
    },
    {
        "content": "<p>Well, the local bypass means that you can easily find where you're doing it which seems like a win. Spooky action at a distance feels bad.</p>",
        "id": 208903275,
        "sender_full_name": "simulacrum",
        "timestamp": 1599090380
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#![feature(privacy_invasion)]</span><span class=\"w\"></span>\n<span class=\"cp\">#![unsafe_invade(other_crate::foo)]</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Later...</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">invade</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">b</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// Accessing a private field.</span>\n</code></pre></div>",
        "id": 208903290,
        "sender_full_name": "Monadic Cat",
        "timestamp": 1599090388
    },
    {
        "content": "<p>Maybe it's something like unsafe_op_in_unsafe_fn</p>",
        "id": 208903297,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090399
    },
    {
        "content": "<p>That could get tiresome if you are writing a whole function in that style though</p>",
        "id": 208903463,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090523
    },
    {
        "content": "<p>it seems very similar to <code>unsafe</code> blocks</p>",
        "id": 208903492,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090546
    },
    {
        "content": "<p>Ah, here's a more plausible use case: you discover there is a fatal flaw in <code>Mutex::lock</code> that is causing your web server to be susceptible to the latest 0-day, and you can't wait for the patch to land in the next version. This would let you patch just that function, writing from within the context that the original was written. (You might be able to copy the whole type, but depending on how intrinsically linked it is to other private stuff that might involve cloning the whole library, and might require a larger change to the build setup.)</p>",
        "id": 208904126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599090964
    },
    {
        "content": "<p>If you need fixes quicker than the ~1 day theoretical minimum turn around that we could in theory provide with a Rust release, then it seems reasonable to expect that you will pay someone to support you, similar to RHEL - who you can expect to patch and issue updates to libraries like std faster.</p>\n<p>Maybe that's not a satisfying answer, but it feels like the right one - ultimately it's not that hard to replace std if you're in a situation where you must patch 0 days rapidly and via std replacement (and not e.g. request filtering or something).</p>",
        "id": 208907176,
        "sender_full_name": "simulacrum",
        "timestamp": 1599093440
    },
    {
        "content": "<p>Also, I'd like to have <code>-Zbuild-std </code>working well enough that it's <em>theoretically</em> possible to build with a patched version of std with about the same difficulty as building with a patched version of any of your direct or indirect dependencies.</p>",
        "id": 208910810,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599097355
    },
    {
        "content": "<p>(e.g. cargo's functionality to replace a crate)</p>",
        "id": 208910815,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599097367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"133169\">@matklad</span> has said a few times they would love to be able to <code>cargo test</code> for the standard library itself</p>",
        "id": 208910829,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097389
    },
    {
        "content": "<p>i.e. not going through bootstrap</p>",
        "id": 208910837,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097403
    },
    {
        "content": "<p>I guess my mental model of the stdlib is incorrect. I thought that std was just a library (used to help build rustc)?</p>",
        "id": 208910947,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599097558
    },
    {
        "content": "<p>std and rustc are developed with each other</p>",
        "id": 208911004,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097596
    },
    {
        "content": "<p>it's sort of the same model as C, where 'the implementation' includes both the standard library and the compiler</p>",
        "id": 208911059,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097617
    },
    {
        "content": "<p>sure, but in the final stage you have a working rustc which builds the std sources + your crate</p>",
        "id": 208911067,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599097627
    },
    {
        "content": "<p>so e.g. libstd depends on implementation details of rustc that aren't stable</p>",
        "id": 208911081,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097634
    },
    {
        "content": "<p>right, it is a \"friend\" of rustc in the present terminology</p>",
        "id": 208911146,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599097686
    },
    {
        "content": "<p>I guess ... but rustc only supports being built with the version of std in-tree</p>",
        "id": 208911161,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097715
    },
    {
        "content": "<p>you can't take beta libstd and use that for nightly rustc</p>",
        "id": 208911164,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097724
    },
    {
        "content": "<p>they're <em>mutally</em> dependant</p>",
        "id": 208911171,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097733
    },
    {
        "content": "<p>is it a literal cycle, or just several trips around the bootstrapping loop</p>",
        "id": 208911186,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599097760
    },
    {
        "content": "<p><a href=\"https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html\">https://rustc-dev-guide.rust-lang.org/building/bootstrapping.html</a></p>",
        "id": 208911199,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097775
    },
    {
        "content": "<p>i.e. rustc can byte for byte reproduce itself in the final stage</p>",
        "id": 208911210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599097788
    },
    {
        "content": "<p>yes, if you run stage2 on itself, stage3 should be identical</p>",
        "id": 208911260,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599097807
    },
    {
        "content": "<p>Aside: Is there a reasonable <a href=\"https://bootstrappable.org/\">bootstrappable build</a> path for rust? That is, to get the latest rust from scratch + source files by a means shorter than replaying every single rust version since the dawn of time</p>",
        "id": 208911431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599098030
    },
    {
        "content": "<p>Second compiler not written in Rust, such as mrustc.</p>",
        "id": 208911501,
        "sender_full_name": "isHavvy",
        "timestamp": 1599098072
    },
    {
        "content": "<p><a href=\"https://github.com/dtolnay/bootstrap\">https://github.com/dtolnay/bootstrap</a></p>",
        "id": 208911508,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098082
    },
    {
        "content": "<p>does it actually work?</p>",
        "id": 208911511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599098087
    },
    {
        "content": "<p>sure</p>",
        "id": 208911513,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098090
    },
    {
        "content": "<p>but it takes about 100 GB of disk and several days <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 208911516,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098099
    },
    {
        "content": "<p>oh is dtolnay's project literally just replaying every version?</p>",
        "id": 208911543,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599098125
    },
    {
        "content": "<p>starting at about 1.31 I think</p>",
        "id": 208911551,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098140
    },
    {
        "content": "<p>rustc only supports compiling with rustc (version - 1), so you have to take the slow path</p>",
        "id": 208911563,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098161
    },
    {
        "content": "<p>how come the versions break so fast?</p>",
        "id": 208911670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599098278
    },
    {
        "content": "<p>rustc does a lot of dogfooding</p>",
        "id": 208911727,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098309
    },
    {
        "content": "<p>so a new feature gets implemented and then gets used almost as quickly</p>",
        "id": 208911732,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098319
    },
    {
        "content": "<p>e.g. <a href=\"https://github.com/rust-lang/rust/pull/71220\">https://github.com/rust-lang/rust/pull/71220</a></p>",
        "id": 208911786,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098395
    },
    {
        "content": "<p>I wonder how bad it would be to keep a rustc that takes much larger bootstrapping jumps, say once per edition</p>",
        "id": 208911911,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599098476
    },
    {
        "content": "<p>I mean, even without dogfooding it would break pretty often</p>",
        "id": 208911929,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098502
    },
    {
        "content": "<p>e.g. whenever you add a new lang item</p>",
        "id": 208911936,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599098513
    },
    {
        "content": "<p>The current compiler cannot be built by significantly older toolchains, but for some time ranges it wouldn't be too hard to backport a small set of changes to be able to build the compiler with.</p>\n<p>But personally I don't see why you would want to, it wouldn't take that long to bootstrap since 1.0 even; I can build a stage 2 compiler in maybe 15 minutes or so locally - that means 47 versions, modulo changing system deps over the last 5 years, could be built in only ~12 hours. So it's not days of time</p>",
        "id": 208952396,
        "sender_full_name": "simulacrum",
        "timestamp": 1599132425
    },
    {
        "content": "<blockquote>\n<p>I can build a stage 2 compiler in maybe 15 minutes or so locally</p>\n</blockquote>\n<p>That makes you the odd man out ;) It would take me at <em>least</em> half an hour even with a cached LLVM</p>",
        "id": 208965888,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1599139526
    },
    {
        "content": "<p>I see I missed many things.^^ I mostly agree with what <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> said. Let me just add that I have very strong feelings on keeping private fields private. In the realm of safe type systems, there is a dividing line between \"type systems that support abstraction\" and \"type systems that do not\". Being able to access private fields puts a language firmly into the \"no abstractions\" camp. Now, with <code>unsafe</code> Rust things become muddy, but I would still be <em>extremely</em> worried about the ecosystem consequences of seemingly \"encouraging\" abstraction-breaking unsafe code by letting it access private fields. The entire Rust ecosystem rests on the power of abstracting unsafe code behind a safe API. The more we weaken that principle, the weaker Rust's safety story becomes.</p>\n<p>So, some kind of opt-in by the \"invaded\" library is a must, IMO. And if we accept that premise, then macro-based solutions are already possible -- a library can expose unsafe functions that provide accesses to all fields.</p>",
        "id": 208981696,
        "sender_full_name": "RalfJ",
        "timestamp": 1599145715
    },
    {
        "content": "<p>I don't really see a distinction between unsafe code and privacy invading code. They both fulfill similar roles - the programmer has additional proof obligations in return for access to more features. In fact <code>unsafe</code> itself is sort of like privacy invasion of the compiler intrinsics; it has a safe front end that you can use but if you need to work across that barrier then the previously designed proofs don't apply to you so you have an additional obligation</p>",
        "id": 208984219,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599146648
    },
    {
        "content": "<p>Of course the abstraction theorem still holds in the presence of privacy invading code, because the privacy invading code is exempt from the thorem (it is lumped in with the abstraction)</p>",
        "id": 208984550,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599146795
    },
    {
        "content": "<p>Unsafe code is exactly as much a threat to the abstraction theorem as privacy invasion</p>",
        "id": 208984622,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599146833
    },
    {
        "content": "<blockquote>\n<p>a library can expose unsafe functions that provide accesses to all fields.</p>\n</blockquote>\n<p>What if it didn't?</p>",
        "id": 208984769,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599146895
    },
    {
        "content": "<p>Then the library is free to add or remove fields or change invariants on private fields, such that a library update would make your unsafe code misbehave in horrible ways.</p>",
        "id": 208985565,
        "sender_full_name": "bjorn3",
        "timestamp": 1599147227
    },
    {
        "content": "<blockquote>\n<p>Being able to access private fields puts a language firmly into the \"no abstractions\" camp. </p>\n</blockquote>\n<p>Actually, I'm not sure I buy this argument either, intuitive though it sounds at first. Suppose we're going for full correctness, and we've associated some logical proposition to the type invariant that is being protected by the API (for example, in a <code>Mutex</code> implementation we might have <code>Mutex&lt;T&gt;</code> representing <code>Lock(J)</code> and <code>MutexGuard&lt;'a, T&gt;</code> representing <code>J</code> where <code>J</code> is the property of the locked object we wish to preserve). In this case, \"a safe API\" means that we have theorems saying that the API operations preserve this balance between <code>Lock(J)</code> and <code>J</code> so as long as you only use the provided operations the invariant <code>J</code> is preserved one way or another. But, as the RustBelt paper points out, this kind of inductive invariant is brittle to alternative mechanisms that manage to preserve the invariant anyway without going through the API. What really matters is the invariant, not the API. The API is just an easy way to satisfy the conditions for the theorem</p>",
        "id": 208985900,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599147362
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208985565\">said</a>:</p>\n<blockquote>\n<p>Then the library is free to add or remove fields or change invariants on private fields, such that a library update would make your unsafe code misbehave in horrible ways.</p>\n</blockquote>\n<p>As I mentioned earlier, when you do this you are tied to the particular version. The cargo file should make it sufficiently obvious that this is happening that one would not expect a semver compatible library update to work out of the box, just as a semver-incompatible update may well break your code today</p>",
        "id": 208986231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599147490
    },
    {
        "content": "<p>The library is free to make changes, but the downstream \"friend\" crate is not free to upgrade</p>",
        "id": 208986418,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599147563
    },
    {
        "content": "<p>Using <code>=x.y.z</code> dependencies is horrible for downstream users, as two dependencies pinning two different semver compatible versions of a library will cause an error, as the semver match means that Cargo wants to use a single version.</p>",
        "id": 208986615,
        "sender_full_name": "bjorn3",
        "timestamp": 1599147623
    },
    {
        "content": "<p>all good reasons to avoid this feature in a public crate</p>",
        "id": 208986712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599147668
    },
    {
        "content": "<p>I'm not saying this is a recommended course of action by any stretch. I just want it to be possible, because the currently available alternatives are much worse and more likely to cause subtle memory bugs</p>",
        "id": 208986872,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599147725
    },
    {
        "content": "<p>just because something is unsafe doesn't mean we should make it impossible to get right</p>",
        "id": 208987038,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599147806
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208987038\">said</a>:</p>\n<blockquote>\n<p>just because something is unsafe doesn't mean we should make it impossible to get right</p>\n</blockquote>\n<p>I don't think anyone disagrees with that in principle <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 208987620,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599148050
    },
    {
        "content": "<p>right now, working with repr(Rust) layouts is impossible to get right because the spec promises next to nothing and the compiler's layout decisions are not available to unsafe code</p>",
        "id": 208988472,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599148372
    },
    {
        "content": "<p>A lot of people focus on the issues with improving the first point but I would rather see progress on the second</p>",
        "id": 208988629,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599148440
    },
    {
        "content": "<p>layout decisions are available insofar as you can, well, query the type layout indirectly, right? Like, you can get a pointer to a field and see what offset that's at</p>",
        "id": 208988913,
        "sender_full_name": "simulacrum",
        "timestamp": 1599148530
    },
    {
        "content": "<p>not to a private field, sure, but that seems orthogonal</p>",
        "id": 208988971,
        "sender_full_name": "simulacrum",
        "timestamp": 1599148549
    },
    {
        "content": "<p>Can you do that at compile time?</p>",
        "id": 208989059,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599148574
    },
    {
        "content": "<p><a href=\"https://github.com/Gilnaa/memoffset#usage-in-constants\">https://github.com/Gilnaa/memoffset#usage-in-constants</a></p>",
        "id": 208989388,
        "sender_full_name": "simulacrum",
        "timestamp": 1599148681
    },
    {
        "content": "<p>Fair enough. I suppose with enough macro magic you can get that to tell you the exact layout, although only for structs that are currently being defined or where you otherwise have an exhaustive list of struct fields, which means <code>derive</code> macros but not reflection on type expressions.</p>",
        "id": 208991500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599149492
    },
    {
        "content": "<p>I think one of the simplifying premises of Rust is that if you type code into a file, you get to do whatever you want to that code, notionally. But if you don't change the code in a file, then code changed in another file, can't break some aspects of how that file worked, at least not easily. This, for example, makes code review possible, because I don't have to worry about the behavior of the code in file x changing while reviewing code in file y.</p>",
        "id": 208991975,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599149683
    },
    {
        "content": "<p>All of your privacy problems are solved by copying file x into x_prime and changing x_prime. I prefer this solution because it's tedious and noticeable in a code review, etc.</p>",
        "id": 208992446,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599149907
    },
    {
        "content": "<p>I want to reiterate that privacy invasion is just like unsafe code here</p>",
        "id": 208992508,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599149931
    },
    {
        "content": "<p>you have to think globally about unsafe code</p>",
        "id": 208992531,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599149945
    },
    {
        "content": "<p>there's the old \"tootsie-pop\" model for unsafe code, roughly at the module boundary</p>",
        "id": 208992618,
        "sender_full_name": "cuviper",
        "timestamp": 1599149983
    },
    {
        "content": "<p>and that continues to hold here</p>",
        "id": 208992712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150008
    },
    {
        "content": "<p>no, privacy invasion makes it a cross-crate concern</p>",
        "id": 208992786,
        "sender_full_name": "cuviper",
        "timestamp": 1599150033
    },
    {
        "content": "<p>crate A is verified correct wrt all of A's code and nothing more. crate B that is a friend of A is verified with respect to the code of A and the interface of C (which it does not invade), and is verified correct wrt its own module boundary</p>",
        "id": 208992898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150079
    },
    {
        "content": "<p>I'm not actually interested in the theory of privacy invasion being equivalent to other unsafe code. The thing I'm interested in is whether privacy invasion is a tool that has a useful cost benefit analysis in practice, as used by humans.</p>",
        "id": 208992931,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150096
    },
    {
        "content": "<p>And unfortunately, I suspect that the answer is, no.</p>",
        "id": 208992958,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150112
    },
    {
        "content": "<p>Its main usefulness is in panic patches</p>",
        "id": 208992973,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150121
    },
    {
        "content": "<p>Local dependencies solve that.</p>",
        "id": 208993075,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150155
    },
    {
        "content": "<p>Just fine.</p>",
        "id": 208993085,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150159
    },
    {
        "content": "<p>where making a copy of large swaths of the dependencies in order to patch one function is not an option</p>",
        "id": 208993119,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150169
    },
    {
        "content": "<p>I'm not even sure what the upper bound on the amount of copying to be done is. Do you really find that to be a viable strategy?</p>",
        "id": 208993332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150240
    },
    {
        "content": "<p>The prospect of setting up my own mini <a href=\"http://crates.io\">crates.io</a> on my computer is quite daunting and I don't know a good reference for how to do it</p>",
        "id": 208993495,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150291
    },
    {
        "content": "<p>I'm honestly not sure how invading privacy even helps with patching bugs in dependencies. Accessing their fields doesn't change the code the functions in the library run.</p>",
        "id": 208993527,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150299
    },
    {
        "content": "<p>well I'm thinking here to add a new function that needs access to internals</p>",
        "id": 208993609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150325
    },
    {
        "content": "<p>or expose a private function that should have just been unsafe public</p>",
        "id": 208993712,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150352
    },
    {
        "content": "<p>extension methods of course could find lots of use for accessing internals</p>",
        "id": 208993898,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150424
    },
    {
        "content": "<p>But that's not fixing a bug, that's you wanting control that the library author didn't give you.</p>",
        "id": 208994028,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150468
    },
    {
        "content": "<p>Those aren't equivalent things.</p>",
        "id": 208994096,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150484
    },
    {
        "content": "<p>no, they are separate applications</p>",
        "id": 208994206,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150526
    },
    {
        "content": "<p>I'm really glad that Rust's privacy is what it is. The alternative is Ruby's monkeypatching.</p>",
        "id": 208994240,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150538
    },
    {
        "content": "<p>Monkeypatching is problematic for performance reasons</p>",
        "id": 208994299,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150562
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208993495\">said</a>:</p>\n<blockquote>\n<p>The prospect of setting up my own mini <a href=\"http://crates.io\">crates.io</a> on my computer is quite daunting and I don't know a good reference for how to do it</p>\n</blockquote>\n<p>There's no need to do this AIUI, you can patch a dependency with a local copy at the final crate level and have it take effect for all dependent crates provided the versions hold.</p>",
        "id": 208994308,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599150564
    },
    {
        "content": "<p>Which seems to be what you're advocating and I don't like that direction.</p>",
        "id": 208994313,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150564
    },
    {
        "content": "<p>(Which is another reason why pinning dependencies to a fixed version is a bad idea)</p>",
        "id": 208994361,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599150582
    },
    {
        "content": "<p>It's problematic because the behavior of a library changes without an obvious change to the library.</p>",
        "id": 208994444,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150603
    },
    {
        "content": "<p>Is there no amount of klaxons that are sufficient to make it obvious?</p>",
        "id": 208994503,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150636
    },
    {
        "content": "<p>I didn't say it had to be silent</p>",
        "id": 208994599,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150680
    },
    {
        "content": "<p>All of the klaxons I want would involve typing characters into files in that library.</p>",
        "id": 208994696,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150722
    },
    {
        "content": "<p>And if you can do that, then well... you can just copy it and you don't need them anyways.</p>",
        "id": 208994778,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150752
    },
    {
        "content": "<p>What if the code of the target library is on a network drive that you have no access to?</p>",
        "id": 208994790,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150756
    },
    {
        "content": "<p>these situations exist</p>",
        "id": 208994808,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150766
    },
    {
        "content": "<p>Great, I can't have a dependency I have no access to.</p>",
        "id": 208994828,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150776
    },
    {
        "content": "<p>So, I can't run it, so no problem.</p>",
        "id": 208994877,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150795
    },
    {
        "content": "<p>no write access</p>",
        "id": 208994892,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150806
    },
    {
        "content": "<p>Read access allows copying.</p>",
        "id": 208994946,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150832
    },
    {
        "content": "<p>this is what I meant by \"power imbalance\" earlier</p>",
        "id": 208995006,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150843
    },
    {
        "content": "<p>You can use <code>[patch.crates-io]</code> and <code>[replace]</code>.</p>",
        "id": 208995031,
        "sender_full_name": "bjorn3",
        "timestamp": 1599150857
    },
    {
        "content": "<p>what are these things?</p>",
        "id": 208995068,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150877
    },
    {
        "content": "<p>They allow you to override crates.</p>",
        "id": 208995101,
        "sender_full_name": "bjorn3",
        "timestamp": 1599150890
    },
    {
        "content": "<p>And this is what I meant by \"I like that it's tedious\" earlier. It's easy to see that it's happening and most importantly, it doesn't change the behavior of an existing library.</p>",
        "id": 208995131,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599150904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> <a href=\"https://doc.rust-lang.org/nightly/cargo/reference/overriding-dependencies.html\">https://doc.rust-lang.org/nightly/cargo/reference/overriding-dependencies.html</a></p>",
        "id": 208995252,
        "sender_full_name": "simulacrum",
        "timestamp": 1599150958
    },
    {
        "content": "<p>Aha, that does address a lot of the problems</p>",
        "id": 208995270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150962
    },
    {
        "content": "<p>so you don't have to make a mini <a href=\"http://crates.io\">crates.io</a>, just copy one crate</p>",
        "id": 208995351,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599150988
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">[patch.crates-io]</span>\n<span class=\"n\">cranelift-codegen</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"s\">&quot;./cranelift-codegen&quot;</span> <span class=\"p\">}</span>\n</code></pre></div>\n\n\n<p>Then everyone dependency that uses <code>cranelift-codegen</code> in a specific version will use <code>./cranelift-codegen</code> instead of the <a href=\"http://crates.io\">crates.io</a> version.</p>",
        "id": 208995376,
        "sender_full_name": "bjorn3",
        "timestamp": 1599150999
    },
    {
        "content": "<p>Yeah, that's what we've been pointing out the entire time. :)</p>",
        "id": 208995416,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1599151013
    },
    {
        "content": "<p>you still have to manage distribution this way though</p>",
        "id": 208995552,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151076
    },
    {
        "content": "<p>can this go in your crate?</p>",
        "id": 208995620,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151091
    },
    {
        "content": "<p>you cannot distribute on <a href=\"http://crates.io\">crates.io</a> with this, but that should basically never be necessary as you've said</p>",
        "id": 208995672,
        "sender_full_name": "simulacrum",
        "timestamp": 1599151115
    },
    {
        "content": "<p>So you would put this elsewhere in the repo, and use a relative path?</p>",
        "id": 208995714,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151142
    },
    {
        "content": "<p>you can build binary artifacts and deploy them to your servers to fix a zero day though, for example</p>",
        "id": 208995725,
        "sender_full_name": "simulacrum",
        "timestamp": 1599151146
    },
    {
        "content": "<p>sure, or in a github repository</p>",
        "id": 208995742,
        "sender_full_name": "simulacrum",
        "timestamp": 1599151155
    },
    {
        "content": "<p>(it supports overriding with any \"type\" of dependency)</p>",
        "id": 208995756,
        "sender_full_name": "simulacrum",
        "timestamp": 1599151167
    },
    {
        "content": "<p>aha, gotcha</p>",
        "id": 208995776,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151180
    },
    {
        "content": "<p>Put another way, it's a <a href=\"http://crates.io\">crates.io</a> restriction that you can't have relative path dependencies not a Rust or Cargo one.</p>",
        "id": 208995795,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599151191
    },
    {
        "content": "<p>can you have github deps?</p>",
        "id": 208995887,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151223
    },
    {
        "content": "<p>On <a href=\"http://crates.io\">crates.io</a>?</p>",
        "id": 208995906,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599151233
    },
    {
        "content": "<p>yeah</p>",
        "id": 208995914,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151238
    },
    {
        "content": "<p>I would guess not</p>",
        "id": 208995935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151247
    },
    {
        "content": "<p>I don't believe so because then you could have crates on <a href=\"http://crates.io\">crates.io</a> that are broken.</p>",
        "id": 208995953,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599151258
    },
    {
        "content": "<p>That's the reason for the policy.</p>",
        "id": 208995970,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599151264
    },
    {
        "content": "<p>are there crates on <a href=\"http://crates.io\">crates.io</a> that are forks of other crates? I don't think I've seen that</p>",
        "id": 208996045,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151296
    },
    {
        "content": "<p>There's no rule against it</p>",
        "id": 208996067,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599151308
    },
    {
        "content": "<p>you can publish anything to <a href=\"http://crates.io\">crates.io</a> (obviously, should comply with licensing etc)</p>",
        "id": 208996150,
        "sender_full_name": "simulacrum",
        "timestamp": 1599151330
    },
    {
        "content": "<p>I'm just a little surprised that there aren't more fork popularity wars on <a href=\"http://crates.io\">crates.io</a>, or maybe I just haven't noticed</p>",
        "id": 208996491,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151476
    },
    {
        "content": "<p>I don't really know :) I guess it seems like there <em>could</em> be but most people who want to fork rather than contribute upstream usually start their own thing rather than fork</p>",
        "id": 208996864,
        "sender_full_name": "simulacrum",
        "timestamp": 1599151636
    },
    {
        "content": "<p>So it sounds like this pretty much solves the \"I need to patch a dependency\" use case from up thread. Was that the main reason you wanted detailed layout information?</p>",
        "id": 208997057,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599151743
    },
    {
        "content": "<p>As <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> pointed out, the issues are somewhat orthogonal, but the combination of features seem to work well enough</p>",
        "id": 208997326,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599151863
    },
    {
        "content": "<p>It would not be enough for e.g. autogenerating a schema that describes all type layouts in the program for external consumption</p>",
        "id": 208997697,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152033
    },
    {
        "content": "<p>things like this are where you really want a proper layout query API</p>",
        "id": 208997830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152077
    },
    {
        "content": "<p>You would probably have enough for a serde-like interface to zero-copy serialization though</p>",
        "id": 208997980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152157
    },
    {
        "content": "<p>Such a schema will break as new layout optimizations are added. For example niche-filling in the past.</p>",
        "id": 208998088,
        "sender_full_name": "bjorn3",
        "timestamp": 1599152177
    },
    {
        "content": "<p>the idea is that a proper layout API would literally say \"I have a niche here\"</p>",
        "id": 208998132,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152203
    },
    {
        "content": "<p>and the library can do what it wants with that</p>",
        "id": 208998155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152222
    },
    {
        "content": "<p>-Zprint-type-sizes and similar will basically provide that</p>",
        "id": 208998188,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152233
    },
    {
        "content": "<p>but it's external, rather than a \"rust language API\"</p>",
        "id": 208998203,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152243
    },
    {
        "content": "<p>I think for that to be correct repr(Rust) needs to at least be deterministic</p>",
        "id": 208998256,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152276
    },
    {
        "content": "<p>Lets imagine we were having this conversation just before the niche-filling optimization was implemented. Now consider what would have happened if the layout API was introduced. Now suddenly we couldn't implement niche-filling anymore, as that would be a breaking change.</p>",
        "id": 208998355,
        "sender_full_name": "bjorn3",
        "timestamp": 1599152318
    },
    {
        "content": "<p>You could plan for it if the layout API previously had a function \"has a niche\" that always returns false, but it's true that the layout API would not be forward compatible if you didn't even have the concept before</p>",
        "id": 208998754,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152485
    },
    {
        "content": "<p>It need not be deterministic so long as it is consistent <em>within the compiled binary</em></p>",
        "id": 208998920,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152569
    },
    {
        "content": "<p>i.e., we do not reorder your fields at runtime</p>",
        "id": 208998937,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152576
    },
    {
        "content": "<p>which I would suspect we can basically RFC fairly easily today</p>",
        "id": 208998959,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152586
    },
    {
        "content": "<p>(and is just technically infeasible for current compilation model)</p>",
        "id": 208998983,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152598
    },
    {
        "content": "<p>Would <code>-Zprint-type-sizes</code> work with a two stage build? That is, the types are used to construct some data that should be accessible to the program, so you have to run it once and then get the types and then run it again with the type info</p>",
        "id": 208999230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152714
    },
    {
        "content": "<p>I would guess not, since that can obviously change the types in general, but it would be nice if there was some set of circumstances in which you could ensure that such a scheme would work</p>",
        "id": 208999376,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152768
    },
    {
        "content": "<p>I mean, you can check and if it did great</p>",
        "id": 208999425,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152793
    },
    {
        "content": "<p>it basically will</p>",
        "id": 208999436,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152797
    },
    {
        "content": "<p>how can you check?</p>",
        "id": 208999448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152801
    },
    {
        "content": "<p>...run twice and compare?</p>",
        "id": 208999456,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152808
    },
    {
        "content": "<p>That was the other half of my original complaint, that unsafe code can't assert the invariants it relies on</p>",
        "id": 208999524,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152843
    },
    {
        "content": "<p>Not all of them, but certainly some</p>",
        "id": 208999688,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152915
    },
    {
        "content": "<p>and generally speaking I would say that permitting asserting invariants is an active area of interest</p>",
        "id": 208999724,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152933
    },
    {
        "content": "<p>In the code I might want to say <code>static_assert_eq!(layout&lt;T&gt;(), Layout { size: 8, fields: [Field {name: \"foo\", offset: 4}] })</code> for example</p>",
        "id": 208999725,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152933
    },
    {
        "content": "<p>I can see why you'd want that. Reflection APIs seem generally useful :)</p>",
        "id": 208999797,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152973
    },
    {
        "content": "<p>(just making up some syntax)</p>",
        "id": 208999799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599152973
    },
    {
        "content": "<p>but are hard to get right</p>",
        "id": 208999808,
        "sender_full_name": "simulacrum",
        "timestamp": 1599152977
    },
    {
        "content": "<p>Using <code>offset_of</code> and <code>size_of</code> and code generation I think you can assert the broad strokes of a data type at compile time</p>",
        "id": 209000047,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599153067
    },
    {
        "content": "<p>yes, broadly so</p>",
        "id": 209000130,
        "sender_full_name": "simulacrum",
        "timestamp": 1599153099
    },
    {
        "content": "<p>so you could do a two stage build and at least do basic sanity checking of your info on the second run</p>",
        "id": 209000221,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599153129
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208998754\">said</a>:</p>\n<blockquote>\n<p>You could plan for it if the layout API previously had a function \"has a niche\" that always returns false, but it's true that the layout API would not be forward compatible if you didn't even have the concept before</p>\n</blockquote>\n<p>Which I think is the fundamental problem. There may be additional concepts we may wish to exploit for layout but unless we can enumerate all of them now we either accept the API could change in the future which I believe diminishes the usefulness of it or we accept that we cannot do those optimizations which feels like a bad tradeoff to me.</p>",
        "id": 209000739,
        "sender_full_name": "Wesley Wiser",
        "timestamp": 1599153355
    },
    {
        "content": "<p>It does seem like an unstable API by nature</p>",
        "id": 209000877,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599153403
    },
    {
        "content": "<p>We have had conversations about things like <code>repr(linear)</code> or similar before though</p>",
        "id": 209000880,
        "sender_full_name": "simulacrum",
        "timestamp": 1599153406
    },
    {
        "content": "<p>and unstable reflection APIs that permit getting at layout details  for structs seem not infeasible, with the perpetual unstableness hat</p>",
        "id": 209000917,
        "sender_full_name": "simulacrum",
        "timestamp": 1599153433
    },
    {
        "content": "<p>It could be selectively stabilized if and when people agree on stabilizing certain aspects of repr(Rust)</p>",
        "id": 209000943,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599153449
    },
    {
        "content": "<p>like <code>has_a_niche</code> could be stabilized when people agree that having a niche is a property types can possess (that depends only on the type and not the phase of the moon)</p>",
        "id": 209001229,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599153567
    },
    {
        "content": "<p>To some extent, sure</p>",
        "id": 209001587,
        "sender_full_name": "simulacrum",
        "timestamp": 1599153704
    },
    {
        "content": "<p>Like, if you wanted to propose this, the MCP route on the lang-team repo is the way to go, I think, though probably we need a project group and it feels like it's a major project and outside current priorities for lang team</p>",
        "id": 209001710,
        "sender_full_name": "simulacrum",
        "timestamp": 1599153738
    },
    {
        "content": "<p>and anything like my <code>layout&lt;T&gt;()</code> would be perpetually unstable because it purports to exhaustively enumerate all layout properties</p>",
        "id": 209001746,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599153755
    },
    {
        "content": "<p>especially because most of it can sort of be done, e.g., bindgen asserts type layouts are the same with offsetof! and similar</p>",
        "id": 209001771,
        "sender_full_name": "simulacrum",
        "timestamp": 1599153765
    },
    {
        "content": "<p>I should point out also that there is a good reason to stage things here: you can get into circularities like</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">arr</span>: <span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">layout</span>::<span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">().</span><span class=\"n\">get_field</span><span class=\"p\">(</span><span class=\"s\">&quot;arr&quot;</span><span class=\"p\">).</span><span class=\"n\">len</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 209004485,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599154985
    },
    {
        "content": "<p>Well, that's just another instance of existing const generic problems like <code>struct Foo([u8; size_of::&lt;Foo&gt;() + 1]);</code>.  Cycle detection always needs to handle that.</p>",
        "id": 209028419,
        "sender_full_name": "scottmcm",
        "timestamp": 1599166558
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208984622\">said</a>:</p>\n<blockquote>\n<p>Unsafe code is exactly as much a threat to the abstraction theorem as privacy invasion</p>\n</blockquote>\n<p>No, that's not true at all. unsafe code <a href=\"https://plv.mpi-sws.org/rustbelt/popl18/\">can be formally proven to be safe to use</a> and <em>that proof relies on abstraction</em> and thus privacy. In other words, unsafe code is only correct (\"sound\") if the ecosystem respects privacy. The only reason that <code>unsafe</code> doesn't break the Rust ecosystem is that we have working privacy! That's why I have such strong feelings on privacy.</p>\n<p>Yes, unsafe code <em>can</em> break privacy, we cannot avoid that. But it usually doesn't, and that is key for being able to write reliable software in Rust.</p>",
        "id": 209073100,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212311
    },
    {
        "content": "<p>Further unsafe code can break those boundaries. This does not invalidate your theorem</p>",
        "id": 209073431,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208992531\">said</a>:</p>\n<blockquote>\n<p>you have to think globally about unsafe code</p>\n</blockquote>\n<p>If that were true, it would be near impossible to write correct unsafe code. But lucky enough, through the power of abstraction, it is possible to reason locally about unsafe code. To give a concrete example, that ability to do local reasoning is <em>the only thing</em> that sets apart Rust's <code>Vec</code> from C++'s <code>std::vector</code>!</p>",
        "id": 209073438,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/209073431\">said</a>:</p>\n<blockquote>\n<p>Further unsafe code can break those boundaries. This does not invalidate your theorem</p>\n</blockquote>\n<p>unsound unsafe code can break everything. Sound unsafe code does not break abstraction boundaries.</p>",
        "id": 209073478,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212602
    },
    {
        "content": "<p>Unsafe code has proof obligations</p>",
        "id": 209073498,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212626
    },
    {
        "content": "<p>privacy breaking code also has proof obligations</p>",
        "id": 209073511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212638
    },
    {
        "content": "<p>with privacy, proof obligations can be discharged locally</p>",
        "id": 209073559,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212650
    },
    {
        "content": "<p>yes</p>",
        "id": 209073566,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212656
    },
    {
        "content": "<p>without privacy, they become a whole-program concern, impossible to manage</p>",
        "id": 209073570,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212659
    },
    {
        "content": "<p>Rust's safety story simply doesn't work without privacy.</p>",
        "id": 209073621,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212692
    },
    {
        "content": "<p>module A can be proven correct wrt module A's boundaries. Module B which invades module A is an extension of the theorem for module A, it might involve adapting the original proof, but it can still be proven with respect to module B's boundaries</p>",
        "id": 209073686,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212738
    },
    {
        "content": "<p>and anything that is not invaded can still be abstract</p>",
        "id": 209073695,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212748
    },
    {
        "content": "<p>so it's not nearly as dire as you propose</p>",
        "id": 209073716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212762
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/208985900\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Being able to access private fields puts a language firmly into the \"no abstractions\" camp. </p>\n</blockquote>\n<p>Actually, I'm not sure I buy this argument either, intuitive though it sounds at first. Suppose we're going for full correctness, and we've associated some logical proposition to the type invariant that is being protected by the API (for example, in a <code>Mutex</code> implementation we might have <code>Mutex&lt;T&gt;</code> representing <code>Lock(J)</code> and <code>MutexGuard&lt;'a, T&gt;</code> representing <code>J</code> where <code>J</code> is the property of the locked object we wish to preserve). In this case, \"a safe API\" means that we have theorems saying that the API operations preserve this balance between <code>Lock(J)</code> and <code>J</code> so as long as you only use the provided operations the invariant <code>J</code> is preserved one way or another. But, as the RustBelt paper points out, this kind of inductive invariant is brittle to alternative mechanisms that manage to preserve the invariant anyway without going through the API. What really matters is the invariant, not the API. The API is just an easy way to satisfy the conditions for the theorem</p>\n</blockquote>\n<p>I do not understand your argument here. But the API is what matters because it is the thing that actually manifests the abstraction barrier in code. The invariant is just a mathematical fiction that we put up to justify correctness of the API.</p>",
        "id": 209073759,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212771
    },
    {
        "content": "<p>you just entangled the correctness proof of A and B, so they become one proof</p>",
        "id": 209073806,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212815
    },
    {
        "content": "<p>The barrier is not the goal, correct code is the goal</p>",
        "id": 209073809,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212817
    },
    {
        "content": "<p>yes, they become one proof</p>",
        "id": 209073830,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212824
    },
    {
        "content": "<p>they become like one super-module</p>",
        "id": 209073850,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212832
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/209073809\">said</a>:</p>\n<blockquote>\n<p>The barrier is not the goal, correct code is the goal</p>\n</blockquote>\n<p>the only way we know to make code correct is to beak apart the correctness argument into small pieces and estabish abstarction barriers in between them</p>",
        "id": 209073873,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212846
    },
    {
        "content": "<p>the reason C/C++ fail is that they dont have proper abstraction barriers</p>",
        "id": 209073895,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212854
    },
    {
        "content": "<p>This is still something you can selectively apply</p>",
        "id": 209073929,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212871
    },
    {
        "content": "<p>proof complexity grows <em>much more than linear</em> with module size. it's probably more like exponential.</p>",
        "id": 209073937,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/209073929\">said</a>:</p>\n<blockquote>\n<p>This is still something you can selectively apply</p>\n</blockquote>\n<p>sure. ask module A owner to expose unsafe methods that let module B do these things.</p>",
        "id": 209073987,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212896
    },
    {
        "content": "<p>rather than one mega proof you have 10 separate proofs and one double-wide proof for a tricky bit</p>",
        "id": 209073998,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212905
    },
    {
        "content": "<p>we <em>already have</em> mechanism to selectively do this, with mutual consent of all modules involved</p>",
        "id": 209074001,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212907
    },
    {
        "content": "<p>without consent, this is a recipe for disaster</p>",
        "id": 209074040,
        "sender_full_name": "RalfJ",
        "timestamp": 1599212923
    },
    {
        "content": "<p>What is the privacy story when there are unsafe accessors?</p>",
        "id": 209074092,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212960
    },
    {
        "content": "<p>Or the correctness story, I mean</p>",
        "id": 209074104,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599212970
    },
    {
        "content": "<p>unsafe accessors have a proof obligation on their caller, carefully documented by module A, saying something like \"you need to make sure my library invariant is upheld\". so, they make the library invariant part of the API, and subject to stability promises.</p>",
        "id": 209074183,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213008
    },
    {
        "content": "<p>Right. The <em>exact same thing</em> applies with privacy invasion</p>",
        "id": 209074216,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213033
    },
    {
        "content": "<p>no</p>",
        "id": 209074223,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213037
    },
    {
        "content": "<p>you still have those same proof obligations to uphold</p>",
        "id": 209074230,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213044
    },
    {
        "content": "<p>you missed the part where I said \"the library invariant part of the API, and subject to stability promises\"</p>",
        "id": 209074244,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213053
    },
    {
        "content": "<p>that is currently not the case</p>",
        "id": 209074250,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213057
    },
    {
        "content": "<p>you need the invaded library to opt in to that</p>",
        "id": 209074263,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213066
    },
    {
        "content": "<p>just like it needs to <code>impl Copy for Type</code></p>",
        "id": 209074278,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213077
    },
    {
        "content": "<p>I don't follow</p>",
        "id": 209074309,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213103
    },
    {
        "content": "<p>I'm afraid I have to get back to work, sorry</p>",
        "id": 209074372,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213124
    },
    {
        "content": "<p>the point is that invasion <em>without consent by whom you are invading</em> is a disaster for the ecosystem</p>",
        "id": 209074400,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213146
    },
    {
        "content": "<p>I am not sure if you are still arguing for \"general invasion into all the things\", if yes, then -- see all of the above for why that is a problem</p>",
        "id": 209074440,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213181
    },
    {
        "content": "<p>If we could somehow better document the invariants, this could be done in a correctness preserving way</p>",
        "id": 209074449,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213184
    },
    {
        "content": "<p>if no, then -- we dont need a new language feature for that</p>",
        "id": 209074458,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213193
    },
    {
        "content": "<p>even if we could, not all lib authors will want to commit to their invariants being <em>stable</em>. a key feature of abstraction is that you ca change implementation details and nobody notices.</p>",
        "id": 209074492,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/209074449\">said</a>:</p>\n<blockquote>\n<p>If we could somehow better document the invariants, this could be done in a correctness preserving way</p>\n</blockquote>\n<p>if by \"document\" you mean \"have the compiler check and enforce them\", sure... at that point we are turning Rust into a theorem prover though. Which it did not want to be, that's why it has <code>unsafe</code>.</p>",
        "id": 209074571,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213289
    },
    {
        "content": "<p>I agree that library invariants are not likely to be stable, which is why privacy invasion usually means that you can't safely make semver-compatible upgrades</p>",
        "id": 209074578,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213292
    },
    {
        "content": "<p>I would love it if rust were a theorem prover :)</p>",
        "id": 209074596,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/209074596\">said</a>:</p>\n<blockquote>\n<p>I would love it if rust were a theorem prover :)</p>\n</blockquote>\n<p>so would I. but then nobody would be able to use it.^^</p>",
        "id": 209074624,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213329
    },
    {
        "content": "<p>maybe in a decade or 3 we have the tech to make theorem proving accessible to people without a CS degree. but right now, we do not, so Rust made a great call here.</p>",
        "id": 209074661,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/209074578\">said</a>:</p>\n<blockquote>\n<p>I agree that library invariants are not likely to be stable, which is why privacy invasion usually means that you can't safely make semver-compatible upgrades</p>\n</blockquote>\n<p>given that much of Rust is based on the concept that you <em>can</em> always make semver-compatible updates (\"stability without stagnation\"), this alone is already a dealbreaker</p>",
        "id": 209074790,
        "sender_full_name": "RalfJ",
        "timestamp": 1599213433
    },
    {
        "content": "<p>Fair enough. My view on privacy is that if you have correctness, privacy is useless cruft. <code>unsafe</code> already satisfies all of the needs of guarding theorem statements without privacy</p>",
        "id": 209074844,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213481
    },
    {
        "content": "<p>it just looks like OO throwback to me</p>",
        "id": 209074933,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213539
    },
    {
        "content": "<p>What about a rust compiler flag that turns off all privacy guards? That would be enough for panic patches</p>",
        "id": 209074997,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213601
    },
    {
        "content": "<p>It would also permanently exile you from <a href=\"http://crates.io\">crates.io</a>, so there are no dependency problems</p>",
        "id": 209075071,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213636
    },
    {
        "content": "<p>Ah, actually you need more than <code>unsafe</code> to replace privacy, you also need <code>unstable</code> markers for internals</p>",
        "id": 209075280,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213800
    },
    {
        "content": "<p>but if something is both unsafe and unstable to access, it seems you are pretty well covered when it comes to changing it and possibly breaking someone's code</p>",
        "id": 209075403,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599213866
    },
    {
        "content": "<p>Anyway, I've made enough ruckus for now. Thanks to everyone who was patient enough to respond, I promise I won't publish any crates with horrible hacks such as I've described</p>",
        "id": 209075610,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599214021
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status/near/209074933\">said</a>:</p>\n<blockquote>\n<p>it just looks like OO throwback to me</p>\n</blockquote>\n<p>I'm going to be the first to join you in saying that the benefits of OO are vastly overstated... but IMO Rust copied some of the best parts of OO, which are interfaces (<code>trait</code>) and modularity through privacy. It left behind things that just don't work well most of the time, like inheritance. Looks like we disagree on which parts of OO are worth keeping and which are not. ;)</p>\n<p>If you want to hear more about the importance of abstraction (and, by extension, privacy) based on principled formal foundations, I can recommend <a href=\"https://www.youtube.com/watch?v=8Xyk_dGcAwk\">this talk</a> by my PhD advisor.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"8Xyk_dGcAwk\" href=\"https://www.youtube.com/watch?v=8Xyk_dGcAwk\"><img src=\"https://i.ytimg.com/vi/8Xyk_dGcAwk/default.jpg\"></a></div>",
        "id": 209081623,
        "sender_full_name": "RalfJ",
        "timestamp": 1599218577
    },
    {
        "content": "<p>In particular I'd argue that reflection (aka invading privacy of others) is one of those things that we should <em>not</em> copy from OO -- something that even Java realized with version 9. ;)</p>",
        "id": 209083415,
        "sender_full_name": "RalfJ",
        "timestamp": 1599219886
    },
    {
        "content": "<p>The idea of abstraction is a nice one, but it seems to come from the same mythos of functional programming that the computer doesn't matter and we can idealize its behavior away, and that's where I get off the bus. Rust is a great language <em>because</em> it combines the careful attention to computational lowering from C and C++ as well as the attention to program semantics from functional languages. Reflection is the idea that the program we write is observable, it is bits that execute on a real machine; we can look at states of the turing machine that is our code and act on it. All macro code works from this premise. Lisps did this the best, with code = data, but they neglect the compile/run time phase distinction so high performance is off the table.</p>\n<p>I want a language that can do all these things. Does that mean I have to write Python that writes C++? Please no.</p>",
        "id": 209085713,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599221369
    },
    {
        "content": "<p>(Anyway, these are only my opinions at this point. Just so you know where I'm coming from.)</p>",
        "id": 209086307,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1599221745
    }
]