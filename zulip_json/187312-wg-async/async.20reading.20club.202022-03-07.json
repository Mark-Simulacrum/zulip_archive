[
    {
        "content": "<p>Hey <span class=\"user-group-mention\" data-user-group-id=\"1172\">@WG-async-foundations</span> !</p>",
        "id": 274414658,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669852
    },
    {
        "content": "<p>I was getting ready to send a message :)</p>",
        "id": 274414765,
        "sender_full_name": "tmandry",
        "timestamp": 1646669886
    },
    {
        "content": "<p>The plan for today was to do our first session of the <a href=\"https://hackmd.io/6kSbmyggT6eAy5uvdB6srA?view\">Async Reading Club</a>, right?</p>",
        "id": 274414769,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669886
    },
    {
        "content": "<p>To that end, let me review the way we expected this to go...</p>",
        "id": 274414807,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669904
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274414658\">said</a>:</p>\n<blockquote>\n<p>Hey <span class=\"user-group-mention silent\" data-user-group-id=\"1172\">WG-async-foundations</span> !</p>\n</blockquote>\n<p>also, we need to rename that alias</p>",
        "id": 274414821,
        "sender_full_name": "tmandry",
        "timestamp": 1646669912
    },
    {
        "content": "<p>first off, please <span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> on the top message to show you're around</p>",
        "id": 274414844,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669920
    },
    {
        "content": "<p>second, today's reading is <a href=\"https://blog.yoshuawuyts.com/async-cancellation-1/\">async cancellation I</a> by our very own <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> <span aria-label=\"clap\" class=\"emoji emoji-1f44f\" role=\"img\" title=\"clap\">:clap:</span> <span aria-label=\"clap\" class=\"emoji emoji-1f44f\" role=\"img\" title=\"clap\">:clap:</span> <span aria-label=\"clap\" class=\"emoji emoji-1f44f\" role=\"img\" title=\"clap\">:clap:</span></p>",
        "id": 274414904,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669944
    },
    {
        "content": "<p>the idea is that we will read for \"a while\" and then chat about it afterwards</p>",
        "id": 274414950,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669967
    },
    {
        "content": "<p>I figure we can keep track of who is still reading by adding emoji to a message</p>",
        "id": 274414976,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669980
    },
    {
        "content": "<p>the expected alloc was 15 minutes to read, 30 minutes to chat</p>",
        "id": 274414996,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669990
    },
    {
        "content": "<p>but we can extend the reading time as needed</p>",
        "id": 274415009,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646669997
    },
    {
        "content": "<p>questions?</p>",
        "id": 274415034,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646670002
    },
    {
        "content": "<p>Hah, I think I assumed folks would read in advance, and this meeting was just for discussion!</p>",
        "id": 274415130,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646670042
    },
    {
        "content": "<p>I don't believe in homework</p>",
        "id": 274415147,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646670055
    },
    {
        "content": "<p>by which I mean \"nobody ever does it\" :)</p>",
        "id": 274415160,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646670062
    },
    {
        "content": "<p>In case anyone finishes reading sooner, I started work on a follow-up today: <a href=\"https://hackmd.io/xoKN8luWTcSKw5kJfNLJ5Q?view\">https://hackmd.io/xoKN8luWTcSKw5kJfNLJ5Q?view</a></p>",
        "id": 274415175,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646670070
    },
    {
        "content": "<p>To signal you are reading, please add the <span aria-label=\"book\" class=\"emoji emoji-1f4d6\" role=\"img\" title=\"book\">:book:</span> emoji to this message. To signal you're done, add the <span aria-label=\"checkbox\" class=\"emoji emoji-2611\" role=\"img\" title=\"checkbox\">:checkbox:</span> emoji.</p>",
        "id": 274415201,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646670082
    },
    {
        "content": "<p>it's been 15 minutes-- I'm still reading a bit</p>",
        "id": 274418047,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646670931
    },
    {
        "content": "<p>seems like 2 others are too</p>",
        "id": 274418060,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646670934
    },
    {
        "content": "<p>5 more minutes?</p>",
        "id": 274418116,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646670960
    },
    {
        "content": "<p>Already this is reminding me of the classic \"cancellation of a non-cancel-safe future\" in a <code>select!</code> statement. I fixed one literally on friday (fortunately not exploitable), having an <code>Async</code> trait that the future that was being selected did not implement would have caught it earlier!</p>",
        "id": 274418254,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646671002
    },
    {
        "content": "<p>ok, I'm done now</p>",
        "id": 274419031,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671313
    },
    {
        "content": "<p>and it's been 5 minutes</p>",
        "id": 274419048,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671320
    },
    {
        "content": "<p>shall we chat?</p>",
        "id": 274419095,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671325
    },
    {
        "content": "<p>I have a question for <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span></p>",
        "id": 274419164,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671359
    },
    {
        "content": "<p>Yeah for sure!</p>",
        "id": 274419178,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671365
    },
    {
        "content": "<p>the post talks about challenges caused by manual implementations of <code>Future</code></p>",
        "id": 274419209,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671378
    },
    {
        "content": "<p>I'm curious what challenges you are thinking of; it's not obvious to me why manual impls would be more-or-less robust than async-await based code</p>",
        "id": 274419262,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671404
    },
    {
        "content": "<p>in particular, I would expect that (either way) all state that must be stored across a poll finds its way into <code>self</code>, which is dropped</p>",
        "id": 274419305,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671426
    },
    {
        "content": "<p>Yes, that makes sense</p>",
        "id": 274419440,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671466
    },
    {
        "content": "<p>the challenging cases (for both of them, in my mind) come about when there is no destructor to run, and the expectation is that something will happen because the \"state machine\" will take us to a state where it occurs</p>\n<p>e.g.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">activate</span><span class=\"o\">&lt;</span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">R</span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">active</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// in sync code, this would be a `FnOnce()`</span>\n<span class=\"w\">    </span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">active</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kc\">false</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">result</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274419544,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671509
    },
    {
        "content": "<p>right that's true</p>",
        "id": 274419628,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671548
    },
    {
        "content": "<p>I think what I meant there is that writing state machines by hand is hard</p>",
        "id": 274419739,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671575
    },
    {
        "content": "<p>no argument there :)</p>",
        "id": 274419770,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671589
    },
    {
        "content": "<p>So you have to be extra extra extra careful about your assumptions; especially when e.g. modifying non-local state (state which outlives the existence of the future)</p>",
        "id": 274419849,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671616
    },
    {
        "content": "<p>one thing I thought was interesting was talking about <em>why</em> one might want to \"catch\" a cancellation; it seems like that question also depends on why cancellations are occurring in the first place</p>",
        "id": 274419904,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671646
    },
    {
        "content": "<p>I've seen two (maybe 3, depending on how you count) general patterns</p>",
        "id": 274419965,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671673
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> So I try and answer that in more detail in the follow-up post: <a href=\"https://hackmd.io/xoKN8luWTcSKw5kJfNLJ5Q?view#Async-Cancellation-vs-Other-Halts\">https://hackmd.io/xoKN8luWTcSKw5kJfNLJ5Q?view#Async-Cancellation-vs-Other-Halts</a>; I actually don't think we ever want to \"catch\" cancellations.</p>",
        "id": 274420050,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671694
    },
    {
        "content": "<p>one is basically \"client dropped their side of the connection\" (or, similarly, timed out) -- then you just want to tear down everything related to that client</p>",
        "id": 274420084,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671707
    },
    {
        "content": "<p>I agree that \"catching\" isn't likely what you want, though you do want to \"recover\"</p>",
        "id": 274420164,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671741
    },
    {
        "content": "<p>\"cancellations\" are something you call / opt into. As opposed to \"errors/panics\" which you need to guard against or \"catch\".</p>",
        "id": 274420227,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671767
    },
    {
        "content": "<p>Talking about catching a cancellation always feels backwards to me. Catching in the contexts of exceptions means catching an exception that came from down the stack, while async cancellation comes from up the stack.</p>",
        "id": 274420276,
        "sender_full_name": "eholk",
        "timestamp": 1646671796
    },
    {
        "content": "<p>I guess that sounds different than the example you're providing; so I think we may be looking at it differently. I would assume that if a client unexpectedly hangs up, that would be a state represented by <code>io::Result</code>?</p>",
        "id": 274420415,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671845
    },
    {
        "content": "<p>another reason that people use cancellation, e.g. the reason highlighted in <a href=\"https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c\">tomaka's blog post</a>), seems to be about \"interrupts\". tokio's mini-redis serve also has this pattern:</p>\n<p><a href=\"https://github.com/tokio-rs/mini-redis/blob/6513e5226c2cfe1108cb89de009c29fe756d436a/src/cmd/subscribe.rs#L127-L137\">https://github.com/tokio-rs/mini-redis/blob/6513e5226c2cfe1108cb89de009c29fe756d436a/src/cmd/subscribe.rs#L127-L137</a></p>",
        "id": 274420419,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274420415\">said</a>:</p>\n<blockquote>\n<p>I guess that sounds different than the example you're providing; so I think we may be looking at it differently. I would assume that if a client unexpectedly hangs up, that would be a state represented by <code>io::Result</code>?</p>\n</blockquote>\n<p>well, it may first be detected that way</p>",
        "id": 274420473,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671880
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274420419\">said</a>:</p>\n<blockquote>\n<p>another reason that people use cancellation, e.g. the reason highlighted in <a href=\"https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c\">tomaka's blog post</a>), seems to be about \"interrupts\". tokio's mini-redis serve also has this pattern:</p>\n</blockquote>\n<p>(I feel that this is not desirable, to be clear)</p>",
        "id": 274420532,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671908
    },
    {
        "content": "<p>I think we need a better primitive here, this is basically a missing \"run these two things concurrently\" primitive; something like scoped spawn would be ideal</p>",
        "id": 274420608,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671929
    },
    {
        "content": "<p>I'm not sure I understand the \"interrupts\" analogy?</p>",
        "id": 274420628,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646671939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274420415\">said</a>:</p>\n<blockquote>\n<p>I guess that sounds different than the example you're providing; so I think we may be looking at it differently. I would assume that if a client unexpectedly hangs up, that would be a state represented by <code>io::Result</code>?</p>\n</blockquote>\n<p>it'd probably be good to talk through the expected workflow for a case like this in detail, agreed</p>",
        "id": 274420632,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671940
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274420628\">said</a>:</p>\n<blockquote>\n<p>I'm not sure I understand the \"interrupts\" analogy?</p>\n</blockquote>\n<p>what happens in that snippet is:</p>\n<ul>\n<li>one future processes frames in a kind of loop</li>\n<li>another future waits for a message to arrive</li>\n</ul>\n<p>there is a select of the two</p>\n<p>if a message arrives, it will cancel the first and immediate respond to that message</p>",
        "id": 274420727,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671975
    },
    {
        "content": "<p>the code is written to be \"halt-\" or \"cancel-safe\", so that canceling it doesn't lose work</p>",
        "id": 274420756,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646671989
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274420419\">said</a>:</p>\n<blockquote>\n<p>another reason that people use cancellation, e.g. the reason highlighted in <a href=\"https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c\">tomaka's blog post</a>), seems to be about \"interrupts\". tokio's mini-redis serve also has this pattern:</p>\n<p><a href=\"https://github.com/tokio-rs/mini-redis/blob/6513e5226c2cfe1108cb89de009c29fe756d436a/src/cmd/subscribe.rs#L127-L137\">https://github.com/tokio-rs/mini-redis/blob/6513e5226c2cfe1108cb89de009c29fe756d436a/src/cmd/subscribe.rs#L127-L137</a></p>\n</blockquote>\n<p>Both those examples seem to rely heavily on <code>select! {}</code>. I wrote <a href=\"https://blog.yoshuawuyts.com/futures-concurrency-3/\">a post</a> recently dissecting <code>select! {}</code> and its issues. I'd be interested in seeing examples that don't use <code>select! {}</code>.</p>",
        "id": 274420758,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646671990
    },
    {
        "content": "<p>I personally think select <em>and select-like</em> APIs are key to the failure modes here</p>",
        "id": 274420811,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672014
    },
    {
        "content": "<p>it's easy to construct a similar example from <code>race</code></p>",
        "id": 274420829,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672023
    },
    {
        "content": "<p>but it looks a bit more...semantically fishy :)</p>",
        "id": 274420861,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672034
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">while</span><span class=\"w\"> </span><span class=\"n\">not_done</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">process_low_priority_message</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"n\">race</span><span class=\"p\">(</span><span class=\"n\">process_higher_priority_message</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274420967,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672066
    },
    {
        "content": "<p>to be clear on what I'm saying, I am not saying \"look, you can mis-use race, therefore cancellation is broken\"</p>",
        "id": 274421035,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672096
    },
    {
        "content": "<p>I think in general, the reason a future wants to catch a cancellation is because cancellation is very abrupt, you can't prepare for it. Therefore, the future might want to tidy up its resources in a more predictable way. This is somewhat analogous to panicking where we assume that panicking leaves the thread in an inconsistent state (thus mutex poisoning, etc), but since cancellation doesn't kill the thread, people want some opportunity to get back to a consistent state</p>",
        "id": 274421062,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646672106
    },
    {
        "content": "<p>I'm saying \"race is probably a better abstraction, because it's clearer about its purpose, and it's more obvious that the above code is broken\"</p>",
        "id": 274421064,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274421062\">said</a>:</p>\n<blockquote>\n<p>I think in general, the reason a future wants to catch a cancellation is because cancellation is very abrupt, you can't prepare for it. Therefore, the future might want to tidy up its resources in a more predictable way. This is somewhat analogous to panicking where we assume that panicking leaves the thread in an inconsistent state (thus mutex poisoning, etc), but since cancellation doesn't kill the thread, people want some opportunity to get back to a consistent state</p>\n</blockquote>\n<p>right, and one question I have is how much async-drop changes the calculus here</p>",
        "id": 274421130,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672137
    },
    {
        "content": "<p>I think that forced, synchronous cancellation is not great</p>",
        "id": 274421150,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672144
    },
    {
        "content": "<p>the other question is how much things like scope do, because examples like the one I gave (<code>self.active = false</code>) don't matter if <code>self</code> itself will get torn down</p>",
        "id": 274421259,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672172
    },
    {
        "content": "<p>async drop seems less than a complete solution, for IO in particular, you cancel because you don't want to wait, but async drop would still block the task</p>",
        "id": 274421307,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646672196
    },
    {
        "content": "<p>(but that in turn comes back to why we are using cancellation)</p>",
        "id": 274421323,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274421062\">said</a>:</p>\n<blockquote>\n<p>I think in general, the reason a future wants to catch a cancellation is because cancellation is very abrupt, you can't prepare for it. Therefore, the future might want to tidy up its resources in a more predictable way. This is somewhat analogous to panicking where we assume that panicking leaves the thread in an inconsistent state (thus mutex poisoning, etc), but since cancellation doesn't kill the thread, people want some opportunity to get back to a consistent state</p>\n</blockquote>\n<p>I guess I don't understand what this means?</p>",
        "id": 274421347,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646672216
    },
    {
        "content": "<p>things like select give no reason at all; this like race are a bit better, but I could see them being vulnerable to the bugs I talked about</p>",
        "id": 274421366,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672224
    },
    {
        "content": "<p>e.g., </p>\n<p><code>with_flag_set(do_the_thing()).race(other_thing()).await</code></p>\n<p>the <code>with_flag_set</code> method needs to use some kind of destructor to \"unset\" the flag</p>",
        "id": 274421451,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672259
    },
    {
        "content": "<p>\"I guess I don't understand what this means?\" - which part?</p>",
        "id": 274421459,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646672262
    },
    {
        "content": "<p>in any case, we're approaching time--</p>",
        "id": 274421552,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672293
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274421459\">said</a>:</p>\n<blockquote>\n<p>\"I guess I don't understand what this means?\" - which part?</p>\n</blockquote>\n<p>I guess I don't understand what people say with \"catching a cancellation\" <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 274421566,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646672296
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> should we throw your hackmd on the list of future reads?</p>",
        "id": 274421603,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672312
    },
    {
        "content": "<p>(I think I'm having a hard time articulating it over text)</p>",
        "id": 274421623,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646672320
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I can probably work it into a full post. <a href=\"https://blog.yoshuawuyts.com/futures-concurrency-3/\">https://blog.yoshuawuyts.com/futures-concurrency-3/</a> might be a better one to add to it first.</p>",
        "id": 274421674,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646672341
    },
    {
        "content": "<p>One of the things I find challenging about cancellation is that there are different vantage points you can look at it from, and I'm not sure we've categorized all these.</p>",
        "id": 274421687,
        "sender_full_name": "eholk",
        "timestamp": 1646672344
    },
    {
        "content": "<p>I want to emphasize that I think the goal of these async reading clubs is <em>mostly</em> to have us all reading things and sparking conversation, I imagine most of the interesting conversation will occur in follow-ups, so perhaps <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> and <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> you can continue this afterwards</p>",
        "id": 274421720,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672357
    },
    {
        "content": "<p>but one thing I would like to do before we hit the hour mark</p>",
        "id": 274421753,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672370
    },
    {
        "content": "<p>is to select what we'll read in 2 weeks!</p>",
        "id": 274421766,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672375
    },
    {
        "content": "<p>Like, there's cancellation from the view of a future that is at a <code>.await</code> point and no one polls them, and there's cancellation from the view of the runtime, etc.</p>",
        "id": 274421803,
        "sender_full_name": "eholk",
        "timestamp": 1646672398
    },
    {
        "content": "<p>looks like we should add \"Futures concurrency 3\" to the list</p>",
        "id": 274421897,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672409
    },
    {
        "content": "<p><a href=\"https://hackmd.io/6kSbmyggT6eAy5uvdB6srA?view\">https://hackmd.io/6kSbmyggT6eAy5uvdB6srA?view</a></p>",
        "id": 274421915,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672412
    },
    {
        "content": "<p>I propose</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://perchance.org/emoji\">Random emoji</a></th>\n<th>Document</th>\n<th>Added to list by</th>\n<th>Why?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span aria-label=\"peach\" class=\"emoji emoji-1f351\" role=\"img\" title=\"peach\">:peach:</span></td>\n<td><a href=\"https://www.ncameron.org/blog/async-read-and-write-traits/\">Async I/O traits</a></td>\n<td>nikomatsakis</td>\n<td>Key output of one of our groups</td>\n</tr>\n</tbody>\n</table>\n<p>?</p>",
        "id": 274422080,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672463
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274421566\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274421459\">said</a>:</p>\n<blockquote>\n<p>\"I guess I don't understand what this means?\" - which part?</p>\n</blockquote>\n<p>I guess I don't understand what people say with \"catching a cancellation\" <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>\n</blockquote>\n<p>Some kind of hook so that a future can take action in the event of cancellation. I imagine something like <code>defer</code> but only called on cancellation, rather than on every exit. Or something like that.</p>",
        "id": 274422110,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646672470
    },
    {
        "content": "<p>would it be crazy to add <a href=\"https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c\">https://tomaka.medium.com/a-look-back-at-asynchronous-rust-d54d63934a1c</a> to the list? I feel like that brings up a couple interesting things</p>",
        "id": 274422187,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646672503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274422080\">said</a>:</p>\n<blockquote>\n<p>I propose</p>\n<table>\n<thead>\n<tr>\n<th><a href=\"https://perchance.org/emoji\">Random emoji</a></th>\n<th>Document</th>\n<th>Added to list by</th>\n<th>Why?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span aria-label=\"peach\" class=\"emoji emoji-1f351\" role=\"img\" title=\"peach\">:peach:</span></td>\n<td><a href=\"https://www.ncameron.org/blog/async-read-and-write-traits/\">Async I/O traits</a></td>\n<td>nikomatsakis</td>\n<td>Key output of one of our groups</td>\n</tr>\n</tbody>\n</table>\n<p>?</p>\n</blockquote>\n<p>I have read it but wfm</p>",
        "id": 274422207,
        "sender_full_name": "tmandry",
        "timestamp": 1646672512
    },
    {
        "content": "<p>nope, feel free <span class=\"user-mention\" data-user-id=\"257428\">@Gus Wynn</span></p>",
        "id": 274422217,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672515
    },
    {
        "content": "<p>but also, <span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> 's point that we haven't actually fully categorized what cancellation IS is a good one</p>",
        "id": 274422306,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646672531
    },
    {
        "content": "<p>yes, I think a good idea would be to have more blog posts exploring that</p>",
        "id": 274422329,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672541
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> Ohh, right yeah! I guess right now we have that in the form of <code>Drop</code> / drop guards. But something like an \"async drop\" / <code>defer</code> / \"async <code>defer</code>\" might make that easier.</p>",
        "id": 274422350,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646672547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274422207\">said</a>:</p>\n<blockquote>\n<p>I have read it but wfm</p>\n</blockquote>\n<p>other suggestions?</p>",
        "id": 274422377,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672557
    },
    {
        "content": "<p>Maybe <a href=\"https://blog.yoshuawuyts.com/async-overloading/\">https://blog.yoshuawuyts.com/async-overloading/</a> ?</p>",
        "id": 274422479,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646672595
    },
    {
        "content": "<p>(side note, I should probably remove the \"random emoji\" entry :)</p>",
        "id": 274422484,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672598
    },
    {
        "content": "<p>(sorry to be tooting my own horn here)</p>",
        "id": 274422498,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646672603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274422479\">said</a>:</p>\n<blockquote>\n<p>Maybe <a href=\"https://blog.yoshuawuyts.com/async-overloading/\">https://blog.yoshuawuyts.com/async-overloading/</a> ?</p>\n</blockquote>\n<p>that could be a good one, yes</p>",
        "id": 274422507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672605
    },
    {
        "content": "<p>it does seem like an imp't thing for us to be discussing, but it's also a <em>bit</em> further out</p>",
        "id": 274422539,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672616
    },
    {
        "content": "<p>which I like</p>",
        "id": 274422550,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672620
    },
    {
        "content": "<p>i.e., I intend to read the async I/O traits sooner too :)</p>",
        "id": 274422563,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672626
    },
    {
        "content": "<p>let's do that!</p>",
        "id": 274422594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672637
    },
    {
        "content": "<p>sounds good</p>",
        "id": 274422695,
        "sender_full_name": "tmandry",
        "timestamp": 1646672667
    },
    {
        "content": "<p>on the topic of tooting one's own horn, if folks haven't read it, I also wrote <a href=\"https://smallcultfollowing.com/babysteps//blog/2022/01/27/panics-vs-cancellation-part-1/\">panics vs cancellation, part 1</a>, and I've got some other parts upcoming...</p>",
        "id": 274422753,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672684
    },
    {
        "content": "<p>I added it to the list too</p>",
        "id": 274423040,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672783
    },
    {
        "content": "<p>thanks all!</p>",
        "id": 274423089,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672803
    },
    {
        "content": "<p>this was fun :)</p>",
        "id": 274423099,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1646672807
    },
    {
        "content": "<p>thanks!</p>",
        "id": 274423135,
        "sender_full_name": "tmandry",
        "timestamp": 1646672825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274422350\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> Ohh, right yeah! I guess right now we have that in the form of <code>Drop</code> / drop guards. But something like an \"async drop\" / <code>defer</code> / \"async <code>defer</code>\" might make that easier.</p>\n</blockquote>\n<p>I guess that drop guards/defer are somewhat equivalent. Though I think the higher order bit here is that we (as a group I mean, or maybe just I) don't have a great idea about how this would look. Maybe it is worth thinking that through? I've mostly been considering non-cancellable futures rather than futures with an opportunity to catch cancellation. It seems like the latter would be much easier to incorporate without huge changes.</p>",
        "id": 274509495,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646728130
    },
    {
        "content": "<p>In particular, I think its worth considering how guaranteed to run such a hook would have to be to be useful. At the moment, regular <code>drop</code> is not good enough for many uses, but we'd never be able to guarantee 100% that a hook would run (at the limit, the process could be terminated between cancellation starting and the cancel hook running). Is it enough to say the hook will run unless the task terminates? The thread?</p>",
        "id": 274509735,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646728278
    },
    {
        "content": "<p>If the hook is async, I think that thread-level is needed to support structured concurrency? For the use case for completion IO buffers that might not be enough.</p>",
        "id": 274510058,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646728513
    },
    {
        "content": "<p>I guess even for structured concurrency it might not be enough, depending on the guarantees people want to rely on it for</p>",
        "id": 274510208,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646728626
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> so if I'm understanding you correctly by \"async hook\" you mean something resembling an \"async drop guard\", and what makes an \"async drop guard\" possible is \"async drop\". Async drop is definitely crucial to Rust's async story, very much including cancellation, and imo as long as we don't have it we'll be working around it awkwardly.</p>",
        "id": 274522684,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646735965
    },
    {
        "content": "<p>I don't quite understand the concerns of \"structured concurrency\" or the comments on when async drop would be run. The way I've been thinking about it, we should be able to <code>.await</code> destructors on drop within async contexts in the same spots sync drop would run. The only library code which really needs to be aware of async drop would be runtimes, which need to ensure that the top-level futures passed to them also have their destructors run.</p>",
        "id": 274523039,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646736141
    },
    {
        "content": "<p>There are some fun design questions about async drop though, in particular the issue of <a href=\"https://without.boats/blog/poll-drop/\">introducing new state</a>. But even this I suspect we may be able to figure out. So we don't end up with a <code>poll_drop</code> method, but an <code>async fn drop</code> instead.</p>",
        "id": 274523116,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646736192
    },
    {
        "content": "<p>So, I think async drop might not be enough because it would not be guaranteed to run (like sync drop) and for a cancellation hook to be useful (well, as useful as non-cancellable futures) I think we need SOME stronger guarantee than that.</p>",
        "id": 274523665,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646736495
    },
    {
        "content": "<p>Can you elaborate why?</p>",
        "id": 274523734,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646736547
    },
    {
        "content": "<p>IMO, defer might be a good solution because it means we wouldn’t need async drop, it could just be a regular function which you await in the defer block. Of course that means defer has to be special rather than just sugar for drop</p>",
        "id": 274523811,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646736597
    },
    {
        "content": "<p>I'm not sure I understand how that would be different from an \"async drop\" ?</p>",
        "id": 274523913,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646736648
    },
    {
        "content": "<p>So, my reasoning is that async drop is equivalent to non cancellable because you can await in it, ie you can block the task for as long as you need before cancellation finishes. However, that is only true if the drop is guaranteed to be run, if not then you can still be abruptly cancelled and cannot reason about the state of the program in all cases</p>",
        "id": 274524053,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646736725
    },
    {
        "content": "<p>It is different because the await can be made explicit</p>",
        "id": 274524089,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646736742
    },
    {
        "content": "<p>ah, so I think this gets to a question: \"should async drop be cancellable?\"</p>",
        "id": 274524126,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646736763
    },
    {
        "content": "<p>which feels in the vein of: \"can we unwind while unwinding\", etc.</p>",
        "id": 274524138,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646736771
    },
    {
        "content": "<p>Not sure if that is enough of a reason to do it, but it seems that implicit await for drop is weird</p>",
        "id": 274524148,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646736776
    },
    {
        "content": "<p>I would assume cancelling async drop would abort similar to a double panic. Seems too weak otherwise</p>",
        "id": 274524215,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646736828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274524148\">said</a>:</p>\n<blockquote>\n<p>Not sure if that is enough of a reason to do it, but it seems that implicit await for drop is weird</p>\n</blockquote>\n<p>heh, I guess it depends on your perspective. For example, I suspect that the moment we get it, the weirdness will almost immediately wear off and folks will just be happy to have an async version of drop.</p>",
        "id": 274524516,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737019
    },
    {
        "content": "<p>Also if we consider <code>.await</code> as marking a \"halting point\", and we don't want \"async drop\" to be cancellable, then the omission of <code>.await</code> makes sense in that regard.</p>",
        "id": 274524566,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737060
    },
    {
        "content": "<p>That’s an interesting point!</p>",
        "id": 274524636,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737094
    },
    {
        "content": "<p>This analogy _slightly_ gets a bit on thin ice when we consider that before the start of a function block there also exists a \"halting point\", but that's not annotated by <code>.await</code>. (because futures are never guaranteed to be executed after construction). But maybe that's the odd one out (:</p>",
        "id": 274524705,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737145
    },
    {
        "content": "<p>I feel the weirdness is not so much something which feels weird, but just makes the mental model of the whole thing a little bit bigger and harder to explain.</p>",
        "id": 274524720,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737158
    },
    {
        "content": "<p>Yeah, I consider that a pretty different kind of halting point to be honest, feels like a different class of thing</p>",
        "id": 274524764,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737198
    },
    {
        "content": "<p>Like it’s not ‘started and canceled’ it’s ‘never started’</p>",
        "id": 274524921,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737227
    },
    {
        "content": "<p>Is it tho?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">my_fn</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">arg2</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"nb\">drop</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274524996,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737277
    },
    {
        "content": "<p>This creates a future, but then drops it. The state machine is still created, values are still moved into it, and destructors will need to be run. To me that feels like \"starting and then cancelling\".</p>",
        "id": 274525105,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737339
    },
    {
        "content": "<p>It might be different, but imo not significantly so.</p>",
        "id": 274525133,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737359
    },
    {
        "content": "<p>From the perspective of the implementer of my_fn, it feels different. There is no opportunity to establish its invariants. Essentially there is no distinction between that and never calling my_fn</p>",
        "id": 274525372,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737505
    },
    {
        "content": "<p>From outside it is equivalent to calling drop(arg1) and drop(arg2), but polling just once means that is not true</p>",
        "id": 274525458,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737561
    },
    {
        "content": "<p>It's also calling <code>drop(fut)</code>; and sync functions may establish invariants even if they later return a future.</p>",
        "id": 274525649,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737656
    },
    {
        "content": "<p>Silly thought: \"futures have a life before <code>poll</code>\"</p>",
        "id": 274525737,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737688
    },
    {
        "content": "<p>Right but my point is that for async functions dropping the future is not observable (other than dropping the arguments)</p>",
        "id": 274525828,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737746
    },
    {
        "content": "<p>I agree that what I shared is less common though; most user code is unlikely to do anything other than immediately return a <code>Future</code>. But strictly speaking, that doesn't necessarily need to be the case.</p>",
        "id": 274525891,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737787
    },
    {
        "content": "<p>With customs futures returned from a sync function things are different</p>",
        "id": 274525911,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737795
    },
    {
        "content": "<p>yes okay, sounds like we're on the same page ^^</p>",
        "id": 274525977,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737823
    },
    {
        "content": "<p>Yeah, I think fundamentally a sync function returning a future and an async function cannot be treated equivalently by the caller, although the differences are usually not too important</p>",
        "id": 274526069,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646737905
    },
    {
        "content": "<p>Can you elaborate why not?</p>",
        "id": 274526166,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646737949
    },
    {
        "content": "<p>Oh actually, I think I might understand what you mean</p>",
        "id": 274526905,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646738286
    },
    {
        "content": "<p>I agree that the differences are unlikely to be meaningful to the caller. Regardless of how things are created, once you have a future you'll want to run its destructors.</p>",
        "id": 274527112,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646738394
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20reading.20club.202022-03-07/near/274524053\">said</a>:</p>\n<blockquote>\n<p>So, my reasoning is that async drop is equivalent to non cancellable because you can await in it, ie you can block the task for as long as you need before cancellation finishes. However, that is only true if the drop is guaranteed to be run, if not then you can still be abruptly cancelled and cannot reason about the state of the program in all cases</p>\n</blockquote>\n<p>Do we have any way we could guarantee  async destructors run? I'd expect those to be vulnerable to <code>mem::forget</code> as well.</p>",
        "id": 274623440,
        "sender_full_name": "eholk",
        "timestamp": 1646782510
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> can't use use the same technique as <code>crossbeam::scope</code> and use an async-drop guard inside a closure, so it can't be leaked?</p>",
        "id": 274626148,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646784275
    },
    {
        "content": "<p>Hmm, maybe? Is the idea there that once a closure starts, it runs to completion (barring a panic, anyway)?</p>",
        "id": 274626674,
        "sender_full_name": "eholk",
        "timestamp": 1646784622
    },
    {
        "content": "<p>well, i imagine it would be like this: <a href=\"https://docs.rs/crossbeam-utils/0.8.5/src/crossbeam_utils/thread.rs.html#163\">https://docs.rs/crossbeam-utils/0.8.5/src/crossbeam_utils/thread.rs.html#163</a></p>\n<div class=\"codehilite\"><pre><span></span><code>async fn async_scope&lt;F: Future, &#39;env&gt;(f: FnOnce() -&gt; F + &#39;env) {\n       let scope = whatever();\n       let jh = spawn(async move {\n               catch_unwind(f(scope).await);\n               // implicit async_drop(scope)\n       });\n       jh.await\n}\n</code></pre></div>\n<p>if you ever call this, then even if you dont poll the future, the scope is created, and guaranteed to be polled by the runtime, and if the closure panics, or exits, or anything, you are guaranteed to async-drop the scope at the end</p>\n<p>I think the problem is: you need to guarantee that the enclosing scope you are borrowing from and calling <code>async_scope</code> stays put until you are done with the scope task...not sure how that would work</p>",
        "id": 274628843,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646786264
    },
    {
        "content": "<p>Ah, I see what you mean. I feel like there's a question of here about whether we trust the runtime (or manually implemented futures) to handle this correctly, or whether we can guarantee that with the language.</p>",
        "id": 274629176,
        "sender_full_name": "eholk",
        "timestamp": 1646786570
    },
    {
        "content": "<p>Like, should I be able to get away with this?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">leaky_race</span><span class=\"p\">(</span><span class=\"n\">f1</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">f2</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">mem</span>::<span class=\"n\">forget</span><span class=\"p\">(</span><span class=\"n\">f1</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f2</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274629248,
        "sender_full_name": "eholk",
        "timestamp": 1646786640
    },
    {
        "content": "<p>Then I could do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">async_scope</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">scope</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">leaky_race</span><span class=\"p\">(</span><span class=\"n\">async_fn_a</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">async_fn_b</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">})</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and end up not calling the destructor for <code>async_fn_a()</code>.</p>",
        "id": 274629375,
        "sender_full_name": "eholk",
        "timestamp": 1646786725
    },
    {
        "content": "<p>I agree</p>\n<p>To me it seems REALLY hard to make sure that the future that we are borrowing from (where the <code>'env</code> lifetime is coming from) does NOT progress until the sub-tasks are done unless either:</p>\n<ul>\n<li>trust the runtime to NEVER poll the borrowed-from task until the sub tasks are done. I am not sure how this is possible if you are creating the subtasks in an <code>async</code> context. I am not 100% sure how this would work</li>\n<li>go with what I think was <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> 's idea and I have <code>?Leak</code> and <code>!Leak</code>, and really do make values that cannot be leaked (including somehow preventing reference-cycle leaks....) This would be a huge change</li>\n</ul>",
        "id": 274753276,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646860477
    },
    {
        "content": "<p>So I haven't really worked out how to do this yet, but it seems like it should be possible to put the parent task in an <code>Arc</code> and have subtasks keep a strong reference to the parent task, or something similar. I think in this case you can even have the runtime poll the parent task, as long as the borrow checker is otherwise happy.</p>",
        "id": 274755841,
        "sender_full_name": "eholk",
        "timestamp": 1646861811
    },
    {
        "content": "<p>Although that also seems like an obvious enough idea that I expect someone would have done it already if it were possible.</p>",
        "id": 274755895,
        "sender_full_name": "eholk",
        "timestamp": 1646861840
    },
    {
        "content": "<p>hmm, ill have to think about that</p>",
        "id": 274874444,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646936148
    }
]