[
    {
        "content": "<p>Who remembers the rationale for the current approach of putting async APIs behind top-level modules like <code>std::future</code> and <code>std::task</code>?</p>\n<p>As we're talking about <a href=\"https://github.com/rust-lang/rfcs/pull/3208\">renaming <code>std::stream::Stream</code> to <code>std::async_iter::AsyncIterator</code></a> I'm thinking about how many other modules like this will be introduced (I/O traits, executor traits, and so on) and wondering if we shouldn't have a central \"entry point\" for finding all of them in the module hierarchy itself.</p>",
        "id": 264964236,
        "sender_full_name": "tmandry",
        "timestamp": 1639542557
    },
    {
        "content": "<p>Personally I would love it if we could do this:</p>\n<ul>\n<li><code>std::async::iter::AsyncIterator</code> - predictable naming for async things that have analogues in the sync world</li>\n<li><code>std::async::task::Task</code> - discoverability for things that <em>don't</em> have direct analogues, using the path to make it more obvious what they're <em>for</em></li>\n</ul>\n<p>But of course we can't now due to async being a keyword (and it might not even be possible to allow, though I don't actually see why not).</p>",
        "id": 264964671,
        "sender_full_name": "tmandry",
        "timestamp": 1639542974
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> General <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for putting most things into a common module hierarchy, but I do think there's value in not having a single module for things that on the sync side would be in multiple places.</p>",
        "id": 264965744,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639544119
    },
    {
        "content": "<p>For instance, I/O is in <code>std::io</code>, and filesystem stuff is in <code>std::fs</code>, and process stuff is in <code>std::process</code>, and I don't think the async equivalents should all be in the same module.</p>",
        "id": 264965802,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1639544166
    },
    {
        "content": "<p>So what I'm wondering is if we should have <code>std::async::io</code> and <code>std::async::fs</code> and so on</p>",
        "id": 264965830,
        "sender_full_name": "tmandry",
        "timestamp": 1639544225
    },
    {
        "content": "<p>(You could even imagine inverting the order.. <code>std::io::async</code>.. but that advantages discovering \"there is an async version of this thing\" over discovering \"here are all the things you can do with async\")</p>",
        "id": 264965917,
        "sender_full_name": "tmandry",
        "timestamp": 1639544321
    },
    {
        "content": "<p>+1 for std::async::io etc, however, we have already stabilised at least std::future, so not everything async will be in std::async</p>",
        "id": 264989794,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639564502
    },
    {
        "content": "<p>not sure how/if that affects the consistency argument</p>",
        "id": 264989823,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639564513
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> we could have a re-export to fix that consistency issue</p>",
        "id": 264994994,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639567193
    },
    {
        "content": "<p>FWIW, I'd love to have an (opt-in) <code>async</code> prelude. <em>e.g.</em>, having to refer to three distinct modules in:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code>::<span class=\"n\">core</span>::<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">future</span>::<span class=\"n\">Future</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">marker</span>::<span class=\"n\">PhantomPinned</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">pin</span>::<span class=\"n\">Pin</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<p>seems quite silly every time I write it <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 264995443,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1639567414
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Paths.20of.20async.20APIs.20in.20std/near/264994994\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> we could have a re-export to fix that consistency issue</p>\n</blockquote>\n<p>True! It would still be a bit messy, but perhaps worth it for a long-term better scenario</p>",
        "id": 264996130,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1639567790
    },
    {
        "content": "<p>There's also the question of async overloading, which would let everything stay where it is now.</p>",
        "id": 265003783,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1639572238
    },
    {
        "content": "<p>Yeah, ideally we could follow <a href=\"https://github.com/apple/swift-evolution/pull/1392\">Swift's example</a> and expose the same APIs for both async and non-async Rust from their existing locations. <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> and I talked about taking a closer look at the feasibility of <a href=\"https://blog.yoshuawuyts.com/async-overloading/\">async overloading</a> to hopefully provide some more clarity on this.</p>",
        "id": 265587250,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640018637
    },
    {
        "content": "<p>+1 to consolidating the hierarchy; I'm not sure about having the overloaded API or not, though it is definitely appealing</p>",
        "id": 265587601,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1640018787
    },
    {
        "content": "<p>Coming from Node.js which has both <a href=\"https://nodejs.org/docs/latest-v15.x/api/fs.html\"><code>fs.readdir</code> and <code>fs.readdirSync</code></a>-style  duplicates <em>everywhere</em>, if we could avoid that type of split in the stdlib it would be incredible.</p>",
        "id": 265587627,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1640018798
    },
    {
        "content": "<p>On the one hand, the idea of being able to just use <code>std::fs::FIle</code> sounds interesting and handy. On the other hand, I'm having a hard time imagining how we could reasonably do that without introducing issues. Sometimes you want to reference a sync API from an async function or vice versa. And conversely, how would we catch errors? If you forget the <code>.await</code>, does that mean you want the sync API or that you want the async API but forgot the <code>.await</code>?</p>",
        "id": 265599067,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640024275
    },
    {
        "content": "<p>I'm rather tempted to have a parallel hierarchy, like <code>async::fs::File</code> (modulo keywordiness).</p>",
        "id": 265599196,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640024328
    },
    {
        "content": "<p>I suppose it's possible to have both <code>sync</code> and <code>async</code> parallel hierarchies, and to have the default ones resolve based on where they're used.</p>",
        "id": 265599839,
        "sender_full_name": "tmandry",
        "timestamp": 1640024689
    },
    {
        "content": "<p>though we may want a more general convenient way to force sync/async resolution than with module hierarchies</p>",
        "id": 265600156,
        "sender_full_name": "tmandry",
        "timestamp": 1640024867
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Paths.20of.20async.20APIs.20in.20std/near/265599067\">said</a>:</p>\n<blockquote>\n<p>Sometimes you want to reference a sync API from an async function or vice versa.</p>\n</blockquote>\n<p>Maybe if we support async overloading we also need to include something like a <code>sync { ... }</code> block that explicitly marks a section of code as sync.</p>",
        "id": 265609836,
        "sender_full_name": "eholk",
        "timestamp": 1640030671
    },
    {
        "content": "<p>Or closures?</p>",
        "id": 265610690,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031231
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">spawn_blocking</span><span class=\"p\">(</span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265610756,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031258
    },
    {
        "content": "<p>I would expect this to resolve to the sync version of <code>foo</code>.</p>",
        "id": 265610780,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031270
    },
    {
        "content": "<p>Not that I know why you would ever want to use the sync version over the async version.</p>",
        "id": 265610873,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031351
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265610943,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031389
    },
    {
        "content": "<p>Would both use the async version then.</p>",
        "id": 265610950,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031396
    },
    {
        "content": "<p>So then the rules would be:</p>\n<ul>\n<li>In a sync fn/closure: sync version</li>\n<li>In a async fn/closure/block: async version</li>\n</ul>",
        "id": 265611515,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031779
    },
    {
        "content": "<p>I think that would work.</p>",
        "id": 265611563,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640031809
    },
    {
        "content": "<p>That would effectively be adopting the \"implicit await\" proposal from a while back.</p>",
        "id": 265623401,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640039314
    },
    {
        "content": "<p>I think all the discussion points raised during that proposal would apply.</p>",
        "id": 265623421,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640039340
    },
    {
        "content": "<blockquote>\n<p>That would effectively be adopting the \"implicit await\" proposal from a while back.</p>\n</blockquote>\n<p>How so?</p>",
        "id": 265624128,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039853
    },
    {
        "content": "<p>There's no implicit await here</p>",
        "id": 265624135,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039861
    },
    {
        "content": "<p>You just have to enter an async context to call the async version of the function.</p>",
        "id": 265624221,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039929
    },
    {
        "content": "<p>Which, in a sync function, means wrapping the call in an async block/closure</p>",
        "id": 265624243,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039950
    },
    {
        "content": "<p>You still have to await the async block to run the future</p>",
        "id": 265624258,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640039963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> OK, then just part of that proposal. But still: that means you can't call <code>async_func()</code> to get a future, in a sync function, then <em>pass</em> that future to an async context.</p>",
        "id": 265624389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040047
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// sync context</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async_func</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">work_with_future</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265624550,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040163
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// sync context</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">func</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"n\">work_with_future</span><span class=\"p\">(</span><span class=\"n\">fut</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265624575,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040192
    },
    {
        "content": "<p>Oh, sorry, maybe the confusion is from my example.</p>",
        "id": 265624592,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040212
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> I realize that's <em>possible</em>, but that's the same kind of problem that existed in the implicit-await proposal.</p>",
        "id": 265624593,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040218
    },
    {
        "content": "<p>It should be <code>async || foo().await</code>, not <code>async || foo()</code></p>",
        "id": 265624601,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040226
    },
    {
        "content": "<p>The failure mode here goes from \"you called an async function in a sync context and that doesn't work\" to \"you called an async function in a sync context so it did an unexpected sync thing instead\".</p>",
        "id": 265624679,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040254
    },
    {
        "content": "<p>Well in a sync context, the default is calling the sync thing. If you expected to call the async thing and get a future, then somewhere down the line you will get a type error <code>Expected impl Future&lt;Output = T&gt;, found T</code></p>",
        "id": 265624763,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040336
    },
    {
        "content": "<p>And I think that's fine.</p>",
        "id": 265624768,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040348
    },
    {
        "content": "<p>Interesting point.</p>",
        "id": 265624776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040354
    },
    {
        "content": "<p>In the interests of fairness, I should also note that a <em>similar</em> failure mode applies to accidentally calling the sync version of an async function, even if it has a different path; after all, you could accidentally call <code>std::fs::File</code> instead of <code>std::async::fs::File</code> or equivalent, especially if you have imports such that that's just <code>fs::File</code> or <code>File</code> and you don't realize it's the wrong one.</p>",
        "id": 265624828,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040377
    },
    {
        "content": "<p>I would also note that <code>async { async_func().await }</code> seems excessively verbose compared to <code>async_func()</code>, especially if you need to do it more than once for different futures, such as if you're calling <code>or</code> or similar.</p>",
        "id": 265624904,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040435
    },
    {
        "content": "<p>Comparison:</p>",
        "id": 265624917,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040447
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">async_func1</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">});</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265624943,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040473
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">async_func1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">());</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265625002,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040495
    },
    {
        "content": "<p>Well, you just have to enter an async context.</p>",
        "id": 265625016,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040513
    },
    {
        "content": "<p>Every future doesn't have to be wrapped in an individual async block.</p>",
        "id": 265625039,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040526
    },
    {
        "content": "<p>I suppose you could <em>also</em> spell that as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">async_func1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">()).</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265625046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040537
    },
    {
        "content": "<p>Yeah</p>",
        "id": 265625048,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040540
    },
    {
        "content": "<p>I don't think that's too bad.</p>",
        "id": 265625065,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040554
    },
    {
        "content": "<p>That still feels like a verbose cost to impose, just so that we can do async overloading.</p>",
        "id": 265625081,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040564
    },
    {
        "content": "<p>Plus, it adds to the context-sensitivity of the language, versus having a given path just be a given function.</p>",
        "id": 265625108,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040597
    },
    {
        "content": "<p><code>async</code> as a call-site modifier is also an option.</p>",
        "id": 265625403,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040729
    },
    {
        "content": "<p>I know that was discussed a lot during the async/await bikeshed.</p>",
        "id": 265625415,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040739
    },
    {
        "content": "<p>Along the lines of <code>async f()</code> rather than <code>async { f().await }</code>?</p>",
        "id": 265625431,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040752
    },
    {
        "content": "<p>It's also what Zig does for their \"colourless async\"</p>",
        "id": 265625438,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040759
    },
    {
        "content": "<p>Yeah</p>",
        "id": 265625441,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040762
    },
    {
        "content": "<p>Do you mean <em>everywhere</em>, or everywhere that's not in an async context already?</p>",
        "id": 265625472,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040785
    },
    {
        "content": "<p>(and in the latter case, wouldn't we also need a sync modifier?)</p>",
        "id": 265625483,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040793
    },
    {
        "content": "<p>Well, I think it is probably too late for <em>everywhere</em> :)</p>",
        "id": 265625525,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040832
    },
    {
        "content": "<p>I think <em>everywhere</em> would also be an even more verbose cost.</p>",
        "id": 265625599,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1640040876
    },
    {
        "content": "<p>True</p>",
        "id": 265625607,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040882
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">async_func1</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">async_func2</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"c1\">// =&gt; let fut = async { or!(async_func1(), async_func2()).await };</span>\n</code></pre></div>",
        "id": 265625641,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040908
    },
    {
        "content": "<p>To be fair the cost of the async wrapping is only imposed on the odd case.</p>",
        "id": 265625678,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640040939
    },
    {
        "content": "<p>For <em>most</em> users, it would ideally \"just work\"</p>",
        "id": 265625779,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041007
    },
    {
        "content": "<p>There's already an extra cost to do things like setup work before returning a future.</p>",
        "id": 265625827,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041051
    },
    {
        "content": "<p>Where the default async/await semantics don't quite work.</p>",
        "id": 265625939,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041107
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">a</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">a</span> <span class=\"kt\">str</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">b</span> <span class=\"kt\">str</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 265626030,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1640041175
    },
    {
        "content": "<p>On that tangent: <a href=\"https://docs.rs/async_fn/0.0.2/async_fn/macro.before_async.html#eager-vs-lazy--suspended-code\">https://docs.rs/async_fn/0.0.2/async_fn/macro.before_async.html#eager-vs-lazy--suspended-code</a></p>",
        "id": 265635357,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1640048412
    },
    {
        "content": "<p>So, related to this is the question of whether we keep the <code>Async</code> prefix on every type and trait. Apparently this was discussed in the context of AsyncIterator, but I missed that (or I've forgotten it). Anyway, just writing my blog post on AsyncRead and AsyncWrite, I am thoroughly sick of writing Async on everything, it feels ridiculous. So given the discussion above seemed to be in favour of using modules called async (though I don't think we settled on async::io vs io::async), I would like to propose we drop the Async prefix.</p>",
        "id": 270558462,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643899115
    },
    {
        "content": "<p>use std::async::io::{Read, Write};</p>",
        "id": 270558531,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643899143
    },
    {
        "content": "<p>vs use std::async::io::{AsyncRead, AsyncWrite};</p>",
        "id": 270558580,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643899164
    },
    {
        "content": "<p>and I guess one reason for preferring io::async to async::io is that if you do need to disambiguate, you can <code>use std::io::*</code> and write <code>Read</code> and <code>async::Read</code></p>",
        "id": 270558790,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643899230
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async/topic/Paths.20of.20async.20APIs.20in.20std/near/264965917\">said</a>:</p>\n<blockquote>\n<p>(You could even imagine inverting the order.. <code>std::io::async</code>.. but that advantages discovering \"there is an async version of this thing\" over discovering \"here are all the things you can do with async\")</p>\n</blockquote>\n<p>In the long-term, I think we want  \"here are all the things you can do with async\" to be exactly the same set of things as the things you can do without it</p>",
        "id": 270559177,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643899329
    },
    {
        "content": "<p>(It's made me angry how many times I've had to type \"async\" just in these messages <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>)</p>",
        "id": 270559316,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643899391
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/Paths.20of.20async.20APIs.20in.20std/near/270558790\">said</a>:</p>\n<blockquote>\n<p>and I guess one reason for preferring io::async to async::io is that if you do need to disambiguate, you can <code>use std::io::*</code> and write <code>Read</code> and <code>async::Read</code></p>\n</blockquote>\n<p>I like this layout as well. It means in most async code you'll just talk about the <code>Read</code> trait, but if you need to disambiguate you can do <code>async::Read</code> or <code>io::Read</code> if you need the sync version. <code>async::Read</code> seems similar to <code>AsyncRead</code>, but it means you don't have to type <code>AsyncRead</code> every time you want to use it.</p>",
        "id": 270590581,
        "sender_full_name": "eholk",
        "timestamp": 1643910853
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/Paths.20of.20async.20APIs.20in.20std/near/270559316\">said</a>:</p>\n<blockquote>\n<p>(It's made me angry how many times I've had to type \"async\" just in these messages <span aria-label=\"joy\" class=\"emoji emoji-1f602\" role=\"img\" title=\"joy\">:joy:</span>)</p>\n</blockquote>\n<p>We had the same idea when we were first designing <code>async-std</code> three years ago. We thought it'd be nice if folks could keep using <code>Read</code> and <code>Write</code> similar to sync io (<a href=\"https://docs.rs/async-std/latest/async_std/io/index.html#traits\"><code>async_std::io</code> traits</a>). But in practice it's probably one of the decisions we regret taking most, and if we could do it again we'd keep using <code>AsyncRead</code> / <code>AsyncWrite</code>, etc.</p>\n<p>Part of the reason for it is that docs don't clearly disambiguate between different traits with the same name (though this can be fixed). But more importantly: when verbally communicating about any of these traits you _do_ need to explain which trait you're dealing with. Are you implement <code>Read</code> or the \"async\" <code>Read</code>. For someone less familiar with the traits, which one is which? That's all kind of hard to get right.</p>",
        "id": 270591356,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1643911172
    },
    {
        "content": "<p>I really do hope that we can design a variant of async overloading so that we don't end up exposing two-of-each in the stdlib, but instead can guarantee that sync and async mirror each other. That would mean that e.g. <code>Read</code> is a single trait, but we'd have <code>async Read</code> and regular <code>Read</code> - which verbally are distinct.</p>",
        "id": 270592229,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1643911497
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> That's a really helpful bit of lessons-learned.</p>",
        "id": 270599708,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643914750
    },
    {
        "content": "<p>(Another possibility is that we <em>could</em> have the canonical name be <code>AsyncRead</code>, but also expose it as <code>Read</code> under an <code>async</code> module.)</p>",
        "id": 270599808,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643914782
    },
    {
        "content": "<p><code>std::io::AsyncRead</code>, re-exported as <code>std::io::async::Read</code>.</p>",
        "id": 270599924,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643914810
    },
    {
        "content": "<p>(Not sure if that's a <em>good</em> idea.)</p>",
        "id": 270599983,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643914822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> that was my idea as well: have a canonical definition with standalone semantics (<em>e.g.</em>, <code>Async</code> in the name), and then a convenience re-export.</p>\n<p>To me, the mistake <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> talks about already exists in the stdlib, but thankfully to a way lesser degree, with <code>Iter</code> (in <code>vec::Iter</code>, see?), or even <code>Weak</code></p>",
        "id": 270712142,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1643980319
    },
    {
        "content": "<p>this <code>async Read</code> idea came up a while ago in relation to async for syntax and i wrote this at the time: <a href=\"https://gist.github.com/rpjohnst/a68de4c52d9b0b0f6ddf54ca293cceee\">https://gist.github.com/rpjohnst/a68de4c52d9b0b0f6ddf54ca293cceee</a></p>",
        "id": 270764418,
        "sender_full_name": "rpjohnst",
        "timestamp": 1644004387
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 270803854,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644035066
    },
    {
        "content": "<blockquote>\n<p>But in practice it's probably one of the decisions we regret taking most, and if we could do it again we'd keep using AsyncRead / AsyncWrite, etc.</p>\n</blockquote>\n<blockquote>\n<p>Part of the reason for it is that docs don't clearly disambiguate between different traits with the same name (though this can be fixed). But more importantly: when verbally communicating about any of these traits you _do_ need to explain which trait you're dealing with. Are you implement Read or the \"async\" Read. For someone less familiar with the traits, which one is which? That's all kind of hard to get right.</p>\n</blockquote>\n<p>So you seem strongly against the idea, but the experience doesn't seem too bad. By docs do you mean hand-written stuff like dev guides or rustdoc? For talking, I would expect people to pronounce async::Read as \"async read\" so it is not ambiguous. This isn't a problem for things today like Error - people talk about \"io error\" to mean io::Error and it doesn't seem to confusing in docs, etc.</p>",
        "id": 271410220,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644487951
    },
    {
        "content": "<blockquote>\n<p>(Another possibility is that we could have the canonical name be AsyncRead, but also expose it as Read under an async module.)</p>\n</blockquote>",
        "id": 271410247,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644487968
    },
    {
        "content": "<p>With existing code, we tend to do the opposite, so for example we have an Error type in io (and many other places) and often people import it with <code>use std::io::Error as IoError;</code> where they need to disambiguate</p>",
        "id": 271410389,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644488046
    },
    {
        "content": "<p><code>std::io::Error</code> vs <code>std::error::Error</code> is types vs traits. \"Implement error for X\" is an unambiguous statement, and not comparable.</p>",
        "id": 271437941,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644503128
    },
    {
        "content": "<p>But there is also fmt::Error and a bunch of other concrete errors.</p>",
        "id": 271438227,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644503265
    },
    {
        "content": "<p>Having two traits with the same name is much rarer. In fact: I believe the only instance where we have duplicate trait names is in the various <code>std::os::{unix, windows}</code> Ext traits</p>",
        "id": 271438344,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644503312
    },
    {
        "content": "<p>I mean true; but those are all not traits either.</p>",
        "id": 271438450,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644503362
    },
    {
        "content": "<p>Traits are behavior. It's confusing when two traits are called the same and you need to specify which is which.</p>",
        "id": 271438616,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644503421
    },
    {
        "content": "<p>In practice I found myself needing to specify which trait we meant over and over: \"implement the async read trait. Sorry, no it's not called that. I mean the 'asynchronous variant of the Read' trait. Yeah you can find it in &lt;submodule&gt;'\"</p>",
        "id": 271438850,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644503524
    },
    {
        "content": "<p>It was annoying. And also not helped by the fact that rustdoc just shows <code>Read</code> as the trait implemented on the type. Without specifiers it's incredibly unclear. (Though as I said, this could be overcome. But it's another issue)</p>",
        "id": 271438992,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644503610
    },
    {
        "content": "<p>That's why I wish we hadn't done it. If we mean \"async read\" name it <code>AsyncRead</code>. Ditto for \"async iterator\". The only exception to that is if we can find a way to introduce async overloading — which would fold it all into a single trait.</p>",
        "id": 271439326,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644503754
    },
    {
        "content": "<blockquote>\n<p>for example we have an Error type in io (and many other places) and often people import it with <code>use std::io::Error as IoError;</code> where they need to disambiguate</p>\n</blockquote>",
        "id": 271440471,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644504274
    },
    {
        "content": "<p>Do they?</p>",
        "id": 271440484,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644504281
    },
    {
        "content": "<p><code>io::Error</code> seems to be the more common pattern</p>",
        "id": 271440609,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644504343
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> Don't forget io::Write and fmt::Write, which is a massive pain sometimes.</p>",
        "id": 271467786,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644515382
    },
    {
        "content": "<p>Ohh, dang yeah I forgot about that. Are those the only ones we duplicate? But yes, agreed.</p>",
        "id": 271468874,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644515801
    },
    {
        "content": "<p>I <em>think</em> so?</p>",
        "id": 271469246,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644515947
    },
    {
        "content": "<p>I think we should have canonical names with Async in them, even if we <em>also</em> have some kind of overloading or a separate module path where they're re-exported.</p>",
        "id": 271469458,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644516009
    },
    {
        "content": "<p>I'm on my phone rn, but one way to quickly validate that would be to dump out all of traits in <code>std</code> (\"all items\" in rustdoc), remove the paths, and print the duplicates</p>",
        "id": 271469964,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644516180
    },
    {
        "content": "<p>I don't have a clear enough picture about what async overloading might end up looking like in practice to say anything meaningful about it I think.</p>",
        "id": 271470201,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644516268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> though I'd love to better understand your reasoning for why you think we should export traits that way even if we have overloads.</p>",
        "id": 271470349,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644516333
    },
    {
        "content": "<p>If we have a way to say <code>T: async Read</code>/<code>T: sync Read</code>, I don't see why that would be necessary</p>",
        "id": 271472083,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644517017
    },
    {
        "content": "<p>Or would the sync/async:: path be the way to do that</p>",
        "id": 271472202,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644517067
    },
    {
        "content": "<p>Even if we do have async overloading, then I think the traits will be different, so overloading must be an aspect of naming, basically. In which case, I don’t see much difference between ‘async Read’ and ‘async::Read’</p>",
        "id": 271477232,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644519366
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/Paths.20of.20async.20APIs.20in.20std/near/271477232\">said</a>:</p>\n<blockquote>\n<p>Even if we do have async overloading, then I think the traits will be different, so overloading must be an aspect of naming, basically. In which case, I don’t see much difference between ‘async Read’ and ‘async::Read’</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> was suggesting still having <code>AsyncRead</code></p>",
        "id": 271494930,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644527509
    },
    {
        "content": "<p>I was just considering the overloading case really. I think just async::Read is more consistent with other types in std (cf re-exporting), but I am concerned about the discussability aspect which Yosh raised.</p>",
        "id": 271496605,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644528260
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/Paths.20of.20async.20APIs.20in.20std/near/271470349\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> though I'd love to better understand your reasoning for why you think we should export traits that way even if we have overloads.</p>\n</blockquote>\n<p>I feel like there are still cases where we'd want to name the two independently, possibly in the same code, and having the name <code>AsyncRead</code> as an unambiguous way to identify the trait <em>without</em> overloading seems useful for a variety of reasons. Contexts in which we just display the trait name, contexts in which a space is obtrusive (if that ends up being the overloading syntax, which it might not be), contexts in which passing a non-identifier is painful (e.g. macro compatibility)...</p>",
        "id": 271501554,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644530499
    }
]