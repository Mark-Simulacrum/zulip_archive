[
    {
        "content": "<p>Yeah so I've been talking some to <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts</span> and some to <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> about async overloading and I thought I'd bring some of those ideas here to chew on</p>",
        "id": 250150999,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482039
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts</span> pointed out that <a href=\"https://github.com/groue/swift-evolution/blob/93f0092fc46609a00c48c8436a2b56edd852666e/proposals/0296-async-await.md#overloading-and-overload-resolution\">Swift has some cool stuff on this point</a></p>",
        "id": 250151400,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482240
    },
    {
        "content": "<p>I was talking some to <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> about it today and we were sketching out an overall setup that seems to me like it could work</p>",
        "id": 250151445,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482263
    },
    {
        "content": "<p>one way to think about it is as a kind of ABI</p>",
        "id": 250151668,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482378
    },
    {
        "content": "<p>e.g., you have the standard \"Rust\" ABI, but you could also have a \"Rust-Async\" ABI</p>",
        "id": 250151688,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482390
    },
    {
        "content": "<p>now if you imagine that when you write <code>fn foo()</code> the ABI is not yet determined</p>",
        "id": 250151966,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482497
    },
    {
        "content": "<p>it's only when you go to create a fn pointer that you determine it</p>",
        "id": 250152001,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482521
    },
    {
        "content": "<p>I'm not sure if the ABI metaphor is <em>super</em> useful, but it may be; I thought of it because we've talked about the option of taking an arbitrary <code>fn foo()</code> and letting you make an <code>extern \"C\" fn()</code> from it (i.e., we compile a <code>fn foo()</code> into whaever ABI(s) it needs to be compiled into)</p>",
        "id": 250152112,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482557
    },
    {
        "content": "<p>you can also think of it a bit like a generic parameter, with monomorphization</p>",
        "id": 250152134,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482568
    },
    {
        "content": "<p>i.e., a non-async fn can be compiled in 2 modes</p>",
        "id": 250152146,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482576
    },
    {
        "content": "<p>when you compile it in sync mode, it's just like today</p>",
        "id": 250152255,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482642
    },
    {
        "content": "<p>when you compile it in <em>async</em> mode, and it calls other funtions that don't have a fixed mode, they are compiled into async mode, and there is an implicit <code>await</code> loop</p>",
        "id": 250152324,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482665
    },
    {
        "content": "<p>like today, async fns can call sync, so this doesn't prevent you from doing blocking things</p>",
        "id": 250152365,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482692
    },
    {
        "content": "<p>but then you could supply async versions of sync primitives</p>",
        "id": 250152378,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482701
    },
    {
        "content": "<p>And you wouldn't be allowed to call the sync version in an async fn?</p>",
        "id": 250152420,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629482727
    },
    {
        "content": "<p>in talking to <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts</span> he was emphasizing this point, because it's super impactful-- maybe the way to do I/O in Rust becomes \"just use the same functions no matter what\"</p>",
        "id": 250152448,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482749
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/async.20overloading/near/250152420\">said</a>:</p>\n<blockquote>\n<p>And you wouldn't be allowed to call the sync version in an async fn?</p>\n</blockquote>\n<p>no you can</p>",
        "id": 250152463,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482756
    },
    {
        "content": "<p>just like today</p>",
        "id": 250152474,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482762
    },
    {
        "content": "<p>but if you have an overloaded version, then it runs in async mode</p>",
        "id": 250152532,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482768
    },
    {
        "content": "<p>(interesting question whether you get a future out of it)</p>",
        "id": 250152560,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482783
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/async.20overloading/near/250152420\">said</a>:</p>\n<blockquote>\n<p>And you wouldn't be allowed to call the sync version in an async fn?</p>\n</blockquote>\n<p>to this point, things like the blocking lint become very important</p>",
        "id": 250152733,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482875
    },
    {
        "content": "<p>the other \"rubber hits the road\" point is <code>dyn Trait</code></p>",
        "id": 250152795,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482888
    },
    {
        "content": "<p>Yeah, that's what I was thinking of.</p>",
        "id": 250152806,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629482891
    },
    {
        "content": "<p>But with things like locks, it might be more confusing.</p>",
        "id": 250152831,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629482910
    },
    {
        "content": "<p>Because you usually want the sync version even in async code.</p>",
        "id": 250152858,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629482927
    },
    {
        "content": "<p>it depends how successful we are I guess</p>",
        "id": 250152861,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482932
    },
    {
        "content": "<p>yeah, that seems plausible</p>",
        "id": 250152873,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482938
    },
    {
        "content": "<p>we might have two variants of locks even so?</p>",
        "id": 250152886,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482946
    },
    {
        "content": "<p>I do think the idea would be that <em>the majority of code</em> can run successfully in sync or async modes</p>",
        "id": 250152911,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482960
    },
    {
        "content": "<p>it would only be stuff that calls into FFI functions that may block that has trouble</p>",
        "id": 250152931,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482969
    },
    {
        "content": "<p>I guess locks are an interesting question</p>",
        "id": 250152944,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629482976
    },
    {
        "content": "<p>Another interesting alternative is something like <code>#[cfg(async)]</code></p>",
        "id": 250153042,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629483016
    },
    {
        "content": "<p>Although I don't think that would be very ergonomic for library authors.</p>",
        "id": 250153092,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629483038
    },
    {
        "content": "<p>something I'm wondering about is if we could leverage this so that we can make <code>?</code> work in iterators :)</p>",
        "id": 250153137,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483066
    },
    {
        "content": "<p>by work I mean: return from the enclosing function</p>",
        "id": 250153158,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483079
    },
    {
        "content": "<p>but that's another story</p>",
        "id": 250153166,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483082
    },
    {
        "content": "<p>well, it's related to the thing I was thinking about.. this can solve the iterator combinator problem with <code>async</code> really really nicely</p>",
        "id": 250153231,
        "sender_full_name": "tmandry",
        "timestamp": 1629483110
    },
    {
        "content": "<p>Does swift do implicit await?</p>",
        "id": 250153287,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629483124
    },
    {
        "content": "<p>no, it's explicit</p>",
        "id": 250153312,
        "sender_full_name": "tmandry",
        "timestamp": 1629483140
    },
    {
        "content": "<p>I don't think swift actually does the thing being proposed here, it's more \"shallow\"</p>",
        "id": 250153395,
        "sender_full_name": "tmandry",
        "timestamp": 1629483187
    },
    {
        "content": "<p>anyway I just wanted to float those ideas more broadly</p>",
        "id": 250153407,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483195
    },
    {
        "content": "<p>I guess <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts</span> is asleep or I might've waited to bring it up until they were around</p>",
        "id": 250153420,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483205
    },
    {
        "content": "<p>because indeed much of this stems from them talking to me about it</p>",
        "id": 250153430,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483214
    },
    {
        "content": "<p>I do think it's something we should dig into---</p>",
        "id": 250153439,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483222
    },
    {
        "content": "<p>of all the problems on the list</p>",
        "id": 250153445,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483224
    },
    {
        "content": "<p>we have no solutions to the async-sync-async sandwich</p>",
        "id": 250153454,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483230
    },
    {
        "content": "<p>(except this one)</p>",
        "id": 250153466,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483234
    },
    {
        "content": "<p>and it could be transformative</p>",
        "id": 250153470,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483236
    },
    {
        "content": "<p>I also don't thik it blocks us making progress on other things</p>",
        "id": 250153533,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483249
    },
    {
        "content": "<p>we still have to solve all the same issues</p>",
        "id": 250153549,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483257
    },
    {
        "content": "<p>C# has gotten along fine with async/sync versions of everything.</p>",
        "id": 250153568,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629483269
    },
    {
        "content": "<p>I'm not a big C# user, but I'm sure it's the same as in most other languages --- yes, you can do it</p>",
        "id": 250153871,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483428
    },
    {
        "content": "<p>it's just the soruce of footguns and copy-pasting and having 2 variants of everything</p>",
        "id": 250153888,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483441
    },
    {
        "content": "<p>it's not the end of the world</p>",
        "id": 250153897,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483445
    },
    {
        "content": "<p>but if we can cleanly solve it, maybe it's worth it</p>",
        "id": 250153915,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483455
    },
    {
        "content": "<p>The other thing we'll have to consider is how this impacts compile times. If a crate exports a function and we don't know if it will be called in sync or async contexts, do we codegen it for both?</p>",
        "id": 250153933,
        "sender_full_name": "tmandry",
        "timestamp": 1629483468
    },
    {
        "content": "<p>yeah</p>",
        "id": 250153967,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483483
    },
    {
        "content": "<p>mmm <span class=\"user-mention\" data-user-id=\"124287\">@mw</span> ready to do MIR-only rlibs?</p>",
        "id": 250154010,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483493
    },
    {
        "content": "<p>that would solve it :)</p>",
        "id": 250154014,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629483496
    },
    {
        "content": "<p>Well it's the same as if there was <code>foo</code> and <code>foo_async()</code> exported</p>",
        "id": 250154043,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629483510
    },
    {
        "content": "<p>Just cleaner</p>",
        "id": 250154050,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1629483512
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/async.20overloading/near/250154010\">said</a>:</p>\n<blockquote>\n<p>mmm <span class=\"user-mention silent\" data-user-id=\"124287\">mw</span> ready to do MIR-only rlibs?</p>\n</blockquote>\n<p>that would have a big impact on compile times too, unless there's a plan I don't know about</p>",
        "id": 250154102,
        "sender_full_name": "tmandry",
        "timestamp": 1629483544
    },
    {
        "content": "<p>deferring codegen until the end is essentially like (Thin)LTO, which slows down compilation by a lot</p>",
        "id": 250154238,
        "sender_full_name": "tmandry",
        "timestamp": 1629483608
    },
    {
        "content": "<p>I talked with <span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts</span> a little about this too, and I think what he had in mind (which I think is basically what Swift does) is that you can write two functions:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And then automagically the right version of <code>foo</code> gets called depending on whether you're in a sync or async context.</p>",
        "id": 250154328,
        "sender_full_name": "eholk",
        "timestamp": 1629483657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/async.20overloading/near/250154043\">said</a>:</p>\n<blockquote>\n<p>Well it's the same as if there was <code>foo</code> and <code>foo_async()</code> exported</p>\n</blockquote>\n<p>except that it's applied to all the normal functions you write, not just the ones the crate author knows are needed for something. it's a cost you would pay whether someone actually needed it or not</p>",
        "id": 250154353,
        "sender_full_name": "tmandry",
        "timestamp": 1629483670
    },
    {
        "content": "<p>maybe a reasonable default is to codegen for sync and put MIR in rlibs in case async is needed, with attributes / flags to tweak the behavior</p>",
        "id": 250154499,
        "sender_full_name": "tmandry",
        "timestamp": 1629483729
    },
    {
        "content": "<p>Does this require making <code>await</code> implicit?</p>",
        "id": 250154533,
        "sender_full_name": "eholk",
        "timestamp": 1629483756
    },
    {
        "content": "<p>At least, if I want to make a function that's polymorphic over sync and async?</p>",
        "id": 250154567,
        "sender_full_name": "eholk",
        "timestamp": 1629483776
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/async.20overloading/near/250154328\">said</a>:</p>\n<blockquote>\n<p>I talked with <span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts</span> a little about this too, and I think what he had in mind (which I think is basically what Swift does) is that you can write two functions:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">.}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And then automagically the right version of <code>foo</code> gets called depending on whether you're in a sync or async context.</p>\n</blockquote>\n<p>the question is, what happens when you do async -&gt; sync -&gt; async?</p>",
        "id": 250154573,
        "sender_full_name": "tmandry",
        "timestamp": 1629483778
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/async.20overloading/near/250154573\">said</a>:</p>\n<blockquote>\n<p>the question is, what happens when you do async -&gt; sync -&gt; async?</p>\n</blockquote>\n<p>So you'd have A call B call C, where A and C are async, right?</p>",
        "id": 250154780,
        "sender_full_name": "eholk",
        "timestamp": 1629483859
    },
    {
        "content": "<p>yes</p>",
        "id": 250154789,
        "sender_full_name": "tmandry",
        "timestamp": 1629483866
    },
    {
        "content": "<p>I think the way it'd work is that if B only has a sync overload, you'd still have the async sandwich.</p>",
        "id": 250154808,
        "sender_full_name": "eholk",
        "timestamp": 1629483882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/async.20overloading/near/250154567\">said</a>:</p>\n<blockquote>\n<p>At least, if I want to make a function that's polymorphic over sync and async?</p>\n</blockquote>\n<p>If you write normal code for a sync function, then if it gets translated all the await points would be implicit. (This would only work with poll-to-completion futures, of course)</p>",
        "id": 250154849,
        "sender_full_name": "tmandry",
        "timestamp": 1629483903
    },
    {
        "content": "<p>I don't really see this as a problem, though</p>",
        "id": 250154909,
        "sender_full_name": "tmandry",
        "timestamp": 1629483938
    },
    {
        "content": "<p>in a lot of cases, writing an async version of <code>B</code> would basically be copy and paste, which is where async polymorphism would come into play.</p>",
        "id": 250154981,
        "sender_full_name": "eholk",
        "timestamp": 1629483964
    },
    {
        "content": "<p>right, and the idea is to do that for you unless you want to specialize</p>",
        "id": 250155049,
        "sender_full_name": "tmandry",
        "timestamp": 1629483995
    },
    {
        "content": "<p>I'm worried about auto traits though.. when a variable is held across one of those implicit await points, your function might be <code>Send</code> in sync and <code>!Send</code> in async</p>",
        "id": 250155183,
        "sender_full_name": "tmandry",
        "timestamp": 1629484078
    },
    {
        "content": "<p>and this <code>!Send</code>-ness would propagate up the call stack, not down</p>",
        "id": 250155230,
        "sender_full_name": "tmandry",
        "timestamp": 1629484086
    },
    {
        "content": "<p>Would we want a way to opt-out of auto-generating the async version?</p>",
        "id": 250155328,
        "sender_full_name": "eholk",
        "timestamp": 1629484140
    },
    {
        "content": "<p>probably</p>",
        "id": 250155402,
        "sender_full_name": "tmandry",
        "timestamp": 1629484176
    },
    {
        "content": "<p>some low-level functions can't really be made async</p>",
        "id": 250155432,
        "sender_full_name": "tmandry",
        "timestamp": 1629484195
    },
    {
        "content": "<p>Kind of off topic, but do we have a way to yield or await on nothing? Like what if I write a big matrix multiply function that's pure computation but takes a long time? Is there a way to say in the middle \"hey, block here in case there are other tasks that need to run\"?</p>",
        "id": 250155587,
        "sender_full_name": "eholk",
        "timestamp": 1629484257
    },
    {
        "content": "<p>I imagine being able to do that matters more if we auto-generate async functions from sync functions.</p>",
        "id": 250155638,
        "sender_full_name": "eholk",
        "timestamp": 1629484283
    },
    {
        "content": "<p>there's <code>yield_now</code>, which isn't in the standard library, though it's something we could include</p>",
        "id": 250155822,
        "sender_full_name": "tmandry",
        "timestamp": 1629484376
    },
    {
        "content": "<p>the reason it's not in std today is there's not a standard way for executors to handle it</p>",
        "id": 250155861,
        "sender_full_name": "tmandry",
        "timestamp": 1629484400
    },
    {
        "content": "<p>but maybe that's something we want to change</p>",
        "id": 250155874,
        "sender_full_name": "tmandry",
        "timestamp": 1629484404
    },
    {
        "content": "<p>(it's just a future that returns <code>Poll::Pending</code> once and then <code>Poll::Ready</code> thereafter)</p>",
        "id": 250155911,
        "sender_full_name": "tmandry",
        "timestamp": 1629484425
    },
    {
        "content": "<p>Something like this would not just be nice to have, but potentially necessary if we want mandatory async drop. I have spent lots of time attempting to design a way to support it, and I have basically concluded it would need some kind of generic-over-async method like this.</p>",
        "id": 250175113,
        "sender_full_name": "Kestrer",
        "timestamp": 1629495074
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> MIR-only RLIBs are blocked on codegen being too slow/not parallel and the duplication of work they cause when there are multiple leaf crates (e.g. cargo integration tests). However, deferring codegen for functions that are not being called in the current crate (like we do for generic functions) would not be too hard, I think. Not sure if that would help.</p>",
        "id": 250322432,
        "sender_full_name": "mw",
        "timestamp": 1629706650
    },
    {
        "content": "<p>Published my blog post on async overloading: <a href=\"https://blog.yoshuawuyts.com/async-overloading/\">https://blog.yoshuawuyts.com/async-overloading/</a></p>",
        "id": 250507111,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1629821047
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124287\">@mw</span> those both seem like surmountable problems, but that sonds right</p>",
        "id": 250534594,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629832733
    }
]