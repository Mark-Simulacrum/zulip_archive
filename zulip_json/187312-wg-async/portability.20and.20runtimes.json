[
    {
        "content": "<p>Hey all -- so <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> and I have been gathering up some data relating to portability and runtimes</p>",
        "id": 227843609,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289198
    },
    {
        "content": "<p>I've kind of been pinging random people but I wanted to move this conversation here</p>",
        "id": 227843670,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289207
    },
    {
        "content": "<p><a href=\"https://hackmd.io/56GNAicTQiWBC24dw1bS4A?edit\">this is the document</a></p>",
        "id": 227843758,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289246
    },
    {
        "content": "<p>in particular I'm interested in improving--</p>",
        "id": 227843793,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289264
    },
    {
        "content": "<ul>\n<li>lists of crates/libraries and things that are conceptually separate from the underlying runtime and where it might be nice for them to be portable</li>\n<li>ways that people build portable things today and which crates/libraries use them</li>\n<li>what kinds of features those crates/libraries/things use from the underlying runtime</li>\n<li>what are the key \"groups\" of runtimes and any interesting details or distinguishing charateristics, especially as it relates to portability</li>\n</ul>",
        "id": 227843993,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289335
    },
    {
        "content": "<p>also, am I missing runtimes in the list?</p>",
        "id": 227844012,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289343
    },
    {
        "content": "<p>For example I was asking <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> if Fuchsia has a list of crates.io-hosted crates that they use; any such crates are presumably portable in some way, unless they are specific to Fuchsia</p>",
        "id": 227844072,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289386
    },
    {
        "content": "<p>I'm also curious about 'prior art' for ways to be portable:</p>\n<ul>\n<li><span class=\"user-mention\" data-user-id=\"226095\">@Dirkjan Ochtman</span> also mentioned <a href=\"https://docs.rs/futures/0.3.13/futures/task/trait.Spawn.html\">the <code>Spawn</code> trait</a> in futures, but said that tokio doesn't support it because it imposes some perf overhead (I'd like to understand that)</li>\n<li><span class=\"user-mention\" data-user-id=\"223879\">@vertexclique</span> pointed me at <a href=\"https://github.com/bastion-rs/agnostik\">bastion-rs/agnostik</a>, I'm not sure if that crates is used by anyone though?</li>\n<li>other relevant things?</li>\n</ul>",
        "id": 227844392,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289532
    },
    {
        "content": "<p>I also pinged folks over in the embedded land; <span class=\"user-mention\" data-user-id=\"263083\">@Daniel Egger</span> mentioned <a href=\"https://blog.drogue.io/introducing-drogue-device/\">Drogue IoT</a>, <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> can you add that to the document if it's not already done?</p>",
        "id": 227844654,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289646
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"348152\">@Dario Nieuwenhuis</span> -- are you Dirbaio from embedded Matrix? :)</p>",
        "id": 227845076,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289810
    },
    {
        "content": "<p>I'd like to see <a href=\"https://matrix.to/#/!BHcierreUuwCMxVqOf:matrix.org/$jmLyltyo4xWSzL2vOxnStokzhWG0h1aEIrFLgcz2cN4?via=matrix.org&amp;via=sorunome.de&amp;via=matrix.coredump.ch\">those points you raised on Matrix</a> incorporated into the doc -- it sounded like partly you were saying that we could factor that list of features I wrote under runtime a bit more carefully</p>",
        "id": 227845261,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289888
    },
    {
        "content": "<p>hello there! yep</p>",
        "id": 227845266,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1614289890
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/227844392\">said</a>:</p>\n<blockquote>\n<ul>\n<li><span class=\"user-mention silent\" data-user-id=\"226095\">Dirkjan Ochtman</span> also mentioned <a href=\"https://docs.rs/futures/0.3.13/futures/task/trait.Spawn.html\">the <code>Spawn</code> trait</a> in futures, but said that tokio doesn't support it because it imposes some perf overhead (I'd like to understand that)</li>\n</ul>\n</blockquote>\n<p>I mean, Tokio also doesn't support it because Tokio doesn't depend on the futures crate. The perf overhead probably has to do with an extra <code>Box</code> layer I think, though looking at it, it uses this <code>FutureObj</code> type which <em>may</em> sidestep that? Not sure.</p>",
        "id": 227845335,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614289918
    },
    {
        "content": "<p>ok -- yeah I guess the question I wanted to understand was not to blame tokio for not understanding it, but to understand if there was an alternative design or something that might be preferred, and why the design is the way it is</p>",
        "id": 227845493,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614289976
    },
    {
        "content": "<p>It's possible that the <code>FutureObj</code> thing they use on that trait is able to avoid the perf problems, but I've only just now become aware of <code>FutureObj</code>, so I would need to look closer.</p>",
        "id": 227845665,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614290046
    },
    {
        "content": "<p>Oh, so is the allocation for the future <em>object</em></p>",
        "id": 227846099,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290269
    },
    {
        "content": "<p>ie., it's so that the trait is dyn-capable?</p>",
        "id": 227846111,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290276
    },
    {
        "content": "<p>Yeah, if the <code>spawn</code> method is generic over the type of future you are spawning, you can't turn <code>Spawn</code> into a trait object, but then you have to take a <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> as argument.</p>",
        "id": 227846235,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614290314
    },
    {
        "content": "<p>the \"but\" in that sentence is confusing me</p>",
        "id": 227846282,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290344
    },
    {
        "content": "<p>I think you mean</p>",
        "id": 227846289,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290346
    },
    {
        "content": "<p>you have to choose between:</p>",
        "id": 227846300,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290351
    },
    {
        "content": "<ul>\n<li>a generic <code>spawn</code>, but not <code>dyn-capable</code></li>\n<li>a method that takes <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code>, which forces an allocation</li>\n</ul>",
        "id": 227846336,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290368
    },
    {
        "content": "<p>yep</p>",
        "id": 227846343,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614290373
    },
    {
        "content": "<p>I'm not sure that's 100% true though, you could have both, but it's annoying and hacky</p>",
        "id": 227846357,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290383
    },
    {
        "content": "<p>and it probably has ergonomics pain</p>",
        "id": 227846376,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290393
    },
    {
        "content": "<p>that helps, thanks!</p>",
        "id": 227846388,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290398
    },
    {
        "content": "<p>If Spawn was written with generics, which would preclude trait objects, you would have no objections?</p>",
        "id": 227846538,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1614290452
    },
    {
        "content": "<p>Not being able to put the spawner into a trait object would probably be pretty painful for libraries that take a spawner as argument.</p>",
        "id": 227846755,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614290545
    },
    {
        "content": "<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 227847046,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1614290654
    },
    {
        "content": "<p>For embedded having to allocate is really bad :(</p>",
        "id": 227847101,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1614290690
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/227844072\">said</a>:</p>\n<blockquote>\n<p>For example I was asking <span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> if Fuchsia has a list of crates.io-hosted crates that they use; any such crates are presumably portable in some way, unless they are specific to Fuchsia</p>\n</blockquote>\n<p>We do: <a href=\"https://cs.opensource.google/fuchsia/fuchsia/+/master:third_party/rust_crates/Cargo.toml\">https://cs.opensource.google/fuchsia/fuchsia/+/master:third_party/rust_crates/Cargo.toml</a></p>",
        "id": 227847227,
        "sender_full_name": "tmandry",
        "timestamp": 1614290751
    },
    {
        "content": "<p>There are two things in my mind:</p>\n<ul>\n<li>we could have a separate methods:<br>\n    * <code>fn spawn_obj(&amp;self, future: FutureObj&lt;'static, ()&gt;) -&gt; Result&lt;(), SpawnError&gt;;</code><br>\n    * <code>fn spawn(&amp;self, future: impl Future&lt;'static, ()&gt;) -&gt; Result&lt;(), SpawnError&gt; where Self: Sized;</code></li>\n<li><code>global_allocator</code>s already are _not_ trait object safe, worth a shot to see what the experience is there</li>\n</ul>",
        "id": 227847392,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1614290813
    },
    {
        "content": "<p>it's good to talk about solutions-- but I think it'd be better to catalog challenges</p>",
        "id": 227847440,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290832
    },
    {
        "content": "<p>for example, I'd like to consider language changes to make dyn work better :)</p>",
        "id": 227847461,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614290843
    },
    {
        "content": "<p>Are you thinking of unsized locals?</p>",
        "id": 227847859,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1614291030
    },
    {
        "content": "<p>Making dyn work better sounds like a great idea.</p>",
        "id": 227849241,
        "sender_full_name": "Daniel Egger",
        "timestamp": 1614291554
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119031\">Esteban Küber</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/227847859\">said</a>:</p>\n<blockquote>\n<p>Are you thinking of unsized locals?</p>\n</blockquote>\n<p>I don't know yet =)</p>",
        "id": 227851410,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614292646
    },
    {
        "content": "<p>futures team is also not very happy with the current Spawn and FutureObj.</p>\n<p>FutureObj is basically a workaround until unsized rvalue stabilizes. See <a href=\"https://github.com/rust-lang/futures-rs/issues/1634#issuecomment-495513571\">https://github.com/rust-lang/futures-rs/issues/1634#issuecomment-495513571</a> for more.</p>\n<p>AFAIK, there are several reasons why the ecosystem doesn't use futures Spawn, one of the main reasons is stability (<a href=\"https://rust-lang.github.io/api-guidelines/necessities.html#public-dependencies-of-a-stable-crate-are-stable-c-stable\">api-guideline's C-stable</a>) and the other is that the current Spawn API forces implementer the use of FutureObj (it's not very easy to use).</p>",
        "id": 227871222,
        "sender_full_name": "Taiki Endo",
        "timestamp": 1614305089
    },
    {
        "content": "<p>Another problem with futures 0.3 Spawn is that its API doesn't support something like <a href=\"https://docs.rs/tokio/1.2.0/tokio/task/struct.JoinHandle.html\">JoinHandle</a>.</p>",
        "id": 227872936,
        "sender_full_name": "Taiki Endo",
        "timestamp": 1614306450
    },
    {
        "content": "<p>I was planning to work on these API issues in futures 0.4, but the pressure I recently received from the member of wg-async-foundation was enough to take away my energy, so I'm not sure if I can finish it.</p>",
        "id": 227872942,
        "sender_full_name": "Taiki Endo",
        "timestamp": 1614306464
    },
    {
        "content": "<p>There are also <strong>behavior</strong> differences between spawn implementations. For example, some executors cancel the spawned task when the handle is dropped, others do not.</p>",
        "id": 227966255,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1614362400
    },
    {
        "content": "<p>yes, I had that section in the doc</p>",
        "id": 227979291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614367766
    },
    {
        "content": "<p>I added some notes about fuchsia and our experience integrating hyper</p>",
        "id": 228493313,
        "sender_full_name": "tmandry",
        "timestamp": 1614722159
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> there's a couple of scheduler characteristics not covered in this document, especially ones on bare-metal devices and runtimes and e.g. the ones used in gstreamer and such (Sebastian Droege is the person to contact there)</p>",
        "id": 228506218,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614727804
    },
    {
        "content": "<p>That's helpful, <span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> -- <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> <span aria-label=\"point up\" class=\"emoji emoji-1f446\" role=\"img\" title=\"point up\">:point_up:</span>  maybe you want to talk to Sebastian Droege</p>",
        "id": 228507353,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614728415
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> re: GNOME/Rust runtime, right?</p>",
        "id": 228507487,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1614728494
    },
    {
        "content": "<p>right</p>",
        "id": 228507496,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614728502
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> do you have specific thoughts about bare-metal devices or suggestions for who to talk to? I've been talking some to <span class=\"user-mention\" data-user-id=\"348152\">@Dario Nieuwenhuis</span></p>",
        "id": 228507782,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614728657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228493313\">said</a>:</p>\n<blockquote>\n<p>I added some notes about fuchsia and our experience integrating hyper</p>\n</blockquote>\n<p>these are the notes about \"lots of code\", <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> ?</p>",
        "id": 228508322,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614728966
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> yep</p>",
        "id": 228524959,
        "sender_full_name": "tmandry",
        "timestamp": 1614738922
    },
    {
        "content": "<p>I know it's a bit terse :)</p>",
        "id": 228525059,
        "sender_full_name": "tmandry",
        "timestamp": 1614738987
    },
    {
        "content": "<p>we were able to integrate successfully but in an ideal world it would have allowed for more reuse of hyper's code (which is tied to tokio today)</p>",
        "id": 228525110,
        "sender_full_name": "tmandry",
        "timestamp": 1614739042
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211727\">@Jonas Schievink  [he/him]</span> ^^, also for RTOS like systems (which usually already have a task model)</p>",
        "id": 228555247,
        "sender_full_name": "Florian Gilcher",
        "timestamp": 1614760758
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"243965\">@Sean McArthur</span> I was talking to <span class=\"user-mention\" data-user-id=\"269568\">@Jacob Rothstein</span> about the web framework he's been building, which aims to be truly portable across runtimes, and I thought he might be a useful person to check out some of the stories you've been working on and/or provide some data :)</p>",
        "id": 228875455,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614903864
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span></p>",
        "id": 228875521,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614903908
    },
    {
        "content": "<p><span aria-label=\"wave\" class=\"emoji emoji-1f44b\" role=\"img\" title=\"wave\">:wave:</span> is the framework public? or do you prefer to chat in private?</p>",
        "id": 228875730,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614904021
    },
    {
        "content": "<p>happy to share whatever mistakes i'm making! repo is still private, but there are async-std, standalone smol, and tokio runtimes. the networking layer and task blocking and  spawning are the only parts that are runtime-specific currently</p>",
        "id": 228875774,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614904062
    },
    {
        "content": "<p>(cc <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> too)</p>",
        "id": 228875867,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614904097
    },
    {
        "content": "<p>it's still private, but i'm happy to share it with you and it will be open source</p>",
        "id": 228875872,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614904100
    },
    {
        "content": "<p>That would be great, but talking about it is also useful. What are the biggest challenges you're encountering so far?</p>",
        "id": 228875947,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1614904166
    },
    {
        "content": "<p>And what was the motivation to make it runtime agnostic?</p>",
        "id": 228875971,
        "sender_full_name": "Esteban Küber",
        "timestamp": 1614904191
    },
    {
        "content": "<p>motivation to make it runtime agnostic is the hardest part of that to answer — i think it was initially \"to see how hard it would be\" but also because it would keep me from assuming any particular library was around, as i noticed frequently happened when working on tide</p>",
        "id": 228876107,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614904268
    },
    {
        "content": "<p>and working on tide and other http-rs crates, there were often issues asking for tokio support, but the suggested approach was to compile both and use compatibility features</p>",
        "id": 228876245,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614904337
    },
    {
        "content": "<p>i also have chatted with a bunch of new async rust developers interested in web dev about how to get started, and the story is \"well, first you have to choose a runtime, and that will determine the ecosystem available to you\"</p>",
        "id": 228876586,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614904545
    },
    {
        "content": "<p>and to the extent that i want this project i'm working on to be approachable, i want to make runtime selection orthogonal, even if i have a default recommendation (which currently is smol)</p>",
        "id": 228876701,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614904604
    },
    {
        "content": "<p>other upsides: i'm also interested in eventually supporting bastion at some point, and my runtime entrypoint allows me to consider aws lambda \"a runtime\" even though i'm currently running inside of tokio</p>",
        "id": 228876937,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614904801
    },
    {
        "content": "<p>for tokio, I currently use async-compat to make tokio tcpstreams AsyncRead and AsyncWrite, and from there on it's all fairly straightforward, to the extent that a http implementation and web framework can be straightforward</p>",
        "id": 228877323,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614905043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"269568\">Jacob Rothstein</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228876586\">said</a>:</p>\n<blockquote>\n<p>i also have chatted with a bunch of new async rust developers interested in web dev about how to get started, and the story is \"well, first you have to choose a runtime, and that will determine the ecosystem available to you\"</p>\n</blockquote>\n<p>I can see how that'd be daunting to a newcomer, for sure. I dunno if this helps, when someone asks me about making a web server, I tell them there's several frameworks around, and picking one depends on your preferred style. There's the attribute/macro style, functional and composing, table-of-contents router... sometimes they then tell me what framework they're most used to, and it's easier to recommend they go look at a similar style in Rust.</p>",
        "id": 228877532,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614905155
    },
    {
        "content": "<p>In one way, that completely skips the runtime aspect, but sometimes they may come back and wonder about runtimes afterwards, so I dunno...</p>",
        "id": 228877638,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614905199
    },
    {
        "content": "<p>it does skip the runtime selection, but then at some point they run into \"this other library i want to use assumes and requires the runtime that my preferred library doesn't use, what do i do?\"</p>",
        "id": 228877695,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614905243
    },
    {
        "content": "<p>/me nods</p>",
        "id": 228877707,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614905265
    },
    {
        "content": "<p>in http-rs land, that was often \"i want to use tide and surf, but i also want to use rusoto\"</p>",
        "id": 228877718,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614905281
    },
    {
        "content": "<p>Jumping in to note that at work, we use Tide &amp; Rusoto together, for better or worse</p>",
        "id": 228877988,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614905408
    },
    {
        "content": "<p>yep, it's totally possible — it's just an example of the sort of thing that gets awkward when people just pick their favorite framework and assume unrelated libraries can be mixed and matched easily</p>",
        "id": 228878121,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614905507
    },
    {
        "content": "<p>Honestly, async-compat made it very easy. but it's the kind of thing you'd need to look for, which while i do, I couldn't expect most of my coworokers to know where to look</p>",
        "id": 228878234,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614905576
    },
    {
        "content": "<p>another broad pain point of doing runtime-independent development: it's not necessarily better when a library has feature flags for async-std vs tokio like sqlx does, since those flags need to get propagated up through dependencies to the user's application</p>",
        "id": 228878270,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614905603
    },
    {
        "content": "<p>the sqlx story has been pretty good for us on the runtime end, haven't had issues with async there</p>",
        "id": 228878312,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614905642
    },
    {
        "content": "<p>true, but your code is entirely async-std-native, right?</p>",
        "id": 228878391,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614905675
    },
    {
        "content": "<p>Yeah, aside from Rusoto</p>",
        "id": 228878401,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614905688
    },
    {
        "content": "<p>the feature flag pain isn't one i've really had to wrangle with yet, so it might compose just fine without my code needing to know which flavor they're using</p>",
        "id": 228878624,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614905843
    },
    {
        "content": "<p>Regarding choosing a runtime though, I have seen people run into issues, and some code at my employer used 3(!) runtimes prior to my arrival.<br>\n(I've moved us to reduce that where possible - I'm a bit wary on an observability / predictability point of view.)</p>\n<p>I also see a lot of people <del>weary</del> wary of choosing a runtime, I suppose just because it's explicit. After all, if you choose e.g. Node.js, you are choosing a runtime. And there are, I think, multiple ruby runtimes.</p>",
        "id": 228878835,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614905978
    },
    {
        "content": "<p>\"weary\" as in tired? Because they have to pick one often?</p>",
        "id": 228879022,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614906070
    },
    {
        "content": "<p>there are multiple ruby interpreters (cruby, jruby, rubinius, and the embedded one), which isn't quite the same. and they all have rubyspec to keep their behavior as close to cruby as possible</p>",
        "id": 228879024,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614906071
    },
    {
        "content": "<p>\"weary\" as in hesitant, I'd say, or maybe also, frustrated, I'm not sure.</p>",
        "id": 228879049,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614906091
    },
    {
        "content": "<p>ah ok, wary. yea that's what i thought at first.</p>",
        "id": 228879131,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614906126
    },
    {
        "content": "<p>as an intermediate async rust developer: i have read the code of several executors and i still don't have a great sense of the design tradeoffs and differences or how/why to guide a decision between them on technical merits</p>",
        "id": 228879262,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614906216
    },
    {
        "content": "<p>and the fact that runtimes (executors) aren't independent of \"async kitchen sink libraries/toolkits/ecosystems\" like tokio and async-std is even more confusing, because it's not actually a decision about the perf characteristics of the executors often</p>",
        "id": 228879553,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614906387
    },
    {
        "content": "<p>I did kinda want the <code>futures</code> crate to have most of the non runtime stuff, in general. It was mentioned in Tokio's discord that one of the advantages of having some of those things (like channels or mutex etc) is that they can use the private \"scheduler task coop\" api to reduce task starvation</p>",
        "id": 228879787,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614906522
    },
    {
        "content": "<p>Simple example of that is <code>while let Some(doodad) = rx.next().await { .. }</code> can make the task hog the entire thread if the channel is ready fast enough.</p>",
        "id": 228879888,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614906587
    },
    {
        "content": "<p>i'm not familiar with the details of that, but i've only been using generic futures stuff that can't reach into the executor/runtime. are any of those hooks universal enough to be generic?</p>",
        "id": 228880000,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614906634
    },
    {
        "content": "<p>I mean, possibly. But the Tokio team so far isn't even certain enough of the exact API to make it public, so making it generic is another step after that...</p>",
        "id": 228880252,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614906774
    },
    {
        "content": "<p>a consequence of that sort of thing is that it means that third party tools get a perf boost by going all-in on one runtime or the other, which is itself a tradeoff the end user would need to make. but as long as less-optimized futures crate stuff works, that seems like a good trade to make for many users, as async rust on the web is probably \"fast enough\" for many use cases compared to whatever else they've been using</p>",
        "id": 228880883,
        "sender_full_name": "Jacob Rothstein",
        "timestamp": 1614907098
    },
    {
        "content": "<p>I'm reading back over this -- I want to try and extract the key takeaways...</p>",
        "id": 228931529,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614940403
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228878234\">said</a>:</p>\n<blockquote>\n<p>Honestly, async-compat made it very easy. but it's the kind of thing you'd need to look for, which while i do, I couldn't expect most of my coworokers to know where to look</p>\n</blockquote>\n<p>I'd be curious, <span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span> or <span class=\"user-mention\" data-user-id=\"269568\">@Jacob Rothstein</span>, to hear a bit more details about this interop. For example, I've heard from others that they get confused they don't realize that there's an initialization step required for the tokio runtime before it can be used. I'm curious if there's a resource that you point people to that explains how to set things up?</p>",
        "id": 228932307,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614940862
    },
    {
        "content": "<p>Also, it seems to me that running two runtimes like this is more of a workaround than a proper solution. Does anyone disagree?</p>",
        "id": 228932346,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614940888
    },
    {
        "content": "<p>I would however be interested to hear about cases where people actively <strong>want</strong> or <strong>need</strong> to have two runtimes -- my assumption is that this would come up in scenarios where one of those runtimes comes from outside Rust, such as the operating system (maybe Mac grand central dispatch) or the environment (e.g., maybe the windowing system has a runtime dispatching events)</p>",
        "id": 228932444,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614940944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"269568\">Jacob Rothstein</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228878270\">said</a>:</p>\n<blockquote>\n<p>another broad pain point of doing runtime-independent development: it's not necessarily better when a library has feature flags for async-std vs tokio like sqlx does, since those flags need to get propagated up through dependencies to the user's application</p>\n</blockquote>\n<p>can you elaborate on this -- by \"propagated through dependencies\", I think you mean -- the final application has to add a dependency on sqlx just to specify feature flags, but that is weird, because maybe the final application doesn't even know that sqlx is in use?</p>",
        "id": 228933035,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614941240
    },
    {
        "content": "<p>(or would prefer not to know)</p>",
        "id": 228933040,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614941245
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228878835\">said</a>:</p>\n<blockquote>\n<p>Regarding choosing a runtime though, I have seen people run into issues, and some code at my employer used 3(!) runtimes prior to my arrival.<br>\n(I've moved us to reduce that where possible - I'm a bit wary on an observability / predictability point of view.)</p>\n</blockquote>\n<p>I'd really like to hear specifics, <span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span>, about those issues -- also how did it come to happen that they had 3 runtimes?</p>",
        "id": 228933159,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614941320
    },
    {
        "content": "<p>We're going to need to know specifics if we're going to write the <a href=\"https://rust-lang.github.io/wg-async-foundations/vision/status_quo.html\">status quo stories</a> properly :)</p>",
        "id": 228933230,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614941366
    },
    {
        "content": "<p>I'm sensing there's a good story here</p>",
        "id": 228933400,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614941455
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228931529\">said</a>:</p>\n<blockquote>\n<p>I'm reading back over this -- I want to try and extract the key takeaways...</p>\n</blockquote>\n<p>ok, I made some <a href=\"https://hackmd.io/qWochQxbQAiqwf0vYVJfqw?edit\">notes in a hackmd</a> -- I'd love it <span class=\"user-mention\" data-user-id=\"269568\">@Jacob Rothstein</span>, <span class=\"user-mention\" data-user-id=\"319552\">@Jeremiah Senkpiel</span>, <span class=\"user-mention\" data-user-id=\"243965\">@Sean McArthur</span>, and <span class=\"user-mention\" data-user-id=\"119031\">@Esteban Küber</span> if y'all wanted to take a look. I also left various <strong>Niko asks</strong> sections that cover some of my questions :) I'd like to elaborate these a bit more and then move them eventually into the <a href=\"https://rust-lang.github.io/wg-async-foundations/conversations.html\">conversations section</a></p>",
        "id": 228933981,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614941782
    },
    {
        "content": "<p><strong>Regarding async-compat:</strong></p>\n<p>I don't know of any doc beyond the docs for async-compat itself: <a href=\"https://crates.io/crates/async-compat\">https://crates.io/crates/async-compat</a></p>\n<p>I knew about the tokio executor initialization thing, but forgot and still ran into that problem. It was annoying.<br>\nI can't say I am sure what benefit it gives tokio to require this but I do think that people in a primarily async-std/smol codebase likely find it offputting.</p>\n<p>The code we really needed this for is to stream a body from Rusoto out through a Tide api unaltered, code like such:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">Body</span>::<span class=\"n\">from_reader</span><span class=\"p\">(</span><span class=\"n\">BufReader</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">into_async_read</span><span class=\"p\">().</span><span class=\"n\">compat</span><span class=\"p\">()),</span><span class=\"w\"> </span><span class=\"nb\">None</span><span class=\"p\">,)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 228990718,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614964815
    },
    {
        "content": "<p>Frankly, we'd rather not be interfacing with tokio for this. It is a compromise of the AWS api being so complicated that we're willing to compromise to get an 'on-rails' client for it.</p>",
        "id": 228990874,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614964875
    },
    {
        "content": "<blockquote>\n<p>nikomatsakis: </p>\n<p>the final application has to add a dependency on sqlx just to specify feature flags, but that is weird, because maybe the final application doesn't &gt; even know that sqlx is in use?</p>\n<p>nikomatsakis: (or would prefer not to know)</p>\n</blockquote>\n<p>This is maybe surprising but isn't much of an issue, a walk through <code>cargo tree</code> looking for tokio found us (not speaking for Jacob) all of the places tokio was actually being used (and wasn't just there for compat).</p>",
        "id": 228991248,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614965034
    },
    {
        "content": "<p>(Personally, I'd also like to avoid pulling it in as a compat dep when no compat is needed, for build times and size.)</p>\n<p>(This is also what <a href=\"https://github.com/bikeshedder/deadpool/issues/88\">https://github.com/bikeshedder/deadpool/issues/88</a> is about.)</p>",
        "id": 228991776,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614965225
    },
    {
        "content": "<p><strong>Regarding the multi-runtime thing:</strong></p>\n<p>Ok so, my employer's first (tiny) Rust service:</p>\n<p>A slackbot for posting build &amp; deploy statuses to a slack channel with per-build/deploy threading.</p>\n<ul>\n<li>Tide was used as the external \"post to this\" http api.(my colleagues chose Tide already before I arrived, despite it also being my own preference - this is because they believed it to be the best candidate to be able to hand to non-deeply-rust developers.)</li>\n<li>Surf was used as the \"post to slack\" http client. (Likely to go hand in hand with Tide)</li>\n<li>The Redis crate was used for redis, to remember some id's for threading.</li>\n<li>Smol was used as the executor because it was new and shiny at the time and one of my colleagues liked it. (It was used with the <code>\"tokio02\"</code> feature.)</li>\n</ul>\n<p>This ends up pulling 3 executors in and I believe actually using two (and also, a third or more threadpool(s) in C):</p>\n<ul>\n<li>Tide &amp; Surf  pull in async-std regardless of specifying smol, although then they do not execute off of it.</li>\n<li>Redis by default pulls in and uses Tokio (as far as I remember)</li>\n<li>Using smol here did not really have much advantage, async-std very soon after switched internally to smol and then later to the underlying crate, async-executor, and then later to async-global-executor (the same thing but globally shared).</li>\n<li>Surf by default uses libcurl through isahc (we still use this but we are looking to move away, something I'm working on)</li>\n</ul>\n<p>Most of this was made cleaner by:</p>\n<ul>\n<li>Removing smol directly, using <code>#[async_std::main]</code></li>\n<li>Setting the redis features to <code>[ \"aio\", \"async-std-comp\" ]</code></li>\n</ul>",
        "id": 228994306,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614966197
    },
    {
        "content": "<p>Thinking through what a user would experience, if they pick a web framework that is agnostic over runtimes, then in order for them to get the thing up and running, don't they then need to go decide on a runtime anyways? I think that's fine, but it also seems to bump into that users are \"wary\" of having to pick one.</p>",
        "id": 228995478,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614966679
    },
    {
        "content": "<p>Seeing that story of how you added more and more dependencies, and how you made the decisions, is really useful!</p>",
        "id": 228996292,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614967006
    },
    {
        "content": "<p>As I investigate each of these libraries (some are new to me (hadn't seen deadpool, looks cool!)), I notice that Tide (and Surf) both uses async-std without an option to pick another (I suppose the suggestion there is to enable async-std's compat?). I'm curious how much that affects ones decision to use a particular runtime. If Tide had the option to use a different one completely, would that have influenced anything, or was your decision for other reasons (if we ignore someone wanting to try something \"new and shiny\").</p>",
        "id": 228996309,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614967014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228932444\">said</a>:</p>\n<blockquote>\n<p>I would however be interested to hear about cases where people actively <strong>want</strong> or <strong>need</strong> to have two runtimes -- my assumption is that this would come up in scenarios where one of those runtimes comes from outside Rust, such as the operating system (maybe Mac grand central dispatch) or the environment (e.g., maybe the windowing system has a runtime dispatching events)</p>\n</blockquote>\n<p>How does multiple runtimes interact with I want multiple drivers? In this I don't see a clear definition of runtime and I think that makes it even more confusing. As a user they should be able to pick and choose those drivers and use the same executor i think that is ideal. But like right now if a user wants to use libaio/io_uring they would need to add another \"runtime\" or driver with its own thread. There is likely some intersection here.</p>",
        "id": 229002559,
        "sender_full_name": "Lucio Franco",
        "timestamp": 1614969332
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"207781\">@Lucio Franco</span> yes likely! I feel like we tend to 'bundle up' a few things into the word 'runtime' (reactor, executor, utilities maybe?) and we probably want eventually some portability across those</p>",
        "id": 229004182,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614969995
    },
    {
        "content": "<p>I think a big win that would be pretty easy is to very clearly define these terms (and maybe change some!) because I think a lot of the confusion new users have is what is a runtime? What is a reactor?</p>",
        "id": 229004481,
        "sender_full_name": "Lucio Franco",
        "timestamp": 1614970113
    },
    {
        "content": "<p>I personally have found async-compat quite useful as well. I wish I had known about it early in my adventures of learning async.</p>",
        "id": 229004633,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614970179
    },
    {
        "content": "<p>I spent a while in the general mindset of \"there are multiple choices here, everything doesn't automatically interoperate, so this must not be mature enough for me to want to get into,. I'll just write sync code\".</p>",
        "id": 229004838,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614970260
    },
    {
        "content": "<p>Then when smol and async-std aligned, and I found async-compat, I realized that I didn't have to choose. This was around the time I was starting to experiment with the mindset of \"don't worry about calling clone, wait to optimize until you know you need to\".</p>",
        "id": 229005076,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614970347
    },
    {
        "content": "<p>So now I just use smol/async-std, and use async-compat when I need to call a library that needs them.</p>",
        "id": 229005149,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614970383
    },
    {
        "content": "<p>And I no longer feel like I'm limited to a subset of the ecosystem.</p>",
        "id": 229005186,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1614970397
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/229004838\">said</a>:</p>\n<blockquote>\n<p>\"there are multiple choices here, everything doesn't automatically interoperate, so this must not be mature enough for me to want to get into\".</p>\n</blockquote>\n<p>Hm, interesting! I'm certain some others will feel the same way, so worth understanding better. And in other places, people accept that things don't work together more easily, like if I look in Java or Scala, right?</p>",
        "id": 229006058,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1614970738
    },
    {
        "content": "<blockquote>\n<p>nikomatsakis: I would however be interested to hear about cases where people actively want or need to have two runtimes -- my assumption is that this would come up in scenarios where one of those runtimes comes from outside Rust, such as the operating system (maybe Mac grand central dispatch) or the environment (e.g., maybe the windowing system has a runtime dispatching events)</p>\n</blockquote>\n<p>Maybe the GTK folks have a view on this, since I think they'll usually operate within the glib event loop?</p>",
        "id": 229012221,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1614973122
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"226095\">@Dirkjan Ochtman</span> yeah, I was thinking that</p>",
        "id": 229012879,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614973371
    },
    {
        "content": "<p>I did ping <span class=\"user-mention\" data-user-id=\"301846\">@Sebastian Dröge</span> and try to setup a time to talk to him about it, not sure if there are others worth pinging</p>",
        "id": 229012908,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614973383
    },
    {
        "content": "<p>that's also the primary name I could come up with</p>",
        "id": 229012962,
        "sender_full_name": "Dirkjan Ochtman",
        "timestamp": 1614973400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228991248\">said</a>:</p>\n<blockquote>\n<p>This is maybe surprising but isn't much of an issue, a walk through <code>cargo tree</code> looking for tokio found us (not speaking for Jacob) all of the places tokio was actually being used (and wasn't just there for compat).</p>\n</blockquote>\n<p>that makes sense. Seems like something you have to know to do, though.</p>",
        "id": 229013507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614973635
    },
    {
        "content": "<p>(not really following here, just got a notification that my name was mentioned) apart from gstreamer, i'm also the one who wrote the async integration in gtk-rs. we can also talk about that next week <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> for usage for building GTK UIs, Bodil Stokke (vgtk) and Antoni Boucher (relm) might be worth talking to. vgtk uses futures all over the place, relm might be especially interesting because it used futures long ago but moved away for some reason i don't know/remember</p>",
        "id": 229015508,
        "sender_full_name": "Sebastian Dröge",
        "timestamp": 1614974497
    },
    {
        "content": "<p>ah, nice</p>",
        "id": 229015565,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614974521
    },
    {
        "content": "<p>ok</p>",
        "id": 229015634,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614974535
    },
    {
        "content": "<p>relm/vgtk are basically elm/react/etc inspired APIs on top of gtk</p>",
        "id": 229015819,
        "sender_full_name": "Sebastian Dröge",
        "timestamp": 1614974611
    },
    {
        "content": "<p>maybe you can send me their emails</p>",
        "id": 229015856,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614974629
    },
    {
        "content": "<p>or I think maybe I have see them on twitter</p>",
        "id": 229015877,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1614974637
    },
    {
        "content": "<p>sure, sent you a mail with the details :)</p>",
        "id": 229016601,
        "sender_full_name": "Sebastian Dröge",
        "timestamp": 1614974923
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"243965\">Sean McArthur</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/228996309\">said</a>:</p>\n<blockquote>\n<p>As I investigate each of these libraries (some are new to me (hadn't seen deadpool, looks cool!)), I notice that Tide (and Surf) both uses async-std without an option to pick another (I suppose the suggestion there is to enable async-std's compat?). I'm curious how much that affects ones decision to use a particular runtime. If Tide had the option to use a different one completely, would that have influenced anything, or was your decision for other reasons (if we ignore someone wanting to try something \"new and shiny\").</p>\n</blockquote>\n<p>Yeah the suggestion we (the http-rs folks) would make is to enable compat on async-std and/or use async-compat.<br>\n<em>(Edit: particularly for Tide. I'm pretty sure Tide technically can have swappable backends too, but there isn't a hyper one written. Surf can use a hyper backend but is pretty bare-bones (and also has no option to use rustls).)</em></p>\n<p>Both myself and my employer were picking lighter weight, easier to understand options than tokio regardless.<br>\n(Note that a lot of that decision making happened almost a year ago, I know tokio has moved closer to just using futures now, which I personally think is a good thing.)</p>",
        "id": 229022511,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614977460
    },
    {
        "content": "<p>Speaking of rustls... We have similar issues between native-tls and rustls, and choosing one or the other, or knowing what crates can or can't support one or the other.</p>",
        "id": 229022942,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614977628
    },
    {
        "content": "<blockquote>\n<p>What is a reactor?</p>\n</blockquote>\n<p>Also I'm going to throw this in here. <strong>I</strong> <em>still</em> have no idea what a reactor is or why I'd need one. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 229028335,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614979963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"319552\">Jeremiah Senkpiel</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/portability.20and.20runtimes/near/229028335\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>What is a reactor?</p>\n</blockquote>\n<p>Also I'm going to throw this in here. <strong>I</strong> <em>still</em> have no idea what a reactor is or why I'd need one. <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>\n</blockquote>\n<p>The reactor is a component in the runtime that knows about all the IO resources used inside the runtime, and which knows when each IO resource is ready so it can have the runtime poll them when and only when they become ready.</p>",
        "id": 229029817,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614980737
    },
    {
        "content": "<p><del>(Turns out it's a fancy name for a task scheduler!)</del></p>",
        "id": 229029840,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614980754
    },
    {
        "content": "<p>I mean, it's not really the task scheduler. The task scheduler is the one who actually runs the tasks, whereas the reactor just tells the task scheduler when IO resources become ready. In particular, other resources that don't depend on the reactor (e.g. mpsc channel) would talk directly to the task scheduler, not going through the reactor at all.</p>",
        "id": 229030080,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614980874
    },
    {
        "content": "<p>As I understand it, in smol the task scheduler and reactor are even entirely separate in <code>async-executor</code> and <code>async-io</code> respectively, where neither depends on the other. (but I may be wrong)</p>",
        "id": 229030271,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1614980988
    },
    {
        "content": "<p>So it is an io polling event loop, and the task scheduler exists to thread things once we have an io event read? Is that right?</p>",
        "id": 229031739,
        "sender_full_name": "Jeremiah Senkpiel",
        "timestamp": 1614981692
    },
    {
        "content": "<p>Right. It's the thing that calls epoll/select/etc and then <em>reacts</em> to things.</p>",
        "id": 229116490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1615053707
    },
    {
        "content": "<p>The last time I checked, smol runs the io reactor on a separate thread which (on linux, for example) calls epoll and then wakes up the relevant task using <code>waker.wake()</code>.</p>",
        "id": 229137852,
        "sender_full_name": "Ahmed Charles",
        "timestamp": 1615073034
    }
]