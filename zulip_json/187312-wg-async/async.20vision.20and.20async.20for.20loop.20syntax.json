[
    {
        "content": "<p>Oh no, I think maybe I got the order wrong in mine...</p>",
        "id": 270789815,
        "sender_full_name": "eholk",
        "timestamp": 1644019390
    },
    {
        "content": "<p>No, your order reflected what was being proposed</p>",
        "id": 270789826,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644019403
    },
    {
        "content": "<p>I think we're in agreement that the order of operations matter in the order of the keywords</p>",
        "id": 270789849,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644019425
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270789587\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span>'s suggestion to use braces makes the ordering clear, although I worry that the braces might be a little heavy syntactically.</p>\n</blockquote>\n<p>I'm actually still not clear on the ordering even with braces. I parse <code>for async try x in ...</code> as <code>for async { try { x } } in ...</code>, but it's not obvious if the ordering comes from \"pulling\" the <code>...</code> through the blocks or \"pulling\" the <code>x</code> through the blocks, which would produce two different orders.</p>",
        "id": 270789906,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019447
    },
    {
        "content": "<p>So... I guess it's just a matter of keywords between the <code>for</code> keyword and the variable created</p>",
        "id": 270789928,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644019466
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270789658\">said</a>:</p>\n<blockquote>\n<p><del>Oh yeah sorry I wrote an iterator of fallible futures <span aria-label=\"face palm\" class=\"emoji emoji-1f926\" role=\"img\" title=\"face palm\">:face_palm:</span></del></p>\n<p>No wait, <code>Some((x, ))</code> first <code>.unwrap()</code>s, then does the <code>.0</code>, so <code>for async try</code> would indeed handle the <code>.await</code> first, and then the <code>?</code>: that is, we still read left-to-right, it's just that the binding is at the right of it all</p>\n</blockquote>\n<p>Edited it</p>",
        "id": 270789940,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644019484
    },
    {
        "content": "<p>I'm trying to think of this with a rough analogy to doing algebra, where <code>async { }</code> and <code>.await</code> are inverses, and <code>try { }</code> and <code>?</code> are inverses.</p>",
        "id": 270789984,
        "sender_full_name": "eholk",
        "timestamp": 1644019529
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> That seems to assume that a future is logically an <code>async { code }</code> block, and you're pattern-matching away the <code>async { }</code> part as if it were a constructor.</p>",
        "id": 270789990,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019534
    },
    {
        "content": "<p>Which makes a kind of sense, but it isn't clear to me that it's the only semantic interpretation.</p>",
        "id": 270790010,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019547
    },
    {
        "content": "<p>I think it's clear. Everything left of the <code>in</code> is left-to-right, everything right of is right-to-left</p>",
        "id": 270790012,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644019551
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252217\">@Khionu Sybiern</span> s/left-to-right/outside-to-inside/ (since patterns can nest)?</p>",
        "id": 270790076,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019580
    },
    {
        "content": "<p>Yeah</p>",
        "id": 270790090,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644019597
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270789984\">said</a>:</p>\n<blockquote>\n<p>I'm trying to think of this with a rough analogy to doing algebra, where <code>async { }</code> and <code>.await</code> are inverses, and <code>try { }</code> and <code>?</code> are inverses.</p>\n</blockquote>\n<p>So you'd do something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>let async { try { x } } = foo;\n</code></pre></div>\n<p>-&gt;</p>\n<div class=\"codehilite\"><pre><span></span><code>let async { try { x } }.await = foo.await;\n</code></pre></div>\n<p>-&gt;</p>\n<div class=\"codehilite\"><pre><span></span><code>let try { x } = foo.await;\n</code></pre></div>\n<p>-&gt;</p>\n<div class=\"codehilite\"><pre><span></span><code>let try { x }? = foo.await?;\n</code></pre></div>\n<p>-&gt;</p>\n<div class=\"codehilite\"><pre><span></span><code>let x = foo.await?;\n</code></pre></div>",
        "id": 270790091,
        "sender_full_name": "eholk",
        "timestamp": 1644019597
    },
    {
        "content": "<p>I'd hope that <code>for ANewtype(async try x) in ...</code> also works.</p>",
        "id": 270790099,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019602
    },
    {
        "content": "<p>And writing it that way, I think I <em>do</em> see the parse-order argument for why <code>.await?</code> could be confusing as well; in <code>for ANewtype(x.await?) in</code>, you'd peel off the ANewtype, then you'd run <code>await</code> and then <code>?</code>, which is neither fully inside-out nor fully outside-in.</p>",
        "id": 270790161,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019669
    },
    {
        "content": "<p>So, regarding the <code>Future</code> needs to be an <code>async { ... }</code> construct, I think we can then defer (<del>deref</del> <span aria-label=\"stuck out tongue closed eyes\" class=\"emoji emoji-1f61d\" role=\"img\" title=\"stuck out tongue closed eyes\">:stuck_out_tongue_closed_eyes:</span>) to the deref patterns proposals, which managed to suggest something trait-impl based rather than raw type based</p>",
        "id": 270790172,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644019682
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> who has had various thoughts on patterns and composability.</p>",
        "id": 270790244,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019709
    },
    {
        "content": "<p>And from there, deconstructing <code>async</code>-pattern would be an <code>.await</code> for any <code>impl Future</code>, and deconstructing a <code>try</code> would be a <code>?</code> for any <code>impl Try</code></p>",
        "id": 270790262,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644019728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270790099\">said</a>:</p>\n<blockquote>\n<p>I'd hope that <code>for ANewtype(async try x) in ...</code> also works.</p>\n</blockquote>\n<p>So that, here, it would be <code>for async try ANewType(x)</code> when against an<br>\n<code>impl IntoIterator&lt;_ = impl Future&lt;_ = impl Try&lt;Output = ANewType&gt;&gt;&gt;</code></p>",
        "id": 270790362,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644019807
    },
    {
        "content": "<p><em>nod</em> (though that's still feeling painful to get the ordering right on), and what I wrote was intended for an iterator of <code>ANewtype</code> wrappers around futures returning results.</p>",
        "id": 270790445,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019913
    },
    {
        "content": "<p>e.g. <code>struct Newtype(Box&lt;dyn Future&lt;Output=Result&lt;...&gt;&gt;&gt;)</code></p>",
        "id": 270790521,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644019967
    },
    {
        "content": "<p>w.r.t. ordering, at least when <em>writing</em> code, the type system would help; but w.r.t. <em>reading</em> code, maybe a warn-by-default-lint could start requiring bracesm, to later on be disabled once ppl get used to it</p>",
        "id": 270790541,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644019995
    },
    {
        "content": "<p>/me is still not convinced that we can't find a readable way to use expression syntax to make this easier to understand the ordering of, though.</p>",
        "id": 270790578,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020035
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270790541\">said</a>:</p>\n<blockquote>\n<p>w.r.t. ordering, at least when <em>writing</em> code, the type system would help; but w.r.t. <em>reading</em> code, maybe a warn-by-default-lint could start requiring bracesm, to later on be disabled once ppl get used to it</p>\n</blockquote>\n<p>The ordering confusion I'm experiencing isn't helped by braces.</p>",
        "id": 270790641,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020061
    },
    {
        "content": "<p>So, another possibility:</p>",
        "id": 270790680,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020100
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270790578\">said</a>:</p>\n<p>It's an interesting venue, for sure <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 270790689,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644020104
    },
    {
        "content": "<p>Haskell has \"view patterns\", in which you can write a pattern like <code>Thing(viewFunction =&gt; AnotherThing(value))</code>.</p>",
        "id": 270790725,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020144
    },
    {
        "content": "<p>We have ... macros <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 270790773,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644020166
    },
    {
        "content": "<p>And that has the semantic effect of matching a Thing, then feeding the insides to <code>viewFunction</code>, then continuing to pattern match on the return value of <code>viewFunction</code>.</p>",
        "id": 270790774,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020167
    },
    {
        "content": "<p>If <code>ANewtype(thing.await?)</code> is confusing as a pattern (and I at least <em>understand</em> why it could be), what if we introduced a view-pattern-like syntax that lets us do things like <code>.await</code> or <code>?</code> and then continue to pattern-match?</p>",
        "id": 270790810,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020208
    },
    {
        "content": "<p>I feel like this should be addressed from the LHS/RHS dichotomy, as the flow of state does reflect it</p>",
        "id": 270790854,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644020266
    },
    {
        "content": "<p>Conceptual bikeshed, not a complete proposal <code>for ANewtype(`.await?` =&gt; thing) in ...</code></p>",
        "id": 270790908,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020297
    },
    {
        "content": "<p>Something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"kr\">do</span><span class=\"w\"> </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>\n<p><span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 270790910,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644020298
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> So, one thought that <em>that</em> raises is that it might make sense to only allow these in infallible patterns, at least for now.</p>",
        "id": 270790935,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020332
    },
    {
        "content": "<p>I wouldn't want this to be how the result of this discussion is explained, but you could say this is destructuring of a Future into it's awaited equivalent</p>",
        "id": 270790951,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644020352
    },
    {
        "content": "<p>If we allowed them in fallible patterns, we'd have to deal with cases like \"what if it doesn't match, will the next pattern await it <em>again</em>?\".</p>",
        "id": 270790955,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270790935\">said</a>:<br>\nThe part after the <code>=&gt;</code> would need to be infallible, yeah</p>",
        "id": 270790974,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644020375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> Fair distinction, yeah; the outer part <em>could</em> be fallible.</p>",
        "id": 270790984,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020392
    },
    {
        "content": "<p>But I also don't have a problem with simplifying to \"the whole thing is only allowed in an infallible-pattern case, such as a loop pattern\".</p>",
        "id": 270791050,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020419
    },
    {
        "content": "<p>So, <code>for SomeWrapper(viewpattern_bikeshed!(.await?) =&gt; thing) in ...</code></p>",
        "id": 270791105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020485
    },
    {
        "content": "<p>Possible bikeshed issues: do we write the expression without a receiver, do we name the receiver somehow...</p>",
        "id": 270791169,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020525
    },
    {
        "content": "<p>I think in the common case, someone would want to <em>not</em> have to name two things if they only need one of those names.</p>",
        "id": 270791185,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020549
    },
    {
        "content": "<p>I was thinking that if it starts with a <code>.</code>, then it's an implicit receiver, otherwise, it's a callable against which it is piped</p>",
        "id": 270791199,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644020562
    },
    {
        "content": "<p>Anyhow, maybe that ought to be split into another thread, for further discussion, and keep the <code>async try</code> discussion here</p>",
        "id": 270791238,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644020619
    },
    {
        "content": "<p>I mean, this whole thread was about syntax and what that syntax should be. :)</p>",
        "id": 270791372,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020741
    },
    {
        "content": "<p>It's not like it's an off-topic syntax bikeshed for an underlying semantic construct; I think we're all in agreement that there should be a construct for looping over futures / results / etc.</p>",
        "id": 270791434,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020775
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"252217\">Khionu Sybiern</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loops/near/270790951\">said</a>:</p>\n<blockquote>\n<p>I wouldn't want this to be how the result of this discussion is explained, but you could say this is destructuring of a Future into it's awaited equivalent</p>\n</blockquote>\n<p>Sorry I haven't understood this <span aria-label=\"bow\" class=\"emoji emoji-1f647\" role=\"img\" title=\"bow\">:bow:</span> Would it be a description of what pattern-matching against <code>async _</code> would do/mean?</p>",
        "id": 270791452,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644020802
    },
    {
        "content": "<p>No, just how we're trying to insert awaiting as an operation</p>",
        "id": 270791487,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644020849
    },
    {
        "content": "<p>Even though <code>async { }</code> is the dual of <code>.await</code>, and <code>try { }</code> is the dual of <code>?</code>, it still doesn't quite feel like a dual in the way that a <em>pattern</em> normally is.</p>",
        "id": 270791569,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020903
    },
    {
        "content": "<p>In particular, I think in part I'm finding it confusing because <code>try { code }</code> typically means \"run this code and catch errors\", and this would be introducing a <em>different</em> meaning of <code>try</code>.</p>",
        "id": 270791624,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020951
    },
    {
        "content": "<p>True. <code>try { }</code> and <code>?</code> are equivalents while <code>async { }</code> and <code>.await</code> are beginning/end</p>",
        "id": 270791633,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644020961
    },
    {
        "content": "<p>Well... no, sorry, confused how <code>try</code> works</p>",
        "id": 270791652,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644020982
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252217\">@Khionu Sybiern</span> I think I don't understand what you meant by that.</p>",
        "id": 270791656,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644020987
    },
    {
        "content": "<p>Nvm, just a blip in my thinking</p>",
        "id": 270791716,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021027
    },
    {
        "content": "<p>I get what you mean, though, about how the relationships feel different</p>",
        "id": 270791731,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021050
    },
    {
        "content": "<p>This feels like it's using <code>try</code> and <code>async</code> to mean something noticeably different than what it usually means.</p>",
        "id": 270791738,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021057
    },
    {
        "content": "<p>One thing that's kind of weird about <code>try { ... }</code> as a pattern is what infallibility means.</p>",
        "id": 270791740,
        "sender_full_name": "eholk",
        "timestamp": 1644021062
    },
    {
        "content": "<p>True</p>",
        "id": 270791753,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644021083
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kr\">try</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270791760,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644021090
    },
    {
        "content": "<p>If <code>let try { x } = foo()</code> is equivalent to <code>let x = foo()?</code>, it's weird that <code>try { ... }</code> on the left hand side leads to a control flow transfer to the end of the function.</p>",
        "id": 270791783,
        "sender_full_name": "eholk",
        "timestamp": 1644021111
    },
    {
        "content": "<p><em>nod</em></p>",
        "id": 270791790,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021121
    },
    {
        "content": "<p>That's a great way of flagging the issue here.</p>",
        "id": 270791837,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021136
    },
    {
        "content": "<p>And yeah, <code>if let try { ... } = foo()</code> is even weirder.</p>",
        "id": 270791843,
        "sender_full_name": "eholk",
        "timestamp": 1644021144
    },
    {
        "content": "<p>We're used to <code>?</code> meaning a control-flow transfer; making <code>try</code> mean a control-flow transfer seems bad.</p>",
        "id": 270791848,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021146
    },
    {
        "content": "<p>If the <code>...</code> returns <code>Err</code>, does the if test fail, or do we return from the function?</p>",
        "id": 270791867,
        "sender_full_name": "eholk",
        "timestamp": 1644021166
    },
    {
        "content": "<p>Likewise, we're used to <code>.await</code> being a suspension point. We're not used to <code>async</code> being a suspension point.</p>",
        "id": 270791869,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021170
    },
    {
        "content": "<p><code>let try { x }</code> then becomes equivalent to <code>let Ok(x)</code></p>",
        "id": 270791871,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021171
    },
    {
        "content": "<p>Yeah that's why I had started with <code>await</code> and <code>?</code> as the patterns themselves, despite the \"inconsistency\" with other patterns</p>",
        "id": 270791887,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644021190
    },
    {
        "content": "<p>I think that captures what's bugging me here: we're making people have two names for the same semantic operation.</p>",
        "id": 270791889,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021194
    },
    {
        "content": "<p>Actually, maybe it should be that simple</p>",
        "id": 270791891,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021198
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"o\">?</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 270791895,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644021199
    },
    {
        "content": "<p><code>for Poll::Ready(x) in vec_of_futures</code></p>",
        "id": 270791913,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021219
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/270791887\">said</a>:</p>\n<blockquote>\n<p>Yeah that's why I had started with <code>await</code> and <code>?</code> as the patterns themselves, despite the \"inconsistency\" with other patterns</p>\n</blockquote>\n<p>Right. But if we're going to make <code>?</code> and <code>await</code> be the patterns themselves, I'd prefer to have them be written like they would be in an expression, despite the ordering inconsistency that introduces.</p>",
        "id": 270791920,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021225
    },
    {
        "content": "<p>Well... nvm</p>",
        "id": 270791922,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021226
    },
    {
        "content": "<p>Is there any reason <code>async for</code> hasn't been brought up?</p>",
        "id": 270791984,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021271
    },
    {
        "content": "<p>Feels like something that would be obvious if there wasn't a clear reason against it</p>",
        "id": 270792027,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021315
    },
    {
        "content": "<p><code>async for</code> reads very well, but then wouldn't \"scale\" / generalize to patterns. But then, do we really need the latter?</p>",
        "id": 270792029,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644021319
    },
    {
        "content": "<p>To me <code>async for</code> reads more like <code>async { for ... }</code></p>",
        "id": 270792032,
        "sender_full_name": "eholk",
        "timestamp": 1644021321
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"252217\">@Khionu Sybiern</span> It has, but 1) it has the same ordering confusion as <code>for async</code> (what does <code>async try for</code> mean), and 2) it doesn't compose, in that you can't use that to handle <code>ANewtype</code>-wrapped futures of results.</p>",
        "id": 270792044,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021337
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/270792032\">said</a>:</p>\n<blockquote>\n<p>To me <code>async for</code> reads more like <code>async { for ... }</code></p>\n</blockquote>\n<p>That too.</p>",
        "id": 270792050,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021347
    },
    {
        "content": "<p>Alrighty, that all makes sense</p>",
        "id": 270792052,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021349
    },
    {
        "content": "<p>Having the async to the right of the <code>for</code> makes it clearer to me that we are awaiting each item in the iterator.</p>",
        "id": 270792053,
        "sender_full_name": "eholk",
        "timestamp": 1644021350
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> Ignoring the exact syntax bikeshed at the moment, would you anticipate any reason why <code>for SomeTupleType(x.await?, y?) in ...</code> (or <code>for SomeTupleType(async try x, try y) in</code>) shouldn't work?</p>",
        "id": 270792142,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021448
    },
    {
        "content": "<p>Maybe it's worth bringing up here that I feel like the <code>ref</code> in <code>if let Some(ref x) = ...</code> is confusing to me, maybe for similar reasons to what we're talking about here?</p>",
        "id": 270792147,
        "sender_full_name": "eholk",
        "timestamp": 1644021458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I don't</p>",
        "id": 270792199,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644021484
    },
    {
        "content": "<p>The only thing I see is the confusion between how this <code>try</code> keyword works and the <code>try</code> block</p>",
        "id": 270792239,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021535
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> Fair. I've gotten used to what <code>ref</code> and <code>ref mut</code> mean, and I feel like these are similar: \"I'm matching a thing, and then I actually want the thing to be processed like this before I get it\".</p>",
        "id": 270792247,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021550
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> heh, <a href=\"https://github.com/danielhenrymantilla/prettyplease-cli/blob/master/src/main.rs#L39-L42\">I love <code>ref</code></a>, but I feel like I'm a minority, so the strangeness budget is indeed something to be mindful of</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>Aside</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>I could rant a bit about why I even like it for <code>let</code>s <span aria-label=\"scream\" class=\"emoji emoji-1f631\" role=\"img\" title=\"scream\">:scream:</span>, but since it's offtopic I won't (feel free to PM if curious)</p>\n</div></div>",
        "id": 270792252,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644021564
    },
    {
        "content": "<p>First you match inwards until you get to the <code>ref</code> or <code>ref mut</code>, then you take the thing you matched and take a <code>&amp;</code> or <code>&amp;mut</code> of that thing respectively.</p>",
        "id": 270792265,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021576
    },
    {
        "content": "<p>This does seem like a \"view\" in a similar way.</p>",
        "id": 270792271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021582
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> I'm in the same group of preferring to write ref and ref mut, though I don't tend to use them in <code>let</code>.</p>",
        "id": 270792310,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644021603
    },
    {
        "content": "<p>Ah, that makes sense! The clarification is helpful.</p>",
        "id": 270792356,
        "sender_full_name": "eholk",
        "timestamp": 1644021656
    },
    {
        "content": "<p>I always feel like <code>let ref x = ...</code> and <code>let &amp;x = ...</code> should mean the same thing.</p>",
        "id": 270792366,
        "sender_full_name": "eholk",
        "timestamp": 1644021677
    },
    {
        "content": "<p>To share what's been on my mind while pondering this, Elixir is the one language I know of that has more powerful pattern matching than Rust, but a lot of that is due to type simplicity and very little (arguably no) syntactic magic. I would be interested in seeing this as simple from the pattern matching perspective as possible, though the whole process of awaiting does add complexity</p>",
        "id": 270792615,
        "sender_full_name": "Khionu Sybiern",
        "timestamp": 1644021951
    },
    {
        "content": "<p><code>for x.await? in ...</code> feels similar to <code>for ref x in ...</code> to me, now that I think about it a little more.</p>",
        "id": 270792626,
        "sender_full_name": "eholk",
        "timestamp": 1644021962
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> I don't tend to use that, because I find <code>for x in something.iter()</code> or similar clearer to me, but I know many people do use it.</p>",
        "id": 270794161,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644023369
    },
    {
        "content": "<p><code>for await x in …</code> is more consistent with <code>ref</code>, so the effect would be that it’s easier to remember what <code>ref</code> does</p>",
        "id": 270803132,
        "sender_full_name": "tmandry",
        "timestamp": 1644033941
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> How would you envision it combining with <code>?</code> or with other patterns, though?</p>",
        "id": 270803373,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644034205
    },
    {
        "content": "<p>I don’t think it’s entirely awful to use <code>?</code> in this way. <code>for ?await? x in …</code> is a little unfortunate but very consistent. you’re applying these operators left-to-right to the thing being matched, not the values you’re binding to</p>",
        "id": 270803381,
        "sender_full_name": "tmandry",
        "timestamp": 1644034241
    },
    {
        "content": "<p>also, that hopefully wouldn’t be common :)</p>",
        "id": 270803391,
        "sender_full_name": "tmandry",
        "timestamp": 1644034272
    },
    {
        "content": "<p>but I like the idea of views in patterns too. that seems generally useful in other ways</p>",
        "id": 270803398,
        "sender_full_name": "tmandry",
        "timestamp": 1644034292
    },
    {
        "content": "<p>if we could add <code>.ref</code> as a suffix operator it would start make more sense, too :)</p>",
        "id": 270803746,
        "sender_full_name": "tmandry",
        "timestamp": 1644034921
    },
    {
        "content": "<p><code>for ?await x in ..</code> seems really... not nice</p>",
        "id": 270803797,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644034980
    },
    {
        "content": "<p>it might be ugly but it seems more consistent</p>",
        "id": 270803950,
        "sender_full_name": "tmandry",
        "timestamp": 1644035232
    },
    {
        "content": "<p>another option is making <code>.try</code> equivalent to <code>?</code> and using <code>try</code>..</p>",
        "id": 270804008,
        "sender_full_name": "tmandry",
        "timestamp": 1644035316
    },
    {
        "content": "<p>I highly value internal consistency, it means simpler mental models</p>",
        "id": 270804082,
        "sender_full_name": "tmandry",
        "timestamp": 1644035430
    },
    {
        "content": "<p>of course I’d also like it if we could figure out a syntax for views so we can sidestep this question :)</p>",
        "id": 270804092,
        "sender_full_name": "tmandry",
        "timestamp": 1644035456
    },
    {
        "content": "<p><code>for x =&gt; x?.await? in …</code> could mean “take this binding, evaluate the expression after =&gt;, and re-bind the result”</p>",
        "id": 270804149,
        "sender_full_name": "tmandry",
        "timestamp": 1644035529
    },
    {
        "content": "<p>but then we’re adding more syntax to the language instead of using it as a chance to reinforce stuff that rust already has</p>",
        "id": 270804162,
        "sender_full_name": "tmandry",
        "timestamp": 1644035613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/270791569\">said</a>:</p>\n<blockquote>\n<p>Even though <code>async { }</code> is the dual of <code>.await</code>, and <code>try { }</code> is the dual of <code>?</code>, it still doesn't quite feel like a dual in the way that a <em>pattern</em> normally is.</p>\n</blockquote>\n<p>i want to push back on this idea that this would be a different kind of dual than other patterns. i agree it could be <em>confusing</em> for <code>let try { x } = foo</code> to transfer control, or for <code>let async { x } = foo</code> to suspend the function, but just like a <code>.x</code> expression corresponds to a <code>Struct { x }</code> pattern, <code>?</code> and <code>.await</code> really would correspond in the same way to <code>try { x }</code> and <code>async { x }</code> patterns.</p>\n<p>instead, i would say that the real difference and source of confusion is that the expression-side \"eliminators\" <code>?</code> and <code>.await</code> have those extra control flow \"side effects,\" while the struct eliminator <code>.x</code> does not.</p>",
        "id": 270806658,
        "sender_full_name": "rpjohnst",
        "timestamp": 1644038775
    },
    {
        "content": "<p>I'm pretty negative about this kind of approach for a few reasons: as mentioned above, the 'backwards' aspect of patterns is a big sticking point for new and intermediate users. I feel that we're in a good place with match ergonomics now, but for most users <code>ref</code> is still a confusing stumbling block. Making patterns more complex feels like it would be a step backwards. Second, I'm wary of patterns executing code rather than being totally passive destructuring. On the technical side, what happens if you have <code>x.await</code> on multiple match arms? Do you await once or twice? But more importantly, I think it makes things confusing for users, building a mental model of pattern matching (which is a new concept for most users) is tricky enough, but having to handle excecuting code as part of that seems rough</p>",
        "id": 270953959,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644227357
    },
    {
        "content": "<p>Also, given the confusion between ref and &amp;, I'm very negative on the specifics of using try/?/Result and of async/await</p>",
        "id": 270954092,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644227430
    },
    {
        "content": "<p>Some (deliberately) weird ideas of mine how to – potentially – extend this.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// x is a Future that outputs 42 now</span>\n<span class=\"fm\">assert_eq!</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">expr</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">// expr was a `Future&lt;Output = &amp;i32&gt;`, now `foo` is a `Future&lt;Output = i32&gt;`</span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// same as</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kr\">try</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"kr\">try</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">?</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"o\">?</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// only works if the Residual is `Copy`</span>\n<span class=\"c1\">// will turn e.g. `bar(): Option&lt;(S, T)&gt;` into</span>\n<span class=\"c1\">// a: Option&lt;S&gt;, and b: Option&lt;T&gt;</span>\n</code></pre></div>",
        "id": 270985604,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644244136
    },
    {
        "content": "<p>Hey all, wondering where the #wg-async-foundations stream is for today's meeting?</p>",
        "id": 270995141,
        "sender_full_name": "Martin Ombura Jr.",
        "timestamp": 1644247928
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"321490\">Martin Ombura Jr.</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/270995141\">said</a>:</p>\n<blockquote>\n<p>Hey all, wondering where the #wg-async-foundations stream is for today's meeting?</p>\n</blockquote>\n<p>This is my first time.. Trying to get the information myself</p>",
        "id": 270995991,
        "sender_full_name": "Abhinav Kumar",
        "timestamp": 1644248277
    },
    {
        "content": "<p>it's a text-chat-only and it happens right here :)</p>",
        "id": 270999837,
        "sender_full_name": "Zeeshan Ali",
        "timestamp": 1644249718
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"400241\">@Zeeshan Ali</span> so I assume it didnt take place today <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 270999946,
        "sender_full_name": "Martin Ombura Jr.",
        "timestamp": 1644249753
    },
    {
        "content": "<p>there are still 25 mins left afaik</p>",
        "id": 271000406,
        "sender_full_name": "Zeeshan Ali",
        "timestamp": 1644249947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"476886\">@Abhinav Kumar</span> - Sorry I didn't see this earlier. We did have the meeting today. It happens in a new topic in this Zulip stream, usually titled \"Triage meeting YYYY-MM-DD.\" Normally the topic doesn't show up until right when we start it, although sometimes I put up a reminder a few minutes before. Hope you can make it next time!</p>",
        "id": 271021796,
        "sender_full_name": "eholk",
        "timestamp": 1644258559
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/270953959\">said</a>:</p>\n<blockquote>\n<p>On the technical side, what happens if you have <code>x.await</code> on multiple match arms? Do you await once or twice?</p>\n</blockquote>\n<p>FWIW, this is a large part of why I'd suggest that we only allow this at a point where the pattern has been otherwise matched and is no longer refutable. Or, for simplicity's sake, only allow it in irrefutable patterns.</p>",
        "id": 271034447,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644264234
    },
    {
        "content": "<p>That would still handle for-loops nicely.</p>",
        "id": 271034503,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644264244
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/271021796\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"476886\">Abhinav Kumar</span> - Sorry I didn't see this earlier. We did have the meeting today. It happens in a new topic in this Zulip stream, usually titled \"Triage meeting YYYY-MM-DD.\" Normally the topic doesn't show up until right when we start it, although sometimes I put up a reminder a few minutes before. Hope you can make it next time!</p>\n</blockquote>\n<p>No problem <span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> I will see you next time.</p>",
        "id": 271074472,
        "sender_full_name": "Abhinav Kumar",
        "timestamp": 1644288821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/270803797\">said</a>:</p>\n<blockquote>\n<p><code>for ?await x in ..</code> seems really... not nice</p>\n</blockquote>\n<p>I've not caught up on everything here <em>but</em> this is not what you would write, though. You want <code>for await? y in x</code> -- the effects for patterns go \"inside out\". The first thing we do is await. The next thing we do is apply <code>?</code>, and then we match what's left with <code>y</code>. If you want <code>for y.await? in x</code> (which might indeed be more learnable, I'd like to test that experimentally), then you do need to \"invert\" the order for postfix patterns (and you get a bunch of fun precedence problems... e.g. <code>&amp;x.await?</code>, what does that mean? (<code>await? &amp;x</code> vs <code>&amp;await? x</code> is unambiguous)</p>",
        "id": 272299479,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121125
    },
    {
        "content": "<p>in case you can't tell I favor extending patterns with</p>\n<div class=\"codehilite\"><pre><span></span><code>Pat := await Pat | ? Pat | ...\n</code></pre></div>\n<p>and then using analysis to ensure that those occur only in \"irrefutable\" positions (perhaps, to start, just in irrefutable patterns like <code>for</code> and <code>let</code>, though I'd like to support them in match arms too if they are guaranteed to execute)</p>",
        "id": 272299634,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121179
    },
    {
        "content": "<p>but I do have concerns because of the experience of <code>&amp;x</code> in pattern vs expr being confusing to folks</p>",
        "id": 272299691,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121197
    },
    {
        "content": "<p>I'm not sure that this is comparable though</p>",
        "id": 272299707,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121207
    },
    {
        "content": "<p>It seems not comparable, in that I expect await and ? as prefixes to be <em>harder</em> to deal with than &amp;.</p>",
        "id": 272300624,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121614
    },
    {
        "content": "<p>With &amp;, you're matching a reference with &amp; which logically \"peels off\" the &amp; and leaves you with the thing it references.</p>",
        "id": 272300752,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121665
    },
    {
        "content": "<p>Match &amp;x against &amp;thing and clearly x is thing.</p>",
        "id": 272300779,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121683
    },
    {
        "content": "<p>people do not experience it that way</p>",
        "id": 272300806,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121696
    },
    {
        "content": "<p>but carry on :)</p>",
        "id": 272300821,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121704
    },
    {
        "content": "<p>Hi, I'm a people. ;)</p>",
        "id": 272300849,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121714
    },
    {
        "content": "<p>there exist people who do not see it that way, is what I mean</p>",
        "id": 272300869,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121723
    },
    {
        "content": "<p>not all people, I agree, poor phrasing :)</p>",
        "id": 272300879,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121730
    },
    {
        "content": "<p>But acknowledged that this isn't the universal interpretation. It just seems like a logical one.</p>",
        "id": 272300888,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121735
    },
    {
        "content": "<p>in any case, you're saying that <code>await x</code> as a pattern doesn't lend itself to that interpretation?</p>",
        "id": 272300920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121754
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272300888\">said</a>:</p>\n<blockquote>\n<p>But acknowledged that this isn't the universal interpretation. It just seems like a logical one.</p>\n</blockquote>\n<p>I think part of is that the <code>&amp;x</code> rarely appears in the expression</p>",
        "id": 272300982,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121769
    },
    {
        "content": "<p>With await and ?, You don't use those symbols to construct the thing in the first place, so there's nothing for those symbols to match directly, and you have to think of them more abstractly.</p>",
        "id": 272300986,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121771
    },
    {
        "content": "<p>e.g. probably <code>for &amp;x in &amp;vec</code> is ... one thing, but <code>for &amp;x in vec.iter()</code> is another</p>",
        "id": 272300997,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121781
    },
    {
        "content": "<p>which seems potentially relevant here</p>",
        "id": 272301012,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121789
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> It appears in the \"value\" underneath, though.</p>",
        "id": 272301030,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121804
    },
    {
        "content": "<p>it appears in the <em>type</em>, right?</p>",
        "id": 272301058,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121820
    },
    {
        "content": "<p>\"that function returns a &amp; so I'm peeling off the &amp;\"</p>",
        "id": 272301071,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121826
    },
    {
        "content": "<p>I guess I expect the main source of confusion being that \"you sometimes write <code>await x</code> and sometimes <code>x.await</code>\"</p>",
        "id": 272301129,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121860
    },
    {
        "content": "<p>That too, but also, even if the value hasn't been named it's a reference, so it's not hard to think of a reference as logically being a value with a &amp; in it.</p>",
        "id": 272301136,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121864
    },
    {
        "content": "<p>like quite literally it's just not the same keystrokes :)</p>",
        "id": 272301166,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121881
    },
    {
        "content": "<p>That's a big part of what I'm getting at, yeah.</p>",
        "id": 272301167,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121881
    },
    {
        "content": "<p>At least if we spelled it <code>for async x</code>, you can imagine that all async blocks have an async on the outside of them, and you can peel it off to get to the inside.</p>",
        "id": 272301253,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121908
    },
    {
        "content": "<p>side note that .. hmm.. <code>fn foo() -&gt; async T</code> would be cool :) ah well</p>",
        "id": 272301268,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121915
    },
    {
        "content": "<p>I'm not convinced about the \"matching and peeling\" thing, I guess</p>",
        "id": 272301291,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121931
    },
    {
        "content": "<p>Which feels less accurate than it does for references, but nonetheless it makes a weird kind of sense.</p>",
        "id": 272301294,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121933
    },
    {
        "content": "<p>or, to put another way, I think there's <em>another</em> correspondence</p>",
        "id": 272301330,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121952
    },
    {
        "content": "<p>between <code>x.await</code> as an expression and a pattern</p>",
        "id": 272301340,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121959
    },
    {
        "content": "<p>that seems much more important than anything that appears in the <code>async fn</code> declaration</p>",
        "id": 272301368,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121975
    },
    {
        "content": "<p>anyway, to step back, I am interested in actually <em>measuring</em> this</p>",
        "id": 272301381,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121985
    },
    {
        "content": "<p>To be clear, I <em>do</em> favor x.await? as a pattern.</p>",
        "id": 272301387,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645121988
    },
    {
        "content": "<p>this seems like just the kind of thing we can potentially run targeted experiments</p>",
        "id": 272301399,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121993
    },
    {
        "content": "<p>we should to Felienne about it :)</p>",
        "id": 272301406,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645121999
    },
    {
        "content": "<blockquote>\n<p>side note that .. hmm.. <code>fn foo() -&gt; async T</code> would be cool :) ah well</p>\n</blockquote>\n<p><code>trait Foo { async type O; fn foo() -&gt; Self::O; }</code></p>",
        "id": 272301503,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1645122022
    },
    {
        "content": "<p>I'm not opposed to <code>x.await?</code>, but I am very curious how to manage the precedence</p>",
        "id": 272301507,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645122023
    },
    {
        "content": "<p>would be good to enumerate all the expected patterns</p>",
        "id": 272301556,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645122050
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> One possibility: make it non-associative, such that you have to parenthesize, possibly with one or two exceptions.</p>",
        "id": 272301986,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122236
    },
    {
        "content": "<p>Another, which I think I'd favor: require that <code>.await</code> and <code>?</code> are done last in the pattern and can only occur after everything potentially refutable.</p>",
        "id": 272302122,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122286
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272301399\">said</a>:</p>\n<blockquote>\n<p>this seems like just the kind of thing we can potentially run targeted experiments</p>\n</blockquote>\n<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span> for measuring it if we can.</p>",
        "id": 272302207,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272301291\">said</a>:</p>\n<blockquote>\n<p>I'm not convinced about the \"matching and peeling\" thing, I guess</p>\n</blockquote>\n<p>FWIW, \"peeling\" isn't quite the right metaphor to me, either, it's just a description of the later step. The important part of the metaphor, to me, is that:</p>\n<ul>\n<li>A pattern looks like a value, with placeholders</li>\n<li>matching puts the pattern in correspondence with the value, and then sees what goes in the placeholders.</li>\n</ul>",
        "id": 272302398,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122403
    },
    {
        "content": "<p><code>&amp;</code> is a thing that appears in a value, and the above works.</p>",
        "id": 272302464,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122432
    },
    {
        "content": "<p>This is why I <em>did</em> have sympathy for <code>ref</code> and <code>mut</code> being confusing in patterns, because they're an exception to the above.</p>",
        "id": 272302525,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122462
    },
    {
        "content": "<p><code>ref</code> <em>isn't</em> like a value; it's creating a <code>&amp;</code> where none existed before.</p>",
        "id": 272302639,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122507
    },
    {
        "content": "<p>It's logically \"part of the placeholder\".</p>",
        "id": 272302708,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122541
    },
    {
        "content": "<p>And I'd favor <code>.await</code> and <code>?</code> being \"part of the placeholder\" as well: you finish the match, then apply any placeholder modifiers.</p>",
        "id": 272302765,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645122566
    },
    {
        "content": "<p>If we use <code>.await</code> in patterns I'd like to support <code>.ref</code> and <code>.mut</code> and maybe deprecate the prefix syntax</p>",
        "id": 272304788,
        "sender_full_name": "tmandry",
        "timestamp": 1645123461
    },
    {
        "content": "<p>user studies sound good, though I'm curious how you would measuring both \"initial reaction\" and approximating \"how it is to use day to day\"</p>",
        "id": 272305703,
        "sender_full_name": "tmandry",
        "timestamp": 1645123891
    },
    {
        "content": "<p>This all sounds like a lot of confusion, complex rules, and churn just to avoid a simpler special case in loops?</p>",
        "id": 272305732,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645123908
    },
    {
        "content": "<p>Can you be more concrete about the simpler special case?</p>",
        "id": 272306096,
        "sender_full_name": "tmandry",
        "timestamp": 1645124059
    },
    {
        "content": "<p>sorry if we discussed it above, this thread is pretty long</p>",
        "id": 272306165,
        "sender_full_name": "tmandry",
        "timestamp": 1645124098
    },
    {
        "content": "<p>I think there have been a few different proposals, but something like for await x in foo</p>",
        "id": 272307057,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645124516
    },
    {
        "content": "<p>In certain ways that doesn't seem simpler.</p>",
        "id": 272307162,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645124550
    },
    {
        "content": "<p>Insofar as what it means in combination with other things.</p>",
        "id": 272307229,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645124583
    },
    {
        "content": "<p>Not least of which <code>?</code>.</p>",
        "id": 272307248,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645124591
    },
    {
        "content": "<p>Hi, I was wondering how a composable \"await pattern\" is related to consuming an <code>AsyncIterator&lt;Item=T&gt;</code>. To me, having a special pattern that awaits would rather imply consuming an <code>Iterator&lt;Item=Future&lt;Output=T&gt;&gt;</code> or an arbitrarily nested variation thereof. My intuition, as an outsider, is that <code>AsyncIterator</code> is different from <code>Iterator</code> and as such requires a different kind of <code>for</code>-loop (e.g. a <code>for await</code>-loop).</p>",
        "id": 272307259,
        "sender_full_name": "Dominik Stolz",
        "timestamp": 1645124596
    },
    {
        "content": "<p>We went to a great deal of effort to create a .await syntax that nicely fit and was orthogonal to other things in the language, and I'd hate to lose that.</p>",
        "id": 272307329,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645124630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"302700\">Dominik Stolz</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272307259\">said</a>:</p>\n<blockquote>\n<p>Hi, I was wondering how a composable \"await pattern\" is related to consuming an <code>AsyncIterator&lt;Item=T&gt;</code>. To me, having a special pattern that awaits would rather imply consuming an <code>Iterator&lt;Item=Future&lt;Output=T&gt;&gt;</code> or an arbitrarily nested variation thereof. My intuition, as an outsider, is that <code>AsyncIterator</code> is different from <code>Iterator</code> and as such requires a different kind of <code>for</code>-loop (e.g. a <code>for await</code>-loop).</p>\n</blockquote>\n<p>This is a good point. We need the loop itself to change; it doesn't really fit the \"placeholder modifier\" pattern, because after awaiting we may discover there is no value for the placeholder to bind to. In other words, you get a <code>Future&lt;Output = Option&lt;Item&gt;&gt;</code>, not an <code>Option&lt;Future&lt;Output = Item&gt;&gt;</code></p>",
        "id": 272308107,
        "sender_full_name": "tmandry",
        "timestamp": 1645124983
    },
    {
        "content": "<p>That’s fair but I’d also hate to complicate patterns, which are a really fundamental part of the language, for the sake of orthogonality</p>",
        "id": 272308483,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645125156
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272308483\">said</a>:</p>\n<blockquote>\n<p>That’s fair but I’d also hate to complicate patterns, which are a really fundamental part of the language, for the sake of orthogonality</p>\n</blockquote>\n<p>We complicated <code>.</code> syntax, which is rather fundamental, for the sake of orthogonality. :)</p>",
        "id": 272308526,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645125187
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272308107\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"302700\">Dominik Stolz</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272307259\">said</a>:</p>\n<blockquote>\n<p>Hi, I was wondering how a composable \"await pattern\" is related to consuming an <code>AsyncIterator&lt;Item=T&gt;</code>. To me, having a special pattern that awaits would rather imply consuming an <code>Iterator&lt;Item=Future&lt;Output=T&gt;&gt;</code> or an arbitrarily nested variation thereof. My intuition, as an outsider, is that <code>AsyncIterator</code> is different from <code>Iterator</code> and as such requires a different kind of <code>for</code>-loop (e.g. a <code>for await</code>-loop).</p>\n</blockquote>\n<p>This is a good point. We need the loop itself to change; it doesn't really fit the \"placeholder modifier\" pattern, because after awaiting we may discover there is no value for the placeholder to bind to. In other words, you get a <code>Future&lt;Output = Option&lt;Item&gt;&gt;</code>, not an <code>Option&lt;Future&lt;Output = Item&gt;&gt;</code></p>\n</blockquote>\n<p>Interesting point. The \"placeholder modifier\" syntax seems useful for the case of iterating over <code>Result</code> values and applying <code>?</code> (which comes up reasonably often), and for the case of iterating over <code>Future</code> values (which comes up much less often), but I agree that it doesn't quite work for the iterator itself being asynchronous.</p>",
        "id": 272308691,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645125251
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272308483\">said</a>:</p>\n<blockquote>\n<p>That’s fair but I’d also hate to complicate patterns, which are a really fundamental part of the language, for the sake of orthogonality</p>\n</blockquote>\n<p>I'm pretty sympathetic to this. My counterpoint is that the idea of placeholder modifiers we were discussing already exists, and by \"putting more eggs in that basket\" users would see them more and be less confused by <code>ref</code> and <code>ref mut</code></p>",
        "id": 272309006,
        "sender_full_name": "tmandry",
        "timestamp": 1645125414
    },
    {
        "content": "<p>but I'm also open to the possibility that actually we should avoid doing that because it will just add more cases to a fundamentally confusing concept</p>",
        "id": 272309187,
        "sender_full_name": "tmandry",
        "timestamp": 1645125489
    },
    {
        "content": "<p>I think the beauty of .await is that it doesn’t really complicate the . Syntax. Admittedly it’s not quite like a field access but it doesn’t have different rules for when it can be used or special ordering or anything, if you think of await as a method you’re not too far wrong</p>",
        "id": 272310000,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645125877
    },
    {
        "content": "<p>I think users don’t see ref much any more so that confusion is much diminished. That’s another reason I’d be sad to make patterns more complicated again</p>",
        "id": 272310103,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645125937
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272308107\">said</a>:</p>\n<blockquote>\n<p>This is a good point. We need the loop itself to change; it doesn't really fit the \"placeholder modifier\" pattern, because after awaiting we may discover there is no value for the placeholder to bind to. In other words, you get a <code>Future&lt;Output = Option&lt;Item&gt;&gt;</code>, not an <code>Option&lt;Future&lt;Output = Item&gt;&gt;</code></p>\n</blockquote>\n<p>this...is true. I hadn't realized that indeed <code>for await</code> is not <em>quite</em> as orthogonal as I would like, though I think that saying \"for await pattern\" desugars to <code>while let await Some(pattern) = ...</code> is not the worst thing ever</p>",
        "id": 272329310,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645134644
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20vision.20and.20async.20for.20loop.20syntax/near/272308483\">said</a>:</p>\n<blockquote>\n<p>That’s fair but I’d also hate to complicate patterns, which are a really fundamental part of the language, for the sake of orthogonality</p>\n</blockquote>\n<p>I guess one person's \"complicate\" is another's enrich? I see value in being able to do (e.g.)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">maybe_future</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"n\">result</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">maybe_future</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"s\">\"default\"</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>More to the point, I do feel that having \"special case\" syntax that doesn't fit nicely together winds up feeling <em>more</em> complex in the end. I'm not sure where this falls, but I don't think the \"complicated vs not\" is as simple as you're making it out to be. </p>\n<p>There's some good writing on this topic in <a href=\"https://www.manning.com/books/the-programmers-brain\">The Programmer's Brain</a>; it kind of comes down to \"if you are able to build an abstraction for something, it becomes 1 thing in your memory, even when it's complex\".</p>\n<p>It's not open-and-shut in either direction, but I am quite wary of trying to add \"special forms\" that can't be understood as \"instances of a more general pattern\".</p>",
        "id": 272329703,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645134867
    },
    {
        "content": "<blockquote>\n<p>I guess one person's \"complicate\" is another's enrich?</p>\n</blockquote>\n<p>true, true, and I don't want to over-simplify things. I'm not making an argument that we should never enhance features for the sake of simplicity</p>",
        "id": 272380314,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645177582
    },
    {
        "content": "<blockquote>\n<p>I see value in being able to do (e.g.)</p>\n</blockquote>\n<p>I feel like the examples so far (other than looping on streams) are a bit shallow, in this case one could do <code>let Some(result) = maybe_future().map(|f| f.await) else { ... }</code> and it is not that much less convenient. Even spelling the whole thing out with a match is not much worse. Perhaps you're thinking that real world examples will add enough complexity that the simple workarounds add up to inconvenience?</p>",
        "id": 272380855,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645177961
    },
    {
        "content": "<blockquote>\n<p>It's not open-and-shut in either direction, but I am quite wary of trying to add \"special forms\" that can't be understood as \"instances of a more general pattern\".</p>\n</blockquote>\n<p>My concern is that we make patterns less general and harder to form a single abstraction of. I wouldn't mind if we were adding something to patterns which fit with the existing abstraction (e.g., deref patterns - which I love). But here it seems like we're adding expression execution to patterns which didn't exist before and is a new concept to reason about, plus some patterns will not be allowed to be repeated, which is another fundamental change to the model of pattern. AND for the await keyword, there are now two syntaxes used in different places but which do fundamentally the same thing (worse, the one which will be more familiar to users from other languages is the one which is used less frequently).</p>",
        "id": 272381362,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645178287
    },
    {
        "content": "<p>So, I don't like to add special forms as much as the next language designer :-), but in this case it seems like the less special thing in terms of complicating the user's mental models</p>",
        "id": 272381444,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645178357
    },
    {
        "content": "<p>So <code>for await</code> is kind of ugly, but also I think intuitively it is very clear: it is just a for loop which awaits on each iteration, so I don't think that complicates the mental model for <code>for</code> very much</p>",
        "id": 272381609,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645178428
    },
    {
        "content": "<p>Maybe <code>for.await</code> is better to make clear that the <code>await</code> modifies the <code>for</code> rather than the pattern?</p>",
        "id": 272381656,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1645178461
    }
]