[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/Should.20we.20seriously.20consider.20radical.20change.3F/near/271006704\">said</a>:</p>\n<blockquote>\n<p>I believe non-cancellable futures potentially merits breakage, but it comes down to how much we care about parallelism</p>\n</blockquote>\n<p>I wanted to break this out into a separate discussion to not distract from the broader question around considering radical change, but how does cancellation interact with parallelism?</p>",
        "id": 271020454,
        "sender_full_name": "eholk",
        "timestamp": 1644257991
    },
    {
        "content": "<p>Hi, this is just my personal best-guess here, but I suppose this might be about the problem of an async version of <a href=\"https://docs.rs/crossbeam/latest/crossbeam/fn.scope.html\"><code>crossbeam::scope</code></a>. The reason why that abstraction can soundly work in providing a way to use non-static references across threads, i.e. spawned threads can reference data in the surrounding stack frame outside of that scope, is because the <code>scope</code> function does, before it finishes, wait for all the not-yet-joined threads that got spawned through it.</p>\n<p>There’s <a href=\"https://docs.rs/rayon/latest/rayon/fn.scope.html\">similar API in rayon</a> btw, which uses a worker-thread-pool, but otherwise follows the same principle.</p>\n<p>The problem with an <code>async</code> version (which would be supposed to call something like <a href=\"https://docs.rs/tokio/latest/tokio/fn.spawn.html\"><code>tokio::spawn</code></a> internally, but support non-<code>'static</code> data) is that the <code>Future</code> that executes the <code>scope</code> call could be cancelled while the spawned tasks (unsoundly) keep running.</p>\n<hr>\n<p>I just did a Google search, and found this page with more information: <a href=\"https://rust-lang.github.io/wg-async/vision/roadmap/scopes.html\">https://rust-lang.github.io/wg-async/vision/roadmap/scopes.html</a></p>",
        "id": 271028931,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1644261687
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"280891\">@Frank Steffahn</span>, that makes sense!</p>",
        "id": 271032666,
        "sender_full_name": "eholk",
        "timestamp": 1644263472
    },
    {
        "content": "<p>re-reading the section on Cancellation (and specifically <em>Voluntary</em> Cancellation), I immediately wonder \"Isn't this the same lesson the pthreads API learned when it deprecated <code>pthread_kill</code> ...?\" Was that just an oversight, or was this an instance of \"Oh, we know about that, but we <em>can</em> express cancellation in our current set up, so we will!\"</p>",
        "id": 271033523,
        "sender_full_name": "pnkfelix",
        "timestamp": 1644263872
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116083\">@pnkfelix</span> - what are some of the lessons from pthreads? I haven't followed that closely</p>",
        "id": 271034084,
        "sender_full_name": "eholk",
        "timestamp": 1644264094
    },
    {
        "content": "<p>I think it was more that cancellation by drop just sort of naturally falls out of the model we adopted and doing anything else is difficult. I’m not sure if folk thought it didn’t matter too much or that the rest of the model outweighed the cancellation issue</p>",
        "id": 271039544,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644266850
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async/topic/Non-cancellable.20futures.20and.20parallelism/near/271034084\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> - what are some of the lessons from pthreads? I haven't followed that closely</p>\n</blockquote>\n<p>I've been working on trying to find some discussion explaining this. I had thought the heart of it was basically the same as what happens in the Scoped API example: That non-voluntary kills can end up destroying resources that are still in use by other threads.</p>",
        "id": 271039925,
        "sender_full_name": "pnkfelix",
        "timestamp": 1644267070
    },
    {
        "content": "<p>so maybe no one used the lessons from pthreads because they aren't sufficiently documented/advertised. :)</p>",
        "id": 271039959,
        "sender_full_name": "pnkfelix",
        "timestamp": 1644267096
    },
    {
        "content": "<p>Ah, okay. Do you know if there's something that makes that more problematic than a vanilla use-after-free bug?</p>",
        "id": 271040268,
        "sender_full_name": "eholk",
        "timestamp": 1644267243
    },
    {
        "content": "<p>Like, we didn't deprecate <code>free()</code> because of UAF, but maybe <code>pthread_kill()</code> is even harder to get right for less benefit (not leaking memory because of <code>free</code> is a pretty big benefit)?</p>",
        "id": 271040352,
        "sender_full_name": "eholk",
        "timestamp": 1644267294
    },
    {
        "content": "<p>I assume it’s the same lessons as from Java and probably other places too?</p>",
        "id": 271040546,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644267381
    },
    {
        "content": "<p>With Java presumably the GC would save you though</p>",
        "id": 271040768,
        "sender_full_name": "eholk",
        "timestamp": 1644267496
    },
    {
        "content": "<p>Unless cancelling a thread gives the thread the chance to run cleanup code?</p>",
        "id": 271040809,
        "sender_full_name": "eholk",
        "timestamp": 1644267520
    },
    {
        "content": "<p>I don’t know the history of pthread_kill <em>specifically</em> but many of the problems with the current model stem from programmers assuming that a function will run to completion when in fact it can be cancelled at an await point, leaving some objects in an inconsistent or intermediate state forever</p>",
        "id": 271042818,
        "sender_full_name": "tmandry",
        "timestamp": 1644268534
    },
    {
        "content": "<p>pthread_kill is worse because the possible stopping points aren’t marked by any language syntax, but it can be argued that both are bad</p>",
        "id": 271042948,
        "sender_full_name": "tmandry",
        "timestamp": 1644268602
    },
    {
        "content": "<p>think e.g. manually allocating a resource, awaiting something, then manually freeing. if your task gets cancelled in the middle the resource is never freed. so in this example the problem is that resources can leak</p>",
        "id": 271043184,
        "sender_full_name": "tmandry",
        "timestamp": 1644268732
    },
    {
        "content": "<p>for Rust it means that in places where you could have written straight line code in sync land, you now need to use drop guards for correctness</p>",
        "id": 271043231,
        "sender_full_name": "tmandry",
        "timestamp": 1644268759
    },
    {
        "content": "<p>which breaks part of the promise of async/await which is to allow you to write straight line code as you would in sync land</p>",
        "id": 271043353,
        "sender_full_name": "tmandry",
        "timestamp": 1644268816
    },
    {
        "content": "<p>(as pointed out above, you also have no guarantee that these drop guards will run, making it impossible to express the safety invariants you need for scoped async tasks)</p>",
        "id": 271043506,
        "sender_full_name": "tmandry",
        "timestamp": 1644268920
    },
    {
        "content": "<p>Another common example of cancellation issues: \"read buffer of data, do some processing, write out buffer of data\". If you allow cancellation between the read and the write, data gets lost. You have to carefully avoid any cancellation point between those, and the language doesn't help you.</p>",
        "id": 271048217,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644271030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async/topic/Non-cancellable.20futures.20and.20parallelism/near/271043231\">said</a>:</p>\n<blockquote>\n<p>for Rust it means that in places where you could have written straight line code in sync land, you now need to use drop guards for correctness</p>\n</blockquote>\n<p>I think this is something worth calling out under the \"sync and async behave the same\" polish goal. It'd be nice to make some kind of guarantee about behavior in the face of cancellation.</p>",
        "id": 271055622,
        "sender_full_name": "eholk",
        "timestamp": 1644274602
    },
    {
        "content": "<p>Its worth noting that straight line code in sync code being possible is actually <em>relatively</em> rare too - panics are pretty commonly annoying to be careful around.  (And are often <em>worse</em> since there's no visible indication at all that they can happen).</p>",
        "id": 271062830,
        "sender_full_name": "simulacrum",
        "timestamp": 1644279226
    },
    {
        "content": "<p>I don't believe the challenges with async cancellation are unique to async: I believe they apply to <code>try</code> operations too — and likely <code>panic!</code> as well.</p>\n<p>I wrote about this in the \"halt-safety\" section in my \"ascync cancellation I\" blog post: <a href=\"https://blog.yoshuawuyts.com/async-cancellation-1/#halt-safety\">https://blog.yoshuawuyts.com/async-cancellation-1/#halt-safety</a></p>\n<p>Imo there are different things we need to do here, but at least one of them is to start teaching people that: \"code may halt at any <code>.await</code> point\".</p>",
        "id": 271306532,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644424706
    },
    {
        "content": "<p>Something that came out of meeting with Niko and Tyler we had on Monday is that we may want to consider looking at <code>defer</code> blocks more seriously as a way to make local state cleanup on halt easier to express.</p>",
        "id": 271307156,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644424900
    },
    {
        "content": "<p>Let’s stop comparing this to panic. It’s fundamentally different as Nikos blog post pointed out. For panics you see what method you are calling. You know that if you only call code that is 100% panic safe, you don’t have to care about it. For cancellation that isn’t true. The behavior is caused by code around the function which isn’t visible and neither is static.</p>",
        "id": 272070349,
        "sender_full_name": "Matthias247",
        "timestamp": 1644982945
    },
    {
        "content": "<p>I don't think it's so fundamentally different. Take these four examples:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// Case 1: Panic, no protection necessary</span>\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">setup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">function</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">cleanup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// Case 2: Panic, protection necessary</span>\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">(</span><span class=\"n\">function</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">FnOnce</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">setup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">defer</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">cleanup</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">function</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// Case 3: Cancellation, no protection necessary</span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">task</span>::<span class=\"n\">spawn</span><span class=\"p\">(</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">setup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">function</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">cleanup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// Case 4: Cancellation, protection necessary</span>\n<span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">setup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">defer</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">cleanup</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">function</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Panics are kind of the inverse of cancellation, happening on the interior rather than the exterior. In both cases, no protection is necessary in the concrete context (interior <code>function()</code> call or exterior <code>task::spawn</code>/<code>block_on</code> call) but protection is necessary in the generic context (interior callback call or exterior returned future). That said, the relative frequency of a concrete exterior context is far fewer than a concrete interior context, so I agree that they aren't identical situations.</p>",
        "id": 272085355,
        "sender_full_name": "Kestrer",
        "timestamp": 1644999813
    },
    {
        "content": "<p>Incidentally, let's not forget about \"state-lending\" <code>defer</code> blocks, since that can come up a lot as well. At that point we'd be reinventing <a href=\"https://docs.rs/scopeguard\">https://docs.rs/scopeguard</a> or <a href=\"https://docs.rs/unwind-safe\">https://docs.rs/unwind-safe</a> (the latter reads better, imho, but cannot be used with <code>async</code>). Do we need language features for that? Maybe we could just have (part of) <code>scopeguard</code>'s API be embedded into the stdlib?</p>",
        "id": 272102127,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1645009944
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"204219\">Matthias247</span> <a href=\"#narrow/stream/187312-wg-async/topic/Non-cancellable.20futures.20and.20parallelism/near/272070349\">said</a>:</p>\n<blockquote>\n<p>Let’s stop comparing this to panic. It’s fundamentally different as Nikos blog post pointed out. For panics you see what method you are calling. You know that if you only call code that is 100% panic safe, you don’t have to care about it. For cancellation that isn’t true. The behavior is caused by code around the function which isn’t visible and neither is static.</p>\n</blockquote>\n<p>There are fundamental differences, but also fundamental similarities. In practice I think you have to frequently assume that \"any function I call might panic\" because you can't really narrow down exactly what code will transitively run (or may run in the future). This is particularly true around generics, especially since whenever you drop a value you have to account for a possible destructor call.</p>\n<p>(In Rayon, I was pretty careful to reason about this, but I at some point realized that I was also dropping a lot of generic code and thus invoking destructors that could panic. My solution was to catch as many panics as I could but introduce a \"abort the process if something leaks through\" bomb.)</p>\n<p>I am skeptical though of any solution that requires \"you just have to be aware that any await may panic\". I think that is going to be very hard to make reliable in practice.</p>",
        "id": 272290433,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645117750
    },
    {
        "content": "<p>Also, this seems like another good argument against letting destructors panic.</p>",
        "id": 272294801,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1645119279
    },
    {
        "content": "<p>it's the main thing that pushed me over the edge, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span></p>",
        "id": 272297423,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1645120357
    },
    {
        "content": "<blockquote>\n<p>In practice I think you have to frequently assume that \"any function I call might panic\" because you can't really narrow down exactly what code will transitively run (or may run in the future).</p>\n</blockquote>\n<p>I don't think we have to assume this. People don't even assume in C++, where exceptions are far more widely used than in Rust. E.g. the Google standard (at least some time ago) said exceptions should not be used, and people took those guarantees for granted. I've also seen the same at lots of other places. Or at least they wrapped exception emitting code, and transformed it so that other places don't have to deal with those. This all works, because the code that is called and depended on is known. But the code which calls ones library is not necessarily known, and can even evolve over time.   Interacting with C libraries is another example where we have to rely on nothing throwing any exceptions, because its not safe to propagate them there.</p>\n<p>Obviously this is different if the code that is called is unknown (provided by someone else), as you mentioned with the Rayon example (and that <span class=\"user-mention\" data-user-id=\"360486\">@Kestrer</span> showed above with <code>impl FnOnce</code>). In this case I agree that that this either needs to be handled, or users should probably set. But unknown/generic code is a special case, it's not the common one. For <code>async fn</code>  even without calling unknown code the extra care is required. Or one probably needs to write into docs \"this library is not cancellation safe\" - but given the wide usage of <code>select!</code> in the ecosystem this doesn't seem right.</p>",
        "id": 272563382,
        "sender_full_name": "Matthias247",
        "timestamp": 1645329329
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> \"transitive code\" doesn't just mean generics, it also means library code, crates from <a href=\"http://crates.io\">crates.io</a>, dependencies of those crates, and code you or others have written or will write in the future. It isn't just documented APIs; it's also bugs. For example numbers wrapping around, out-of-bounds indexes, and <code>unwrap</code>s can all lead to unintentional panics. To meaningfully say that code will not panic we need to prove that all code we rely on, in fact, will not. And that's usually an impractically high bar to clear.</p>\n<p>The best way to prove that code won't panic would be to rely on the compiler (e.g. <a href=\"https://docs.rs/no-panic/latest/no_panic/index.html\"><code>no_panic</code></a> enables a check like that today). But unless the compiler can prove our code won't panic, it's wise to assume it might. Especially when talking about it from the perspective of language design.</p>",
        "id": 272673130,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1645441318
    }
]