[
    {
        "content": "<p>our app is multithreaded, but we use a single-threaded executor in each thread, and so our wakers are Rc-based. is anyone else doing Rc wakers? I wonder if it could be worth having something in std</p>",
        "id": 273679039,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646156025
    },
    {
        "content": "<p>I thought the existing Send / Sync impls on Context and Waker, don't leave enough wiggle room to make it a valid implementation <a href=\"https://github.com/rust-lang/rust/issues/66481\">#66481</a>.</p>",
        "id": 273679916,
        "sender_full_name": "tm",
        "timestamp": 1646156329
    },
    {
        "content": "<p>You can implement Send/Sync and check thread IDs</p>",
        "id": 273681561,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1646156923
    },
    {
        "content": "<p>yeah I'm curious about that. currently we don't check thread IDs and our waker contract is \"promise not to pass to another thread\". but if it is possible to efficiently check for invalid use and panic, then that seems like a good enough solution. the discussion in the above issue and <a href=\"https://boats.gitlab.io/blog/post/wakers-ii/\">https://boats.gitlab.io/blog/post/wakers-ii/</a> about ergonomics in the common case make sense to me. it is/was a tricky design problem</p>",
        "id": 273684229,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646157872
    },
    {
        "content": "<p>Oh yeah, that's a really good question. This is relevant for e.g. Glommio too. iirc there was an issue about this, proposing we remove the <code>Send</code> / <code>Sync</code> bounds from <code>task::Context</code>, so we can add a <code>local_waker</code> method which can be based on <code>Rc</code>.</p>",
        "id": 273820119,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646233564
    },
    {
        "content": "<p>That's a backwards-incompatible change -- but I believe the theory is that that might actually have minimal breakage since <code>Context</code> is rarely held over <code>Send</code> bounds; <code>Waker</code> is</p>",
        "id": 273820294,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646233629
    },
    {
        "content": "<p>Oh yeah, the thread is indeed <a href=\"https://github.com/rust-lang/rust/issues/66481\">https://github.com/rust-lang/rust/issues/66481</a>, tracked in the WG as <a href=\"https://github.com/rust-lang/wg-async/issues/87\">https://github.com/rust-lang/wg-async/issues/87</a></p>",
        "id": 273820525,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646233699
    },
    {
        "content": "<p>cc/ <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> maybe we should pick this up?</p>",
        "id": 273820850,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646233823
    },
    {
        "content": "<p>Glommio does currently check thread IDs</p>",
        "id": 273820967,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1646233877
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> Not sure I understand what that's in reply to?</p>",
        "id": 273821149,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646233954
    },
    {
        "content": "<p>You mentioning glommio and <span class=\"user-mention\" data-user-id=\"462944\">@Justin Karneges</span> asking about checking for invalid use</p>",
        "id": 273821381,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1646234057
    },
    {
        "content": "<p>Oh I see</p>",
        "id": 273821461,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646234101
    },
    {
        "content": "<p>For context: I talked to Glommio's lead and asked them to weigh in on this last year, here: <a href=\"https://github.com/rust-lang/wg-async/issues/87#issuecomment-821567041\">https://github.com/rust-lang/wg-async/issues/87#issuecomment-821567041</a> -- they seemed keen if we could move the <code>!Send</code> / <code>!Sync</code> contract out into the type system.</p>",
        "id": 273822006,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646234331
    },
    {
        "content": "<p>I think the rough steps to take here are as follows:</p>\n<ol>\n<li>Prototype a <code>Context::local_waker</code> impl with the right <code>!Send</code> / <code>!Sync</code> bounds to prove things work, possibly outside of std.</li>\n<li>Get a branch / PR of this in to the compiler, so we can do a crater run and see how much breaks.</li>\n<li>Decide on next steps based on that run. If nothing breaks we're lucky and can probably move ahead. If it does, we'll have to figure something else out.</li>\n</ol>\n<p>Something like that?</p>",
        "id": 273822685,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646234579
    },
    {
        "content": "<p>I'm not sure if this is RFC material. If there's breakage it might very well need to be, since we need to justify it. But if the crater run turns up nothing, then possibly not?</p>",
        "id": 273822893,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646234648
    },
    {
        "content": "<p>I don't think a large change like this can be made purely by a crater run</p>",
        "id": 273824357,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1646235190
    },
    {
        "content": "<p>I think it has to be an RFC - there are so many large async projects (with complex executor stuff) not published on <a href=\"http://crates.io\">crates.io</a></p>",
        "id": 273825716,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646235654
    },
    {
        "content": "<p>This gets back to the private crater run idea</p>",
        "id": 273825812,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1646235693
    },
    {
        "content": "<p>But I still think it would need an RFC</p>",
        "id": 273825849,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1646235711
    },
    {
        "content": "<p>I<br>\n<span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/Rc.20waker/near/273820850\">said</a>:</p>\n<blockquote>\n<p>cc/ <span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> maybe we should pick this up?</p>\n</blockquote>\n<p>we probably should, but I'm not sure where it fits exactly. I def don't have the bandwidth at the moment though</p>",
        "id": 273825902,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1646235722
    },
    {
        "content": "<p>as others have said, including boats, removing Sync from Context seems like it should be harmless. the Waker change, less so. there is a possible midway point: making <code>Context::local_waker()</code> return a normal Waker that will panic if used improperly</p>",
        "id": 273834979,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646238840
    },
    {
        "content": "<p>hmm, it occurs to me that if a <code>local_waker()</code> accessor is introduced, that an executor would still be obligated to provide a regular <code>waker()</code> accessor. so this change would be a way for a Future to opt-in to using a thread local waker, rather than a way for an executor to express to a Future that its wakers are not thread-safe. meaning, even our single-threaded executor which currently only provides Rc-based wakers would need to also implement a <code>waker()</code> that returns a thread-safe waker for completeness. this is a little surprising, but probably reasonable</p>",
        "id": 273836953,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646239547
    },
    {
        "content": "<p>to allow executors to express they don't support Send/Sync wakers, we'd need <code>LocalFuture</code>, <code>LocalContext</code>, <code>LocalWaker</code>. Such an executor would only allow spawning <code>LocalFuture</code>s, not <code>Future</code>s</p>",
        "id": 273838725,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646240158
    },
    {
        "content": "<p>true. and that does feel a bit excessive to me. even as someone that uses only thread-local wakers, I think I'd sooner prefer to implement thread-safe wakers that go unused, or make <code>Context::waker()</code> panic, rather than push to introduce <code>LocalFuture</code> into the ecosystem</p>",
        "id": 273846762,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646242865
    },
    {
        "content": "<p>I suppose there could be other benefits of thread-local futures beyond optimizing waker, but I think this could be expressed with <code>Future + !Send + !Sync</code></p>",
        "id": 273847661,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646243175
    },
    {
        "content": "<p>a <code>Future + !Send + !Sync</code> might still try to Send its Waker</p>",
        "id": 273847849,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646243249
    },
    {
        "content": "<p>right, but having <code>Context::local_waker()</code> might be a sufficient solution to that</p>",
        "id": 273848125,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646243353
    },
    {
        "content": "<p><code>LocalFuture</code> wouldn't be able to because it'd only have access to a <code>LocalWaker</code> which is <code>!Send</code></p>",
        "id": 273848215,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646243382
    },
    {
        "content": "<p>understood, <code>LocalFuture</code> would be forced to use <code>LocalWaker</code>. but if futures are given a choice, by offering both <code>Context::waker()</code> and <code>Context::local_waker()</code> (the latter providing a <code>LocalWaker</code> which is <code>!Send</code>), then a <code>Future + !Send + !Sync</code> could access either waker without causing problems</p>",
        "id": 273850835,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1646244268
    }
]