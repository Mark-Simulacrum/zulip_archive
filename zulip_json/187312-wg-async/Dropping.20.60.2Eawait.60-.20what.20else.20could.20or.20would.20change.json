[
    {
        "content": "<p>I have to admit: When I first read <span class=\"user-mention\" data-user-id=\"224941\">@Carl Lerche</span> 's idea about dropping <code>.await</code> I was mostly thinking \"I don't care a lot - its fine either way\". But today I was thinking a bit more about it, and wondered whether it's actually just the syntax that would change or whether there could be more behind it:</p>\n<ul>\n<li>If <code>.await</code> happens implicitely, there is no chance for users anymore to move <code>Futures</code> (or <code>Async</code>s?) around anymore before they are invoked. That ability in the current system made lifetimes incredibly complicated, since <code>Future</code>s  capture the lifetime of all their inputs, but might consume them at a different time (then the <code>Future</code> is polled). Assuming users can't move them anymore because the <code>.await</code>happens implicitely - could that mean lifetimes could be simplified and the exactly match the beavhior of synchronous functions?</li>\n<li>One concern with todays <code>async</code> system that is less often talked about is large <code>Future</code> sizes. <code>Future</code>s which have been blowing the stack are now unheard of, and probalby even if the sizes are far smaller it might still hurt performance more than what we actually gain from <code>async</code> functions compared to normal stacks. My understanding is that parts of this size growth - which sometimes is exponential - is due to lazy composition of <code>Future</code>s - one first has to build a composite <code>Future</code> and return it before polling can start (but I think <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> understands this topic far better). Assuming <code>Future</code>s are by default not movable since they are implicitely awaited - could this lead to smaller <code>Future</code> sizes due to being able to optimize compiler passes and maybe construct more things in-place?</li>\n<li>For most basic functionality immediately awaiting a future is ok and dropping <code>.await</code> there too. But how would passing something async to a <code>spawn</code> function (either a scoped or global spawn) work? Carls example uses an async block there. Would those be restricted to that, or maybe even take async closures to get close to what a synchronous spawn look like (<code>scope.spawn(async || {} )</code>)? If yes, what is the type of what those functions are accepting? I don't think it should be <code>Async&lt;T&gt;</code>, since this like an already produced async operation. Maybe more along of an <code>impl AsyncFn</code> which when called produces an <code>Async&lt;T&gt;</code> - and there might be constraints on how you can use that one (e.g. you might not be allowed to defer polling too much to avoid the lifetime issues pointed out in point 1).</li>\n</ul>",
        "id": 244780483,
        "sender_full_name": "Matthias247",
        "timestamp": 1625287825
    },
    {
        "content": "<p>I dug some into this in the doc</p>",
        "id": 244855530,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625398821
    },
    {
        "content": "<p>There isn't, I don't think, a change in expressiveness or anything else, but some things get simpler if you make <code>.await</code> the default</p>",
        "id": 244855546,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625398873
    },
    {
        "content": "<p>Optimization potential is the most interesting to me</p>",
        "id": 244855553,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625398883
    },
    {
        "content": "<p>But also the fact that the mental model between \"sync\" and \"async\" is identical-- e.g., in both cases, you make a \"closure-like thing\" to defer executing code immediately</p>",
        "id": 244855558,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625398904
    },
    {
        "content": "<p>However, there are also some complications, depending on how we want to \"expose\" the idea that an async function doesn't immediately execute</p>",
        "id": 244855602,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625398929
    },
    {
        "content": "<p>Ultimately it seems like a \"detail\" but not the most significant thing to me, though it has a huge impact on the daily writing of code and other things. I was surprised when writing some async code how much mental load I expended deciding whether I needed an await on some particular function or not. It's a constant question in the back of your mind, I find, and that's kind of a yellow flag for me.</p>",
        "id": 244855619,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625398992
    },
    {
        "content": "<p>Just wondering, is this something that could actually change? It would be a pretty huge breaking change, no?</p>",
        "id": 244861714,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1625408624
    },
    {
        "content": "<p>We could certainly change it over an edition</p>",
        "id": 245358518,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771785
    },
    {
        "content": "<p>It would be a big migration though :)</p>",
        "id": 245358523,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625771789
    },
    {
        "content": "<p>I've added some comments on the doc re this. tldr: I think it's a really really bad idea.</p>",
        "id": 245381093,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625784242
    },
    {
        "content": "<p>(not sure what the right place to discuss is? can copypaste the comments here if wanted)</p>",
        "id": 245381180,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625784306
    },
    {
        "content": "<p>Thanks! Will read. I'm currently in the process of moving things from the doc into a fork of wg-async-foundations, and I'm trying to include some of those comments either by adjusting the content or adding FAQs and things to discuss further</p>",
        "id": 245437272,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625834489
    },
    {
        "content": "<p>I hope to get a PR up today, so we can move some of the discussion to that format, which is easier</p>",
        "id": 245437298,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625834515
    },
    {
        "content": "<p>But I'd also be game to schedule a slot to go deeper, <span class=\"user-mention\" data-user-id=\"348152\">@Dario Nieuwenhuis</span>, especally about no-std considerations (I saw a number of comments from you in that direction)</p>",
        "id": 245437374,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625834546
    },
    {
        "content": "<p>Would it make sense to have a preliminary design meeting discussion to go over some of the pros and cons of dropping <code>.await</code>? This seems like it informs enough things that it'd be worth starting that conversation early.</p>",
        "id": 245464593,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625847906
    },
    {
        "content": "<p>I actually think it's a relatively minor detail</p>",
        "id": 245466392,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625848768
    },
    {
        "content": "<p>But I do think that we need a number of design meetings</p>",
        "id": 245466400,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625848773
    },
    {
        "content": "<p>The piece of this whole picture that <em>I personally</em> am most nervous about is <a href=\"https://nikomatsakis.github.io/wg-async-foundations/vision/harmonic/compose_control_scheduling/async_trait.html\">introducing a second async trait</a></p>",
        "id": 245466509,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625848811
    },
    {
        "content": "<p>I admit that when I first saw <span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span>'s PR I was pretty negative, but as I've dug more into this, I've become more and more convinced that it makes sense.</p>",
        "id": 245466545,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625848835
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245466392\">said</a>:</p>\n<blockquote>\n<p>I actually think it's a relatively minor detail</p>\n</blockquote>\n<p>Obviously a highly visible one :)</p>",
        "id": 245466591,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625848858
    },
    {
        "content": "<p>Oh lol I didn't even include it in my PR yet, I should do that</p>",
        "id": 245466799,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625848975
    },
    {
        "content": "<p>I feel it's kind of similar to the relationship between <code>FnMut</code> and <code>FnOnce</code>, imagine if the std definition is something like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FutureOnce</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">poll_once</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span>::<span class=\"n\">Output</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Future</span>: <span class=\"nc\">FutureOnce</span><span class=\"w\">  </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">poll</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">self</span>: <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Poll</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span>::<span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The former one will serve well for non-interruptable futures, right?</p>",
        "id": 245477533,
        "sender_full_name": "Charles Lew",
        "timestamp": 1625854061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I like the concept of the proposed new trait in theory. Am I interpreting correctly that we would allow both, so that it's possible to have a future that can be forgotten, but that's a property that you can choose?</p>",
        "id": 245478315,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854453
    },
    {
        "content": "<p>Because there are valid use cases for a future that never gets to finish.</p>",
        "id": 245478341,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854466
    },
    {
        "content": "<p>But I would also love to demarcate regions where I'm holding important data and don't want to drop it on the floor, as one of many examples.</p>",
        "id": 245478389,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854489
    },
    {
        "content": "<p>(or, better yet, not have to demarcate them)</p>",
        "id": 245478409,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625854497
    },
    {
        "content": "<blockquote>\n<p>I like the concept of the proposed new trait in theory. Am I interpreting correctly that we would allow both, so that it's possible to have a future that can be forgotten, but that's a property that you can choose?</p>\n</blockquote>\n<p>We can decide whether we want both! <a href=\"https://github.com/Matthias247/rfcs/pull/1\">https://github.com/Matthias247/rfcs/pull/1</a> had described the way where <code>Future</code> is kept around to have a way of always cancellable <code>Future</code>s. However Niko also described it might be useful to have a broader migration to the new trait, which also makes sense to me.</p>\n<p>I agree there are use-cases for the current system. For me the strongest use-case is something like a <code>select!</code> on multiple channels. Whichever receives an item first - we handle it. That requires the receive operations to be cancellable or pausable, which isn't that easy with the completion trait.</p>",
        "id": 245478985,
        "sender_full_name": "Matthias247",
        "timestamp": 1625854805
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> I think we definitely want a way to express \"this future can be canceled\"</p>",
        "id": 245491419,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861315
    },
    {
        "content": "<p>I'm not 100% sure if using the old trait for that makes sense, but it's plausible</p>",
        "id": 245491469,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861340
    },
    {
        "content": "<p>the main argument against that I mentioned to <span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> was basically that it uses <code>Pin</code> and that it might be the only place <code>Pin</code> is used; I'm not convinced <code>Pin</code> carries its weight there</p>",
        "id": 245491513,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861374
    },
    {
        "content": "<p>versus like a marker trait</p>",
        "id": 245491520,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861378
    },
    {
        "content": "<p>\"what matthias said\", basically :)</p>",
        "id": 245491618,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625861424
    },
    {
        "content": "<p>Well Pin there still allows for intrusive waiter lists that allow for MPMC channels, async semaphores and Mutexes, etc without any dynamic allocations. </p>\n<p>While I think for Mutexes it can be worthwhile to think whether there i should only be non cancellable variants - I donâ€™t see the same for channels yet. Unless we find another way to select over them (crossbeam can also do it in a synchronous world - so it should be doable)</p>",
        "id": 245493369,
        "sender_full_name": "Matthias247",
        "timestamp": 1625862352
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> So, the premise is that the new trait implies Pin but doesn't actually need to use Pin?</p>",
        "id": 245493514,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862428
    },
    {
        "content": "<p>The new pin has an <code>unsafe</code> <code>poll</code> method, so we can make one of the conditions be that, once you start polling, you cannot move the pollee again</p>",
        "id": 245493567,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862461
    },
    {
        "content": "<p>I don't think <code>Pin</code> buys you much at that stage</p>",
        "id": 245493587,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862473
    },
    {
        "content": "<p>It seems like we have a lot of machinery around Pin to give people a way to express that.</p>",
        "id": 245493646,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862488
    },
    {
        "content": "<p>I'm not <em>completely</em> sure that we want to just say \"here's an unsafe function, be careful to not move the object afterward\".</p>",
        "id": 245493675,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862507
    },
    {
        "content": "<p>The thing is, nobody is calling that method but runtimes.</p>",
        "id": 245493721,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862535
    },
    {
        "content": "<p>It's possible we could still use <code>Pin</code>, but I don't know that it carries its weight in that scenario.</p>",
        "id": 245493746,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862552
    },
    {
        "content": "<p>People implementing futures also currently end up doing things with Pin sometimes, to express their data structures. How confident are we that nobody actually needs to do so?</p>",
        "id": 245493794,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862585
    },
    {
        "content": "<p>It's a bit different today as there are a lot of <code>Poll</code> methods</p>",
        "id": 245493798,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862587
    },
    {
        "content": "<p>For the record, I <em>love</em> the idea of eliminating both Pin and Poll as concerns for anyone not implementing a runtime.</p>",
        "id": 245493882,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862619
    },
    {
        "content": "<p>I will say that I've yet to hear <em>anybody</em> say they understand <code>Pin</code></p>",
        "id": 245493884,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862620
    },
    {
        "content": "<p>that is, anybody who is using async fn day to day</p>",
        "id": 245493897,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862633
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245493884\">said</a>:</p>\n<blockquote>\n<p>I will say that I've yet to hear <em>anybody</em> say they understand <code>Pin</code></p>\n</blockquote>\n<p>I feel like I understand it <em>better</em> after reading <a href=\"https://fasterthanli.me/articles/pin-and-suffering\">https://fasterthanli.me/articles/pin-and-suffering</a> , but that doesn't make me happy about it. :)</p>",
        "id": 245493918,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862648
    },
    {
        "content": "<p>I'm not sure that this argues against it <em>exactly</em></p>",
        "id": 245493940,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862661
    },
    {
        "content": "<p>in other words, if <code>Pin</code> is making things hard because people would've been writing wrong unsafe code...</p>",
        "id": 245493980,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862683
    },
    {
        "content": "<p>Right.</p>",
        "id": 245493991,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625862693
    },
    {
        "content": "<p>...anyway, I think the question of \"When do you need to implement futures by hand\" is a good one. I don't think there will be many cases.</p>",
        "id": 245494012,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625862706
    },
    {
        "content": "<p>Bringing it back on topic, I'd be fine with dropping Pin if 1) we feel like we're still giving people enough tools to write the unsafe code for \"don't move this\" correctly (and ideally assisted by the type system), and 2) we don't need it for other things, like self-refs.</p>",
        "id": 245494695,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625863082
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"204219\">Matthias247</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245493369\">said</a>:</p>\n<blockquote>\n<p>Well Pin there still allows for intrusive waiter lists that allow for MPMC channels, async semaphores and Mutexes, etc without any dynamic allocations. </p>\n<p>While I think for Mutexes it can be worthwhile to think whether there i should only be non cancellable variants - I donâ€™t see the same for channels yet. Unless we find another way to select over them (crossbeam can also do it in a synchronous world - so it should be doable)</p>\n</blockquote>\n<p>also things like <code>cxx</code> can express rust's inability to move std::string's by pinning any mutable access, overall its a great api even if the <code>Async trait</code> doesnt use it</p>",
        "id": 245494742,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1625863092
    },
    {
        "content": "<p>I kind of agree that if the method is already unsafe then Pin doesnâ€™t buy terribly much. But if people want to keep it for the sake of expressing that extra requirement Iâ€™m also not opposed</p>",
        "id": 245494774,
        "sender_full_name": "Matthias247",
        "timestamp": 1625863123
    },
    {
        "content": "<p>(did some thread juggling there)</p>",
        "id": 245494827,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863156
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257428\">@Gus Wynn</span> that's interesting! I didn't know about that.</p>",
        "id": 245494856,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863176
    },
    {
        "content": "<p>Pin is now also used heavily in the Rust for Linux kernel effort. Probably due to intrusive data structures</p>",
        "id": 245494962,
        "sender_full_name": "Matthias247",
        "timestamp": 1625863222
    },
    {
        "content": "<p>Also interesting.</p>",
        "id": 245495069,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863288
    },
    {
        "content": "<p>We also use the drop guarantee of Pin in embedded to register/de-register interrupts</p>",
        "id": 245495495,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625863496
    },
    {
        "content": "<p>And to access state in these interrupts</p>",
        "id": 245495526,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625863511
    },
    {
        "content": "<p>Although I think Pin is a kinda bad, but it's what we have for that, I would love if it would be more baked into the language</p>",
        "id": 245495580,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625863552
    },
    {
        "content": "<p>I also just had a case of needing to poll an async fn once before fully awaiting it, would that be possible somehow if .await gets removed ?</p>",
        "id": 245495837,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625863695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204219\">@Matthias247</span> In <a href=\"https://nikomatsakis.github.io/wg-async-foundations/vision/harmonic/compose_control_scheduling/async_trait.html\">https://nikomatsakis.github.io/wg-async-foundations/vision/harmonic/compose_control_scheduling/async_trait.html</a> , what is <code>core::task::Ready</code> supposed to be? (That type doesn't exist today.)</p>",
        "id": 245495919,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625863753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"267734\">Thales Fragoso</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245495837\">said</a>:</p>\n<blockquote>\n<p>I also just had a case of needing to poll an async fn once before fully awaiting it, would that be possible somehow if .await gets removed ?</p>\n</blockquote>\n<p>say more about this?</p>",
        "id": 245496099,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863865
    },
    {
        "content": "<p>I guess the same as <code>Poll::Ready</code>? Just a new name to differentiate from old futures? <br>\nItâ€™s <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> invention, my RFC reused <code>Poll</code> ðŸ˜€</p>",
        "id": 245496132,
        "sender_full_name": "Matthias247",
        "timestamp": 1625863882
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245495919\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"204219\">Matthias247</span> In <a href=\"https://nikomatsakis.github.io/wg-async-foundations/vision/harmonic/compose_control_scheduling/async_trait.html\">https://nikomatsakis.github.io/wg-async-foundations/vision/harmonic/compose_control_scheduling/async_trait.html</a> , what is <code>core::task::Ready</code> supposed to be? (That type doesn't exist today.)</p>\n</blockquote>\n<p>I meant to reuse Poll</p>",
        "id": 245496155,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863893
    },
    {
        "content": "<p>I just misremembered the name :)</p>",
        "id": 245496162,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863898
    },
    {
        "content": "<p>will fix</p>",
        "id": 245496165,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863901
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> can you elaborate on your use case? I'd say it'd be <em>possible</em> but highly discouraged :)</p>",
        "id": 245496267,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625863947
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> We have an async fn to setup a DMA transfer and await for it, it makes sense to setup and await in the same fn because when you enable the DMA you basically giving the buffer to it since it can start modifying it. </p>\n<p>That works nicely, but some peripherals need some start condition to be done after the DMA is enabled, so the idea is to poll once for the setup, do the start condition and then await the DMA future</p>",
        "id": 245496505,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625864110
    },
    {
        "content": "<p>We could separate the setup and awaiting into two different fns, one normal and another async, but it would be kinda of error prone, because when you enable the DMA is when you really shouldn't be touching the buffer anymore, and it's the future that borrows it</p>",
        "id": 245496668,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625864183
    },
    {
        "content": "<p>I'm curious whether a setup like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">dma</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* do the setup */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>would work for you</p>",
        "id": 245496752,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625864248
    },
    {
        "content": "<p>Hmm, that might be possible, yeah</p>",
        "id": 245497006,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625864375
    },
    {
        "content": "<p>I would have to check the code, but I think that modification could be done</p>",
        "id": 245497135,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625864414
    },
    {
        "content": "<p>I actually just hit this case today, so I haven't had the time to really go through it</p>",
        "id": 245497274,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625864449
    },
    {
        "content": "<p>worth checking, seems simpler!</p>",
        "id": 245497359,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625864467
    },
    {
        "content": "<p>Agreed, thanks</p>",
        "id": 245497400,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625864476
    },
    {
        "content": "<p>I'd like to clarify how exactly \"autoawait\" would work. What would the <code>foo()</code> syntax mean in these cases?</p>\n<ul>\n<li>in async context, <code>foo</code> is an async fn -&gt; implicit await</li>\n<li>in async context, <code>foo</code> is a normal fn -&gt; normal function call</li>\n<li>in non-async context, <code>foo</code> is an async fn -&gt; ????</li>\n<li>in non-async context, <code>foo</code> is a normal fn -&gt; normal function call</li>\n</ul>",
        "id": 245498902,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625864822
    },
    {
        "content": "<p>Yeah, I'm not sure how that would work either :)</p>",
        "id": 245499134,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625864888
    },
    {
        "content": "<p>Certainly one way would be: you can't reference <code>foo</code> in a sync context</p>",
        "id": 245499166,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625864898
    },
    {
        "content": "<p>and</p>\n<ul>\n<li>How do you retrieve the Future for <code>foo()</code> as a plain value, in both async and non-async context?</li>\n<li>If you have a Future value in a variable, how do you await it</li>\n</ul>",
        "id": 245499177,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625864902
    },
    {
        "content": "<blockquote>\n<p>you can't reference <code>foo</code> in a sync context</p>\n</blockquote>\n<p>how do you spawn an async task from a sync context then? you do that currently with <code>executor::spawn(foo())</code></p>",
        "id": 245499381,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625864970
    },
    {
        "content": "<p>probably <code>executor::spawn(async || foo())</code></p>",
        "id": 245499441,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625864992
    },
    {
        "content": "<p>I think the idea would be: if you want an <code>Async</code> value, you make an <code>async || </code> closure</p>",
        "id": 245499521,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865011
    },
    {
        "content": "<p>async functions can only be invoked from inside an async context (and an async closure is such a context)</p>",
        "id": 245499574,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865030
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245499441\">said</a>:</p>\n<blockquote>\n<p>probably <code>executor::spawn(async || foo())</code></p>\n</blockquote>\n<p>obviously similar to <code>std::thread::spawn(move || foo())</code></p>",
        "id": 245499635,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865052
    },
    {
        "content": "<p>but you can do <code>thread::spawn(foo)</code></p>",
        "id": 245499681,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625865067
    },
    {
        "content": "<p>sure</p>",
        "id": 245499706,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865074
    },
    {
        "content": "<p>why do I need a closure for async spawn?</p>",
        "id": 245499725,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625865081
    },
    {
        "content": "<p>you actually maybe don't</p>",
        "id": 245499796,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865104
    },
    {
        "content": "<p>I'm thinking</p>",
        "id": 245499817,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865109
    },
    {
        "content": "<p>if we pursue the \"there is no difference between an <code>Async</code> and a <code>AsyncFnOnce</code>\"</p>",
        "id": 245499920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865132
    },
    {
        "content": "<p>then in a way, the call <em>is</em> the await</p>",
        "id": 245499941,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865139
    },
    {
        "content": "<p>also wouldn't it be <code>executor::spawn(async { foo() })</code>? <code>async{}</code> is a Future, <code>async || {}</code> is a <code>Fn() -&gt; impl Future</code> (?)</p>",
        "id": 245499989,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625865156
    },
    {
        "content": "<p>in that scenario, writing <code>let f = foo</code> gets you the <code>Async</code></p>",
        "id": 245500005,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865161
    },
    {
        "content": "<p>in both a sync and an sync context</p>",
        "id": 245500057,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865179
    },
    {
        "content": "<p>the only difference is that you can't <em>call</em> it in a sync context</p>",
        "id": 245500082,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865186
    },
    {
        "content": "<p>(hmm, that doesnt make sense)</p>",
        "id": 245500239,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865237
    },
    {
        "content": "<p>it has to capture the arguments :)</p>",
        "id": 245500245,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865239
    },
    {
        "content": "<p><code>async fn foo</code> is a \"factory of asyncs\", not an \"async\" itself though, right?</p>",
        "id": 245500322,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625865255
    },
    {
        "content": "<p>right, that's what I just realized :)</p>",
        "id": 245500404,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865284
    },
    {
        "content": "<p>so you need a way to \"cause factorifying to happen without causing await to happen\" to get the future to spawn that</p>",
        "id": 245500519,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625865328
    },
    {
        "content": "<p>for that, I really can't think of a more elgant way than the current <code>foo()</code> vs <code>foo().await</code> to be honest...</p>",
        "id": 245500841,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625865378
    },
    {
        "content": "<p>I somewhat agree :)</p>",
        "id": 245501113,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865445
    },
    {
        "content": "<p>That said, I do think that <code>AsyncDrop</code> inserting implicit awaits means that \"look for await to find out where X happens\" Is much less useful</p>",
        "id": 245501287,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865491
    },
    {
        "content": "<p>and I do think that when I write async code, having to insert await is annoying :)</p>",
        "id": 245501313,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865500
    },
    {
        "content": "<p>It does make logical sense to observe that people await a future more often than they pass it around without awaiting it. But at the same time, I think there's a certain \"safety bias\" here, where it feels a little more comfortable to have syntax for \"do thing\" rather than having syntax for \"don't do thing\".</p>",
        "id": 245502085,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625865729
    },
    {
        "content": "<p>It's absolutely a tradeoff.</p>",
        "id": 245502116,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625865740
    },
    {
        "content": "<p>(We could also consider other ways to address that tradeoff, such as entertaining shorter syntaxes for <code>.await</code>.)</p>",
        "id": 245502169,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625865753
    },
    {
        "content": "<p>I don't think the length of the keyword is a problem</p>",
        "id": 245502218,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625865769
    },
    {
        "content": "<p>Seems worth considering, at least. We went from <code>try!</code> to <code>?</code> and that made error handling <em>much</em> better.</p>",
        "id": 245502329,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625865803
    },
    {
        "content": "<p>In async code, <code>.await</code> seems as prevalent as <code>?</code>, but it's much more verbose.</p>",
        "id": 245502366,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625865814
    },
    {
        "content": "<p>Another potential option would be the idea of an <code>await {}</code> block, which uses auto-await syntax for all async functions within. That might be more comfortable than forcing auto-await <em>everywhere</em>.</p>",
        "id": 245502621,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625865888
    },
    {
        "content": "<p>I think in general terms I'm suggesting that if we consider that tradeoff important, we might want to entertain other possible solutions that touch on the same tradeoff.</p>",
        "id": 245502705,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625865914
    },
    {
        "content": "<p>\"optional autoawait syntax\" would be even worse imo. <code>foo()</code> would mean radically different things based on context</p>",
        "id": 245504150,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625866349
    },
    {
        "content": "<p>I already really don't like that <code>my_async_fn()</code> and <code>my_sync_fn()</code> mean different things, but having <code>my_async_fn()</code> mean different thigns based on context is even worse</p>",
        "id": 245504399,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625866439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245502329\">said</a>:</p>\n<blockquote>\n<p>Seems worth considering, at least. We went from <code>try!</code> to <code>?</code> and that made error handling <em>much</em> better.</p>\n</blockquote>\n<p>the big shift here, imo, was moving to postfix form.</p>",
        "id": 245504716,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625866533
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348152\">Dario Nieuwenhuis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245504399\">said</a>:</p>\n<blockquote>\n<p>I already really don't like that <code>my_async_fn()</code> and <code>my_sync_fn()</code> mean different things</p>\n</blockquote>\n<p>this is, of course, what I am driving at :)</p>",
        "id": 245504797,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625866557
    },
    {
        "content": "<p>still, I definitely see yor point that it's hard to see how removing <code>await</code> would <strong>actually work</strong> when you drill into the details :)</p>",
        "id": 245504920,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625866586
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> was making a similar point to me as well</p>",
        "id": 245504943,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625866595
    },
    {
        "content": "<p>well even if we figured out the details, I disagree with the <em>idea</em> too :S</p>",
        "id": 245505337,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625866724
    },
    {
        "content": "<p>Rust is a very explicit language. The compiler won't use vtables unless you write <code>dyn</code>. The compiler won't do allocations unless you write <code>Box::new</code>, etc etc</p>",
        "id": 245505839,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625866896
    },
    {
        "content": "<p>implicit await would be a major departure from this</p>",
        "id": 245505881,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625866909
    },
    {
        "content": "<p>Do you feel the same way about <code>AsyncDrop</code>?</p>",
        "id": 245506322,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867049
    },
    {
        "content": "<p><em>mayyybe</em> a bit too, yes, but much less strongly</p>",
        "id": 245506496,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867113
    },
    {
        "content": "<p>what makes it different?</p>",
        "id": 245506558,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867138
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">dma</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* do the setup */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> how would a be able to write if we remove .await ?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">fut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dma</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">send_start</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">fut</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245506560,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625867138
    },
    {
        "content": "<p>Drop is already \"magic implicit function calls\"<br>\nAsyncDrop would be \"magic implicit async function calls\"</p>",
        "id": 245506702,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867173
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"267734\">@Thales Fragoso</span> presumably <em>that</em> would be </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">dma</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">AsyncFnOnce</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">do_setup</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and then</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">closure</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">dma</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">send_start</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">closure</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245506798,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867210
    },
    {
        "content": "<p>...or something like that :)</p>",
        "id": 245506872,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867235
    },
    {
        "content": "<p>Got it</p>",
        "id": 245506891,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625867240
    },
    {
        "content": "<p>and Drop/AsyncDrop for the most part is quite \"predictable\", it just does cleanup</p>",
        "id": 245506915,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867248
    },
    {
        "content": "<p>anyway, I don't know :) I want to go off and play with it now that <span class=\"user-mention\" data-user-id=\"348152\">@Dario Nieuwenhuis</span> poked a bunch of holes in my idea of what it would be like</p>",
        "id": 245506949,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867260
    },
    {
        "content": "<p>but (as I said at the top of this thread...) to me, the question of <code>.await</code> or not is relatively minor</p>",
        "id": 245507011,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867280
    },
    {
        "content": "<p>I'm much more keen on scopes and other things as a solution to a bunch of problems</p>",
        "id": 245507088,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867294
    },
    {
        "content": "<p>I would like to explore alternatives to AsyncDrop, though</p>",
        "id": 245507110,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867302
    },
    {
        "content": "<p>I'd be curious to talk it out</p>",
        "id": 245507151,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867316
    },
    {
        "content": "<p>I thought about it a fair bit and came to the conclusion that you really <em>do</em> want it to work implicitly, but it'd be interesting to find another option</p>",
        "id": 245507207,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867332
    },
    {
        "content": "<p>I guess you could imagine <code>{ ... }.await</code> or something :)</p>",
        "id": 245507238,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867344
    },
    {
        "content": "<p>but it's really stuff like <code>?</code> operator and <code>break</code> that does it for me</p>",
        "id": 245507306,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867366
    },
    {
        "content": "<p>for example the <code>?Drop</code> idea could be used to forbid sync-dropping something<br>\nfor example on a file i/o lib,  this could be used to force the user to call an async <code>.close()</code></p>",
        "id": 245507363,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867385
    },
    {
        "content": "<p>Yes, I went down that road.</p>",
        "id": 245507401,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867400
    },
    {
        "content": "<p>but that's not implicit at all, no</p>",
        "id": 245507419,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867402
    },
    {
        "content": "<p><code>?Drop</code> is a pretty major chagne to the language though</p>",
        "id": 245507460,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867407
    },
    {
        "content": "<p>I could imagine that becoming annoying</p>",
        "id": 245507480,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867412
    },
    {
        "content": "<p>plus, I think if you work it out-- that</p>",
        "id": 245507495,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867416
    },
    {
        "content": "<p>well speaking of major changes for the language...<br>\nI would like to lobby for <code>?Leak</code> too <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span></p>",
        "id": 245507575,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867445
    },
    {
        "content": "<p>(<code>?Drop</code> does have stuff to recommend it; it might be a good idea)</p>",
        "id": 245507587,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867450
    },
    {
        "content": "<p>I <em>think</em> it's possible to remove the need for the \"Future 2.0\" trait (Async) if we have <code>?Drop</code> and <code>?Leak</code></p>",
        "id": 245507660,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867476
    },
    {
        "content": "<p>Plausibly</p>",
        "id": 245507712,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867496
    },
    {
        "content": "<p>But those are <em>much</em> more disruptive changes :)</p>",
        "id": 245507744,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867507
    },
    {
        "content": "<p>And unlike a Futures 2.0, they don't go away in time</p>",
        "id": 245507772,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1625867518
    },
    {
        "content": "<p><code>?Drop</code> would be much, much cleaner IMO. Having a second trait feels like an ugly hack/workaround of limitations of the Rust type system</p>",
        "id": 245507856,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867538
    },
    {
        "content": "<blockquote>\n<p>in non-async context, foo is an async fn -&gt; ????</p>\n</blockquote>\n<p>I would have expected it is a compilation error just like it would be in Kotlin or C++</p>",
        "id": 245507871,
        "sender_full_name": "Matthias247",
        "timestamp": 1625867545
    },
    {
        "content": "<p><code>?Drop</code> and <code>?Leak</code> address the root cause of the issue</p>",
        "id": 245507987,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867587
    },
    {
        "content": "<p>while <code>Async</code> workarounds it with unsafe asking the user to \"hey please don't drop me OK?\"</p>",
        "id": 245508086,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867625
    },
    {
        "content": "<blockquote>\n<p>but you can do thread::spawn(foo)</p>\n</blockquote>\n<p>But <code>foo</code> is the name of the function, not an invocation. If you do <code>spawn(foo())</code> it will also do the immediate invocation.<br>\nImho it would be perfectly resembling the synchronous world if one had to do <code>spawn(async || async_foo())</code> or <code>spawn(async_foo)</code>.</p>",
        "id": 245508206,
        "sender_full_name": "Matthias247",
        "timestamp": 1625867656
    },
    {
        "content": "<p>no</p>\n<p>in sync a \"runnable unit\" is a closure<br>\nin async a \"runnable unit\" is a future</p>\n<p>an async closure is a \"factory of futures\"</p>",
        "id": 245508378,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867733
    },
    {
        "content": "<p>async spawn should take a future, not an async closure</p>",
        "id": 245508416,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625867746
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348152\">Dario Nieuwenhuis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245507660\">said</a>:</p>\n<blockquote>\n<p>I <em>think</em> it's possible to remove the need for the \"Future 2.0\" trait (Async) if we have <code>?Drop</code> and <code>?Leak</code></p>\n</blockquote>\n<p>Can I get a bit more context on the implication of <code>?Drop</code> and <code>?Leak</code>? Is the idea here to have types that you're not allowed to implicitly drop, and <em>must</em> explicitly drop?</p>",
        "id": 245510457,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1625868452
    },
    {
        "content": "<p>I mean, I've wanted types that you _have_ to explicitly consume somehow for a long time, just because it is helpful for writing hard-to-misuse APIs.</p>",
        "id": 245510693,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1625868536
    },
    {
        "content": "<p>yeah!</p>",
        "id": 245510719,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625868548
    },
    {
        "content": "<p>I imagine it would be something like this (completely invented syntax)</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">..</span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"nb\">Drop</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span>::<span class=\"n\">new</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"c1\">// compile error: you may not drop an instance of Foo</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245510812,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625868588
    },
    {
        "content": "<p>then <code>Foo</code> could define a <code>fn close(self)</code> that you <em>have</em> to call to get rid of it</p>",
        "id": 245510983,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625868644
    },
    {
        "content": "<p>or even <code>async fn close(self)</code> to enforce closing is async</p>",
        "id": 245511014,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625868658
    },
    {
        "content": "<p>I mean, you run in to the issue that you can't use <code>?</code> in any function with such a type in scope, so it's not as clear cut.</p>",
        "id": 245511126,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1625868708
    },
    {
        "content": "<p>with this, you can use the current <code>Future</code> trait for non-cancellable futures, no need for a new trait</p>",
        "id": 245511208,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625868726
    },
    {
        "content": "<p>oh taht's true, hmm...</p>",
        "id": 245511235,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625868739
    },
    {
        "content": "<p>Also please consider that some of those things are about intent and usability, instead of just combining low-levels things. Of course one could offer things like \"use a generator instead of an async fn, combine that with traits like <code>?Drop</code> and <code>?Leak</code>, and sprinkle a bit of <code>Pin</code> in between \".</p>\n<p>However which \"casual developer\" can really keep up with all of those terms? <code>async fn</code>  is imho intended to be an easy way for the majority of developers to write code which multiplexes multiple tasks on a thread . This is a super common requirement,  and in my team we have like 50 developers writing code that way. Out of that, at least 45 likely don't know that what <code>?Trait</code>, other kinds of higher level trait bounds  or <code>Pin</code> is.</p>",
        "id": 245514724,
        "sender_full_name": "Matthias247",
        "timestamp": 1625871210
    },
    {
        "content": "<p>I do undestand that's the rationale behind these proposals</p>",
        "id": 245514992,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625871437
    },
    {
        "content": "<p>however:</p>\n<ol>\n<li>Rust is an inherently low level language. Developers have to deal with complexity, such as lifetimes, subtle distinctions like Arc vs Rc, Send/Sync, etc. Rust has always been about giving the developer tools to manage that complexity safely and productively <em>but without hiding it</em>. Rust will not use vtables unless you write <code>dyn</code>. Rust will not do allocations unless you write <code>Box::new</code>. Rust will not do integer casts unless you write <code>as</code>. I fail to see a justification of why should async Rust be different.</li>\n</ol>",
        "id": 245515352,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625871757
    },
    {
        "content": "<ol start=\"2\">\n<li>JS developers have been writing <code>await</code> at every async call just fine for years, and JS is arguably one of the most removed-from-low-level-stuff languages. And the JS developer population is overwhelmingly junior devs.</li>\n</ol>",
        "id": 245515484,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625871887
    },
    {
        "content": "<p>I'm with <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> on that one. It depends on what you gain from having access to more functionality. Without <code>dyn Trait</code>, you can avoid the cost for dynamic dispatch. What is the reason for having an explicit future on the stack that is only valid if you very carefully handle it? And even if you require to have that mechanism - the approach would not take it away - it just requires a different syntax.  </p>\n<p>And think about it - you don't see raw stack frames in rust either, or don't see raw pointers by default. You don't really know whether the compiler passes something by copy or value if both approaches are valid. There's already lots of abstraction for use-cases where there are sane defaults for most users.</p>",
        "id": 245516012,
        "sender_full_name": "Matthias247",
        "timestamp": 1625872436
    },
    {
        "content": "<ol start=\"3\">\n<li>I'm fairly confident that it's possible to wire up some lowlevel machinery like <code>AsyncDrop</code> or <code>?Drop</code> to get the high-level properties we want, so that it Just Works for high-level code without high-level users having to learn these in depth.</li>\n</ol>",
        "id": 245516077,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625872503
    },
    {
        "content": "<p>I would argue the cost of an \"await\" is higher than the cost of dynamic dispatch / box</p>",
        "id": 245516098,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625872537
    },
    {
        "content": "<p>and it's not just the cost of the await itself. You often want to control where a big buffer goes. Currently it's super easy: are you holding the big buffer across an await? it goes on the future, otherwise it goes in the stack.</p>",
        "id": 245516220,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625872634
    },
    {
        "content": "<p>so with a quick look you can tell whether an <code>async fn</code> will have a bloated future or not, and quickly fix it</p>",
        "id": 245516247,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625872677
    },
    {
        "content": "<p>if you hide awaits, that's no longer possible</p>",
        "id": 245516294,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625872685
    },
    {
        "content": "<p>you have to check the docs of each and every single \"function call-looking\" <code>foo()</code> to see if it's a function call or an await</p>",
        "id": 245516314,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625872711
    },
    {
        "content": "<p>This makes async HARDER to use in applications where you care about memory usage, not easier.</p>",
        "id": 245516337,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625872735
    },
    {
        "content": "<p><code>+ 1</code> to know if a buffer goes in a future or the stack. I got bit by this recently</p>",
        "id": 245516498,
        "sender_full_name": "Thales Fragoso",
        "timestamp": 1625872875
    },
    {
        "content": "<blockquote>\n<p>it goes on the future, otherwise it goes in the stack.</p>\n</blockquote>\n<p>I think this is a reasonable argument  for it - which is alongside the <code>Send/Sync</code> requirement ones.<br>\nIt had been mentioned that those things could be highlighted by IDEs. But since not everyone uses an IDE, and for example there are typically none for code-views, there are also points against that</p>",
        "id": 245516733,
        "sender_full_name": "Matthias247",
        "timestamp": 1625873052
    },
    {
        "content": "<p>I find the \"your IDE will highlight that\" argument pretty weak, yes</p>",
        "id": 245516788,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873134
    },
    {
        "content": "<p>Another thing: <code>await</code> makes the points at which your future can get canceled (dropped) really visible.</p>",
        "id": 245516886,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873226
    },
    {
        "content": "<p>This has been priceless in ensuring correctness in Embassy's async HALs (hardware abstraction layers)</p>",
        "id": 245516904,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873263
    },
    {
        "content": "<p>for example, a \"send bytes\" async fn would do:</p>\n<ul>\n<li>Set up DMA to send the bytes, start it (all sync register writes)</li>\n<li>Await DMA completion</li>\n<li>Cleanup state (all sync register writes again)</li>\n</ul>\n<p>With a very quick glance at the code, I can know there's only 2 possible paths through that code:</p>\n<ul>\n<li>Setup, await, cleanup -&gt; all great</li>\n<li>Setup, await, cancel -&gt; I setup a drop handler to stop DMA on cancel to ensure correctness</li>\n</ul>\n<p>And that's it! I have the guarantee that these two paths are correct, everything's great.</p>",
        "id": 245517073,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873411
    },
    {
        "content": "<p>However, with \"autoawait\":</p>\n<ol>\n<li>It's now no longer possible to ensure there's just these two possible code paths through visual inspection</li>\n<li>Someone else might change a sync fn called in cleanup to async. This would introduce a third code path through this function! And the code would compile as-is, so this would go unnoticed and this function will likely behave incorrectly if the future is canceled in this new 3rd code path.</li>\n</ol>",
        "id": 245517245,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873585
    },
    {
        "content": "<p>Regular function calls and awaits having different syntax is a <em>feature</em></p>",
        "id": 245517274,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873632
    },
    {
        "content": "<p>You are missing that we are talking about a new non-cancellable trait</p>",
        "id": 245517280,
        "sender_full_name": "Matthias247",
        "timestamp": 1625873641
    },
    {
        "content": "<p>I <em>want</em> my futures to be cancelable</p>",
        "id": 245517321,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873652
    },
    {
        "content": "<p>The problem is not \"I want to prevent cancelation\", it's \"I want to ensure correctness when cancelation happens\"</p>",
        "id": 245517338,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873694
    },
    {
        "content": "<p>Implicit awaits make ensuring correctness incredibly hard</p>",
        "id": 245517358,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625873716
    },
    {
        "content": "<p>Well there have been cases where there is really no safe way to correctly handle cancellation.  That is the main motivation for another trait. Please try to catch up on those before dismissing it.</p>\n<p>Dropping <code>.await</code> is mostly an additional idea, around which I personally have no strong opinion. I think it will likely work fine either way,  with some minor adjustments here and there to accomodate some use-cases</p>",
        "id": 245517791,
        "sender_full_name": "Matthias247",
        "timestamp": 1625874137
    },
    {
        "content": "<p>I'm not dismissing the need for some form of async cancel / async drop, and I have caught up with all discussions on that.</p>",
        "id": 245517845,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625874231
    },
    {
        "content": "<p>All of the above are arguments against autoawait</p>",
        "id": 245517908,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1625874290
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348152\">Dario Nieuwenhuis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245517908\">said</a>:</p>\n<blockquote>\n<p>All of the above are arguments against autoawait</p>\n</blockquote>\n<p>TBH they also read as arguments against panic and sync Drop! Giving sync and async calls different syntax is only a feature if you also assume a bunch of other differences between the two are fundamental (e.g. lack of async Drop, weird interactions between Send/Sync and threads vs tasks)</p>\n<p>But the whole overarching goal here is to make the two more similar, because the differences keep turning out to be footguns and/or roadblocks. And of course this has to be predicated on preserving some important things about async, but determining which aspects of async are critical and which are \"just\" workarounds is the hard part.</p>\n<p>IMO it helps to consider the critical aspects of async to be purely on the \"generated code\" side- sync code uses large dynamically allocated stacks with an ambient cross-language preemptive kernel scheduler; async code uses small (mostly-)fixed-size stacks with a language-integrated cooperative user-space scheduler. Everything else flows from this, or else it is probably equally important to solve in sync code!</p>\n<p>So back to the start of this message- if your problem with autoawait is that it makes it harder to pick out the full set of control flow paths... then why is this not also a problem with sync code which can also panic (the sync version of cancellation) at any function call? Either sync code makes that potential explosion fine somehow (e.g. Drop can block, thus async Drop would provide identical benefits to autoawait) or else the sync code has the same problem (and thus we should approach the problem more generally rather than doubling down on the status quo for async only).</p>",
        "id": 245622921,
        "sender_full_name": "rpjohnst",
        "timestamp": 1626031990
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245502329\">said</a>:</p>\n<blockquote>\n<p>Seems worth considering, at least. We went from <code>try!</code> to <code>?</code> and that made error handling <em>much</em> better.</p>\n</blockquote>\n<p><code>try!</code> to <code>?</code> means we went from <code>try!(try!(try!(foo).bar()).baz))</code> to <code>foo?.bar()?.baz()?</code>. I think the big difference it the postfix syntax, and that already happened with <code>await! -&gt; .await</code>. I don't thing shortening the keyword will really help.</p>",
        "id": 245623414,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1626032828
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245622921\">said</a>:</p>\n<blockquote>\n<p>if your problem with autoawait is that it makes it harder to pick out the full set of control flow paths... then why is this not also a problem with sync code which can also panic (the sync version of cancellation) at any function call? </p>\n</blockquote>\n<p>IMO panic is not the sync version of cancelation. In sync code you cancel stuff by setting some flag, or by using deadlines/timeouts/close on sockets, and bubble up the returned errors in <code>Result</code>s.</p>\n<p>And indeed, using panics for error handling or cancelation is a very bad practice and makes ensuring correctness really hard. It should be only used for unrecoverable, fatal errors.</p>\n<p>In embedded, <code>panic</code> usually doesn't even unwind, it might do some emergency cleanup to bring the system to a safe state (like stopping motors) then reboot the entire microcontroller. A panic is not a \"sync cancelation\", it's a \"the universe ends and time stops\" thing, there's no \"after\" to worry about.</p>\n<p>However, in async canceling a future by dropping it is the intended, officially blessed way of doing it. Not a bad practice.</p>",
        "id": 245629616,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1626041177
    },
    {
        "content": "<p>This is not a big problem in sync code because most programs don't even attempt to recover from panics, or when they do they do it at a very coarse granularity (per HTTP request in a server, for example) which causes all state to be thrown away.</p>",
        "id": 245629870,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1626041564
    },
    {
        "content": "<p>Panic \"cancelation\" can only cause issues if a thread panics <em>while mutating global state</em> in a program that recovers panics such as an HTTP server. And even then, such global state is probably behind a Mutex which gets poisoned in this case.</p>",
        "id": 245629886,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1626041618
    },
    {
        "content": "<p>tldr sync panic is for fatal errors and not intended to be recovered from, while async cancel is normal routine</p>",
        "id": 245630071,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1626041859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"348152\">Dario Nieuwenhuis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245629616\">said</a>:</p>\n<blockquote>\n<p>IMO panic is not the sync version of cancelation. In sync code you cancel stuff by setting some flag, or by using deadlines/timeouts/close on sockets, and bubble up the returned errors in <code>Result</code>s.</p>\n</blockquote>\n<p>it's an operational comparison, not a purpose comparison. panic is functionally near-identical to future cancellation- destructors on the stack are run and the thread never continues (speaking in terms of panic=unwind here obviously!)</p>\n<p>so in that sense what you're saying simply suggests that future cancellation should only be used for unrecoverable errors, rather than actual semantic cancellation! and that's exactly the sort of idea coming out of \"make sync/async more similar\"/\"support async drop\"/etc.</p>",
        "id": 245714880,
        "sender_full_name": "rpjohnst",
        "timestamp": 1626108833
    },
    {
        "content": "<p>and thus, if the consequences of panic and future cancellation are such that it only makes sense to use them for unrecoverable errors, then the question becomes: why are we trying to reason about future cancellation control flow paths, instead of just doing cancellation via bubbling Result and letting Drop handle the cleanup? (probably, again, because we don't have async Drop!)</p>",
        "id": 245715307,
        "sender_full_name": "rpjohnst",
        "timestamp": 1626109034
    },
    {
        "content": "<p>or to flip things around in the other direction- we have .await markers so it's (apparently) feasible to reason about future cancellation. why not add panic-point markers so it becomes feasible to reason about panic cancellation?</p>",
        "id": 245715784,
        "sender_full_name": "rpjohnst",
        "timestamp": 1626109243
    },
    {
        "content": "<blockquote>\n<p>why not add panic-point markers so it becomes feasible to reason about panic cancellation?</p>\n</blockquote>\n<p>Because you write code assuming panics don't happen. I believe that all expected code paths (that is: continuation and cancellation) should be marked with a symbol (<code>.await</code>), where all unexpected code paths (panic) shouldn't be.</p>\n<p>Supporting cancellation by default is a good thing, because it makes it much easier to write async code. One of the most common questions I see about sync code is \"how do I cancel a thread\", and solutions are always complex. But with async and explicit <code>.await</code>, we get the best of both worlds: Easy task cancellation without it being a footgun (since cancellation points are obvious).</p>\n<p>Note that with Dario's async model, it is possible to write a combinator <code>.must_complete()</code> which would enforce that a certain future is never cancelled, so it is entirely possible to achieve the same semantics as proposed by this one. I suspect this combinator will be very useful.</p>",
        "id": 245739639,
        "sender_full_name": "Kestrer",
        "timestamp": 1626119901
    },
    {
        "content": "<p>Note that with completion async fn cancellation points are the regular return values of function calls, and you can detect them also be looking at whether a function returns <code>Result&lt;T, AnErrorEnumerationWhichIncludesAPotentialCancellationError&gt;</code></p>",
        "id": 245743336,
        "sender_full_name": "Matthias247",
        "timestamp": 1626121571
    },
    {
        "content": "<p>I don't really like that, because it forces all operations to be fallible. Something like <code>sleep</code> having to return a <code>Result</code> would just be a pain. <code>?</code> exists but you'd have to add a Cancelled variant to all your error enums and that's really not ideal. I think combining implicit cancellation with <code>AsyncDrop</code> for async cleanup is a slightly nicer solution.</p>",
        "id": 245749110,
        "sender_full_name": "Kestrer",
        "timestamp": 1626123859
    },
    {
        "content": "<p>It totally makes sense for <code>sleep</code> to return an error on cancellation, because it didn't sleep as long as you wanted.</p>",
        "id": 245752644,
        "sender_full_name": "Matthias247",
        "timestamp": 1626125328
    },
    {
        "content": "<p>Cancellation, in the <code>sleep</code> scenario, sounds more like someone mutated a value (the sleep future) you owned; if there's something to allow such mutation, shouldn't the <code>Output</code> of that future include whether or not someone else touched it? I feel like cancellation isn't a \"failure\" circumstance <em>except</em> if it means \"cancelled out from under you, in an operation you expected not to fail\".</p>\n<p>Cancellation by the owner is the only way that should ever occur, otherwise- and if something causes a failure to perform a sleep successfully because of a dependency not pulling through, wouldn't that explicitly be something other than a cancellation?</p>",
        "id": 245754734,
        "sender_full_name": "Zoey",
        "timestamp": 1626126518
    },
    {
        "content": "<p>Functions that would otherwise be infallible returning cancellation errors would result in <code>.unwrap()</code>s being necessary in contexts where you don't expect it to be cancelled, for example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">future</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">duration</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">do_work</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">other_duration</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">other_thing</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">.</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">.</span><span class=\"n\">must_complete</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 245781240,
        "sender_full_name": "Kestrer",
        "timestamp": 1626154516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"360486\">Kestrer</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245739639\">said</a>:</p>\n<blockquote>\n<p>Supporting cancellation by default is a good thing, because it makes it much easier to write async code.</p>\n</blockquote>\n<p>But this is not borne out in practice, that's the whole point. \"Oops this got cancelled and broke something\" is one of the main footguns this wg is looking at, no? In fact, in this thread Dario made the argument that .await is necessary <em>because</em> cancellation is available by default, but at the same time cancellation keeps catching people by surprise anyway. So arguably, \".await helps reason about control flow\" is not really helpful on its own- it only makes sense in the context of this particular kind of (error-prone) cancellation!</p>\n<p>I'm not trying to \"take a side\" on explicit vs implicit cancel/panic points here- I'm trying to point out that the differences between the two are perhaps more accidental than fundamental or intentional, and in particular the current division between them is not the only possible or reasonable one. For example if cancellation were less error-prone somehow (e.g. async Drop, to match the sync approach to cleanup), then would explicit .await really be such an important tool anymore? Importantly, the goal is not to remove .await per se, but to improve cancellation.</p>",
        "id": 245854585,
        "sender_full_name": "rpjohnst",
        "timestamp": 1626195538
    },
    {
        "content": "<blockquote>\n<p>But this is not borne out in practice, that's the whole point.</p>\n</blockquote>\n<p>The example I have seen of cancellation being a footgun used <code>select!</code> in a loop, and I would consider that to be the real footgun here. That pattern should be eliminated, and replaced with the much more obvious and less footgunny approach of simply <code>select</code>ing two futures, where each future contains its own loop. Cancellation itself is not a problem; if made explicit by <code>select</code>ing two futures once or calling <code>.abort()</code>, there is no surprise that a future will stop in the middle of executing. So I wouldn't describe this method of cancellation as error-prone; just one common usage of it.</p>\n<p>I'm not really sure on how async drop would affect the error-proneness of implicit cancellation points, but Dario's above arguments would still apply.</p>",
        "id": 245864711,
        "sender_full_name": "Kestrer",
        "timestamp": 1626199774
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Dropping.20.60.2Eawait.60-.20what.20else.20could.20or.20would.20change/near/245622921\">said</a>:</p>\n<blockquote>\n<p>IMO it helps to consider the critical aspects of async to be purely on the \"generated code\" side- sync code uses large dynamically allocated stacks with an ambient cross-language preemptive kernel scheduler; async code uses small (mostly-)fixed-size stacks with a language-integrated cooperative user-space scheduler. Everything else flows from this, or else it is probably equally important to solve in sync code!</p>\n</blockquote>\n<p>I agree with this, <span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> </p>\n<blockquote>\n<p>So back to the start of this message- if your problem with autoawait is that it makes it harder to pick out the full set of control flow paths... then why is this not also a problem with sync code which can also panic (the sync version of cancellation) at any function call? Either sync code makes that potential explosion fine somehow (e.g. Drop can block, thus async Drop would provide identical benefits to autoawait) or else the sync code has the same problem (and thus we should approach the problem more generally rather than doubling down on the status quo for async only).</p>\n</blockquote>\n<p>Initially I was making this same argument -- but the main difference here, imo, is <code>select</code>. This is why I wrote the story <a href=\"https://rust-lang.github.io/wg-async-foundations/vision/status_quo/barbara_gets_burned_by_select.html\">Barbara gets burned by select</a>. In short, cancellation is (idiomatically) used far more often than <code>panic!</code>, and for quite different purposes. I suspect if used <code>panic!</code> for all those things, we would indeed see the same sorts of bugs in sync code -- and this is precisely <strong>why</strong> we chose to encode \"recoverable\" errors using <code>Result</code> and not <code>panic!</code></p>",
        "id": 245879407,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626206583
    },
    {
        "content": "<p>Just to make sure: the plan is not to remove cancel-by-drop completely, but to add a new way to optionally make futures not-cancelable right? I think it has to be, because making <code>async fn</code> noncancelable would be a breaking change.</p>\n<p>In this case then my argument of keeping <code>.await</code> to make cancel points visible still stands. I <em>want</em> to make my futures cancelable, and I want to ensure correct behavior at all cancelation points. </p>\n<p>\"It's OK to make awaits invisible because all futures will be noncancelable\" is not right...</p>",
        "id": 245910266,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1626226823
    },
    {
        "content": "<p>I don't think there is any fixed plan yet. There are a couple of ideas, proposals, motivations, goals, interests and concerns. That all still needs to get towards a plan.</p>\n<p>And I think one part of the plan would also need to be how to cover backward compatibility and provide a smooth part forward - I certainly also don't believe switching out everything that is available now in one go for something else is the right path to take.</p>\n<p>Anyway, I feel like this discussion here diverged a bit from from the initial \"assuming we would do away with <code>.await</code>, what other side effects would it have\" towards some discussions around other topics like cancellation. Might be good to keep them separate?</p>\n<p>I want to talk/write in the near future a bit more about cancellation, including also a bit of background on \"what has proven to work for most use-cases\" and how a common [graceful] cancellation strategy for both synchronous as well as async Rust code can look like.<br>\nBut other responsibilities are keeping me busy, so it will likely not be this week.</p>",
        "id": 245911038,
        "sender_full_name": "Matthias247",
        "timestamp": 1626227794
    },
    {
        "content": "<p>This is just a tiny bit of anecdotal introspection on my part, but sometimes I like the <code>await</code> suffix.   I find it useful as a flag of sorts, that visually indicates that some \"heavy lifting\" is happening.   It's true that I sometimes forget to include it, and the compiler yells at me, but I've never been tripped up  by a missing <code>.await</code>.  (It's much more common for me to omit a <code>?</code> operator and gets a fully typed-checked program that is <a href=\"https://gist.github.com/eminence/4fc0387dc96f3e93edf1c681bc44571d\">semantically incorrect</a>)</p>",
        "id": 245915586,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1626233536
    },
    {
        "content": "<p>Does anyone have any examples of languages that do implicit await without magic? The \"magic\" variants (greenlet, fibers, etc) all lead to a lot of \"this function might yield, so don't touch anything you care about because it's probably going to break\" pseudo-documentation that are explicitly visible to code reviewers if an await keyword is there.</p>\n<p>Even Haskell - the language I'd most expect to have done this with its sometimes-excessive use of clever tricks that approach magic, and the fact that almost everything is asynchronous or lazy in some form - uses explicit awaits for effects that cross a thread or task boundary, and often requires you to describe them monadically to further avoid potential ambiguity. Scala, similarly, has a penchant for brevity above all else, and keeps an explicit await despite the PML pattern allowing N-layer implicit casting which could easily invoke an await-like call on Futures.</p>\n<p>In other words- is there a reason that other languages that have the option to avoid an explicit <code>await</code> choose not to do so? If it's for type safety, why are languages with even stronger type systems than Rust's hesitant to do so?</p>",
        "id": 245916143,
        "sender_full_name": "Zoey",
        "timestamp": 1626234357
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"398288\">@Zoey</span> Kotlin is the prime example, I believe.</p>",
        "id": 245968646,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626273404
    },
    {
        "content": "<p>And of course Go</p>",
        "id": 245968668,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626273416
    },
    {
        "content": "<p>And pthreads :)</p>",
        "id": 245968679,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1626273421
    },
    {
        "content": "<p>I have been following only loosely and not sure if I should contribute, but I feel that cpp and python developers would find that rust having a semantically similar model for asynchronous programming, but not using an await keyword very curious. For better or worse, most popular Future/Promise/Coroutine based use an explicit await keyword. Whether or not thats because the design of the language required it to do things in a backwards compat way (i suspect that this is at least tangentially true for python and cpp) is besides the point on what people are used to.<br>\nI don't really know anything about js, but they might feel the same.</p>\n<p>My own personal opinion is that easily reasoning about the exact locations of yield points, even when async-vision is done and most footguns and perf gotchas are systematically dealt with, is still going to be something people do or want to be able to do, but I have been wrong in the past (like about postfix await haha)</p>",
        "id": 245970644,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1626274353
    },
    {
        "content": "<p>From a pull-request reviewer's standpoint, knowing the yield points is only going to get more important as we add concepts like async generators, and not knowing them now is a great way to end up in <code>I don't know what my code is doing without having an IDE to guide me</code> land.</p>",
        "id": 246028791,
        "sender_full_name": "Zoey",
        "timestamp": 1626300800
    },
    {
        "content": "<p>Can we put together a list of all the things that explicit <code>await</code> points buy you? I have...</p>\n<ul>\n<li>More transparent performance characteristics</li>\n<li>Much easier to review for cancellation correctness (for implicitly cancellable futures)</li>\n<li>Easier to understand \"value behind held across an await point\" errors</li>\n<li>Visibility for severe performance/logic errors like accidentally holding a mutex across an await point, or other \"out-of-band synchronization\" primitives that interact with concurrency</li>\n</ul>",
        "id": 246040867,
        "sender_full_name": "tmandry",
        "timestamp": 1626311102
    },
    {
        "content": "<p>Similarly, is there anything we gain by dropping it, to justify the costs to compilation and intuition complexity? Or is it just because Go?</p>",
        "id": 246040958,
        "sender_full_name": "Zoey",
        "timestamp": 1626311205
    },
    {
        "content": "<p>I think that gets covered fairly well in <a href=\"https://hackmd.io/uAI0q9ZiSwyUkmGQQkyXXg?view#await-syntax\">niko's doc</a></p>",
        "id": 246041059,
        "sender_full_name": "tmandry",
        "timestamp": 1626311368
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> Easier to pass around a future without accidentally awaiting it, which means easier use of future combinators and similar.</p>",
        "id": 246041060,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1626311369
    },
    {
        "content": "<blockquote>\n<p>More transparent performance characteristics</p>\n</blockquote>\n<p>Why is that? I can see some reasoning around \"we are sure it will not block the runtime/thread, because it has an <code>.await</code> behind it\". Anything else?</p>",
        "id": 246045404,
        "sender_full_name": "Matthias247",
        "timestamp": 1626316244
    },
    {
        "content": "<blockquote>\n<p>@tmandry Easier to pass around a future without accidentally awaiting it, which means easier use of future combinators and similar.</p>\n</blockquote>\n<p>And easier to create a stack overflow ;) <br>\nJust kidding. I feel like this is in line with <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> 's comment of</p>\n<blockquote>\n<p>Much easier to review for cancellation correctness (for implicitly cancellable futures)</p>\n</blockquote>\n<p>which applies more to implicitly cancellable futures? I can't think of too many reasons why you want to move the other version around too much - in my use of Go or Kotlin code I didn't feel like the need to have raw access to the tasks stack or whatever is equivalent to a <code>Future</code> there.</p>",
        "id": 246045581,
        "sender_full_name": "Matthias247",
        "timestamp": 1626316460
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/meeting.202021-07-09/near/245474032\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"204219\">Matthias247</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/meeting.202021-07-09/near/245473817\">said</a>:</p>\n<blockquote>\n<p>Would be great if one could write <code>async fn myfunc(callback: impl AsyncFnOnce)</code> and get exactly the same semantics as with synchronous functions. It isn't really that easy with passing the current version of <code>Future</code> due to lifetime differences.</p>\n</blockquote>\n<p>I don't quite understand what you mean by this, can you elaborate a bit?</p>\n</blockquote>\n<p>Moving the answer over into this thread, since I think it fits better. <br>\nLet's look into this gist, which makes use callback functions in the same way in both the sync as well as async world: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e46acb168f3d07ce73b09dfbfce8425a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=e46acb168f3d07ce73b09dfbfce8425a</a></p>\n<p>While the synchronous version is straightforward, the async one compiles with a hard-to-understand lifetime issue, where also the fix is non-obvious. I run into those kind of things in various places in the async world, and usually end up with either restructuring or boxing everything.</p>\n<p>I was wondering if implicit await could allow to get the async experience closer to the synchronous one - exactly because people can't move futures around manually anymore and there might be more guarantees on when the produced future might be used. </p>\n<p>Obviously I'm totally not sure about it, and I guess it would only be if there is additional requirements on the <code>unsafe</code> poll method.</p>\n<p>But getting these things to work easier would be a much stronger motivator for me to drop <code>.await</code> than the pure syntactic motivations.</p>",
        "id": 246049822,
        "sender_full_name": "Matthias247",
        "timestamp": 1626321809
    },
    {
        "content": "<p>Implicit await wouldn't help at all in the playground you linked. The problem there is the lack of higher kinded types, which could be implemented both with or without implicit await. Even giving the guarantee that the future is immediately awaited wouldn't help much I don't think, we just need to have the compiler support async closures and then it will all be fine.</p>",
        "id": 246061213,
        "sender_full_name": "Kestrer",
        "timestamp": 1626334837
    },
    {
        "content": "<p>Iâ€™m sure this sentiment has been repeated been time and time again, in much more detail than this, but my opinion is to keep the keyword, as it is (imo) the perfect trade-off between explicitness and DRY, here</p>\n<p>Knowing where a yield point is, and what exactly is being yielded into what where, is very important if you want to explicitly control your asynchronous control flow in such a function, I can imagine much frustration when <em>not</em> being in control of this, when a call simply yields right then and there, while there much value in passing around the actual future that should be awaited, I.e. to pass into FuturesUnordered, or to mess around with it, reordering when and where yielding occurs, to satisfy the borrow checker</p>",
        "id": 248540023,
        "sender_full_name": "Jonathan de Jong",
        "timestamp": 1628199188
    },
    {
        "content": "<p>In short, Iâ€™d rather know when my program is yielding, than having to guess and â€œtamperâ€ to get it to do what I want</p>",
        "id": 248540355,
        "sender_full_name": "Jonathan de Jong",
        "timestamp": 1628199374
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"300259\">@Jonathan de Jong</span> What about <code>AsyncDrop</code>? Take this code, for example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">stream</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TlsStream</span>::<span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">stream</span><span class=\"p\">.</span><span class=\"n\">write_all</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// stream is replaced, the old stream is dropped, a yield point is inserted</span>\n<span class=\"w\">    </span><span class=\"n\">stream</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TlsStream</span>::<span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">another_addr</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">stream</span><span class=\"p\">.</span><span class=\"n\">write_all</span><span class=\"p\">(</span><span class=\"n\">more_data</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// another stream is created then dropped, and a yield point is inserted</span>\n<span class=\"w\">    </span><span class=\"n\">TlsStream</span>::<span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">third_addr</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">.</span><span class=\"n\">write_all</span><span class=\"p\">(</span><span class=\"n\">even_more_data</span><span class=\"p\">).</span><span class=\"k\">await</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n\n<span class=\"w\">    </span><span class=\"c1\">// stream is implicitly dropped, a yield point is inserted</span>\n<span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The above code has three yield points where there was no explicit await. To be honest I'm not really sure what to do here, but I'm leaning towards having those yield points not also be cancellation points.</p>",
        "id": 248575120,
        "sender_full_name": "Kestrer",
        "timestamp": 1628230407
    }
]