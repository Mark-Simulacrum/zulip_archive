[
    {
        "content": "<p><a href=\"https://blog.yoshuawuyts.com/futures-concurrency-3/\">https://blog.yoshuawuyts.com/futures-concurrency-3/</a></p>\n<p>Hey all, I've published the third installment in my \"async concurrency\" series of blog posts, this time on the _\"process concurrently, yield sequentially\"_ (for lack of a better name) mode of concurrency. I cover how the <code>select!</code> macro implements this mode of concurrency, cover the issues specific to the <code>select!</code>, and show an alternative non-macro API which enables this mode of concurrency to be used.</p>\n<p>It's a rather long read, and is closer to \"reference guide\" than \"tutorial\". But I hope it'll be helpful in informing the design of the APIs we provide via the language and library.</p>",
        "id": 271320790,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644429538
    },
    {
        "content": "<p>Awesome blog post, really really nice! I'm way more pleased with this nicer API + enum approach than with the current \"use channels and/or spawn tasks\" <em>status quo</em>. Observing that concurrency over <code>Future</code>s is a form of <code>Stream</code>, in and of itself, really hit the nail on the head <span aria-label=\"ok\" class=\"emoji emoji-1f44c\" role=\"img\" title=\"ok\">:ok:</span></p>",
        "id": 271750595,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644765372
    },
    {
        "content": "<p>(aside: I liked the shiny future imaginings, at least the first batch; I wasn't, however, fond at all of the anonymous <code>enum</code> idea: dispatching based on type rather than on stream / explicit message kind did seem to make the code more messy / less structured. On that end, maybe an existential enum but with explicitly named variants could be an acceptable in between).</p>",
        "id": 271750941,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644765895
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> thanks for the kind words! -- I'm not sure I fully understand what you mean by \"existential enum with explicitly named variants\" - could you share a sketch of what you think that might look like?</p>",
        "id": 271809827,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644835607
    },
    {
        "content": "<p>Ah yeah, just something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">Message</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// or</span>\n<span class=\"k\">type</span> <span class=\"nc\">Message</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Enum</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n\n<span class=\"c1\">// Create our streams and map them to the shared output type.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">].</span><span class=\"n\">into_async_iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Message</span>::<span class=\"n\">Num</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"s\">\"chashu\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"nori\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"lily\"</span><span class=\"p\">].</span><span class=\"n\">into_async_iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Message</span>::<span class=\"n\">Text</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async_iter</span>::<span class=\"n\">once</span><span class=\"p\">(</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"s\">\"hello\"</span><span class=\"w\"> </span><span class=\"p\">}).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">Message</span>::<span class=\"n\">Text</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Merge the streams, iterate over them, and handle the output sequentially.</span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">).</span><span class=\"n\">merge</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Num</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"received a number: {n}\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Text</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"received a string: {s}\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>as in: let's still have a named <code>Enum</code> with named variants, but just let the variants be inferred from the usage in that scope. Basically offering the reduction:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\">// The shared output type</span>\n<span class=\"gd\">- enum Message {</span><span class=\"w\"></span>\n<span class=\"gd\">-     Num(u8),</span><span class=\"w\"></span>\n<span class=\"gd\">-     Text(&amp;'static str),</span><span class=\"w\"></span>\n<span class=\"gd\">- }</span><span class=\"w\"></span>\n<span class=\"gi\">+ enum Message { .. }</span><span class=\"w\"></span>\n<span class=\"w\">// or</span>\n<span class=\"gi\">+ type Message = impl Enum;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271824204,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644844627
    },
    {
        "content": "<p>Another option, if we really wanted to merge streams and have a way to automagically combine them, would be:</p>\n<div class=\"codehilite\" data-code-language=\"Diff\"><pre><span></span><code><span class=\"w\"> </span> let a = [1, 2, 3];<span class=\"w\"></span>\n<span class=\"w\"> </span> let b = [\"chashu\", \"nori\", \"lily\"];<span class=\"w\"></span>\n<span class=\"w\"> </span> let c = async { \"hello\" };<span class=\"w\"></span>\n\n<span class=\"w\"> </span> for await msg in (a, b, c).merge() match {<span class=\"w\"></span>\n<span class=\"gd\">-     n: u8 =&gt; println!(\"received a number: {n}\"),</span><span class=\"w\"></span>\n<span class=\"gd\">-     s: &amp;str =&gt; println!(\"received a string: {s}\"),</span><span class=\"w\"></span>\n<span class=\"gi\">+     (n, !, !) =&gt; println!(\"received a number: {n}\"),</span><span class=\"w\"></span>\n<span class=\"gi\">+     (!, s, !) | (!, !, s) =&gt; println!(\"received a string: {s}\"),</span><span class=\"w\"></span>\n<span class=\"w\"> </span> }<span class=\"w\"></span>\n</code></pre></div>\n<p>Since the main objective, as I see it, is to keep knowledge of whose stream the current element belongs to.</p>",
        "id": 271824209,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644844629
    },
    {
        "content": "<p>But I still lean towards the \"auto-filled enum definition\" approach: being able to label the variants with names seems nicer, even if a bit more cumbersome</p>",
        "id": 271824262,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644844659
    },
    {
        "content": "<p>I seeee, thanks for elaborating!</p>",
        "id": 271848891,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644855138
    },
    {
        "content": "<p>In practice I would just stick to the good old <code>enum</code>, since it could even be combined with a \"helper autoenum\"</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// A helper defined once.</span>\n<span class=\"k\">enum</span> <span class=\"nc\">AutoEnum</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">D</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">!&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"err\">…</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>yielding:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">AutoEnum</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">type</span> <span class=\"nc\">Message</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">AutoEnum</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"c1\">//          ^^^^^^ 2 variants</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">].</span><span class=\"n\">into_async_iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"s\">\"chashu\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"nori\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"lily\"</span><span class=\"p\">].</span><span class=\"n\">into_async_iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async_iter</span>::<span class=\"n\">once</span><span class=\"p\">(</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"s\">\"hello\"</span><span class=\"w\"> </span><span class=\"p\">}).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">).</span><span class=\"n\">merge</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"received a number: {n}\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"received a string: {s}\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or even:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">AutoEnum</span>::<span class=\"o\">*</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">].</span><span class=\"n\">into_async_iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">A</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">                                        </span><span class=\"c1\">// ^^^^^^ 2 variants</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"s\">\"chashu\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"nori\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"s\">\"lily\"</span><span class=\"p\">].</span><span class=\"n\">into_async_iter</span><span class=\"p\">().</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">async_iter</span>::<span class=\"n\">once</span><span class=\"p\">(</span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"s\">\"hello\"</span><span class=\"w\"> </span><span class=\"p\">}).</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"n\">msg</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">).</span><span class=\"n\">merge</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"received a number: {n}\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"received a string: {s}\"</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271849944,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644855571
    },
    {
        "content": "<p>I guess I'm still somewhat gravitating towards having the ability to declare \"anonymous enums\", much the way tuples allow us to declare \"anonymous structs\". That would allow us to have more parity between enums and structs too:</p>\n<p><strong>Structs</strong></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// named type</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">MyStruct</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// anonymous type</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"c1\">// type erased type</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p><strong>Enums</strong></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// named type</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">MyEnum</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// anonymous type (currently unsupported)</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"o\">|</span><span class=\"w\"> </span><span class=\"kt\">u16</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"c1\">// type erased type (currently unsupported)</span>\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Debug</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271850792,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644855913
    },
    {
        "content": "<p><code>impl Trait</code> in return position currently only works when a function returns a single type. Typically you have to use <code>dyn Trait</code> if you want to choose between N values, but that requires dynamic dispatch which is not always desireable.</p>\n<p>However you can work around this restriction by creating an inline enum, and then type-erasing that. That's how the <a href=\"https://docs.rs/auto_enums/latest/auto_enums/index.html\">auto_enums</a> crate enables multi-type <code>impl Trait</code> to work.</p>",
        "id": 271851326,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644856151
    },
    {
        "content": "<p>That feature would be more like union types, and it works slightly different to how I would imagine literal anonymous enums to behave. Particularly, with a union type <code>u8 | u8 | u16</code> ends up being the same type as <code>u8 | u16</code>, whereas with enums <code>enum Foo { A(u8), B(u8), C(u16) }</code> has three distinct variants. I'd imagine anonymous enums to look more like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">enum</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"kt\">u8</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">C</span><span class=\"p\">(</span><span class=\"kt\">u16</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">enum</span>::<span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 271862038,
        "sender_full_name": "Kestrer",
        "timestamp": 1644860758
    },
    {
        "content": "<p>Exactly. The parallel to tuples would be rather something like my <code>AutoEnum</code> suggestion, but wih arbitrary arity, and thus \"numbered\" variants</p>",
        "id": 271895504,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644876011
    },
    {
        "content": "<p><code>u8 | u8 | u16</code> would thus have a a <code>0(u8)</code> variant, a <code>1(u8)</code>, and a <code>2(u16)</code></p>",
        "id": 271895684,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644876084
    },
    {
        "content": "<p>I like the concept of having easy ways to define enums, but not as much the idea of them being anonymous.</p>",
        "id": 271915415,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644889203
    },
    {
        "content": "<p>Ended up writing another blog post about this yesterday + this morning: <a href=\"https://blog.yoshuawuyts.com/more-enum-types/\">https://blog.yoshuawuyts.com/more-enum-types/</a> -- brief one though</p>",
        "id": 271949534,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644918688
    },
    {
        "content": "<p>This is the summary table from the post:<br>\n<a href=\"/user_uploads/4715/HPksHK2WRiX7bp02lVsksadU/More-Enum-Types.png\">More-Enum-Types.png</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/HPksHK2WRiX7bp02lVsksadU/More-Enum-Types.png\" title=\"More-Enum-Types.png\"><img src=\"/user_uploads/4715/HPksHK2WRiX7bp02lVsksadU/More-Enum-Types.png\"></a></div>",
        "id": 271949967,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644918898
    },
    {
        "content": "<p>Just from looking at that table, the last lone is a bit confusing, since one can abstract an enum with impl Trait in the exact same way as a struct</p>",
        "id": 271957620,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644923024
    },
    {
        "content": "<p>I should read the blog post of course, you are probably thinking something  a bit different than the table implies to me</p>",
        "id": 271957705,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644923060
    },
    {
        "content": "<p>also the struct column looks like tuples rather than structs?</p>",
        "id": 271957751,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644923093
    },
    {
        "content": "<p>OK, I've read the post and your names make more sense, although I think if you want the table to be a tl;dr the names are confusing :-)</p>",
        "id": 271958639,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644923560
    },
    {
        "content": "<p>Anyway, I think it is worth considering named vs anon on the axes of both type names and field names - since we are also missing structs with named fields but not named types, and you are proposing anon enum types with anon fields, but not enums with anon types and named fields</p>",
        "id": 271958837,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644923652
    },
    {
        "content": "<p>I think its an interesting discussion in general. I feel like we've evolved Rust's abstract data types <em>a lot</em> over the years: associated types were only just pre-1.0, impl Trait in various places, trait aliases, specialization, GATs, etc., but Rust's concrete types haven't changed at all since way before 1.0 (other than adding unions I guess, but they are pretty niche). I think it is worth thinking about if we made the right decisions or whether we should fill the gaps in the struct/tuple/enum space, add enum variant types (or even refinement types over enum variants)</p>",
        "id": 271959716,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644924162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/Blog.20post.3A.20Futures.20Concurrency.20III/near/271958837\">said</a>:</p>\n<blockquote>\n<p>Anyway, I think it is worth considering named vs anon on the axes of both type names and field names - since we are also missing structs with named fields but not named types, and you are proposing anon enum types with anon fields, but not enums with anon types and named fields</p>\n</blockquote>\n<p>interesting, I had not considered the \"struct with named fields but not named types\", and \"enums with anonymous types and named fields\". Do you have a sense for when those would be useful?</p>",
        "id": 271967242,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644928630
    },
    {
        "content": "<p>Another idea I've been working on, speaking of fundamental container types in Rust, is the ability to express <code>bitfield</code> types in Rust. The way I view it <code>bitfield</code> is a combination of the following features:</p>\n<ul>\n<li>be able to define memory layout</li>\n<li>expose Set-like membership methods such as <code>intersection</code> and <code>is_{sub,super}set</code>, etc.</li>\n<li>implement support for operators such as <code>+</code> <code>|</code> <code>-</code> to operate on sets</li>\n</ul>\n<p>The operators bit is already handled through <code>std::ops</code>. The ability to define precise memory layout is something which we know we want for other reasons too, so it's likely that will be its own feature. Which leaves set-like membership methods. And I have a design through which we could expose those by implementing a trait + derive macro. Though I still need to prototype it; spent maybe 10 mins on it last week and didn't get it done in that time.</p>",
        "id": 271967855,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644928959
    },
    {
        "content": "<p>I think that's the other fundamental data container type we're missing.</p>",
        "id": 271967904,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644928987
    },
    {
        "content": "<p>They are both the same category, and I think they are objectively less useful than the existing data types. I think they are useful for making field access more self-documenting without the overhead of a decl, e.g., you want a function that takes (i64, i64, i64) but calling p.x or p.y is more informative than p.0, p.1 (and you don't want to declare a Point struct). They're also perhaps useful (if we had default field values) for emulating named or default arguments.</p>",
        "id": 271968121,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644929077
    },
    {
        "content": "<p>Ohh, interesting. If I understand you correctly, this could potentially allow for something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rgb</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">r</span>: <span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">g</span>: <span class=\"kt\">i64</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">i64</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">get_rgb</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"red channel = {}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">rgb</span><span class=\"p\">.</span><span class=\"n\">r</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is that right?</p>",
        "id": 271968692,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644929399
    },
    {
        "content": "<p>Right, exactly</p>",
        "id": 271973590,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644931973
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/Blog.20post.3A.20Futures.20Concurrency.20III/near/271967242\">said</a>:</p>\n<blockquote>\n<p>interesting, I had not considered the \"struct with named fields but not named types\", and \"enums with anonymous types and named fields\". Do you have a sense for when those would be useful?</p>\n</blockquote>\n<p>(still catching up on this thread but...) I found myself wanting \"struct with named fields by not named types\" recently. Basically, I wanted a one-off struct to return two things from a function, something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">do_thing</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">part1</span>: <span class=\"nc\">Foo</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">part2</span>: <span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"cm\">/* function body */</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>I could have used a tuple, but I like the built in documentation you get from having to name the fields. I think I ended up making a top-level struct for this, but it seemed like overkill given that the only purpose of the struct was to be returned from that function.</p>",
        "id": 272015123,
        "sender_full_name": "eholk",
        "timestamp": 1644948748
    },
    {
        "content": "<p>This is a relevant RFC for anonymous structs or \"structural records\": <a href=\"https://github.com/rust-lang/rfcs/pull/2584\">https://github.com/rust-lang/rfcs/pull/2584</a><br>\nI miss them mostly for one off return values, with named data (instead of using tuples) and could be useful for nested structs</p>",
        "id": 272015467,
        "sender_full_name": "pachi",
        "timestamp": 1644948898
    },
    {
        "content": "<p>That RFC is one of  @Centril's wonderful design documents</p>",
        "id": 272015698,
        "sender_full_name": "pachi",
        "timestamp": 1644949008
    },
    {
        "content": "<p>It was closed in 2021 due to other features having higher priority</p>",
        "id": 272015905,
        "sender_full_name": "pachi",
        "timestamp": 1644949088
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> you haven't addressed the \"squashing\" <em>vs.</em> \"no-squashing\" in auto-enums, which to me seems like an important aspect. The <code>auto_enums</code> example, for instance, is about providing ad-hoc <code>enum</code>s to easily get an <code>impl Trait</code>, as you mentioned, so that type unification is the only objective. In a way, <strong>it's actually closer to <code>dyn Trait</code> than to anonymous <code>enum</code></strong>, in that the enum discriminant is only used to know the type of the variant, it's kind of like a mini-embedded <code>TypeId</code>.</p>\n<ul>\n<li><code>fn foo() -&gt; dyn(enum) Debug</code></li>\n</ul>\n<p>So, if doing:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">42_</span><span class=\"k\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">27_</span><span class=\"k\">u16</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">C</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"mi\">42_</span><span class=\"k\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>is auto-enum-unified, we won't be able to distinguish <code>A</code> from <code>C</code> (which, back to your original post, seems quite important: when merging <code>stream</code>s to replace <code>select!</code>, to get feature parity we need to be able to know from which stream each value came).</p>\n<hr>\n<p>In the same fashion that tuple structs still provide positional field names to access each element, <code>.0, </code>.1<code>, …, an anonymous </code>enum<code> would be providing the </code>0(…)<code>, </code>1(…)`, wrappings. <strong>This is where the parallel lies</strong>.</p>\n<p>Your anonymous enum idea would, in the product-type universe, become a \"set struct idea\", where each field name would have to be different, and the indexing would occur thanks to that:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Person</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">String</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"mi\">42</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">String</span>::<span class=\"n\">from</span><span class=\"p\">(</span><span class=\"s\">\"…\"</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">age</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"nb\">String</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<hr>\n<p>In both cases (your anonymous enums, or my \"set struct\"s), it's true that helper wrappers could be helpful to get back the labelling:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">A</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">B</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">C</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Person</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"nb\">String</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Person</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"s\">\"…\"</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">age</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">A</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">name</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">B</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and so, with your enums:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">foo_stream</span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"n\">bar_stream</span><span class=\"p\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">await</span><span class=\"w\"> </span><span class=\"n\">elem</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">foo_stream</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">bar_stream</span><span class=\"p\">).</span><span class=\"n\">merge</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"n\">bar</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"err\">…</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 272017489,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644949772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> I guess what I was trying to do with my post was less propose we do something concrete, and more show that: \"hey, there seem to be some core enum variants missing. Isn't that quaint?\" — I think what you're sharing is interesting to read, and I appreciate the feedback. But it also seems worded pretty strongly, and I want to make sure you don't have the wrong idea of what the intent of my post was?</p>",
        "id": 272020266,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644951018
    },
    {
        "content": "<p>The reason why I didn't include it is because the practical differences didn't seem too big to me, so I just went with the example which felt most natural to me. I may of course have been wrong, and the differences might actually be meaningful. But discerning which design of anonymous enums is the right one was not the goal of the post.</p>",
        "id": 272020666,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644951213
    },
    {
        "content": "<p>I hope that makes sense?</p>",
        "id": 272020676,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644951219
    },
    {
        "content": "<p>Sorry for the strong wording; you started with the \"here is the dual to structs\" claim, and the way I see it that's incorrect, because of the labelling difference, and that kind of triggered me, especially because I'd see that feature as actually harmful for the stream/merge proposal, which I just found so aesthetically pleasant. So I just wanted to post my thoughts quickly, and because of that, I worded them poorly / didn't have time to nuance them.<br>\nThe idea of anonymous enums, in general, and <em>if split in two</em> (unlabelled and labelled), is definitely interesting <span aria-label=\"100\" class=\"emoji emoji-1f4af\" role=\"img\" title=\"100\">:100:</span> (and anonymous structs would be, to me, even more handy, so if this also fuels discussion there then all for the better!) <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 272020680,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1644951220
    },
    {
        "content": "<p>That's alright, I appreciate you elaborating!</p>",
        "id": 272020792,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644951259
    },
    {
        "content": "<p>If this idea would ever grow legs, you're entirely right that we <em>should</em> cover all variants and trade-offs in-depth to ensure we go with the right one!</p>",
        "id": 272020859,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644951306
    }
]