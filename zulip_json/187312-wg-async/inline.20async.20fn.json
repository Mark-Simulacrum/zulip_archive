[
    {
        "content": "<p>So <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> I was thinking more about inline async functions and whether they are necessary</p>",
        "id": 249868804,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301230
    },
    {
        "content": "<p>I think maybe if we focus instead on \"dyn async traits\", we solve the problem a better way</p>",
        "id": 249868865,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301262
    },
    {
        "content": "<p>It's worth remembering that -- if <code>AsyncDrop</code> is like <code>Drop</code> -- it is \"very special\" in terms of how it is treated by the language</p>",
        "id": 249868909,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301285
    },
    {
        "content": "<p>The main reason that I was arguing that inline async fn were important for Drop is that we want to be able to use auto traits on types</p>",
        "id": 249868938,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301305
    },
    {
        "content": "<p>but the rules for autotraits for things that implement AsyncDrop can be special</p>",
        "id": 249868962,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301315
    },
    {
        "content": "<p>for example, we might say: </p>\n<ul>\n<li>If <code>T</code> implements <code>AsyncDrop</code>, then <code>T: Send</code> requires <em>also</em> that <code>&lt;T as AsyncDrop&gt;::drop: Send</code> (where that names the future)</li>\n</ul>",
        "id": 249869037,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301338
    },
    {
        "content": "<p>Now, you ask, what about <code>Box&lt;dyn Trait&gt;</code> stuff and auto-traits?</p>",
        "id": 249869064,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301354
    },
    {
        "content": "<p>Well, indeed, that is a very good question</p>",
        "id": 249869081,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301363
    },
    {
        "content": "<p>We can impose  rules about what can be made into a <code>dyn Trait</code>, though</p>",
        "id": 249869149,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301391
    },
    {
        "content": "<p>The most draconian would be \"nothing that implements <code>AsyncDrop</code>\"</p>",
        "id": 249869211,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301414
    },
    {
        "content": "<p>this is, I guess, where your ideas about \"send if Self: Send\" come into play</p>",
        "id": 249869241,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301425
    },
    {
        "content": "<p>er, wait, sorry</p>",
        "id": 249869271,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301440
    },
    {
        "content": "<p>let me back up</p>",
        "id": 249869273,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301442
    },
    {
        "content": "<p>what I realized is: this is basically the <em>same question</em> as any other <code>async fn</code> that goes behind a <code>dyn Trait</code></p>",
        "id": 249869337,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301458
    },
    {
        "content": "<p>in other words, if we are saying that when you have an <code>async fn</code>, the \"dyn version\" of the trait returns some kind of boxed future, the same is true for <code>async fn drop</code></p>",
        "id": 249869387,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/inline.20async.20fn/near/249869037\">said</a>:</p>\n<blockquote>\n<p>for example, we might say: </p>\n<ul>\n<li>If <code>T</code> implements <code>AsyncDrop</code>, then <code>T: Send</code> requires <em>also</em> that <code>&lt;T as AsyncDrop&gt;::drop: Send</code> (where that names the future)</li>\n</ul>\n</blockquote>\n<p>and hence this same rule just applies to that type</p>",
        "id": 249869407,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301493
    },
    {
        "content": "<p>so if that boxed type that gets returned by <code>async fn drop(&amp;mut self)</code> is (e.g.) a <code>Box&lt;dyn Future + Send&gt;</code>, then <code>Foo&lt;T&gt;: Send</code> is true, but if it is <code>Box&lt;dyn Future&gt;</code>, then <code>Foo&lt;T&gt;: Send</code> is false</p>",
        "id": 249869513,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301534
    },
    {
        "content": "<p>importantly, this applies equally well to all auto traits</p>",
        "id": 249869531,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301540
    },
    {
        "content": "<p>so this bottoms out in having control over what kind of type is used to make your async fn \"dyn executable\"</p>",
        "id": 249869593,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301563
    },
    {
        "content": "<p>importantly:</p>",
        "id": 249869685,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301601
    },
    {
        "content": "<p>you were talking about specifying <em>on the trait</em> whether the async fn \"inherit\" send-ness from the self-type</p>",
        "id": 249869717,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629301615
    },
    {
        "content": "<p>because in an \"inherit\" case, I would like to have 2 dyn impls, something like</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">AsyncFnFuture</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">AsyncFnFuture</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 249870562,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629302012
    },
    {
        "content": "<p>^^ yeah and then we need a way to express the existence of the first as a bound I guess, in the non-<code>AsyncDrop</code> case</p>",
        "id": 249882139,
        "sender_full_name": "tmandry",
        "timestamp": 1629306975
    },
    {
        "content": "<p>unless we just apply the same \"auto trait equivalence\" to <em>all</em> async fn futures in traits, which I guess is one option</p>",
        "id": 249882194,
        "sender_full_name": "tmandry",
        "timestamp": 1629307004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/inline.20async.20fn/near/249869717\">said</a>:</p>\n<blockquote>\n<p>you were talking about specifying <em>on the trait</em> whether the async fn \"inherit\" send-ness from the self-type</p>\n</blockquote>\n<p>if it is an <code>AsyncDrop</code> specific thing, I think we can still express the \"inheritance\" of auto traits on the <code>AsyncDrop</code> trait itself and reason about it that way</p>",
        "id": 249882406,
        "sender_full_name": "tmandry",
        "timestamp": 1629307108
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/inline.20async.20fn/near/249870562\">said</a>:</p>\n<blockquote>\n<p>because in an \"inherit\" case, I would like to have 2 dyn impls, something like</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">AsyncFnFuture</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Trait</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">AsyncFnFuture</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Box</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>do non-async traits currently effectively have just this impl:</p>\n<div class=\"codehilite\"><pre><span></span><code>impl Trait for Box&lt;dyn Trait&gt; {\n    fn item(&amp;self) {\n        *self.item()\n   }\n}\n</code></pre></div>\n<p>?</p>",
        "id": 249887072,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1629309188
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/inline.20async.20fn/near/249882194\">said</a>:</p>\n<blockquote>\n<p>unless we just apply the same \"auto trait equivalence\" to <em>all</em> async fn futures in traits, which I guess is one option</p>\n</blockquote>\n<p>I'm not sure what \"auto trait equivalence\" you mean exactly here</p>",
        "id": 249901765,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629315677
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257428\">@Gus Wynn</span> something like that, yes</p>",
        "id": 249901821,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629315707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/inline.20async.20fn/near/249901765\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/inline.20async.20fn/near/249882194\">said</a>:</p>\n<blockquote>\n<p>unless we just apply the same \"auto trait equivalence\" to <em>all</em> async fn futures in traits, which I guess is one option</p>\n</blockquote>\n<p>I'm not sure what \"auto trait equivalence\" you mean exactly here</p>\n</blockquote>\n<p><code>&lt;T as MyTrait&gt;::MyAsyncFnOutput</code> is <code>Send</code> if <code>T</code> is <code>Send</code></p>",
        "id": 249902226,
        "sender_full_name": "tmandry",
        "timestamp": 1629315887
    },
    {
        "content": "<p>we could make this the default for all async fns in traits</p>",
        "id": 249902392,
        "sender_full_name": "tmandry",
        "timestamp": 1629315969
    },
    {
        "content": "<p>I see</p>",
        "id": 249903061,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629316346
    },
    {
        "content": "<p>Yes, that we could do, I'm just not sure if it's the right default</p>",
        "id": 249903079,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629316356
    },
    {
        "content": "<p>I don't know how common it is to want to invoke async fns and then send the result over a new thread</p>",
        "id": 249903098,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629316368
    },
    {
        "content": "<p>It seems...probably fairly uncommon</p>",
        "id": 249903110,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629316374
    },
    {
        "content": "<p>well ok I guess I'm wrong</p>",
        "id": 249903137,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629316386
    },
    {
        "content": "<p>I mean that probably <em>is</em> uncommon, but I was forgetting that futures often want to be <code>Send</code> <em>at each await point</em></p>",
        "id": 249903172,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629316407
    },
    {
        "content": "<p>in which case it's probably super common</p>",
        "id": 249903211,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629316425
    },
    {
        "content": "<p>yeah, I'm not sure if it's right either, but it might be</p>",
        "id": 249910689,
        "sender_full_name": "tmandry",
        "timestamp": 1629320301
    },
    {
        "content": "<p>Just came across <a href=\"https://rust-lang.github.io/async-fundamentals-initiative/evaluation/design/inline_async_fn.html#proposal-inline-futures\">repr(inline_async)</a>, as a way to store the state for futures within the parent struct and avoid boxing. It looks almost too magical. I wonder if <a href=\"https://github.com/rust-lang/rust/issues/63063\">Permit impl Trait in type aliases</a> would be a sufficient alternative, as I think that would allow declaring a variable within a struct to hold a generated future. basically a more explicit way to achieve the same result</p>",
        "id": 269033699,
        "sender_full_name": "Justin Karneges",
        "timestamp": 1642964735
    },
    {
        "content": "<p>In the latest evolution of that idea</p>",
        "id": 269132410,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643042254
    },
    {
        "content": "<p>I have prototype a procedural macro that generates a wrapper</p>",
        "id": 269132442,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643042265
    },
    {
        "content": "<p>perhaps along the lines of what you are suggesting</p>",
        "id": 269132461,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643042273
    },
    {
        "content": "<p>it does rely on TAIT</p>",
        "id": 269132465,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1643042275
    },
    {
        "content": "<p>ah, I like that idea</p>",
        "id": 269485009,
        "sender_full_name": "tmandry",
        "timestamp": 1643232432
    }
]