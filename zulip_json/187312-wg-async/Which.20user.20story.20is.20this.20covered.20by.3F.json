[
    {
        "content": "<p>I've been running into a painful issue in async code lately, and I'm wondering if there's an existing user story that covers it, or if not, if there should be.</p>",
        "id": 260975119,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636542903
    },
    {
        "content": "<p>I'm trying to write an HTTP request handler that reads the body incrementally, and for each entry in the body, does some processing.</p>",
        "id": 260975172,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636542935
    },
    {
        "content": "<p>The incremental processing looks like <code>body.read_exact(&amp;mut buf).await?;</code>, which is a suspend point.</p>",
        "id": 260975247,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636542970
    },
    {
        "content": "<p>But doing the processing requires an object that can't be sent across threads (a <code>git2::Odb</code>).</p>",
        "id": 260975309,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543011
    },
    {
        "content": "<p>I have such an object freshly created for <em>this</em> future to use, and no other future will use it, but it still isn't <code>Send</code> so that makes the future not <code>Send</code>.</p>",
        "id": 260975372,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543063
    },
    {
        "content": "<p>And <code>tide</code> doesn't handle that (transparently or otherwise).</p>",
        "id": 260975386,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543079
    },
    {
        "content": "<p>This feels like a \"Rust frustration\", in that while in general I understand what Rust is protecting me against, and I definitely want that protection, in this case it feels like there could theoretically be a more nuanced set of types that would allow this to work.</p>",
        "id": 260975528,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543164
    },
    {
        "content": "<p>I'm not sure what that would look like, and I'm not sure what the <em>right</em> solution is here, but I'd love to know if there's a good user story for \"frustration caused by non-Send types owned by a future\".</p>",
        "id": 260975574,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543200
    },
    {
        "content": "<p>Right now, my most likely fix to this code is to stop reading the body incrementally, read it all in advance, and then I don't hold non-Send types over a suspend point.</p>",
        "id": 260975658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543227
    },
    {
        "content": "<p>But it seems like there should be a better way.</p>",
        "id": 260975674,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543240
    },
    {
        "content": "<p>If the type in question is not <code>Send</code>, then the two ways are reading it into memory first, and running it on a single-threaded runtime that supports non-Send futures.</p>",
        "id": 260976340,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1636543635
    },
    {
        "content": "<p>In some cases where I do need this kind of thing to work incrementally, I run a background thread that owns the object, and communicate with it via a channel, actor-style.</p>",
        "id": 260976422,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543696
    },
    {
        "content": "<p>But also, thinking in broader terms, I'm wondering if in the ecosystem we need a way of expressing \"you can only use this on one thread at once, but it doesn't have to keep being the <em>same</em> thread\".</p>",
        "id": 260976502,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543768
    },
    {
        "content": "<p>(In other words, the solution-space can include \"<code>git2::Odb</code> should have different properties/traits\".)</p>",
        "id": 260976612,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636543824
    },
    {
        "content": "<p>(For the specific case I encountered, the solution I ended up with was that <code>git2::Repository</code> is <code>Send</code>, but <code>git2::Odb</code> isn't, so I just get the <code>Odb</code> from the <code>Repository</code> each time.)</p>",
        "id": 260980613,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636546436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Which.20user.20story.20is.20this.20covered.20by.3F/near/260976502\">said</a>:</p>\n<blockquote>\n<p>But also, thinking in broader terms, I'm wondering if in the ecosystem we need a way of expressing \"you can only use this on one thread at once, but it doesn't have to keep being the <em>same</em> thread\".</p>\n</blockquote>\n<p>this is a sentiment expressed by... <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> (I think) at some point? Let me see if I can find the zulip thread</p>",
        "id": 261040057,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1636571773
    },
    {
        "content": "<p><a href=\"#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send\">https://rust-lang.zulipchat.com/#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send</a></p>",
        "id": 261040179,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1636571839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Which.20user.20story.20is.20this.20covered.20by.3F/near/260976502\">said</a>:</p>\n<blockquote>\n<p>But also, thinking in broader terms, I'm wondering if in the ecosystem we need a way of expressing \"you can only use this on one thread at once, but it doesn't have to keep being the <em>same</em> thread\".</p>\n</blockquote>\n<p>Does that mean that you can release an <code>Odb</code> within a different thread that whence it was created? If that's the case, and from skimming the API very quickly, it does look like the <code>Odb</code> ought to be <code>Send</code> and remain <code>!Sync</code>. And if the <code>!Sync</code> then still causes problem in your <code>Future</code>, you can soothe Rust by only accessing it through <code>&amp;mut</code>s, and thus wrapping it in a <a href=\"https://docs.rs/sync_wrapper/0.1.1/sync_wrapper/struct.SyncWrapper.html\"><code>SyncWrapper</code></a></p>",
        "id": 261061441,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636581807
    },
    {
        "content": "<p>If, on the other hand, the <code>Odb</code> is tied to a <code>Repo</code>sitory (which is <code>!Sync</code>) and acts as a shared handle to the latter, then, indeed, in Rust, <code>(Repo, Odb&lt;'slf&gt;)</code>, on top of being a self-referential entity, would not be <code>Send</code> even though the two together could be moved across thread boundaries. This just hints at the API potentially missing such a \"bundle\". It does look like there may be a need for an <code>OdbMut</code> unique handle to the <code>Repo</code>, which would thus be <code>Send</code></p>",
        "id": 261063020,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636582558
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> I believe the internal libgit2 odb object is tied to a repo, yes.</p>",
        "id": 261070406,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636586316
    },
    {
        "content": "<p>And in particular, you can always re-obtain the odb from the repo.</p>",
        "id": 261070417,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636586325
    },
    {
        "content": "<p>However, I don't think you can release an odb that's owned by a repo.</p>",
        "id": 261070452,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636586348
    },
    {
        "content": "<p>Oh, but hmmm...</p>",
        "id": 261070676,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636586509
    },
    {
        "content": "<p>It looks like odb actually has internal locking these days, so it might even be <em>sync</em> now.</p>",
        "id": 261070712,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636586522
    },
    {
        "content": "<p><a href=\"https://github.com/libgit2/libgit2/pull/6109\">https://github.com/libgit2/libgit2/pull/6109</a> :)</p>",
        "id": 261071717,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636587177
    },
    {
        "content": "<p>If you are using tide you can always call async_std::spawn_local(.....).await in the handler</p>",
        "id": 261075680,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1636589861
    },
    {
        "content": "<p>So, it seems there's different flavors of <code>spawn</code>s for different kinds of tasks...  <code>spawn</code> for most general ones, <code>spawn_local</code> for ones that cannot leave the thread that build them(!Send),  <code>spawn_blocking</code> for ones that need not be rescheduled (<code>Send</code>), and it seems the original assumption is that maybe a task that is gonna spawn a local(<code>!Send</code>) child  task needs to be spawned, and the child task need to resident on one of the executor worker threads...</p>",
        "id": 261128778,
        "sender_full_name": "Charles Lew",
        "timestamp": 1636634790
    }
]