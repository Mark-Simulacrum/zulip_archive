[
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=d68f48effd9419241e5323bb3cf86148</a></p>",
        "id": 249676640,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173063
    },
    {
        "content": "<p>This example doesn't type check because the two async blocks are !Send, therefore foo is not !Send, which is required by spawn</p>",
        "id": 249676661,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173111
    },
    {
        "content": "<p>One could fix this by using a Mutex or something, but it seems vaguely reasonable to fix this without needing more atomics, etc, by some kind of scoping composability of futures</p>",
        "id": 249676716,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173184
    },
    {
        "content": "<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>",
        "id": 249676791,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173322
    },
    {
        "content": "<p>Is it possible to write something like that today (using async, rather than writing the futures manually)? Or is this on the radar for async work? (It feels a bit similar to the scopes deliverable, but I don't think it quite addresses it)</p>",
        "id": 249676857,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629173420
    },
    {
        "content": "<p>Niko and I were actually talking about this a bit yesterday.. ideally we can separate the original call from the \"polling state\" somehow</p>",
        "id": 249788825,
        "sender_full_name": "tmandry",
        "timestamp": 1629240515
    },
    {
        "content": "<blockquote>\n<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>\n</blockquote>\n<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>",
        "id": 249888026,
        "sender_full_name": "Matthias247",
        "timestamp": 1629309587
    },
    {
        "content": "<p>If you have an executor which provides guarantees of not moving tasks between threads (like a single-threaded one), it can take <code>!Send</code> <code>Future</code>s  and everything is fine. tokio <code>LocalSet</code> also does something like this.</p>",
        "id": 249888304,
        "sender_full_name": "Matthias247",
        "timestamp": 1629309668
    },
    {
        "content": "<p>What I like to see for a while is that once we have structured concurrency you can create a sub-scope which has stronger executor guarantees, like tying everything onto a single thread. And from there on you can do <code>.spawn_local(task)</code> to start non-synchronized tasks</p>",
        "id": 249888536,
        "sender_full_name": "Matthias247",
        "timestamp": 1629309745
    },
    {
        "content": "<p>Although it seems like I might just have gotten half of the question, and the other half is why it requires <code>Sync</code> here and not just <code>Send</code>. I'm not sure on this.</p>",
        "id": 249889605,
        "sender_full_name": "Matthias247",
        "timestamp": 1629310163
    },
    {
        "content": "<p>Right, this has to do with Rust not having a concept of \"not <code>Send</code> unless you move every instance simultaneously\", which applies to both <code>Rc</code> and <code>&amp;T</code> for non-Sync <code>T</code>.</p>",
        "id": 249902481,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1629316053
    },
    {
        "content": "<p>^ that's interesting. to me it feels conceptually similar to self-borrows</p>",
        "id": 249914769,
        "sender_full_name": "tmandry",
        "timestamp": 1629322416
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"204219\">Matthias247</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/249888026\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I.e., one could imagine that a future which owns the Cell and evaluates to join, should be Send, even though the join future is not Send because internal to that future, the sub-futures will be evaluated on the same thread and the reference to the Cell does not exist outside the future</p>\n</blockquote>\n<p>That would need to be a guarantee that is given by the executor. And executors which are multi-threaded don't provide it. They might move the task between each <code>.poll()</code> operation.</p>\n</blockquote>\n<p>You could have an executor which assigns futures to a potentially different thread on spawn, but does not move them between polls. That seems like a common enough use case that's worth considering</p>",
        "id": 249914937,
        "sender_full_name": "tmandry",
        "timestamp": 1629322515
    },
    {
        "content": "<p>You could. But to make use of that you would have to change the spawn signature, since the <code>Future</code> type is the same between having been polled or not being polled yet. Something along: <code>spawn&lt;Func: Send + FnOnce() -&gt; Fut, Fut: Future&gt;(f:  Func)</code>. </p>\n<p>Not sure if you would want that, or just start/enter a sub-scope first which is ok with <code>!Send</code> and from there on spawn the tasks.</p>",
        "id": 249946376,
        "sender_full_name": "Matthias247",
        "timestamp": 1629354367
    },
    {
        "content": "<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>",
        "id": 250241417,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629586362
    },
    {
        "content": "<p>Theoretically we could have an API like this</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">with_unsync_ref</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">S</span>: <span class=\"o\">?</span><span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">AsyncFnOnce</span><span class=\"o\">&lt;</span><span class=\"p\">(</span><span class=\"n\">Ref</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,),</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">O</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Future</span>: <span class=\"nc\">S</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">O</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The HRTB would require that the <code>AsyncFnOnce</code> doesn't use any <code>!Send</code> types inside it other than the <code>Ref</code>, so the future returned by <code>with_unsync_ref</code> would always be <code>Send</code>.</p>",
        "id": 250256755,
        "sender_full_name": "Kestrer",
        "timestamp": 1629610983
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Example.20of.20odd.20composing.20of.20Send/near/250241417\">said</a>:</p>\n<blockquote>\n<p>I get that the executor can move the future between threads between polls and that's why the futures need to be Send, I'm wondering if its possible to deduce somehow that the Join future should be Send even though the 'child' futures are !Send, essentially because its OK to move the 'whole thing' but not 'components of the thing'</p>\n</blockquote>\n<p>In what scenario would that be ok?</p>",
        "id": 250534082,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1629832506
    },
    {
        "content": "<p>When you have a future containing a Cell and a reference to the Cell. You can move the whole thing, but can't separate the owned value &amp; reference because that could cause data races.</p>",
        "id": 250545073,
        "sender_full_name": "Kestrer",
        "timestamp": 1629837458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> see the playground at the start of the thread. I haven't thought about generalisations</p>",
        "id": 250553801,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1629841623
    },
    {
        "content": "<p>Here's a strawman called <a href=\"https://hackmd.io/m5ooA3drSJWjHQYJlJ5KxQ?view\">Shards</a> that I think could work for expressing this in the language. I'm not proposing actually adding this, so do with it what you will (:</p>",
        "id": 251772474,
        "sender_full_name": "tmandry",
        "timestamp": 1630610897
    },
    {
        "content": "<blockquote>\n<ul>\n<li>This is ugly and not worth complicating the language!<ul>\n<li>I tend to agree. It could serve as a starting point for a better idea or a more general “capabilities” mechanism, however.</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>I also tend to agree, but I'm intrigued by the idea of a more general capabilities system. Have you thought any about what that would look like, <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span>?</p>",
        "id": 251780048,
        "sender_full_name": "eholk",
        "timestamp": 1630613954
    },
    {
        "content": "<p>I actually kind of like the idea, I just think it's weird to have something so similar to lifetimes alongside the lifetimes system</p>",
        "id": 251780232,
        "sender_full_name": "eholk",
        "timestamp": 1630614032
    },
    {
        "content": "<p>not really. <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> mentioned it to me in passing</p>",
        "id": 251780389,
        "sender_full_name": "tmandry",
        "timestamp": 1630614109
    },
    {
        "content": "<p>I assume there is prior art in type systems research, I’m just not familiar with it</p>",
        "id": 251780602,
        "sender_full_name": "tmandry",
        "timestamp": 1630614211
    },
    {
        "content": "<p>So resurrecting this thread, I'm thinking some more about the case where you do</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">SomeSendType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"{y:?}\"</span><span class=\"p\">);</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Under current rules, the resulting generator isn't <code>Send</code> since <code>&amp;SomeSendType</code> is not send because <code>SomeSendType</code> is not <code>Sync</code> (I guess that's not explicitly stated, but let's assume it's true).  But it seems like it should be safe for the generator to be <code>Send</code> since we can't really send <code>y</code> without sending <code>x</code> with it (I'd love to have a clear counterexample where we could break something like this if there is one).</p>\n<p>I wonder if we could support this using just the borrow checker? The idea would be to insert a special <code>'current_stack_frame</code> region and then if the lifetime on <code>&amp;x</code> is <code>'a</code> and <code>'current_stack_frame</code> outlives <code>'a</code> then it's okay for the generator to be <code>Send</code>?</p>\n<p>Of course, implementing this is a little tricky because we currently figure out auto traits before we run the borrow checker, and this particular rule wouldn't mean we're adding a constraint but rather changing the type depending on whether a constraint holds.</p>",
        "id": 274196768,
        "sender_full_name": "eholk",
        "timestamp": 1646432719
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> <a href=\"#narrow/stream/187312-wg-async/topic/Example.20of.20odd.20composing.20of.20Send/near/274196768\">said</a>:</p>\n<blockquote>\n<p>But it seems like it should be safe for the generator to be <code>Send</code> since we can't really send <code>y</code> without sending <code>x</code> with it (I'd love to have a clear counterexample where we could break something like this if there is one).</p>\n</blockquote>\n<p>So, it's a bit of a contrived API <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> , but honestly not <em>that</em> much:</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>code</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"p\">{</span><span class=\"n\">cell</span>::<span class=\"n\">Cell</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">marker</span>::<span class=\"n\">PhantomData</span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">ZstRef</span><span class=\"o\">&lt;'</span><span class=\"na\">c</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"cm\">/* = */</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// As if</span>\n<span class=\"w\">    </span><span class=\"n\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// Self had this =&gt; not Send</span>\n<span class=\"w\">        </span><span class=\"o\">&amp;'</span><span class=\"na\">c</span><span class=\"w\"> </span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"fm\">thread_local!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">static</span><span class=\"w\"> </span><span class=\"n\">PTR</span>: <span class=\"nc\">Cell</span><span class=\"o\">&lt;*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span>::<span class=\"n\">core</span>::<span class=\"n\">ptr</span>::<span class=\"n\">null_mut</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">c</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">ZstRef</span><span class=\"o\">&lt;'</span><span class=\"na\">c</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">r</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">c</span> <span class=\"nc\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">      </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">ZstRef</span><span class=\"o\">&lt;'</span><span class=\"na\">c</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">c</span><span class=\"o\">&gt;</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">ops</span>::<span class=\"n\">Deref</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">ZstRef</span><span class=\"o\">&lt;'</span><span class=\"na\">c</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">type</span> <span class=\"nc\">Target</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">            </span><span class=\"cp\">#[inline]</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">fn</span> <span class=\"nf\">deref</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"bp\">self</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">ZstRef</span><span class=\"o\">&lt;'</span><span class=\"na\">c</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">              </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">c</span> <span class=\"nc\">Cell</span><span class=\"o\">&lt;</span><span class=\"kt\">u8</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                    </span><span class=\"c1\">// # Safety</span>\n<span class=\"w\">                    </span><span class=\"c1\">//   - PTR filled at construction</span>\n<span class=\"w\">                    </span><span class=\"c1\">//   - Self : !Send, so *this is the same PTR as the one filled at construction*</span>\n<span class=\"w\">                    </span><span class=\"o\">&amp;*</span><span class=\"n\">PTR</span><span class=\"p\">.</span><span class=\"n\">with</span><span class=\"p\">(</span><span class=\"n\">Cell</span>::<span class=\"n\">get</span><span class=\"p\">).</span><span class=\"n\">cast</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// PTR filled at construction indeed:</span>\n<span class=\"w\">        </span><span class=\"n\">PTR</span><span class=\"p\">.</span><span class=\"n\">with</span><span class=\"p\">(</span><span class=\"o\">|</span><span class=\"n\">it</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">().</span><span class=\"n\">is_null</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">it</span><span class=\"p\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"bp\">Self</span><span class=\"p\">(</span><span class=\"n\">PhantomData</span><span class=\"p\">))</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"k\">else</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n</div></div>\n<ul>\n<li>\n<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=7fd1bd10faf5cd870abf774a424b0f78\">Playground</a></p>\n</li>\n<li>\n<p>Note that this example, for the sake of simplicity, wraps the reference itself, but it could be made to be a transparent newtype around <code>Cell</code>, and then have a <code>&amp;'c MyRef&lt;Cell&lt;u8&gt;&gt;</code> rather than a <code>MyRef&lt;&amp;'c Cell&lt;u8&gt;&gt;</code> so to speak (granted the \"zst ref\" pseudo justification of such an API would be a bit moot, at that point <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span>); so saying \"the forced <code>Sync</code>ness mechanism would not apply for wrapped references\" would not be a valid way to dodge the issue.</p>\n</li>\n</ul>",
        "id": 274317761,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646587325
    },
    {
        "content": "<p>Also, in case the issue wasn't clear:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">ZstRef</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">().</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// &lt;- the future may be sent to another thread during this suspension, if allowed to be Send</span>\n<span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"{:?}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">());</span><span class=\"w\"> </span><span class=\"c1\">//  &lt;- if run from a distinct thread, this derefs a null ptr</span>\n</code></pre></div>",
        "id": 274317964,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646587569
    },
    {
        "content": "<p>I personally believe that the way to tackle this, from the point of view of a user, is to use <code>let y = &amp;mut x</code> when possible, and <a href=\"https://docs.rs/sync_wrapper/0.1.1/sync_wrapper/struct.SyncWrapper.html\"><code>SyncWrapper</code></a> otherwise.</p>",
        "id": 274318387,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646588125
    },
    {
        "content": "<p>There is one are of \"improvement\", language-wise, which would be to somehow be able to express that a <code>Future</code> needs to be <code>Send</code> up until the point where it is first polled: that it may cease to be <code>Send</code> afterwards, since there could be non-work-stealing but multi-threaded executors that could work with such bounds, and it is currently not something expressible in current Rust, thus such an executor, nowadays, would have to require <code>Fut : Send</code>, and thus refuse a future such as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">non_send_future</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Cell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">42</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">r</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"p\">{}.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">r</span><span class=\"p\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(something akin to <code>impl Send + FnOnce() -&gt; (impl ?Send + Future)</code> maybe?)</p>",
        "id": 274318388,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646588126
    },
    {
        "content": "<p>Yeah, I agree that being able to separate the type of a future before the first await point versus after would be handy, although I think it might be hard to add that in a way that doesn't add a lot more complexity to the language than the feature is worth, but I could be wrong (to be fair, my proposal for changing auto trait inference with rules around a 'current_stack_frame lifetime is also likely more complexity than it's worth).</p>",
        "id": 274431302,
        "sender_full_name": "eholk",
        "timestamp": 1646675851
    },
    {
        "content": "<p>Thanks for the counter example you showed, <span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> ! It definitely shows some complexity I hadn't thought about. I don't _think_ it's contradicts my proposal but whether it does probably depends on what's considered acceptable in an <code>unsafe</code> block. The reason is that by putting a reference in a thread-local variable, it does escape the current stack frame, and on the dereference side, the value is pulled again from outside the current stack frame. The compiler can't see this because it's laundered by <code>unsafe</code>, but I think a case could be made that this isn't actually a safe use of <code>unsafe</code>.</p>\n<p>Of course, it's only hypothetically unsafe because of the rule I'm proposing that says non-Send values aren't considered in generator auto traits if they and all references are bound by <code>'current_stack_frame</code>, so under the current rules I agree that you're example's fine.</p>",
        "id": 274433251,
        "sender_full_name": "eholk",
        "timestamp": 1646676541
    },
    {
        "content": "<p>Of course, as I understand it, our current unsafe rules are more behavioral/operational rather than structural, by which I mean it's more about how you dereference raw pointers than where you store them. I'm guessing moving to a structural view would be hard to define and also break a lot of code that's currently considered safe.</p>",
        "id": 274433599,
        "sender_full_name": "eholk",
        "timestamp": 1646676666
    }
]