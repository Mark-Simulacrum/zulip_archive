[
    {
        "content": "<p>I just saw <a href=\"#narrow/stream/122651-general/topic/Specifying.20lifetime.20bounds.20in.20async.20closures\">this thread</a> on #general and thought I'd highlight it here too. I know I've hit this issue before. Will any of the work around RPITIT or RPITIDT apply here too?</p>",
        "id": 274758717,
        "sender_full_name": "eholk",
        "timestamp": 1646863336
    },
    {
        "content": "<p>I don't think <code>type_alias_impl_trait</code> will help. Using as a return type in a generic or impl doesn't count as a defining use. <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=5d7864eb93c4cfe4bfa55a0c376c78a7\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2021&amp;gist=5d7864eb93c4cfe4bfa55a0c376c78a7</a></p>\n<p>Seems like the crux of the issue is that HRTBs can only apply to one bound. Passing a generic closure requires two bounds: one for the future return type and one for the closure itself, and the two need to share a lifetime.</p>\n<p>Like:</p>\n<div class=\"codehilite\"><pre><span></span><code>fn read_modify_write&lt;Fut, F&gt;(mut cb: F)\nwhere\n    F: for&lt;&#39;a&gt; FnMut(&amp;&#39;a Server) -&gt; Fut,\n    Fut: Future + &#39;a_from_above_somehow\n{ ... }\n</code></pre></div>",
        "id": 274760234,
        "sender_full_name": "Alex Parrill",
        "timestamp": 1646864127
    },
    {
        "content": "<p>It'd be nice if we could do something like </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">read_modify_write</span><span class=\"o\">&lt;</span><span class=\"n\">Fut</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">cb</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">F</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Server</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Fut</span>::<span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Fut</span>: <span class=\"nc\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">b</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">b</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274760429,
        "sender_full_name": "eholk",
        "timestamp": 1646864210
    },
    {
        "content": "<p>you can kinda do that like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#![feature(unboxed_closures)]</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">read_modify_write</span><span class=\"o\">&lt;</span><span class=\"n\">Fut</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">F</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">cb</span>: <span class=\"nc\">F</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">F</span>: <span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Server</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">for</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&lt;</span><span class=\"n\">F</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"nb\">FnMut</span><span class=\"p\">(</span><span class=\"o\">&amp;'</span><span class=\"na\">a</span><span class=\"w\"> </span><span class=\"n\">Server</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>::<span class=\"n\">Output</span>: <span class=\"nc\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">XXX</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">a</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274788225,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646886404
    },
    {
        "content": "<p>but that won't typecheck because rust is not smart enough.</p>\n<p>Seems the issue is bounds on higher-ranked associated types don't work in general. There's quite a few issues open, closest is maybe <a href=\"https://github.com/rust-lang/rust/issues/23481\">#23481</a> . Seems it's blocked on \"lazy normalization\": <a href=\"https://github.com/rust-lang/rust/issues/60471\">#60471</a></p>",
        "id": 274788330,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646886531
    },
    {
        "content": "<p>I had to battle this recently and ended up giving up</p>",
        "id": 274788404,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646886615
    },
    {
        "content": "<p>it's one of the biggest async papercuts right now imo. There's simply no way to do \"async closures\" that borrow stuff. It's quite common to run into this when trying to convert code to async.</p>",
        "id": 274788497,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646886722
    },
    {
        "content": "<p>I can amend <a href=\"https://docs.rs/higher-order-closure\">https://docs.rs/higher-order-closure</a> to also handle <code>async</code> closures like expected, by using <code>Box</code>ing on stable, and some unstable features on nightly / opt-in. I'll probably release that as an <code>async-closure</code>crate or somenthing like that, and then have <code>higher-order-closure</code> reexport it.</p>",
        "id": 274840612,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646921940
    },
    {
        "content": "<p>But if I had to guess, I'd say that's the main reason <code>async |…|</code> syntax is unstable? It would have to cover this?</p>",
        "id": 274840651,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646921964
    },
    {
        "content": "<p>you can do <code>|...| async { ... }</code> on stable, which is just a regular closure returning an <code>async{}</code> block.</p>",
        "id": 274855993,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646928278
    },
    {
        "content": "<p>(I'm not sure what advantages would <code>async |..|</code> have over that, I think they desugar to the same..?)</p>",
        "id": 274856060,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646928308
    },
    {
        "content": "<p>I took a look at <code>higher-order-closure</code>, but I can't see how to use it for this. It'd need doing <code>FnMut(..) -&gt; impl Future + 'a</code> which is not allowed.</p>",
        "id": 274856587,
        "sender_full_name": "Dario Nieuwenhuis",
        "timestamp": 1646928516
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/187312-wg-async/topic/Lifetime.20bounds.20on.20-.3E.20impl.20Trait/near/274840651\">said</a>:</p>\n<blockquote>\n<p>But if I had to guess, I'd say that's the main reason <code>async |…|</code> syntax is unstable? It would have to cover this?</p>\n</blockquote>\n<p>I think covering this case is one of the primary asks for async closures</p>",
        "id": 274874718,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646936268
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> for the problem in the general topic, I think you can make an ad-hoc trait that captures the constraints, but then you may hit this: <a href=\"https://github.com/rust-lang/rust/issues/70263\">https://github.com/rust-lang/rust/issues/70263</a></p>",
        "id": 274874899,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1646936341
    },
    {
        "content": "<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span> for the problem in the general topic, I think you can make an ad-hoc trait that captures the constraints, but then you may hit this: <a href=\"https://github.com/rust-lang/rust/issues/70263\">https://github.com/rust-lang/rust/issues/70263</a></p>\n</blockquote>\n<p>Yeah, I linked to that in the #general thread.</p>",
        "id": 274877893,
        "sender_full_name": "Alex Parrill",
        "timestamp": 1646937756
    }
]