[
    {
        "content": "<p>In particular, the idea of implicit await and/or non-cancellable futures?</p>",
        "id": 270954336,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644227554
    },
    {
        "content": "<p>Rather than discussing the merits of these ideas in depth here, I think we should consider if we could make these changes at all, and if there is such a possibility we should do some thinking/planning/discussion <em>now</em> since the earlier we do huge changes ,the better and it touches on design questions for almost everything else we're looking at</p>",
        "id": 270954505,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644227647
    },
    {
        "content": "<p>How willing are we to break backwards compatibility?</p>",
        "id": 271004144,
        "sender_full_name": "eholk",
        "timestamp": 1644251281
    },
    {
        "content": "<p>Imo it could be an option if we find we have structural problems in our current design which cannot be overcome in any other way. But I've been actively looking at areas folks point out as problematic (e.g. <code>io_uring</code>, cancellation), and so far I haven't been able to find anything that could warrant breakage.</p>",
        "id": 271005954,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644252060
    },
    {
        "content": "<p>I believe non-cancellable futures potentially merits breakage, but it comes down to how much we care about parallelism</p>",
        "id": 271006704,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644252390
    },
    {
        "content": "<p>In general I feel like there's regular talk about breaking changes, but relatively little writing in terms of motivating cases, and exploration of alternative ways to solve the same problems. I'd like us to focus more on that first, and only if we find that all other options are exhausted, to consider breakage.</p>",
        "id": 271006743,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644252408
    },
    {
        "content": "<p>I don't think implicit await is worth it at present, although I see some advantages</p>",
        "id": 271006747,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644252412
    },
    {
        "content": "<p>I agree we should justify whatever we do with very solid arguments :)</p>",
        "id": 271006799,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644252439
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> I like the series you've started on async cancellation, and am excited for the next installment which promises to go into examples - would love to see more of that (:</p>",
        "id": 271006813,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644252450
    },
    {
        "content": "<p>However, I think it is pretty well established that we cannot have scoped parallelism without some changes to the Future trait.</p>",
        "id": 271006826,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644252456
    },
    {
        "content": "<p>Though I agree it would be good to collect the arguments in a clear form</p>",
        "id": 271006922,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1644252491
    },
    {
        "content": "<p>heh, yeah I was about to say</p>",
        "id": 271007001,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1644252528
    },
    {
        "content": "<p>What would a breaking change look like? Would that mean code that used to compile doesn't anymore? That we add a <code>Future2</code> trait? That we create Rust 2.0 or maybe fork and have a new language Async Rust. (To be clear, the last one especially is in my opinion firmly in the extremely bad idea category, I'm just throwing it out there to cover the spectrum)</p>",
        "id": 271020698,
        "sender_full_name": "eholk",
        "timestamp": 1644258103
    },
    {
        "content": "<p>Those are some scary ideas <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 271021272,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1644258357
    },
    {
        "content": "<p>Actually, re-reading my list, I think all but <em>maybe</em> <code>Future2</code> (with a better name) are bad ideas.</p>",
        "id": 271021948,
        "sender_full_name": "eholk",
        "timestamp": 1644258609
    },
    {
        "content": "<p>I'm in favor of substantial change <em>if</em> it has commensurate value.</p>",
        "id": 271034678,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644264313
    },
    {
        "content": "<p>For io_uring in particular, I think it's worth some substantially different interfaces, but I also think we should not gate present improvements to the state of futures on that.</p>",
        "id": 271034825,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644264373
    },
    {
        "content": "<p>I think io_uring is sufficiently different that more than just futures would need to change, and we should do that in parallel.</p>",
        "id": 271034857,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644264393
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/Should.20we.20seriously.20consider.20radical.20change.3F/near/271006826\">said</a>:</p>\n<blockquote>\n<p>However, I think it is pretty well established that we cannot have scoped parallelism without some changes to the Future trait.</p>\n</blockquote>\n<p>Can you elaborate on this? By \"scoped parallelism\", do you mean unifying futures with something like Rayon, for compute-intensive work? Or do you mean \"scoped futures\" similar to scoped threads where you can hand a borrow to a future because you know it won't outlive what it borrows?</p>",
        "id": 271034980,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644264459
    },
    {
        "content": "<p>I think Niko means the latter</p>",
        "id": 271052640,
        "sender_full_name": "tmandry",
        "timestamp": 1644272976
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 271052688,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644272996
    },
    {
        "content": "<p>The whole non-cancellable futures thing mainly gets us scoped tasks as I see it. There's nothing blocking us from implementing <code>tokio::fs::File</code> to use io_uring as its interface is today.</p>",
        "id": 271086115,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1644301352
    },
    {
        "content": "<p>I'm currently working on an io_uring based async io library using io_uring. While non-cancellable futures would be nice in some instances, the main thing I've found to an issue are the AsyncRead and AsyncWrite traits from futures.</p>",
        "id": 271097906,
        "sender_full_name": "Sashanoraa",
        "timestamp": 1644310864
    },
    {
        "content": "<p>Nothing it std has been a major hurdle thus far, though we'll see if I feel differently when the library is closer to completion.</p>",
        "id": 271098039,
        "sender_full_name": "Sashanoraa (any/all)",
        "timestamp": 1644310925
    },
    {
        "content": "<p>I feel like when people talk about io_uring requiring different designs there are unspoken design requirements? Because it seems pretty easy to have an optimally performant io_uring implementation today (using either AsyncBufRead or maybe even AsyncRead) as long as you have some kind of buffer manager rather than expecting the future calling <code>read</code> to allocate the buffer on it s stack.</p>",
        "id": 271100129,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644312047
    },
    {
        "content": "<p>I would like to know what those 'unspoken requirements' are precisely</p>",
        "id": 271100245,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644312106
    },
    {
        "content": "<p>I feel like cancellation brings a bunch of footguns, not just with parallelism. But I don't have a list (probably should!)</p>",
        "id": 271100483,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644312203
    },
    {
        "content": "<p>In the case of <code>tokio::fs::File</code>, we would simply use an internal buffer to store the data while its in the kernel - this is already what we do today, so it's fine. As for avoiding the copy, then you do indeed need a different trait, but such a trait _is_ possible today.</p>",
        "id": 271100651,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1644312277
    },
    {
        "content": "<p>Right, avoiding the copy seems pretty easy - the obvious design for AsyncBufRead should permit it (pretty easy from the POV of the trait design, not necessarily the concrete implementation)</p>",
        "id": 271103635,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644313943
    },
    {
        "content": "<p>I guess by avoiding the copy you mean that you want the kernel to write directly into the user's data structure rather than an intermediate buffer? I think then to be precise about the buffer manager, I mean that the user has to use  these managed buffers for their data structures</p>",
        "id": 271103974,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644314145
    },
    {
        "content": "<p>So perhaps the unspoken requirement is that people want to be able to pass pointers to memory which they fully own to read and have the kernel write directly into them without any copying?</p>",
        "id": 271104131,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644314225
    },
    {
        "content": "<p>The tokio-uring crate has a fancy IoBuf trait that lets you temporarily give away ownership of the buffer, then get it back when the operation completes.</p>",
        "id": 271111920,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1644318731
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"218683\">Alice Ryhl</span> <a href=\"#narrow/stream/187312-wg-async/topic/Should.20we.20seriously.20consider.20radical.20change.3F/near/271100651\">said</a>:</p>\n<blockquote>\n<p>In the case of <code>tokio::fs::File</code>, we would simply use an internal buffer to store the data while its in the kernel - this is already what we do today, so it's fine. As for avoiding the copy, then you do indeed need a different trait, but such a trait _is_ possible today.</p>\n</blockquote>\n<p>Yeah, I don't think this needs new <em>language</em> features for the most part. And I do think separate traits are the right answer, rather than trying to adapt our existing async-related traits. But it's not just about avoiding copies; there's also the use of internal ring file indexes rather than file descriptors, the use of kernel-registered buffers, and the ability to do fused operations that stay in the kernel (e.g. \"read from here and write to there\" or \"open this file, read from it, close it\").</p>",
        "id": 271147658,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1644335479
    },
    {
        "content": "<p>for what its worth, I agree with <span class=\"user-mention\" data-user-id=\"218683\">@Alice Ryhl</span> that un-cancellable futures might be necessary for scoped spawns, and I think scoped spawns would be a huge upgrade for the ecosystem</p>",
        "id": 271365011,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1644450367
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> </p>\n<blockquote>\n<p>What would a breaking change look like? Would that mean code that used to compile doesn't anymore? That we add a Future2 trait? </p>\n</blockquote>\n<p>Not sure if you've seen it, but there's a RFC around it for quite some time: <a href=\"https://github.com/Matthias247/rfcs/pull/1/files\">https://github.com/Matthias247/rfcs/pull/1/files</a><br>\nThere's actually nothing breaking in it at this point in time - it's compatible to what exists. Like both non-generic Java collections can coexist with the generic ones, and like C# has 2 sets of collection types ;) <br>\nThe main concern back then was whether the extra addition to the language and ecosystem is worth it.</p>\n<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> </p>\n<blockquote>\n<p>So perhaps the unspoken requirement is that people want to be able to pass pointers to memory which they fully own to read and have the kernel write directly into them without any copying?</p>\n</blockquote>\n<p>Yes. But you might just call it \"behaves exactly as <code>Read</code> and <code>Write</code>\" - it directly transfers data from a slice to a sink or the other way around.<br>\nWhat you talk about mostly here it the <code>Read</code> route, but let's for example briefly look at <code>Write</code>. Let's assume we have a HTTP stack and a TLS library. Let's call that rustls. When the request/response generates data, it makes a <code>write()</code> call to the TLS library. That has an internal buffer. In there we encrypt things. Now we want to write the encrypted data using syscalls. There's now 2 options:</p>\n<ul>\n<li>Just write the internal buffer - which is exactly what is done today.</li>\n<li>Swap out the existing buffer in the TLS library, somehow give ownership for it to a background task which can do the write. And then think deeply about you get backpressure back. This is doable, but requires more deliberate changes in the whole stack. You will probably end up going to rewrite a whole bunch of infrastructure on top of buffer pools like how some infrastructure (DPDK, nginx) is already managing data. </li>\n</ul>\n<p>There's similar examples for the reading side, where we would like to read data from the kernel exactly to a certain memory location, because then it's most efficient to further process it.</p>",
        "id": 272564963,
        "sender_full_name": "Matthias247",
        "timestamp": 1645331221
    }
]