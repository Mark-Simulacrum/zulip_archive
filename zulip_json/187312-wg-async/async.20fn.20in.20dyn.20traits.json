[
    {
        "content": "<p>I've posted a first draft of the \"async fn in dyn traits\" explainer:</p>\n<p><a href=\"https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait.html\">https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait.html</a></p>",
        "id": 275046097,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647039699
    },
    {
        "content": "<p>You'll note that it ends on a cliffhanger :)</p>",
        "id": 275067718,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647046444
    },
    {
        "content": "<p>One thing that is not mentioned in the proposal is how lifetimes work with dynx things, since it seems like <code>&amp;</code> and <code>&amp;mut</code> are on the list of things that can be used in dynx. I would love to see an example with the <code>async fn count()</code> calling something that is returning a <code>&amp;mut MyFuture</code>. Maybe it all just works with the same mechanisms as used in <code>dyn Trait</code> but the fact that futures might be larger than a provided stack allocation seems like it might cause a problem here</p>",
        "id": 275195089,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647235112
    },
    {
        "content": "<p>I'm a little surprised the draft doesn't mention <a href=\"https://poignardazur.github.io/2022/02/23/rust-unsized-vars-analysis/\">unsized returns</a> at all.</p>",
        "id": 275224922,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647258741
    },
    {
        "content": "<p>Like, I get that the proposal was initially reject/postponed because implementing it was too complex for something that wasn't a lang team priority.</p>",
        "id": 275224967,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647258777
    },
    {
        "content": "<p>But right now you're proposing to introduce an entire new <code>dynx Trait</code> compiler concept, with unclear interactions with other concepts. It seems complex enough to justify revisiting RFC 2884.</p>",
        "id": 275225193,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647258940
    },
    {
        "content": "<p>Is the idea that <code>dyner</code> is a testing crate using proc-macros, but the <code>dynx</code> keywork might natively support what it does in the future?</p>",
        "id": 275276095,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1647281355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263609\">Olivier FAURE</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275224967\">said</a>:</p>\n<blockquote>\n<p>Like, I get that the proposal was initially reject/postponed because implementing it was too complex for something that wasn't a lang team priority.</p>\n</blockquote>\n<p>unsized returns have a bunch of flaws, in my view, but chief among them is that they are plain incompatible with our async model, which assumes that it knows how big a stack frame is (so that it can allocate a struct of that size). One thing that <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> and I were saying today is that we should add a thorough comparison amongst the alternatives, so I'm going to add that.</p>",
        "id": 275276342,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647281473
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257428\">Gus Wynn</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276095\">said</a>:</p>\n<blockquote>\n<p>Is the idea that <code>dyner</code> is a testing crate using proc-macros, but the <code>dynx</code> keywork might natively support what it does in the future?</p>\n</blockquote>\n<p>no, <code>dynx</code> is never meant to be a syntax used by anyone</p>",
        "id": 275276359,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647281483
    },
    {
        "content": "<p>I would say dyner is...probably just done. one could imagine adding some of its capability elsewhere at some point, but you would always be \"adapting\" an existing instance to specify how it uses its memory</p>",
        "id": 275276412,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647281515
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276359\">said</a>:</p>\n<blockquote>\n<p>no, <code>dynx</code> is never meant to be a syntax used by anyone</p>\n</blockquote>\n<p>(that said, I do think that -- given some <em>other</em> syntax -- it'd be cool to replace the idea of dyn trait with \"Some kind of pointer to trait\", I would just never make that syntax be <code>dynx</code>)</p>",
        "id": 275276493,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647281551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275195089\">said</a>:</p>\n<blockquote>\n<p>One thing that is not mentioned in the proposal is how lifetimes work with dynx things, since it seems like <code>&amp;</code> and <code>&amp;mut</code> are on the list of things that can be used in dynx. I would love to see an example with the <code>async fn count()</code> calling something that is returning a <code>&amp;mut MyFuture</code>. Maybe it all just works with the same mechanisms as used in <code>dyn Trait</code> but the fact that futures might be larger than a provided stack allocation seems like it might cause a problem here</p>\n</blockquote>\n<p>like a <code>dyn</code> type, a <code>dynx</code> type needs a lifetime bound</p>",
        "id": 275276530,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647281574
    },
    {
        "content": "<p>I think you could return a <code>Pin&lt;&amp;mut Future&gt;</code>, but you'd have to get that pointer from somewhere, I'm not sure that's very realistic</p>",
        "id": 275276624,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647281619
    },
    {
        "content": "<p>the \"inline\" adapter uses stack allocation, but it does it by \"pre-allocating\" the stack storage space earlier</p>",
        "id": 275276706,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647281647
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276530\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275195089\">said</a>:</p>\n<blockquote>\n<p>One thing that is not mentioned in the proposal is how lifetimes work with dynx things, since it seems like <code>&amp;</code> and <code>&amp;mut</code> are on the list of things that can be used in dynx. I would love to see an example with the <code>async fn count()</code> calling something that is returning a <code>&amp;mut MyFuture</code>. Maybe it all just works with the same mechanisms as used in <code>dyn Trait</code> but the fact that futures might be larger than a provided stack allocation seems like it might cause a problem here</p>\n</blockquote>\n<p>like a <code>dyn</code> type, a <code>dynx</code> type needs a lifetime bound</p>\n</blockquote>\n<p>the lifetime bound is the bound on the pointer to where-ever the concrete impl is on the stack, right?</p>",
        "id": 275308572,
        "sender_full_name": "Gus Wynn",
        "timestamp": 1647298304
    },
    {
        "content": "<p>It is a bit odd that <code>dynx</code> is introduced as a way of generalizing the <code>Pin&lt;Box&lt;dyn Trait&gt;&gt;</code> pattern but the only example that is given is essentially <code>Pin&lt;Box&lt;dyn Trait&gt;&gt;</code> itself. If we are trying to avoid heap allocation then I thought <code>Pin&lt;&amp;mut dyn Trait&gt;</code> would be how to do it, but it sounds like this doesn't work?</p>",
        "id": 275308866,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1647298499
    },
    {
        "content": "<p>You could turn a <code>Pin&lt;&amp;mut T&gt;</code> into a <code>dynx</code>. From a <code>#[dyn(identity)]</code> method the return type is: <code>impl Future + IntoRawPointer</code></p>",
        "id": 275331314,
        "sender_full_name": "tmandry",
        "timestamp": 1647322152
    },
    {
        "content": "<p>The lifetime of the reference would become the lifetime bound of the <code>dynx</code></p>",
        "id": 275331391,
        "sender_full_name": "tmandry",
        "timestamp": 1647322213
    },
    {
        "content": "<p>The key point of <code>dynx</code> is that the caller doesn't have to care if the pointer is an owned pointer like <code>Box</code> or an unowned pointer like <code>&amp;mut</code> (or a even shared pointer like <code>Arc</code>).</p>",
        "id": 275331430,
        "sender_full_name": "tmandry",
        "timestamp": 1647322303
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275331314\">said</a>:</p>\n<blockquote>\n<p>You could turn a <code>Pin&lt;&amp;mut T&gt;</code> into a <code>dynx</code>. From a <code>#[dyn(identity)]</code> method the return type is: <code>impl Future + IntoRawPointer</code></p>\n</blockquote>\n<p>Here <code>T</code> is the concrete type that implements <code>Future</code></p>",
        "id": 275331628,
        "sender_full_name": "tmandry",
        "timestamp": 1647322549
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116009\">nikomatsakis</span> <a href=\"#narrow/stream/187312-wg-async/topic/async.20fn.20in.20dyn.20traits/near/275276342\">said</a>:</p>\n<blockquote>\n<p>unsized returns have a bunch of flaws, in my view, but chief among them is that they are plain incompatible with our async model, which assumes that it knows how big a stack frame is (so that it can allocate a struct of that size).</p>\n</blockquote>\n<p>Incompatible how?</p>\n<p>To be clear, unsized returns don't imply unsized locals. They could be stored in Boxes, RCs, or reusable local storage, just like you propose with <code>InlineAsyncIterator</code>. The biggest difference would be that the storage method would be decided by the function using <code>dyn AsyncIterator</code> and not the function creating it, which to me seems more predictable. (Also FWIW would involve fewer vtable lookups)</p>",
        "id": 275353863,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647339839
    },
    {
        "content": "<p>To be clear, I don't want to go into a discussion of feature tradeoffs if you're not interested. Ultimately, you're the lang team member, you're the one who knows how compiler internals work, etc. But to me it feels like you've been thinking about the <code>dynx</code> idea for months (I remember you mentioning something similar in your async blog posts), and now that you're starting to formalize it,  you're looking for quick-and-easy reasons to dismiss unsized returns because you haven't seriously considered them.</p>",
        "id": 275354384,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647340105
    },
    {
        "content": "<p>What I'm saying is, I think you should seriously sit down and spend some actual time considering the unsized returns proposal and how it could work with async, before dismissing it. I might be wrong, but to me it feels you haven't done that so far.</p>",
        "id": 275354636,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647340253
    },
    {
        "content": "<p>One of the design goals is for this feature to work in no-std environments with no allocator. To handle unsized returns you would need to either</p>\n<ul>\n<li>Extend the stack (alloca), which isn't possible in async contexts or generators for the reasons Niko described above</li>\n<li>Allocate on the heap, which isn't possible in no-std</li>\n</ul>\n<p>So, yes, we did consider unsized returns (I was initially excited about this direction) but didn't find a way to use them in a way that meets these design goals. Using adapters does: it allows code that statically knows the type to pre-allocate space for those futures on the stack before erasing type information.</p>",
        "id": 275459854,
        "sender_full_name": "tmandry",
        "timestamp": 1647396470
    },
    {
        "content": "<p>Side note, <span class=\"user-mention\" data-user-id=\"263609\">@Olivier FAURE</span>, I appreciate your interest in the discussion but in those last couple of messages you're coming off as a little hostile. There was plenty of thought that went into this and I welcome feedback on the technical merits (I know Niko does too), but let's try to stick to that please</p>",
        "id": 275461718,
        "sender_full_name": "tmandry",
        "timestamp": 1647398957
    },
    {
        "content": "<p>Currently reading.</p>",
        "id": 275480155,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647420090
    },
    {
        "content": "<p>Typo: On the 'how it feels' page, the example impl under \"How you implement a trait with async fns\", the impl of <code>next</code> is missing its return type</p>",
        "id": 275480165,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647420098
    },
    {
        "content": "<p>And on the next page</p>",
        "id": 275480487,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647420299
    },
    {
        "content": "<p>Question: about drop, is the proposal different from what already happens? I assume that is how drop for pointers to DSTs works already?</p>",
        "id": 275483732,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647422136
    },
    {
        "content": "<p>Does the dynx wrapper affect the drop analysis done for closures for 2229 (I couldn't find documentation of how <code>rustc_insignificant_dtor</code> works)? I expect at worse that analysis will just need to become dynx aware.</p>",
        "id": 275490319,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647425817
    },
    {
        "content": "<p>Regarding <code>no_std</code> support, it could be interesting to, <em>later on</em>, extend the framework to play with some arena / bump allocator, which could be capped and stack-memory backed, so that an <code>async fn</code> signature would be:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">method</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">arena</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"na\">arena</span> <span class=\"nc\">Arena</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">args</span><span class=\"err\">…</span><span class=\"w\"></span>\n<span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Pin</span><span class=\"o\">&lt;&amp;'</span><span class=\"na\">arena</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;&gt;</span><span class=\"w\">  </span><span class=\"cm\">/* maybe option wrapped with the panic on capacity exhaustion is not desirable */</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li>(I think the blog post already hints at that at some point <span aria-label=\"ok\" class=\"emoji emoji-1f44c\" role=\"img\" title=\"ok\">:ok:</span> , but we may want to further discuss about it over here)</li>\n</ul>\n<p>and then erase that <code>Pin&lt;&amp;mut …&gt;</code> as the suggested <del><code>dynx</code></del> <code>VirtualPtr&lt;dyn Future&lt;Output = R&gt;&gt;</code></p>",
        "id": 275499839,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1647431771
    },
    {
        "content": "<p>Aside: I prefer something with <code>ptr</code> in the name to the <code>dynx</code> naming, to be honest, since a <code>dyn Trait</code> is the pointee, but a <code>dynx</code> is the pointer. Indeed, consider:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">some_function</span><span class=\"o\">&lt;'</span><span class=\"na\">lt</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nc\">VirtualPtr</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">lt</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"></span>\n<span class=\"c1\">// vs.</span>\n<span class=\"k\">fn</span> <span class=\"nf\">some_function</span><span class=\"o\">&lt;'</span><span class=\"na\">lt</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">  </span>-&gt; <span class=\"nc\">dynx</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">lt</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>VirtualPtr can already be defined in Rust (with manual impls for each supported trait, of course)</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<h3>Core definition</h3>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">ty</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Erased</span><span class=\"p\">(());</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">VirtualPtr</span><span class=\"o\">&lt;</span><span class=\"n\">DynTrait</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">VirtualPtrVTable</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">ptr</span>: <span class=\"nc\">ptr</span>::<span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">ty</span>::<span class=\"n\">Erased</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">vtable</span>: <span class=\"nc\">ptr</span>::<span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">&lt;</span><span class=\"n\">DynTrait</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"n\">VirtualPtrVTable</span><span class=\"o\">&gt;</span>::<span class=\"n\">T</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">VirtualPtrVTable</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">DynTrait</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">VirtualPtrVTable</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Send</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">VirtualPtr</span><span class=\"o\">&lt;</span><span class=\"n\">DynTrait</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">DynTrait</span><span class=\"w\"> </span>: <span class=\"nb\">Send</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">DynTrait</span><span class=\"w\"> </span>: <span class=\"o\">?</span><span class=\"nb\">Sized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">VirtualPtrVTable</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"nb\">Sync</span><span class=\"w\"></span>\n<span class=\"k\">for</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">VirtualPtr</span><span class=\"o\">&lt;</span><span class=\"n\">DynTrait</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">DynTrait</span><span class=\"w\"> </span>: <span class=\"nb\">Sync</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<h3>An example for <code>Future</code></h3>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// generated for trait Future</span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// future::Futurrs</span>\n<span class=\"w\">        </span><span class=\"n\">task</span>::<span class=\"p\">{</span><span class=\"n\">Context</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Poll</span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">FutureVirtualPtrVTable</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">drop_owned</span>: <span class=\"nc\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">ptr</span>::<span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">ty</span>::<span class=\"n\">Erased</span><span class=\"o\">&gt;</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">poll</span>:\n            <span class=\"nc\">unsafe</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">fn</span><span class=\"p\">(</span><span class=\"n\">ptr</span>::<span class=\"n\">NonNull</span><span class=\"o\">&lt;</span><span class=\"n\">ty</span>::<span class=\"n\">Erased</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">cx</span>: <span class=\"kp\">&amp;</span><span class=\"o\">'</span><span class=\"nb\">_</span> <span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Context</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">              </span>-&gt; <span class=\"nc\">Poll</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">VirtualPtrVTable</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">type</span> <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">FutureVirtualPtrVTable</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">VirtualPtrVTable</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"nb\">_</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Send</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">type</span> <span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">FutureVirtualPtrVTable</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[cfg(TODO)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">usability</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Fut</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">P</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">VirtualPtr</span><span class=\"o\">&lt;</span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"o\">'</span><span class=\"na\">usability</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Fut</span><span class=\"w\"> </span>: <span class=\"o\">'</span><span class=\"na\">usability</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">P</span><span class=\"w\"> </span>: <span class=\"nc\">SomePtrTrait</span><span class=\"o\">&lt;</span><span class=\"n\">Fut</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"cm\">/* … */</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>\n<ul>\n<li><strong><a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8805e8f802b37bcc8a696da2335bb32b\">Playground</a></strong></li>\n</ul>\n</div></div>",
        "id": 275499965,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1647431875
    },
    {
        "content": "<p>Some more thoughts: I'm pleasantly surprised how well this all works out. It's not totally friction-free, but it seems that the common case is and the non-common case is fairly good. So this seems overall a great design.</p>",
        "id": 275501436,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647432673
    },
    {
        "content": "<p>For the syntax, the downside seems to be that we do implicit allocation in the common case and that seems not perfect (I do see the argument for making the common case so easy, don't get me wrong). An obvious alternative would be to make the explicit <code>#[dyn(Box)]</code> required rather than the default and have the default be a type error. I think that alternative is worse, but I wanted to bring it up anyway :-)</p>",
        "id": 275501711,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647432843
    },
    {
        "content": "<p>I'd be curious to see how this generalises to <code>impl Trait</code> and returning type params other than async, I don't expect  there to be any surprises but  maybe there are more bounds to take account of or something?</p>",
        "id": 275501839,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647432905
    },
    {
        "content": "<p>I wonder also if being able to specify how a future is wrapped (e.g., Boxed vs by value) is more generally useful? E.g., I think a non-cancellable future could be expressed as a &amp; pointer to a future with the owner of the future being sufficiently far up the stack? Or maybe an Rc&lt;Future&gt; where the runtime (or nursery in the structured concurrency case) also keeps a reference.</p>",
        "id": 275502111,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647433048
    },
    {
        "content": "<p>Another random wondering is if the mechanism for allocating a value somewhere and then returning a pointer to it is also generalisable? Being able to do this would make the ReadBuf design better, for example.</p>",
        "id": 275502270,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647433138
    },
    {
        "content": "<p>There is an assumption that fat pointers are always two words, but if we allow custom DST (or even non-custom but with custom size hidden data), then that will no longer hold. Not sure there's anything we can do about that though.</p>",
        "id": 275502433,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647433227
    },
    {
        "content": "<p>I reread the InlineAsyncIterator and I understand it better now. One objection I have is: how does it handle multiple call to the async method?</p>",
        "id": 275503188,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647433645
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">window</span><span class=\"p\">(</span><span class=\"n\">i</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"k\">dyn</span><span class=\"w\"> </span><span class=\"n\">AsyncIterator</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">[</span><span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275503614,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647433929
    },
    {
        "content": "<p>You can't reuse pre-allocated space since the variables are live at the same time.</p>",
        "id": 275503987,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647434164
    },
    {
        "content": "<p>You could use GATs to prevent this use case but (1) that has to be integrated in the design (2) this use case seems like something users would actually want.</p>",
        "id": 275504142,
        "sender_full_name": "Olivier FAURE",
        "timestamp": 1647434279
    },
    {
        "content": "<p>Yeah, the inline futures for <code>&amp;self</code> methods each have to be wrapped in a <code>RefCell</code> (or its equivalent) to prevent that. For <code>&amp;mut self</code> it will be prevented statically, since <code>async fn</code> captures all input lifetimes in its return value.</p>",
        "id": 275709769,
        "sender_full_name": "tmandry",
        "timestamp": 1647543526
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"263609\">@Olivier FAURE</span> you can't write that code because the future returned by <code>next()</code> holds a borrow on <code>i</code></p>",
        "id": 275725039,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647550453
    },
    {
        "content": "<p>for an <code>&amp;self</code> method, though, it could work; that is one reason I didn't want to build this mechanism <em>in</em>, because it's \"imperfect\", it doesn't work great on <em>all</em> traits</p>",
        "id": 275725075,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647550476
    },
    {
        "content": "<p>I think that's ok for a kind of niche case thing</p>",
        "id": 275725085,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1647550480
    },
    {
        "content": "<p>I'm reading the lang document (thanks Niko for preparing it early :) and this thread, and one question that I haven't seen answered yet is why we need dyn(box) vs. dyn(identity) etc with the current design, other than as a special-case form of static assert. It seems like one simple approach could be that if the returned value is &lt;= size_of(usize), we automatically skip boxing it (basically just putting it in the ptr slot for dynx) and if it is larger, then we do box. This means that if you don't care you can still get fast behavior if your future is compact, and if you do care you just need to be careful to return something 'small enough' (and probably assert it, perhaps with an attribute, perhaps with something else).</p>\n<p>For the example in the lang hackmd (<a href=\"https://hackmd.io/@nikomatsakis/S1xxjkZGc#How-to-write-an-adapter\">https://hackmd.io/@nikomatsakis/S1xxjkZGc#How-to-write-an-adapter</a>), if the allocator you chose is something that isn't a ZST (for example, the arena allocator example above), then presumably there's a monomorphization-time error for dyn(identity) telling you the return type is too big, which seems quite unfortunate. Maybe there's nothing we can do to solve this nicely without providing better abstractions in dyner or equivalents.</p>",
        "id": 275747205,
        "sender_full_name": "simulacrum",
        "timestamp": 1647564110
    },
    {
        "content": "<p>One other question I'm not quite seeing the answer to yet is what the expected flow is around lints etc to let users opt-out of Box by default in some cases, or otherwise identifying where that has happened.</p>",
        "id": 275747329,
        "sender_full_name": "simulacrum",
        "timestamp": 1647564220
    },
    {
        "content": "<p>(One reason I ask about lints is that it seems sad that you have to constantly import InlineAdapter or MyOwnBoxAdapter etc in every place you go from impl Trait to dyn Trait -- it seems like ideally we'd have some way to have a \"global\" allocator for dyn Trait converters. But that can be left for the future, I guess.)</p>",
        "id": 275747483,
        "sender_full_name": "simulacrum",
        "timestamp": 1647564312
    },
    {
        "content": "<p>Yeah a global lint and/or \"adaptation mode\" is something I'd like to see</p>",
        "id": 275747566,
        "sender_full_name": "tmandry",
        "timestamp": 1647564392
    },
    {
        "content": "<p>I think we could optimize automatically and turn <code>#[dyn(identity)]</code> to something more like a lint that asserts that boxing is skipped. It ties into some of the other questions (that we intentionally left out of scope for that doc) about the rules around pointers</p>",
        "id": 275747604,
        "sender_full_name": "tmandry",
        "timestamp": 1647564450
    },
    {
        "content": "<p>I also am wondering how much of an impediment we expect the manual trait definition copying to be -- it seems pretty annoying to me. You could imagine that we can avoid that by 'just' providing a magic compiler feature which lets you pass in a <code>fn dynify_with&lt;T: SomeTrait&gt;(value: T) -&gt; dynx SomeTrait</code> to a <code>adapt(impl AsyncIterator, dynify_with) -&gt; dyn AsyncIterator</code> -- basically moving the \"derive\" into the compiler, just generating the shim based on it</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">dyner</span>::<span class=\"n\">inline</span>::<span class=\"n\">adapter_struct</span><span class=\"o\">!</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">InlineAsyncIterator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">MyTrait</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 275747814,
        "sender_full_name": "simulacrum",
        "timestamp": 1647564663
    },
    {
        "content": "<p>Anyway, this is super exciting, really happy to see this coming along</p>",
        "id": 275747914,
        "sender_full_name": "simulacrum",
        "timestamp": 1647564734
    },
    {
        "content": "<blockquote>\n<p>if the allocator you chose is something that isn't a ZST (for example, the arena allocator example above), then presumably there's a monomorphization-time error for dyn(identity) telling you the return type is too big, which seems quite unfortunate.</p>\n</blockquote>\n<p>In our current iteration you need to implement a trait called <code>IntoRawPointer</code> for <code>Box&lt;T, YourAllocator&gt;</code>, and the size requirements are baked into the <code>IntoRawPointer</code> API. So your smart pointer has to be convertible to/from a raw pointer, but doesn't necessarily have to <em>be</em> one. This can all be determined during type check.</p>",
        "id": 275879991,
        "sender_full_name": "tmandry",
        "timestamp": 1647651658
    },
    {
        "content": "<p>...there's one tiny problem with that, though, which is that writing such an impl yourself violates current orphan rules</p>",
        "id": 275880131,
        "sender_full_name": "tmandry",
        "timestamp": 1647651796
    },
    {
        "content": "<p>I added a page on a more \"advanced topic\", <a href=\"https://rust-lang.github.io/async-fundamentals-initiative/explainer/async_fn_in_dyn_trait/nested_impl_trait.html\">adapting nested <code>impl Trait</code></a></p>",
        "id": 275881675,
        "sender_full_name": "tmandry",
        "timestamp": 1647653859
    },
    {
        "content": "<p>this one has had less scrutiny, so it could be flawed</p>",
        "id": 275881775,
        "sender_full_name": "tmandry",
        "timestamp": 1647653984
    }
]