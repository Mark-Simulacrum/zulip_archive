[
    {
        "content": "<p>A thread for discussion. <a href=\"https://www.ncameron.org/blog/async-io-with-completion-model-io-systems/\">https://www.ncameron.org/blog/async-io-with-completion-model-io-systems/</a></p>",
        "id": 275397205,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647361459
    },
    {
        "content": "<p>I'm curious what people think about the options here. I guess we want an async::BufRead trait in any case, so the big question is whether we want to support owned-buffer reads <em>as well</em>. I'll note that that seems to be the preference amongst implementers, but it would mean further divergence from the sync traits. If we want to support that, the next question is about whether to add another trait of more functionality to <code>async::Read</code>.</p>",
        "id": 275397477,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647361574
    },
    {
        "content": "<p>My WIP library currently supports both owned-buffers and a managed buffer pool at the choice of the user.</p>",
        "id": 275462776,
        "sender_full_name": "Sashanoraa (any/all)",
        "timestamp": 1647400259
    },
    {
        "content": "<p>I personally think non-cancellable futures would be a really nice way to resolve this, but I understand that's probably one of the harder solutions for a lang prospective.</p>",
        "id": 275462859,
        "sender_full_name": "Sashanoraa (any/all)",
        "timestamp": 1647400333
    },
    {
        "content": "<p>Maybe a broader abstraction could be some kinda of non-droppable types? So you could express which states are droppable and which aren't through a type transition.</p>",
        "id": 275462893,
        "sender_full_name": "Sashanoraa (any/all)",
        "timestamp": 1647400423
    },
    {
        "content": "<p>Do completion-based IO systems normally provide a way to do cancellation?</p>",
        "id": 275565336,
        "sender_full_name": "eholk",
        "timestamp": 1647458827
    },
    {
        "content": "<p>If so, it seems like in the <code>Drop</code> impl for the async IO future it could include a call to the OS to cancel the IO, at least as long as the OS-provided cancel API is synchronous.</p>",
        "id": 275565412,
        "sender_full_name": "eholk",
        "timestamp": 1647458881
    },
    {
        "content": "<p>Although I'm guessing for the OS to safely implement synchronous cancellation then that would negate most of the benefits of async IO...</p>",
        "id": 275565508,
        "sender_full_name": "eholk",
        "timestamp": 1647458926
    },
    {
        "content": "<p>I believe the is provided cancellation is always async and that you have to keep the buffer alive until either the cancellation or the original io completes</p>",
        "id": 275565818,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647459121
    },
    {
        "content": "<p>Even with sync cancellation, there's no way of guaranteeing that the destructor is run</p>",
        "id": 275565952,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1647459206
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"363998\">Ibraheem Ahmed</span> <a href=\"#narrow/stream/187312-wg-async/topic/Blog.20post.20on.20completion.20IO.20systems.20and.20BufRead.20trait/near/275565952\">said</a>:</p>\n<blockquote>\n<p>Even with sync cancellation, there's no way of guaranteeing that the destructor is run</p>\n</blockquote>\n<p>True, although it seems like then we also wouldn't free the backing buffer so there wouldn't be a risk of use-after-free when the IO finally completes (unless you stack allocated the buffer....)</p>",
        "id": 275566332,
        "sender_full_name": "eholk",
        "timestamp": 1647459425
    },
    {
        "content": "<p>Anyway, I don't think \"hoping the buffer leaks too\" is a good strategy for avoiding UB here.</p>",
        "id": 275566483,
        "sender_full_name": "eholk",
        "timestamp": 1647459490
    },
    {
        "content": "<p>How do we solve this problem in the face of panics?</p>",
        "id": 275566610,
        "sender_full_name": "eholk",
        "timestamp": 1647459559
    },
    {
        "content": "<p>The buffer could be elsewhere and is borrowed for the io. In which case it would be dropped even if the other dtor is not called</p>",
        "id": 275572039,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647462082
    },
    {
        "content": "<p>*owned elsewhere</p>",
        "id": 275572048,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647462094
    }
]