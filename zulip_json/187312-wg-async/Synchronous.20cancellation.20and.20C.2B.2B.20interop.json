[
    {
        "content": "<p>I thought this group might want to know what the current status of cancellation is in our C++ async interop solution, <a href=\"https://github.com/pcwalton/cxx-async\">https://github.com/pcwalton/cxx-async</a></p>",
        "id": 264107825,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1638934541
    },
    {
        "content": "<p>The problem is that C++ coroutines generally want to run to completion (note that the standard doesn't specify this, but libraries generally assume it), while Rust futures can be dropped at any time</p>",
        "id": 264107905,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1638934585
    },
    {
        "content": "<p>What I've done is to create a lazily-spawned, process-global thread called the \"reaper\", where C++ coroutines are reparented to if the Rust future wrapping them is dropped</p>",
        "id": 264107967,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1638934668
    },
    {
        "content": "<p>The reaper is a simple executor that just drives coroutines to completion and discards their results</p>",
        "id": 264108015,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1638934684
    },
    {
        "content": "<p>This actually seems to work well. The downside is that C++ may need to copy references to stack locals if the future gets reparented. But cxx-async currently requires wrapped C++ futures to be <code>'static</code> anyway, so this doesn't matter right now.</p>",
        "id": 264108066,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1638934771
    },
    {
        "content": "<p>That's awesome! I had no idea this work was happening, but I'm glad to see it.</p>",
        "id": 264230683,
        "sender_full_name": "eholk",
        "timestamp": 1639002750
    },
    {
        "content": "<p>Do you run into issues mixing Rust and C++ executors? I would expect problems with that even between different Rust executors, so doing it with C++ seems even more challenging.</p>",
        "id": 264230759,
        "sender_full_name": "eholk",
        "timestamp": 1639002797
    },
    {
        "content": "<p>It was challenging to get executor interop working, but it seems to be working well now :)</p>",
        "id": 264336848,
        "sender_full_name": "Patrick Walton",
        "timestamp": 1639071311
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"384014\">Patrick Walton</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Synchronous.20cancellation.20and.20C.2B.2B.20interop/near/264107905\">said</a>:</p>\n<blockquote>\n<p>The problem is that C++ coroutines generally want to run to completion (note that the standard doesn't specify this, but libraries generally assume it), while Rust futures can be dropped at any time</p>\n</blockquote>\n<p>I thought the spec mentioned it was undefined behavior if a C++ future wasn't run to completion? It sounds like I might have misunderstood?</p>",
        "id": 264741093,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1639416663
    },
    {
        "content": "<p>+1 to what <span class=\"user-mention\" data-user-id=\"421986\">@eholk</span> said, this is very cool. Annoying that you had to navigate this mismatch, but I'm glad you found something that actually works well.</p>",
        "id": 264965255,
        "sender_full_name": "tmandry",
        "timestamp": 1639543590
    }
]