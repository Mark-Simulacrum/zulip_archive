[
    {
        "content": "<p>Hi everyone! I have been spending a little time today looking at <a href=\"https://github.com/rust-lang/rust/issues/72956\">#72956</a>. I had thought when I first started looking at this that the “obvious” answer would be to revise <code>generator_interior.rs</code> to add a special-case for <code>ExprKind::Index</code> and force it to be treated like its desugared form.</p>",
        "id": 258484465,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634789066
    },
    {
        "content": "<p>However, after digging in a little bit, I am revisiting that assumption</p>",
        "id": 258484482,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634789085
    },
    {
        "content": "<p>In particular: The internal logic of <code>generator_interior.rs</code>, as part of its analysis, makes a call  <code>self.region_scope_tree.temporary_scope(expr.hir_id.local_id)</code></p>",
        "id": 258484635,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634789224
    },
    {
        "content": "<p>And the interesting thing I discovered, when I compare a version of the code that does <code>let _r = peach[0];</code> with another that does <code>let _r = drop(&amp;peach);</code> (where I’m pretty sure that drop call is the moral equivalent of <code>Index::index(&amp;peach, 0)</code>, but with less perturbation of the resulting AST and HIR id numbers), is that the version that uses <code>&amp;peach[0]</code> produces Remainder temporary scopes for <code>Peach</code> and <code>&amp;Peach</code>. The version that does <code>drop(&amp;peach)</code> merely produces a Node scope.</p>",
        "id": 258484862,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634789434
    },
    {
        "content": "<p>So: this raises a question to me: Why the broader scope for <code>&amp;peach[0]</code>, when it desugars to <code>Index::index(&amp;peach, 0)</code> …?</p>",
        "id": 258484898,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634789482
    },
    {
        "content": "<p>(at the same time, the scope code is so fundamental to so many things in the language/compiler, I am <em>very</em> hesitant to muck with it without a really solid grasp of the implications. Its been a long time since I’ve had my hands dirty in it…)</p>",
        "id": 258484985,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634789562
    },
    {
        "content": "<p>(I am currently guessing the answer to my question is going to lie in the implementation and history of <a href=\"https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler/rustc_passes/src/region.rs#L660\">record_rvalue_scope</a>…)</p>",
        "id": 258485274,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634789822
    },
    {
        "content": "<p>(Hmm. I wonder if there are some cases where this difference in scoping ends up being significant, e.g. when you have array expressions inline as the <code>recv</code> in<code>let _r = recv[idx];</code>/<code>let _r = recv.index(idx);</code> …)</p>",
        "id": 258485777,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634790255
    },
    {
        "content": "<p>Yep, it does matter: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9a3a0cb2ac1c7f1e1ac14129dd5a10ab\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=9a3a0cb2ac1c7f1e1ac14129dd5a10ab</a></p>",
        "id": 258486119,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634790602
    },
    {
        "content": "<p>I’ll go write a comment on the issue noting that these two forms are not 100% interchangable. (I don’t think that implies we should close the issue, though. We may be able to make our analysis more precise here.)</p>",
        "id": 258486307,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634790754
    },
    {
        "content": "<p>(also, my attempt to just YOLO it and try a  <a href=\"https://github.com/rust-lang/rust/blob/efd0483949496b067cd5f7569d1b28cd3d5d3c72/compiler/rustc_passes/src/region.rs#L660\">record_rvalue_scope</a> that didn’t treat <code>Index</code> this way immediately broke, due to code like this <code>let utf8 = &amp;mut [first_byte, 0, 0, 0][..utf8_len];</code> in rustc-demangle crate.)</p>",
        "id": 258488053,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634792284
    },
    {
        "content": "<p>New update: posted another, more narrowly focused, YOLO change to record_rvalue_scope: <a href=\"https://github.com/rust-lang/rust/issues/72956#issuecomment-948271239\">https://github.com/rust-lang/rust/issues/72956#issuecomment-948271239</a></p>",
        "id": 258491571,
        "sender_full_name": "pnkfelix",
        "timestamp": 1634795457
    },
    {
        "content": "<p>I at least don't see an obvious reason why that wouldn't work. If there does turn out to be some soundness issue in practice we should get an ICE due to the comparison with MIR analysis.</p>",
        "id": 258565628,
        "sender_full_name": "tmandry",
        "timestamp": 1634829789
    },
    {
        "content": "<p>okay. I guess I could just make a PR with it. (To be honest I'm not 100% sure why the change <em>works</em>; that is, I don't understand how in a block <code>{ let var = ... ; let _other = var[idx]; ... </code>, I don't understand how the temporary for the array-base of the index expression can end up with a longer scope than the let bound variable itself... I haven't had a chance to look more deeply into that question, though.)</p>",
        "id": 259306320,
        "sender_full_name": "pnkfelix",
        "timestamp": 1635368703
    }
]