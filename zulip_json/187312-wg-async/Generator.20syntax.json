[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119031\">@Esteban KÃ¼ber</span> is it ok to discuss/bikeshed <a href=\"https://estebank.github.io/rust-iterator-item-syntax.html\">https://estebank.github.io/rust-iterator-item-syntax.html</a> here? Or do you have a different preferred channel?</p>",
        "id": 261165338,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653121
    },
    {
        "content": "<p>No! Here is great.</p>",
        "id": 261165400,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653135
    },
    {
        "content": "<p>Cool!</p>",
        "id": 261165420,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653146
    },
    {
        "content": "<p>I do prefer to have at least a summary as a ticket on the repo, or ideally a PR :)</p>",
        "id": 261165428,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653152
    },
    {
        "content": "<p>The biggest value I see is in people actually <em>using</em> these different syntaxes</p>",
        "id": 261165464,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653171
    },
    {
        "content": "<p>So, I have a question, is it necessary to have the * in fn* as well as using <code>yields</code> instead of <code>return</code> or is it just a stylistic preference?</p>",
        "id": 261165537,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653217
    },
    {
        "content": "<p>(other than to avoid an explicit <code>yields ()</code>, I guess)</p>",
        "id": 261165626,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653262
    },
    {
        "content": "<p>None, other than taking a maximalist approach to syntax: the bigger the distance between two different features (in this case, functions and generators), the better for diagnostics, but in this case it might be enough to <em>only</em> have <code>yields</code> and make people be explicit about <code>yields ()</code>.</p>",
        "id": 261165862,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653405
    },
    {
        "content": "<p>There are some people that want the <code>-&gt;</code> syntax for <code>yields</code> though.</p>",
        "id": 261165872,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653422
    },
    {
        "content": "<p>That means using <code>-&gt;</code> instead of yields like in regular functions?</p>",
        "id": 261166017,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653499
    },
    {
        "content": "<p>(Whoops, I meant <code>-&gt;</code> not <code>return</code> in my question)</p>",
        "id": 261166052,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653523
    },
    {
        "content": "<p>I like <code>yields</code>, but I also like <code>throws</code> :-)</p>",
        "id": 261166106,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653566
    },
    {
        "content": "<p>hahaha, I think people would get even madder with me if I took that one away from them</p>",
        "id": 261166332,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653658
    },
    {
        "content": "<p><code>yeets</code> <span aria-label=\"eyes\" class=\"emoji emoji-1f440\" role=\"img\" title=\"eyes\">:eyes:</span></p>",
        "id": 261166354,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653671
    },
    {
        "content": "<p>lol, I meant for errors, not for generators :-)</p>",
        "id": 261166382,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653691
    },
    {
        "content": "<p>ah! I see, yes.</p>",
        "id": 261166391,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653701
    },
    {
        "content": "<p>I see what you mean, you're qualifying your sense of taste <span aria-label=\"big smile\" class=\"emoji emoji-1f604\" role=\"img\" title=\"big smile\">:big_smile:</span></p>",
        "id": 261166419,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653721
    },
    {
        "content": "<p>indeed, I believe it is a sense of taste that is not universally popular :-)</p>",
        "id": 261166510,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636653751
    },
    {
        "content": "<p>I started the <code>fn*</code> version as a joke, I have to say I kind of like it now.</p>",
        "id": 261166619,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653832
    },
    {
        "content": "<p>and I liked the idea of having a modifier as part of the header of the item, likely due to anchorage from the initial proposal of <code>gen foo</code> and <code>gen fn foo</code>, but the more I think about it, the trailing <code>yields Ty</code> serves it function...</p>",
        "id": 261166772,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653911
    },
    {
        "content": "<p>I've seen some people that missed the <code>*</code>, I wonder if they missed the <code>yields</code> too</p>",
        "id": 261166810,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653939
    },
    {
        "content": "<p>if you scan through code, I'm guessing you tend to look before the arguments for info of a function... but maybe I'm wrong</p>",
        "id": 261166879,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636653969
    },
    {
        "content": "<p>I wonder how important it is to notice? Python at least doesnâ€™t make any distinction in the signature</p>",
        "id": 261167089,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636654113
    },
    {
        "content": "<p>Not that they exact syntax needs to be settled right away, but IMO iterator/stream blocks are just as important as iterator/stream functions (if not more so).</p>",
        "id": 261167163,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636654157
    },
    {
        "content": "<p>I must admit to often missing the â€˜asyncâ€™ when reviewing code, so I am maybe not the best person to answer this question ðŸ˜€</p>",
        "id": 261167178,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1636654169
    },
    {
        "content": "<p>That makes a keyword-less version of the feature kinda hard.</p>",
        "id": 261167396,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636654290
    },
    {
        "content": "<p>(sorry to interject but I have a hard time letting go of generator/coroutine/iterator proposals lol)</p>",
        "id": 261167545,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636654369
    },
    {
        "content": "<p>Why is the expression version more important, if I can ask?</p>",
        "id": 261167616,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636654416
    },
    {
        "content": "<p>The trivial argument is that it parallels async and try blocks. But in general I think it is very nice to be able to capture data in iterators/streams vs pass it in explicitly. Obviously we could add iterator closures, but arguments act basically the same as captures in that case so it just feels sorta silly.</p>",
        "id": 261167975,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636654625
    },
    {
        "content": "<p>The underlying mechanism for iterator items supports captures, so I'd feel bad not allowing users to take advantage.</p>",
        "id": 261168209,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636654761
    },
    {
        "content": "<p>I agree, it's just that I'm trying to land the smallest possible unit on a path to stabilization that <em>doesn't preclude</em> later expansions.</p>",
        "id": 261168417,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636654895
    },
    {
        "content": "<p>For sync iterators, <code>from_fn</code> <em>already</em> serves the function of the closure generator relatively well, while the item version has the benefit of being able to be <em>very</em> specific on what the types involved are. I think that inference might be tricky when it comes to the closure version (despite nightly already having them).</p>",
        "id": 261168605,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636655003
    },
    {
        "content": "<p>I think we want to have them, but I fear they'll stop <em>anything</em> landing if we don't focus on a specific part :)</p>",
        "id": 261168648,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636655038
    },
    {
        "content": "<p>Totally! I would personally focus on blocks first and do functions later but that is just my style. I just wanted to throw it out there that an <code>fn*</code> or implicit syntax conflicts roughly with obvious future expansions in my mind.</p>",
        "id": 261168992,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636655240
    },
    {
        "content": "<p>Definitely a bikeshed though.</p>",
        "id": 261169032,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636655270
    },
    {
        "content": "<p>I have lots of options on paint color <span aria-label=\"grinning face with smiling eyes\" class=\"emoji emoji-1f601\" role=\"img\" title=\"grinning face with smiling eyes\">:grinning_face_with_smiling_eyes:</span></p>",
        "id": 261169103,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636655297
    },
    {
        "content": "<p>I am very much <em>against</em> implicit syntax for this</p>",
        "id": 261169763,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636655657
    },
    {
        "content": "<p>I'm not sure what <code>fn*</code> precludes, but that's why I created the proc-macro, so that we can explore these in public :)</p>",
        "id": 261169798,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636655682
    },
    {
        "content": "<p>It think precludes any sort of iterator blocks in the future. A <code>gen</code> keyword does not.</p>",
        "id": 261170176,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636655888
    },
    {
        "content": "<p>Adding a whole new keyword requires a new edition, it might still be worth it, but it is a consideration</p>",
        "id": 261170393,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636656010
    },
    {
        "content": "<p>Totally</p>",
        "id": 261170410,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636656022
    },
    {
        "content": "<p>I do agree that from_fn + a coroutine syntax works pretty well for the capturing case, so maybe we don't really need to worry about iterator blocks at all. But at this point I am not optimistic about the language getting coroutines done in the near future.</p>",
        "id": 261170444,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636656044
    },
    {
        "content": "<p>I feel bad I'm bikeshedding when you specifically created the proc_macro so people can show rather than tell. I'll call it quits here and go make a demo if you want.</p>",
        "id": 261170802,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636656292
    },
    {
        "content": "<p>I want to make sure these convos are not left in chat only, I want that repo to be self-contained with enough context for answering these questions to t-lang.</p>",
        "id": 261172897,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636657510
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"119031\">Esteban KÃ¼ber</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20syntax/near/261170393\">said</a>:</p>\n<blockquote>\n<p>Adding a whole new keyword requires a new edition, it might still be worth it, but it is a consideration</p>\n</blockquote>\n<p>Actually adding the keyword requires an edition, but we can start with <code>k#gen</code>.</p>",
        "id": 261195221,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636672753
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119031\">@Esteban KÃ¼ber</span> Also, I like the idea of having a keyword like <code>gen fn</code>, rather than <code>fn*</code>, because that naturally extends to <code>gen || { ... }</code> and possibly <code>gen { ... }</code>.</p>",
        "id": 261195252,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636672789
    },
    {
        "content": "<p>(Also, we've talked about letting people opt-in to new keywords, prior to an edition boundary making it available by default.)</p>",
        "id": 261195355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636672884
    },
    {
        "content": "<p>So you could write <code>k#gen</code>, or you could write <code>#![keywords(gen)]</code> ( <span aria-label=\"bike\" class=\"emoji emoji-1f6b2\" role=\"img\" title=\"bike\">:bike:</span> <span aria-label=\"house\" class=\"emoji emoji-1f3e0\" role=\"img\" title=\"house\">:house:</span> <span aria-label=\"painting\" class=\"emoji emoji-1f3a8\" role=\"img\" title=\"painting\">:painting:</span>) at the top of your module and then write <code>gen</code>.</p>",
        "id": 261195428,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636672944
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119031\">@Esteban KÃ¼ber</span> Does that make the idea of a keyword more appealing?</p>",
        "id": 261195469,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673002
    },
    {
        "content": "<p>Oh! That's an interesting idea that I hadn't heard of</p>",
        "id": 261195483,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636673027
    },
    {
        "content": "<p>it absolutely changes my opinion</p>",
        "id": 261195492,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636673036
    },
    {
        "content": "<p>for things like <code>gen</code> I can treat it in the parser and suggest <code>k#gen</code> automatically, but that doesn't please by aesthetic sensitivities, but being able to opt-into the new keywords flips the equation in my eyes</p>",
        "id": 261195569,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636673095
    },
    {
        "content": "<p>Yeah, I think you'd just emit a suggestion to add the opt-in to the module.</p>",
        "id": 261195603,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673127
    },
    {
        "content": "<p>On a different note, I wonder if we could define a shorthand syntax that would allow <code>-&gt; impl Iterator&lt;T&gt;</code> rather than <code>-&gt; impl Iterator&lt;Item = T&gt;</code>.</p>",
        "id": 261195684,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673203
    },
    {
        "content": "<p>I think that'd feel <em>substantially</em> less verbose.</p>",
        "id": 261195702,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673225
    },
    {
        "content": "<p>I was really wishing for <code>Iterator&lt;T&gt;</code> just minutes ago when sketching this out.</p>",
        "id": 261195724,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673254
    },
    {
        "content": "<p>I don't know how you'd motivate it in Rust, but someone coming from Python for example probably just expects that to work in any case.</p>",
        "id": 261195777,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673288
    },
    {
        "content": "<p>It could be <code>fn thing() -&gt; Iterator!&lt;i32&gt;</code> I guess, but that seems super ugly.</p>",
        "id": 261195813,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222520\">Sam Sartor</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20syntax/near/261195777\">said</a>:</p>\n<blockquote>\n<p>I don't know how you'd motivate it in Rust, but someone coming from Python for example probably just expects that to work in any case.</p>\n</blockquote>\n<p>I have no problem with the idea of \"if a trait has exactly one associated type, and zero generic arguments, you may abbreviate <code>Trait&lt;typename=T&gt;</code> as <code>Trait&lt;T&gt;</code>\".</p>",
        "id": 261195821,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673362
    },
    {
        "content": "<p>(and if there's any ambiguity, you go back to having to write <code>typename=</code>.)</p>",
        "id": 261195837,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673382
    },
    {
        "content": "<p>It would be sooo nice with Future too</p>",
        "id": 261195892,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673410
    },
    {
        "content": "<p>Yup.</p>",
        "id": 261195895,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673414
    },
    {
        "content": "<p>If someone feels sufficiently motivated to follow through with an MCP writeup, I'll happily second it.</p>",
        "id": 261195911,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673429
    },
    {
        "content": "<p>Just for that narrow case (single associated type, no generic arguments).</p>",
        "id": 261195936,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673459
    },
    {
        "content": "<p>Hmmm. One alternative that might be even better: make it opt-in by the trait.</p>",
        "id": 261195965,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673489
    },
    {
        "content": "<p>Then if you think you might add more arguments in the future (with defaults, so that they might be compatible), you could avoid opting in.</p>",
        "id": 261195975,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673519
    },
    {
        "content": "<p>Yah, I was just wondering if it should be an attribute or something.</p>",
        "id": 261196029,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673543
    },
    {
        "content": "<p>I'd love to put together an MCP!</p>",
        "id": 261196045,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673558
    },
    {
        "content": "<p>My big question is would this increase new user confusion with associated types or decrease it?</p>",
        "id": 261196153,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673673
    },
    {
        "content": "<p>We may want to check with people who teach Rust, but I suspect they may appreciate the ability to defer discussion of associated types.</p>",
        "id": 261196175,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673708
    },
    {
        "content": "<p>Regarding expectations, I've been beating the drum of \"use errors to tell people how their expectation diverged, and if we know what they wanted, recover to continue evaluating and suggest the right auto-applicable code\"</p>",
        "id": 261196181,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636673713
    },
    {
        "content": "<p>I'm slightly concerned about changing the trait suddenly breaking things (which is expected for type params, but nor for assoc types). That changes the stability guarantees that APIs have.</p>",
        "id": 261196248,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636673764
    },
    {
        "content": "<p>Might not be a show-stopper, but it's something to consider.</p>",
        "id": 261196258,
        "sender_full_name": "Esteban KÃ¼ber",
        "timestamp": 1636673781
    },
    {
        "content": "<p>The opt-in would help with that.</p>",
        "id": 261196271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673796
    },
    {
        "content": "<p>Vague idea for initial syntax bikeshed: <code>#[positional]</code></p>",
        "id": 261196293,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673832
    },
    {
        "content": "<p>(since it turns what looks like a named argument into a positional one)</p>",
        "id": 261196302,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673847
    },
    {
        "content": "<p>I like that. I don't see a reason to limit it to 1 associated type at that point either. Might as well give the attribute full control.</p>",
        "id": 261196361,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636673890
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222520\">@Sam Sartor</span> Since it's opt-in, that's true.</p>",
        "id": 261196410,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673985
    },
    {
        "content": "<p>Presumably, then, they become positional arguments in the order they appear.</p>",
        "id": 261196422,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636673998
    },
    {
        "content": "<p>I <em>do</em> think, however, it should be disallowed for any trait that has generic arguments.</p>",
        "id": 261196464,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674013
    },
    {
        "content": "<p>In theory you could arrange to put them in a specific order, but I think that's likely to lead to confusion.</p>",
        "id": 261196482,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674037
    },
    {
        "content": "<p>Agreed. It is technically doable but has no wholesome usecases that I can think of</p>",
        "id": 261196506,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636674073
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"222520\">Sam Sartor</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20syntax/near/261196506\">said</a>:</p>\n<blockquote>\n<p>Agreed. It is technically doable but has no wholesome usecases that I can think of</p>\n</blockquote>\n<p>I love the phrase \"no wholesome use cases\".</p>",
        "id": 261196536,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674091
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222520\">@Sam Sartor</span> On a related note, we've been experimenting in the lang team with allowing more experimentation in nightly when doing so doesn't commit us to any stable expectations. So I think a seconded MCP would be sufficient to start <em>implementing</em> it in the nightly compiler.</p>",
        "id": 261196610,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674147
    },
    {
        "content": "<p>Rough sketch of how this could go:<br>\nFile MCP -&gt; second MCP -&gt; implement in nightly -&gt; experiment in nightly for a while -&gt; decide if we need an RFC -&gt; FCP to stabilize</p>",
        "id": 261196722,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674252
    },
    {
        "content": "<p>(We might also opt to stabilize <code>Iterator&lt;T&gt;</code> before stabilizing <code>#[positional]</code> itself, though I don't think we need to.)</p>",
        "id": 261196735,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674275
    },
    {
        "content": "<p>Hmmm, I sorta like that! It does seem like more and more steps keep getting added to the feature proposal process over the years, to better filter stuff out. But often that means that discussions just get bogged down without a concrete implementation to look at.</p>",
        "id": 261196759,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636674310
    },
    {
        "content": "<p>Like, coroutines have been in that boat for ages now. A nightly experiment would have done a lot to sort it out.</p>",
        "id": 261196856,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636674395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222520\">@Sam Sartor</span> Yeah, when we first introduced the MCP process it felt like a net increase in complexity for proposers; we're trying to make it a net <em>decrease</em>.</p>",
        "id": 261196870,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674408
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20syntax/near/261196464\">said</a>:</p>\n<blockquote>\n<p>I <em>do</em> think, however, it should be disallowed for any trait that has generic arguments.</p>\n</blockquote>\n<p>This is interesting to me, because I have a very strong intuition that associated types go after generic arguments, and would be surprised if it was written any other way, so I don't see an issue with allowing generic args before the \"positional\" args</p>",
        "id": 261196962,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636674489
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> I feel like allowing that might close off some opportunities, such as supporting named generic arguments, or improving the ability to evolve generics over time with defaults.</p>",
        "id": 261197029,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674575
    },
    {
        "content": "<p>I'm not saying we <em>couldn't</em> support it, but I'd want to see a good use case.</p>",
        "id": 261197041,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674587
    },
    {
        "content": "<p>I agree that <em>default</em> generics should be incompatible with positional args, which suggests that positional args really ought to be opt in</p>",
        "id": 261197123,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636674639
    },
    {
        "content": "<p>but besides that, you can think of positional args as another kind of default generic syntax</p>",
        "id": 261197155,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636674682
    },
    {
        "content": "<p>I don't think that named generic arguments are inhibited by positional args, you just need some rule for how to handle the mixture, same as any other language that does optionally named function arguments</p>",
        "id": 261197246,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636674748
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20syntax/near/261197246\">said</a>:</p>\n<blockquote>\n<p>I don't think that named generic arguments are inhibited by positional args, you just need some rule for how to handle the mixture, same as any other language that does optionally named function arguments</p>\n</blockquote>\n<p>Sure. But I'd propose that, in lieu of designing that rule, we prohibit the combination for now. :)</p>",
        "id": 261197271,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674785
    },
    {
        "content": "<p>We have an important and pervasive use case for <code>Iterator&lt;T&gt;</code> and <code>Future&lt;T&gt;</code>. I don't want to delay that while designing a rule to handle complex combinations of generic arguments and associated types.</p>",
        "id": 261197307,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674823
    },
    {
        "content": "<p>well, it's not hard to prohibit, considering that named generic args don't even exist yet</p>",
        "id": 261197314,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636674830
    },
    {
        "content": "<p>(by which I mean type parameters referred by name, not associated types)</p>",
        "id": 261197373,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1636674872
    },
    {
        "content": "<p>I mean, I'd prefer to prohibit the combination with <em>any</em> generic arguments, for now, to bypass several potential design traps that seem likely to produce extended discussions.</p>",
        "id": 261197374,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674872
    },
    {
        "content": "<p>(Again, no opposition to the combination, but I'd like to conserve design bandwidth.)</p>",
        "id": 261197391,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636674892
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20syntax/near/261195684\">said</a>:</p>\n<blockquote>\n<p>On a different note, I wonder if we could define a shorthand syntax that would allow <code>-&gt; impl Iterator&lt;T&gt;</code> rather than <code>-&gt; impl Iterator&lt;Item = T&gt;</code>.</p>\n</blockquote>\n<p>See <a href=\"https://docs.rs/async_fn/0.0.2/async_fn/trait.Fut.html\">https://docs.rs/async_fn/0.0.2/async_fn/trait.Fut.html</a></p>\n<p>The above, btw, proves that your whole suggestion, <strong>at the cost of distinct names</strong>, could be covered by <code>trait</code> aliases:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Iter</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Fut</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>or use a module to handle the naming issue:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">mod</span> <span class=\"nn\">generic_trait_shorthands</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">future</span>::<span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span>::<span class=\"n\">core</span>::<span class=\"n\">iter</span>::<span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>so as to do:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span>::<span class=\"n\">generic_trait_shorthands</span>::<span class=\"p\">{</span><span class=\"n\">Future</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261200344,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1636677612
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> Absolutely, but I'm not sure if that makes the proposal unnecessary.</p>",
        "id": 261200753,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636678126
    },
    {
        "content": "<p>Not least of which that it'd be nice to support both <code>Iterator&lt;T&gt;</code> and <code>Iterator&lt;Item = T&gt;</code>.</p>",
        "id": 261200771,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1636678144
    },
    {
        "content": "<p>What do you all think? <a href=\"https://github.com/rust-lang/lang-team/issues/126\">https://github.com/rust-lang/lang-team/issues/126</a></p>",
        "id": 261202121,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1636679672
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119031\">@Esteban KÃ¼ber</span> another question: I'm a bit unclear on the terminology from the blog post, in particular the difference (if any) between \"iterator items\" and \"generators\". AIUI, currently there is unstable syntax for generator closures - are you proposing keeping that around or removing/changing it? You are proposing iterator items (with the strawman <code>fn*</code> syntax), are these the only kind of generator functions we would support? Or would there be syntax for generator functions which are not iterator items too? Is there (or will you propose) syntax for invoking generators which are not iterators?</p>",
        "id": 261788982,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637158412
    },
    {
        "content": "<p>And on a terminology note, AIUI, using \"coroutine\" to mean an async or parallel generator is a Python quirk. There seem to be many definitions for coroutines floating around so it's probably best avoiding the term altogether. But using it to mean an async generator seems to be begging for confusion</p>",
        "id": 261790911,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637159200
    },
    {
        "content": "<p>In particular, for some definitions, I think the Generator trait defines a coroutine rather than a strict generator :-|</p>",
        "id": 261791056,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637159257
    },
    {
        "content": "<p>I'll mention that in <a href=\"https://lang-team.rust-lang.org/design_notes/general_coroutines.html\">the generalizing coroutines notes</a> I used \"generator\" strictly to mean any syntax which produces an <code>impl Iterator</code> or <code>impl Stream</code> and \"corountine\" to mean the syntax which underlies futures/generators (needs resume arguments and arbitrary return/yield types). But whatever terminology we use there are tradeoffs because \"generator\" is very overloaded: referring both to the current unstable feature which supports futures and a number of proposed Iterator/Stream syntaxes. I guess that is the reason why this proposal calls them \"iterator items\". But unfortunately the obvious keyword to reserve for an iterator item is \"gen\"...</p>",
        "id": 261792782,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637159972
    },
    {
        "content": "<p>I've been doing my best not to shill yield closures here. But since I just linked the notes, here is the view from 30,000ft:</p>\n<ul>\n<li>Rust  needs some coroutine syntax somewhere which receives resume arguments</li>\n<li>The most ergonomic generator syntax for <code>impl Stream</code> can not also take resume arguments</li>\n</ul>",
        "id": 261795025,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637160917
    },
    {
        "content": "<p>\"Rust needs some coroutine syntax somewhere which receives resume arguments\" - why?</p>",
        "id": 261795190,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637160988
    },
    {
        "content": "<p>In my mind there is now way around having two separate features for the two different cases even if one is just a macro. Hence, it is a good idea for this proposal to focus strictly on <code>impl Iterator</code>/<code>impl Stream</code> and we just need to make sure it doesn't preclude stabilizing some form of general coroutine in the future.</p>",
        "id": 261795263,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637161018
    },
    {
        "content": "<p>\"The most ergonomic generator syntax for impl Stream can not also take resume arguments\" I'm confused by this statement - does \"can not\" here mean \"must not\" or \"does not\"?</p>",
        "id": 261795285,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637161034
    },
    {
        "content": "<p>Sorry, I meant why does Rust need the flexibility of generators which take arguments? What are the motivating use cases?</p>",
        "id": 261795444,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637161099
    },
    {
        "content": "<p>Gosh, I really just need to write a whole blog post on resume arguments at this point. But pending that:<br>\nOther programming languages can easily pass data by sharing a mutable reference between the inside of the coroutine and the outside world. Rust does not like that. This can be seen with the early implementation of <code>async { }</code>, which passed the <code>&amp;mut Context</code> via a thread_local and UnsafeCell (gross).  Futures got a significant elegance and performance bump with <a href=\"https://github.com/rust-lang/rust/pull/68524\">https://github.com/rust-lang/rust/pull/68524</a>, which allowed the <code>&amp;mut Context</code> to be passed to the resume function directly. This could be a one-off thing inside the compiler just to support futures, but users of Rust are often in the same boat. <a href=\"https://docs.rs/futures/0.3.17/futures/io/trait.AsyncRead.html\"><code>AsyncRead</code></a> is the first example which springs to mind: it receives the buffer on each resume. I can take the time to create some proper user stories if you want.</p>",
        "id": 261796335,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637161465
    },
    {
        "content": "<p>The problem with adding user-defined resume arguments to any syntax which produces <code>impl Stream</code> is the <code>&amp;mut Context</code> resume argument. It conflicts fundamentally with those user-defined resume arguments. Conceptually: should the user-defined resume arguments be passed on every call to <code>poll_next</code> along with <code>&amp;mut Context</code>, or should the user-defined resume arguments be passed once per yield to produce a <code>impl Future</code> which then receives the async context separately? If you dig deeper into either option it gets nasty.</p>",
        "id": 261796971,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637161737
    },
    {
        "content": "<p>That being said, any well-designed general coroutine syntax can be used to author Stream quite easily, with just a little bit of async-context-juggling and type conversion boilerplate. But Rust usually tries to avoid exposing <code>&amp;mut Context</code> when possible.</p>",
        "id": 261797101,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637161799
    },
    {
        "content": "<p>Hence, there are good syntaxes for streams and good syntaxes for resume aguments but no good syntax for both. I admit the two syntaxes could be quite similar on their faces to the point that users might not notice the distinction, but the distinction must be there.</p>",
        "id": 261798821,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637162440
    },
    {
        "content": "<p>Thanks for the explanations! Will digest ...</p>",
        "id": 261809417,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637166561
    },
    {
        "content": "<p>Yah, that discussion is a heck of a tangent away from \"what terminology is in use?\" and should really happen at a future time and place.</p>",
        "id": 261810153,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637166860
    },
    {
        "content": "<p>Hmm, does an iterator item desugar to a function which returns a generator object (analogous to async functions) or is the function itself the generator?</p>",
        "id": 261823839,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637172362
    },
    {
        "content": "<p>And what does <code>return</code> mean in an iterator item?</p>",
        "id": 261823962,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637172395
    },
    {
        "content": "<p>In this proposal it is the former, analogous to async functions. Generator blocks (i.e. <code>gen { ... }</code>) would give you a generator object directly.</p>",
        "id": 261824046,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637172429
    },
    {
        "content": "<p>hmm, I guess that answers my generator block vs generator lambda question</p>",
        "id": 261824199,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637172478
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async-foundations/topic/Generator.20syntax/near/261823962\">said</a>:</p>\n<blockquote>\n<p>And what does <code>return</code> mean in an iterator item?</p>\n</blockquote>\n<p>Upon returning, the <code>next</code> impl will produce None and the underlying coroutine enters a poisoned state.</p>",
        "id": 261824257,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637172485
    },
    {
        "content": "<p>Same as a async function really, but with Poll::Ready(T) instead of None.</p>",
        "id": 261824288,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637172501
    },
    {
        "content": "<p>right, makes sense</p>",
        "id": 261824341,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637172526
    },
    {
        "content": "<p>If we were to desugar into MCP-49-style yield closures, iterator items would look like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">gen</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">len</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kr\">yield</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// BECOMES</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">len</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"nb\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">iter</span>::<span class=\"n\">from_fn</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">||</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">yield</span><span class=\"w\"> </span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"nb\">None</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261824962,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637172779
    },
    {
        "content": "<p>Or to illustrate my tangent above, a stream item will look like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">async</span><span class=\"w\"> </span><span class=\"n\">gen</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">len</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kr\">yield</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// BECOMES</span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">len</span>: <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">Output</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">impl</span><span class=\"w\"> </span><span class=\"n\">Stream</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span><span class=\"o\">=</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">stream</span>::<span class=\"n\">from_fn</span><span class=\"p\">(</span><span class=\"k\">move</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">ctx</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">.</span><span class=\"k\">await</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">ctx</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">i</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"o\">..</span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kr\">yield</span><span class=\"w\"> </span><span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"nb\">Some</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"nb\">None</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">})</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 261825642,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637173100
    },
    {
        "content": "<p>Although I should mention that the current iterator items prototype includes a way of specifying  size_hint, which the desugars above don't show.</p>",
        "id": 261826102,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637173286
    },
    {
        "content": "<p>In Estebanâ€˜s doc?</p>",
        "id": 261827293,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637173797
    },
    {
        "content": "<p><a href=\"https://github.com/estebank/iterator_item/blob/master/tests/gen_2996.rs#L6\">https://github.com/estebank/iterator_item/blob/master/tests/gen_2996.rs#L6</a></p>",
        "id": 261827519,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637173877
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 261911834,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1637232950
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"222520\">@Sam Sartor</span> <span class=\"user-mention\" data-user-id=\"116883\">@tmandry</span> and I have actually been thinking about a more general solution to this problem of \"threading <code>&amp;mut</code> context around\", we call them \"with clauses\" or \"capabilities\"</p>",
        "id": 261942508,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249369
    },
    {
        "content": "<p>there's a somewhat dated explanation <a href=\"https://rust-lang.github.io/async-fundamentals-initiative/evaluation/design/with_clauses.html\">here</a></p>",
        "id": 261942669,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249440
    },
    {
        "content": "<p>I should probably take some time and bring it up to date</p>",
        "id": 261942680,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249447
    },
    {
        "content": "<p>in any case, I think the only sensible interpretation (although not the only <em>possible one</em>) around generators is that with clauses would be \"resupplied\" after each yield</p>",
        "id": 261942808,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249512
    },
    {
        "content": "<p>but I've been wanting to put more thought into that</p>",
        "id": 261942815,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249516
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"211722\">@Yoshua Wuyts [he/they]</span> was pointing out to me the connection to effects, which seems right.</p>",
        "id": 261942878,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249528
    },
    {
        "content": "<p>Hmmmm, that is definitely a very interesting version of this which I'll need to think about more. It is also a feature I've wanted desperately in other contexts.</p>",
        "id": 261943134,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637249649
    },
    {
        "content": "<p>Yes, I want it so bad.</p>",
        "id": 261943258,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249716
    },
    {
        "content": "<p>in the limit, you could imagine threading around an async runtime this way -- or all of std!</p>",
        "id": 261943346,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249757
    },
    {
        "content": "<p>that would push us into territory like <a href=\"https://blog.sunfishcode.online/introducing-cap-std/\">cap-std</a>, hence the reason I've started calling these capabilities</p>",
        "id": 261943426,
        "sender_full_name": "nikomatsakis",
        "timestamp": 1637249784
    },
    {
        "content": "<p>Certainly it is not necessary for general coroutines. But is opens up some interesting possibilities, especially if traits like Iterator/Future have default \"associated clauses\".</p>",
        "id": 261943430,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637249787
    },
    {
        "content": "<p>Actix would love it because you could get a mutable reference to your actor by putting a with clause on your async blocks/fns.</p>",
        "id": 261943587,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637249868
    },
    {
        "content": "<p>(which would be resupplied on resume)</p>",
        "id": 261943717,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1637249906
    }
]