[
    {
        "content": "<p>I remember there being some discussion of having <code>async fn read</code> vs <code>fn poll_read</code> (for Read and likewise for Write traits), but I can't find it now. Does anyone have a link? And more generally, does anyone have thoughts on this question?</p>",
        "id": 268291972,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642437176
    },
    {
        "content": "<p>Thoughts beyond <code>async fn</code> being obviously nicer, but dependent on async traits being implemented</p>",
        "id": 268291991,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642437199
    },
    {
        "content": "<p>Is the idea that <code>poll_read</code> would let us have <code>AsyncRead</code>/<code>Write</code> without waiting for <code>async fn</code> in traits?</p>",
        "id": 268293855,
        "sender_full_name": "eholk",
        "timestamp": 1642438388
    },
    {
        "content": "<p>Yeah, the current traits in <a href=\"http://futures.io\">futures.io</a> and Tokio both have the polling versions</p>",
        "id": 268294424,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642438720
    },
    {
        "content": "<p>I seem to remember there is a performance advantage too, though I can't remember the details. Something about multiple calls or multiple layers of delegation avoiding multiple initialisation costs?</p>",
        "id": 268294516,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642438777
    },
    {
        "content": "<p>I mentioned that</p>",
        "id": 268299248,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642441844
    },
    {
        "content": "<p>That only applies if read returns a boxed future</p>",
        "id": 268299276,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642441862
    },
    {
        "content": "<p>It could work with 'inline' async traits</p>",
        "id": 268299501,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642442037
    },
    {
        "content": "<p>There's some design notes here: <a href=\"https://rust-lang.github.io/wg-async-foundations/vision/roadmap/portable/read_write.html\">https://rust-lang.github.io/wg-async-foundations/vision/roadmap/portable/read_write.html</a></p>",
        "id": 268299777,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642442232
    },
    {
        "content": "<p>Right, so I guess that depends on the eventual design of async in dyn Trait</p>",
        "id": 268301504,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642443346
    },
    {
        "content": "<p>But the downside is that if you have &amp;dyn Read, then the async fn requires boxing of the returned future but the poll_read version does not, and for vectored reads or just where you need to do multiple reads, that might add up to a lot of boxing overhead</p>",
        "id": 268301690,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642443484
    },
    {
        "content": "<p>The idea of an inline async trait is that the future is stored in the trait object</p>",
        "id": 268301947,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642443691
    },
    {
        "content": "<p>So no need to box</p>",
        "id": 268301956,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642443700
    },
    {
        "content": "<p>Right <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 268302673,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642444210
    },
    {
        "content": "<p>To me the \"Permitting simultaneous reads/writes\" problem seems more important than the problems about boxing.</p>",
        "id": 268303151,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1642444570
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> This is also an issue of usability. It's much easier to write an async function than something returning Poll. Using async fn helps work towards a world of \"if you're not writing an async framework, you never need to deal with Poll directly\".</p>",
        "id": 268303353,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642444724
    },
    {
        "content": "<p>Yeah, totally agree, that’s what I meant by nicer</p>",
        "id": 268303439,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642444795
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"218683\">@Alice Ryhl</span> I thought that is mostly orthogonal to poll vs async fns? Is there a connection?</p>",
        "id": 268303575,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642444881
    },
    {
        "content": "<p>Well, if the async fn borrows the IO resource mutably, then stuff like <a href=\"https://docs.rs/tokio/latest/tokio/io/fn.split.html\"><code>tokio::io::split</code></a> can't be implemented for the async fn version.</p>",
        "id": 268303677,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1642444939
    },
    {
        "content": "<p>I would expect there to be implementations that need to borrow the resource mutably in order to function. A buffer, for instance. How would you split the read and write impls backed by a Vec?</p>",
        "id": 268303790,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642445041
    },
    {
        "content": "<p>Well, point is that with poll fns, such a utility is no problem even if they mutably borrow the IO resource. You can just interleave the calls to poll_read and poll_write with a mutex or similar.</p>",
        "id": 268303892,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1642445118
    },
    {
        "content": "<p>Ah, I see</p>",
        "id": 268303904,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642445135
    },
    {
        "content": "<p>(You answered my question before I could finish typing it <span aria-label=\"heart\" class=\"emoji emoji-2764\" role=\"img\" title=\"heart\">:heart:</span>️)</p>",
        "id": 268304030,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642445222
    },
    {
        "content": "<blockquote>\n<p>Using async fn helps work towards a world of \"if you're not writing an async framework, you never need to deal with Poll directly\"</p>\n</blockquote>\n<p>Users would interact with an <code>async fn read</code>, but runtimes would provide the <code>fn poll_ready</code>.</p>",
        "id": 268304227,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642445358
    },
    {
        "content": "<p>Similar to how <code>Stream</code> has <code>poll_next</code> and <code>async fn next</code> (although the latter hasn't actually been added yet).</p>",
        "id": 268304260,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642445385
    },
    {
        "content": "<p>Without prejudicing the poll approach, I think there is overhead for users in the methods just exisiting, even if they don’t have to be used. And I would expect many users will want to impl ReadWrite, not just the runtimes</p>",
        "id": 268304630,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642445629
    },
    {
        "content": "<p>Yeah, creating wrapper streams/asyncio types is a common question, and the answer usually is \"just add an inherent async fn\".</p>",
        "id": 268304759,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642445698
    },
    {
        "content": "<p>Another question is how these traits interact with io-uring.</p>",
        "id": 268304795,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642445719
    },
    {
        "content": "<p>Which requires that pointers to a buffer are stable.</p>",
        "id": 268304902,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642445777
    },
    {
        "content": "<p>That is indeed another question! One question at a time though - I think this one and simultaneous read/write are enough to. E going on with <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 268304940,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642445811
    },
    {
        "content": "<p>The more I see comparisons of io_uring and async, the more I wonder if io_uring would do best in an environment that doesn't look quite like our async underneath. Less poll, more notify.</p>",
        "id": 268307276,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642447311
    },
    {
        "content": "<p>I feel like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">AsyncSplit</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">ReadHalf</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span>: <span class=\"nc\">AsyncRead</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">WriteHalf</span><span class=\"o\">&lt;'</span><span class=\"na\">a</span><span class=\"o\">&gt;</span>: <span class=\"nc\">AsyncWrite</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">split</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">ReadHalf</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">WriteHalf</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Is the best API for permitting simultaneous read/writes.</p>",
        "id": 268307658,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642447555
    },
    {
        "content": "<p>Standardizing <code>&amp;T: AsyncRead</code> could be a footgun for types that only permit a single concurrent reader/writer (<code>tokio::TcpStream</code>).</p>",
        "id": 268307760,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642447611
    },
    {
        "content": "<p>The readiness API doesn't work really at all for io-uring.</p>",
        "id": 268307797,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642447648
    },
    {
        "content": "<p>And this way, types that don't support concurrent I/O (like <code>Vec</code>) simply don't implement the split trait.</p>",
        "id": 268307877,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642447685
    },
    {
        "content": "<p>I think the main question would be how to support borrowed/owned versions of halves.</p>",
        "id": 268308038,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642447815
    },
    {
        "content": "<p>Maybe the borrowed form is not useful enough to be included, or maybe it would need to look more like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">AsyncSplit</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// ...</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">as_split</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">ReadHalf</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">WriteHalf</span><span class=\"o\">&lt;'</span><span class=\"nb\">_</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">into_split</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"p\">(</span><span class=\"bp\">Self</span>::<span class=\"n\">OwnedReadHalf</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"bp\">Self</span>::<span class=\"n\">OwnedWriteHalf</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 268308229,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642447946
    },
    {
        "content": "<p>I'll mention that yield closures make poll functions really easy to implement. Although it would help to have some syntax sugar around Pin projection and an await macro.</p>",
        "id": 268311873,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1642450638
    },
    {
        "content": "<p>Here is an example I just threw together if anyone is curious: <a href=\"https://gitlab.com/-/snippets/2237073\">https://gitlab.com/-/snippets/2237073</a></p>",
        "id": 268314658,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1642453083
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/89780\"><code>.ready()?</code></a> is essentially <code>.await</code> for poll methods.</p>",
        "id": 268315972,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642454181
    },
    {
        "content": "<p>I'm this context I'm using <code>$x.await!($y)</code> as a shorthand for roughly</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">loop</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"cp\">$x</span><span class=\"p\">(</span><span class=\"cp\">$y</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Pending</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"kr\">yield</span><span class=\"w\"> </span><span class=\"n\">Pending</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Ready</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"k\">break</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Which isn't quite possible with the try syntax alone.</p>",
        "id": 268317845,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1642456066
    },
    {
        "content": "<p>I also have an example of yield closures being used with async drop to do io-uring stuff, but I don't know if I really finished it.</p>",
        "id": 268317964,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1642456190
    },
    {
        "content": "<p>My base64 example is a little artificial, but I like how it highlights the difficulties of maintaining state between <code>read</code> calls, which I think is a pretty common case for AsyncRead.</p>",
        "id": 268318187,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1642456337
    },
    {
        "content": "<p>Yield closures are nice for that versus having an async function which starts from scratch each call. But it all just needs to kind of get played around with.</p>",
        "id": 268318231,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1642456378
    },
    {
        "content": "<p>It'd be really nice to have some sort of yield method semantics, where the generator state transform gets run on the impl'd type itself. But I don't really know how that would interact with the usual separation of type and impl.</p>",
        "id": 268318616,
        "sender_full_name": "Sam Sartor",
        "timestamp": 1642456737
    },
    {
        "content": "<p>I like the idea of having a dedicated trait or traits for splitting, so that some things don't have to implement it if it doesn't make sense.</p>",
        "id": 268329154,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642466359
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> could you expand on \"Standardizing &amp;T: AsyncRead could be a footgun for types that only permit a single concurrent reader/writer (tokio::TcpStream).\" please? I would expect you simply would not implement AsyncRead for &amp;TcpStream. Are you saying you want to permit simultaneous read and write but not simultaneous read?</p>",
        "id": 268368655,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642500454
    },
    {
        "content": "<p>My current preference is to implement AsyncRead/AsyncWrite for &amp; types. That follows the sync libs most closely and is simplest (no new traits, etc). I'm keen to understand any problems with that approach (and in particular why the trade off is different for the async case vs the existing sync code).</p>",
        "id": 268368875,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642500566
    },
    {
        "content": "<p>Well, the reason Tokio doesn't implement AsyncRead/AsyncWrite for <code>&amp;TcpStream</code> and friends is that this is incompatible with a poll-based trait.</p>",
        "id": 268372157,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1642502413
    },
    {
        "content": "<p>Because you generally only wake the waker from the most recent poll call, but if multiple tasks are making such calls, then you can't tell the difference between multiple poll calls from within one task, and multiple poll calls from different tasks</p>",
        "id": 268372248,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1642502471
    },
    {
        "content": "<p>So you don't want multiple readers because it could lead to unfair scheduling of the tasks which are reading? But since read and write are different, the wakers can be differentiated? Or scheduling is not  a problem in practice?</p>",
        "id": 268376685,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642505038
    },
    {
        "content": "<p>Is that still a problem with async fns? It seems like it ought to be?</p>",
        "id": 268376841,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642505131
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"363998\">@Ibraheem Ahmed</span> in you split trait, what are the GAT lifetimes for? And why is the result of Split a tuple of values? What are the concrete types which get returned? How would it be implemented?</p>",
        "id": 268378313,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642506044
    },
    {
        "content": "<p>(My experiment essentially requires the same backing code as impls on &amp; refs, but the impl is on a wrapper type rather than a &amp; ref)</p>",
        "id": 268378532,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642506216
    },
    {
        "content": "<p>(Ah, I see the GAT lifetime  is so that the wrapper types can keep a reference to self)</p>",
        "id": 268378879,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642506421
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>FileReader&lt;&#39;a&gt;(&amp;&#39;a File);\nFileWriter&lt;&#39;a&gt;(&amp;&#39;a File);\n\nimpl AsyncSplit for File {\n    type ReadHalf&lt;&#39;a&gt; = FileReader&lt;&#39;a&gt;;\n    type WriteHalf&lt;&#39;a&gt; = FileWriter&lt;&#39;a&gt;;\n\n    fn split&lt;&#39;a&gt;(&amp;&#39;a mut self) -&gt; (FileReader&lt;&#39;a&gt;, FileWriter&lt;&#39;a&gt;) {\n        (FileReader(self), FileWriter(self))\n    }\n}\n\nimpl&lt;&#39;a&gt; AsyncRead for FileReader&lt;&#39;a&gt; {\n    async fn read(&amp;mut self, buf: &amp;mut BufRead) -&gt; Result&lt;()&gt; {\n        self.0.async_read(buf)\n    }\n}\n\nimpl&lt;&#39;a&gt; AsyncWrite for FileWriter&lt;&#39;a&gt; {\n    async fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt; {\n        self.0.async_write(buf)\n    }\n}\n</code></pre></div>",
        "id": 268379290,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642506639
    },
    {
        "content": "<p>It's not about unfair scheduling, it's about some of the calls to <code>read</code> getting completely lost and never completing because their waker was ignored due to a later unrelated call to poll.</p>",
        "id": 268381486,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1642507953
    },
    {
        "content": "<p>Yes, as alice explained, some types support only a single concurrent reader and writer, because only one waker is stored and woken up per direction</p>",
        "id": 268385297,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642510014
    },
    {
        "content": "<p>The reader and writer wakers are stored individually</p>",
        "id": 268385332,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642510037
    },
    {
        "content": "<p>And yes, the GAT is to support wrapper types that implement AsyncRead/Write respectively (given we don't have the &amp;T impls)</p>",
        "id": 268385444,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642510092
    },
    {
        "content": "<p><a href=\"https://docs.rs/tokio/latest/tokio/net/tcp/struct.ReadHalf.html\">https://docs.rs/tokio/latest/tokio/net/tcp/struct.ReadHalf.html</a></p>",
        "id": 268385486,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642510116
    },
    {
        "content": "<p>I see, thanks!</p>",
        "id": 268387750,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642511231
    },
    {
        "content": "<p>So, is the waker a thing still a problem with the async fns rather than the poll functions? It seems like it should be if the waker is only identified by its task?</p>",
        "id": 268388137,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642511413
    },
    {
        "content": "<p>No, it's only a problem with the poll functions.</p>",
        "id": 268395481,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642515030
    },
    {
        "content": "<p>That's why a function like <code>async fn readable</code> is usually provided as well.</p>",
        "id": 268395650,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642515120
    },
    {
        "content": "<p>Which gets it's own unique waker slot in a vec/map.</p>",
        "id": 268396005,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642515252
    },
    {
        "content": "<p>I'm not sure if tokio does this, but I know smol does.</p>",
        "id": 268396037,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642515265
    },
    {
        "content": "<p>Ah yeah, tokio does it with a linked list.</p>",
        "id": 268396160,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642515324
    },
    {
        "content": "<p>So then the only issue with impls on references in a world with async fns is that there are some types for which we want simultaneous read/write but not multiple readers for logical reasons?</p>",
        "id": 268399156,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642516554
    },
    {
        "content": "<p>I only skimmed, but <code>async fn read(....)</code> also requires reserving a buffer for every single in-flight read, which isn't really an option for high concurrency net servers.</p>",
        "id": 268432787,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1642529303
    },
    {
        "content": "<p>A sketch, but this would support concurrent read / write, avoid reserving buffers for in-flight read, and use <code>async fn</code>: <a href=\"https://gist.github.com/carllerche/5d7037bd55dac1cb72891529a4ff1540\">https://gist.github.com/carllerche/5d7037bd55dac1cb72891529a4ff1540</a></p>",
        "id": 268433051,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1642529418
    },
    {
        "content": "<p><code>async fn read</code> and <code>async fn write</code> could included as methods w/ default impls and implemented in terms of ready &amp; try_read / try_write</p>",
        "id": 268433087,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1642529449
    },
    {
        "content": "<p>and that problem is real. i've spoken with engineers that cannot have 8kb allocated PER socket waiting for a read that might come eventually. they want to use a single buffer for whatever socket becomes ready</p>",
        "id": 268435247,
        "sender_full_name": "Sean McArthur",
        "timestamp": 1642530459
    },
    {
        "content": "<p>Do we even need AsyncRead/AsyncWrite then? Rather than just Read/Write.</p>",
        "id": 268440516,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642532881
    },
    {
        "content": "<p>I guess we could make things more ergonomic by making try_read/try_write async so that the WouldBlock case is handled internally, but in most cases the future would resolve immediately?</p>",
        "id": 268440944,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642533052
    },
    {
        "content": "<p>It is possible we don't need AsyncRead / AsyncWrite, however, overloading Read / Write has historically not panned out well</p>",
        "id": 268441119,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1642533138
    },
    {
        "content": "<p>in this case though, the AsyncIo trait would provide the necessary trait bound</p>",
        "id": 268441137,
        "sender_full_name": "Carl Lerche",
        "timestamp": 1642533150
    },
    {
        "content": "<p>I do think we need separate traits for AsyncRead/AsyncWrite rather than using Read/Write, because some types will have a <em>different</em> operation they need to do in the non-blocking case.</p>",
        "id": 268441519,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642533334
    },
    {
        "content": "<p>But I'd love to have something like <code>smol::Async</code> in the standard library for the case where this is as simple as \"put FD/handle into non-blocking mode, and expect it to select/epoll/etc as readable/writable when ready\".</p>",
        "id": 268441599,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642533362
    },
    {
        "content": "<p>The idea of providing a better abstraction over <em>just</em> the readiness operation seems potentially viable.</p>",
        "id": 268441778,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642533453
    },
    {
        "content": "<p>That wouldn't be compatible with io-uring.</p>",
        "id": 268445802,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1642535358
    },
    {
        "content": "<p>That abstraction doesn't need to be.</p>",
        "id": 268496031,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642572627
    },
    {
        "content": "<p>It's a helper for the common case, not an obligate framework.</p>",
        "id": 268496041,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642572646
    },
    {
        "content": "<p>(Also, I'm increasingly wondering if the right async for io_uring looks <em>completely</em> different and we should just build the right async for other things.)</p>",
        "id": 268496080,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1642572697
    },
    {
        "content": "<p>I'm also thinking there is no good one size fits all API. Not sure what the implications for that look like</p>",
        "id": 268516536,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1642586890
    },
    {
        "content": "<p>With sync read, a common pattern is to loop, calling <code>read</code> repeatedly until it returns 0 bytes  (i.e., reading is complete), filling a single buffer and processing the buffer at the end. Am I right that this doesn't happen so often in the async world? I.e., you want to process data as it arrives rather than buffer it and process when complete? Is there ever any need to follow that pattern (files vs network?). If one were using the readiness pattern for async IO traits, how would one use it to do such repeated reads (or check that the resource has nothing more to read)? I imagine you need to call Ready::ready each time, so presumably you'd need a pre-allocated or growable buffer?</p>",
        "id": 269126019,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643039802
    },
    {
        "content": "<p>An HTTP server might repeatedly read into a couple kilobyte buffer and stream the rest</p>",
        "id": 269126514,
        "sender_full_name": "Ibraheem Ahmed",
        "timestamp": 1643039985
    },
    {
        "content": "<p>Do you know how that would look using the AsyncIo trait proposal?</p>",
        "id": 269126757,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1643040043
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> I've definitely written the \"read into buffer, handle partial reads, do something with buffer, repeat\" loop in both sync and async code. That includes both \"process whatever partial read I get\" cases and \"make sure I have enough data to process\" cases (the latter for things like parsing).</p>",
        "id": 269171369,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643057704
    },
    {
        "content": "<p>For the latter case, I've done both \"read a length, read_exact that many bytes\" and \"read into a buffer however many bytes I get, if I don't have enough to process, read more\".</p>",
        "id": 269171443,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1643057750
    },
    {
        "content": "<p>So, if a program is doing async reads and they care about memory usage, they wait for readiness, then read into either a thread-local or stack-allocated buffer. But AIUI, there is always the possibility that you don't read enough and have to wait for another read (or even multiple reads) before you can start processing. In that case, what is does the program do with the data read so far? Does it have to be copied to more permanent storage? Or is the shared buffer smart enough that it can be used to keep the data in until the next read? Do we rely on this being very uncommon in practice or is this something which happens a lot? (cc <span class=\"user-mention\" data-user-id=\"243965\">@Sean McArthur</span> <span class=\"user-mention\" data-user-id=\"224941\">@Carl Lerche</span> )</p>",
        "id": 271409098,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644487391
    },
    {
        "content": "<p>I mean, it would have to store that data somewhere.</p>",
        "id": 271410073,
        "sender_full_name": "Alice Ryhl",
        "timestamp": 1644487867
    },
    {
        "content": "<p>Yes of course :-) , I'm wondering how it is done in practice and whether that is a common or exceptional code path</p>",
        "id": 271410487,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644488119
    }
]