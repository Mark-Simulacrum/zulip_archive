[
    {
        "content": "<p>I was thinking of an idea for a small change we could make to make async stack traces better. The basic idea is that currently <code>foo::generator$0</code> is surprising because a user shouldn't need to have any expectation that generators are involved in async code, even if they are used under the hood as an implementation detail.</p>\n<p>So, we could change backtrace printing code to render <code>foo::generator$0</code> as <code>async fn foo</code>. Except, we run into the reverse issue if the user actually wrote a generator (\"why does it as <code>async fn foo</code>? I didn't write any async code, I'm just using generators\"). So, we'd want to tweak the symbol name to describe whether this function came from an async fn, an async block, a generator, or perhaps some other source. For async blocks, we might consider including the line number in the symbol name to give a more user-friendly way of distinguishing them.</p>\n<p>I wrote some about this idea here: <a href=\"https://github.com/rust-lang/wg-async-foundations/pull/265\">https://github.com/rust-lang/wg-async-foundations/pull/265</a></p>\n<p>It seems like this should be an easy change to make, since I would expect we don't need to preserve backwards compatibility for generated symbol names like this.</p>\n<p>What do folks think?</p>",
        "id": 267667477,
        "sender_full_name": "eholk",
        "timestamp": 1641947575
    },
    {
        "content": "<p>Yes! I love it</p>",
        "id": 267674107,
        "sender_full_name": "tmandry",
        "timestamp": 1641953096
    },
    {
        "content": "<p>last time I was thinking about this I remember there being an extra stack frame for each async fn for the <code>from_generator</code> future adapter or similar. not sure if this was already solved with inlining or other tricks.</p>",
        "id": 267674186,
        "sender_full_name": "tmandry",
        "timestamp": 1641953177
    },
    {
        "content": "<p>The other question I have is: should these kinds of \"function decorators\" included in <a href=\"https://github.com/rust-lang/rust/issues/60705\">v0 symbol mangling scheme</a>? cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span></p>",
        "id": 267674328,
        "sender_full_name": "tmandry",
        "timestamp": 1641953363
    },
    {
        "content": "<p>i guess this means we can easily distinguish generators created by async stuff and manually created generators?</p>",
        "id": 267678658,
        "sender_full_name": "Andrew Chin (eminence)",
        "timestamp": 1641958296
    },
    {
        "content": "<p>that’s the idea of <span class=\"user-mention silent\" data-user-id=\"421986\">eholk</span>’s proposal. mine is one approach to implementing it at the debuginfo level. We need some standard way to go from a mangled symbol name to <code>async fn foo</code>; v0 symbol mangling is a standard that we can change and is close to becoming the default</p>",
        "id": 267688562,
        "sender_full_name": "tmandry",
        "timestamp": 1641971089
    },
    {
        "content": "<p>(I’m hoping we could do it without updating the standard though, since there are already a number of implementations out there that would have to change)</p>",
        "id": 267688767,
        "sender_full_name": "tmandry",
        "timestamp": 1641971320
    },
    {
        "content": "<p>That's a good question about the symbol naming. I imagined this would be sort of another layer of mangling on top of what we already do, but it might be better to fold it into the existing mangling scheme instead.</p>",
        "id": 267782864,
        "sender_full_name": "eholk",
        "timestamp": 1642019971
    },
    {
        "content": "<p>I'd rather not have additional schemes on top that still have to be supported by all the debuggers</p>",
        "id": 267948460,
        "sender_full_name": "tmandry",
        "timestamp": 1642117321
    },
    {
        "content": "<p>I need to check that RFC again to find out what the options are</p>",
        "id": 267948536,
        "sender_full_name": "tmandry",
        "timestamp": 1642117355
    },
    {
        "content": "<p>I just put up <a href=\"https://github.com/rust-lang/rust/issues/92873\">#92873</a> to make different names based on the generator kind. It's pretty straightforward but should still make things a little better.</p>",
        "id": 267949642,
        "sender_full_name": "eholk",
        "timestamp": 1642118148
    },
    {
        "content": "<p>A change like that can easily break any existing  debugger plugins that rely on names in debuginfo looking a certain way. It's not a problem right now, I think -- but it would be great if we had regression tests that make sure things keep working and a specification of debuginfo.</p>",
        "id": 268011752,
        "sender_full_name": "mw",
        "timestamp": 1642166248
    },
    {
        "content": "<p>Thanks, <span class=\"user-mention\" data-user-id=\"124287\">@mw</span>, that's  good point. I wasn't sure what kind of stability guarantees we make about symbol names, but it sounds like we don't have much here. Of course, not making stability guarantees doesn't stop people from depending on them :)</p>",
        "id": 268040915,
        "sender_full_name": "eholk",
        "timestamp": 1642179274
    },
    {
        "content": "<p>Yeah, once you have debugger plugins that are shipped separately from the compiler, then debuginfo becomes part of the public interface of a crate. We've gotten away with keeping debuginfo unstable so far -- but that instability might be a reason why we don't see many plugins.</p>",
        "id": 268043652,
        "sender_full_name": "mw",
        "timestamp": 1642180458
    },
    {
        "content": "<p>This is part of why I'd like to incorporate into something with more explicit stability guarantees like (eventually) v0 symbol mangling</p>",
        "id": 268061111,
        "sender_full_name": "tmandry",
        "timestamp": 1642188780
    },
    {
        "content": "<p>it's not clear to me what interface we actually <em>want</em>, though</p>",
        "id": 268061412,
        "sender_full_name": "tmandry",
        "timestamp": 1642188938
    },
    {
        "content": "<p>and it's also hard to update that spec</p>",
        "id": 268062133,
        "sender_full_name": "tmandry",
        "timestamp": 1642189274
    },
    {
        "content": "<p>so, using the existing spec, for <code>async fn</code> we could (ab)use the ABI specifier by making the ABI <code>async</code></p>",
        "id": 268062243,
        "sender_full_name": "tmandry",
        "timestamp": 1642189335
    },
    {
        "content": "<p>(this isn't totally out of the blue, we've talked about async being an ABI before, but it is a bit weird)</p>",
        "id": 268062287,
        "sender_full_name": "tmandry",
        "timestamp": 1642189365
    },
    {
        "content": "<p>for async blocks and closures, using a nested path within the function path (as we do today) probably continues to make the most sense</p>",
        "id": 268062329,
        "sender_full_name": "tmandry",
        "timestamp": 1642189388
    },
    {
        "content": "<p>other than the ABI, the closest thing we have to an <code>async</code> prefix is <code>unsafe</code>, which is directly built in to the spec</p>",
        "id": 268062730,
        "sender_full_name": "tmandry",
        "timestamp": 1642189600
    },
    {
        "content": "<p>Okay, I was talking with <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> just now and it turns out there <em>is</em> a concept for something like this in v0 mangling</p>",
        "id": 268068746,
        "sender_full_name": "tmandry",
        "timestamp": 1642192301
    },
    {
        "content": "<p>tbc, the mangling concept maps 1:1 this data: <a href=\"https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler/rustc_hir/src/definitions.rs#L284-L285\">https://github.com/rust-lang/rust/blob/02c9e73e6ca7e2bd444d39182f8dee7e2ba4a609/compiler/rustc_hir/src/definitions.rs#L284-L285</a></p>",
        "id": 268068831,
        "sender_full_name": "eddyb",
        "timestamp": 1642192333
    },
    {
        "content": "<p>so you would have to change the compiler as a whole</p>",
        "id": 268068850,
        "sender_full_name": "eddyb",
        "timestamp": 1642192346
    },
    {
        "content": "<p>you can see it says <code>::{closure#0}</code> in paths w/o going through mangling: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=066de567145fba40e1c853d990617f2b\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=066de567145fba40e1c853d990617f2b</a></p>",
        "id": 268068962,
        "sender_full_name": "eddyb",
        "timestamp": 1642192417
    },
    {
        "content": "<p>you want to change <em>that</em>, and mangling follows</p>",
        "id": 268068973,
        "sender_full_name": "eddyb",
        "timestamp": 1642192424
    },
    {
        "content": "<p>Relevant part of the spec:</p>\n<div class=\"codehilite\"><pre><span></span><code>// Namespace of the identifier in a (nested) path.\n// It&#39;s an a-zA-Z character, with a-z reserved for implementation-internal\n// disambiguation categories (and demanglers should never show them), while\n// A-Z are used for special namespaces (e.g. closures), which the demangler\n// can show in a special way (e.g. `NC...` as `...::{closure}`), or just\n// default to showing the uppercase character.\n&lt;namespace&gt; = &quot;C&quot;      // closure\n            | &quot;S&quot;      // shim\n            | &lt;A-Z&gt;    // other special namespaces\n            | &lt;a-z&gt;    // internal namespaces\n</code></pre></div>",
        "id": 268069048,
        "sender_full_name": "tmandry",
        "timestamp": 1642192449
    },
    {
        "content": "<p>so we could potentially add more builtin namespaces for e.g. <code>async_block</code> (and make the changes <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> mentioned above)</p>",
        "id": 268069185,
        "sender_full_name": "tmandry",
        "timestamp": 1642192522
    },
    {
        "content": "<p>and we probably want to do this for the code written in an <code>async fn</code>, instead of using only closure paths</p>",
        "id": 268069256,
        "sender_full_name": "tmandry",
        "timestamp": 1642192562
    },
    {
        "content": "<p>I'd be worried about adding a whole menagerie but if it needs done, it's not <em>hard</em></p>",
        "id": 268069297,
        "sender_full_name": "eddyb",
        "timestamp": 1642192567
    },
    {
        "content": "<p>based on this, you need 4 new namespaces in <code>DefPathData</code> and mangling: <a href=\"https://github.com/rust-lang/rust/pull/92873/files#diff-e0465b23357962aaea9ec60b764de458bda0e9e9b55f745328078cebc0d02f68R522-R526\">https://github.com/rust-lang/rust/pull/92873/files#diff-e0465b23357962aaea9ec60b764de458bda0e9e9b55f745328078cebc0d02f68R522-R526</a></p>",
        "id": 268069367,
        "sender_full_name": "eddyb",
        "timestamp": 1642192612
    },
    {
        "content": "<p>(unless you conflate some of them together)</p>",
        "id": 268069383,
        "sender_full_name": "eddyb",
        "timestamp": 1642192626
    },
    {
        "content": "<p>..I'm wondering if we'd need another set for generator functions (and async generators?)</p>",
        "id": 268069434,
        "sender_full_name": "tmandry",
        "timestamp": 1642192650
    },
    {
        "content": "<p>btw you can already do some shenanigans</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"go\">~ $ echo _RNCNvC3foo3bar0 | rustfilt</span>\n<span class=\"gp\">foo::bar::{closure#</span><span class=\"m\">0</span><span class=\"o\">}</span>\n<span class=\"go\">~ $ echo _RNCNvC3foo3bar5async | rustfilt</span>\n<span class=\"gp\">foo::bar::{closure:async#</span><span class=\"m\">0</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 268069583,
        "sender_full_name": "eddyb",
        "timestamp": 1642192720
    },
    {
        "content": "<p>oh, interesting</p>",
        "id": 268069832,
        "sender_full_name": "tmandry",
        "timestamp": 1642192849
    },
    {
        "content": "<p>but note that that's more wasteful</p>",
        "id": 268069896,
        "sender_full_name": "eddyb",
        "timestamp": 1642192884
    },
    {
        "content": "<p>also this is what happens for an unknown namespace letter:</p>\n<div class=\"codehilite\" data-code-language=\"Bash Session\"><pre><span></span><code><span class=\"go\">~ $ echo _RNGNvC3foo3bar0 | rustfilt</span>\n<span class=\"gp\">foo::bar::{G#</span><span class=\"m\">0</span><span class=\"o\">}</span>\n<span class=\"go\">~ $ echo _RNGNvC3foo3bar5async | rustfilt</span>\n<span class=\"gp\">foo::bar::{G:async#</span><span class=\"m\">0</span><span class=\"o\">}</span>\n</code></pre></div>",
        "id": 268069959,
        "sender_full_name": "eddyb",
        "timestamp": 1642192917
    },
    {
        "content": "<p>so it doesn't break existing demanglers, it's just not as pretty</p>",
        "id": 268070040,
        "sender_full_name": "eddyb",
        "timestamp": 1642192943
    },
    {
        "content": "<p>Ah, this is helpful!</p>",
        "id": 268072181,
        "sender_full_name": "eholk",
        "timestamp": 1642194059
    },
    {
        "content": "<p>I suspect once generators are stabilized we'll have a similar <code>generator_fn</code> and <code>generator_block</code> at least that we'll need. Probably <code>async_generator_fn</code> and <code>async_generator_block</code> too.</p>",
        "id": 268072235,
        "sender_full_name": "eholk",
        "timestamp": 1642194103
    },
    {
        "content": "<p>As a side note: the names in debuginfo are not really related to symbol mangling. Debuginfo stores unmangled/human-readable names (see e.g. <a href=\"http://wiki.dwarfstd.org/index.php?title=Best_Practices#Names_of_Program_Entities\">http://wiki.dwarfstd.org/index.php?title=Best_Practices#Names_of_Program_Entities</a>). Some restrictions apply for those too because that's what consumers of debuginfo usually work with.</p>",
        "id": 268289743,
        "sender_full_name": "mw",
        "timestamp": 1642435765
    }
]