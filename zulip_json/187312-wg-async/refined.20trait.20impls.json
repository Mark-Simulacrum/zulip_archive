[
    {
        "content": "<p>I posted a draft of a new RFC I've been working on: <a href=\"https://rust-lang.github.io/async-fundamentals-initiative/RFC/refined_impls.html\">Refined trait impls</a></p>",
        "id": 275457954,
        "sender_full_name": "tmandry",
        "timestamp": 1647394412
    },
    {
        "content": "<p>Part of the motivation for this is <a href=\"https://github.com/rust-lang/rfcs/pull/3193\">RPITIT</a>; it makes the feature much more useful and answers some questions raised in the discussion of that RFC</p>",
        "id": 275458111,
        "sender_full_name": "tmandry",
        "timestamp": 1647394588
    },
    {
        "content": "<p>But this RFC also fixes some surprising inconsistencies in the language today</p>",
        "id": 275458136,
        "sender_full_name": "tmandry",
        "timestamp": 1647394641
    },
    {
        "content": "<p>In the 'Automatic migration for the next edition' section, I don't understand why rewriting is necessary? I'd think the only rewrite necessary is to remove #[refine] attributes? Methods which look refined will still continue to work (and would have triggered a warning in any case) and no behaviour of existing programs will change, but more valid programs could be written after the edition change</p>",
        "id": 275524746,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647443386
    },
    {
        "content": "<p>For refinement of where clauses, I would expect that we have to look at where type variables are used, not just at the bounds in the where clause? I.e., if a type variable is used only in arguments, then we check bounds are refined contravariantly, covariant if they're used in return types, and invariant in return types, plus apply the rules for variance of type variables in nested position</p>",
        "id": 275525191,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647443556
    },
    {
        "content": "<p>I like the RFC in general!</p>",
        "id": 275525385,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647443639
    },
    {
        "content": "<p>Another area I would like to allow is that impls should be able to name lifetimes which are elided in super traits, e.g., if <code>fn foo(&amp;self) -&gt; &amp;str</code> is in the trait, then an impl with <code>fn foo&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str</code> should be allowed, and furthermore stronger constraints on lifetimes should be allowed, e.g., if <code>fn bar(a: &amp;T, b &amp;T)</code> is in the trait, <code>fn bar&lt;'a&gt;(a: &amp;'a T, b: 'a T)</code> should be allowed, as well as the straightforward expansion</p>",
        "id": 275525932,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647443829
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275524746\">said</a>:</p>\n<blockquote>\n<p>In the 'Automatic migration for the next edition' section, I don't understand why rewriting is necessary? I'd think the only rewrite necessary is to remove #[refine] attributes? Methods which look refined will still continue to work (and would have triggered a warning in any case) and no behaviour of existing programs will change, but more valid programs could be written after the edition change</p>\n</blockquote>\n<p>All that is true. My concern is that we end up stabilizing new API surface that libraries didn't mean to stabilize because they weren't as careful about how their impls were written before this feature was introduced. This might turn out to be a non issue, though.</p>",
        "id": 275546868,
        "sender_full_name": "tmandry",
        "timestamp": 1647451109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275525191\">said</a>:</p>\n<blockquote>\n<p>For refinement of where clauses, I would expect that we have to look at where type variables are used, not just at the bounds in the where clause? I.e., if a type variable is used only in arguments, then we check bounds are refined contravariantly, covariant if they're used in return types, and invariant in return types, plus apply the rules for variance of type variables in nested position</p>\n</blockquote>\n<p>I went down this path for awhile but I don't think it's actually right. Where clauses are <em>always</em> proved by the caller; they can't be used purely to promise things about the callee's return type (unlike RPIT). So contravariance (removing bounds that the caller has to prove) is always the right direction.</p>",
        "id": 275547875,
        "sender_full_name": "tmandry",
        "timestamp": 1647451551
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275525932\">said</a>:</p>\n<blockquote>\n<p>Another area I would like to allow is that impls should be able to name lifetimes which are elided in super traits, e.g., if <code>fn foo(&amp;self) -&gt; &amp;str</code> is in the trait, then an impl with <code>fn foo&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a str</code> should be allowed, and furthermore stronger constraints on lifetimes should be allowed, e.g., if <code>fn bar(a: &amp;T, b &amp;T)</code> is in the trait, <code>fn bar&lt;'a&gt;(a: &amp;'a T, b: 'a T)</code> should be allowed, as well as the straightforward expansion</p>\n</blockquote>\n<p>Yeah, this overlaps with the future direction of allowing added generic parameters that I talk about at the end. I can add something on lifetimes there too. Btw, your last example would only work in the opposite direction (relaxing bounds in the implementation).</p>",
        "id": 275548306,
        "sender_full_name": "tmandry",
        "timestamp": 1647451726
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116883\">tmandry</span> <a href=\"#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275547875\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/187312-wg-async/topic/refined.20trait.20impls/near/275525191\">said</a>:</p>\n<blockquote>\n<p>For refinement of where clauses, I would expect that we have to look at where type variables are used, not just at the bounds in the where clause? I.e., if a type variable is used only in arguments, then we check bounds are refined contravariantly, covariant if they're used in return types, and invariant in return types, plus apply the rules for variance of type variables in nested position</p>\n</blockquote>\n<p>I went down this path for awhile but I don't think it's actually right. Where clauses are <em>always</em> proved by the caller; they can't be used purely to promise things about the callee's return type (unlike RPIT). So contravariance (removing bounds that the caller has to prove) is always the right direction.</p>\n</blockquote>\n<p>Yeah, that makes sense. I'm not exactly sure what is going on here with the types, but thinking about it practically that seems right.</p>",
        "id": 275550912,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1647452746
    }
]