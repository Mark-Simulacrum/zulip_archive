[
    {
        "content": "<p>Hey all, I wrote an idea I had of how we could potentially use Niko's idea for \"view types\" to create safe pin projections - and the general challenges of creating safe pin projections in Rust. It's intentionally less researched than some of my other posts, but I figured the idea was interesting enough that it was worth writing down. Hope folks find it interesting!</p>\n<p><a href=\"https://blog.yoshuawuyts.com/safe-pin-projections-through-view-types/\">https://blog.yoshuawuyts.com/safe-pin-projections-through-view-types/</a></p>",
        "id": 274130380,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646401640
    },
    {
        "content": "<p>Heh, I know it's kind of too late, but I, too, wish the pin-projection unsafety had been written the other way around: unsafe to <code>impl Unpin</code>, safe to pin-project (or even that one could have been unsafe as well, I don't really care).</p>\n<div class=\"spoiler-block\"><div class=\"spoiler-header\">\n<p>problems of non-unsafe Unpin</p>\n</div><div class=\"spoiler-content\" aria-hidden=\"true\">\n<p>Non-<code>unsafe</code> <code>Unpin</code> is a big thorny aspect for a sound and non-<code>unsafe</code> pin-projection API: <code>#[pin_project]</code>'s current desugaring <em>currently</em> gets away thanks to limitations in the coherence checker. Any time the coherence checker becomes smarter and thus more lenient, it's yet <strong>another chance for <code>#[pin_project]</code> to become unsound</strong>: it is the case if <code>Unpin</code> were marked <code>#[marker]</code> (which is why it won't), and it is almost the case with <code>with_negative_coherence</code> (another \"bug\"/quirk/accidental lack of leniency in there currently \"saves the day\". The whole thing sounds so backwards).</p>\n</div></div>\n<p>Regarding raising <code>Pin</code> to become a full-featured language construct (it currently is a <em>hybrid</em>), I agree as well: <code>pin</code> projections, stack pinning, <strong>implicit <code>Pin</code>-reborrowing</strong> could all be made more intuitive thanks to it.</p>\n<ul>\n<li>(The type would have to be a <code>&amp;'r pin mut Self</code> rather than just a <code>pin Self</code>, though, I think, since we could also have APIs requiring <code>&amp;'r pin Self</code>).</li>\n</ul>",
        "id": 274135019,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646403610
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> <a href=\"#narrow/stream/187312-wg-async/topic/pin.20projections.20through.20view.20types/near/274135019\">said</a>:</p>\n<blockquote>\n<p>I, too, wish the pin-projection unsafety had been written the other way around: unsafe to <code>impl Unpin</code>, safe to pin-project (or even that one could have been unsafe as well, I don't really care).</p>\n</blockquote>\n<p>Heh yeah, definitely. I guess right now we consider \"pinning\" to be difficult, and we as the WG are looking to remove it as much as we can from APIs (e.g.  async trait-based<code>AsyncIterator</code>, <code>AsyncRead</code>, <code>AsyncWrite</code>). But I actually wonder what the user-experience was like if pinning better fitted into the language? What other than async APIs does pinning enable? What are we trading losing by moving to <code>async</code>-based core traits?</p>\n<p>I don't feel like we have satisfying answers to that yet. And I think it'd be worth working through that. At the minimum so we've covered all our bases. Though I suspect that actually some things which seem obvious today, might not be as obvious as we assume.</p>",
        "id": 274141761,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646406427
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"232018\">@Daniel Henry-Mantilla</span> oh yeah, <code>pin self</code> vs <code>pin mut self</code> makes sense! Though I'm curious: what's the <code>'r</code> lifetime for? Did you just add it for clarity, or do you think it should always carry a lifetime annotation?</p>",
        "id": 274142424,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646406648
    },
    {
        "content": "<p>Internals thread is here by the way: <a href=\"https://internals.rust-lang.org/t/post-safe-pin-projections-through-view-types/16248/5\">https://internals.rust-lang.org/t/post-safe-pin-projections-through-view-types/16248/5</a></p>",
        "id": 274160042,
        "sender_full_name": "Yoshua Wuyts [he/they]",
        "timestamp": 1646414144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"211722\">Yoshua Wuyts [he/they]</span> <a href=\"#narrow/stream/187312-wg-async/topic/pin.20projections.20through.20view.20types/near/274142424\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"232018\">Daniel Henry-Mantilla</span> oh yeah, <code>pin self</code> vs <code>pin mut self</code> makes sense! Though I'm curious: what's the <code>'r</code> lifetime for? Did you just add it for clarity, or do you think it should always carry a lifetime annotation?</p>\n</blockquote>\n<p>If it's borrowing it has a lifetime; although it can obviously be elided. I prefered to name it here so that we can see in which order the elems of the pinned reference would be laid out <span aria-label=\"upside down\" class=\"emoji emoji-1f643\" role=\"img\" title=\"upside down\">:upside_down:</span></p>",
        "id": 274309074,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1646577456
    }
]