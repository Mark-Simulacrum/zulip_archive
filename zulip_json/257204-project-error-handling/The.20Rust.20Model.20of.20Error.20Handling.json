[
    {
        "content": "<p>I'm planning on writing a 2022 roadmap / status update for the error handling project group and I thought it might be a good time to step back and do some holistic planning around error handling in rust.</p>",
        "id": 271049787,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644271787
    },
    {
        "content": "<p>As a first step I want to create a collaborative document outlining \"The Rust Model of Error Handling\" to make sure we're all on the same page and using the same definitions in discussions about error handling.</p>",
        "id": 271049922,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644271846
    },
    {
        "content": "<p>I've started drafting that document here: <a href=\"https://hackmd.io/VN6AtpySR4Or_CV8b8XjRg\">https://hackmd.io/VN6AtpySR4Or_CV8b8XjRg</a></p>",
        "id": 271049938,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644271861
    },
    {
        "content": "<p>For now I'm starting with a couple of sections</p>",
        "id": 271049972,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644271882
    },
    {
        "content": "<p><code>Definitions</code> is for establishing common definitions for frequently overloaded / confusing terms used when talking about error handling</p>",
        "id": 271050038,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644271916
    },
    {
        "content": "<p><code>Core Design Goals</code> is to outline the practical features of rust error handling and possibly to prioritize them relative to eachother</p>",
        "id": 271050132,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644271954
    },
    {
        "content": "<p>and then <code>Current areas of confusion</code> is for the topics of discussion that tend to be contentious / unclear to different users</p>",
        "id": 271050590,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644272055
    },
    {
        "content": "<p>The draft is very rough at the moment, my current focus is filling in the core design goals section</p>",
        "id": 271051008,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644272223
    },
    {
        "content": "<p>For definitions I'm just putting in the terms that I think need to be defined but leaving definitions of them for later, I'm particularly curious to see and compare what definitions other people would provide for these terms</p>",
        "id": 271051095,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644272267
    },
    {
        "content": "<p>Would it be appropriate to also add more general Rust terms that are used as part of error handling machinery? Downcasting is at the forefront of my mind. I remember being a concept that took me some time to understand but which crops up occasionally in the context of error handling.</p>",
        "id": 271134485,
        "sender_full_name": "Sean Chen (he/him)",
        "timestamp": 1644330252
    },
    {
        "content": "<p>Generic member access is perhaps another term as well.</p>",
        "id": 271135728,
        "sender_full_name": "Sean Chen (he/him)",
        "timestamp": 1644330682
    },
    {
        "content": "<p>absolutely</p>",
        "id": 271140646,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644332675
    },
    {
        "content": "<blockquote>\n<p>Errors should be fast by default<br>\nErrors should be informative by default</p>\n</blockquote>\n<p>Any thoughts on when these are in conflict (e.g. file errors)?</p>\n<p>Anecdote: in one library, I ran into this tension and provided parallel <code>-&gt; Option</code> / <code>-&gt; Result</code> functions to make the performance / informative distinction clear.</p>\n<blockquote>\n<p>Introducing new errors or changing error messages shouldnâ€™t be a breaking change by default</p>\n</blockquote>\n<p>I feel like \"breaking changes\" is a topic in of itself (encouraging stable APIs), for example</p>\n<ul>\n<li><code>?</code> encouraging <code>impl From</code> which puts implementation details in your public API </li>\n<li>Implicit or explicit contracts around <code>source</code> which probably ties into your usage / best practice section</li>\n</ul>",
        "id": 271143436,
        "sender_full_name": "Ed Page",
        "timestamp": 1644333765
    },
    {
        "content": "<blockquote>\n<p>Any thoughts on when these are in conflict (e.g. file errors)?</p>\n</blockquote>\n<p>I think they're pretty commonly in conflict, like you said, the question of whether or not to include a PathBuf in a file error by default. My expectation is that we would prioritize fast by default over informative by default given previous decisions, but we could revisit that decision and changing our mind could certainly have a large impact!</p>",
        "id": 271143790,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644333927
    },
    {
        "content": "<p>For core features (and maybe areas of confusion), I think it would be good to mention the different kinds of backtraces, and how they are constructed. Off the top of my head: backtraces in Errors , on panics, and in debuggers</p>",
        "id": 271146244,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644334868
    },
    {
        "content": "<p>For core features: probably worth mentioning concrete errors vs trait object errors more explicitly</p>",
        "id": 271146455,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644334949
    },
    {
        "content": "<p>On error reporting, I think it might be worth mentioning reporting errors for programmers doing debugging or in logs, vs reporting errors to users (which is really error handling not error reporting, but I think that can be confusing)</p>",
        "id": 271146771,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644335095
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/271146771\">said</a>:</p>\n<blockquote>\n<p>On error reporting, I think it might be worth mentioning reporting errors for programmers doing debugging or in logs, vs reporting errors to users (which is really error handling not error reporting, but I think that can be confusing)</p>\n</blockquote>\n<p>I think i did mention this one, let me check</p>",
        "id": 271146823,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644335122
    },
    {
        "content": "<blockquote>\n<ul>\n<li>It should be possible for the same error to be formatted differently depending on where it is being displayed (e.g. multiple lines if going to a terminal but all in a single line if going to a log file)</li>\n</ul>\n</blockquote>",
        "id": 271146880,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644335149
    },
    {
        "content": "<p>i can make this more explicit about why you'd want to do that (e.g. reporting to users vs reporting to devs)</p>",
        "id": 271146989,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644335182
    },
    {
        "content": "<p>sorry kid just came home, more later,,,</p>",
        "id": 271146998,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644335185
    },
    {
        "content": "<p>Yeah, I was thinking of a higher level  division than that, I think. Like in terminal case there is a difference between essentially just logging the error (which is actually what most Rust CLI apps do, due to being often aimed at devs, or immaturity) and producing a 'good' message for the user. In particular that might include localisation or fancy rendering (like the rustc error messages with code snippets). And an internal error might need to be both logged and rendered for the user. (Oh and if its not a CLI app, the error will need rendering as graphics or a dialog box or whatever)</p>",
        "id": 271161354,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644341071
    },
    {
        "content": "<p>So I guess you cover it with \"formatted differently\" but I feel like that doesn't do justice to the difference in approaches</p>",
        "id": 271161482,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644341118
    },
    {
        "content": "<p>It would be uncommon to have one code path with different formatting rules , I guess</p>",
        "id": 271161547,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644341144
    },
    {
        "content": "<p>Not sure if you want to cover this, but under areas of confusion you could add whether to use a library and if so which one(s), and if multiple, how do they combine/interact</p>",
        "id": 271161804,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644341242
    },
    {
        "content": "<blockquote>\n<p>Yeah, I was thinking of a higher level division than that, I think. Like in terminal case there is a difference between essentially just logging the error (which is actually what most Rust CLI apps do, due to being often aimed at devs, or immaturity) and producing a 'good' message for the user. In particular that might include localisation or fancy rendering (like the rustc error messages with code snippets). </p>\n</blockquote>\n<p>Balancing user-reporting vs logging is tricky.</p>\n<ul>\n<li>Clap focuses on user-reporting and we are getting some requests for instead doing logging (since they are already logging). </li>\n<li><code>toml_edit</code> also does user-reporting while <code>toml-rs</code> did formatted for error logging but at the cost of <code>toml_edit</code> not providing the details for error logging.</li>\n</ul>\n<p>I feel like the common Rust pattern for providing context via chaining only helps with error logging but doesn't work well for user reporting.  Chains tend to just be a linked list of disparate messages without coherence or a contract on how to combine opaquely (via <code>Display</code>) or via downcasts.  <code>clap</code> is experimenting with providing all of its user-reporting data as a <code>Vec&lt;(ContextKind, ContextValue)&gt;</code> so we can provide a contract on what any of the context means.</p>",
        "id": 271162748,
        "sender_full_name": "Ed Page",
        "timestamp": 1644341594
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/271161804\">said</a>:</p>\n<blockquote>\n<p>Not sure if you want to cover this, but under areas of confusion you could add whether to use a library and if so which one(s), and if multiple, how do they combine/interact</p>\n</blockquote>\n<p>that seems like a good idea, but also I don't want this to be all controlled by me. A big part of why I want to do this model of errors is because I want to make sure that my conceptualization of error handling in rust is aligned with the rest of the community's. I'm worried that I've done a poor job including other perspectives and I want to make sure I'm not just forcing my ideas on everyone else.</p>",
        "id": 271162844,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644341630
    },
    {
        "content": "<p>which along those lines, can everyone else edit this document?</p>",
        "id": 271162941,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644341657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/271162941\">said</a>:</p>\n<blockquote>\n<p>which along those lines, can everyone else edit this document?</p>\n</blockquote>\n<p>Yep</p>",
        "id": 271165336,
        "sender_full_name": "Sean Chen (he/him)",
        "timestamp": 1644342760
    },
    {
        "content": "<p>I did some editing and added a comment to clarify one point</p>",
        "id": 271255605,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644402013
    },
    {
        "content": "<blockquote>\n<p>Unrecoverable error propagation should be hidden / should not affect public APIs</p>\n</blockquote>\n<p>I'm not sure I'm understanding this right. This seems to describe panics, but I also would've thought <code>Result::Err</code>s which result in a <code>std::process::exit</code> as often unrecoverable. I think that aligns with the definition given as well?</p>",
        "id": 271275833,
        "sender_full_name": "Plecra",
        "timestamp": 1644413335
    },
    {
        "content": "<blockquote>\n<p>The relationship between panics (unrecoverable error handling) and the error trait / result (recoverable error handling)</p>\n</blockquote>\n<p>Woah! Yeah, I thought this might be what threw me off. Recoverability, as laid out in \"Recoverable and unrecoverable errors\", has nothing to do with panic vs Result. It's a higher level property of the actual error condition being one that the application can't do anything about.</p>",
        "id": 271276432,
        "sender_full_name": "Plecra",
        "timestamp": 1644413588
    },
    {
        "content": "<p>(Btw, from my experience with error crates, I suspect things like <code>thiserror</code> aren't actually very helpful. The public enum design is only suitable in a very select few cases, and it normally doesn't make any sense to directly surface the errors from other libraries. I've found nearly every library is better served by a small, deliberately designed opaque error type. I'd definitely like to explore some real world cases to see if we can give good advice about writing custom error types)</p>",
        "id": 271280404,
        "sender_full_name": "Plecra",
        "timestamp": 1644414888
    },
    {
        "content": "<p>There might be a mismatch because I wrote the definition for recoverable and unrecoverable errors and Jane wrote the lower down bit, I think we have different opinions about the precise meaning</p>",
        "id": 271281253,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644415206
    },
    {
        "content": "<p>Absolutely fair enough :) I was adding my take on the difference between the two</p>",
        "id": 271282009,
        "sender_full_name": "Plecra",
        "timestamp": 1644415456
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"263805\">Plecra</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/271280404\">said</a>:</p>\n<blockquote>\n<p>(Btw, from my experience with error crates, I suspect things like <code>thiserror</code> aren't actually very helpful. The public enum design is only suitable in a very select few cases, and it normally doesn't make any sense to directly surface the errors from other libraries. I've found nearly every library is better served by a small, deliberately designed opaque error type. I'd definitely like to explore some real world cases to see if we can give good advice about writing custom error types)</p>\n</blockquote>\n<p>I feel like this is the $64k question for error handling. On the one hand the 'enum of errors' works really well locally recovering from errors. OTOH it doesn't scale well and it is way more common for errors to be handled remotely and generically. However, I haven't seen any good guidance on exactly when to use one or the other and where to convert between the two.</p>",
        "id": 271283311,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644416009
    },
    {
        "content": "<p>(I had this idea of 'error modules' at some point of the boundaries where one converts from concrete to abstract errors, but I don't think it is actually very helpful)</p>",
        "id": 271283444,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644416054
    },
    {
        "content": "<p>Just seeing this now. I realize I've been a bit off the radar recently, but I'm still very much at work on the error return tracing stuff at my job. I'll see if I can take a look at the draft and offer any perspective from the error tracing side of things, if that would be valuable</p>",
        "id": 271480287,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1644520566
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"435059\">Ben Reeves</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/271480287\">said</a>:</p>\n<blockquote>\n<p>Just seeing this now. I realize I've been a bit off the radar recently, but I'm still very much at work on the error return tracing stuff at my job. I'll see if I can take a look at the draft and offer any perspective from the error tracing side of things, if that would be valuable</p>\n</blockquote>\n<p>yes please!</p>",
        "id": 271481666,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644521170
    },
    {
        "content": "<p>though also any thoughts on error handling in general would also be quite welcome</p>",
        "id": 271481687,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644521182
    },
    {
        "content": "<p>trying to get as diverse a set of perspectives as I can</p>",
        "id": 271481720,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1644521199
    },
    {
        "content": "<p>Reading this thread, one think that came to mind: How do you handle internationalization in the opaque error type case?<br>\nIf it's a crate you control, you could make sure all the strings you need are extracted, but for a third party crate, with currently no real internationalization standard crate I know of, that seems difficult.</p>",
        "id": 271507050,
        "sender_full_name": "Vincent Isambart",
        "timestamp": 1644533732
    },
    {
        "content": "<p>You could still extract data from an opaque type that could then be localised, either by downcasting or by generic member access. But the app has to know what to expect from the errors, which signals to me that a purely opaque type is the wrong abstraction</p>",
        "id": 271542779,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644567223
    },
    {
        "content": "<p>Intuitively, it seems like i18n of errors is something that an application will have to implement manually for concrete error types. Libraries won't reliably provide translations for any given language a caller wants in generic code.</p>",
        "id": 271583161,
        "sender_full_name": "Plecra",
        "timestamp": 1644589246
    },
    {
        "content": "<p>What would a good API look like here? I think we have to assume that crates will rarely give non-english errors themselves.</p>",
        "id": 271583301,
        "sender_full_name": "Plecra",
        "timestamp": 1644589313
    },
    {
        "content": "<p>Right, and its not just i18n, I think in general to present an error to a user there is a processing step that can only be accomplished by the application, not the upstream crates, e.g., rendering in a GUI, forwarding to a web frontend, adjusting the error message to be optimal for the <br>\naudience, etc. Upstream libs can only make error messages suitable for logging (and even then, your app might want to do structured logging or filtering, etc.). Basically I think errors should be data structures and shouldn't try to make error messages, ever</p>",
        "id": 271588419,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1644591646
    },
    {
        "content": "<blockquote>\n<p>Basically I think errors should be data structures</p>\n</blockquote>\n<p>While I agree, it presents its own challenges.  You either need to either know about all error types, with graceful fallbacks, or you need common patterns and vocabulary terms so you can generically process all errors.</p>\n<p>Examples of systems I worked on include:</p>\n<ul>\n<li><code>Vec&lt;Key, Value&gt;</code> where <code>Key</code> was shared across multiple products that were integrated and there was a localization table for <code>Key</code>.  <code>Value</code> was a <code>Box&lt;Any&gt;</code> with one type in it was another localization lookup key.  We would just render the context as a bulleted list after a static description pulled from a localization table based on the <code>ErrorKind</code></li>\n<li>The error contains a key and a json blob.  The key is to look up the renderer for the json blob.</li>\n</ul>",
        "id": 271589500,
        "sender_full_name": "Ed Page",
        "timestamp": 1644592100
    },
    {
        "content": "<p>revisiting this again today, I'm thinking about taking the discussion we had so far and trying to start a broader conversation about the strengths and weaknesses of rust error handling today</p>",
        "id": 276415920,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648078055
    },
    {
        "content": "<p>and then basically make some sort of call for blog posts or something similar</p>",
        "id": 276415932,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648078066
    },
    {
        "content": "<p>started out with this</p>",
        "id": 276428259,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648091196
    },
    {
        "content": "<p><a href=\"https://twitter.com/yaahc_/status/1506799278211014658?s=20&amp;t=yx-qegk-Zrf-mmRBfkVkfw\">https://twitter.com/yaahc_/status/1506799278211014658?s=20&amp;t=yx-qegk-Zrf-mmRBfkVkfw</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/yaahc_/status/1506799278211014658?s=20&amp;t=yx-qegk-Zrf-mmRBfkVkfw\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/eeaff3a60f7422ff43d15ea1fba5c17154dd4cc3/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313236303734363233383532373332343136322f6f4d4a48724846435f6e6f726d616c2e6a7067\"></a><p>Hey <a href=\"https://twitter.com/rustlang\">@rustlang</a> community, show me your best or worst error handling code in rust\n\nI'm doing an analysis of the strengths, weaknesses, best pratices, and footguns of rust error handling for the error handling project group and could use some more examples.</p><span>- Yaah (@yaahc_)</span></div></div>",
        "id": 276428260,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648091196
    },
    {
        "content": "<p><a href=\"https://nitter.net/mgattozzi/status/1506809138101297152#m\">https://nitter.net/mgattozzi/status/1506809138101297152#m</a> definitely reflects my experience trying to buffer errors, it's very painful</p>",
        "id": 276432871,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098175
    },
    {
        "content": "<p>Every place with Result suddenly needs a <code>match</code> and ... some other things I don't remember, it's been nearly 3 years at this point</p>",
        "id": 276432900,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098236
    },
    {
        "content": "<p>I'd love to see and play with an example</p>",
        "id": 276432966,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098323
    },
    {
        "content": "<p>If you have any you can share</p>",
        "id": 276432974,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098331
    },
    {
        "content": "<p>I don't remember where I read this, but I vaguely recall reading a suggestion about \"localized global handlers\", where you say </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">with</span><span class=\"w\"> </span><span class=\"s\">\"error-handler\"</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"n\">err</span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>and that sounded super cool</p>",
        "id": 276432978,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098355
    },
    {
        "content": "<p>Oh sure let me pull up the code</p>",
        "id": 276433021,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098364
    },
    {
        "content": "<p>ok, here's one example: <a href=\"https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/analyze/expr.rs#L109-L115\">https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/analyze/expr.rs#L109-L115</a><br>\n<code>self.err</code> buffers the error for later handling</p>",
        "id": 276433071,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098470
    },
    {
        "content": "<p>without immediately returning and preventing further errors from being reported</p>",
        "id": 276433113,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098484
    },
    {
        "content": "<p>ah yeah now I'm remembering why this is annoying <a href=\"https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/data/error.rs#L13\">https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/data/error.rs#L13</a></p>",
        "id": 276433139,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098549
    },
    {
        "content": "<p>there's absolutely no existing abstractions for this, you have to come up with your own models</p>",
        "id": 276433144,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098561
    },
    {
        "content": "<p>Yeah</p>",
        "id": 276433162,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098585
    },
    {
        "content": "<p><code>location.with(err)</code> is also not my favorite<br>\n<a href=\"https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/data/error.rs#L62\">https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/data/error.rs#L62</a></p>",
        "id": 276433215,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098605
    },
    {
        "content": "<p>but not sure there's any way around that, since <code>location</code> has no relation to the stack trace, it's a diagnostic span pointing somewhere in the input</p>",
        "id": 276433222,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098617
    },
    {
        "content": "<p>LOL I just remembered this is the enum that <span class=\"user-mention silent\" data-user-id=\"119235\">David Tolnay</span> used as a test suite for thiserror <a href=\"https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/data/error.rs#L107\">https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/data/error.rs#L107</a></p>",
        "id": 276433315,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098736
    },
    {
        "content": "<p>Lol</p>",
        "id": 276433344,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098777
    },
    {
        "content": "<p>Nice</p>",
        "id": 276433345,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098780
    },
    {
        "content": "<p>And yeah, errors for parsers and compliers are some of the hardest to represent with error trait as it is currently, and aggregated errors</p>",
        "id": 276433362,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098833
    },
    {
        "content": "<p>I feel like you handled it how I would have</p>",
        "id": 276433402,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098847
    },
    {
        "content": "<p>Localized error handlers sounds kinda like an error effect handler</p>",
        "id": 276433415,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098863
    },
    {
        "content": "<p>I'm very surprised to hear that tbh <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I wrote most of this code in my first few months of learning rust lol</p>",
        "id": 276433421,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098878
    },
    {
        "content": "<p>oh, maybe I rewrote the error handling later, don't remember</p>",
        "id": 276433430,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/276433415\">said</a>:</p>\n<blockquote>\n<p>Localized error handlers sounds kinda like an error effect handler</p>\n</blockquote>\n<p>yeah that was the name I heard!</p>",
        "id": 276433445,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098912
    },
    {
        "content": "<p>\"effect handlers\", somewhere in #langdev on the community server</p>",
        "id": 276433456,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648098922
    },
    {
        "content": "<p>Aah, yea that tracks</p>",
        "id": 276433457,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098923
    },
    {
        "content": "<p>I've been talking with niko about effect handlers but it's mostly from a lang theory perspective and not really something that seems easy to add to rust</p>",
        "id": 276433468,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098953
    },
    {
        "content": "<p>Just me being interested in it for the very reasons it's hard here</p>",
        "id": 276433517,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098970
    },
    {
        "content": "<p>Lol</p>",
        "id": 276433518,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648098971
    },
    {
        "content": "<p>/me needs to stop reading this code before he gets the urge to start working on it again</p>",
        "id": 276433623,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648099132
    },
    {
        "content": "<p>Loool</p>",
        "id": 276433990,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648099622
    },
    {
        "content": "<p>Ok, here's another example: control flow is forced to be separate from error handling, I want <code>self.err</code> to always be coupled with <code>return pretend_zero</code> in this function, but there's no way to do that without a macro<br>\n<a href=\"https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/analyze/expr.rs#L246\">https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/analyze/expr.rs#L246</a></p>",
        "id": 276434006,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648099642
    },
    {
        "content": "<p>Could you have the return type pretend_zero only be synthesized by a err call?</p>",
        "id": 276434064,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648099709
    },
    {
        "content": "<p>So you just go return self.err(...); And any other code path is a compiler error,</p>",
        "id": 276434075,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648099735
    },
    {
        "content": "<p>Or maybe there's another way to create that as appropriate</p>",
        "id": 276434078,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648099748
    },
    {
        "content": "<p>Hmm, I don't see a convenient way to do that. err() is used in many more places than just this function</p>",
        "id": 276434079,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648099753
    },
    {
        "content": "<p>Hmm</p>",
        "id": 276434083,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648099763
    },
    {
        "content": "<p>using a closure might be possible but I'd be worried about borrowck errors from borrowing self</p>",
        "id": 276434091,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648099786
    },
    {
        "content": "<p>Ok looking back this code is not as bad as I remember haha</p>",
        "id": 276434313,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648100065
    },
    {
        "content": "<p>I rolled my own libraries and stuff but the call sites are pretty reasonable</p>",
        "id": 276434319,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648100083
    },
    {
        "content": "<p>So this method is aggregating the errors into self</p>",
        "id": 276434532,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100402
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276434570,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100410
    },
    {
        "content": "<p>But each call only produces one error right?</p>",
        "id": 276434571,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100411
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276434588,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100487
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276434590,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100487
    },
    {
        "content": "<p>Wondering if this could have used Result still</p>",
        "id": 276434591,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100487
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276434592,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100487
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276434593,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100487
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276434594,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100487
    },
    {
        "content": "<p>You still have to combine the error with the location but that seems fairly unavoidable</p>",
        "id": 276434595,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100488
    },
    {
        "content": "<p>Wow zulip</p>",
        "id": 276434600,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100499
    },
    {
        "content": "<p>Or a try block probably would have helped a lot here</p>",
        "id": 276434687,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648100621
    },
    {
        "content": "<p>I don't see how Result is useful. I need to both produce the error and also a valid type (well, valid in the sense of an Ok variant, it has <code>Type::Error</code> set)</p>",
        "id": 276434779,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648100728
    },
    {
        "content": "<p>Not all places short circuit either, most of them continue running after generating an error</p>",
        "id": 276434854,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648100796
    },
    {
        "content": "<p>I was imagining you propagate out the error and then have the caller or some wrapping function aggregate the error and then construct and return the pretend_zero</p>",
        "id": 276435259,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648101243
    },
    {
        "content": "<p>Oh, didn't know this didn't short circuit</p>",
        "id": 276435272,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648101263
    },
    {
        "content": "<p>Ah hmm I see what you mean - yeah I do that in some places</p>",
        "id": 276435279,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648101272
    },
    {
        "content": "<p>I thought you said every err here was followed by a return</p>",
        "id": 276435283,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648101274
    },
    {
        "content": "<p>In this specific function, not everywhere in this file. But yeah you're right, for this function Result would be a good choice</p>",
        "id": 276435309,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648101305
    },
    {
        "content": "<p>Tho honestly, this would be best represented by an inner try block, assuming they all short circuit that is</p>",
        "id": 276435310,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648101305
    },
    {
        "content": "<p>another place that did use result: <a href=\"https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/analyze/expr.rs#L1052\">https://github.com/jyn514/saltwater/blob/097c72d30e325de57fbed8a506431754a0560374/saltwater-parser/analyze/expr.rs#L1052</a></p>",
        "id": 276435401,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1648101392
    },
    {
        "content": "<p>Specifically for parsers/compilers, I think that handling those errors is not error handling in the sense of 'Rust model of error handling' a compiler finding an error in source code is an expected event and processing those is part of the normal execution path. We shouldn't expect any generic error handling framework to help at all. Of course a compiler can encounter real errors (e.g., not being able to write to a file) that should be handled in the same way as for other programs. I'm not sure about error buffering in general, but I expect the libraries you want for that are completely different to the ones you'd want for regular error handling</p>",
        "id": 276452223,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1648115726
    },
    {
        "content": "<p>One thing I don't see mentioned which i've only encountered a couple of times, is when an error has a lifetime associated with it, and when you need to propagate this error up into another error which outlives that, this doesn't technically contradict \"Information should not be lost when reporting errors\", because of \"when reporting\", but is a pretty thin line and I didn't see anything about it mentioned.</p>",
        "id": 276453431,
        "sender_full_name": "matt rice",
        "timestamp": 1648116358
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 276479746,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648130705
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"254366\">@matt rice</span> The thing that I have traditionally seen people do in that scenario is have an API for converting their borrowing error types into an owned version</p>",
        "id": 276479982,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648130815
    },
    {
        "content": "<p>I've generally just handled it in a lossy way like <code>Error::ErrorWasReported</code>, this is kind of lossy, but I was doing it in an application rather than a library, so it didn't matter so much where things were reported as long as I could eventually return non-zero.</p>",
        "id": 276482592,
        "sender_full_name": "matt rice",
        "timestamp": 1648131871
    },
    {
        "content": "<p>I don't really have a good name for this concept but I want to do a study of library APIs that use either flat style error types, where there's one central error that covers errors from many different APIs, vs libraries that export many separate error types</p>",
        "id": 276492467,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648135829
    },
    {
        "content": "<p>evaluate the pros and cons of each approach</p>",
        "id": 276492498,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648135839
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/276492467\">said</a>:</p>\n<blockquote>\n<p>I don't really have a good name for this concept but I want to do a study of library APIs that use either flat style error types, where there's one central error that covers errors from many different APIs, vs libraries that export many separate error types</p>\n</blockquote>\n<p>That's a really good concept to look at.</p>",
        "id": 276494480,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648136567
    },
    {
        "content": "<p>Central error handling seems really common for convenience, or for libraries that are built upon a C library that returns a C error code or similar, it's common to have a single error type.</p>",
        "id": 276494835,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648136698
    },
    {
        "content": "<p>And they can be convenient for users of the library if they're bubbling up errors in the thiserror style rather than in the catch-all anyhow/eyre style.</p>",
        "id": 276495065,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648136774
    },
    {
        "content": "<p>But separate types for different modules or even for different functions can be really convenient for the user as well, if you're actually going to <em>handle</em> the errors.</p>",
        "id": 276495093,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648136786
    },
    {
        "content": "<p>Because then you don't have to handle errors that function can't return.</p>",
        "id": 276495156,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1648136812
    },
    {
        "content": "<p>yea, there's also the issue of representing multiple levels of error cases, where your library has lower level apis that produce errors that conceptually mean different things for different higher level APIs</p>",
        "id": 276498907,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648138195
    },
    {
        "content": "<p>which is much harder to represent with a single flat error type than with multiple error types and source errors</p>",
        "id": 276499000,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648138213
    },
    {
        "content": "<p>Yeah, I think I usually do something in between, with each module having its own error type, and then a error type wrapping those, and if multiple error types overlap omitting things like From impls.</p>",
        "id": 276499792,
        "sender_full_name": "matt rice",
        "timestamp": 1648138514
    },
    {
        "content": "<p>I'll second <span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span>'s point here.  I don't think of \"spit out infos/warns/errors as you go\" as <em>error handling</em>, especially because I find that I often want to do the best I can to have even most of the \"errors\" not prevent creating a \"best effort\" return value.</p>\n<p>So my approach the last few times I've had that need was essentially to pass <code>&amp;mut FnMut(Thing)</code> into the code that can find the problems, so it can be passed as <code>|_| {}</code> or <code>|x| log!(x)</code> or <code>|x| v.push(x)</code> or <code>|_| { failed = true; }</code> or whatever as appropriate.  (Albeit this wasn't in Rust, so I'm paraphrasing a bit.)</p>",
        "id": 276499831,
        "sender_full_name": "scottmcm",
        "timestamp": 1648138529
    },
    {
        "content": "<p>In general though, one thing I'm thinking about doing is taking all the examples of error handling ppl sent me on twitter and classifying them and then doing a series of case studies on the various approaches people take to solving similar problems</p>",
        "id": 276499871,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648138546
    },
    {
        "content": "<p>im not sure if it would be helpful to ppl to have a bunch of real world error handling examples organized like that, on the one hand they can see exactly how things are done, but on the other hand it might take quite a lot of time to review the examples well enough to understand why they made the decisions they did, so it could be too much information</p>",
        "id": 276500122,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648138629
    },
    {
        "content": "<p>My organized summary of the responses I got to the twitter thread on best and worst of error handling <a href=\"https://hackmd.io/DB9gsezMT-OhAxDrmbf4oQ\">https://hackmd.io/DB9gsezMT-OhAxDrmbf4oQ</a></p>",
        "id": 276694300,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648253848
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/276452223\">said</a>:</p>\n<blockquote>\n<p>Specifically for parsers/compilers, I think that handling those errors is not error handling in the sense of 'Rust model of error handling' a compiler finding an error in source code is an expected event and processing those is part of the normal execution path. We shouldn't expect any generic error handling framework to help at all. Of course a compiler can encounter real errors (e.g., not being able to write to a file) that should be handled in the same way as for other programs. I'm not sure about error buffering in general, but I expect the libraries you want for that are completely different to the ones you'd want for regular error handling</p>\n</blockquote>\n<p>I know this isn't exactly a scientific study or really indicative of the true relative impact of these problems, but not having good options for aggregating errors was the issue that came up the most in the thread</p>",
        "id": 276694382,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648253933
    },
    {
        "content": "<p>and is one of the only ones that came up multiple times independently</p>",
        "id": 276694392,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648253943
    },
    {
        "content": "<p>along with general confusion around how to structure errors</p>",
        "id": 276694397,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648253951
    },
    {
        "content": "<p>so it's probably worth investing energy into, even if that doesn't mean new APIs in std/core</p>",
        "id": 276694417,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648253970
    },
    {
        "content": "<p>Side note: zebra-test sounds similar to assert_cmd / assert_fs with snapbox and trycmd being the next steps up.</p>",
        "id": 276721853,
        "sender_full_name": "Ed Page",
        "timestamp": 1648295163
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby [she/her]</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/276694417\">said</a>:</p>\n<blockquote>\n<p>so it's probably worth investing energy into, even if that doesn't mean new APIs in std/core</p>\n</blockquote>\n<p>Yeah, its probably an area we should include in a guide or something, rather than support in libs</p>",
        "id": 276726938,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1648302362
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> <span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby [she/her]</span> Related to that usecase (some form of parsing with recoverable errors or need to propagate warnings), I wonder if it's possible to collect warnings/errors/info messages from the log faÃ§ade into a Vec&lt;String&gt; or something like it. That would avoid having to pass to any function that can emit those warnings some form of context and duplicating the mechanism with log. Still, I'm not sure how to do it. No docs explain something like that (only outputting to console or to a file) AFAICT.</p>",
        "id": 276734028,
        "sender_full_name": "pachi",
        "timestamp": 1648312377
    },
    {
        "content": "<p>I'm not a huge fan of solving that problem on the back of a logging framework</p>",
        "id": 276734154,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648312562
    },
    {
        "content": "<p>To me this is sounding like another example of a problem caused by not having an effects system</p>",
        "id": 276734206,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648312603
    },
    {
        "content": "<p>Or at least, one that could easily be solved by an effect system</p>",
        "id": 276734218,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648312627
    },
    {
        "content": "<p>If desired, some additional examples / use cases of processing messages</p>\n<ul>\n<li>commited is a commit style checker: <a href=\"https://github.com/crate-ci/committed/blob/master/src/report.rs\">https://github.com/crate-ci/committed/blob/master/src/report.rs</a></li>\n<li>typos is a programming spell checker: <a href=\"https://github.com/crate-ci/typos/blob/master/src/bin/typos-cli/report.rs\">https://github.com/crate-ci/typos/blob/master/src/bin/typos-cli/report.rs</a></li>\n</ul>",
        "id": 276736702,
        "sender_full_name": "Ed Page",
        "timestamp": 1648316014
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby [she/her]</span> indeed, using logging looks like a hack. The proposal of Contexts and Capabilities looks like a better solution (is that what you are referring to when mentioning an effects system?) (<a href=\"https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/\">https://tmandry.gitlab.io/blog/posts/2021-12-21-context-capabilities/</a>)</p>",
        "id": 276743989,
        "sender_full_name": "pachi",
        "timestamp": 1648326172
    },
    {
        "content": "<p>That's the closest thing in the works, yeah</p>",
        "id": 276744961,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648327645
    },
    {
        "content": "<p>I'm just referring to effects systems generally though</p>",
        "id": 276744971,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648327670
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"424212\">Ed Page</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/The.20Rust.20Model.20of.20Error.20Handling/near/276721853\">said</a>:</p>\n<blockquote>\n<p>Side note: zebra-test sounds similar to assert_cmd / assert_fs with snapbox and trycmd being the next steps up.</p>\n</blockquote>\n<p>I should really try out those crates, the rest of zebra-test isn't really the interesting part for me, but I did end up copying the context_from stuff into a WIP PR for color-eyre if you want to check it out:</p>",
        "id": 276816705,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648428665
    },
    {
        "content": "<p><a href=\"https://github.com/yaahc/color-eyre/pull/107\">https://github.com/yaahc/color-eyre/pull/107</a></p>",
        "id": 276816707,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648428667
    },
    {
        "content": "<p>touching on this again, as I work through the various problems ppl brought up in that twitter thread I'm going to create an error handling FAQ that can start to cross link to various docs with a focus on updating existing docs when there is confusion</p>",
        "id": 277800732,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649110198
    },
    {
        "content": "<p>starting with a question someone brought up in one of the error handling office hours meetings I've started holding. I had someone who was confused on when to use panic vs Result. There are existing lines in the docs on <code>panic!</code> that cover this but it's currently scattered across multiple paragraphs, gonna consolidate this into one section and cross link it from the various <code>unwrap</code>/<code>expect</code> methods on <code>Option</code> and <code>Result</code>.</p>",
        "id": 277801074,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649110383
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/pull/95660\">https://github.com/rust-lang/rust/pull/95660</a></p>",
        "id": 277806698,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649114027
    },
    {
        "content": "<p>Sounds good.  I was just doing a review of some code from someone new to rust, and they were bothering with a <code>Result</code> return from an <code>include_str!(\"...\").parse()</code> (essentially), so a good place to link for \"no you can just panic here\" would have been helpful.</p>",
        "id": 277809188,
        "sender_full_name": "scottmcm",
        "timestamp": 1649115938
    },
    {
        "content": "<p>Okay, I created the error handling FAQ starting point</p>",
        "id": 278051935,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649263241
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/project-error-handling/issues/50\">https://github.com/rust-lang/project-error-handling/issues/50</a></p>",
        "id": 278051937,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649263241
    },
    {
        "content": "<p>There's an interesting point made in the Hyper 1.0 roadmap (<a href=\"https://github.com/hyperium/hyper/pull/2806/files\">https://github.com/hyperium/hyper/pull/2806/files</a>) about error handling which I hadn't considered: if an error exposes underlying errors from dependencies via <code>source()</code>, then the dependency may be made public and thus an implicit (well, known only at runtime-only) part of the API, which seems obviously bad. I wonder if there should be advice in the FAQ for how to deal with this? I.e., some errors should probably be converted when added to the source or something?</p>",
        "id": 278128641,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649318111
    },
    {
        "content": "<p>(In general, this seems like another instance of the problem of errors crossing abstraction boundaries, much like showing stringified errors to users)</p>",
        "id": 278128751,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1649318169
    },
    {
        "content": "<p>I actually just added a note about that to eyre the other day</p>",
        "id": 278128801,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649318212
    },
    {
        "content": "<p><a href=\"https://github.com/yaahc/eyre/#usage-recommendations-and-stability-considerations\">https://github.com/yaahc/eyre/#usage-recommendations-and-stability-considerations</a></p>",
        "id": 278128840,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649318239
    },
    {
        "content": "<p>I'd be down to add that to the faq but I'd want to do so based on someone asking about it not ppl pointing it out as a footgun, otherwise it doesn't seem like a good fit for that format</p>",
        "id": 278128948,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649318301
    },
    {
        "content": "<p>I guess I didn't get into source specifically</p>",
        "id": 278129161,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649318410
    },
    {
        "content": "<p>And how source has the same issue as eyre Report or a box dyn error</p>",
        "id": 278129203,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649318424
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> thinking about it more I don't think that should be its own question, but it definitely feels like it belongs in the \"how should I structure my errors\" question</p>",
        "id": 278129297,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649318489
    },
    {
        "content": "<p>Which will almost certainly be a book in its own right x.x</p>",
        "id": 278129312,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649318500
    },
    {
        "content": "<p>It seems like that's even more so the case for anything that allows downcasting -- like <a href=\"https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast\">https://docs.rs/anyhow/latest/anyhow/struct.Error.html#method.downcast</a> means that any error from a dependency is implicitly part of your public API</p>",
        "id": 278201283,
        "sender_full_name": "scottmcm",
        "timestamp": 1649353588
    },
    {
        "content": "<p>Yeah <span aria-label=\"pensive\" class=\"emoji emoji-1f614\" role=\"img\" title=\"pensive\">:pensive:</span></p>",
        "id": 278205328,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649355460
    },
    {
        "content": "<p>I think this comes down to expectations which we can define, whether its downcasting, MSRV, <code>unstable</code> feature flags, \"bugs\", string output format, etc.  Anything can be a breaking change to someone, so we have to set expectations for what we will keep compatibility one.</p>",
        "id": 278209122,
        "sender_full_name": "Ed Page",
        "timestamp": 1649357252
    },
    {
        "content": "<p>maybe we should just update the standard library docs on <code>downcast</code> and <code>source</code> to assert that a type being namable via <code>downcast</code> does not imply a stability guarantee by the author who exposed that type via source or w/e, and that it is up to library authors to create a stability commitment for what types can be stably downcasted too.</p>",
        "id": 278209246,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1649357305
    }
]