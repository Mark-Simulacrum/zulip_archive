[
    {
        "content": "<p>I wish this is not duplicated. I found an annoying pain-point: Error Handling in FFI.</p>\n<hr>\n<p>First, for <code>recoverable error</code>itself, its handling in FFI context is not much different from the general case.<br>\nBut I'd like to get more guides on how to turn the convert between a Rust <code>recoverable error</code> to its  C counterpart.</p>\n<p>Specifically,  C doesn't have a native error handling paradigm, but there are a few common practices. For example, using error code to represent an error type, or using a string buffer provided by the caller to write error message in.</p>\n<p>So for example, it would be helpful to know how to cut the boilerplate codes on the conversion.<br>\nIt's also helpful to if Rust adopters to adopt some some practices, instead of using their own makeshift representation of C-compatible error types.</p>\n<hr>\n<p>For <code>unrecoverable error</code>, correct me if I were wrong, it's at least a synonym to, if not identical to, panic in most context.<br>\nBut panic in FFI context is really annoying since it's intertwined with memory management and safety.</p>\n<ul>\n<li>One solution to tackle this issue is to use a <code>std::panic::catch_unwind</code> to contain it in a \"sandbox\". But this has two issue.<br>\n    - First the trait bound on <code>UnwindSafe</code> is implemented for <code>Sync + Send</code> types. I'd like more details and examples on when <code>AssertUnwindSafe</code> wrapper could and could not be used.<ul>\n<li>Second, the documentation mentioned that it cannot catch panics which <em>abort the process</em>. But it'd be really helpful, especially beginners, if the documentation elaborates on how to verify this. Otherwise it's for people to confidently use <code>catch_unwind</code>.</li>\n</ul>\n</li>\n<li>Another common practice is to utilize edition 2018's feature <a href=\"https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/aborting-on-panic.html\"><code>aborting on panic</code></a>.  This is not wrong by itself, and is actually recommended in some sources I read. But is this really advisable, given that the memory may be not freed?</li>\n</ul>",
        "id": 211183888,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1600978348
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346097\">@Lucius Hu</span> I think improving interoperability with C error handling is quite relevant to the project group and probably something we should look into.</p>",
        "id": 211191460,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600982505
    },
    {
        "content": "<p>as for the panic handling, I think this is potentially something we could look into but might be something that is better handled by project-ffi-unwind</p>",
        "id": 211191529,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600982528
    },
    {
        "content": "<p>Generally though Rust can't enforce safety inside another language</p>",
        "id": 211191538,
        "sender_full_name": "oliver",
        "timestamp": 1600982535
    },
    {
        "content": "<p>Wouldn't panic handling effectively attempt to do that?</p>",
        "id": 211191608,
        "sender_full_name": "oliver",
        "timestamp": 1600982587
    },
    {
        "content": "<p>true. But we should promote good practice to make things right on Rust side</p>",
        "id": 211191610,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1600982589
    },
    {
        "content": "<p>So wrapping unsafe in a panic handler</p>",
        "id": 211191656,
        "sender_full_name": "oliver",
        "timestamp": 1600982629
    },
    {
        "content": "<p>C does also have a method for native 'faux'-error handling which is the compiler as does the Rust compiler which can identify unsoundness</p>",
        "id": 211191912,
        "sender_full_name": "oliver",
        "timestamp": 1600982778
    },
    {
        "content": "<p>So we cannot prevent error on the other side of FFI boundary, but we need to make sure errors occured  in Rust is managed properly.</p>\n<ul>\n<li>If Rust is calling a C library and C panics, we can not free the memory issues created by C, but we could probably do better on <code>reporting error</code> and relies on Rust's memory safety so at least memory managed on Rust side is properly freed.</li>\n<li>If a C program is calling a Rust library, that's what we have more controls. For example <code>ffi_support</code> crate used by Mozilla relies on <code>panic_unwind</code> to turn panic into (recoverable) error, so that the C side could properly free the memory. ( Otherwise if C side also panics that's really an issue )</li>\n</ul>",
        "id": 211192117,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1600982903
    },
    {
        "content": "<p>in short we cannot enforce any safety rules on other languages, but we need to minimize the chance memory safety issues could raise, by doing things right on Rust side.</p>",
        "id": 211192314,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1600983015
    },
    {
        "content": "<p>i believe this is what project-ffi-unwind is trying to do maybe</p>",
        "id": 211192379,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600983064
    },
    {
        "content": "<p>not sure</p>",
        "id": 211192387,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600983066
    },
    {
        "content": "<p>should check the charter</p>",
        "id": 211192391,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600983072
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/project-ffi-unwind/blob/master/charter.md\">https://github.com/rust-lang/project-ffi-unwind/blob/master/charter.md</a></p>",
        "id": 211192445,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600983109
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"120076\">@BatmanAoD (Kyle Strand)</span></p>",
        "id": 211192451,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600983114
    },
    {
        "content": "<p>thx</p>",
        "id": 211192499,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1600983126
    },
    {
        "content": "<p>and <a href=\"https://github.com/rust-lang/project-ffi-unwind/blob/master/rfcs/0000-c-unwind-abi.md\">https://github.com/rust-lang/project-ffi-unwind/blob/master/rfcs/0000-c-unwind-abi.md</a></p>",
        "id": 211192524,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600983153
    },
    {
        "content": "<p>but there's some overlapping parts for error-handling too</p>",
        "id": 211192531,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1600983161
    },
    {
        "content": "<p>for sure, I just want to be careful about duplicating effort</p>",
        "id": 211192554,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600983181
    },
    {
        "content": "<p>project-ffi-unwind is a lang team project idk what that implies</p>",
        "id": 211192558,
        "sender_full_name": "oliver",
        "timestamp": 1600983183
    },
    {
        "content": "<p>I guess I don't know all of the context behind <code>unsafe</code> but it seems to me that<br>\none isn't meant to be using it to introduce unsoundness</p>",
        "id": 211195106,
        "sender_full_name": "oliver",
        "timestamp": 1600984995
    },
    {
        "content": "<blockquote>\n<p>project-ffi-unwind is a lang team project idk what that implies</p>\n</blockquote>\n<p>It requires a lot of work on the parts of the codebase that's part of the lang team (while this project is under the libs team)</p>",
        "id": 211206808,
        "sender_full_name": "DPC",
        "timestamp": 1600994434
    },
    {
        "content": "<p>it was a rhetorical question but thanks for your input</p>",
        "id": 211206923,
        "sender_full_name": "oliver",
        "timestamp": 1600994593
    },
    {
        "content": "<p>for your reference questions in the english language typically end in a <code>?</code> mark</p>",
        "id": 211206934,
        "sender_full_name": "oliver",
        "timestamp": 1600994635
    },
    {
        "content": "<p>rhetorical meaning not requiring a response not intended to further the discussion</p>",
        "id": 211207014,
        "sender_full_name": "oliver",
        "timestamp": 1600994708
    },
    {
        "content": "<p>i know what's a rhetorical question, but in chat applications people often tend to omit the <code>?</code> even for normal questions</p>",
        "id": 211207417,
        "sender_full_name": "DPC",
        "timestamp": 1600995184
    },
    {
        "content": "<blockquote>\n<p>for your reference questions in the english language typically end in a ? mark</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"281739\">@Oliver</span> I'm sure it wasn't meant this way but this can come across as a bit condescending when we only have text to work with. Let's all try keep on topic, with language discussion focused on the ones we program in <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 211219782,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1601011367
    },
    {
        "content": "<p>Hi, I'll try to explain my views on the scope of the FFI-unwind project as it pertains to error-handling conventions. <span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby</span>, thanks for tagging me.</p>\n<p>First, though,  <span class=\"user-mention\" data-user-id=\"346097\">@Lucius Hu</span>, I'd like to understand what you mean by <code>recoverable error</code> and <code>unrecoverable error</code>. I think of those as purely \"conceptual\", i.e., they're not referring to specific language features but to an idea of how certain errors can or cannot be handled. I think this is how you mean it as well, but this part of your first post confuses me:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211183888\">said</a>:</p>\n<blockquote>\n<p>For <code>unrecoverable error</code>, correct me if I were wrong, it's at least a synonym to, if not identical to, panic in most context.</p>\n</blockquote>\n<p>I would agree that <code>panic</code> is the best mechanism for handling errors that the programmer thinks are not recoverable, and I suspect that this is a fairly widely-shared consensus in the community. Is that what you're suggesting here?</p>\n<p>I think I can also clarify the connection between <code>panic</code> and aborting:</p>\n<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211183888\">said</a>:</p>\n<blockquote>\n<p>- Second, the documentation mentioned that it cannot catch panics which <em>abort the process</em>. But it'd be really helpful, especially beginners, if the documentation elaborates on how to verify this. Otherwise it's for people to confidently use <code>catch_unwind</code>.<br>\n- Another common practice is to utilize edition 2018's feature <a href=\"https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/aborting-on-panic.html\"><code>aborting on panic</code></a>. </p>\n</blockquote>\n<p>These are actually referring to the same feature, which is not specific to the 2018 edition (despite appearing in the edition guide, which is a recognized point of confusion). The feature causes _all_ uses of <code>panic</code> in a compiled Rust binary (executable) into \"abort\" statements, causing the program to terminate immediately. A single executable should never have a mix of \"abort\" <code>panic</code>s and \"normal\" (unwinding) <code>panic</code>s.</p>\n<p><code>catch_unwind</code> can't catch aborts for the simple reason that when a process aborts, it does not check first whether a <code>catch_unwind</code> exists. So when compiled with <code>panic=abort</code>, <code>catch_unwind</code> essentially has no effect. So it is safe to use <code>catch_unwind</code> in libraries, regardless of whether they are used in programs using <code>panic=abort</code> or not.</p>\n<p>Regarding clean-up on <code>panic=abort</code>, in most contexts, there is actually no problem with not freeing memory. If your target platform has an operating system, it will automatically free all memory associated with a process once that process terminates. This is part of why it's actually considered safe in Rust to leak memory! There are some resources that _won't_ be cleaned up on some platforms; for instance, I believe that on most file systems, file descriptors can leak, which could be a problem. But I believe it is generally considered safe to abort a process on a \"full\" (i.e. not real-time) OS, because the OS will usually keep anything too bad from happening.</p>",
        "id": 211381446,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601152400
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120076\">@BatmanAoD (Kyle Strand)</span> <br>\nI used the terminology defined in the workgroup <a href=\"https://github.com/rust-lang/project-error-handling/blob/master/CHARTER.md\">charter</a></p>\n<blockquote>\n<p>Recoverable error: An error that can be reacted and recovered from when encountered e.g. a missing file.<br>\nUnrecoverable error: An error that cannot reasonably be reacted to or recovered from and which indicates a bug e.g. indexing out of bounds.</p>\n</blockquote>",
        "id": 211381645,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601152669
    },
    {
        "content": "<p>Oh wow! I didn't see that the charter was so fleshed out already. Sorry for missing that context; thanks for pointing me to it!</p>",
        "id": 211381700,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601152708
    },
    {
        "content": "<p>Thanks for the detailed explanations. It's true that on a modern OS memory not freed would eventually be recycled by OS. But people may use Rust-FFI for jobs where SECURITY is the top priority</p>",
        "id": 211381736,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601152779
    },
    {
        "content": "<p>I would say that the first two bullet points in the \"Come to a consensus on current best practices\" confirm what you wrote, then, that <code>panic</code> is synonymous with \"unrecoverable error\", or at least, that by convention they should be treated synonymously.</p>",
        "id": 211381745,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601152793
    },
    {
        "content": "<p>Hm. I wouldn't think of memory-cleanup as a security protection. Allocators do not typically _overwrite_ old memory.</p>",
        "id": 211381801,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601152825
    },
    {
        "content": "<p>(when freeing it)</p>",
        "id": 211381805,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601152838
    },
    {
        "content": "<p>I'm not talking about specific platform or OS, but just generic FFI. For simplicity we can assume it's something like x86_64 *unix. For more specific cases, they may better fit Embedded WG or others.</p>",
        "id": 211381832,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601152915
    },
    {
        "content": "<p>So the concern of memory security really troubles people. So if they don't matter due to some of Rust's design or due to guarantees offered by modern OS, I think we should explicit document it.</p>",
        "id": 211381902,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153031
    },
    {
        "content": "<p>Just for references.</p>",
        "id": 211381905,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153038
    },
    {
        "content": "<p>Either way, I don't see a close connection between security-related cleanup and either FFI or error handling in general. I think you're potentially right that for security-critical data, <code>abort</code> might be a dangerous choice, but I don't know enough about the field, and I think that's probably somewhat outside the scope of this group's concerns.</p>",
        "id": 211381958,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601153104
    },
    {
        "content": "<p>I found the security guide from the French spy agency really helpful <a href=\"https://anssi-fr.github.io/rust-guide/07_ffi.html#memory-and-resource-management\">https://anssi-fr.github.io/rust-guide/07_ffi.html#memory-and-resource-management</a></p>",
        "id": 211382050,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153257
    },
    {
        "content": "<p>Regarding FFI-unwind: our charter is fairly minimal. We are specifically concerned with control-flow constructs that cross between language boundaries, and making sure that the Rust compiler is able to emit code that interacts with these constructs without causing undefined behavior. The connection to error-handling, of course, is that such constructs are usually used for error-handling.</p>\n<p>Specifically, our first RFC was to establish a way for C++ exceptions to cross \"through\" Rust and back into C++, and for Rust <code>panic</code>s to cross \"through\" C++ and back into Rust. In each case:</p>\n<ul>\n<li>Resource clean-up via destructors and <code>Drop</code> must happen normally in each language</li>\n<li>If the unwinding is recovered from, that must happen in the language where the unwinding originated  (i.e. with <code>catch_unwind</code> for <code>panic</code> or <code>try</code>/<code>catch</code> for exceptions)</li>\n</ul>\n<p>Our next major effort, I think, will be to specify when it is safe to drop Rust frames without unwinding. This is what happens on most platforms with <code>longjmp</code> (which is true in C++ as well). In general, relying on <code>longjmp</code> should not be considered a \"best practice\" in Rust, but it's something that we sometimes need to deal with when interfacing with C libraries. Note that there is no way whatsoever for any language to perform cleanup on arbitrary target platforms when C <code>longjmp</code>s through it, so we definitely won't be introducing mechanisms for using <code>Drop</code> types in the presence of <code>longjmp</code>.</p>",
        "id": 211382101,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601153309
    },
    {
        "content": "<p>I agree that for some works maybe memory leak is not a very severe issue. But in some cases, there are strict guidelines developers must comply with if they ever want integration of  Rust-FFI.</p>",
        "id": 211382124,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153391
    },
    {
        "content": "<p>I think we would never recommend exposing <code>panic</code> across a language boundary as a go-to error-communication mechanism, though.</p>",
        "id": 211382125,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601153392
    },
    {
        "content": "<p>For example, if I want to make an R extension and publish it in CRAN, I think I need to ensure no memory leak. Because CRAN is running multiple tools to check memory leak all the time.</p>",
        "id": 211382177,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153455
    },
    {
        "content": "<p>Is that still related to error-handling? I'm a little confused.</p>",
        "id": 211382186,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601153483
    },
    {
        "content": "<p>It is. Because if we just let the Rust program panic, without proper handling, then memory could be leaked.</p>",
        "id": 211382242,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153564
    },
    {
        "content": "<p>That's more about RAII than error-handling.</p>",
        "id": 211382253,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601153586
    },
    {
        "content": "<p>_wondering how old this document from the spy agency you linked is_</p>",
        "id": 211382254,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601153586
    },
    {
        "content": "<p>It's published this year.</p>",
        "id": 211382262,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153599
    },
    {
        "content": "<p>interesting</p>",
        "id": 211382263,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601153603
    },
    {
        "content": "<p>It's immensely strict</p>",
        "id": 211382264,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153609
    },
    {
        "content": "<p><code>fn foo_create() -&gt; *mut RawFoo;</code></p>",
        "id": 211382267,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601153616
    },
    {
        "content": "<p>im surprised this isn't something like <code>fn foo_create() -&gt; Option&lt;NonNull&lt;RawFoo&gt;&gt;;</code> or w/e the syntax is</p>",
        "id": 211382277,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601153642
    },
    {
        "content": "<p>keep in mind i've done like no ffi</p>",
        "id": 211382315,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601153647
    },
    {
        "content": "<p>For a state-level adversary, someone must use that level of cautions lol</p>",
        "id": 211382317,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601153649
    },
    {
        "content": "<p>Re: unrecoverable errors and FFI: the \"sandbox\" approach for <code>panic</code> is almost certainly the only viable (and safe)  global/default approach. In our RFC for cross-language unwinding, we specified that <code>\"C\"</code> will now <code>abort</code> rather than let a <code>panic</code> cross the boundary. This makes <code>extern \"C\"</code> functions somewhat \"sandbox-like\" in that regard.</p>",
        "id": 211382348,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601153747
    },
    {
        "content": "<p>sick</p>",
        "id": 211382391,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601153767
    },
    {
        "content": "<p>Right, we need some guidelines like this. But sometimes abort alone is not enough to prevent memory leak.</p>",
        "id": 211382618,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154200
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"346097\">@Lucius Hu</span> in abort you'd still have the chance to run a panic hook, assuming you're aborting via libstd's aborting infrastructure</p>",
        "id": 211382666,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154266
    },
    {
        "content": "<p>i think</p>",
        "id": 211382668,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154287
    },
    {
        "content": "<p>let me double check</p>",
        "id": 211382669,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154290
    },
    {
        "content": "<p>In many cases one side of FFI boundary, either Rust or C, may need to manually call the destructor to free the memory. The problem of both abort and panic is that, if that ever happens, the program may not get the chance to call the destructor.</p>",
        "id": 211382670,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154291
    },
    {
        "content": "<p>I guess my summary would be that FFI-unwind is (currently) for dealing with the messy realities of systems programming as it exists today, where C is the lingua franca, so there is no language-level mechanism for handling errors, much less for distinguishing recoverable from non-recoverable errors. In this context, our job is mostly to \"protect\" Rust from C, and vice-versa.</p>\n<p>For less \"antagonistic\" cross-language error handling, I think we rely somewhat on the progress of some broader efforts in this direction:</p>\n<ul>\n<li>For \"traditional\" systems programming, the C and C++ communities have started collaborating a bit on sketching out what cross-language error handling might look like. The latest paper I've seen on this topic is here: <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2429.pdf\">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2429.pdf</a></li>\n<li>For target platforms of the future, I think WebAssembly Interface Types seem promising, and I hope that they include some built-in notion of error handling. <a href=\"https://hacks.mozilla.org/2019/08/webassembly-interface-types/\">https://hacks.mozilla.org/2019/08/webassembly-interface-types/</a></li>\n</ul>",
        "id": 211382682,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601154322
    },
    {
        "content": "<p>Yep there are some facilities for that. But we need to document and summarize them.</p>",
        "id": 211382750,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154411
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211382317\">said</a>:</p>\n<blockquote>\n<p>For a state-level adversary, someone must use that level of cautions lol</p>\n</blockquote>\n<p>why is encrypted memory not being used in the first place, or if it is, is there _really_ any distinction between memory that has been cleared and hasn't?</p>",
        "id": 211382752,
        "sender_full_name": "nagisa",
        "timestamp": 1601154413
    },
    {
        "content": "<p>ok, for example, though it's not related to Rust, one way of hacking MacBook is to dump the memory. Because in hibernation the memory still posses data which could be highly sensible. Clearly it's not feasible to encrypt all the memory right</p>",
        "id": 211382818,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154546
    },
    {
        "content": "<p>Fair, I guess we're still a couple years away from memory controllers in conventional laptops having ability to encrypt _all_ memory.</p>",
        "id": 211382871,
        "sender_full_name": "nagisa",
        "timestamp": 1601154606
    },
    {
        "content": "<p>In many scenarios we can not assume the underlying infrastructure has encryption, that's why we need extra effort to ensure no memory leak in the first place</p>",
        "id": 211382887,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154687
    },
    {
        "content": "<p>This is something that is available in server-chip space (e.g. as implemented by EPYCs) and I remember seeing embedded chips that have this functionality too.</p>",
        "id": 211382895,
        "sender_full_name": "nagisa",
        "timestamp": 1601154690
    },
    {
        "content": "<p>this is seeming more and more like a security topic that happens to intersect with error handling than something that is _about_ error handling</p>",
        "id": 211382896,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154703
    },
    {
        "content": "<p>yeah my bad ^^, feel free to split out the messages into a topic in <a class=\"stream\" data-stream-id=\"122651\" href=\"/#narrow/stream/122651-general\">#general</a></p>",
        "id": 211382951,
        "sender_full_name": "nagisa",
        "timestamp": 1601154739
    },
    {
        "content": "<p>no i dont think its you specifically, just the entire conversation has been drifting this way</p>",
        "id": 211382953,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154755
    },
    {
        "content": "<p>so I agree that we have many ways to ensure securities or let the OS recycle leaked memory. But it's best we can do as good as we can so we don't need those alternative approaches</p>",
        "id": 211382954,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154759
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211382954\">said</a>:</p>\n<blockquote>\n<p>so I agree that we have many ways to ensure securities or let the OS recycle leaked memory. But it's best we can do as good as we can so we don't need those alternative approaches</p>\n</blockquote>\n<p>this seems quite reasonable, the point I'm making though is I don't think it makes sense for the error handling project group in particular to oversee this work</p>",
        "id": 211382964,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154825
    },
    {
        "content": "<p>well to return to the topic, if we don't properly manage the \"unrecoverable error\", bad things could happen</p>",
        "id": 211382967,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154830
    },
    {
        "content": "<p>to me this seems more suited to an independent RFC</p>",
        "id": 211382968,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154834
    },
    {
        "content": "<p>im not sure if theres a security wg of some sort</p>",
        "id": 211382987,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154842
    },
    {
        "content": "<p>i know theres the unsafe code guidelines wg</p>",
        "id": 211383014,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154850
    },
    {
        "content": "<p><a class=\"stream\" data-stream-id=\"146229\" href=\"/#narrow/stream/146229-wg-secure-code\">#wg-secure-code</a> probably</p>",
        "id": 211383016,
        "sender_full_name": "nagisa",
        "timestamp": 1601154866
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"132721\">@Tony Arcieri</span></p>",
        "id": 211383036,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154911
    },
    {
        "content": "<p>there could be thousands of ways to cause a security breach, for this WG specifically, I think we need guidelines and documentations</p>",
        "id": 211383041,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601154930
    },
    {
        "content": "<p>ohai</p>",
        "id": 211383046,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601154955
    },
    {
        "content": "<p>to summarize the backscroll, we're talking about the security implementations of panics and ffi</p>",
        "id": 211383090,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601154992
    },
    {
        "content": "<p>aah</p>",
        "id": 211383091,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155001
    },
    {
        "content": "<p>and I think this might be more up your alley than mine</p>",
        "id": 211383093,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155004
    },
    {
        "content": "<p>so I'm not proposing that we need to invent additional stuff to ensure security, which is clearly not related to the WG. But since this WG is for generic error-handling, I think it fits to include guidelines for error-handling in FFI context</p>",
        "id": 211383096,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155022
    },
    {
        "content": "<p>especially since you got that zeroize crate</p>",
        "id": 211383097,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155022
    },
    {
        "content": "<p>seems very relevant</p>",
        "id": 211383101,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155025
    },
    {
        "content": "<p>so uhh, I'm not sure how much I can talk about here, but Google is working on some cool stuff in LLVM</p>",
        "id": 211383103,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155028
    },
    {
        "content": "<p>and yes I wrote <code>zeroize</code> but we can do a lot better <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 211383107,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155039
    },
    {
        "content": "<p>the idea I like the most is, for a lack of a better term, \"stack bleaching\" which is something being used a bit in the Linux kernel but also potentially possible with LLVM even across FFI boundaries</p>",
        "id": 211383152,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155087
    },
    {
        "content": "<p>the general idea is you decide you begin an operation with transient secrets on the stack, and the hard part is calculating the high watermark on the stack</p>",
        "id": 211383161,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155128
    },
    {
        "content": "<p>and once the entire set of operations is done, you zero the stack up to the high watermark</p>",
        "id": 211383168,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155144
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211383096\">said</a>:</p>\n<blockquote>\n<p>so I'm not proposing that we need to invent additional stuff to ensure security, which is clearly not related to the WG. But since this WG is for generic error-handling, I think it fits to include guidelines for error-handling in FFI context</p>\n</blockquote>\n<p>aah, okay that sounds fine. I think if we end up writing an error handling book that might be a good place to put guidelines about ffi memory safety concerns around error handling</p>",
        "id": 211383171,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155145
    },
    {
        "content": "<p>I'll have to defer to you on writing those guidelines though, but I'll be happy to review any chapters you contribute as much as I am able</p>",
        "id": 211383177,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155165
    },
    {
        "content": "<p>Hi Tony, my intention is, providing guidelines to better manage errors in FFI context, so we may not even need to deal with so much complications</p>",
        "id": 211383180,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155185
    },
    {
        "content": "<p><code>zeroize</code> is kind of a hack to accomodate what is possible in stable Rust today</p>",
        "id": 211383182,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155192
    },
    {
        "content": "<p>It's best if there's no error. If there is, it's best it's recoverable. If it's unrecoverable, it's best we \"sandbox\" it so we can gracefully do the clean up.</p>",
        "id": 211383227,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155239
    },
    {
        "content": "<p>yeah I'm not sure exactly what you need here per se. if there were really secrets on the stack, stack bleaching is probably the best option, otherwise I'm not sure what else you can do</p>",
        "id": 211383228,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155246
    },
    {
        "content": "<p>If otherwise, then things gets really complicated.... And that's where I want to avoid</p>",
        "id": 211383234,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155273
    },
    {
        "content": "<p>yeah exactly</p>",
        "id": 211383235,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155279
    },
    {
        "content": "<p>the nice thing about the stack bleaching approach is it's actually relatively simple and works cleanly across FFI boundaries, at least in the context of LLVM-compiled languages</p>",
        "id": 211383241,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155307
    },
    {
        "content": "<p>but when and if it hits mainline LLVM... TBD</p>",
        "id": 211383284,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155329
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211383227\">said</a>:</p>\n<blockquote>\n<p>It's best if there's no error. If there is, it's best it's recoverable. If it's unrecoverable, it's best we \"sandbox\" it so we can gracefully do the clean up.</p>\n</blockquote>\n<p>regarding this point, it seems like the ffi unwind group's current plans cover this</p>",
        "id": 211383286,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155337
    },
    {
        "content": "<p>and then there's Cranelift to think about</p>",
        "id": 211383287,
        "sender_full_name": "Tony Arcieri",
        "timestamp": 1601155339
    },
    {
        "content": "<p>the unwinding panic turns into an abort if it hits a c boundary and isn't caught with catch::unwind</p>",
        "id": 211383294,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155371
    },
    {
        "content": "<p>but you're still already doing the proper unwinding all the way up to that point</p>",
        "id": 211383296,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155381
    },
    {
        "content": "<p>with the ability to setup your panic hook and catch it as you see fit to secure the memory</p>",
        "id": 211383306,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601155400
    },
    {
        "content": "<p>that sounds great I will take a look</p>",
        "id": 211383308,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155419
    },
    {
        "content": "<p>but in the meantime, I'm not sure when their efforts will materialize...</p>",
        "id": 211383366,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155495
    },
    {
        "content": "<p>so even if their FFI unwinding mechanism cannot be completed, with careful handling of errors we can still do something to mitigate the risk of memory leak, with the existing features of Rust</p>",
        "id": 211383519,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155784
    },
    {
        "content": "<p>In my view that's also the value of error-handling. Although there are multiple ways to deal with the same problem ( e.g. memory leak ), it's best if we do it right in every aspect</p>",
        "id": 211383587,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155918
    },
    {
        "content": "<p>so they keep making their FFI unwind, and we could also contain the risk with good error handling</p>",
        "id": 211383638,
        "sender_full_name": "Lucius Hu",
        "timestamp": 1601155971
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211383286\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211383227\">said</a>:</p>\n<blockquote>\n<p>It's best if there's no error. If there is, it's best it's recoverable. If it's unrecoverable, it's best we \"sandbox\" it so we can gracefully do the clean up.</p>\n</blockquote>\n<p>regarding this point, it seems like the ffi unwind group's current plans cover this</p>\n</blockquote>\n<p>My only caveat would be that the development and communication of best practices would probably fall more in this group's purview than in FFI-unwind's. But yes, the RFC does specify a way to sandbox panics! I think we would also like to add some additional \"sandboxing\" features, but that starts to creep into effects-algebra territory, which is much broader.</p>",
        "id": 211383755,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601156166
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"346097\">Lucius Hu</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Error-Handling.20in.20FFI.20context/near/211383519\">said</a>:</p>\n<blockquote>\n<p>so even if their FFI unwinding mechanism cannot be completed, with careful handling of errors we can still do something to mitigate the risk of memory leak, with the existing features of Rust</p>\n</blockquote>\n<p>This is absolutely true. I think it would be entirely reasonable for a security-conscientious app to have a stack-bleach followed by <code>abort</code> inside a <code>catch_unwind</code> at the top of every <code>extern \"C\"</code> function. It's noisy, but it's safe.</p>",
        "id": 211383775,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1601156257
    },
    {
        "content": "<p>that sounds sick</p>",
        "id": 211383837,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1601156360
    }
]