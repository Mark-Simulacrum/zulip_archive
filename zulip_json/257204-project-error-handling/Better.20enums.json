[
    {
        "content": "<p>Often, I'll see libraries that have many different errors that could be raised, they'll often place them inside of one single enum that every function returns. It would be nice if you could specify that a function returns only a subset of an enum</p>",
        "id": 210592717,
        "sender_full_name": "alex",
        "timestamp": 1600482122
    },
    {
        "content": "<p>I think that would be especially useful if different functions return overlapping subsets of the set of possible errors, since that can't be modeled with nested enums.</p>",
        "id": 210593215,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1600482913
    },
    {
        "content": "<p>I think large error enums are an anti-pattern overall as it requires people to handle error cases that could be impossible to trigger. In my opinion, error enums should be as small and isolated as much as possible.</p>\n<p>That would also require a significant language changes and this is a libs team project group.</p>",
        "id": 210599668,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1600495482
    },
    {
        "content": "<blockquote>\n<p>I think large error enums are an anti-pattern overall as it requires people to handle error cases that could be impossible to trigger.</p>\n</blockquote>\n<p>/me glares at <a href=\"https://docs.rs/toml/0.5.6/toml/ser/fn.to_string.html\">https://docs.rs/toml/0.5.6/toml/ser/fn.to_string.html</a></p>",
        "id": 210614641,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600521313
    },
    {
        "content": "<p>err ... actually I might have just misread that page, it looks like that's specific to serialization errors</p>",
        "id": 210614663,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600521358
    },
    {
        "content": "<p>Right now, SNAFU encourages creating enums with some light recommendation to make <em>multiple</em> error types. One per module, for example, but also more. There's a ergonomic tradeoff between many variants that people have to handle vs many error types people have to handle.</p>\n<p>I'm working on something like this for SNAFU at the moment:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[derive(Debug, Snafu)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Error1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"cp\">#[derive(Debug, Snafu)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Error2</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"cp\">#[derive(Debug, Snafu)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Error3</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(Debug, Snafu)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">ErrorA</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Error1</span><span class=\"p\">(</span><span class=\"n\">Error1</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Error2</span><span class=\"p\">(</span><span class=\"n\">Error2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(Debug, Snafu)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">ErrorB</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Error3</span><span class=\"p\">(</span><span class=\"n\">Error3</span><span class=\"p\">),</span><span class=\"w\"> </span><span class=\"n\">Error2</span><span class=\"p\">(</span><span class=\"n\">Error2</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">f1</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Error1</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">f2</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Error2</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">f3</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">Error3</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">fa</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ErrorA</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f1</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f2</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">fb</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">ErrorB</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f3</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">f2</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 210615454,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600522420
    },
    {
        "content": "<p>I'll probably also need to figure out some way of going from subset enums to superset enums.</p>",
        "id": 210615515,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600522466
    },
    {
        "content": "<blockquote>\n<p>It would be nice if you could specify that a function returns only a subset of an enum</p>\n</blockquote>\n<p>As stated, that requires a language change. I'm seeking to achieve that goal by making creating the errors, enums, and conversions easier.</p>",
        "id": 210615574,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600522560
    },
    {
        "content": "<p>However, think of a library where every function returns a unique error type. I think you'd hate it.</p>",
        "id": 210615628,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600522590
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210615628\">said</a>:</p>\n<blockquote>\n<p>However, think of a library where every function returns a unique error type. I think you'd hate it.</p>\n</blockquote>\n<p>you'd <em>have</em> to use an error handling library that has a single error type</p>",
        "id": 210615642,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600522612
    },
    {
        "content": "<p>(or <code>Box&lt;dyn Error&gt;</code> everywhere)</p>",
        "id": 210615658,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1600522630
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210615628\">said</a>:</p>\n<blockquote>\n<p>However, think of a library where every function returns a unique error type. I think you'd hate it.</p>\n</blockquote>\n<p>This actually sounds appealing to me, and from my brief experience Rust seems to allow consuming such libraries with low overhead. Do you have more thoughts on why it would be undesirable? Perhaps because it'd be difficult/impossible to write catch-all handler functions?</p>",
        "id": 210618051,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600525941
    },
    {
        "content": "<p>As soon as you call two functions with different error types and want to return either, you need to unify them somehow. That means either boxing them or creating a new type (usually an enum). SNAFU is all about creating those enums easier, but itâ€™s still an amount of work you have to do.</p>",
        "id": 210619074,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600527258
    },
    {
        "content": "<p>So I guess my objection is that itâ€™s not actually low overhead.</p>",
        "id": 210619082,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600527286
    },
    {
        "content": "<p>Even with a language-based solution, youâ€™d still have to type all the specific variants in the signature (and then have all the downsides of a unnameable type)</p>",
        "id": 210619287,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600527527
    },
    {
        "content": "<p>Thereâ€™s also a decision about who takes on the overhead. If the library does it, then every user can benefit at the risk of it not being a perfect fit. If the library punts on it, then every user has to re-create similar work</p>",
        "id": 210619556,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600527948
    },
    {
        "content": "<p>For you what are the downsides of unnameable types?</p>",
        "id": 210619914,
        "sender_full_name": "oliver",
        "timestamp": 1600528407
    },
    {
        "content": "<p>That you canâ€™t name it :-)</p>\n<p>You canâ€™t document it, You canâ€™t reuse them without introducing duplication.</p>",
        "id": 210620563,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600529369
    },
    {
        "content": "<p>tl;dr is it a undocumented feature or a side effect of the type system?</p>",
        "id": 210620843,
        "sender_full_name": "oliver",
        "timestamp": 1600529718
    },
    {
        "content": "<p>there just doesn't seem to be a whole lot of attention given to it overall</p>",
        "id": 210620980,
        "sender_full_name": "oliver",
        "timestamp": 1600529899
    },
    {
        "content": "<p>Iâ€™m not sure exactly what you are referring to. Right now thereâ€™s no language feature for anonymous enums, which is what I think the initial intent was. </p>\n<p>There are anonymous types around traits, which is mostly what Iâ€™m basing the downsides around.</p>",
        "id": 210621326,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600530291
    },
    {
        "content": "<p>From what I can gather at a glance unnameable types are a problem which work has gone into to mitigate and anonymous enums are a proposed feature</p>",
        "id": 210621691,
        "sender_full_name": "oliver",
        "timestamp": 1600530873
    },
    {
        "content": "<p>This might also be related to opaque types?</p>",
        "id": 210622212,
        "sender_full_name": "oliver",
        "timestamp": 1600531627
    },
    {
        "content": "<p>I feel that, it's not that useful to <code>enum</code> all kinds of errors. It would be more useful if we can classify error into how we want to deal with them. Basically there's three strategies: Abort,  Retry, Ignore. If you already decided to abort, what caused it is not at all very useful... It's in what situations you should retry or ignore is very useful.</p>",
        "id": 210626321,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600537355
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281739\">oliver</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210621691\">said</a>:</p>\n<blockquote>\n<p>From what I can gather at a glance unnameable types are a problem which work has gone into to mitigate and anonymous enums are a proposed feature</p>\n</blockquote>\n<p>Maybe? Rust 1.0 had unnamable types (every closure), then Rust 1.26 added <code>impl Trait</code> syntax to allow semi-naming them, at least their shape. Work continues on to make these more useful.</p>",
        "id": 210627361,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600538895
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210626321\">said</a>:</p>\n<blockquote>\n<p>I feel that, it's not that useful to <code>enum</code> all kinds of errors. It would be more useful if we can classify error into how we want to deal with them. </p>\n</blockquote>\n<p>This assumes that there's a single such grouping. What categorization is \"failing to open a file\"?</p>",
        "id": 210627398,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600538992
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210615628\">said</a>:</p>\n<blockquote>\n<p>However, think of a library where every function returns a unique error type. I think you'd hate it.</p>\n</blockquote>\n<p>you could possibly paper over the effects of this by doing something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">// in library</span>\n<span class=\"cp\">#[derive(From, Into)]</span><span class=\"w\">   </span><span class=\"c1\">// imagine this is from derive_more or w/e</span>\n<span class=\"k\">enum</span> <span class=\"nc\">AllErrors</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Error1</span><span class=\"p\">(</span><span class=\"n\">Error1</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Error2</span><span class=\"p\">(</span><span class=\"n\">Error2</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// in app</span>\n<span class=\"k\">enum</span> <span class=\"nc\">AppError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">LibraryError</span><span class=\"p\">(</span><span class=\"n\">AllErrors</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">AppError</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nb\">Into</span><span class=\"o\">&lt;</span><span class=\"n\">AllErrors</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">from</span><span class=\"p\">(</span><span class=\"n\">e</span>: <span class=\"nc\">T</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">AppError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">AppError</span>::<span class=\"n\">LibraryError</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">into</span><span class=\"p\">())</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>unfortunately this would instantly conflict with other trait impls, such as <code>Impl Into&lt;AllErrors&gt; for AppError</code>... need specialization again? or perhaps the library exports a macro that explicitly impls From for all its errors for a given type.</p>",
        "id": 210627645,
        "sender_full_name": "Markus Unterwaditzer",
        "timestamp": 1600539300
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210626321\">said</a>:</p>\n<blockquote>\n<p>It would be more useful if we can classify error into how we want to deal with them.</p>\n</blockquote>\n<p>Some errors may also result in UB where others do not.</p>",
        "id": 210628701,
        "sender_full_name": "oliver",
        "timestamp": 1600540547
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"344315\">@Markus Unterwaditzer</span> I think that would run into <a href=\"https://stackoverflow.com/q/37347311/155423\">https://stackoverflow.com/q/37347311/155423</a> quickly. However, the enum that you've described is more-or-less exactly what SNAFU does. With current syntax:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[derive(Debug, Snafu)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">AllErrors</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Error1</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"nc\">Error1</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Error2</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"nc\">Error2</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 210628931,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600540804
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281739\">oliver</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210628701\">said</a>:</p>\n<blockquote>\n<p>Some errors may also result in UB where others do not.</p>\n</blockquote>\n<p>That sounds (a) interesting (b) hard-to-believe and (c) like a separate topic. Perhaps you'd care to start a new topic describing how that could happen?</p>",
        "id": 210628994,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600540890
    },
    {
        "content": "<p>Not especially if it isn't toally germane to the current discussion</p>",
        "id": 210629070,
        "sender_full_name": "oliver",
        "timestamp": 1600540954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210615628\">said</a>:</p>\n<blockquote>\n<p>However, think of a library where every function returns a unique error type. I think you'd hate it.</p>\n</blockquote>\n<p>Is that any worse than each <code>Iterator</code> function returning its own iterator type?</p>",
        "id": 210635297,
        "sender_full_name": "isHavvy",
        "timestamp": 1600549532
    },
    {
        "content": "<p>It certainly feels different. Other than itertools, I donâ€™t know of a library where every function returns an iterator. ðŸ˜…</p>",
        "id": 210635976,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600550572
    },
    {
        "content": "<p>Thereâ€™s also a matter of composition. Iterators tend to compose with less hassle.</p>",
        "id": 210636001,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600550636
    },
    {
        "content": "<p>Although I think improving error-bearing iterators could also be something the project looks at and potentially improves</p>",
        "id": 210636057,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600550686
    },
    {
        "content": "<p>Although a different topic as well.</p>",
        "id": 210636061,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600550703
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"240091\">@alex</span> circling back to your original point, <strong>why</strong> do <em>you</em> wish for such a feature? You gave a potential implementation, but glossed over the benefit you are seeking.</p>",
        "id": 210636319,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600551044
    },
    {
        "content": "<blockquote>\n<p>Iterators tend to compose with less hassle.</p>\n</blockquote>\n<p>You can get easy composition of errors by boxing them always, but then you lose the ability to easily test for a specific error. </p>\n<p>Iterators also tend to wrap their underlying iterator via generics. Thatâ€™s something that errors could do (and SNAFU supports it) but itâ€™s pretty unusual.</p>",
        "id": 210637731,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600553479
    },
    {
        "content": "<p><code>fn foo() -&gt; Result&lt;(), impl Error&gt;</code> would likewise be surprising.</p>",
        "id": 210637781,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600553557
    },
    {
        "content": "<p>I'm a bit confused about the composition-without-boxing issue. Isn't that trivial? <code>?</code> automatically calls <code>into()</code> if necessary, and the conversion from one enum into a \"superset\" enum should be very simple (in fact it could even be a no-op in most cases).</p>",
        "id": 210637900,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1600553785
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120076\">@BatmanAoD (Kyle Strand)</span> I think the point is that the superset enum doesn't exist unless the library provides it</p>",
        "id": 210638104,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554125
    },
    {
        "content": "<p>and if you do this \"right\" you then presumably need <em>tons</em> of such enums</p>",
        "id": 210638113,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554141
    },
    {
        "content": "<p>for every pair/three/... distinct small error enums/structs in your library</p>",
        "id": 210638119,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554165
    },
    {
        "content": "<p>and at that point you really just want language support. One thing I've thought about historically is that if we had \"enum from impl Trait\" or similar, we could do something like <code>Result&lt;(), impl Any + Error&gt;</code>, but it's ... not perfect, perhaps</p>",
        "id": 210638139,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554212
    },
    {
        "content": "<p>though I guess error already supports downcasting, so you don't need the Any</p>",
        "id": 210638183,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554248
    },
    {
        "content": "<p>Right, but that's a different problem than composability, I think. But yes, that's a ton of code.</p>",
        "id": 210638190,
        "sender_full_name": "BatmanAoD (Kyle Strand)",
        "timestamp": 1600554273
    },
    {
        "content": "<p>I think the problem is that easily composable errors lead you to big error enums (or erased errors), both of which mean that you can't easily know \"okay, I've handled all cases that this function can return\"</p>",
        "id": 210638216,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554326
    },
    {
        "content": "<p>kind of like how e.g. std::io::copy between two vectors basically can't fail, but the compiler can't catch it for you today because it just returns io::Result</p>",
        "id": 210638265,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554368
    },
    {
        "content": "<p>Pedantically, it calls <code>into</code> unconditionally <span aria-label=\"innocent\" class=\"emoji emoji-1f607\" role=\"img\" title=\"innocent\">:innocent:</span></p>\n<p>The non-trivial point I see is the creation of those enums. The language doesnâ€™t create them for you. SNAFU can help, but people seem to prefer the boxing path, presumably because of the simplicity of use. </p>\n<p>How do you see those enums being defined / created? An interesting exercise would be 3 leaf errors and then all 6 permutations of those errors (half demonstrated above)</p>",
        "id": 210638269,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600554372
    },
    {
        "content": "<p>Or <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> could say the same thing but better while Iâ€™m typing. ðŸ˜´</p>",
        "id": 210638288,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600554427
    },
    {
        "content": "<p>It's certainly an interesting (and hard!) problem to solve. fine-grained composability, especially with semver-promises, seems both fragile and perhaps too similar to checked exceptions from Java to my liking... but it may also be not that bad, if you can have the compiler take care of it for you. I think my major complaint with checked exceptions in Java was always repeating myself in the callstack</p>",
        "id": 210638359,
        "sender_full_name": "simulacrum",
        "timestamp": 1600554510
    },
    {
        "content": "<p>The use pattern for errors is that you generally care about one or two types and you pass the rest to the default handler (up the stack). I've seen entire libraries written to throw Exception (a general type of error) in Java because there are just too many exception cases propagating around. This is similar to the Anyhow solution, which might not be ideal, but it gets the job done without loss of sanity. :) It seems like there should be something better in a language known for its strong typing, though.</p>",
        "id": 210640707,
        "sender_full_name": "Jason Smith",
        "timestamp": 1600558876
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> for the repeating bit do you mean writing errors out in the signature of leaf functions and then having to write those errors in every function that calls those?</p>",
        "id": 210644027,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600565856
    },
    {
        "content": "<p>Yep, though I don't know of a good solution</p>",
        "id": 210644064,
        "sender_full_name": "simulacrum",
        "timestamp": 1600565885
    },
    {
        "content": "<p>I'm not super familiar with checked exceptions</p>",
        "id": 210644065,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600565886
    },
    {
        "content": "<p>I'm wondering if somehow associated types could help with this</p>",
        "id": 210644068,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600565900
    },
    {
        "content": "<p>like if you could create an associated error type for a function</p>",
        "id": 210644072,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600565917
    },
    {
        "content": "<p>then use an anon enum to define it, and then you could name that associated type</p>",
        "id": 210644077,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600565933
    },
    {
        "content": "<p>I feel like unioning the different error types would still be an issue tho</p>",
        "id": 210644087,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600565973
    },
    {
        "content": "<p>Hm, perhaps. I think the challenge is that you probably want semver guarantees for the list (at least that it won't grow, shrinking seems fine), but to do that well you really do want to enumerate the list, at least in public functions</p>",
        "id": 210644134,
        "sender_full_name": "simulacrum",
        "timestamp": 1600566029
    },
    {
        "content": "<p>But I personally haven't written ~any Rust libraries with error types, so maybe this is not too much of a problem in practice. Certainly I can't think of cases where I sort of wanted this</p>",
        "id": 210644147,
        "sender_full_name": "simulacrum",
        "timestamp": 1600566120
    },
    {
        "content": "<p>(I guess for e.g. serde it would be cool to have infallible serialization, but that seems hard and not worth it)</p>",
        "id": 210644186,
        "sender_full_name": "simulacrum",
        "timestamp": 1600566157
    },
    {
        "content": "<p>I think most of the time when I've felt an API returning a smaller set would be good, that wouldn't be practical because the API is a trait or equivalent to that, and so having the error type be more specific isn't practical</p>",
        "id": 210644231,
        "sender_full_name": "simulacrum",
        "timestamp": 1600566256
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210627398\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116458\">Charles Lew</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210626321\">said</a>:<br>\nThis assumes that there's a single such grouping. What categorization is \"failing to open a file\"?</p>\n</blockquote>\n<p>I think callee define all kinds of errors, and caller define the categorization.</p>",
        "id": 210644763,
        "sender_full_name": "Charles Lew",
        "timestamp": 1600567393
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Slightly off topic but serde does have infallible serialisation since the error type is an associated type of Serializer. So you could just use a unit struct for that particular case.</p>",
        "id": 210652241,
        "sender_full_name": "XAMPPRocky",
        "timestamp": 1600583340
    },
    {
        "content": "<p>Straw man syntax:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">enum</span> <span class=\"nc\">LibraryError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">E1</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E3</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"n\">FooError</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"nb\">Err</span><span class=\"p\">(</span><span class=\"n\">LibraryError</span>::<span class=\"n\">E3</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"n\">subenum</span><span class=\"w\"> </span><span class=\"n\">FooError</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">LibraryError</span>::<span class=\"p\">{</span><span class=\"n\">E2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">E3</span><span class=\"p\">};</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 210653759,
        "sender_full_name": "isHavvy",
        "timestamp": 1600586333
    },
    {
        "content": "<p>We would extend <code>as</code> to allow casting from a subenum to its parent enum (or parent subenum should we allow subenums of subenums)</p>",
        "id": 210653924,
        "sender_full_name": "isHavvy",
        "timestamp": 1600586709
    },
    {
        "content": "<p>subenum should probably just auto-coerce into the parent type as necessary.</p>",
        "id": 210654186,
        "sender_full_name": "Lokathor",
        "timestamp": 1600587205
    },
    {
        "content": "<p>That can work. The main thing I think that should stand out about one is that you can match over <code>FooError</code> and not have to worry about <code>LibraryError::E1</code>. Could even possibly allow associated items on <code>FooError</code>.</p>",
        "id": 210654355,
        "sender_full_name": "isHavvy",
        "timestamp": 1600587509
    },
    {
        "content": "<p>I'd like to submit the approach that I've been using briefly, but have been contemplating for a while. For reference, a lot of this approach can be seen in the first commit for a small new <a href=\"https://github.com/eZanmoto/dpnd/blob/master/src/main.rs\">project</a> I'm working on.</p>\n<p>I currently prefer the approach of simply having a unique error enum for each function that describes the all the different failures that that function can generate. This has the negative of being more work for the function author, but has the most flexibility in my opinion.</p>\n<p>An example is the \"leaf\" method <code>parse_deps</code>, which can return a <code>ParseDepsError</code>, defined as follows:</p>\n<div class=\"codehilite\"><pre><span></span><code>enum ParseDepsError {\n    DupDepName(usize, String, usize),\n    InvalidDepName(usize, String, usize),\n    InvalidDepSpec(usize, String),\n    UnknownTool(usize, String, String),\n}\n</code></pre></div>\n\n\n<p>(For this, I think that record syntax would provide much better readibility and I intend to refactor <code>ParseDepsError</code> to use it; I'll leave this aspect of the discussion to the side for now.)</p>\n<p>In terms of composability, I think that the best approach is for consuming functions to simply nest inner errors in their own error enums. For example, <code>parse_deps</code> is called by <code>parse_deps_conf</code>, which has the following error enum:</p>\n<div class=\"codehilite\"><pre><span></span><code>enum ParseDepsConfError {\n    MissingOutputDir,\n    ParseDepsFailed(ParseDepsError),\n}\n</code></pre></div>\n\n\n<p>It adds its own extra failure condition, but in the case of a sub-failure, it simply tags it and nests it. A handler then has the choice of drilling into the error to get more information, if they want.</p>\n<p>To cater for slightly easier error-handling I also have a <code>wrap_err!</code> macro, similar in nature to <code>try!</code>:</p>\n<div class=\"codehilite\"><pre><span></span><code>macro_rules! wrap_err {\n    ($x:expr, $y:path $(, $z:expr)* $(,)?) =&gt; {{\n        match $x {\n            Ok(v) =&gt; {\n                v\n            },\n            Err(e) =&gt; {\n                return Err($y(e $(, $z)*));\n            },\n        }\n    }}\n}\n</code></pre></div>\n\n\n<p>I'll give an example usage. <code>install</code> can return an <code>InstallError</code>, and one of its possible values is <code>CreateMainOutputDirFailed(IoError, PathBuf)</code>. This allows for the following call:</p>\n<div class=\"codehilite\"><pre><span></span><code>wrap_err!(\n    fs::create_dir_all(&amp;conf.output_dir),\n    InstallError::CreateMainOutputDirFailed,\n    conf.output_dir,\n);\n</code></pre></div>\n\n\n<p>This, like <code>try!</code>, returns the <code>Ok</code> value of the call on success. On <code>Err(err)</code>, however, the function will return <code>CreateMainOutputDirFailed(err, conf.output_dir)</code>, which nests the error and adds some contextual information, for both logical and debugging purposes. From my understanding, \"wrapping\" the error in such a way is trickier with <code>try!</code> because of the following:</p>\n<ul>\n<li><code>impl From&lt;io::Error&gt; for MyError</code> must be implemented for each wrapped error type, and you can't distinguish between different <code>io::Error</code>s.</li>\n<li>You can't add contextual information.</li>\n</ul>\n<p>The big caveat of <code>wrap_err!</code>, in my opinion, is its blockiness. My personal code style has some accountability here, but looking at the definition of <a href=\"https://github.com/eZanmoto/dpnd/blob/master/src/main.rs#L39\"><code>install</code></a>, you can probably see how <code>wrap_err</code> obscures the \"happy path\" logic somewhat. I think this could probably be remedied somewhat by adding <code>wrap_err!</code> support to <code>Result</code>, so that the following could be done:</p>\n<div class=\"codehilite\"><pre><span></span><code>fs::create_dir_all(&amp;conf.output_dir)\n    .wrap_err!(\n        InstallError::CreateMainOutputDirFailed,\n        conf.output_dir,\n    );\n</code></pre></div>\n\n\n<p>But that's more of a personal improvement idea, rather than a suggestion.</p>\n<p>One benefit of the above approach, in my opinion, is to be able to define a comprehensive error handler at the top level which can give very specific error messages. Even better, in my opinion, is that the error messages themselves are defined at the top level, where they belong, as opposed to in the generating functions, as you might find in say, Go error handling, for example. Again, it might not be to everyone's liking, but <a href=\"https://github.com/eZanmoto/dpnd/blob/master/src/main.rs#L261\">here</a> is the top-level error handling routine that I mention. Note also that such a routine is much more amenable to say, localisation, and other processing, in my opinion.</p>\n<p>Sorry for the wall of text; like I mentioned, these are ideas that have been germinating for a while and I'm excited to suggest. Let me know what you think!  Thanks.</p>",
        "id": 210658659,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600595596
    },
    {
        "content": "<p>As a side note, I also adopted the following convention in the above project:</p>\n<blockquote>\n<p>This project also identifies two types of error value. An error that contains a nested error is considered a \"failed operation\" error. Such error values should end with <code>Failed</code> and the nested error(s) should be the first listed in the associated tuple data. For example:</p>\n<div class=\"codehilite\"><pre><span></span><code>enum InstallError&lt;E&gt; {\n    GetCurrentDirFailed(IoError),\n    ...\n}\n</code></pre></div>\n\n\n<p>Any other error is considered a \"root\" error, and has no required naming or data conventions. For example:</p>\n<div class=\"codehilite\"><pre><span></span><code>enum InstallError&lt;E&gt; {\n    ...\n    NoDepsFileFound,\n    ...\n}\n\nenum ParseDepsError {\n    InvalidDependencySpec(usize, String),\n    UnknownTool(usize, String, String),\n}\n</code></pre></div>\n\n\n</blockquote>",
        "id": 210658704,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600595656
    },
    {
        "content": "<p>hi <span class=\"user-mention\" data-user-id=\"344273\">@SeÃ¡n Kelleher</span>, some thoughts on your suggestions:</p>\n<p>the wrap_err function you suggested sounds a lot like map_err, is there a reason you didn't use that? alternatively it's very similar to the context function on SNAFU.</p>\n<p>regarding the print_install_error, is there a reason you didn't implement the error trait and use that to print your errors? I have a great deal of interest in this specific problem myself and wonder what you think of error reporting crates like eyre and anyhow that are built ontop of the error trait and why you choose to implement a manual printing method specific to your error type rather than using error trait based composition to print your errors generically.</p>",
        "id": 210661322,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600599851
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"344273\">@SeÃ¡n Kelleher</span> yes, it sounds like you have 90-95% overlap with the goals and current implementation of  SNAFU</p>",
        "id": 210662159,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600600985
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">fs</span>::<span class=\"n\">create_dir_all</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">conf</span><span class=\"p\">.</span><span class=\"n\">output_dir</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">context</span><span class=\"p\">(</span><span class=\"n\">CreateMainOutputDirFailed</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">dir</span>: <span class=\"nc\">conf</span><span class=\"p\">.</span><span class=\"n\">output_dir</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"o\">?</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 210662182,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600601043
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[derive(Debug, Snafu)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">ParseDepsError</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[snafu(display(</span><span class=\"s\">&quot;This is the text {}, {}&quot;</span><span class=\"cp\">, alpha, gamma))]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">DupDepName</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">alpha</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">beta</span>: <span class=\"nb\">String</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">gamma</span>: <span class=\"kt\">usize</span> <span class=\"p\">},</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 210662246,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600601118
    },
    {
        "content": "<blockquote>\n<p>much more amenable to say, localisation</p>\n</blockquote>\n<p>Yep. My hope is to combine Fluent somehow <a href=\"https://github.com/projectfluent/fluent-rs/issues/107\">https://github.com/projectfluent/fluent-rs/issues/107</a></p>",
        "id": 210662334,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600601250
    },
    {
        "content": "<p>Hi Jane and Jake,</p>\n<p>Thanks very much for the questions. For the most part, I must admit I don't have much familiarity with Rust, and so a lot of my approach is a halfway-house between my personal ideal and whatever tools make themselves apparent to me at the time. As such, I wasn't actually aware of <code>map_err</code>, but at a cursory glance the main difference I can see is that <code>wrap_err!</code> is able to <code>return</code> the resulting error, but with <code>map_err</code> that would need to be done in a following statement. Other than that I think <code>map_err</code> looks almost ideal, if it can be used like the following:</p>\n<div class=\"codehilite\"><pre><span></span><code>fs::create_dir_all(&amp;conf.output_dir)\n    .map_err(|err| { InstallError::CreateMainOutputDirFailed(err, conf.output_dir) });\n</code></pre></div>\n\n\n<p>Looking at SNAFU, it looks like the context issue is handled quite nicely with it.</p>\n<p>I'm not fully sure about your question about implementing the error trait, I might have to take a look at <code>eyre</code> and <code>anyhow</code> to compare the approaches; it could very well be that they achieve the same thing. If it's in terms of having the error be able to describe itself, I think that's useful to have, but I think that it's ultimately the application should render errors to the user manually, and relying on error's own descriptions can present errors in terms that are too low-level; this would be how things work in Go anyway, which is my primary language. Sorry if I've misunderstood though.</p>",
        "id": 210662565,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600601621
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210662182\">said</a>:</p>\n<blockquote>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">fs</span>::<span class=\"n\">create_dir_all</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">conf</span><span class=\"p\">.</span><span class=\"n\">output_dir</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">.</span><span class=\"n\">context</span><span class=\"p\">(</span><span class=\"n\">CreateMainOutputDirFailed</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">dir</span>: <span class=\"nc\">conf</span><span class=\"p\">.</span><span class=\"n\">output_dir</span><span class=\"w\"> </span><span class=\"p\">})</span><span class=\"o\">?</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n</blockquote>\n<p>I actually haven't looked into SNAFU yet, but this looks ideal.</p>",
        "id": 210662620,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600601693
    },
    {
        "content": "<p>Ah, I just realised that <code>map_err</code> can/should be used with <code>?</code> (I only checked the docs for usage); that actually works better than <code>wrap_err</code> in that case so.</p>",
        "id": 210662703,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600601814
    },
    {
        "content": "<blockquote>\n<p>but I think that it's ultimately the application should render errors to the user manually</p>\n</blockquote>\n<p>I think you'll ultimately find this to be difficult. For that to be fully realized, every error exposed by every library would have to give complete access to all the variants. This makes it much harder for a library to adhere to semver, and is probably downright impossible given platform-specific concerns.</p>",
        "id": 210663068,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600602389
    },
    {
        "content": "<p>but within a specific crate, sure.</p>",
        "id": 210663079,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600602418
    },
    {
        "content": "<blockquote>\n<p>about implementing the error trait,</p>\n</blockquote>\n<p>Note that SNAFU also defines the Error trait for you.</p>",
        "id": 210663146,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600602492
    },
    {
        "content": "<p>the way it normally works is you describe your errors with the error trait and then you define how to display them with a reporter</p>",
        "id": 210663325,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602776
    },
    {
        "content": "<p>I actually did a whole talk on this if you want a nice primer</p>",
        "id": 210663334,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602790
    },
    {
        "content": "<p><a href=\"https://youtu.be/rAF8mLI0naQ\">https://youtu.be/rAF8mLI0naQ</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"rAF8mLI0naQ\" href=\"https://youtu.be/rAF8mLI0naQ\"><img src=\"https://i.ytimg.com/vi/rAF8mLI0naQ/default.jpg\"></a></div>",
        "id": 210663337,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602809
    },
    {
        "content": "<p>I even mention how this relates to go error handling briefly</p>",
        "id": 210663343,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602837
    },
    {
        "content": "<p>tho admittedly I know very little about go</p>",
        "id": 210663382,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602847
    },
    {
        "content": "<p>this doesn't really help with localization, in that case it's up to the author of the crate to provide localization support rather than the author of the app</p>",
        "id": 210663411,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602903
    },
    {
        "content": "<p>but this means that there's much less duplicated work, you don't end up with every crate that depends on your crate having to reimplement localization and error messages</p>",
        "id": 210663431,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602937
    },
    {
        "content": "<p>Thanks for the primer Jane.</p>",
        "id": 210663488,
        "sender_full_name": "Charles Ellis O'Riley Jr.",
        "timestamp": 1600602978
    },
    {
        "content": "<p>it's all tradeoffs, tho I doubt many people would want to adopt an error handling style where they have to define the error messages for foreign error types</p>",
        "id": 210663493,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600602987
    },
    {
        "content": "<p>people already hate how verbose it is to just implement Error Display and From manually</p>",
        "id": 210663497,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600603010
    },
    {
        "content": "<p>and that's just for the local error types</p>",
        "id": 210663499,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1600603018
    },
    {
        "content": "<p>would be nice to have <code>#[derive(Error)]</code> some point in the future <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 210664067,
        "sender_full_name": "DPC",
        "timestamp": 1600603916
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120823\">DPC</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210664067\">said</a>:</p>\n<blockquote>\n<p>would be nice to have <code>#[derive(Error)]</code> some point in the future :P</p>\n</blockquote>\n<p>I doubt it, just because <code>Error: Display</code> and deriving <code>Display</code> isn't really a _thing_.</p>",
        "id": 210664492,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600604546
    },
    {
        "content": "<p>i'm aware hence \"some point in future\" <span aria-label=\"stuck out tongue\" class=\"emoji emoji-1f61b\" role=\"img\" title=\"stuck out tongue\">:stuck_out_tongue:</span></p>",
        "id": 210664611,
        "sender_full_name": "DPC",
        "timestamp": 1600604710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210663325\">said</a>:</p>\n<blockquote>\n<p>the way it normally works is you describe your errors with the error trait and then you define how to display them with a reporter</p>\n</blockquote>\n<p>I mildly object to \"normally\", unless you call <code>unwrap</code>/<code>expect</code>/<code>println</code> a \"reporter\". Perhaps that's how it should be though.</p>",
        "id": 210665322,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600605697
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"344273\">@SeÃ¡n Kelleher</span> another point is that you can define Error and Display for your error types but still match on them to do whatever you want, like display them differently</p>",
        "id": 210665395,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600605790
    },
    {
        "content": "<p>SNAFU provides simple automatic implementations of Display, so you can use those if you mostly want to ignore Display anyway</p>",
        "id": 210665458,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600605870
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210663068\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but I think that it's ultimately the application should render errors to the user manually</p>\n</blockquote>\n<p>I think you'll ultimately find this to be difficult. For that to be fully realized, every error exposed by every library would have to give complete access to all the variants. This makes it much harder for a library to adhere to semver, and is probably downright impossible given platform-specific concerns.</p>\n</blockquote>\n<p>It's a good point in terms of practicality, and perhaps it's just a pipe dream. However, in terms of semver, I'm not fully sure how this could be addressed without having each function return <code>Error</code>. For example, I would expect that the idea of specifying subsets of <code>Error</code> for specific functions runs into the same issues with semver.</p>",
        "id": 210666579,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600607468
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210663334\">said</a>:</p>\n<blockquote>\n<p>I actually did a whole talk on this if you want a nice primer</p>\n</blockquote>\n<p>That's great, thanks for linking, I'll take a look at this later.</p>",
        "id": 210666592,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600607509
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210663493\">said</a>:</p>\n<blockquote>\n<p>it's all tradeoffs, tho I doubt many people would want to adopt an error handling style where they have to define the error messages for foreign error types</p>\n</blockquote>\n<p>I suppose this is the crux of the matter, and I would admit that my approach is a theoretical purist one (at least in my opinion), and wouldn't necessarily suit everyone's tastes. Thankfully, the different options I've seen so far seem fairly orthogonal, and I'm very happy with what I've been able to get with Rust out of the box.</p>",
        "id": 210666789,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600607790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"344273\">SeÃ¡n Kelleher</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210666579\">said</a>:</p>\n<blockquote>\n<p>I'm not fully sure how this could be addressed without having each function return <code>Error</code>. For example, I would expect that the idea of specifying subsets of <code>Error</code> for specific functions runs into the same issues with semver.</p>\n</blockquote>\n<p>The general problem is that a public enum has public variants with public fields. That means that removing variants or fields is a semver break. If you haven't used <code>#[nonexhaustive]</code>, then adding variants or fields is likewise a semver break. I'd expect any equivalent \"anonymous enum\" idea would have the same problem.</p>\n<p>This ultimately means that things that should be innocuous refactorings because semver breaks. For example, if I had code like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">Error</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">NotFound</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"nc\">regex</span>::<span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>but then realized I could replace the regex with a <code>str::starts_with</code>, I can't remove the error without a semver break. If that was my only usage of the regex crate, I can't even remove the (theoretically internal) dependency for the same reason.</p>",
        "id": 210670252,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600613674
    },
    {
        "content": "<p>In SNAFU, I encourage people to have two layers â€” public opaque error types and internal fully-detailed error types.</p>",
        "id": 210670265,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600613718
    },
    {
        "content": "<p>That way a crate exposes just <code>mycrate::Error</code> (or a small number of similar) that the author has to very carefully decide what to make public API.</p>",
        "id": 210670319,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600613766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"344273\">SeÃ¡n Kelleher</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210666789\">said</a>:</p>\n<blockquote>\n<p>Thankfully, the different options I've seen so far seem fairly orthogonal...</p>\n</blockquote>\n<p>Meaning different as a positive? Or meant to imply parallels to your proposal?</p>",
        "id": 210671959,
        "sender_full_name": "oliver",
        "timestamp": 1600616467
    },
    {
        "content": "<p>Which parts specifically?</p>",
        "id": 210672034,
        "sender_full_name": "oliver",
        "timestamp": 1600616603
    },
    {
        "content": "<p>Is the parts about nesting enums not viable?</p>",
        "id": 210672123,
        "sender_full_name": "oliver",
        "timestamp": 1600616717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210665395\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"344273\">SeÃ¡n Kelleher</span> another point is that you can define Error and Display for your error types but still match on them to do whatever you want, like display them differently</p>\n</blockquote>\n<p>That's the thing, and one of the very nice nice aspects of Rust, is that these are all orthogonal concerns, and Rust seems to handle them all very nicely. I suppose my main objective here is to present my own thoughts and approach, and how I would see errors being treated in an ideal world.</p>",
        "id": 210673777,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600619214
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210670252\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"344273\">SeÃ¡n Kelleher</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210666579\">said</a>:</p>\n<blockquote>\n<p>I'm not fully sure how this could be addressed without having each function return <code>Error</code>. For example, I would expect that the idea of specifying subsets of <code>Error</code> for specific functions runs into the same issues with semver.</p>\n</blockquote>\n<p>The general problem is that a public enum has public variants with public fields. That means that removing variants or fields is a semver break. If you haven't used <code>#[nonexhaustive]</code>, then adding variants or fields is likewise a semver break. I'd expect any equivalent \"anonymous enum\" idea would have the same problem.</p>\n<p>This ultimately means that things that should be innocuous refactorings because semver breaks. For example, if I had code like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">enum</span> <span class=\"nc\">Error</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">NotFound</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">source</span>: <span class=\"nc\">regex</span>::<span class=\"n\">Error</span><span class=\"w\"> </span><span class=\"p\">},</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>but then realized I could replace the regex with a <code>str::starts_with</code>, I can't remove the error without a semver break. If that was my only usage of the regex crate, I can't even remove the (theoretically internal) dependency for the same reason.</p>\n</blockquote>\n<p>Definitely, it's absolutely a tradeoff. Moreover, where semver usually allows, say, adding new enum values in the same major version, because of the Rust's exhaustive matching, this will also cause a break. I suppose it all boils down to compromise, either of theoretical ideals, or of practicality. For example, with the <code>Error::NotFound</code> example, you could still keep the enum value, even if it's not being used anymore, if you decide that it's more important to you not to do a version bump.</p>\n<p>Note that I think the same issue exists with a \"global-union\"-type <code>Error</code>; if you do a refactoring where the <code>Error::NotFound</code> value just isn't returned anymore, you'll similarly be faced with the choice of a semver bump or unused value. The difference is in how often these issues are likely to occur (more often with function-specific errors, and less often with <code>Error</code>, probably).</p>",
        "id": 210674238,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600619946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"344273\">SeÃ¡n Kelleher</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210673777\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210665395\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"344273\">SeÃ¡n Kelleher</span> another point is that you can define Error and Display for your error types but still match on them to do whatever you want, like display them differently</p>\n</blockquote>\n<p>That's the thing, and one of the very nice nice aspects of Rust, is that these are all orthogonal concerns, and Rust seems to handle them all very nicely. I suppose my main objective here is to present my own thoughts and approach, and how I would see errors being treated in an ideal world.</p>\n</blockquote>\n<p>I think I lost the thread of the discussion somewhere. You contributed some very<br>\ninteresting options and it was pointed out that <code>SNAFU</code> is similar in some of<br>\nits designs. Is most everything related to <code>SNAFU</code> and your designs now to be<br>\nconsidered untenable to the project goals? My tl;dr here of that is simply that<br>\nit's generally too difficult to trace error logic manually with a sufficient<br>\nlevel of specificity such that the concept of nested errors is out of scope.</p>",
        "id": 210674301,
        "sender_full_name": "oliver",
        "timestamp": 1600620043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210670319\">said</a>:</p>\n<blockquote>\n<p>That way a crate exposes just <code>mycrate::Error</code> (or a small number of similar) that the author has to very carefully decide what to make public API.</p>\n</blockquote>\n<p>That's a very interesting approach; I'm not sure that I'd completely agree with it right now but it's definitely something I'm going to keep in mind as a possibility.</p>",
        "id": 210674302,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600620056
    },
    {
        "content": "<p>Sorry <span class=\"user-mention\" data-user-id=\"281739\">@oliver</span> , I've been jumping around a bit throughout the day while I tried to answer on mobile, I'll try and address your comments now.</p>",
        "id": 210674373,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600620183
    },
    {
        "content": "<blockquote>\n<p>Note that I think the same issue exists with a \"global-union\"-type Error; if you do a refactoring where the Error::NotFound value just isn't returned anymore,</p>\n</blockquote>\n<p>Likewise, it's a semver-incompatible change to go from returning an error to not and vice-versa. At least going away from an error has an easy enough hack where you say <code>enum Error {}</code> and it becomes zero-sized.</p>",
        "id": 210674761,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600620815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281739\">oliver</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210674301\">said</a>:</p>\n<blockquote>\n<p>I think I lost the thread of the discussion somewhere. You contributed some very<br>\ninteresting options and it was pointed out that <code>SNAFU</code> is similar in some of<br>\nits designs. Is most everything related to <code>SNAFU</code> and your designs now to be<br>\nconsidered untenable to the project goals? My tl;dr here of that is simply that<br>\nit's generally too difficult to trace error logic manually with a sufficient<br>\nlevel of specificity such that the concept of nested errors is out of scope.</p>\n</blockquote>\n<p>From my understanding so far, it looks like most of what I want to be able to achieve with my own peculiar approach to error handling seems possible with <code>SNAFU</code>, even if I don't take some of the recommended approaches. The two main approaches that I don't see myself taking are to use <code>Error</code> types (I will endeavour to use function-level errors until I feel its infeasible), and to define rendering rules for error values on the error values themselves. However, due to the flexibility of Rust and <code>SNAFU</code>, it looks like I'm free to make those choices, with essentially no consequences. For example, I'm free to use nested errors in my projects as much as I want, and even if a crate exports errors with rendering rules specified on the error values, I believe it's feasible to ignore them and to specify a manual print function, if I so wish. This second point is greatly contrasted with the Go way of doing things, where you often depend on the error string returned from the lower level (unless the package authors are interested in exposing error values that can be handled properly).</p>\n<p>On your TL;DR, this might be the case, but I suppose I'm just not yet convinced that it is too difficult. Of course, I'm not going to be pushing my approach on anyone, precisely because I don't have enough evidence to back it up.</p>",
        "id": 210674838,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600620949
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116155\">Jake Goulding</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210674761\">said</a>:</p>\n<blockquote>\n<p>Likewise, it's a semver-incompatible change to go from returning an error to not and vice-versa. At least going away from an error has an easy enough hack where you say <code>enum Error {}</code> and it becomes zero-sized.</p>\n</blockquote>\n<p>That's very cool. As for <code>Error</code> vs function-errors in practical terms, for semver it probably boils down to the fact that you're likely going to encounter the same issues with both at some point, but the <code>Error</code> approach is likely to defer those issues for a lot longer. What do you think?</p>",
        "id": 210674995,
        "sender_full_name": "SeÃ¡n Kelleher",
        "timestamp": 1600621192
    },
    {
        "content": "<p>Improving enums for multiple failure cases is specifically in-scope for the<br>\nproject. I'm not clear on exactly how simple that can or should be. What's<br>\nexciting is the potential for something that really pushes the limits of some<br>\nfundamental trade offs.</p>\n<p>In terms of semvar, is it to mean that the change requires an edition update<br>\n(i.e. it's a major breaking change)? Or is one just saying that packages<br>\nadopting the (non-Rust-breaking) feature will then choose to break their own<br>\nreverse dependencies?</p>",
        "id": 210675382,
        "sender_full_name": "oliver",
        "timestamp": 1600621701
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281739\">oliver</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/Better.20enums/near/210675382\">said</a>:</p>\n<blockquote>\n<p>Improving enums for multiple failure cases is specifically in-scope for the project.</p>\n</blockquote>\n<p>I suppose it depends on exactly what that means. I don't know for sure, but I didn't expect there to be any language-level changes from the group. At best it might identify some patterns or desires and then request / propose them to the lang team.</p>\n<blockquote>\n<p>What's exciting is the potential for something that really pushes the limits of some fundamental trade offs.</p>\n</blockquote>\n<p>One of the best parts of Rust, IMO.</p>\n<blockquote>\n<p>the change requires an edition update</p>\n</blockquote>\n<p>So long as you mean the generally-accepted \"edition\" (e.g. the 2015 and 2018 editions), then what I have described is not that. </p>\n<blockquote>\n<p>packages adopting the (non-Rust-breaking) feature will then choose to break their own reverse dependencies?</p>\n</blockquote>\n<p>The public API of a crate is subject to semver concerns. That a function returns a <code>Result</code> or not is part of the public API. The specific error type in a <code>Result</code> is part of the public API. Public fields of an error type are part of the public API. Enum variants and fields are part of the public API. Changing any of those (without very specific conditions) constitutes a semver-incompatible change to the crate and thus a new release with a semver-distinct version.</p>",
        "id": 210675909,
        "sender_full_name": "Jake Goulding",
        "timestamp": 1600622522
    }
]