[
    {
        "content": "<p>I've been trying to get a handle on the work to move <code>Error</code> and <code>Backtrace</code> from std to core. I have many questions! But before I ask them, I thought it would be useful to write down my understanding as somebody new to the work and leave the links that I think are important, hopefully this will make it easier for others to get involved.</p>",
        "id": 246184217,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626410670
    },
    {
        "content": "<p>Big picture, we want to move the <code>Error</code> trait (<a href=\"https://doc.rust-lang.org/nightly/std/error/trait.Error.html\">https://doc.rust-lang.org/nightly/std/error/trait.Error.html</a>) into core. The motivation is to allow integrating <code>Error</code> with the panic infrastructure, make error handling more uniform (e.g., for no-std crates), and facilitate moving other traits to core (I can't find the reference again, but iirc some io traits like Read or Write). This is blocked on two things: the use of <code>Box</code> in <code>downcast()</code> and the use of <code>Backtrace</code> in <code>backtrace()</code>. The former can be solved by moving <code>downcast</code> to an impl on <code>Box&lt;Error&gt;</code> in alloc or std, rather than being an inherent method (see <a href=\"https://github.com/rust-lang/rust/pull/72981#issuecomment-662143462\">https://github.com/rust-lang/rust/pull/72981#issuecomment-662143462</a>). The latter is solved by moving <code>Backtrace</code> to core too. Moving <code>Bactrace</code> to core is blocking its stabilisation (<a href=\"https://github.com/rust-lang/rust/pull/72981\">https://github.com/rust-lang/rust/pull/72981</a>).</p>\n<p>Question: is moving <code>Backtrace</code> to core a desire in its own right? E.g., do no-std crates want to use <code>Backtrace</code>?</p>",
        "id": 246184963,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626411656
    },
    {
        "content": "<p>Some links:</p>\n<ul>\n<li>A prototype implementation of <code>Backtrace</code> in core: <a href=\"https://github.com/rust-lang/rust/pull/77384\">https://github.com/rust-lang/rust/pull/77384</a>, work is paused in favour of an RFC</li>\n<li>A WIP RFC for <code>Backtrace</code> in core: <a href=\"https://github.com/JDuchniewicz/rfcs/blob/backtrace-in-core/0000-backtrace-in-core.md\">https://github.com/JDuchniewicz/rfcs/blob/backtrace-in-core/0000-backtrace-in-core.md</a></li>\n<li>RFC 2504 which proposed <code>Backtrace</code>: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md\">https://github.com/rust-lang/rfcs/blob/master/text/2504-fix-error.md</a></li>\n<li>Tracking issue for the above RFC with some discussion of the core issue: <a href=\"https://github.com/rust-lang/rust/issues/53487\">https://github.com/rust-lang/rust/issues/53487</a></li>\n<li>project group issue: <a href=\"https://github.com/rust-lang/project-error-handling/issues/3\">https://github.com/rust-lang/project-error-handling/issues/3</a></li>\n<li><code>Backtrace</code> docs: <a href=\"https://doc.rust-lang.org/nightly/std/backtrace/struct.Backtrace.html\">https://doc.rust-lang.org/nightly/std/backtrace/struct.Backtrace.html</a></li>\n</ul>",
        "id": 246185094,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626411814
    },
    {
        "content": "<p>AIUI, the reason it is non-trivial to move <code>Backtrace</code> into core is that a real, captured  backtrace uses lots of std (or at least alloc) types, so we want the version in core to be somewhat abstract and only provide concrete versions for 'dummy' backtraces, such as those created when capturing a backtrace is disabled. The obvious way to do that is using a trait, but then to pass around a trait object we need to use a pointer type and we can't use <code>Box</code> from core. Furthermore, we want std to extend <code>core::Backtrace</code> with a real backtrace (currently a <code>LazilyResolvedCapture</code>), which means we want <code>Error::backtrace</code> (or some global function which it delegates to) to do something different depending on whether or not std is linked. (Is this correct?)</p>",
        "id": 246185395,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626412215
    },
    {
        "content": "<p>That all seems quite accurate</p>",
        "id": 246185698,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412684
    },
    {
        "content": "<p>The source for the read and write traits wanting an error trait in core is another thread I believe in t-libs suggesting having a core::io::Write trait and an associated internals thread by the same author</p>",
        "id": 246185711,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412734
    },
    {
        "content": "<p>That's not a strong motivator at the moment though, since that work is fairly early in the process and we're not sure we can or should do that yet</p>",
        "id": 246185731,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412763
    },
    {
        "content": "<p>As for motivations for a backtrace in core, I don't have concrete examples of people wanting it</p>",
        "id": 246185739,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412790
    },
    {
        "content": "<p>But I know <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> and some others have talked about wanting to customize backtrace functionality</p>",
        "id": 246185786,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412813
    },
    {
        "content": "<p>Or it being potentially useful</p>",
        "id": 246185789,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412822
    },
    {
        "content": "<p>So I suspect that there would be value to backtrace in core but I'm not positive it will be useful in its own right</p>",
        "id": 246185802,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412854
    },
    {
        "content": "<p>Also I'd point out that there at least one more alternative to the backtrace dependency blocking Error in core, namely removing the backtrace accessor method on the error trait in favor of the generic member access RFC</p>",
        "id": 246185871,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626412945
    },
    {
        "content": "<p>I'm least clear on the possible solutions (there is lots of discussion in lots of places, but I can't figure out what is current and what is obsolete). The RFC doesn't yet specify the solution. The PoC implementation uses a trait for the kind of backtrace, using a raw pointer trait object in <code>Backtrace</code>. There are 'dummy' concrete backtrace types in core, and <code>StdBacktrace</code> in std which has can contain a real backtrace. There are functions for checking if backtraces are enabled and creating one, and these are lang items defined in both core and std. I'm not sure how the compiler knows which one to call, perhaps this is the open question about linking discussed in the comments? std uses a Box to back the raw pointer trait object. There is a fair amount of unsafe code around to facilitate this and some <code>todo!</code>s, I didn't delve into it so I'm not sure if this just requires filling in the gaps or if there are open questions around safety.</p>\n<p>I'm not clear if the PoC as implemented is what will be described in the RFC or whether there have been improvements discussed.</p>",
        "id": 246185943,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626413053
    },
    {
        "content": "<p>There could very well be safety issues</p>",
        "id": 246185970,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626413123
    },
    {
        "content": "<blockquote>\n<p>in favor of the generic member access RFC</p>\n</blockquote>\n<p>For completeness, this is <a href=\"https://github.com/rust-lang/rfcs/pull/2895\">https://github.com/rust-lang/rfcs/pull/2895</a>. AIUI, that is blocked on pulling out some of the more generic mechanisms into a new RFC?</p>",
        "id": 246186024,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626413179
    },
    {
        "content": "<p>The PoC is going to be the basis of the RFC, which will then possibly lead to a cleaned up version assuming the lang item route seems best</p>",
        "id": 246186031,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626413185
    },
    {
        "content": "<p>Correct</p>",
        "id": 246186037,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626413198
    },
    {
        "content": "<p>I need to follow up with <span class=\"user-mention\" data-user-id=\"263805\">@Plecra</span> to see if they're still planning on working on that</p>",
        "id": 246186043,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626413214
    },
    {
        "content": "<p>I should probably read the rfc again, but isn’t the backtrace case different to the generic context case because we want to implement backtrace() once for all errors, not implement it each time for individual error types?</p>",
        "id": 246204958,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626429839
    },
    {
        "content": "<p>Spitballing an idea, could we have an extension trait ErrorWithBacktrace with the backtrace method on it in std and a blanket impl for all implementers of Error? You’d have to import the trait to get a backtrace so marginally less ergonomic, but it would statically prevent you trying to get a backtrace if you didn’t use std</p>",
        "id": 246205235,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626430028
    },
    {
        "content": "<p>(I’m sure there must be a problem with that)</p>",
        "id": 246205264,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626430053
    },
    {
        "content": "<p>To answer one question you had Nick: Having the ability to walk a backtrace with an iterator and immediately print it out to whatever sink in a <code>no_std</code> situation without actually allocating would be good to have.</p>",
        "id": 246226537,
        "sender_full_name": "Lokathor",
        "timestamp": 1626444099
    },
    {
        "content": "<p>I'm not sure I understand what you mean <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span>. As I understand it you can't have a default impl for fn backtrace, you have to manually specify which member you're using as the source of the Backtrace and implement the method per Error type.</p>",
        "id": 246227281,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626444385
    },
    {
        "content": "<p>Sorry, I think I was confusing the backtrace method on Error with the methods on Backtrace</p>",
        "id": 246259596,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626459162
    },
    {
        "content": "<p>So, is there a reason that backtrace are more privileged than other context info? Ie why do they have their own method rather than being accessed via the context mechanism?</p>",
        "id": 246259782,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626459269
    },
    {
        "content": "<p>the argument that was made way back before I started the error handling project group was that <code>Backtrace</code> is the context most people will want to use</p>",
        "id": 246259843,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626459303
    },
    {
        "content": "<p>Hmmm</p>",
        "id": 246259986,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626459374
    },
    {
        "content": "<p>What about having an ErrorWithBacktrace trait in std which extends the core::Error trait with the backtrace method?</p>",
        "id": 246260094,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626459437
    },
    {
        "content": "<p>I'd be worried about people wanting to use that instead of the <code>Error</code> trait and ending up in a similar situation with the <code>Fail</code> trait</p>",
        "id": 246260164,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626459479
    },
    {
        "content": "<p>where you have lots of incompatibilities because you need to compose errors one way but they're implemented the other way</p>",
        "id": 246260239,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626459502
    },
    {
        "content": "<p>It wouldn’t be quite that bad because you could always upcast to Error</p>",
        "id": 246260281,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626459527
    },
    {
        "content": "<p>Another idea which you’ve probably already thought about, the backtrace returns a reference to a Backtrace, so either Backtrace could be a trait, rather than a struct wrapping a trait, or the Backtrace struct could be unsized, either way it means you can’t pass a Backtrace by value, but you don’t need the raw pointer and explicit destructor</p>",
        "id": 246260943,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626459879
    },
    {
        "content": "<p>so <code>std</code>'s public API would just be <code>Box&lt;dyn Backtrace&gt;</code> or something?</p>",
        "id": 246261362,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626460124
    },
    {
        "content": "<p>So for what?</p>",
        "id": 246261415,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460168
    },
    {
        "content": "<p>sounds much better to me!</p>",
        "id": 246261428,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626460177
    },
    {
        "content": "<p>Sorry, api for what?</p>",
        "id": 246261433,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460180
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/246260281\">said</a>:</p>\n<blockquote>\n<p>It wouldn’t be quite that bad because you could always upcast to Error</p>\n</blockquote>\n<p>I think it might still fall over when you want to have the <code>ErrorWithBacktrace</code> type be a source error, rather than the outermost error. Now you need to downcast from a <code>dyn Error</code> to a <code>dyn ErrorWithBacktrace</code> or have an alternate <code>source</code> method on <code>ErrorWithBacktrace</code> that returns it as a <code>dyn ErrorWithBacktrace</code>, then you need to check both source methods at each step to iterate fully through a chain of errors</p>",
        "id": 246261459,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460194
    },
    {
        "content": "<p>it might be possible but from experience we know this direction is fraught</p>",
        "id": 246261570,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460253
    },
    {
        "content": "<p>if we had generic member access we could have an extension trait implemented for all <code>E: Error</code> types that just wraps a call to <code>self.context::&lt;Backtrace&gt;()</code> and re-exports that as an <code>fn backtrace()</code></p>",
        "id": 246261647,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460321
    },
    {
        "content": "<p>And another question: why have the methods for capturing a backtrace in core? Could we not have the Backtrace type in core just as an abstraction with no way to capture one, then the capturing functions in a module in std?</p>",
        "id": 246261702,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460335
    },
    {
        "content": "<p>though you'd still have to expose that backtrace internally in the provide method from generic member access</p>",
        "id": 246261703,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460336
    },
    {
        "content": "<p>so <code>fn std::backtrace::capture() -&gt; Box&lt;dyn core::backtrace::Backtrace&gt;</code> (excuse my syntax)</p>",
        "id": 246261718,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626460348
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/246261702\">said</a>:</p>\n<blockquote>\n<p>And another question: why have the methods for capturing a backtrace in core? Could we not have the Backtrace type in core just as an abstraction with no way to capture one, then the capturing functions in a module in std?</p>\n</blockquote>\n<p>I kinda came at it trying to emulate the way we handle panics</p>",
        "id": 246261803,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460402
    },
    {
        "content": "<p>so I figured if someone writes some <code>no_std</code> code that calls <code>Backtrace::capture</code> but std is actually linked in they'd want to get a full backtrace</p>",
        "id": 246261826,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460423
    },
    {
        "content": "<p>kinda like how you can core panic and have it hit the std panic handler</p>",
        "id": 246261839,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460429
    },
    {
        "content": "<p>Ah, I see, thanks</p>",
        "id": 246261856,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460440
    },
    {
        "content": "<p>but I'm not sure we _need_ it to have a capture interface in core</p>",
        "id": 246261861,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460442
    },
    {
        "content": "<p>Could source return Self rather than Error or is it too late to change that?</p>",
        "id": 246261944,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460479
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/246261362\">said</a>:</p>\n<blockquote>\n<p>so <code>std</code>'s public API would just be <code>Box&lt;dyn Backtrace&gt;</code> or something?</p>\n</blockquote>\n<p>one of the proposals was to add a Backtrace trait to core and have the type still live in std</p>",
        "id": 246261955,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460491
    },
    {
        "content": "<p>though back when we first discussed that the option of using hooks was preferred</p>",
        "id": 246261979,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460507
    },
    {
        "content": "<p>i think because of the larger repr of a trait object</p>",
        "id": 246261994,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460518
    },
    {
        "content": "<p>and because it would require changing the backtrace fn's interface</p>",
        "id": 246262015,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460529
    },
    {
        "content": "<p>we could always add the <code>fn capture()</code> to <code>alloc</code> later, that way it won't block moving <code>Error</code> to <code>core</code></p>",
        "id": 246262020,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1626460536
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/246261944\">said</a>:</p>\n<blockquote>\n<p>Could source return Self rather than Error or is it too late to change that?</p>\n</blockquote>\n<p>Self as in the concrete type of the error? wouldnt that break object safety or am I misunderstanding?</p>",
        "id": 246262056,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460561
    },
    {
        "content": "<p>Don’t we already pay the larger repr of the trait object because wit is embedded in the Backtrace struct?</p>",
        "id": 246262139,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460594
    },
    {
        "content": "<p>Oh yeah, pesky object safety <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 246262182,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460616
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/246262139\">said</a>:</p>\n<blockquote>\n<p>Don’t we already pay the larger repr of the trait object because wit is embedded in the Backtrace struct?</p>\n</blockquote>\n<p>In the PoC impl? uuuh, yea I think you're right <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 246262258,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460666
    },
    {
        "content": "<p>that might be a fucky wucky on my part</p>",
        "id": 246262310,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1626460683
    },
    {
        "content": "<p>Given that there doesn’t seem much motivation to have Backtrace in core other than to support Error, I’d be keen to consider keeping capturing in std if it spares us a lot of complications</p>",
        "id": 246262426,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626460746
    },
    {
        "content": "<blockquote>\n<p>To answer one question you had Nick: Having the ability to walk a backtrace with an iterator and immediately print it out to whatever sink in a no_std situation without actually allocating would be good to have.</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> aiui, it will not be possible to collect a backtrace in a no-std crate, so the only way this could happen is if a no-std crate is used by another crate which does use std, and that crate passes an error with a backtrace to the no-std crate, which seems like something which won't happen too often. Did you have another scenario in mind?</p>",
        "id": 246535904,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626745194
    },
    {
        "content": "<p>i don't want to collect it to a vec or anything, i want to print it directly right there</p>",
        "id": 246536009,
        "sender_full_name": "Lokathor",
        "timestamp": 1626745302
    },
    {
        "content": "<p>In that case, it seems like you would have to collect the backtrace yourself (since core doesn't give you the OS stuff required to collect the backtrace), so is there any advantage to using a standardised Backtrace type rather than it being a completely custom type?</p>",
        "id": 246536181,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626745455
    },
    {
        "content": "<p>(If it even makes sense for there to be a type at all if the data is not being stored)</p>",
        "id": 246536192,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626745479
    },
    {
        "content": "<p>In truth I have not been following the full discussion, but I was at one point lead to believe that it would be possible to get an iterator over the backtrace frames, even from within <code>core</code> code. I would want to have a panic handler that could do something like <code>for frame in get_core_backtrace_iterator() { my_embedded_print_fn(frame) }</code></p>",
        "id": 246536300,
        "sender_full_name": "Lokathor",
        "timestamp": 1626745616
    },
    {
        "content": "<p>but if that is not possible, then nevermind</p>",
        "id": 246536319,
        "sender_full_name": "Lokathor",
        "timestamp": 1626745644
    },
    {
        "content": "<p>Heh, I'm new to this, so I may be completely wrong :-) My impression is that that would not be possible, but I'm probably wrong</p>",
        "id": 246536380,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626745689
    },
    {
        "content": "<p>is there anything you can do with backtrace frames other than print them? The API seems a little thin</p>",
        "id": 246536723,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626746093
    },
    {
        "content": "<p>I think \"print them\" is non-trivial in this case, you might want to process them to be user friendly or in a specific log format or something. I can imagine some programs might want to make statistical info from them (90% of errors originated from X module or something) or maybe influence recovery (Y was in the backtrace, so there is no point in trying recovery mechanism Z). I'm just guessing what people might do, I have no data</p>",
        "id": 246536963,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626746348
    },
    {
        "content": "<p>What do you mean by \"pretty thin\"? Do you think it should be bigger? Or that it is not worth having at all? Or...?</p>",
        "id": 246536986,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626746394
    },
    {
        "content": "<p>If we were to leave the backtrace collection functions in std, could we move them to core later? Since it seems that the std ones would 'override' the core ones anyway?</p>",
        "id": 246540252,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626750317
    },
    {
        "content": "<p>So, at a high level the solution space to the Backtrace in std problem seems to be either a) move Backtrace to core, or b) use generic access to get the backtrace from an Error type. In (a), Backtrace would become a trait rather than an enum, and either backtrace returns a trait object, or there is a wrapper type around the trait (as in the current PoC impl). In case (b), we could make things more ergonomic by having an extension trait of Error in std to provide a backtrace method which delegates to the generic access. Obviously, approach (b) is blocked on the generic access work itself.</p>",
        "id": 246540714,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626750960
    },
    {
        "content": "<p>In case (a) we could consider the backtrace collection functions too (in case b, I think they just stay in std). We could either leave them in std only, move them to core (as in the current PoC) or leave them in std for now with the option of moving to core/using hooks later.</p>",
        "id": 246540785,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626751045
    },
    {
        "content": "<p>Have I missed any alternatives?</p>",
        "id": 246540790,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626751051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/246536986\">said</a>:</p>\n<blockquote>\n<p>What do you mean by \"pretty thin\"? Do you think it should be bigger? Or that it is not worth having at all? Or...?</p>\n</blockquote>\n<p>I think you should be able to programmatically query information about the backtrace: what function it was, what module it was in, maybe the actual code address - any information that can be provided on most platforms. If the only public method is to print it then that means I have to parse the output of the formatter to figure out what's going on, which is exactly the kind of stringly typed API we want to avoid</p>",
        "id": 246540874,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626751171
    },
    {
        "content": "<p>From the above solutions, I prefer case (a) since it is not blocked by the generic access work, though if we think the generic access work and moving Error to core are on similar timelines, then (b) is more attractive. If we go with (a), my preference would be to have a Backtrace trait without wrapping it in a concrete type, and to leave the collection functions in std with an open question for moving to core later (if we think that is possible).</p>",
        "id": 246540875,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626751172
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> agree! My understanding (possibly incorrect, since I am just getting the feel of things) is that Backtrace and BacktraceFrame will have methods added over the long run to support this kind of thing, and that the 'print only' API is just a minimal starting place.</p>",
        "id": 246540958,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626751265
    },
    {
        "content": "<p>By \"print\" we all mean <code>Display::fmt</code> right?</p>",
        "id": 246540972,
        "sender_full_name": "Lokathor",
        "timestamp": 1626751300
    },
    {
        "content": "<p>yes</p>",
        "id": 246540974,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626751304
    },
    {
        "content": "<p>I think it has a debug formatter too</p>",
        "id": 246540980,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1626751318
    },
    {
        "content": "<p>Very stimulating discussion going on here. I will update the RFC with different approaches we can take. As I understood it, we <em>need</em> to move <code>Error</code> to <code>core</code> or at least <code>alloc</code>?</p>",
        "id": 246558246,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1626770014
    },
    {
        "content": "<p>Also, since <code>no_std</code> users might want the <code>Backtrace</code> to be available, the idea a) as <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span>  stated, will allow them to write their own impls as they have to write <code>panic</code> fn's themselves</p>",
        "id": 246558463,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1626770153
    },
    {
        "content": "<p>Not sure about the allocating part of the <code>Backtrace</code> when it is in <code>core</code>. It may be possible to have some preallocated (static) memory we will be filling with out backtrace log and do whatever we need with it. Probably this could be a part of <code>Backtrace</code> API.</p>",
        "id": 246558763,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1626770315
    },
    {
        "content": "<p>What other methods would you envision in the API? In my opinion simply returning the frames to the user is enough, as people can do whatever they require afterwards.</p>",
        "id": 246559142,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1626770592
    },
    {
        "content": "<blockquote>\n<p>we need to move Error to core</p>\n</blockquote>\n<p>That is my understanding too</p>",
        "id": 246562130,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626772944
    },
    {
        "content": "<blockquote>\n<p>Not sure about the allocating part of the Backtrace when it is in core. It may be possible to have some preallocated (static) memory we will be filling with out backtrace log and do whatever we need with it. Probably this could be a part of Backtrace API.</p>\n</blockquote>\n<p>I guess if we let people implement their own Backtrace types (implementing a Backtrace trait) then they would be free to do this and it shouldn't affect the API too much? As long as we e.g., return references to frames rather than Box or whatever</p>",
        "id": 246562287,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626773048
    },
    {
        "content": "<blockquote>\n<p>What other methods would you envision in the API? In my opinion simply returning the frames to the user is enough, as people can do whatever they require afterwards.</p>\n</blockquote>\n<p>I think we can leave this for later? AIUI, we aim to stabilise a minimal Backtrace API for now (just a Display impl, etc) and we can add API for iterating frames later. Having said that, my assumption was that the interesting question is what a Frame object looks like and the Backtrace API would be quite simple, just providing a FrameIterator or something similar</p>",
        "id": 246562482,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626773179
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"344196\">@Jakub Duchniewicz</span> did you get a chance to update the RFC? Is there anything I can help with?</p>",
        "id": 246907727,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1626988885
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> will be doing it today and during the weekend, I will ask here for clarifications and update my progress</p>",
        "id": 246959623,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627034477
    },
    {
        "content": "<p>Sorry got bogged down with other work during the weekend. Got to it finally today <span aria-label=\"east\" class=\"emoji emoji-27a1\" role=\"img\" title=\"east\">:east:</span>  (<em>summer is hard to push things through :)</em>)</p>",
        "id": 247186115,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627295911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"344196\">@Jakub Duchniewicz</span> how did the RFC work go? Did you have any questions or do you want a round of feedback?</p>",
        "id": 247405954,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627428328
    },
    {
        "content": "<p>Hi <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> I filled out the <a href=\"https://github.com/JDuchniewicz/rfcs/blob/backtrace-in-core/0000-backtrace-in-core.md\">RFC</a> slightly, I would love to get some comments to get me going</p>",
        "id": 247481965,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627489716
    },
    {
        "content": "<p>summer time is not the easiest time to work on such things for me (a lot of moving around and other commitments :))</p>",
        "id": 247482034,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627489757
    },
    {
        "content": "<p>hence it does not go as rapidly as I would like it to go</p>",
        "id": 247482073,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627489777
    },
    {
        "content": "<p>I am not sure how long the RFC should be, as some of them are very lenghty and some are brief</p>",
        "id": 247482154,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627489805
    },
    {
        "content": "<p>it seems like this is somewhere in between</p>",
        "id": 247482174,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627489814
    },
    {
        "content": "<p>and I need to include a reference-level explanation in which I will explain how a user might make use of this after its implementation (provide their custom backtrace hooks etc)</p>",
        "id": 247482247,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627489852
    },
    {
        "content": "<p>not sure what to include in prior art as I think that no-one moved traits in such a way before</p>",
        "id": 247482312,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627489884
    },
    {
        "content": "<p>Also <span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby</span> you could take a look and tell me if I am going in the good direction</p>",
        "id": 247483744,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627490461
    },
    {
        "content": "<p>it is my first RFC so it will for sure require many iterations to get it right <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 247483814,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627490506
    },
    {
        "content": "<p>hopefully I included all points of view from this discussion along with some of my own</p>",
        "id": 247483901,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627490529
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"344196\">Jakub Duchniewicz</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/247483744\">said</a>:</p>\n<blockquote>\n<p>Also <span class=\"user-mention silent\" data-user-id=\"220273\">Jane Lusby</span> you could take a look and tell me if I am going in the good direction</p>\n</blockquote>\n<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 247493097,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627494771
    },
    {
        "content": "<p>ill take a look right after the libs meetings</p>",
        "id": 247493121,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627494780
    },
    {
        "content": "<p>I probably missed the discussion: why can't core's Backtrace implement Display and Debug, which are also in core?</p>",
        "id": 247498451,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627497122
    },
    {
        "content": "<p>Jakub is there an associated PR for your RFC?</p>",
        "id": 247520708,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627508273
    },
    {
        "content": "<p>I need somewhere to leave comments</p>",
        "id": 247520718,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627508280
    },
    {
        "content": "<p>I will open a PR right now</p>",
        "id": 247549509,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627540994
    },
    {
        "content": "<p>did not want to jump the gun with the WiP state of the RFC</p>",
        "id": 247549523,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627541016
    },
    {
        "content": "<p>here is the <a href=\"https://github.com/rust-lang/rfcs/pull/3156\">PR</a></p>",
        "id": 247549852,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627541403
    },
    {
        "content": "<p>a good question <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span> , maybe Jane has a reason in her implementation. I will poke around it to see if it is justified or just a decision</p>",
        "id": 247552366,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627543874
    },
    {
        "content": "<p>I don't recall not having a display and debug impl</p>",
        "id": 247553457,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627544795
    },
    {
        "content": "<p>I think I remember <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span> suggesting not including a capturing API in core to keep the implementation simpler, but also I gave reasoning based on panic for why I implemented it the way it is currently and so I wouldn't be surprised if we want pretty much feature parity with the current API</p>",
        "id": 247553563,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627544890
    },
    {
        "content": "<p>yes, my bad. Just a quick glance at the code and there they are :)</p>",
        "id": 247589962,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627568637
    },
    {
        "content": "<p>what could we do with the backtrace frame if we did not capture it?</p>",
        "id": 247590101,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1627568678
    },
    {
        "content": "<p>presumably we could still print it if it was passed in from some code that has access to <code>std</code></p>",
        "id": 247607742,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627576434
    },
    {
        "content": "<p>so we could have a no_std library that has a fn like <code>fn print_backtrace(backtrace: &amp;core::backtrace::Backtrace)</code>  and then have another crate that depends on this and has access to <code>std</code> which then captures a backtrace and calls our fn</p>",
        "id": 247607876,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627576486
    },
    {
        "content": "<p>\"core only\" code might also have \"printing\" systems even without <code>std</code>, including something as basic as writing the panic message to a known static buffer before the device locks up, and the person debugging can go check the buffer</p>",
        "id": 247614628,
        "sender_full_name": "Lokathor",
        "timestamp": 1627579581
    },
    {
        "content": "<p>that's assuming we also include the capture API in core right? otherwise there would be nothing to print backtrace wise</p>",
        "id": 247616731,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627580455
    },
    {
        "content": "<p>yes, you do need to be able to iterate/inspect/whatever the stack frames in core to be able to do that.</p>",
        "id": 247619665,
        "sender_full_name": "Lokathor",
        "timestamp": 1627581763
    },
    {
        "content": "<p>For example, with the <code>gba</code> crate we provide core::fmt::Write impls for the debug output streams in the two most commonly used emulators. and then the panic handler can spit the error message out there</p>",
        "id": 247622110,
        "sender_full_name": "Lokathor",
        "timestamp": 1627583032
    },
    {
        "content": "<p>displaying a backtrace seems essentially the same, assuming it's available</p>",
        "id": 247622179,
        "sender_full_name": "Lokathor",
        "timestamp": 1627583050
    },
    {
        "content": "<p>For sure</p>",
        "id": 247625969,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627584995
    },
    {
        "content": "<p>Aiui, for at least some use cases, being no std doesn’t mean the program can’t capture or print, etc, but that the program will provide these facilities not std (not entirely sure if there is any point of using the Backtrace trait at all in this case, but interoperability maybe?)</p>",
        "id": 247630138,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627587117
    },
    {
        "content": "<p>The issue is one of knowledge.</p>\n<ul>\n<li>I know how to take a PanicInfo someone hands to me and write it out to an impl of <code>core::fmt::Write</code>. That's easy.</li>\n<li>I wouldn't have the <em>slightest idea</em> of where to begin writing code to somehow examine the callstack and show a backtrace.</li>\n</ul>\n<p>And I think that for most Rust programmers those two facts hold true.</p>",
        "id": 247637749,
        "sender_full_name": "Lokathor",
        "timestamp": 1627590941
    },
    {
        "content": "<p>You wouldn’t necessarily implement it yourself, you might depend on a library to do it, just not std. my assumption is that if you’re doing no std work that’s either because you’re implementing a kernel and you do know how to examine the call stack, you’re on some exotic platform with no std support but there are libraries for it, or you’re doing embedded work and either there’s a library or it’s impractical to get a backtrace at all.</p>",
        "id": 247659837,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627606494
    },
    {
        "content": "<p>Are there no std use cases where it is reasonable to assume we can provide a backtrace some how?</p>",
        "id": 247659921,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627606577
    },
    {
        "content": "<p>Or are you thinking of the case where a no std crate is linked in to a program using std?</p>",
        "id": 247659943,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627606618
    },
    {
        "content": "<p>But Nick, I <em>am</em> the library author.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"256841\">Nick Cameron</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/247659921\">said</a>:</p>\n<blockquote>\n<p>Are there no std use cases where it is reasonable to assume we can provide a backtrace some how?</p>\n</blockquote>\n<p>I don't know enough about backtraces to even say Yes or No to this question.</p>\n<p>I <em>can</em> say that the GBA is an ARMv4T arch CPU that LLVM already had a target profile for, basically since forever, the arch was designed in like 1993. The amount of effort to make this \"exotic platform\" work with Rust is essentially none at all, just the basic amount that all embedded devices have (an assembly code startup before you jump to <code>main</code>, and you need a linker script).</p>\n<p>So though I am the maintainer of the GBA library, I have never once been called upon to examine my own stack frames, nor would I have any idea of how to do so.</p>",
        "id": 247662673,
        "sender_full_name": "Lokathor",
        "timestamp": 1627610071
    },
    {
        "content": "<p>Heh, fair enough. Do you know how a backtrace collector in core would work for such a platform? I thought that it was specific to the platform and therefore we couldn’t possibly implement it in core? (My understanding here is not good)</p>",
        "id": 247664592,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627612382
    },
    {
        "content": "<p>I kinda assumed that somehow... debug symbols... something something... magic? I'm so unaware of how making a backtrace works that I don't even know what would be different on an old arch CPU without an OS.</p>",
        "id": 247664826,
        "sender_full_name": "Lokathor",
        "timestamp": 1627612692
    },
    {
        "content": "<p>We can look into this. AFAIK, it depends on the calling convention which is a dependent on the combination of processor, compiler, and OS, which is why we can’t do it in core. But it’s possible there are cross platform standards which would work in at least some cases and which I don’t know about</p>",
        "id": 247665880,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627614069
    },
    {
        "content": "<p>In my experience with embedded platforms (microcontrollers), debug info is generally not available on the target cpu, since it is stripped when flashing the binary. If debug info is needed, backtraces can't be captured, unless you can cheat and ask a host system (semi-hosting) for either the debug info or to get a backtrace for you.</p>",
        "id": 247677417,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1627629657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/247664826\">said</a>:</p>\n<blockquote>\n<p>I kinda assumed that somehow... debug symbols... something something... magic? I'm so unaware of how making a backtrace works that I don't even know what would be different on an old arch CPU without an OS.</p>\n</blockquote>\n<p>i think its fairly os specific but I'm definitely not an expert on backtrace implementations</p>",
        "id": 247723177,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1627658903
    },
    {
        "content": "<p>I left a bunch of comments on the RFC PR: <a href=\"https://github.com/rust-lang/rfcs/pull/3156#pullrequestreview-719704831\">https://github.com/rust-lang/rfcs/pull/3156#pullrequestreview-719704831</a></p>",
        "id": 247882135,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627860162
    },
    {
        "content": "<p>I think we should go for the simplest solution which works and unblocks the Error -&gt; core work, then expand on the alternatives/extensions in the  alternatives section</p>",
        "id": 247882199,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1627860246
    },
    {
        "content": "<p>as for the backtrace on embedded devices, <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span>  has a valid point - debug symbols are usually stripped to conserve memory on the target platform. Why and how one would want a standalone backtrace for examining is unclear to me (probably on a intermediary step in development when the target is running some kind of smoke tests or something similar and is running standalone and can write the backtrace to a buffer)</p>",
        "id": 248240995,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628006200
    },
    {
        "content": "<p>Though I cannot fathom other cases where it would be useful (I might ask on the Embedded Rust matrix channel about this)</p>",
        "id": 248241074,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628006235
    },
    {
        "content": "<p>they would have most experience with these matters</p>",
        "id": 248241106,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628006248
    },
    {
        "content": "<p>I am working through your comments <span class=\"user-mention\" data-user-id=\"256841\">@Nick Cameron</span>, leaving comments where something is unclear</p>",
        "id": 248241165,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628006273
    },
    {
        "content": "<p>I think the simplest solution is <span class=\"user-mention\" data-user-id=\"220273\">@Jane Lusby</span>'s PR which the RFC is based upon mostly</p>",
        "id": 248241264,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628006296
    },
    {
        "content": "<p>with the rest of ideas being extensions and alternatives</p>",
        "id": 248241427,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628006330
    },
    {
        "content": "<p>not sure if it is the simplest(compared to waiting for stabilization of generic member access RFC)</p>",
        "id": 248241488,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628006354
    },
    {
        "content": "<p>i expect just doing generic access would be easiest but I'm not confident the API will pass muster</p>",
        "id": 248241563,
        "sender_full_name": "Jane Lusby",
        "timestamp": 1628006402
    },
    {
        "content": "<p>not sure if I should write <code>core</code> or core or <em>core</em> :)</p>",
        "id": 248245055,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628008050
    },
    {
        "content": "<p>usually it is the middle one</p>",
        "id": 248245069,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628008060
    },
    {
        "content": "<p>however it strikes me as indistinguishable from the rest of the text usually</p>",
        "id": 248245107,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628008082
    },
    {
        "content": "<p>I usually write plain core or use ‘the core library’ and only use backticks if it is actually code, e.g., in core::error::Backtrace</p>",
        "id": 248254129,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1628012531
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 248305304,
        "sender_full_name": "Nick Cameron",
        "timestamp": 1628044860
    },
    {
        "content": "<p>sure, will stick to the regular naming conventions</p>",
        "id": 248316014,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628059781
    },
    {
        "content": "<p>one case where a backtrace on an embedded system would be useful is for automated bug reporting.</p>",
        "id": 248318023,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628061701
    },
    {
        "content": "<p>but here we are talking about bigger embedded platforms which can afford to have networking and debug symbols for these kinds of reporting (probably even a full-blown linux with std support)</p>",
        "id": 248318737,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628062354
    },
    {
        "content": "<p>having networking doesn't mean there's enough space for debug symbols, a good example is Arduino, which has networking with only 2kB of ram: <a href=\"https://www.arduino.cc/en/Reference/Ethernet\">https://www.arduino.cc/en/Reference/Ethernet</a></p>",
        "id": 248322528,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628065379
    },
    {
        "content": "<p>(admittedly you'd probably want more ram to bother with automated bug reporting...maybe 8kB?)</p>",
        "id": 248322662,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1628065480
    },
    {
        "content": "<p>ah yes, just generally speaking that we need a more powerful platform for this</p>",
        "id": 248323970,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628066456
    },
    {
        "content": "<p>asked on the embedded rust matrix chat</p>",
        "id": 248324015,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628066476
    },
    {
        "content": "<p>backtraces can be symbolized after transmission, doesn't necessarily need to happen on device.</p>",
        "id": 248333459,
        "sender_full_name": "nagisa",
        "timestamp": 1628073417
    },
    {
        "content": "<p>debug symbols could also be stored on an external flash chip rather than on the SoC memory.</p>",
        "id": 248333513,
        "sender_full_name": "nagisa",
        "timestamp": 1628073474
    },
    {
        "content": "<p>one thing that gets me thinking is how heavy would be unwinding code</p>",
        "id": 248334082,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628073899
    },
    {
        "content": "<p>not fluent in how they are unwound, so just speculating here</p>",
        "id": 248334213,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628073975
    },
    {
        "content": "<p>With frame pointers enabled (which I believe is typically true on thumb) the unwinding is just chasing a pointer in a linked list. Along with storing the chain somewhere else that'd be a couple hundred bytes if written with care.</p>",
        "id": 248336433,
        "sender_full_name": "nagisa",
        "timestamp": 1628075583
    },
    {
        "content": "<p>great, so it seems to be not that heavy. Curious what embedded folks think about it</p>",
        "id": 248337543,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628076417
    },
    {
        "content": "<p>You don't even need to necessarily store the chain. You can possibly print/transmit one frame at a time as you iterate the call stack.</p>",
        "id": 248429257,
        "sender_full_name": "Lokathor",
        "timestamp": 1628127372
    },
    {
        "content": "<p>not much feedback on embedded matrix, they told me to ask around their next meeting on Tuesday 20:00 CEST</p>",
        "id": 248443824,
        "sender_full_name": "Jakub Duchniewicz",
        "timestamp": 1628146288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/257204-project-error-handling/topic/core.3A.3AError.20and.20core.3A.3ABacktrace/near/248429257\">said</a>:</p>\n<blockquote>\n<p>You don't even need to necessarily store the chain. You can possibly print/transmit one frame at a time as you iterate the call stack.</p>\n</blockquote>\n<p>Yeah, I meant that the code to store the addresses somewhere would be included into the byte estimation ^^</p>",
        "id": 248463597,
        "sender_full_name": "nagisa",
        "timestamp": 1628162146
    }
]