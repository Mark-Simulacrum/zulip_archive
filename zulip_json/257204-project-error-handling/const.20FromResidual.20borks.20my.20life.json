[
    {
        "content": "<p>Howdy y'all. It's the error tracing guy again.</p>\n<p>One of the 1.59 nightlies made <code>impl FromResidual for Result</code> into a <code>const</code> impl, and now that is throwing a wrench into our ability to specialize the <code>FromResidual</code> impl. As a bit of a refresher, we have patched our Rust stdlib to have a specialized implementation of <code>FromResidual for Result</code> that allows for capturing the code location of every <code>?</code> invocation.</p>\n<p>I've filed two issues for this (<a href=\"https://github.com/rust-lang/rust/issues/95186\">#95186</a> and <a href=\"https://github.com/rust-lang/rust/issues/95187\">#95187</a>), but after looking at the min_specialization implementation, it seems very purposeful that const trait impls are disallowed from specialization. I think it makes sense as to why; the const-eval code would need to take the specialization graph into account in order to support specializing const trait impls.</p>\n<p>This is a really big wrench for us. We've very recently finished converting all of our Rust code to using <code>TracedError</code>, and we definitely don't want to give up all that work by undoing the specialization and removing the error tracing functionality entirely. But there also doesn't appear to be any quick fix for us. We can't even do the dirty band-aid fix (un-const the <code>FromResidual</code> impl) because some things in stdlib are now dependent on the constness of <code>?</code>.</p>\n<p>I don't really know what I'm asking of you folks by posting this. I think I mostly want advice. It would be ideal if I could get into a conversation with Niko or any contributor who knows (and cares) enough about specialization so we can talk through what the expected behavior should really be and try to form a plan of attack for fixing the interaction of <code>min_specialization</code> and <code>const_trait_impls</code>. I'm in a position at work where I can dedicate work hours to fixing this issue in rustc, but I don't have the means to make decisions or understand their implications without talking to somebody who knows this better than I do.</p>",
        "id": 276265808,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1647989920
    },
    {
        "content": "<p>can you share your specialized version of FromResidual for Result?</p>",
        "id": 276266426,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647990326
    },
    {
        "content": "<p>Yeah, i think it's buried in an old draft PR of mine</p>",
        "id": 276266456,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1647990347
    },
    {
        "content": "<p>tyty</p>",
        "id": 276266462,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647990352
    },
    {
        "content": "<p><a href=\"https://github.com/BGR360/rust/blob/return-tracing/library/core/src/result.rs#L1914-L1940\">https://github.com/BGR360/rust/blob/return-tracing/library/core/src/result.rs#L1914-L1940</a></p>",
        "id": 276266612,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1647990463
    },
    {
        "content": "<p>yea, the only thing I can think of to do is to use something other than std::result::Result :(</p>",
        "id": 276266829,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647990614
    },
    {
        "content": "<p>at least as a short term fix</p>",
        "id": 276266868,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647990643
    },
    {
        "content": "<p>not sure if viable</p>",
        "id": 276266871,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647990645
    },
    {
        "content": "<p>'tisn't :(</p>",
        "id": 276266882,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1647990655
    },
    {
        "content": "<p>I'm guessing we already talked about that in the past and i don't remember why that wouldn't work for you</p>",
        "id": 276266883,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647990656
    },
    {
        "content": "<p>might be good to copy this discussion over to <a class=\"stream\" data-stream-id=\"146212\" href=\"/#narrow/stream/146212-t-compiler.2Fconst-eval\">#t-compiler/const-eval</a> and/or <a class=\"stream\" data-stream-id=\"144729\" href=\"/#narrow/stream/144729-wg-traits\">#wg-traits</a></p>",
        "id": 276266945,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647990711
    },
    {
        "content": "<p>We did indeed discuss it :)<br>\n<a href=\"#narrow/stream/257204-project-error-handling/topic/track_caller.20error.20crate/near/254122747\">https://rust-lang.zulipchat.com/#narrow/stream/257204-project-error-handling/topic/track_caller.20error.20crate/near/254122747</a></p>",
        "id": 276267080,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1647990804
    },
    {
        "content": "<p>oof, yea</p>",
        "id": 276268150,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647991481
    },
    {
        "content": "<p>Here are the only viable short-term actions that I see for us:</p>\n<ul>\n<li>Stay on 1.58 and indefinitely delay upgrading our rust toolchain</li>\n<li>Disable the specialized behavior for <code>Result</code> and forfeit all of the benefits of error tracing in our Rust code (indefinitely)</li>\n<li>Hack rustc to \"just accept\" const trait impls for specialization. This will leave us with a compiler that is <em>known incorrect</em> when evaluating traits at runtime. This may not be as bad as it sounds, considering we don't care about evaluating traits at compile time. But it's still scary since I don't know enough to say that it wouldn't cause other subtle issues.</li>\n</ul>",
        "id": 276268164,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1647991492
    },
    {
        "content": "<p>short term, I did manage to get #[track_caller] on result's from residual impl</p>",
        "id": 276268172,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647991503
    },
    {
        "content": "<p>so you should be able to at least capture locations on each error type interconversion</p>",
        "id": 276268187,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647991515
    },
    {
        "content": "<p>in your From impl</p>",
        "id": 276268190,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647991517
    },
    {
        "content": "<p>but you won't get a full trace of every <code>?</code></p>",
        "id": 276268195,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1647991527
    },
    {
        "content": "<p>Hm, I hadn't considered that. It's certainly better than nothing.</p>",
        "id": 276268294,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1647991593
    },
    {
        "content": "<p>I just discovered that the rustc_const_eval <em>does</em> appear to take specialization into account. I don't know why I assumed otherwise initially.</p>",
        "id": 276542603,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1648157741
    },
    {
        "content": "<p>So that \"hack\" to \"just allow const specialized impls\" might not be a hack at all and could just be a good PR to make</p>",
        "id": 276542677,
        "sender_full_name": "Ben Reeves",
        "timestamp": 1648157771
    },
    {
        "content": "<p>Lol, nice!</p>",
        "id": 276561409,
        "sender_full_name": "Jane Lusby [she/her]",
        "timestamp": 1648171828
    }
]