[
    {
        "content": "<p>Has there been any discussion of including libclang in the llvm-tools-preview rustup component? If possible, it seems like it'd help make bindgen usage a lot more user-friendly when building in environments that don't have easy access to a modern clang.</p>",
        "id": 263783063,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1638730397
    },
    {
        "content": "<p>I think there is some discussion here: <a href=\"https://github.com/rust-lang/rust/issues/56371\">https://github.com/rust-lang/rust/issues/56371</a></p>",
        "id": 263784469,
        "sender_full_name": "Eric Huss",
        "timestamp": 1638732233
    },
    {
        "content": "<p>That is for clang, not libclang. Libclang is what is necessary for rust-bindgen.</p>",
        "id": 263786889,
        "sender_full_name": "bjorn3",
        "timestamp": 1638735577
    },
    {
        "content": "<p>Libclang depends on libllvm afaik. I think having the same libllvm used by a proc-macro and by rustc itself may cause issues as the proc-macro may for example forget to initialize llvm (which would silently work for as long as rustc depends on the same libllvm, but may break if it changes to a different libllvm or a non-llvm based codegen backend), or it may try to configure llvm with different settings from rustc which could cause arbitrary bad things to happen. If the proc macro doesn't configure llvm with some settings, that would break if rustc doesn't use the same libllvm, but if it does, that may break rustc. While rust-bindgen doesn't use a proc macro, there is nothing preventing this from being done, and in fact I would expect some people to already do this.</p>",
        "id": 263787229,
        "sender_full_name": "bjorn3",
        "timestamp": 1638735983
    },
    {
        "content": "<p>Wouldn't you be in even worse shape if the program ended up linking to two distinct llvms with overlapping symbol names? Or can the dynamic linker handle that</p>",
        "id": 263790399,
        "sender_full_name": "Steven Fackler",
        "timestamp": 1638740136
    },
    {
        "content": "<p>Rustc uses RTLD_LOCAL when calling dlopen which prevents symbols from leaking out of the proc macro. I think within the proc macro explicit dependencies will have priority over rustc exported symbols, though I am less certain of this. At least on macOS I am sure it isn't a problem due to two level namespaces, which basically record for each symbol in which dylib they need to be looked up.</p>",
        "id": 263790958,
        "sender_full_name": "bjorn3",
        "timestamp": 1638740962
    }
]