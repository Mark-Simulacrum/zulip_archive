[
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> <span class=\"user-mention\" data-user-id=\"422148\">@Joel Marcey</span> <span class=\"user-mention\" data-user-id=\"224872\">@rylev</span> </p>\n<p>I have started building the infra for auto-login via github and general cloud dev desktop stuff: <a href=\"https://github.com/oli-obk/cloud_dev_desktop\">https://github.com/oli-obk/cloud_dev_desktop</a></p>",
        "id": 255857049,
        "sender_full_name": "oli",
        "timestamp": 1633167344
    },
    {
        "content": "<p>I'll continue on Tuesday, but feel free to play with it, poke holes into it or modify it</p>",
        "id": 255857130,
        "sender_full_name": "oli",
        "timestamp": 1633167404
    },
    {
        "content": "<p>thanks <span class=\"user-mention\" data-user-id=\"124288\">@oli</span>! taking a quick look at it, I have a few comments :)</p>",
        "id": 255861575,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1633171673
    },
    {
        "content": "<ul>\n<li>we need to handle github users by their id, not their username, otherwise the system will break once someone changes their username</li>\n</ul>",
        "id": 255861632,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1633171712
    },
    {
        "content": "<ul>\n<li>didn't know about <code>AuthorizedKeysCommand</code>, nice!</li>\n</ul>",
        "id": 255861684,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1633171793
    },
    {
        "content": "<ul>\n<li>we should make sure the tool also allows logging in with non-github users, so that infra can have sudo-enabled accounts managed the same way as the other systems</li>\n</ul>",
        "id": 255861769,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1633171865
    },
    {
        "content": "<ul>\n<li>when we deploy this we should probably move everything over to ansible (<a href=\"https://github.com/rust-lang/simpleinfra/tree/master/ansible\">https://github.com/rust-lang/simpleinfra/tree/master/ansible</a>), so that it's managed like all the other VMs infra is managing</li>\n</ul>",
        "id": 255861791,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1633171906
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121055\">Pietro Albini</span> <a href=\"#narrow/stream/242791-t-infra/topic/cloud.20dev.20desktops/near/255861632\">said</a>:</p>\n<blockquote>\n<ul>\n<li>we need to handle github users by their id, not their username, otherwise the system will break once someone changes their username</li>\n</ul>\n</blockquote>\n<p>for this, to avoid having inconvenient access like <code>gh123456@europe.cloud-dev.rust-lang.org</code>, it might be enough to keep a <code>github_id =&gt; local_username</code> mapping, and when it doesn't match anymore rename the local user and move their home directory</p>",
        "id": 255862016,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1633172110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121055\">Pietro Albini</span> <a href=\"#narrow/stream/242791-t-infra/topic/cloud.20dev.20desktops/near/255861769\">said</a>:</p>\n<blockquote>\n<ul>\n<li>we should make sure the tool also allows logging in with non-github users, so that infra can have sudo-enabled accounts managed the same way as the other systems</li>\n</ul>\n</blockquote>\n<p>according to the docs of <code>AuthorizedKeysCommand</code> if the script fails, it continues to the regular login</p>",
        "id": 255866463,
        "sender_full_name": "oli",
        "timestamp": 1633176444
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"121055\">Pietro Albini</span> <a href=\"#narrow/stream/242791-t-infra/topic/cloud.20dev.20desktops/near/255861632\">said</a>:</p>\n<blockquote>\n<ul>\n<li>we need to handle github users by their id, not their username, otherwise the system will break once someone changes their username</li>\n</ul>\n</blockquote>\n<p>we don't guarantee persistence anyway. my recommendation would be to just not address this and require manual migration if they want to keep their old data</p>",
        "id": 255866545,
        "sender_full_name": "oli",
        "timestamp": 1633176514
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> what if someone changes their username and a new person outside the project creates a new account with that name? The random person shouldn't get access.</p>",
        "id": 255874137,
        "sender_full_name": "Joshua Nelson",
        "timestamp": 1633183989
    },
    {
        "content": "<p>The random person wouldn't get access in that case -- well, unless they have ssh private keys</p>",
        "id": 255874860,
        "sender_full_name": "simulacrum",
        "timestamp": 1633184728
    },
    {
        "content": "<p>we can add a cron job that deletes and archives nonexistant accounts</p>",
        "id": 255875449,
        "sender_full_name": "oli",
        "timestamp": 1633185339
    },
    {
        "content": "<p>they still need to be a team member, too, so it's not that trivial</p>",
        "id": 255875508,
        "sender_full_name": "oli",
        "timestamp": 1633185368
    },
    {
        "content": "<p>I do think it's worth thinking a little about our security requirements. Most similar services/scripts I've looked at (e.g., <a href=\"https://goteleport.com/\">https://goteleport.com/</a>, <a href=\"https://www.vaultproject.io/\">https://www.vaultproject.io/</a>, <a href=\"https://www.boundaryproject.io/\">https://www.boundaryproject.io/</a>) pursue a path that is a little higher resistance -- temporary ssh credentials, typically based on certificate signing -- and add an extra authentication layer to the service (typically e.g. GitHub or some other provider's \"login\" action, afaict).</p>\n<p>I think at minimum whatever tooling we identify should probably have a basic threat model documented and what we're doing to mitigate the risks. For example, it's worth considering that my guess is we will quickly want some kind of hook for garbage collecting user accounts, because particularly with rustc builds today, it is really easy for the disk space requirements to be quite large -- we can certainly provision large disks, but having multiple terabytes of storage per machine is both costly and may start running up against limitations (e.g., max storage provisioned quotas that we need to bump). It seems like we <em>could</em> do this locally -- the script I saw so far would give us a possible hook to schedule from -- but it seems like it might not be the best architecture.</p>\n<p>I think it's also worth adding some kind of monitoring/audit trail for who is logging in to each of these machines. While this doesn't really help directly, I think it will help us understand how people are using them and when (e.g., which regions have the highest demand, how distributed are logins over time or is everyone working in the same \"time\"). To some extent, we get partial assessment from the grafana dashboards showing CPU util and such, but that is a somewhat distant proxy for this data.</p>",
        "id": 255875670,
        "sender_full_name": "simulacrum",
        "timestamp": 1633185556
    },
    {
        "content": "<p>Yea, the threat model I have here is that the only thing we need to protect are users' private keys they will end up using to push to github. If we can avoid storing such private keys (e.g. via the \"login, get temporary token\" method), then to me it seems like we have nothing to protect</p>",
        "id": 255875881,
        "sender_full_name": "oli",
        "timestamp": 1633185772
    },
    {
        "content": "<p>the only other thing that can be attacked is the machine in order to (ab)use its resources, and that is not too critical I believe. Like... someone will tell us and we'll nuke the machine and then improve our security</p>",
        "id": 255875979,
        "sender_full_name": "oli",
        "timestamp": 1633185856
    },
    {
        "content": "<blockquote>\n<p>Yea, the threat model I have here is that the only thing we need to protect are users' private keys they will end up using to push to github. If we can avoid storing such private keys (e.g. via the \"login, get temporary token\" method), then to me it seems like we have nothing to protect</p>\n</blockquote>\n<p>Hm, not sure I follow -- I think we are explicitly aiming for \"no private keys in our possession\" currently, right? We <em>could</em> add a temporary token or signature that the user acquires in order to control access, but I think currently we should probably start with just what we have now since it seems like it should mostly be enough.</p>",
        "id": 255876566,
        "sender_full_name": "simulacrum",
        "timestamp": 1633186484
    },
    {
        "content": "<p>It does mean that if github is down people can't work -- which seems unfortunate; the certificate model with auth through github avoids that</p>",
        "id": 255876593,
        "sender_full_name": "simulacrum",
        "timestamp": 1633186529
    },
    {
        "content": "<p>(with a long enough timeout, say, 3 days)</p>",
        "id": 255876659,
        "sender_full_name": "simulacrum",
        "timestamp": 1633186575
    },
    {
        "content": "<p>I can think two projects off top of my head that can achieve this by moving the authentication to some iap/auth/vault implementation.</p>",
        "id": 255876690,
        "sender_full_name": "nagisa",
        "timestamp": 1633186618
    },
    {
        "content": "<p>that is all beyond my abilities</p>",
        "id": 255876698,
        "sender_full_name": "oli",
        "timestamp": 1633186633
    },
    {
        "content": "<p>we don't store private keys, but ppl may store them</p>",
        "id": 255876716,
        "sender_full_name": "oli",
        "timestamp": 1633186664
    },
    {
        "content": "<p><a href=\"https://github.com/standard-ai/cog\">https://github.com/standard-ai/cog</a> and <a href=\"https://goteleport.com/\">https://goteleport.com/</a></p>",
        "id": 255876768,
        "sender_full_name": "nagisa",
        "timestamp": 1633186686
    },
    {
        "content": "<p>I'll look at these next week... maybe they are not too hard to use</p>",
        "id": 255876801,
        "sender_full_name": "oli",
        "timestamp": 1633186745
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/242791-t-infra/topic/cloud.20dev.20desktops/near/255876690\">said</a>:</p>\n<blockquote>\n<p>I can think two projects off top of my head that can achieve this by moving the authentication to some iap/auth/vault implementation.</p>\n</blockquote>\n<p>Right, I mean, I pointed at one of those and there's a few more in my comment above...</p>",
        "id": 255876822,
        "sender_full_name": "simulacrum",
        "timestamp": 1633186779
    },
    {
        "content": "<p>Using them is not that hard; we can certainly provision them. I think we don't necessarily need to do so for the first iteration, but I do think we need some solution for the disk space question</p>",
        "id": 255876926,
        "sender_full_name": "simulacrum",
        "timestamp": 1633186831
    },
    {
        "content": "<p>To the best of my knowledge they do require a fair amount of setup that only makes sense for fleets of servers tbh. For something simple I don't see why asking people \"please don't store secrets on this machine\" and just grabbing the public keys off their github account is insufficient.</p>",
        "id": 255876931,
        "sender_full_name": "nagisa",
        "timestamp": 1633186833
    },
    {
        "content": "<p>I need to figure out how to get them to be able to git push to their forks, other than that, we store no secrets</p>",
        "id": 255876969,
        "sender_full_name": "oli",
        "timestamp": 1633186880
    },
    {
        "content": "<p>Hmâ€¦ ssh-agent forwarding?</p>",
        "id": 255876981,
        "sender_full_name": "nagisa",
        "timestamp": 1633186908
    },
    {
        "content": "<p>It has its implications, but not as terrible as storing your own private key on the machine.</p>",
        "id": 255877031,
        "sender_full_name": "nagisa",
        "timestamp": 1633186932
    },
    {
        "content": "<p>I do think grabbing github keys is probably enough for the first iteration</p>",
        "id": 255877310,
        "sender_full_name": "simulacrum",
        "timestamp": 1633187240
    },
    {
        "content": "<p>You could limit the key file format to the thing that is commonly used with hardware tokens. ed25519-sk.</p>",
        "id": 255881174,
        "sender_full_name": "The 8472",
        "timestamp": 1633191422
    },
    {
        "content": "<p>and recommend that people use one of those</p>",
        "id": 255881182,
        "sender_full_name": "The 8472",
        "timestamp": 1633191435
    },
    {
        "content": "<blockquote>\n<p>because particularly with rustc builds today, it is really easy for the disk space requirements to be quite large</p>\n</blockquote>\n<p>btrfs or xfs support offline deduplication. that could at least dedup <a href=\"http://crates.io\">crates.io</a> registry downloads and git repos. idk how sharable build parts are. a shared sccache daemon could help too with non-incremental builds.</p>",
        "id": 255881730,
        "sender_full_name": "The 8472",
        "timestamp": 1633191983
    },
    {
        "content": "<p>I don't think those would work well -- most peoples builds aren't going to be the same, binary-wise, since they're in different directories. The <a href=\"http://crates.io\">crates.io</a> registry and git repositories are relatively small, I'm not worried about them.</p>",
        "id": 255882932,
        "sender_full_name": "simulacrum",
        "timestamp": 1633193180
    },
    {
        "content": "<p>It's possible we just don't try to solve this for now, that's probably fine</p>",
        "id": 255882940,
        "sender_full_name": "simulacrum",
        "timestamp": 1633193192
    },
    {
        "content": "<p>but it'll likely quickly become a problem is my guess</p>",
        "id": 255882949,
        "sender_full_name": "simulacrum",
        "timestamp": 1633193203
    },
    {
        "content": "<p>the files don't have to be bit-identical for deduplication. This works on a block-level. But I think blocks need to be aligned so the path-dependent stuff would have to sit towards the end. or ideally in separate files.</p>",
        "id": 255883680,
        "sender_full_name": "The 8472",
        "timestamp": 1633193952
    },
    {
        "content": "<p>yep, needs to be aligned</p>",
        "id": 255883853,
        "sender_full_name": "The 8472",
        "timestamp": 1633194089
    },
    {
        "content": "<p>give everyone a username of the same length and recommend a specific directory layout, then it might work out :D</p>",
        "id": 255883943,
        "sender_full_name": "The 8472",
        "timestamp": 1633194181
    },
    {
        "content": "<p>simpler option: cron job that scans for build dirs and nukes them. that way people get to keep the source</p>",
        "id": 255885912,
        "sender_full_name": "The 8472",
        "timestamp": 1633196185
    },
    {
        "content": "<p>Yes, I think we should nuke build directories that haven't changed in a week and maybe just teach x.py to clean the incremental cache if the base commit of the current branch changes.</p>",
        "id": 255890332,
        "sender_full_name": "oli",
        "timestamp": 1633200655
    },
    {
        "content": "<p>We could try stripping paths to make them all relative to the repository. We do have the logic for this for reproducible builds, maybe we can just enable this in general?</p>",
        "id": 255890426,
        "sender_full_name": "oli",
        "timestamp": 1633200738
    },
    {
        "content": "<p>Maybe. I doubt we'll get much mileage out of deduplication, but cleaning out unchanged directories for a week seems reasonable and probably essentially equivalent</p>",
        "id": 255891213,
        "sender_full_name": "simulacrum",
        "timestamp": 1633201473
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>$ btrfs filesystem du -s *\n     Total   Exclusive  Set shared  Filename\n  14.00GiB     1.82GiB     8.87GiB  rust1\n   7.46GiB     1.20GiB     5.36GiB  rust2\n</code></pre></div>\n<p>dedup does work, I think. I checked out two different revisions, chose different x.py setup profiles (one building llvm) and performed git maintenance on one but not the other, then ran stage1 ui tests.<br>\nthen ran <a href=\"https://github.com/markfasheh/duperemove\">duperemove</a></p>",
        "id": 255891271,
        "sender_full_name": "The 8472",
        "timestamp": 1633201552
    },
    {
        "content": "<p>is btrfs dedup efficient at all? for zfs enabling dedup is strongly advised against due to extreme memory overheads.</p>",
        "id": 255891358,
        "sender_full_name": "nagisa",
        "timestamp": 1633201625
    },
    {
        "content": "<p>And if this is a VM or something we are talking about, it sounds to me like adding more disk would likely give much more straightforward returns than attempting to provision deduplication.</p>",
        "id": 255891396,
        "sender_full_name": "nagisa",
        "timestamp": 1633201681
    },
    {
        "content": "<p>btrfs dedup is done in userspace. you provide the program that looks for duplicate blocks and then ask the kernel to dedup them (kernel will doublecheck). no homungous deduplication tables kept in memory, unlike ZFS. but it does increase fragmentation.</p>",
        "id": 255891446,
        "sender_full_name": "The 8472",
        "timestamp": 1633201698
    },
    {
        "content": "<p>nevermind. automatic snapshots messed up the shared accounting. dedup only saved 3.6GB out of 14GB for the one with llvm build after rerunning on a subvolume without snapshotting.</p>",
        "id": 255892420,
        "sender_full_name": "The 8472",
        "timestamp": 1633202695
    },
    {
        "content": "<p>another good way to save some space is to use a filesystem-level compression. lz4 saves me like 30% on my projects dataset. If there's any interest I can try measuring just a typical rust checkout with build artifacts.</p>",
        "id": 255892901,
        "sender_full_name": "nagisa",
        "timestamp": 1633203196
    },
    {
        "content": "<p>So... I played around a little, and we cannot use the AuthorizedKeysCommand system, but it turns out this only works for users that already exist. There is nothing built-in to handle non-existing users beyond \"have a daemon look at the failed login logs and create the users\".</p>",
        "id": 257393525,
        "sender_full_name": "oli",
        "timestamp": 1634141781
    },
    {
        "content": "<p>I did not look at <a href=\"https://goteleport.com/\">https://goteleport.com/</a>, <a href=\"https://www.vaultproject.io/\">https://www.vaultproject.io/</a>, <a href=\"https://www.boundaryproject.io/\">https://www.boundaryproject.io/</a> yet and won't get to those before next week</p>",
        "id": 257393711,
        "sender_full_name": "oli",
        "timestamp": 1634141867
    },
    {
        "content": "<p>yea, without writing a new PAM module (<a href=\"https://serverfault.com/a/990546\">https://serverfault.com/a/990546</a>) or the fun daemon above... we need a real system like the three mentioned alternatives</p>",
        "id": 257397483,
        "sender_full_name": "oli",
        "timestamp": 1634143287
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> wouldn't a cronjob that runs every 5 minutes and creates/deletes users also work?</p>",
        "id": 257398422,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1634143599
    },
    {
        "content": "<p>it wouldn't be instant but other things take a couple minutes to synchronize with the team repo</p>",
        "id": 257398518,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1634143627
    },
    {
        "content": "<p>sure</p>",
        "id": 257398753,
        "sender_full_name": "oli",
        "timestamp": 1634143713
    },
    {
        "content": "<p>Well, we don't even need that - right? We can have the sync-teams script we already run in a privileged context on aws  do an Ansible deploy to reprovision accounts, which seems like it might be better anyway</p>",
        "id": 257398801,
        "sender_full_name": "simulacrum",
        "timestamp": 1634143727
    },
    {
        "content": "<p>that sounds reasonable, then the login script doesn't need to check the teams repo anymore, as we can assume the accounts are alright, because the ansible deploy can delete users that are not in the list</p>",
        "id": 257399024,
        "sender_full_name": "oli",
        "timestamp": 1634143809
    },
    {
        "content": "<p>That seems pretty reasonable to me at least. It might be even less work (since we already mostly have Ansible setup for other machines, just without syncing with team repo)</p>",
        "id": 257399171,
        "sender_full_name": "simulacrum",
        "timestamp": 1634143868
    },
    {
        "content": "<p>ok... uh... can I either get some guidance or help or outright someone else to do it here? Or is it pretty obvious how stuff works if I just read the scripts repo?</p>",
        "id": 257399388,
        "sender_full_name": "oli",
        "timestamp": 1634143951
    },
    {
        "content": "<p>I don't think anyone here is more familiar with ansible than \"has run it some times locally and skimmed docs\"</p>",
        "id": 257400157,
        "sender_full_name": "simulacrum",
        "timestamp": 1634144217
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/sync-team\">https://github.com/rust-lang/sync-team</a> is the thing that runs in the privileged context</p>",
        "id": 257400204,
        "sender_full_name": "simulacrum",
        "timestamp": 1634144232
    },
    {
        "content": "<p>it's probably not too hard to add an ssh sync to that (just running ssh command likely with an admin account or so...)</p>",
        "id": 257400321,
        "sender_full_name": "simulacrum",
        "timestamp": 1634144279
    },
    {
        "content": "<p>hmm, I think it's likely less complex to just have a cronjob/systemd timer for that</p>",
        "id": 257400465,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1634144334
    },
    {
        "content": "<p>afaik there's not really a clean way to take the list of users from the team api and put it into the ansible variables</p>",
        "id": 257400570,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1634144377
    },
    {
        "content": "<p>so we'd need to have ansible run a script into the server that adds and deletes the users</p>",
        "id": 257400598,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1634144392
    },
    {
        "content": "<p>at that point we can just have that script in a timer</p>",
        "id": 257400616,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1634144398
    },
    {
        "content": "<p>yeah, I mean, we don't really need it to be ansible</p>",
        "id": 257400681,
        "sender_full_name": "simulacrum",
        "timestamp": 1634144407
    },
    {
        "content": "<p>anyway, a cron job also seems fine to me</p>",
        "id": 257400785,
        "sender_full_name": "simulacrum",
        "timestamp": 1634144433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116122\">simulacrum</span> <a href=\"#narrow/stream/242791-t-infra/topic/cloud.20dev.20desktops/near/257400785\">said</a>:</p>\n<blockquote>\n<p>anyway, a cron job also seems fine to me</p>\n</blockquote>\n<p>cool, I can do a cron job!</p>",
        "id": 257424637,
        "sender_full_name": "oli",
        "timestamp": 1634153851
    },
    {
        "content": "<p>ok, everything works <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 257536824,
        "sender_full_name": "oli",
        "timestamp": 1634218942
    },
    {
        "content": "<p>all setup stuff is in <a href=\"https://github.com/oli-obk/cloud_dev_desktop\">https://github.com/oli-obk/cloud_dev_desktop</a></p>",
        "id": 257536883,
        "sender_full_name": "oli",
        "timestamp": 1634218969
    },
    {
        "content": "<p>great! I think we'll want to see the setup scripts repackaged into an ansible config so we can consistently run them against the (eventual) multiple machines</p>",
        "id": 257538040,
        "sender_full_name": "simulacrum",
        "timestamp": 1634219392
    },
    {
        "content": "<p>(in particular as a PR against rust-lang/simpleinfra)</p>",
        "id": 257538136,
        "sender_full_name": "simulacrum",
        "timestamp": 1634219419
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116155\">@Jake Goulding</span> has recently done the legwork to do that for <a href=\"http://play.rust-lang.org\">play.rust-lang.org</a>, so you can probably look at that PR</p>",
        "id": 257538192,
        "sender_full_name": "simulacrum",
        "timestamp": 1634219445
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/simpleinfra/pull/78\">https://github.com/rust-lang/simpleinfra/pull/78</a></p>",
        "id": 257538250,
        "sender_full_name": "simulacrum",
        "timestamp": 1634219466
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> <span class=\"user-mention\" data-user-id=\"116122\">@simulacrum</span> Just catching up here. So we now have all the right scripts to get a general set of AWS machines set up with what is needed for maintainers to access the cloud infra. We have one actual AWS machine running this setup right now, correct? Has the flow been tested yet on it? i.e. a pull request from a maintainer that actually uses the machine?</p>",
        "id": 258737630,
        "sender_full_name": "Joel Marcey",
        "timestamp": 1634920703
    },
    {
        "content": "<p>oh right lol, should actually try out more than trivial rustc builds</p>",
        "id": 258753472,
        "sender_full_name": "oli",
        "timestamp": 1634927463
    },
    {
        "content": "<p>I got a contributor to log on, so that part works</p>",
        "id": 258753516,
        "sender_full_name": "oli",
        "timestamp": 1634927484
    },
    {
        "content": "<p>I have started the \"make more of these machines\" PR in <a href=\"https://github.com/rust-lang/simpleinfra/pull/79\">https://github.com/rust-lang/simpleinfra/pull/79</a></p>",
        "id": 258753641,
        "sender_full_name": "oli",
        "timestamp": 1634927529
    },
    {
        "content": "<p>it is entirely untested tho</p>",
        "id": 258753666,
        "sender_full_name": "oli",
        "timestamp": 1634927542
    },
    {
        "content": "<p>Is there a current non-critical PR that we can use to test the flow?</p>",
        "id": 258839322,
        "sender_full_name": "Joel Marcey",
        "timestamp": 1635018221
    },
    {
        "content": "<p>It's less testing it on a real PR that is the problem, I can verify this together with a contributor that everything works, the main problem is replicating the machine, which I haven't figured out how to test yet</p>",
        "id": 258863389,
        "sender_full_name": "oli",
        "timestamp": 1635058115
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"124288\">@oli</span> Could we manually set up 3-4 machines globally and then come up with the right process to replicate more as needed?</p>",
        "id": 259132723,
        "sender_full_name": "Joel Marcey",
        "timestamp": 1635269649
    },
    {
        "content": "<p>I would prefer we use Ansible to configure the machines from the start, that way all the machines will be standardized and centrally managed</p>",
        "id": 259133138,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1635269835
    },
    {
        "content": "<p>infra has been trying to migrate away from manually managed machines, and I'd prefer not to regress on that front <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 259133533,
        "sender_full_name": "Pietro Albini",
        "timestamp": 1635269997
    },
    {
        "content": "<p>Yeah, I think that's a necessity. I left another comment on Oli's PR, and am happy to try it out when that's resolved to configure a new machine.</p>\n<p>We'll likely also want to manage the machines themselves through terraform so it's easy to spin them up in the appropriate size -- IIRC, we don't yet have configs for that? I might have them in a local branch though, not sure</p>",
        "id": 259133537,
        "sender_full_name": "simulacrum",
        "timestamp": 1635269999
    },
    {
        "content": "<p>Thanks ... I agree with both of you that a centrally managed system to manage the machines is definitely optimal and the way to go. I just wasn't sure how close we were to getting there. And I didn't want to  hold up the potential benefits of this indefinitely. But, if we are close to having a turnkey system, then that's <span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 259137123,
        "sender_full_name": "Joel Marcey",
        "timestamp": 1635271452
    }
]