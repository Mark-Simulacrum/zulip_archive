[
    {
        "content": "<p>I'm planning to work on a policy for reimplementations of Rust and \"extensions\" to Rust, and how (or if) we collaborate with such things. It seems like use of MIR for purposes like code generation (especially for things like proprietary code generation backends) or for extensions to the language (of any kind, whether open or proprietary) are likely to generate issues in that regard. It's not something we can <em>prohibit</em>, and people could do it anyway by modifying the whole compiler, and in practice I expect it'll produce more value than harm, but I want to be cautious about it and take it into account in any such policy.</p>",
        "id": 277922835,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649183078
    },
    {
        "content": "<p>So, yes, I can see how exposing MIR as a usable interchange format could introduce issues like you describe.</p>",
        "id": 277923708,
        "sender_full_name": "pnkfelix",
        "timestamp": 1649183385
    },
    {
        "content": "<p>The initial users we are targeting here are the formal methods folks; <span class=\"user-mention\" data-user-id=\"312719\">@Xavier Denis</span> prepared a nice doc that was also presented at the 2022-03-25 steering meeting. Doc here: <a href=\"https://hackmd.io/qLk-wnwtStOhCOBeF5YuOw?view\">https://hackmd.io/qLk-wnwtStOhCOBeF5YuOw?view</a></p>",
        "id": 277923998,
        "sender_full_name": "pnkfelix",
        "timestamp": 1649183489
    },
    {
        "content": "<p>but alternative code generators, such as cranelift, are an obvious additional customer</p>",
        "id": 277924054,
        "sender_full_name": "pnkfelix",
        "timestamp": 1649183506
    },
    {
        "content": "<p>I'm curious if you have specific concerns that your policy is meant to address. the most obvious one i can think of is \"Lets not encourage people to fork the language.\" (which some might convert into \"lets not make it <em>too easy</em> for people to fork the language\", though I would argue that is a different goal...)</p>",
        "id": 277924288,
        "sender_full_name": "pnkfelix",
        "timestamp": 1649183578
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/320896-project-stable-mir/topic/Backends.2C.20extensions.2C.20and.20policy/near/277924288\">said</a>:</p>\n<blockquote>\n<p>I'm curious if you have specific concerns that your policy is meant to address. the most obvious one i can think of is \"Lets not encourage people to fork the language.\" (which some might convert into \"lets not make it <em>too easy</em> for people to fork the language\", though I would argue that is a different goal...)</p>\n</blockquote>\n<p>That's a big part of it, and that includes \"forking the language\", \"forking the ecosystem\", and things like proprietary targets or optimizers.</p>",
        "id": 277927807,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649184977
    },
    {
        "content": "<p>Useful new api's being added to libcore relatively often should prevent long term forks of the language I think. As for proprietary codegen backends I think those would also be worked against if we keep the churn around the interaction between libcore and rustc and only stabilize the MIR data structures, but not eg some intrinsics and lang items. It should still be useful for formal verification or other things that don't need compiling every single function, but those use cases for where it is needed would need to adopt every rustc release I think.</p>",
        "id": 277928828,
        "sender_full_name": "bjorn3",
        "timestamp": 1649185420
    },
    {
        "content": "<p>I don't necessarily think we should make it <em>gratuitously hard</em> on a <em>technical</em> level to use MIR for such purposes, if we don't have some other reason to do so. Rather, we should be aware that such uses are likely to arise. There's a cycle of people saying \"hey, what if we shipped a proprietary optimizer that advantages our hardware\", or \"what if we shipped a proprietary GPU backend\", or many other things, that long predates Rust.</p>",
        "id": 277931391,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649186605
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/320896-project-stable-mir/topic/Backends.2C.20extensions.2C.20and.20policy/near/277928828\">said</a>:</p>\n<blockquote>\n<p>Useful new api's being added to libcore relatively often should prevent long term forks of the language I think. As for proprietary codegen backends I think those would also be worked against if we keep the churn around the interaction between libcore and rustc and only stabilize the MIR data structures, but not eg some intrinsics and lang items. It should still be useful for formal verification or other things that don't need compiling every single function, but those use cases for where it is needed would need to adopt every rustc release I think.</p>\n</blockquote>\n<p>I'm not sure I see what you mean about why that would affect proprietary codegen backends. Part of being a backend would be that it reuses the Rust frontend.</p>",
        "id": 277931539,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1649186659
    },
    {
        "content": "<blockquote>\n<p>I'm not sure I see what you mean about why that would affect proprietary codegen backends.</p>\n</blockquote>\n<p>A proprietary codegen backend would be harder to keep up to date than one users can build from source and harder than in-tree (even if as git subtree) backends.</p>\n<blockquote>\n<p>Part of being a backend would be that it reuses the Rust frontend.</p>\n</blockquote>\n<p>Backends need a certain level of integration with lang items and full integration with intrinsics. Intrinsics are entirely implemented in the codegen backend.</p>",
        "id": 277932568,
        "sender_full_name": "bjorn3",
        "timestamp": 1649187237
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/320896-project-stable-mir/topic/Backends.2C.20extensions.2C.20and.20policy/near/277927807\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"116083\">pnkfelix</span> <a href=\"#narrow/stream/320896-project-stable-mir/topic/Backends.2C.20extensions.2C.20and.20policy/near/277924288\">said</a>:</p>\n<blockquote>\n<p>I'm curious if you have specific concerns that your policy is meant to address. the most obvious one i can think of is \"Lets not encourage people to fork the language.\" (which some might convert into \"lets not make it <em>too easy</em> for people to fork the language\", though I would argue that is a different goal...)</p>\n</blockquote>\n<p>That's a big part of it, and that includes \"forking the language\", \"forking the ecosystem\", and things like proprietary targets or optimizers.</p>\n</blockquote>\n<p>I don't think that a stable mir should be a cause for concern about forking the language. If anything I think it will be beneficial for us as a whole both by enabling researchers to work with rust and also by helping us get a better understanding of what we want the mir semantics to be (though of course the two are the same subjects)</p>",
        "id": 277941845,
        "sender_full_name": "Xavier Denis",
        "timestamp": 1649192051
    }
]