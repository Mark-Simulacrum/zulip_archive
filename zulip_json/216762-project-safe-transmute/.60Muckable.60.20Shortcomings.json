[
    {
        "content": "<p>The <em>Drawbacks</em> section of the RFC is still a TODO, and I'd like to fill it out in the near future. The RFC presents a major design question with two compelling answers:</p>\n<ul>\n<li>just solve safety, but not stability (i.e., with <code>Here!()</code>)</li>\n<li>solve safety in a way that intertwines it with stability (i.e., with <code>Muckable</code>)</li>\n</ul>\n<p>The drawbacks of the first approach have been well discussed. The drawbacks of the second approach less so, and I want to start documenting them.</p>",
        "id": 216526979,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605214409
    },
    {
        "content": "<p>Chiefely, I'd like to identify the situations where an all-or-nothing stability promise is prohibitively strong. If the stability constraints of <code>Muckable</code> are prohibitive for a type, then that type cannot be safely transmuted.</p>",
        "id": 216528486,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605215123
    },
    {
        "content": "<p>Mahkoh <a href=\"https://github.com/rust-lang/rfcs/pull/2981#issuecomment-720729607\">points out</a>:</p>\n<blockquote>\n<p>The libc crate contains plenty of types that carry a size field at the start so that new fields can be added at the end in future versions. Surely it should be safe to transmute into those types?</p>\n</blockquote>\n<p>Concretely, with a type like this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">FFIType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">size</span>: <span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">field_1</span>: <span class=\"nc\">Foo</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">field_2</span>: <span class=\"nc\">Bar</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* append-only more fields */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...fields can be non-breakingly appended to this definition over time because the type is marked <code>#[non_exhaustive]</code>. </p>\n<p>However, by implementing <code>Muckable</code>, the crate author promises to treat <em>any</em> observable changes to the type's layout as breaking changes. If this type implemented <code>Muckable</code>, any field additions would need to correspond to a major version release of its crate. The stability goals of crates like <code>libc</code> probably rule out implementing <code>Muckable</code>.</p>",
        "id": 216529318,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605215578
    },
    {
        "content": "<p>I'd like to note that within a C/FFI context, the <code>non_exhaustive</code> part is not considered important and is generally not applied to the structs in question.</p>",
        "id": 216632313,
        "sender_full_name": "Lokathor",
        "timestamp": 1605283586
    },
    {
        "content": "<p>If the crate in question is <code>libc</code>, as mahkoh suggests, it <em>would</em> be importantâ€”right?</p>",
        "id": 216633736,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605284082
    },
    {
        "content": "<p>No. If the definition of the struct changes you'll have a new value in the size field.</p>",
        "id": 216659795,
        "sender_full_name": "Lokathor",
        "timestamp": 1605295479
    },
    {
        "content": "<p>Remember, other langs don't use matching so they don't care</p>",
        "id": 216659830,
        "sender_full_name": "Lokathor",
        "timestamp": 1605295501
    },
    {
        "content": "<p>Yeah, I got that. But rust <em>does</em>, so you can't semver-nonbreakingly add a field to an exhaustively destructurable type without bumping the major version number.</p>",
        "id": 216660011,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605295578
    },
    {
        "content": "<p>I mean I guess that rust code could care about it on the rust-only side, yeah.</p>\n<p>I should say that \"in terms of a C FFI ABI interface it's not considered a break\"</p>",
        "id": 216660084,
        "sender_full_name": "Lokathor",
        "timestamp": 1605295618
    },
    {
        "content": "<p>(And i suspect libc doesn't use non_exhaustive yet because it supports old compilers)</p>",
        "id": 216660377,
        "sender_full_name": "Lokathor",
        "timestamp": 1605295719
    },
    {
        "content": "<p>Yep! I think we're on the same page.</p>\n<p>Basically: there's a pattern of abi evolution in C that isn't considered breaking. But to pull off that same pattern in Rust without semver breaking changes, you technically should  mark the type with <code>#[non_exhaustive]</code>.</p>",
        "id": 216660441,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605295737
    },
    {
        "content": "<p>yet again rust is slightly leaky with abstractions, oh well</p>",
        "id": 216660717,
        "sender_full_name": "Lokathor",
        "timestamp": 1605295813
    },
    {
        "content": "<p>(cross-linking the discussion <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard/near/216747469\">here</a>! summary follows:)</p>\n<p>If <code>Muckable</code> denotes fixed field order in the layout, then <code>Muckable</code> must <em>not</em> be implemented for <code>repr(rust)</code> types. Such types currently do not have many guarantees (and thus are not <code>TransmuteFrom</code> by a longshot), but it's not inconceivable that a future version of Rust <em>could</em> provide guarantees for those types other than field order.</p>\n<p>If <code>Muckable</code> implementations on <code>repr(rust)</code> types are puttering around, those implementations go from being harmless (you can't observe their useless guarantee because they're not <code>TransmuteFrom</code>) to dangerous (since you <em>can</em> use them with <code>TransmuteFrom</code>.</p>\n<p>We can solve this in a few ways:</p>\n<ul>\n<li>have <code>Muckable</code> continue to denote field-order stability but prohibit implementations of <code>Muckable</code> on types that aren't <code>#[repr(c)]</code></li>\n<li>disentangle layout stability from safety</li>\n</ul>",
        "id": 216757695,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605398264
    },
    {
        "content": "<p>I hate to bring up old conversations, but is another possible way to clarify <code>Muckable</code> to break it up into several traits that more clearly mark their guarantees? If you have a <code>StableFieldOrdering</code> + <code>ByteComplete</code> + <code>InvariantFree</code> doesn't it become easier to know which invariants can be placed on which types?</p>",
        "id": 216865787,
        "sender_full_name": "rylev",
        "timestamp": 1605530809
    },
    {
        "content": "<p>It becomes a little more self-documenting, but we should be able to document what guarantees <code>Muckable</code> gives.</p>",
        "id": 216907027,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605549147
    },
    {
        "content": "<p>Also, I'd probably combine <code>ByteComplete</code> and <code>InvariantFree</code>, since if you don't have both you can't transmute into.</p>",
        "id": 216907072,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605549191
    },
    {
        "content": "<p>(You could transmute something with aligned fields of the same type, but that doesn't seem worth the split.)</p>",
        "id": 216907120,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605549225
    },
    {
        "content": "<p>Similarly, for <code>StableFieldOrdering</code>, under what circumstances would you want to guarantee that and nothing else, or conversely, everything else but not that?</p>",
        "id": 216907208,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605549260
    },
    {
        "content": "<p>What would you <em>get</em> by doing so?</p>",
        "id": 216907214,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605549265
    },
    {
        "content": "<p>I feel like the combination is the most useful, and it seems much rarer to want just some of the pieces.</p>",
        "id": 216907274,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605549302
    },
    {
        "content": "<p>When you say \"you\", do you mean the Rust Programming Language, or do you mean a type author making SemVer stability promises about their type?</p>",
        "id": 216912690,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605551667
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> example: StableFieldOrdering is <em>not</em> part of <code>struct Point2D(i32,i32)</code>, even though the type is byte complete and invariant free.</p>",
        "id": 216917520,
        "sender_full_name": "Lokathor",
        "timestamp": 1605553963
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> True (albeit I personally think it <em>should</em> be possible to assume that has the same order as any other <code>(i32,i32)</code>).</p>",
        "id": 216917601,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554006
    },
    {
        "content": "<p>But if you can't assume <code>StableFieldOrdering</code>, what can you do, transmute-wise?</p>",
        "id": 216917625,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554022
    },
    {
        "content": "<p>but the <code>(i32,i32)</code> values <em>also</em> don't have a stable field ordering :3 Specifically in the case of StableFieldOrdering you don't particularly \"get\" much out of a type lacking that trait, but that's also the default state for rust types, so that's just \"how it is\" for now</p>",
        "id": 216917695,
        "sender_full_name": "Lokathor",
        "timestamp": 1605554053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/216917695\">said</a>:</p>\n<blockquote>\n<p>but the <code>(i32,i32)</code> values <em>also</em> don't have a stable field ordering :3 Specifically in the case of StableFieldOrdering you don't particularly \"get\" much out of a type lacking that trait, but that's also the default state for rust types, so that's just \"how it is\" for now</p>\n</blockquote>\n<p>Right, but separating the traits would mostly be of benefit if you want to specify some but not all of them. But I don't think you <em>gain</em> anything by doing so.</p>",
        "id": 216917720,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/216917625\">said</a>:</p>\n<blockquote>\n<p>But if you can't assume <code>StableFieldOrdering</code>, what can you do, transmute-wise?</p>\n</blockquote>\n<p>Quite a bit, depending on your use-case and what degree of stability you need.</p>",
        "id": 216917724,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605554083
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/216912690\">said</a>:</p>\n<blockquote>\n<p>When you say \"you\", do you mean the Rust Programming Language, or do you mean a type author making SemVer stability promises about their type?</p>\n</blockquote>\n<p>I mean the latter, but in particular, I mean \"what do you gain in terms of capabilities, by specifying some but not all of these promises\".</p>",
        "id": 216917755,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554102
    },
    {
        "content": "<p>For language-level stability, see this comment: <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard/near/216750267\">https://rust-lang.zulipchat.com/#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard/near/216750267</a></p>",
        "id": 216917786,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605554120
    },
    {
        "content": "<p>also, traits aren't really about \"missing\" something to begin with, they're about saying \"this type <strong>supports</strong> a thing\", so Copy is about \"this type is freely copyable (and not all things are!)\" and StableFieldOrder is about \"this type has a stable field order (and not all types have that!)\"</p>",
        "id": 216917832,
        "sender_full_name": "Lokathor",
        "timestamp": 1605554147
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> If you can't assume that the fields have the same order as even another type with the same fields, I don't think there's any useful transmute you can do, except perhaps between containers containing the type opaquely.</p>",
        "id": 216917861,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554162
    },
    {
        "content": "<p>Ah, I see.</p>",
        "id": 216917969,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554201
    },
    {
        "content": "<blockquote>\n<p>except perhaps between containers containing the type opaquely.</p>\n</blockquote>\n<p>That's nothing to sneeze at, though. That's the extent of Haskell's <code>Coercible</code> machinery.</p>",
        "id": 216918039,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605554238
    },
    {
        "content": "<p>I'd forgotten that one of the things you could \"ask for\" with the safe-transmute trait-based system was whether you cared about stability, and if you don't care then it's fine to transmute the type into bytes and bytes back into the type as long as you don't unserialize them with a different compiled version of the code than you serialized them with.</p>",
        "id": 216918076,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554259
    },
    {
        "content": "<p>It's debatable how \"safe\" that is (since you have to manually maintain the invariant that you're handing back the same bytes you got in).</p>",
        "id": 216918180,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554303
    },
    {
        "content": "<p>But safety aside, it's something you'd be allowed to do.</p>",
        "id": 216918207,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605554317
    },
    {
        "content": "<p>which actually makes a lot of network apps \"way easier\" if you know you're communicating with a particular bit of code on the far side, eg if you've deployed both the server and the client</p>",
        "id": 216918209,
        "sender_full_name": "Lokathor",
        "timestamp": 1605554319
    },
    {
        "content": "<p>Now <em>separately</em> from safe transmute we should probably take some effort and specify more cases of repr(rust) at some point, but that would be a whole separate RFC.</p>",
        "id": 216918445,
        "sender_full_name": "Lokathor",
        "timestamp": 1605554425
    },
    {
        "content": "<p>There are a <em>lot</em> of possible shades of possible language-level layout guarantees that are less extreme than <code>#[repr(C)]</code>, and there are a <em>lot</em> of possible shades of SemVer stability that might be valuable other than all-or-nothing.</p>\n<p>I'm very wary of limiting <code>TransmuteFrom</code> in a way that means its basically only usable at these guarantee and stability extremes. That will close doors for us with other reprs, and it will mean that safe transmute isn't available in cases with an all-or-nothing SemVer guarantee about layout is prohibitive.</p>",
        "id": 216918709,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605554561
    },
    {
        "content": "<p>Honestly, it should just <em>be fine</em> for you to sometimes get garbage nonsense</p>",
        "id": 216918789,
        "sender_full_name": "Lokathor",
        "timestamp": 1605554606
    },
    {
        "content": "<p>If we separate stability from safety, as the constructability-aware version of the RFC did, these problems do not arise: we don't need to have very subtle discussions about <code>Muckable</code>'s implications, we don't risk limiting ourselves in the future with other reprs if it turns out we got <code>Muckable</code> wrong, and we don't limit ourselves in the present by imposing a semver stability system that isn't applicable in some situations.</p>\n<p>There were some concerns about whether the constructability-aware version is sound, but the discussion on the <em>Type Privacy &amp; Safety</em> topic <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216805918\">suggests</a> that the (existing) mechanism that underlies it can be soundly relied on. If the remaining concerns about it are primarily aesthetic, we should weigh those aesthetic cost against the expressive cost of the alternative.</p>",
        "id": 216920499,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605555424
    },
    {
        "content": "<p>I think it'll be very hard to find a one-size-fits all solution to stability:</p>\n<ul>\n<li>what sort of stability you value varies widely by use-case</li>\n<li>we're unlikely to identify all present use-cases in which a stability system is inadequate</li>\n<li>we're unlikely to identify all future use-cases in which a stability system might become inadequate (e.g., through new layout guarantees on other reprs)</li>\n</ul>\n<p>If transmutation stability and safety are entangled (as is the case for <code>Muckable</code>), all of those use cases in which our stability system is inadequate will be use-cases in which we cannot provide safe transmutation. <span aria-label=\"frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"frown\">:frown:</span></p>",
        "id": 216923136,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605556771
    },
    {
        "content": "<p>Would it be any more involved that just removing the stability part from <code>Muckable</code>?</p>",
        "id": 216933201,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1605561294
    },
    {
        "content": "<p>I certainly wouldn't object to 1) removing the stability parts of <code>Muckable</code>, 2) clearly documenting the \"wrapper\" pattern that allows having a \"private\" <code>impl Muckable</code> within a crate, and 3) supporting the development of a <code>private impl</code> mechanism to avoid having to use that wrapper pattern.</p>",
        "id": 216933723,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605561576
    },
    {
        "content": "<p>I think that'd be a much simpler model.</p>",
        "id": 216933738,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605561584
    },
    {
        "content": "<p>Trying to encode stability in the type system seems painful, compared to the more orthogonal approach of extending encapsulation to cover traits (and providing a workaround until we do).</p>",
        "id": 216933931,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605561669
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> what do you mean by \"extending encapsulation to cover traits\"?</p>",
        "id": 216935903,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605562622
    },
    {
        "content": "<p>I mean that today we don't allow private impls, which means that traits break encapsulation in a way. We should fix that if we can.</p>",
        "id": 216972612,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605597797
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> we already did! <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> Type Privacy provides a compiler-enforced mechanism of implementation privacy.</p>",
        "id": 217010248,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605623929
    },
    {
        "content": "<p>Trait implementations inherit the minimum visibility of the trait, the implemented type, or their parameters.</p>",
        "id": 217010504,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605624034
    },
    {
        "content": "<p>I would assume Josh is talking about a more direct implementation that doesn't require extra <code>Scope</code> parameters everywhere. Especially since that was the main objection anyway (\"reimplementing the visibility system in the trait system\")- type privacy only talks about impls insofar as it helps accomplish its goal of making private types actually private.</p>",
        "id": 217020714,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605628322
    },
    {
        "content": "<p>The type privacy RFC focuses significantly on ensuring that private implementations cannot be used. (E.g., even if you infer access to a private type, you can't use its <code>From</code> implementation.)</p>",
        "id": 217020964,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605628419
    },
    {
        "content": "<p>Sorry, silly question: Can you link the \"type privacy RFC\"?</p>",
        "id": 217044986,
        "sender_full_name": "scottmcm",
        "timestamp": 1605638586
    },
    {
        "content": "<p>Sure! <a href=\"https://github.com/rust-lang/rfcs/pull/2145\">https://github.com/rust-lang/rfcs/pull/2145</a></p>",
        "id": 217045080,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605638631
    },
    {
        "content": "<p>Ah, the \"statically anonymized\" bit is what I was missing.  I'm confused by the \"or usual generics\" part, though, since it seems like that'd re-open the \"Now foreign code can freely define functions like\" thing that was just described as a problem.</p>",
        "id": 217046726,
        "sender_full_name": "scottmcm",
        "timestamp": 1605639488
    },
    {
        "content": "<p>I'm pretty sure that by \"usual generics\", the RFC is referring to a situation like <code>From</code>/<code>Into</code>. If you define a private implementation of <code>From</code>; i.e., either:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Private</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Public</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">Private</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Public</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">Public</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Private</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...then <em>you</em> can still take advantage of the blanket impl on <code>Into</code> provided by libcore. For instance, if a third-party crate defines a function:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">is_convertible</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nb\">Into</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><em>you</em> can call that function with <code>Public</code> and <code>Private</code> <em>even though the implementations of <code>From</code> for those types is private from the perspective of libcore</em> (where the blanket impl of <code>Into</code> is defined generically in terms of <code>From</code>).</p>",
        "id": 217047996,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605640094
    },
    {
        "content": "<p>Ah, so if _I_ call <code>fn require_trait_value&lt;T: Trait&gt;(arg: T) { ... }</code> then it can use it via that <code>T</code>, but they can't do it if they grabbed the type through some other jiggery-pokery?</p>",
        "id": 217049202,
        "sender_full_name": "scottmcm",
        "timestamp": 1605640733
    },
    {
        "content": "<p>Feels like that still allows it to leak if something you're calling bounds by different traits than expected.  And I don't know what it means for specialization...</p>",
        "id": 217049419,
        "sender_full_name": "scottmcm",
        "timestamp": 1605640837
    },
    {
        "content": "<p>My understanding is: Whether or not that function is invocable depends on a reachability-based analysis of the visibility of <code>T: Trait</code> from the point where <code>require_trait_value</code> is invoked with a concrete <code>T</code>.</p>",
        "id": 217049915,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605641066
    },
    {
        "content": "<p>Providing these sorts of protections was a <a href=\"https://internals.rust-lang.org/t/lang-team-minutes-private-in-public-rules/4504\">major motivation of type privacy</a> and its enforcement is <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216805918\">already relied upon to be airtight</a>.</p>",
        "id": 217050143,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605641189
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217020964\">said</a>:</p>\n<blockquote>\n<p>The type privacy RFC focuses significantly on ensuring that private implementations cannot be used. (E.g., even if you infer access to a private type, you can't use its <code>From</code> implementation.)</p>\n</blockquote>\n<p>Sure, but that doesn't change anything about its <em>intent</em> (or aesthetics, as you put it elsewhere). Regardless of how airtight and/or relied-upon this kind of impl visibility is, it exists solely in service of its primary goal of <em>type</em> privacy.</p>",
        "id": 217056066,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644011
    },
    {
        "content": "<p>From the <a href=\"https://internals.rust-lang.org/t/lang-team-minutes-private-in-public-rules/4504\">internals discussion</a></p>\n<blockquote>\n<p>Their intention is to ensure that if you have a private struct, then nobody outside of the module can get their hands on an instance of that struct, and nor can they name the type. <strong>This implies that methods defined on that private struct (including methods from public traits like Clone which donâ€™t have privacy protections) cannot be invoked except for within the module that defined it. This is a useful guarantee for unsafe code.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>",
        "id": 217056316,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644126
    },
    {
        "content": "<p>I.e., currently the only way to mark an impl as private is to involve a private <em>type</em>, like <code>Scope</code>.</p>",
        "id": 217056329,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644131
    },
    {
        "content": "<p>I really don't understand what point you're trying to make <span aria-label=\"oh no\" class=\"emoji emoji-1f615\" role=\"img\" title=\"oh no\">:oh_no:</span></p>",
        "id": 217056363,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644151
    },
    {
        "content": "<p>You can rely on type privacy to ensure that trait implementations involving private types are private, too.</p>",
        "id": 217056448,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644178
    },
    {
        "content": "<p>Yes? How does that change anything about what I'm saying (about what I assume Josh meant)?</p>",
        "id": 217056483,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644198
    },
    {
        "content": "<p>Sorry, I thought you were saying that private impls were an accidental consequence of type privacy, since it's called \"type privacy\" and not \"trait privacy\". Whereas, in actuality, private impls were an underlying motivation.</p>",
        "id": 217056595,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644272
    },
    {
        "content": "<p>I'm saying that private impls were made possible entirely in service of <em>type</em> privacy, and so may not be very fun to use when <em>your</em> primary goal is to hide an impl on a public type.</p>",
        "id": 217056713,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644328
    },
    {
        "content": "<p>I don't know if your interpretation of <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>'s comment is correct.</p>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/216972612\">said</a>:</p>\n<blockquote>\n<p>I mean that today we don't allow private impls, which means that traits break encapsulation in a way. We should fix that if we can.</p>\n</blockquote>\n<p>We <em>do</em> have private impls, traits don't break encapsulation, and this was fixed three years ago.</p>",
        "id": 217056732,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644339
    },
    {
        "content": "<p>But you can't write <code>pub(self) impl ...</code>. That's all I'm taking that as.</p>",
        "id": 217056787,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644378
    },
    {
        "content": "<p>Sure. That's not at issue here, though. In the original RFC, the end-user is never writing anything where <code>pub(self) impl</code> would be useful. The compiler is.</p>",
        "id": 217056892,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644424
    },
    {
        "content": "<p>That doesn't make it any less weird or unidiomatic.</p>",
        "id": 217056920,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644446
    },
    {
        "content": "<p>My goal isn't to define the funnest API. It's to define an API that automatically exposes a sound and complete analysis of transmutation safety.</p>",
        "id": 217057025,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644505
    },
    {
        "content": "<p>And my (and presumably Josh's) goal is to expose that analysis in a way that fits with the rest of the language.</p>",
        "id": 217057140,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644550
    },
    {
        "content": "<p>Ultimately, \"weird\" is an aesthetic criticism. The mechanics that underlie the constructability-aware proposal are sound, and <em>already a part of the language</em>.</p>",
        "id": 217057166,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644568
    },
    {
        "content": "<p>Language design is deeply aesthetic.</p>",
        "id": 217057209,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644593
    },
    {
        "content": "<p>They're only part of the language if you are talking about the <code>Scope</code>/<code>Here!()</code> mechanism, which was rejected for purely \"aesthetic\" reasons.</p>",
        "id": 217057263,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644622
    },
    {
        "content": "<p>No, impl privacy is <em>already</em> a part of the language! <a href=\"https://github.com/rust-lang/rfcs/pull/2145#issuecomment-727232373\">https://github.com/rust-lang/rfcs/pull/2145#issuecomment-727232373</a></p>",
        "id": 217057394,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644670
    },
    {
        "content": "<p>(BTW, <code>Here!()</code> is <em>only</em> for ergonomics. The RFC works without it.)</p>",
        "id": 217057440,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644695
    },
    {
        "content": "<p>You can't make an impl private without a private type...</p>",
        "id": 217057493,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644723
    },
    {
        "content": "<p>I feel like you are really talking past me, I fully agree that impl privacy is part of the language in a technical sense.</p>",
        "id": 217057542,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644753
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217057493\">said</a>:</p>\n<blockquote>\n<p>You can't make an impl private without a private type...</p>\n</blockquote>\n<p>...which is why <code>Here!()</code> generates a private type.</p>",
        "id": 217057689,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217057542\">said</a>:</p>\n<blockquote>\n<p>I feel like you are really talking past me, I fully agree that impl privacy is part of the language in a technical sense.</p>\n</blockquote>\n<p>Then, to reiterate my earlier point:</p>\n<blockquote>\n<p>If the remaining concerns about it are primarily aesthetic, we should weigh those aesthetic cost against the expressive cost of the alternative.</p>\n</blockquote>",
        "id": 217057715,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644833
    },
    {
        "content": "<p>I'm not arguing that language design <em>isn't</em> aesthetic.</p>",
        "id": 217057732,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605644847
    },
    {
        "content": "<p>Is that (weighing the costs) not what we are already doing?</p>",
        "id": 217057779,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644869
    },
    {
        "content": "<p>The only reason I said anything at all was that it seemed Josh was suggesting that <em>directly</em> private impls might make the aesthetic cost less.</p>",
        "id": 217057853,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644896
    },
    {
        "content": "<p>And thus perhaps worth pursuing in the future.</p>",
        "id": 217057876,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644908
    },
    {
        "content": "<p>And that, in the meantime, the newtype pattern has a lesser aesthetic cost than the <code>Scope</code>/<code>Here!()</code> pattern.</p>",
        "id": 217057965,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644963
    },
    {
        "content": "<p>(To be clear- personally I agree with that as well, but it's not what I was trying to get at.)</p>",
        "id": 217058009,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605644982
    },
    {
        "content": "<p>Yeah, that wasn't my reading of Josh's comment about \"traits breaking encapsulation\"; I assumed he had technical questions.</p>",
        "id": 217058089,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605645007
    },
    {
        "content": "<p>I think all that means is \"if you just impl a trait on a public type with no other shenanigans, it is automatically public across the entire universe.\" Which feels a lot like \"breaking encapsulation\" even if it's technically fine and intentional.</p>",
        "id": 217058175,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605645052
    },
    {
        "content": "<p>And further, even if you implement it on a private type, that does not prevent external generic code from working with that private type, if passed the private type from within its module.</p>",
        "id": 217058253,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605645099
    },
    {
        "content": "<p>I think you and I are on the same page.</p>",
        "id": 217058336,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605645133
    },
    {
        "content": "<p>Which is a sense in which an actual, direct, <code>priv impl</code> might potentially want to differ from existing type privacy.</p>",
        "id": 217058357,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605645143
    },
    {
        "content": "<p>(And that feels like the direction Scott was pointing.)</p>",
        "id": 217058512,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605645241
    },
    {
        "content": "<p>It's very possible that the effects of a <code>priv impl</code> syntax might differ from type privacy. (Whether or not that's the case is totally speculationâ€”there are deep questions about how that syntax would integrate into the language.)</p>\n<p>However, in the case of safe transmutation, the semantics of type privacy match what we need. Type privacy enforces that impls are only usability if they are visible with respect to the reference point that the impl is being used in.</p>\n<p>Likewise, a transmutation is safe if the relevant fields of the involved type are visible with respect to the reference point the transmutation is occuring in. The constructability-aware version introduces a private type that encodes the reference point of the transmutationâ€”thus leveraging the existing mechanism of type privacy.</p>",
        "id": 217059400,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605645621
    },
    {
        "content": "<p>A <code>priv impl</code> syntax does <em>not</em> improve the ergonomics of a constructability-aware <code>TransmuteFrom</code>, because end users are never <em>implementing</em> <code>TransmuteFrom</code>. Implementations of this trait are generated on-the-fly by the compiler.</p>",
        "id": 217059503,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605645672
    },
    {
        "content": "<p>A <code>priv impl</code> syntax <em>does</em> improve the ergonomics of <code>Muckable</code>, but not the expressivity issues, nor does it eliminate the footgun imposed by a trait that indicates \"you can ignore field encapsulation for this type\".</p>",
        "id": 217059903,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605645845
    },
    {
        "content": "<p>Following up, because I wasn't around for much of the discussion of my original comment...</p>",
        "id": 217063630,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647637
    },
    {
        "content": "<p>Yes, I know that it's possible to use a newtype wrapper around a private type to hide impls.</p>",
        "id": 217063695,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647656
    },
    {
        "content": "<p>That doesn't mean \"the language has private impls\".</p>",
        "id": 217063707,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647661
    },
    {
        "content": "<p>Er, it's a technical term from the Type Privacy RFC. It's not just about newtypes.</p>",
        "id": 217063741,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605647677
    },
    {
        "content": "<p>It means \"it's possible to work around the shortcoming that you can't have private impls for a public type\".</p>",
        "id": 217063751,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647682
    },
    {
        "content": "<p>My original point was that I think it <em>should</em> be possible to have private impls for a public type, in the most straightforward way possible, without any kind of wrapper or private internal type.</p>",
        "id": 217063860,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647734
    },
    {
        "content": "<p>Ideally it'd be as simple as <code>pub(self) impl Trait for Type</code>.</p>",
        "id": 217063963,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647773
    },
    {
        "content": "<p>Gotcha! Yeah, that would be great! It's not quite helpful to <code>TransmuteFrom</code>, since end-users don't write impls of <code>TransmuteFrom</code>.</p>",
        "id": 217064008,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605647801
    },
    {
        "content": "<p>(<em>Ideally</em> we eventually require <code>pub impl Trait for Type</code> and make <code>impl Trait for Type</code> private, to avoid a special \"public by default\" case, but that's a much bigger transition.)</p>",
        "id": 217064026,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647811
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> It's helpful for safe transmute insofar as someone might want <code>pub(crate) impl Muckable for Type</code>, as in \"I can safe transmute to and from this type because I'm the crate that owns it, but I don't want other crates doing so\".</p>",
        "id": 217064093,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605647855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217064008\">said</a>:</p>\n<blockquote>\n<p>Gotcha! Yeah, that would be great! It's not quite helpful to <code>TransmuteFrom</code>, since end-users don't write impls of <code>TransmuteFrom</code>.</p>\n</blockquote>\n<p>I imagine having it implemented might put compiler-generated private impls on more solid ground, though.</p>",
        "id": 217064191,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605647890
    },
    {
        "content": "<p>Yep. That's an ergonomic improvement over wrapping your type's private innards in a newtype.</p>",
        "id": 217064195,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605647892
    },
    {
        "content": "<p>It doesn't improve the expressivity issues, though.</p>",
        "id": 217064374,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605647980
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> Suppose you have a crate that, today, has a public type with some (but not all) public fields, but for which you don't want to make all the guarantees of <code>Muckable</code>. You internally use unsafe transmute on that type to implement some things. You'd like to eliminate unsafe by using safe transmute. How would you go about doing that, without allowing code outside your crate to use <code>Muckable</code>? The \"newtype wrapper\" pattern doesn't work here, because parts of your type are public.</p>",
        "id": 217064863,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605648164
    },
    {
        "content": "<p>I stand corrected!</p>",
        "id": 217065016,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605648231
    },
    {
        "content": "<p>That wasn't an expressivity issue anyone had pointed out yet. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 217065093,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605648251
    },
    {
        "content": "<p>Depending on the compiler's guarantees or non-guarantees, would it be possible to do <code>struct InternalWrapper(PublicType); unsafe impl Muckable for InternalWrapper {}</code>?</p>",
        "id": 217065216,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605648329
    },
    {
        "content": "<p>And then if you want to safe-transmute, you wrap the type in InternalWrapper first?</p>",
        "id": 217065247,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605648358
    },
    {
        "content": "<p>Yes, if we lifted the requirement that types are recursively muckable (a la <code>Copy</code>), which is required to make <code>Muckable</code> safe.</p>",
        "id": 217065317,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605648382
    },
    {
        "content": "<p>Doesn't really solve the problem, in any case, since it wouldn't let you forbid unsafe in your crate.</p>",
        "id": 217065618,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605648560
    },
    {
        "content": "<p>So yeah, private impls seem necessary for full expressiveness. But safe transmute is still quite useful without that.</p>",
        "id": 217065688,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605648594
    },
    {
        "content": "<p>We don't need to wait on <code>priv impl</code> for full expressivity. The constructability-aware formulation of <code>TransmuteFrom</code> is safe, expressive, and completely automatic. It's not subject to the thorny design considerations of what, exactly, <code>Muckable</code> must denote, or the expressive and ergonomic limitations it imposes, because <code>Muckable</code> doesn't exist. It's not subject to the potential user error of when <code>Muckable</code> should be implemented, because the safety of the system doesn't depend on manual user intervention.</p>\n<p>The cost of this formulation is an extra type parameter. However, if somebody someday figures out a sound, <em>implicit</em> mechanism for scoped impls (as has been suggested here), that parameter can perhaps be defaulted.</p>",
        "id": 217066689,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605649102
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217066689\">said</a>:</p>\n<blockquote>\n<p>The cost of this formulation is an extra type parameter. However, if somebody someday figures out a sound, <em>implicit</em> mechanism for scoped impls (as has been suggested here), that parameter can perhaps be defaulted.</p>\n</blockquote>\n<p>The cost is more than an extra type parameter! It's a whole new design pattern that lifts the visibility system into the trait system, and then introduces and exploits a hole in that system.</p>",
        "id": 217069919,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605650799
    },
    {
        "content": "<p>What's the hole being introduced and exploited?</p>",
        "id": 217070109,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605650891
    },
    {
        "content": "<p><code>NeglectStability</code>. I have yet to see a private impl-based formulation that does not also introduce a way to bypass that privacy.</p>",
        "id": 217070382,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605651032
    },
    {
        "content": "<p><code>NeglectStability</code> is not essential to the original RFC. If that's your primary concern, consider it cut.</p>\n<p>We're also at the point where <code>Muckable</code> will cary no stability implications.</p>",
        "id": 217070675,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605651124
    },
    {
        "content": "<p>Am I misunderstanding the original RFC? I was under the impression that it relied on <code>NeglectStability</code> to address some use cases.</p>",
        "id": 217070803,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605651201
    },
    {
        "content": "<p>Including the archetype pattern</p>",
        "id": 217071045,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605651341
    },
    {
        "content": "<p>Er, sorry. It was used in the <em>original</em> RFC to accomodate the stability system. Then, that stability system was removed, and with it the need for <code>NeglectStability</code>.</p>\n<p>Then, that version of the RFC was replaced by one introducing <code>Muckable</code>, which carried both safety and stability implications. Then, we discovered that those stability implications were overly restrictive. I've yet to update the RFC, but the conversation that occured here yesterday points to <code>Muckable</code> <em>not</em> carrying any semver connotations.</p>\n<p>The current situation is thus this: we hope to provide a <code>TransmuteFrom</code> trait that soundly and completely tells you whether a transmutation is safe.</p>",
        "id": 217071322,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605651485
    },
    {
        "content": "<p>So: no more <code>NelectStability</code> and no more stability (at least for now).</p>",
        "id": 217071405,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605651538
    },
    {
        "content": "<p>If <code>Muckable</code> doesn't need to carry any semver connotations, then the case I mentioned may not be an issue.</p>",
        "id": 217073111,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605652675
    },
    {
        "content": "<p>What do you mean about \"an extra type parameter\"?</p>",
        "id": 217073173,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605652698
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217073173\">said</a>:</p>\n<blockquote>\n<p>What do you mean about \"an extra type parameter\"?</p>\n</blockquote>\n<p>An earlier version of the RFC used a <code>Scope</code> type parameter to emulate <code>pub(self) impl</code>- if you saw anything about <code>Here!()</code> that was what that was all about.</p>",
        "id": 217074721,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605653684
    },
    {
        "content": "<p>A type is safely <code>TransmuteFrom</code> another type if such a transmutation is well-defined (per their layouts) and the appropriate fields are visible. The question is: <em>visible from where</em>?</p>\n<p>If we formulate <code>TransmuteFrom</code> like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">     </span><span class=\"n\">Dst</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the reference frame from which we're considering the visibility of <code>Src</code> and <code>Dst</code>'s fields is unclear. We <em>mean</em> to use the scope of wherever we wrote that bound as our reference frame, but there's nothing here the compiler can use to sus that out. It does quite the opposite: it assumes that if it's proven <code>Dst: TransmuteFrom&lt;Src&gt;</code> once, it's proven it everywhere.</p>\n<p>So, we add an additional type parameter to <code>TransmuteFrom</code> that encodes this information:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">     </span><span class=\"n\">Dst</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...where <code>Scope</code> is a <em>private</em> type.</p>\n<p>To determine whether <code>Dst: TransmuteFrom&lt;Src, Scope&gt;</code>, the compiler both:</p>\n<ol>\n<li>confirms that the layout of <code>Src</code> is soundly transmutable into the layout of <code>Dst</code></li>\n<li>confirms that the appropriate fields of <code>Dst</code> (and sometimes <code>Src</code>) are visible from the defining scope of whatever concrete type is provided by <code>Scope</code>.</li>\n</ol>\n<p>The RFC suggests providing a <code>Here!()</code> macro that expands to a private type which uniquely identifies its invocation scopeâ€”so you don't need to go through the rigamarole of writing <code>struct Here;</code> whenever you transmute two concrete types.</p>\n<p>Type Privacy does the work of ensuring this mechanism is foolproof. You cannot \"leak\" a private type in a way that would provide access to the private impl of <code>TransmuteFrom</code>.</p>",
        "id": 217074790,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605653737
    },
    {
        "content": "<p>So at this point I've seen at least three different workarounds for a lack of <code>pub(self) impl</code>- there's the newtype approach you mentioned above (<code>struct InternalWrapper(PublicType);</code>), another newtype approach suggested by boats in the RFC thread (<code>struct PublicType(InternalTypeImplementingMuckable);</code>), and the <code>Scope</code>/<code>Here!()</code> approach.</p>",
        "id": 217074896,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605653798
    },
    {
        "content": "<p><code>Scope</code>+<code>Here!()</code> isn't a workaround for <code>pub(self) impl</code>, since end-users aren't writing impls of <code>TransmuteFrom</code>.</p>",
        "id": 217074979,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605653865
    },
    {
        "content": "<p>I mean, it kind of is- it's a way to control which scopes <code>TransmuteFrom</code> works in, no?</p>",
        "id": 217075066,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605653912
    },
    {
        "content": "<p>Doesn't really matter who would be writing (or generating) the <code>impl</code> block, the point is how the client determines if it's allowed to use that impl.</p>",
        "id": 217075127,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605653949
    },
    {
        "content": "<p>Gotchya. Yes, in that sense it's perhaps related. Whether it's a <em>replacement</em> will depend on the whatever shape that RFC ultimately takes. My hunch is that a \"hidden impls\" RFC will make some crucial compromises.</p>",
        "id": 217075693,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605654303
    },
    {
        "content": "<p>Indeed- personally I would rather avoid hidden impls entirely, and rely on the <code>struct PublicNewtype(PrivateTransmutable)</code> pattern, since a) that's already in active use in the ecosystem and b) there seems to be a clearer path forward toward cleaning up some of its associated boilerplate (\"delegation\").</p>",
        "id": 217075966,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605654499
    },
    {
        "content": "<p>The compiler could generate <code>TransmuteFrom</code> impls without any regard for scope, but only in response to a user request, and then the existing visibility of the impl type would control the visibility of those impls.</p>",
        "id": 217076077,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605654586
    },
    {
        "content": "<p>I think we've mostly settled the design point that don't want type authors to have to opt-in for a third party to pose questions about the well-definedness (and <em>hopefully</em> safety) of transmuting that type from/to another type.</p>",
        "id": 217076234,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605654711
    },
    {
        "content": "<p>Eh? Type authors need to opt in or else we're throwing visibility (and thus semver/stability) out the window. Or am I misunderstanding?</p>",
        "id": 217076421,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605654847
    },
    {
        "content": "<p>We're throwing semver stability out the window.</p>",
        "id": 217076435,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605654859
    },
    {
        "content": "<p>Sounds bad :P</p>",
        "id": 217076442,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605654866
    },
    {
        "content": "<p>The trait might very well be called <code>UnstableTransmuteFrom</code>.</p>",
        "id": 217076464,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605654881
    },
    {
        "content": "<p>That's the whole thing I've been complaining about with <code>NeglectStability</code>.</p>",
        "id": 217076465,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605654881
    },
    {
        "content": "<p>Flips the entire trait system on its head- if types start implementing internals-exposing traits without their authors' opt in, <em>even</em> if that trait is \"wait please don't use this except in ways documented by the author,\" then we're opening a big can of worms. :/</p>",
        "id": 217076635,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605654983
    },
    {
        "content": "<p>Yep. This would be be <strong>loudly</strong> documented.</p>",
        "id": 217076681,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605655017
    },
    {
        "content": "<p>I don't feel like any amount of documentation would be sufficient here. :P</p>",
        "id": 217076800,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605655097
    },
    {
        "content": "<p>This was the whole reason boats brought up the newtype pattern to begin with- it preserves the visibility system without using any new patterns or language features.</p>",
        "id": 217076891,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605655175
    },
    {
        "content": "<p>We don't see a way to define a one-size-fits-all stability system. The kinds of layout stability guarantees that matter vary <em>wildly</em> between use-cases.</p>",
        "id": 217076905,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605655185
    },
    {
        "content": "<p>From where I stand, the problem is the whole idea of a \"stability system\" beyond what the language already offers and is already used.</p>",
        "id": 217076995,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605655221
    },
    {
        "content": "<p>I liked the idea of the archetype pattern- that seemed to address the layout stability guarantees simply by reusing the set of things already considered (un)stable about <code>#[repr(C)]</code> types.</p>",
        "id": 217077097,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605655293
    },
    {
        "content": "<p>But you may be right- and if it comes down to it, at the end of the day, I would prefer a vastly smaller \"safe transmute\" feature that preserves visibility, to a more flexible one that breaks it.</p>",
        "id": 217077190,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605655336
    },
    {
        "content": "<p>So, a couple of things...</p>",
        "id": 217077238,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655374
    },
    {
        "content": "<p>First, the second type parameter and <code>Here!()</code> was a substantial point of concern in the lang team about the previous version of the proposal, and everyone strongly prefers the new simpler version.</p>",
        "id": 217077288,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655407
    },
    {
        "content": "<p>Going back to that version doesn't seem like an advancement.</p>",
        "id": 217077319,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655430
    },
    {
        "content": "<p>Second, I don't think this kind of opt-in seems like a problem.</p>",
        "id": 217077395,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655465
    },
    {
        "content": "<p>Naming and related bikeshedding aside, the idea of <code>impl Muckable for Type</code> to opt into being able to safe-transmute seems great. And if people want to hide that inside their crate, they can either use the newtype-wrapper pattern with a private type, or wait for private impls.</p>",
        "id": 217077443,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655504
    },
    {
        "content": "<p>We should clearly document what you're promising with a public impl of <code>Muckable</code>, but that's still reasonable.</p>",
        "id": 217077468,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655533
    },
    {
        "content": "<p>To clarify: I'm assuming that <code>Muckable</code> would be a necessary but not sufficient condition for <code>TransmuteFrom</code>, and the compiler-generated stuff would do the actual handling of \"are these two types compatible\".</p>",
        "id": 217077548,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655587
    },
    {
        "content": "<p><code>Muckable</code> would be the opt-in for \"I don't mind having my type synthesized out of a transmute\".</p>",
        "id": 217077560,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605655601
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>  Just to confirm that we're on the same page.</p>\n<p>These are the shortcomings that <code>Muckable</code> and the constructability-aware version share:</p>\n<ul>\n<li><code>TransmuteFrom</code> is SemVer unstable</li>\n</ul>\n<p>These are the additional shortcomings of the <code>Muckable</code> approach:</p>\n<ul>\n<li>The safety of the system depends on the user's judgement of when to implement <code>Muckable</code> or not. A user must now reason about the visibility of their type, the visibility of its fields, <em>and</em> the appropriateness of implementing <code>Muckable</code>. Getting any of these wrong can lead to unsafety.</li>\n<li><code>Muckable</code> is <em>also</em> not subject to SemVer guarantees.</li>\n<li>To make a type with private fields privately safely transmutable, you need newtype its innards. This constitutes a significant refactoring of modules that are likely to <em>already</em> have unsafe code.</li>\n<li><code>Muckable</code> is all-or-nothing, and thus is inapplicable for transmutations of partially constructible types.</li>\n<li>All cases in which <code>Muckable</code> is insufficient reflects a case where we cannot provide safe transmute.</li>\n</ul>",
        "id": 217078443,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605656315
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217078443\">said</a>:</p>\n<blockquote>\n<ul>\n<li><code>Muckable</code> is <em>also</em> not subject to SemVer guarantees.</li>\n</ul>\n</blockquote>\n<p>Why not? If you implement <code>Muckable</code>, you are marking transmutes as public (if the type is public), and thus changes that could break transmuting clients need a major version bump. That's how trait impls work, <em>including</em> auto traits.</p>",
        "id": 217078869,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605656660
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217078443\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span>  Just to confirm that we're on the same page about the shortcomings of this approach compared to the constructability-aware version:</p>\n<ul>\n<li>The safety of the system depends on the user's judgement of when to implement <code>Muckable</code> or not. A user must now reason about the visibility of their type, the visibility of its fields, <em>and</em> the appropriateness of implementing <code>Muckable</code>. Getting any of these wrong can lead to unsafety.</li>\n</ul>\n</blockquote>\n<p>True. You should not publicly implement Muckable on a type for which you'd hesitate to make all fields public, for instance.</p>\n<blockquote>\n<ul>\n<li><code>Muckable</code> is <em>also</em> not subject to SemVer guarantees.</li>\n</ul>\n</blockquote>\n<p>What do you mean by this? We can't <em>guarantee</em> semver compatibility; that's up to the crate. Crates can also delete fields or functions and bump only the patch version, but they shouldn't. The crate needs to take semver into account when choosing whether to impl <code>Muckable</code> for a type.</p>\n<blockquote>\n<ul>\n<li>To make a type with private fields privately safely transmutable, you need newtype its innards. This constitutes a significant refactoring of modules that are likely to <em>already</em> have unsafe code.</li>\n</ul>\n</blockquote>\n<p>True, though we could fix that if Rust supported <code>pub(self) impl</code>.</p>\n<blockquote>\n<ul>\n<li><code>Muckable</code> is all-or-nothing, and thus is inapplicable for transmutations of partially constructible types.</li>\n</ul>\n</blockquote>\n<p>Are you referring to the case of a public prefix you want to extract/construct?</p>\n<blockquote>\n<ul>\n<li>All cases in which <code>Muckable</code> is insufficient reflects a case where we cannot provide safe transmute.</li>\n</ul>\n</blockquote>\n<p>For now. We could extend the mechanism in the future to handle other cases.</p>",
        "id": 217079011,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605656799
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span>, do you foresee that implementing <code>Muckable</code> implies that if <code>Dst: TransmuteFrom&lt;Src&gt;</code> holds in some set of crate versions, that it should also hold in subsequent minor releases of the involved crates?</p>",
        "id": 217079167,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605656961
    },
    {
        "content": "<p>I believe so, yes.</p>",
        "id": 217079390,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657170
    },
    {
        "content": "<p>My biggest concern of all the ones you raised above is the \"partially constructable\" case.</p>",
        "id": 217079437,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657232
    },
    {
        "content": "<p>Then implementing <code>Muckable</code> doesn't <em>only</em> mean that you deem your type safely constructible via transmute, it <em>also</em> means that you promise to treat most changes to its layout as a breaking change.</p>",
        "id": 217079439,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605657235
    },
    {
        "content": "<p>That seems like an extremely fair price to pay for transmuting it, IMO</p>",
        "id": 217079500,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605657265
    },
    {
        "content": "<p>True. Alternatively, if you don't want that, you could privately implement <code>Muckable</code>and then publicly expose a limited set of operations powered by safe transmute.</p>",
        "id": 217079518,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657291
    },
    {
        "content": "<p>For instance, you might wish to support transmuting to bytes, but not transmuting <em>from</em> bytes without a validation step.</p>",
        "id": 217079555,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657319
    },
    {
        "content": "<p>You might still handle that by using safe transmute internally, but then checking the fields before returning the type.</p>",
        "id": 217079647,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657369
    },
    {
        "content": "<p>I <em>absolutely</em> believe that this will not solve every single case where people want safe transmute, and I believe we'll want to provide more capabilities in the future, but I think it'll solve many problems for many people.</p>",
        "id": 217079682,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657413
    },
    {
        "content": "<p><code>Muckable</code> is a prohibitive stability promise for this sort of type:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">i32</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The type's author may <em>currently</em> add fields to this type without incrementing major versions. They could not if they implemented <code>Muckable</code>.</p>",
        "id": 217079683,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605657414
    },
    {
        "content": "<p>We might choose to lint against <code>impl Muckable</code> for a type with <code>#[non_exhaustive]</code>. I'd also love to see a solution for the case of structs with public prefixes, or variable sizes.</p>",
        "id": 217079795,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657497
    },
    {
        "content": "<p>For that matter...</p>",
        "id": 217079799,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657501
    },
    {
        "content": "<p>Hypothetically, suppose we had <code>MuckableFrom</code> (you can turn this into things) and <code>MuckableTo</code> (you can turn things into this).</p>",
        "id": 217079815,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657526
    },
    {
        "content": "<p>The former wouldn't prevent you from adding fields at the end, only the latter would, right?</p>",
        "id": 217079836,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657544
    },
    {
        "content": "<p><del><code>MuckableFrom</code> does prevent you from adding fields. If you increase the size of the type, you set a lower bound on the size of types it can be transmuted from.</del></p>",
        "id": 217080037,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605657657
    },
    {
        "content": "<p>Oh gotcha</p>",
        "id": 217080050,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605657666
    },
    {
        "content": "<p>These names don't quite match up with the direction I'd expect.</p>",
        "id": 217080065,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605657679
    },
    {
        "content": "<p>Fair point; not looking to bikeshed.</p>",
        "id": 217080068,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657686
    },
    {
        "content": "<p>The descriptions are the key here: if you can turn the type into things, but you can't turn things into the type, you can add fields all you like.</p>",
        "id": 217080085,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657705
    },
    {
        "content": "<p>Given:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">S</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">i32</span> <span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">TurnThisIntoThings</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Type</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>You could safe-transmute S into an <code>i32</code>.</p>",
        "id": 217080187,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657780
    },
    {
        "content": "<p>(grumble grumble <code>#[repr(C)]</code> handwave)</p>",
        "id": 217080231,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657814
    },
    {
        "content": "<p>I think this is an improvement.</p>",
        "id": 217080238,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605657823
    },
    {
        "content": "<p>I think many more people would be willing to opt their types into <code>TurnThisIntoThings</code>.</p>",
        "id": 217080315,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657867
    },
    {
        "content": "<p>That only guarantees you won't change the public prefix of the type incompatibly.</p>",
        "id": 217080325,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657878
    },
    {
        "content": "<p>And then types <em>designed</em> for byte-based deserialization will opt into <code>TurnThingsIntoThis</code>.</p>",
        "id": 217080360,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657916
    },
    {
        "content": "<p>It's a better stability system than an omnibus <code>Muckable</code>. (but it's still a system that rules out use-cases)</p>",
        "id": 217080404,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605657957
    },
    {
        "content": "<p>It certainly doesn't allow everything; I understand that.</p>",
        "id": 217080461,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657979
    },
    {
        "content": "<p>I think it'll be easier for people to wrap their heads around.</p>",
        "id": 217080476,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605657990
    },
    {
        "content": "<p>And I <em>think</em> it could be extended in the future.</p>",
        "id": 217080490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658002
    },
    {
        "content": "<p>So: you can't make changes that would break whether <code>TransmuteFrom</code> is satisfied or not. Are you allowed to re-order fields?</p>",
        "id": 217080492,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605658005
    },
    {
        "content": "<p>I would expect the answer to that question to be a bit domain-specific- the same way as whether changing the return value of a function is considered breaking.</p>",
        "id": 217080541,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605658043
    },
    {
        "content": "<p>Yep. Nonetheless, we have to answer it.</p>",
        "id": 217080549,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605658060
    },
    {
        "content": "<p>We <em>haven't</em> answered the equivalent question about function return values, though.</p>",
        "id": 217080564,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605658078
    },
    {
        "content": "<p>We do so on a function-by-function basis. Here, we have a trait and we need to settle what its contract is.</p>",
        "id": 217080641,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605658130
    },
    {
        "content": "<p>We can describe the general case. Crates may occasionally document exceptions, and that's up to those crates. I've seen crates do things like \"the internal functions called by this macro are public because they have to be, but we make no guarantees and may change those at any time\". That's <em>technically</em> a semver violation, but that's up to the crate.</p>",
        "id": 217080651,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658142
    },
    {
        "content": "<p>It seems a bit more pressing in this case, since a <code>TransmuteFrom</code> trait is naturally going to lead to people building abstractions over safe transmutation.</p>",
        "id": 217080684,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605658189
    },
    {
        "content": "<p>There's a kind of syntax-vs-semantics distinction here, where you can't change what you can transmute to, but it may be domain-specific if you're allowed to interpret the resulting bytes.</p>",
        "id": 217080766,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658224
    },
    {
        "content": "<p>For instance, you can't change <code>struct S { x: i64, y: i64, z: i16 }</code> to <code>struct S { x: i64, z: i16, y: i64 }</code>.</p>",
        "id": 217080838,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658290
    },
    {
        "content": "<p>But you <em>might</em> be able to get away with changing <code>struct S { x: i64, y: i64, z: i16 }</code> to <code>struct S { y: i64, x: i64, z: i16 }</code> depending on the nature of the struct.</p>",
        "id": 217080924,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658336
    },
    {
        "content": "<p>You can't do that if you implement <code>TurnThingsIntoThis</code>.</p>",
        "id": 217080951,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658363
    },
    {
        "content": "<p>(Assume all fields are <code>pub</code> in the above. Or for that matter, assume x and y are pub and z isn't; that would also produce a different valid example.)</p>",
        "id": 217080970,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658383
    },
    {
        "content": "<p>The question is whether it's reasonable, given <code>TurnThisIntoThings</code>, to make certain assumptions about the bytes you get out.</p>",
        "id": 217081081,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658463
    },
    {
        "content": "<p>I'd say in <em>most</em> cases, no, you can't reorder the fields.</p>",
        "id": 217081096,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658480
    },
    {
        "content": "<p>To be a little more concrete...</p>",
        "id": 217081182,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658554
    },
    {
        "content": "<p>Suppose you had something like <code>FirmwareStructure { header: Header, various: [SomeUnion; 8] }</code> (ignore variable-lengths for a moment for the sake of argument).</p>",
        "id": 217081288,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658612
    },
    {
        "content": "<p>Assume all the structures involved can be safely transmuted to bytes.</p>",
        "id": 217081314,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658645
    },
    {
        "content": "<p>A piece of code might come to rely upon, for instance, that in practice the thing constructing that type always has the <code>various</code> in a specific order; for instance, it always puts <code>SomeUnion { console_info: ... }</code> first, before any <code>SomeUnion { serial_number_info: ... }</code>.</p>",
        "id": 217081434,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658730
    },
    {
        "content": "<p>That's not a reasonable assumption, and it might even be documented that you shouldn't do that.</p>",
        "id": 217081446,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658742
    },
    {
        "content": "<p>If you change that by generating <code>various</code> in a different, you may break people relying on your code.</p>",
        "id": 217081475,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658762
    },
    {
        "content": "<p>That might or might not be a semver violation, depending on your documentation and what was reasonable to assume.</p>",
        "id": 217081504,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658785
    },
    {
        "content": "<p>That's all domain-specific.</p>",
        "id": 217081585,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658828
    },
    {
        "content": "<p>The only guarantee is \"things you could transmute to before, you can still transmute to\".</p>",
        "id": 217081606,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658848
    },
    {
        "content": "<p>You could even have that problem <em>today</em> if you provided a <code>pub to_bytes(s: &amp;FirmwareStructure) -&gt; &amp;[u8]</code>.</p>",
        "id": 217081654,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605658889
    },
    {
        "content": "<p>Summarizing: I think we should document that publicly implementing <code>TurnThisIntoThings</code> means you must not change the struct in ways that would prevent it from being transmuted into anything it could be transmuted into before, you should not in general change the offset of any public field, and you may or may not have additional semantic guarantees depending on what your callers expect to be able to assume about the data they get out.</p>",
        "id": 217081899,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605659064
    },
    {
        "content": "<p>(I'll have to first do some thinking about how <code>Muckable{From,Into}</code> interacts with generics, but I'll definitely come back to this.)</p>\n<p><strong>Separately:</strong> <code>#[repr(C)]</code> is a bit of an extreme in terms of language-level layout well-definedness and stability. We could imagine a repr that guarantees the same layout of a type for the same build, or for different builds within the same compiler version. (E.g., perhaps field order is the aspect that is defined to be unstable.) If <code>Dst: TransmuteFrom&lt;Src&gt;</code> is intended to behave semver-stably, I don't see how it could be used to judge the safety/stability of such transmutations.</p>",
        "id": 217081969,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605659130
    },
    {
        "content": "<p>If <code>Muckable</code> is really only compatible with <code>#[repr(C)]</code>'s language-level guarantees, <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20semver.20hazard/near/216747469\">we're back at this point in the discussion</a>. We'd need to proactively forbid implementations of <code>Muckable</code> for types that aren't recursively <code>repr(C)</code>, <code>repr(transparent)</code>, or the primitive repr.</p>",
        "id": 217153722,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605714902
    },
    {
        "content": "<p>I personally would be very open to making guarantees about <code>repr(Rust)</code>, at least regarding its compatibility with similar types.</p>",
        "id": 217161562,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605717656
    },
    {
        "content": "<p>For instance, I think <code>struct S(i32, i32)</code> and <code>(i32, i32)</code> and <code>struct S2(i32, i32)</code> and <code>struct S3 { x: i32, y: i32 }</code> ought to be guaranteed compatible.</p>",
        "id": 217161662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605717699
    },
    {
        "content": "<p><em>if</em> you impl <code>Muckable</code> for them.</p>",
        "id": 217161776,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605717730
    },
    {
        "content": "<p>If, in the future, we offered some kind of struct reordering (beyond what we currently do to fill holes if you put fields in a suboptimal order for their sizes), we could potentially say \"we don't do this on types that impl <code>Muckable</code>\", or we could make it opt-in via an attribute, or similar.</p>",
        "id": 217161987,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605717814
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217153722\">said</a>:</p>\n<blockquote>\n<p>We'd need to proactively forbid implementations of <code>Muckable</code> for types that aren't recursively <code>repr(C)</code>, <code>repr(transparent)</code>, or the primitive repr.</p>\n</blockquote>\n<p>Would it alternatively be possible to allow those impls but then not generate <code>TransmuteFrom</code> impls involving those types? Essentially \"pretend\" that types that aren't <code>repr(C)</code>/etc. all have unique layouts.</p>",
        "id": 217164236,
        "sender_full_name": "rpjohnst",
        "timestamp": 1605718689
    },
    {
        "content": "<p>Is it possible to allow only recursively <code>#[repr(C)]</code> types for now while leaving the opening for more types to impl <code>Muckable</code> in the future? It seems trivial to reject any types that aren't recursively <code>#[repr(C)]</code>.</p>",
        "id": 217164664,
        "sender_full_name": "rylev",
        "timestamp": 1605718872
    },
    {
        "content": "<p>We could also (for now) ban structs with generic type parameters. This might be heavy handed but it's not something that's needed for a lot of use cases.</p>",
        "id": 217164857,
        "sender_full_name": "rylev",
        "timestamp": 1605718939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217164236\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217153722\">said</a>:</p>\n<blockquote>\n<p>We'd need to proactively forbid implementations of <code>Muckable</code> for types that aren't recursively <code>repr(C)</code>, <code>repr(transparent)</code>, or the primitive repr.</p>\n</blockquote>\n<p>Would it alternatively be possible to allow those impls but then not generate <code>TransmuteFrom</code> impls involving those types? Essentially \"pretend\" that types that aren't <code>repr(C)</code>/etc. all have unique layouts.</p>\n</blockquote>\n<p>Yes, although that rules out a class of safe transmutations for those types.</p>",
        "id": 217180365,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605725846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224872\">Ryan Levick</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217164857\">said</a>:</p>\n<blockquote>\n<p>We could also (for now) ban structs with generic type parameters. This might be heavy handed but it's not something that's needed for a lot of use cases.</p>\n</blockquote>\n<p>Unfortunately, a lot of the use-cases I'm most interested in would be ruled out by that. :(</p>",
        "id": 217182275,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605726662
    },
    {
        "content": "<p>There's a middle-ground where we can provide <em>both</em> the fully-fledged compiler analysis of transmutation safety, <em>and</em> the less-weird-but-less-expressive <code>Muckable{From,Into}</code>-based system.</p>\n<p>Given <code>UnstableTransmuteFrom</code>, the <code>Muckable{From,Into}</code>-based <code>TransmuteFrom</code> is just this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Src</span>: <span class=\"nc\">MuckableInto</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">MuckableFrom</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">UnstableTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NeglectConstructability</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(And we can imagine <em>other</em> SemVer stable facades over <code>UnstableTransmuteFrom</code> that are appropriate for these other niche use-cases we've considered.)</p>",
        "id": 217182958,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605726963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217080315\">said</a>:</p>\n<blockquote>\n<p>I think many more people would be willing to opt their types into <code>TurnThisIntoThings</code>.</p>\n</blockquote>\n<p>This is the direction my brain was thinking too.  It also helps this:</p>\n<blockquote>\n<p>The type's author may currently add fields to this type without incrementing major versions. They could not if they implemented Muckable.</p>\n</blockquote>\n<p>Because if that's <code>MuckableInto</code> then you can add things at the end (which matches well with the kinds of things C often allows for) and still allow the thing to be transmuted to the same prefixes as worked before.</p>",
        "id": 217186111,
        "sender_full_name": "scottmcm",
        "timestamp": 1605728373
    },
    {
        "content": "<p>Yeah, as far as I can tell, it's a strict improvement over just having <code>Muckable</code>.</p>",
        "id": 217186263,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605728433
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217161776\">said</a>:</p>\n<blockquote>\n<p><em>if</em> you impl <code>Muckable</code> for them.</p>\n</blockquote>\n<p>Depending on whether the type impled Muckable for that seems odd to me.</p>\n<p>I'd expect either \"use <code>repr(linear)</code> to get that\" or \"<code>repr(rust)</code> for a type where all the fields are the same type (maybe the same layout) is defined as <code>repr(linear)</code>\".</p>",
        "id": 217186531,
        "sender_full_name": "scottmcm",
        "timestamp": 1605728545
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217186263\">said</a>:</p>\n<blockquote>\n<p>Yeah, as far as I can tell, it's a strict improvement over just having <code>Muckable</code>.</p>\n</blockquote>\n<p>And I think we keep rediscovering some form of the split, which gives me extra confidence in it.  It's similar, in a way, to the very old conversations about \"has no padding\" vs \"all bit patterns are valid\", which are roughly directionally the same.</p>",
        "id": 217186784,
        "sender_full_name": "scottmcm",
        "timestamp": 1605728650
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217186531\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217161776\">said</a>:</p>\n<blockquote>\n<p><em>if</em> you impl <code>Muckable</code> for them.</p>\n</blockquote>\n<p>Depending on whether the type impled Muckable for that seems odd to me.</p>\n<p>I'd expect either \"use <code>repr(linear)</code> to get that\" or \"<code>repr(rust)</code> for a type where all the fields are the same type (maybe the same layout) is defined as <code>repr(linear)</code>\".</p>\n</blockquote>\n<p>Question for clarification: by \"all the fields are the same type\", do you mean \"two structures have fields of the same size/layout at the same offsets\"? (Many of the examples above used <code>i32</code> everywhere, so I wanted to make sure you weren't attaching significance to the fact that all the fields in the <em>same</em> structure have the same type.)</p>",
        "id": 217187043,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605728785
    },
    {
        "content": "<p>I feel like <code>repr(linear)</code> has a \"fencepost security\" problem: it's talking in terms of things we <em>won't</em> do rather than in terms of things we <em>might</em> do. Field order is only one of the things we might conceivably modify with a <code>repr(Rust)</code> type.</p>",
        "id": 217187137,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605728838
    },
    {
        "content": "<p>As another example, with a <code>repr(Rust)</code> type, I'd love to be able to say \"<em>every</em> instance of this type assigns the same value to this field, and nothing modifies this field, so let's not store the field at all, and just treat accesses to it as returning the constant value we know it'll have\".</p>",
        "id": 217187296,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605728908
    },
    {
        "content": "<p>I was specifically referring to the fields in the same struct having the same layout, yes.  Because IIRC there has been a bunch of desire in the unsafe code WG to _not_ do the \"repr(rust) is the same layout for the same fields between different types\".</p>",
        "id": 217187322,
        "sender_full_name": "scottmcm",
        "timestamp": 1605728925
    },
    {
        "content": "<p>Interesting.</p>",
        "id": 217187490,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729005
    },
    {
        "content": "<p>I feel like that \"every instance of this type sets this field to the same value\" is a counter-example to the \"different types with the same fields have the same layout\" thing from earlier, for example.</p>",
        "id": 217187545,
        "sender_full_name": "scottmcm",
        "timestamp": 1605729044
    },
    {
        "content": "<p>You're suggesting we might <em>not</em> want to allow transmute between (non-repr(C)) <code>struct S(i64, i32)</code> and <code>(i64, i32)</code> and <code>struct S2 { f1: i64, f2: i32 }</code>?</p>",
        "id": 217187553,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729051
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217182958\">said</a>:</p>\n<blockquote>\n<p>There's a middle-ground where we can provide <em>both</em> the fully-fledged compiler analysis of transmutation safety, <em>and</em> the less-weird-but-less-expressive <code>Muckable{From,Into}</code>-based system.</p>\n<p>Given <code>UnstableTransmuteFrom</code>, the <code>Muckable{From,Into}</code>-based <code>TransmuteFrom</code> is just this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Src</span>: <span class=\"nc\">MuckableInto</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">MuckableFrom</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">UnstableTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">!</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NeglectConstructability</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(And we can imagine <em>other</em> SemVer stable facades over <code>UnstableTransmuteFrom</code> that are appropriate for these other niche use-cases we've considered.)</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span>, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Would there be any appetite from the lang team of pursuing this dual approach? It would allow us to cover <code>repr(C)</code> types with rigidish semver stability requirements very well via <code>TransmuteFrom</code>, but <em>also</em> provide raw access to a more general and powerful automatic analysis of transmutation safety.</p>",
        "id": 217187605,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605729085
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217187545\">said</a>:</p>\n<blockquote>\n<p>I feel like that \"every instance of this type sets this field to the same value\" is a counter-example to the \"different types with the same fields have the same layout\" thing from earlier, for example.</p>\n</blockquote>\n<p>I'm not suggesting it isn't, and it's a good reason why <code>repr(Rust)</code> might not want to allow that, but I'm asking if <code>repr(linear)</code> is the right concept and name to cover not just reordering but \"let's omit this field entirely\" or other such ideas.</p>",
        "id": 217187651,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729110
    },
    {
        "content": "<p>Personally I'm not sure, but I recall a bunch of people explicitly wanting to have a compiler flag for layout randomization that would make those transmutes definitely not ok.</p>\n<p>(Like weak-ASLR, but for fields.)</p>",
        "id": 217187664,
        "sender_full_name": "scottmcm",
        "timestamp": 1605729116
    },
    {
        "content": "<p>Yeah, I don't know that <code>repr(linear)</code> is actually the right answer.  I guess for the case I mentioned it'd be more like <code>repr(array)</code>, which would be more clearly defined (and restricted in applicability, like <code>repr(transparent)</code> is).</p>",
        "id": 217187851,
        "sender_full_name": "scottmcm",
        "timestamp": 1605729199
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span><br>\n1) I think that would depend <em>heavily</em> on the details of <code>UnstableTransmuteFrom</code>'s second and third generic arguments.<br>\n2) Just from reading that, I <em>really</em> don't think we should use <code>Into</code> and <code>From</code> in these names, because I'm having to think about them three or four times to get even a little confidence in which direction they mean.</p>",
        "id": 217187893,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729226
    },
    {
        "content": "<p>At least <code>From</code> and <code>Into</code> in bounds are usually written like <code>SomeType: From&lt;SomeOtherType&gt;</code> or <code>SomeOtherType: Into&lt;SomeType&gt;</code>, which have the advantage that if you read them in the most natural way you have the semantics right.</p>",
        "id": 217188036,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729291
    },
    {
        "content": "<p><code>MuckableFrom</code> and <code>MuckableInto</code> feel very strange to me, partly because there's no \"x from y\" or \"x into y\".</p>",
        "id": 217188078,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729316
    },
    {
        "content": "<p>Something more like <code>ToBytes</code> or <code>FromBytes</code>, or some other name that makes the direction <em>obvious</em> from a casual reading, would help keep them straight.</p>",
        "id": 217188197,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729375
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> Given that one of the goals is allowing transmuting to prefixes, I'm definitely in favour of the dual approach.  I've always considered it basically necessary for common newtype patterns, too -- <code>struct Even(i32);</code> feels like it's only ever safe-transmute in one of the directions.</p>\n<p>Like Josh, though, I'm not sure I follow exactly what <code>UnstableTransmuteFrom</code>'s details are.  If it's unstable, though -- maybe just initially, I don't know -- I might not have to, though.</p>",
        "id": 217188444,
        "sender_full_name": "scottmcm",
        "timestamp": 1605729484
    },
    {
        "content": "<p>I'm also wondering how easy it would be to write (and write the type signature for) something like this:<br>\n<code>impl ValidatedTransmuteFrom&lt;Src&gt; for Dst where Src: (bikeshedded name), Dst: Validate, Dst: SomethingAboutLayoutCompatibilityOnly&lt;Src&gt;</code>.</p>",
        "id": 217188815,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729655
    },
    {
        "content": "<p>Where <code>Validate</code> is a trait with a function that takes a <code>&amp;Dst</code> that might not meet the requirements of <code>Dst</code> and confirm that it meets the requirements of <code>Dst</code> or returns an error.</p>",
        "id": 217189062,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729776
    },
    {
        "content": "<p>Something like that would allow <code>&amp;str: ValidatedTransmuteFrom&lt;&amp;[u8]&gt;</code> or <code>NonZeroU32: ValidatedTransmuteFrom&lt;u32&gt;</code>.</p>",
        "id": 217189302,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729874
    },
    {
        "content": "<p>The compiler's generated traits would handle questions of layout compatibility, and <code>Validate</code> would <em>only</em> have to check type-specific invariants.</p>",
        "id": 217189387,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605729920
    },
    {
        "content": "<p>Hmm, how much is the \"transmuteness\" essential in situations doing validation?  Vs just using safe-transmute-on-inner-private-type in a <code>TryFrom</code> impl?</p>",
        "id": 217189430,
        "sender_full_name": "scottmcm",
        "timestamp": 1605729946
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> The difference is that you usually have to write <em>specific</em> <code>TryFrom</code> impls for particular types you want to support.</p>",
        "id": 217189589,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730013
    },
    {
        "content": "<p>As opposed to an impl saying \"anything you can transmute to me I'm happy to validate\".</p>",
        "id": 217189621,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730025
    },
    {
        "content": "<p>That does suggest a better name, though: this is <code>TryTransmuteFrom</code>.</p>",
        "id": 217189674,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/.60Muckable.60.20Shortcomings/near/217189621\">said</a>:</p>\n<blockquote>\n<p>As opposed to an impl saying \"anything you can transmute to me I'm happy to validate\".</p>\n</blockquote>\n<p>Ah, that's the part I'd missed.  Interesting.</p>",
        "id": 217189701,
        "sender_full_name": "scottmcm",
        "timestamp": 1605730070
    },
    {
        "content": "<p>Thinking again, though, I'm not sure mixing the two into the same API is the right path.  Transmuting to the archetype and then using a validation API might be ok.  Like you could <code>str::from_utf8(foo.transmute_into())</code>.</p>",
        "id": 217190005,
        "sender_full_name": "scottmcm",
        "timestamp": 1605730205
    }
]