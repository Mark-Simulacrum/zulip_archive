[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span>, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> </p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">   </span><span class=\"n\">Dst</span>: <span class=\"nc\">UnstableTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Options</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Where:</p>\n<p>* <code>Src</code> is the source type<br>\n  * <code>Dst</code> is the destination type<br>\n  * <code>Scope</code> is a private type whose definition site is the reference point from which the visibility of <code>Src</code>'s and <code>Dst</code>'s fields is assessed.<br>\n  * <code>Options</code> is a single or tuple combination of <code>TransmuteOptions</code></p>\n<p>A <code>TransmuteOption</code> is one of the following void types:</p>\n<p>* <code>NelectAlignment</code><br>\n  * <code>NeglectValidity</code><br>\n  * <code>NeglectVisibility</code> (bikeshed name?)</p>\n<p>...or a tuple combination of the above (including the empty set of options <code>()</code>).</p>\n<p>Each of these options corresponds to a static check to skip when checking the soundness and safety of a transmutation. The use of any of these options compromises the safety or well-definedness of a transmutation, but there are situations where <em>safer-but-not-safe</em> transmutation is exactly what you want:</p>\n<ul>\n<li><code>NeglectAlignment</code> is useful for crates like bytemuck.</li>\n<li><code>NeglectValidity</code> is useful for building abstractions over falliable transmutations.</li>\n<li><code>NeglectVisibility</code> is useful for building the <code>Muckable</code> system we've discussed where a different method is used to signal visibility.</li>\n</ul>",
        "id": 217189643,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605730038
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> Two questions that raises...</p>",
        "id": 217189837,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730140
    },
    {
        "content": "<p>Is this <code>UnstableTransmuteFrom</code> (perma-unstable), or <code>UnsafeTransmuteFrom</code> (method is unsafe to invoke, albeit less unsafe than <code>std::mem::transmute</code>), or both?</p>",
        "id": 217189915,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730179
    },
    {
        "content": "<p>Second, is there any way we can avoid the concept of <code>Scope</code> entirely?</p>",
        "id": 217190098,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730266
    },
    {
        "content": "<p>This is <code>SemVerUnstableTransmuteFrom</code>.</p>\n<p>It provides a fully-fledged analysis of well-definedness and safety, with the key shortcoming that it's <em>just</em> a compiler analysis and the compiler has no clue about SemVer stability. (Just as <code>mem::align_of</code> is just the compiler's analysis of a type's alignment, and doesn't care whether that alignment is semver stable.)</p>",
        "id": 217190210,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605730314
    },
    {
        "content": "<p>I see. So naming aside, this is the trait that the compiler auto-generates and that you can't implement yourself?</p>",
        "id": 217190282,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730338
    },
    {
        "content": "<p>Bingo.</p>",
        "id": 217190309,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605730356
    },
    {
        "content": "<p>OK, that makes sense.</p>",
        "id": 217190320,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730366
    },
    {
        "content": "<p>Then, <em>general</em> feedback: I'm in favor of separating the publicly visible trait (<code>TransmuteFrom</code>) from the compiler-generated trait, and writing the former in terms of the latter in <code>core</code>.</p>",
        "id": 217190366,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730398
    },
    {
        "content": "<p>I'm much less enthusiastic about some of the details of the compiler-generated trait, notably <code>Scope</code>. I'd love to hide that in some way that means we can arbitrarily change it without language/library stability guarantees.</p>",
        "id": 217190514,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730471
    },
    {
        "content": "<p>I also expect that we'll want to stabilize the public trait much sooner than we stabilize the compiler-generated trait.</p>",
        "id": 217190627,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730524
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/UnstableTransmuteFrom/near/217190098\">said</a>:</p>\n<blockquote>\n<p>Second, is there any way we can avoid the concept of <code>Scope</code> entirely?</p>\n</blockquote>\n<p>No, not that we know of, unfortunately. The currently compiler <em>really</em> likes making the assumption that if <code>T: Trait</code> in one place, <code>T: Trait</code> in other places. If you want to make an implementation private today, you <em>need</em> to introduce a private type.</p>\n<p>In the far-flung future, the compiler <em>might</em> get a sense of the provenance of trait bound requirements implicitly. If this occurs, <code>Scope</code> can perhaps be defaulted.</p>",
        "id": 217190808,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605730618
    },
    {
        "content": "<p>It feels uncomfortable in particular to have <em>both</em> <code>Muckable</code> and <code>Scope</code>/<code>NeglectVisibility</code>.</p>",
        "id": 217190902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605730668
    },
    {
        "content": "<p>I think we have no choice but to have the separation given that we expect there to be an opt-in for this stuff.</p>\n<p>I'd also be excited (assuming compiler is fine with it) to get some version of the internal trait implemented in nightly (if it isn't already) sooner rather than later, since that can always be changed.  And +1 to expecting the opt-in more-limited trait to stabilize well before the magic one -- I might even say that the magic one should never be stabilized, like an intrinsic, though perhaps some other core trait would expose it through a blanket impl or something at some point.</p>",
        "id": 217191012,
        "sender_full_name": "scottmcm",
        "timestamp": 1605730700
    },
    {
        "content": "<p>(Returning to this topic for discussion on the <code>Scope</code> parameter.)</p>",
        "id": 217192609,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731470
    },
    {
        "content": "<p>Suppose we had a future version of Rust where you could have private trait impls, and the compiler pays attention to the invoking scope to determine if you're allowed to know that <code>T: Trait</code>.</p>",
        "id": 217192774,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731557
    },
    {
        "content": "<p>(I'm 100% on board that <code>TransmuteFrom</code> <strong>won't</strong> haven't a <code>Scope</code> parameter, btw.)</p>",
        "id": 217192794,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605731568
    },
    {
        "content": "<p>...go on.</p>",
        "id": 217192817,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605731580
    },
    {
        "content": "<p>What would <code>UnstableTransmuteFrom</code> look like then, and how can we design the current trait so that it's completely forward-compatible in all the details we might ever consider stabilizing?</p>",
        "id": 217192876,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731608
    },
    {
        "content": "<p>Given compiler support, could we <em>completely</em> hide the <code>Scope</code> parameter, so that you can't name it, can't turbofish it, can't pass it from one generic invocation to another (via <code>UnstableTransmuteFrom&lt;..., Scope, ...&gt;, ... Scope ...</code>)...</p>",
        "id": 217193040,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731674
    },
    {
        "content": "<p>Just make it an invisible implementation detail of how the compiler pseudo-implements having scope for impls in the first place?</p>",
        "id": 217193105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731701
    },
    {
        "content": "<p>So that if we have \"native\" support for that kind of scoping and visibility, it goes away entirely without breaking anything (except <code>core</code> which can change to match)?</p>",
        "id": 217193141,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731720
    },
    {
        "content": "<p>I remember the macro approach, but I'm wondering if there's some way to just have the equivalent of <code>Scope=Here!()</code> (defaulting) without exposing either <code>Here!</code> or <code>Scope</code> to any user of <code>UnstableTransmuteFrom</code>.</p>",
        "id": 217193280,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731777
    },
    {
        "content": "<p>Having an explicit <code>Scope</code> parameter is essential for preserving type privacy across generic abstractions. If you can figure out how to correctly infer the right <code>Scope</code> parameter every time, you've figured out how to make private impls work generally.</p>",
        "id": 217193321,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605731799
    },
    {
        "content": "<p>/me tries to process that.</p>",
        "id": 217193357,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731821
    },
    {
        "content": "<p>/me has to go to another meeting.</p>",
        "id": 217193513,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731893
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/UnstableTransmuteFrom/near/217193321\">said</a>:</p>\n<blockquote>\n<p>Having an explicit <code>Scope</code> parameter is essential for preserving type privacy across generic abstractions. If you can figure out how to correctly infer the right <code>Scope</code> parameter every time, you've figured out how to make private impls work generally.</p>\n</blockquote>\n<p>I'd like to understand this better, later.</p>",
        "id": 217193523,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731904
    },
    {
        "content": "<p>I feel like understanding this would be key to understanding how much \"innate complexity\" this has to have and how much we can reasonably contain.</p>",
        "id": 217193553,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605731934
    },
    {
        "content": "<p><em>(This is the explanation from an earlier version of the RFC...)</em></p>\n<p>This explicit <code>Scope</code> parameter of <code>TransmuteFrom</code> makes possible the creation of generic abstractions over it. For instance, consider a hypothetical <code>FromZeros</code> trait that indicates whether <code>Self</code> is safely initializable from a sufficiently large buffer of zero-initialized bytes:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">mod</span> <span class=\"nn\">zerocopy</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FromZeros</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"sd\">/// Safely initialize `Self` from zeroed bytes.</span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">zeroed</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[derive(Copy, Clone, PromiseTransmutableInto)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[repr(u8)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">enum</span> <span class=\"nc\">Zero</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Dst</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FromZeros</span><span class=\"o\">&lt;</span><span class=\"n\">Neglect</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Dst</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">Zero</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"o\">???</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">zeroed</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">[</span><span class=\"n\">Zero</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">].</span><span class=\"n\">transmute_into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The above definition leaves ambiguous (<code>???</code>) the scope in which the constructability of <code>Dst</code> is checked: is it from the perspective of where this trait is defined, or where this trait is <em>used</em>? You probably do <em>not</em> intend for this trait to <em>only</em> be usable with <code>Dst</code> types that are defined in the same scope as the <code>FromZeros</code> trait!</p>\n<p>Adding an explicit <code>Scope</code> parameter to <code>FromZeros</code> makes this unambiguous; the transmutability of <code>Dst</code> should be assessed from where the trait is used, <em>not</em> where it is defined:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FromZeros</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"sd\">/// Safely initialize `Self` from zeroed bytes.</span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">zeroed</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FromZeros</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">Zero</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">zeroed</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">[</span><span class=\"n\">Zero</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">].</span><span class=\"n\">transmute_into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>A third-party could then use <code>FromZeros</code> like so:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">zerocopy</span>::<span class=\"n\">FromZeros</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[derive(PromiseTransmutableInto)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"c1\">// Initialize `Foo` from zero-initialized bytes.</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">FromZeros</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Here</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"o\">&gt;</span>::<span class=\"n\">zeroed</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 217193791,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605732068
    },
    {
        "content": "<p>Oh, huh, here's another thought, <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> (for whenever you return): If someday Rust gets <code>Scope</code> inference, than <code>UnstableTransmuteFrom</code> is mostly just a clunkier way of using <code>TransmuteFrom</code>, because <code>TransmuteFrom</code> can then gain those same constructability-aware superpowers.</p>",
        "id": 217194220,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605732354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/UnstableTransmuteFrom/near/217194220\">said</a>:</p>\n<blockquote>\n<p>Oh, huh, here's another thought, <span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> (for whenever you return): If someday Rust gets <code>Scope</code> inference, than <code>UnstableTransmuteFrom</code> is mostly just a clunkier way of using <code>TransmuteFrom</code>, because <code>TransmuteFrom</code> can then gain those same constructability-aware superpowers.</p>\n</blockquote>\n<p>Not quite. There's still some value in separating <code>Muckable</code> from the compiler-generated compatibility trait, and allowing people to implement other mechanisms on top of the compiler-generated trait (such as <code>TryTransmuteFrom</code>).</p>",
        "id": 217203009,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605737174
    },
    {
        "content": "<p>Good point. Still, in that case, <code>UnstableTransmuteFrom</code> would just be a clunkier way of using <code>TryTransmuteFrom</code>, which would also presumably inherit scope-awareness.</p>",
        "id": 217203130,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605737252
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> have you had a chance took look over <a href=\"#narrow/stream/216762-project-safe-transmute/topic/UnstableTransmuteFrom/near/217193791\">this example</a>?</p>",
        "id": 217432309,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605893019
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> I did. I understand, now, why <code>Scope</code> has to be passed around explicitly. I don't, however, understand why the <em>caller</em> has to pass it in explicitly.</p>",
        "id": 217444289,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605898852
    },
    {
        "content": "<p>Can we not teach the compiler to pass in <code>Here!()</code> implicitly, as a default?</p>",
        "id": 217444360,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605898889
    },
    {
        "content": "<p>I would love for <code>Here!()</code> to be completely hidden and un-callable directly, if at all possible.</p>",
        "id": 217444407,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605898908
    },
    {
        "content": "<p><code>Here!()</code> (or any private type—<code>Here!()</code> is just for convenience) would <em>not</em> be the right thing to fill in <code>???</code> with in this example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">FromZeros</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"sd\">/// Safely initialize `Self` from zeroed bytes.</span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">zeroed</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[derive(Copy, Clone, PromiseTransmutableInto)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cp\">#[repr(u8)]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">enum</span> <span class=\"nc\">Zero</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Zero</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Dst</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">FromZeros</span><span class=\"o\">&lt;</span><span class=\"n\">Neglect</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">Dst</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"p\">[</span><span class=\"n\">Zero</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"o\">???</span><span class=\"w\"> </span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">zeroed</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">[</span><span class=\"n\">Zero</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"p\">].</span><span class=\"n\">transmute_into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...because that would denote \"evaluate the constructability of <code>Dst</code> from the context of the <code>zerocopy</code> crate—where the concrete <code>Dst</code> type almost certainly isn't even reachable.</p>",
        "id": 217444727,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605899048
    },
    {
        "content": "<p>I'm not suggesting you can't provide a <em>different</em> value, by passing in your own Scope type parameter.</p>",
        "id": 217444833,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899108
    },
    {
        "content": "<p>I understand that Scope can't be completely hidden; your example above made that clear.</p>",
        "id": 217444866,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899127
    },
    {
        "content": "<p>Gotcha!</p>",
        "id": 217444877,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605899130
    },
    {
        "content": "<p>I'm asking if <code>Here!()</code> can be completely hidden and handled by the compiler if you don't pass in a Scope.</p>",
        "id": 217444902,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899149
    },
    {
        "content": "<p>Both for simplicity and for forward-compatibility with some future implementation with a different trait model.</p>",
        "id": 217445010,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899198
    },
    {
        "content": "<p>The less public surface area, the more we can evolve.</p>",
        "id": 217445029,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899213
    },
    {
        "content": "<p>I think that might be possible, but I can see it having a <em>lot</em> of tricky edge cases—just as default type parameters <em>already</em> have tricky, longstanding edge cases. I'd hate to add to that complexity.</p>",
        "id": 217445214,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605899284
    },
    {
        "content": "<p>That's fair. I feel like it's worth attempting, and if we run into difficulties we can always consider alternatives.</p>",
        "id": 217445523,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899436
    },
    {
        "content": "<p><code>Here!()</code> was the biggest concern with the previous version, and I'm trying to figure out how we can avoid that and simplify.</p>",
        "id": 217445563,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899462
    },
    {
        "content": "<p>Hmmm. That does mean that we'll need some (eventually stable) way to denote a parameter that will default to the compiler-provided scope.</p>",
        "id": 217445660,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899521
    },
    {
        "content": "<p>Since the type parameter to <code>FromZeros</code> should default to that as well. Or any other Scope parameter for someone's trait built atop TransmuteFrom directly or indirectly.</p>",
        "id": 217445749,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605899552
    },
    {
        "content": "<p>So: We're on the same page that there <em>are</em> cases where the explicit <code>Scope</code> parameter is necessary as it would be inappropriate to infer <code>Here!()</code>. If you're building generic abstractions over transmutation, it's inescapable that you'll have to think about <code>Scope</code>. (In fact, the cases where you leave it to be inferred probably are a mistake.)</p>\n<p>For end-users <em>using</em> those abstractions on concrete types, it'd be nice if they <em>didn't</em> have to think about it. The RFC proposed achieving this with this macro:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"cp\">$expr</span>: <span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">TransmuteFrom</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Here</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"o\">&gt;</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"cp\">$expr</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//              ┯  ━━━┯━━━</span>\n<span class=\"w\">    </span><span class=\"c1\">//              │     ┕ check constructability from `transmute!`'s invocation scope</span>\n<span class=\"w\">    </span><span class=\"c1\">//              ┕ the destination type of the transmute (`_` used to infer the type from context)</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This macro means that end-users don't necessarily even need to think about the trait <code>TransmuteFrom</code> at all, either.</p>\n<p><code>Here!()</code> was just there for ergonomics. If it's a sticking point in its own right, the good news is that it's not actually needed at all. The technical goals of the <code>Scope</code> parameter require that it's just instantiated with a private type. It doesn't need to be a <em>particular</em> private type. So that macro could, equivalently, be written as:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"cp\">$expr</span>: <span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">enum</span> <span class=\"nc\">Here</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// define a private type to represent `transmute!`'s invocation scope</span>\n<span class=\"w\">    </span><span class=\"n\">TransmuteFrom</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Here</span><span class=\"o\">&gt;</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"cp\">$expr</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">//              ┯  ━┯━━</span>\n<span class=\"w\">    </span><span class=\"c1\">//              │   ┕ check constructability from visibility reference frame of `Here`</span>\n<span class=\"w\">    </span><span class=\"c1\">//              ┕ the destination type of the transmute (`_` used to infer the type from context)</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 217446636,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605899905
    },
    {
        "content": "<p>I think I should come at this from a different angle:</p>",
        "id": 217450833,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605902003
    },
    {
        "content": "<p>I'm hoping it's possible for us to change the compiler, to add specific support for this kind of type parameter, and desugar it accordingly.</p>",
        "id": 217450953,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605902051
    },
    {
        "content": "<p>Could we arrange to write this without a macro, and just let people write <code>TransmuteFrom::transmute_from</code>, with the compiler going \"oh, there's a <code>Scope</code> parameter there, I should fill that in\"?</p>",
        "id": 217451075,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605902109
    },
    {
        "content": "<p>By way of non-ergonomic but plausible syntax: <code>trait FromZeroes&lt;#[scope_param] Scope&gt;</code>.</p>",
        "id": 217451404,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605902237
    },
    {
        "content": "<p>That seems like an excellent basis for a <code>priv impl</code> RFC!</p>",
        "id": 217451686,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605902369
    },
    {
        "content": "<p>Private impl seems related, in that it solves the same problem in a more fundamental way. This would be an intermediate step that's more feasible than fully scope-and-visibility-aware impls.</p>",
        "id": 217451973,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605902487
    },
    {
        "content": "<p>I just don't want us to end up with a public surface area that <em>prevents</em> us from getting to either of those two points in the future.</p>",
        "id": 217452046,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605902516
    },
    {
        "content": "<p>Also, to answer your earlier point, using a private type rather than a <code>Here!()</code> macro seems likely to be an improvement, yes. Makes the proposal seem like it has less magic in it. :)</p>",
        "id": 217452137,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605902551
    },
    {
        "content": "<p>What's your motivation for wanting to make <code>Scope</code> implicit in some cases? Is it just ergonomics?</p>",
        "id": 217454932,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605904134
    },
    {
        "content": "<p>Partly ergonomics, partly the thought that the \"pass a type to indicate scope\" mechanism may not be how we want to handle it in the future if the compiler gets smarter about scope, and I'd like that to not be part of the stable interface.</p>",
        "id": 217455644,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605904520
    },
    {
        "content": "<p>Trying to minimize public surface area, in addition to wanting the interface to not require calling a macro.</p>",
        "id": 217455677,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605904545
    },
    {
        "content": "<p>I'd like people to be able to treat <code>TransmuteFrom</code> as a normal trait most of the time, in terms of calling its functions.</p>",
        "id": 217455740,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605904565
    },
    {
        "content": "<p>And not think about Scope unless they're building an interface atop it.</p>",
        "id": 217455763,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605904581
    },
    {
        "content": "<p>What happens here?<br>\ncrate1:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">UnrelatedType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_private</span>: <span class=\"p\">(),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[repr(transparent)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Even</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">v</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">%</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"bp\">Self</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>crate2:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">make_odd</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">crate1</span>::<span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">TransmuteFrom</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">crate1</span>::<span class=\"n\">UnrelatedType</span><span class=\"o\">&gt;</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"k\">u32</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 217455894,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1605904678
    },
    {
        "content": "<p>No implementation found for yada yada yada. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span> </p>\n<p>The <code>Scope</code> parameter can only be instantiated with private types.</p>",
        "id": 217456036,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605904764
    },
    {
        "content": "<p>Is there any way those types could \"leak\" via private-in-public?</p>",
        "id": 217456150,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605904828
    },
    {
        "content": "<p>My understanding is that the type privacy mechanism does a reachability-basis visibility analysis at implementation use-sites, and that these checks are relied upon to be air-tight. There's a bunch of conversation in the 'Type Privacy &amp; Safety' topic about this.</p>",
        "id": 217456328,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605904959
    },
    {
        "content": "<p>crate1:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">UnrelatedType</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">PrivateType</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">func</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">UnrelatedType</span><span class=\"o\">&lt;</span><span class=\"n\">PrivateType</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"c1\">// plus `Even` from above</span>\n</code></pre></div>\n<p>crate2:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">make_odd</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_unused</span>: <span class=\"nc\">crate1</span>::<span class=\"n\">UnrelatedType</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">crate1</span>::<span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">TransmuteFrom</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"o\">&gt;</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"k\">u32</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 217456395,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605905020
    },
    {
        "content": "<p>Try it. :)</p>",
        "id": 217456416,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605905038
    },
    {
        "content": "<p>IIRC, you'll get two errors. First, a purely local priv-in-pub lint at the <code>func</code> definition site. Then, a hard, reachability-based error in <code>crate2</code>.</p>",
        "id": 217456575,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605905126
    },
    {
        "content": "<p>I knew about the former, but not the latter.</p>",
        "id": 217456668,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605905164
    },
    {
        "content": "<p>Does that still apply if you make <code>func()</code> return an <code>UnrelatedType&lt;impl SomeTrait&gt;</code> where <code>func()</code> gets to determine the type but not tell you about it?</p>",
        "id": 217456803,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605905243
    },
    {
        "content": "<p>(trying that now)</p>",
        "id": 217456811,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605905252
    },
    {
        "content": "<p>There are exceptions carved out for <em>anonymized</em> private types so it should let you \"leak\" it. However, you won't be able to snag implementations of <code>TransmuteFrom</code> in <code>crate2</code> using it, IIRC.</p>",
        "id": 217457026,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605905401
    },
    {
        "content": "<p>So you might be able to get around the private-in-public issue, but not the reachability check in crate2?</p>",
        "id": 217457102,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605905430
    },
    {
        "content": "<p>Yep. That was the conclusion of the discussion over on 'Type Privacy &amp; Safety'.</p>",
        "id": 217457167,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605905490
    },
    {
        "content": "<p><span aria-label=\"+1\" class=\"emoji emoji-1f44d\" role=\"img\" title=\"+1\">:+1:</span></p>",
        "id": 217458309,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605906207
    },
    {
        "content": "<p>That definitely addresses one of my concerns about whether we'd find a soundness issue down the road.</p>",
        "id": 217458355,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1605906234
    },
    {
        "content": "<p>Glad to hear it. If there are issues with type privacy, the issues will be felt more broadly than <em>just</em> transmutation. <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216805918\">Some aspects of linking depend on type privacy</a>, and it wouldn't be unambiguously sound to implement a public traits for private types.</p>",
        "id": 217459151,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605906632
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/UnstableTransmuteFrom/near/217455644\">said</a>:</p>\n<blockquote>\n<p>Partly ergonomics, partly the thought that the \"pass a type to indicate scope\" mechanism may not be how we want to handle it in the future if the compiler gets smarter about scope, and I'd like that to not be part of the stable interface.</p>\n</blockquote>\n<p>If <code>UnstableTransmuteFrom</code> gains scope-inference powers in the future, we can non-breakingly surface that capability by defaulting the <code>Scope</code> parameter to some sigil signifying \"scope inference me!\" (e.g., <code>!</code> or <code>()</code>). Existing code that explicitly passes a <code>Scope</code> parameter will continue to work. New code can then either be in the form <code>Dst: UnstableTransmuteFrom&lt;Src&gt;</code>, or (if <code>Neglect</code> options need to be passed) <code>Dst: UnstableTransmuteFrom&lt;Src, !, Neglect&gt;</code>.</p>\n<p>And, since <code>UnstableTransmuteFrom</code> is straight compiler magic anyways, we can take this one step further and treat <code>Dst: UnstableTransmuteFrom&lt;Src, Neglect&gt;</code> as <code>Dst: UnstableTransmuteFrom&lt;Src, !, Neglect&gt;</code>. (I think you proposed something like this in an earlier comment.)</p>",
        "id": 217829314,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606261897
    }
]