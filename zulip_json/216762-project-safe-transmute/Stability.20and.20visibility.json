[
    {
        "content": "<p>I'm reading through the RFC, and I'm feeling uneasy about 1) the sheer size of the API, and 2) any attempt to talk about visibility/stability with the trait system.</p>\n<p>That is, I don't believe stability ought to be reified into std- today, it is determined purely by the set of visible items (both <code>pub</code> and <code>impl</code> based). Thus, instead of the <code>PromiseTransmutable..</code> and <code>NeglectStability</code> stuff, I would expect \"public\"/\"stable\" transmutability to use \"plain old impls\" of an option-less version of <code>Transmute..</code> (like how <code>Copy</code> is not an auto trait either), and \"private\" transmutability to be performed <em>without</em> going through a trait, e.g. via a lang-item based directly on implicit constructibility.</p>\n<p>IIUC, this would limit the public/\"vocabulary\" API to <em>just</em> a deriv-able <code>Transmute..</code>, with no option parameters or extra traits. The static checks on alignment/etc would be left up to the \"private\" non-trait-based mechanism, to be used within those impls. Does this sound reasonable, or am I missing something subtle?</p>",
        "id": 208723943,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598983143
    },
    {
        "content": "<p>(Side note: I am probably missing a lot of details here! I wish there were more of a separate \"problem statement\" that described what the RFC is trying to accomplish <em>without</em> reference to <code>PromiseTransmutable..</code>/<code>NeglectStability</code>- as it is, I am having to untangle those goals from the way the RFC proposes to accomplish them.)</p>",
        "id": 208723963,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598983156
    },
    {
        "content": "<p>It's important to me that we do not conflate safety with stability. This RFC allows you to query the safety of a transmutation independent from its stability:</p>\n<ul>\n<li><code>Dst: TransmuteFrom&lt;Src, NeglectStability&gt;</code> if <code>Src</code> to <code>Dst</code> is safe</li>\n</ul>\n<p>It sounds like you are describing an alternative where instances of a <code>TransmuteFrom</code> trait are only available for types whose author has annotated them with <code>derive(Transmute)</code>. This deeply intertwines safety and stability. A type <code>Dst</code> would be <code>TransmuteFrom&lt;Src&gt;</code> only if the authors of <code>Dst</code> and <code>Src</code> annotated their types with <code>derive(Transmute)</code>, and if the transmutation  from <code>Src</code> to <code>Dst</code> was safe.</p>\n<p>This wouldn't avoid the issue of transmutation stability so much as it would make it inescapable.</p>",
        "id": 208746069,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598993271
    },
    {
        "content": "<p>In contrast to the stability system proposed by our RFC, this alternative system is all-or-nothing. You could not, for instance, use it to bound the stable size or alignment of your type.</p>",
        "id": 208746265,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598993375
    },
    {
        "content": "<p>As for <code>Neglect</code>: the ability to turn off static checks is what makes our proposal a useful foundation for a range of other effort. The ability to neglect the alignment check is going to be bytemuck's bread-and-butter (cc <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>). The ability to neglect the validity check is going to make possible a range of <em>fallible</em> transmutation abstractions (cc <span class=\"user-mention\" data-user-id=\"264680\">@Tristan Hume</span>).</p>",
        "id": 208746865,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598993646
    },
    {
        "content": "<p>And, the ability to <code>NeglectStability</code> is going to make possible benefitting from this RFC's mechanisms without waiting for all of one's dependencies to catch up. Without it, you'd need to fall back to a <em>totally</em> unsafe alternative if confronted with a transmute-unstable type.</p>",
        "id": 208747080,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598993761
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> what did you think of adding a size-match requirement with a Neglect to turn it off?</p>",
        "id": 208747253,
        "sender_full_name": "Lokathor",
        "timestamp": 1598993827
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> that does not seem relevant to this thread...</p>",
        "id": 208747347,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598993870
    },
    {
        "content": "<p>size changes in a type accidentally turning into a truncation were specifically called out in the rfc thread as a form of stability hazard</p>",
        "id": 208747449,
        "sender_full_name": "Lokathor",
        "timestamp": 1598993911
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> Yes, I am describing an alternative where <code>TransmuteFrom</code> must be implemented by the type author. But no, that does not intertwine safety and stability- <code>TransmuteFrom</code> would represent stability, and a non-trait lang-item-y mechanism would represent safety.</p>",
        "id": 208747537,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598993958
    },
    {
        "content": "<p>This is not all-or-nothing! This is simply sticking to the existing idioms of Rust- you can still do all the same things, you just divide up the responsibilities differently.</p>",
        "id": 208747616,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598993996
    },
    {
        "content": "<p>The point is, this amount of API complexity has a massive cost, and it is <em>not</em> a necessary part of the compiler providing the static checks described in the RFC.</p>",
        "id": 208747755,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598994034
    },
    {
        "content": "<p>I made the comparison to <code>Copy</code> very deliberately- <code>Copy</code> is a <em>stability</em> guarantee, but positions in the program that have access to private details can still perform the copy operation without the trait!</p>",
        "id": 208747898,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598994076
    },
    {
        "content": "<p>What sort of non-trait lang-item-y mechanism are you envisioning? <code>TransmuteFrom</code> is a trait lang item. We use a trait, as opposed to a function intrinsic, to expose transmutation safety, because traits can be abstracted over.</p>",
        "id": 208747987,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598994113
    },
    {
        "content": "<p>That abstraction is the source of my concern. As soon as you put something in the trait system it ceases to have anything to do with visibility, and so an auto-impled lang item trait simply cannot be used to enforce visibility-related invariants. It would be more appropriate to use a language feature that <em>can</em> take visibility into account- e.g. a \"magic\" function (like how <code>mem::transmute</code> enforces matching size), or even new syntax (analogous to how <code>SomeStruct { fields }</code> is language-level syntax).</p>",
        "id": 208748349,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598994260
    },
    {
        "content": "<blockquote>\n<p>so an auto-impled lang item trait simply cannot be used to enforce visibility-related invariants</p>\n</blockquote>\n<p>Yes, hence the RFC's formulation of safety-via-constructability, and the stability declaration traits.</p>",
        "id": 208748672,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598994430
    },
    {
        "content": "<p>Ultimately, the ability to build abstractions over transmutations is a core design goal of this RFC. We could (and did) consider realizing certain aspects of the RFC as intrinsic predicates, but those fail to address the requirement of abstraction-building.</p>",
        "id": 208748831,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598994505
    },
    {
        "content": "<blockquote>\n<p>We could (and did) consider realizing certain aspects of the RFC as intrinsic predicates, but those fail to address the requirement of abstraction-building.</p>\n</blockquote>\n<p>I am not convinced of this. With intrinsics/syntax you may need to introduce new traits outside of std for each particular use case, but that doesn't actually <em>prevent</em> any abstraction-building AFAICT. Arguably, moving that kind of abstraction-building out of std is <em>exactly</em> the way to shrink the RFC and get a minimum viable feature set.</p>",
        "id": 208749394,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598994745
    },
    {
        "content": "<p>I share the concerns about introducing so much complexity to deal with the semver problem. The way I see it, this RFC introduces a very wide-reaching change (a trait that is auto-derived for a huge number of types), which would make it so that changes to struct layouts are breaking changes, and then introduces a significant amount of complexity to the trait API to fix this problem. If the trait were not pervasively auto-derived in the first place, and instead opt-in (like Copy), it would interact with semver in a standard way like other traits.</p>",
        "id": 208750124,
        "sender_full_name": "glowcoil",
        "timestamp": 1598995071
    },
    {
        "content": "<p>I am confident that the <a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#towards-an-initial-smart-implementation\">initial smart implementation</a> of this RFC <em>is</em> a minimal viable feature set. It either addresses or can gracefully evolve to address (e.g., via adding additional neglectable checks) all of the use-cases considered by this working group.</p>\n<p>I am very reluctant to recommend adopting an API that <em>cannot</em> grow to accomodate use-cases considered by this working-group; that would seem to imply that we might have to eventually design an <em>alternative</em> safe-transmute API to accomodate those use-cases.</p>",
        "id": 208750206,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1598995099
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284949\">glowcoil</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208750124\">said</a>:</p>\n<blockquote>\n<p>(a trait that is auto-derived for a huge number of types), which would make it so that changes to struct layouts are breaking changes</p>\n</blockquote>\n<p>This is a great way to put it! The existence of <code>TransmuteFrom&lt;T, NeglectStability&gt;</code> makes certain layout changes (which were previously minor semver changes) breaking, with no opt-out- or in other words, it punches a new hole through the usual usage of <code>pub</code> and <code>impl</code> to manage stability.</p>\n<p>The initial smart implementation <em>does</em> avoid this by downgrading <code>NeglectStability</code> to <code>unsafe</code>. But my argument is that <code>NeglectStability</code> should stay that way forever: Either a type author should explicitly impl <code>TransmuteFrom</code> (basically \"marking some of its layout <code>pub</code>\", analogous to impling <code>Copy</code>), or else the type's layout should stay entirely private, and only safely transmutable from positions where it is implicitly constructible.</p>\n<p>Notably this last condition is actually much more powerful than even the full version of <code>TransmuteFrom&lt;T, NeglectStability&gt;</code>. It would let you do safe transmutes in the type's module <em>even with private fields</em>, while still preventing outside modules from doing so. The trait system, OTOH, can't express this no matter how much compiler magic you throw at it, because traits impls don't have their own visibility.</p>",
        "id": 208752877,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598996644
    },
    {
        "content": "<p>Coming at this from the \"API size\" angle again, this makes <code>NeglectStability</code> feel like it exists solely as a short-term workaround for people who want to work with types that a) have documented their layout but b) have not yet implemented <code>Promise..</code>. This feels analogous to a hypothetical <code>NeglectNotCopy</code>- the correct solution is to add the impl, and we already have the tools to do that! (i.e. cargo patch)</p>",
        "id": 208754165,
        "sender_full_name": "rpjohnst",
        "timestamp": 1598997429
    },
    {
        "content": "<blockquote>\n<p>The existence of <code>TransmuteFrom&lt;T, NeglectStability&gt;</code> makes certain layout changes (which were previously minor semver changes) breaking, with no opt-out- or in other words, it punches a new hole through the usual usage of <code>pub</code> and <code>impl</code> to manage stability.</p>\n</blockquote>\n<p>This is simply incorrect. <strong>You have to <em>opt-in</em> to neglecting stability.</strong> Stability is not neglected unless you type the words <code>NeglectStability</code>.</p>\n<hr>\n<blockquote>\n<p>The initial smart implementation does avoid this by downgrading <code>NeglectStability</code> to <code>unsafe</code>.</p>\n</blockquote>\n<p>No, that's not at all why the initial smart implementation does this. We do it because the simple formulation of constructability has a soundness hole, not because <code>unsafe</code> discourages people from doing a thing.</p>\n<hr>\n<blockquote>\n<p>or else the type's layout should stay entirely private</p>\n</blockquote>\n<p>This does not accurately describe the status quo. You can observe and rely on potentially unstable aspects of a type's layout <em>already</em>, in safe code; <a href=\"https://doc.rust-lang.org/core/mem/fn.size_of.html\"><code>size_of</code></a> and <a href=\"https://doc.rust-lang.org/core/mem/fn.align_of.html\"><code>align_of</code></a> are trivial cases of this.</p>\n<hr>\n<blockquote>\n<p>Notably this last condition is actually much more powerful than even the full version of TransmuteFrom&lt;T, NeglectStability&gt;. It would let you do safe transmutes in the type's module even with private fields, while still preventing outside modules from doing so.</p>\n</blockquote>\n<p>The full formulation of constructability in the RFC permits exactly this scenario, because checking for implicit constructability intrinsically relates to scope.</p>\n<hr>\n<blockquote>\n<p>The trait system, OTOH, can't express this no matter how much compiler magic you throw at it, because traits impls don't have their own visibility.</p>\n</blockquote>\n<p>Scope resolution occurs, necessarily, <em>before</em> trait resolution. It is absolutely possible for trait resolution to take scope into account. This isn't unprecedented: it's more or less how Haskell's <code>Coercible</code> typeclass works. We acknowledge it may not be <em>easy</em> to do this, which is why we propose a simplified formulation of constructability as a candidate for initial implementation.</p>",
        "id": 208759824,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599001302
    },
    {
        "content": "<p>This is quickly becoming quite combative, so I'll respond to some misunderstandings but leave the actual subject matter alone for now.</p>",
        "id": 208761372,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599002490
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208759824\">said</a>:</p>\n<blockquote>\n<p>This is simply incorrect. <strong>You have to opt-in to neglect stability.</strong> Stability is not neglected unless you type the words <code>NeglectStability</code>.</p>\n</blockquote>\n<p>You misunderstand. \"You\" here is the type user, but up until this point \"you\" has always been, instead, the type author. To be perfectly clear:</p>\n<p>Today, if crate A 1.0 defines a type like this...</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Pair</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">i8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">i32</span> <span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>...then crate A 1.1 can change that to look like this...</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Pair</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"kt\">i8</span> <span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>...without breaking crate B, because today nobody can safely transmute a <code>Pair</code>. Automatically implementing <code>TransmuteFrom&lt;Pair, NeglectStability&gt;</code> is a totally new possibility- you can of course argue that <code>NeglectStability</code> shifts the blame for any breakage onto crate B, but that doesn't change the fact that a change in crate A that used to be perfectly innocuous may now break crate B. That's all I meant here.</p>",
        "id": 208761496,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599002570
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208759824\">said</a>:</p>\n<blockquote>\n<p>No, that's not at all why the initial smart implementation does this. We do it because the simple formulation of constructability has a soundness hole, not because <code>unsafe</code> discourages people from doing a thing.</p>\n</blockquote>\n<p>I never claimed that was <em>why</em> the initial smart implementation makes <code>NeglectStability</code> unsafe, only that doing so happens to avoid the breakage described above, if you squint at the unsafe obligations in a particular way.</p>",
        "id": 208761645,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599002659
    },
    {
        "content": "<p>If crate B is transmuting, pointer casting, or otherwise reinterpreting <code>Pair</code>, then yes, that change will be breaking (in the sense that it silently causes UB).</p>",
        "id": 208761647,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599002663
    },
    {
        "content": "<p>Sigh.</p>",
        "id": 208761672,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599002697
    },
    {
        "content": "<p>The RFC views stability as basically orthogonal to stability. As part of our MVP, we position stability as an <em>extension</em> of safety, but <a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#stability-of-unsafe-transmutations\">we explore how even this restriction might be lifted in the future</a>.</p>",
        "id": 208761909,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599002905
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208759824\">said</a>:</p>\n<blockquote>\n<p>This does not accurately describe the status quo. You can observe and rely on potentially unstable aspects of a type's layout <em>already</em>, in safe code; <a href=\"https://doc.rust-lang.org/core/mem/fn.size_of.html\"><code>size_of</code></a> and <a href=\"https://doc.rust-lang.org/core/mem/fn.align_of.html\"><code>align_of</code></a> are trivial cases of this.</p>\n</blockquote>\n<p>Doing so will not, today, break compilation of crate B unless they are doing unsafe things. Changing the size of a type is not, per se, a capitalized Breaking Change, while <code>NeglectStability</code> will convert it into one. On the other hand, if crate A type authors must opt into certain size/align-dependent operations being explicitly available (e.g. by implementing <code>TransmuteFrom</code>), then making those changes Breaking is perfectly fine.</p>",
        "id": 208761912,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599002907
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208759824\">said</a>:</p>\n<blockquote>\n<p>Scope resolution occurs, necessarily, <em>before</em> trait resolution. It is absolutely possible for trait resolution to take scope into account. This isn't unprecedented: it's more or less how Haskell's <code>Coercible</code> typeclass works. We acknowledge it may not be <em>easy</em> to do this, which is why we propose a simplified formulation of constructability as a candidate for initial implementation.</p>\n</blockquote>\n<p><em>Trait</em> resolution relying on scope is fine, because it does not change the set of available impls for a given trait. <em>Impl</em> resolution, on the other hand, <em>cannot ever</em> depend on scope, without introducing serious and subtle soundness holes.  If a (post-scope-resolution) trait is implemented for a (post-scope-resolution) type in one location, it <em>absolutely must</em> be implemented for it in all locations, and vice versa.</p>",
        "id": 208762098,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599003067
    },
    {
        "content": "<p>(And all locations must further use the <em>same</em> impl.)</p>",
        "id": 208762210,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599003150
    },
    {
        "content": "<p>Relaxing this, as GHC's Coercible class does, is a <em>major</em> change to the trait system in its own right and should not be used as justification to toss in future extensions to an RFC...</p>",
        "id": 208762405,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599003351
    },
    {
        "content": "<blockquote>\n<p>Doing so will not, today, break compilation of crate B unless they are doing unsafe things.</p>\n</blockquote>\n<p>Counterpoint:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">crate_a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// try to change the size of `Foo` without breaking `crate_b`</span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">([</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">]);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">mod</span> <span class=\"nn\">crate_b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">size_of</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// no unsafe code here</span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">[();</span><span class=\"w\"> </span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"k\">super</span>::<span class=\"n\">crate_a</span>::<span class=\"n\">Foo</span><span class=\"o\">&gt;</span><span class=\"p\">()]</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[();</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 208762481,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599003399
    },
    {
        "content": "<p>Indeed, even with that change, GHC still includes \"type roles\" as a way for type authors to control this.</p>",
        "id": 208762486,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599003403
    },
    {
        "content": "<p>That's a fair example, though I will note that it is the cause of much anguish in other parts of the language already, so on its own it's still not an argument to go further in that direction.</p>",
        "id": 208762600,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599003500
    },
    {
        "content": "<blockquote>\n<p>it is the cause of much anguish in other parts of the language already</p>\n</blockquote>\n<p>Is this true? It doesn't seem self-evident to me.</p>",
        "id": 208762779,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1599003708
    },
    {
        "content": "<p>I'm referring to, for example, <code>extern type</code>.</p>",
        "id": 208762827,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599003726
    },
    {
        "content": "<p>I am not advocating rust <em>ever</em> adopt a <em>general</em> mechanism for scope-dependent impls, and I acknowledge it's no small change.  However, there's a difference between hard and theoretically unsound. The situation you describe does not point to this being theoretically unsound, just unsound given the <em>current</em> implementation of trait resolution. This RFC is emphatically about having the trait resolution system do things it currently doesn't, like assess the layouts of types.</p>\n<p>(My understanding of roles is that they are needed moreso because GHC reasons about type definitions, not type layouts.)</p>",
        "id": 208762999,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599003900
    },
    {
        "content": "<p>Overall, our biggest difference does seem to be this expectation that the trait system may eventually be capable of hiding impls based on scope. With that, then <code>NeglectStability</code> has a path forward, and my concern would primarily be about the unwieldiness of the API. Without that, <code>NeglectStability</code> has no reason to exist, and my concern is that the RFC is biting off more than it can chew.</p>",
        "id": 208763160,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599004027
    },
    {
        "content": "<p>Some other factors in why I would not bet on this trait system extension necessarily being possible:</p>\n<ul>\n<li>GHC classes and Rust traits are quite similar in some ways but they are very different in others, <em>especially</em> surrounding coherence/object safety/variance/specialization/etc.</li>\n<li>GHC, as you say, does not reason about type layouts- its value representation is uniform and GCed, so it can simply ignore the size/alignment/padding/ownership/etc concerns that are Rust's bread and butter.</li>\n<li>Expanding on the first point a bit, Rust already has a lot of uncertainty to deal with around <em>future</em> trait system features- specialization, negative impls, interactions with async and const, generic and defaulted associated types, etc. (See e.g. <a href=\"https://github.com/rust-lang/rust/issues/71550\">#71550</a> for a soundness bug arising from the interaction between object safety, variance, and associated types.)</li>\n</ul>",
        "id": 208763910,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599004724
    },
    {
        "content": "<blockquote>\n<p>Overall, our biggest difference does seem to be this expectation that the trait system may eventually be capable of hiding impls based on scope.</p>\n</blockquote>\n<p>That seems about right. I think of it more as, <em>the trait system generates impls on-the-fly (in part) based on scope</em>, but I <em>think</em> that's pretty similar to \"hiding impls based on scope\". </p>\n<p>I wouldn't necessarily say I have an <em>expectation</em> that the trait system will eventually be capable of this, but rather that it seems <em>plausible</em> that it <em>could</em> within the next few <em>decades</em>. If it ever does, then the compiler's implementation of this RFC will match the platonic ideal of it—without needing to overhaul the RFC's API surface at all. </p>\n<p>Until then, the simplified formulation is constructability is still a pretty damn good proxy for safety. The impact of its pub-in-priv soundness hole feels quite small: it <em>just</em> means that <code>NeglectStability</code> is an unsafe transmute option for the time being. Can you clarify how this amounts to <code>NeglectStability</code> having \"no reason to exist\"?</p>",
        "id": 208764094,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599004846
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208764094\">said</a>:</p>\n<blockquote>\n<p>Can you clarify how this amounts to <code>NeglectStability</code> having \"no reason to exist\"?</p>\n</blockquote>\n<p>In the spirit of \"clarify intent but leave the subject matter alone for now:\"</p>\n<ul>\n<li>In its initial unsafe form, <code>NeglectStability</code> is basically just a placeholder in the API, pending future extensions that make it safe.</li>\n<li>In its safe but non-scope-based form, it foists a new kind of (yes, opt-in for clients) breaking change on the ecosystem, all to get around a missing upstream impl that should be added anyway. (Or not added, in which case <code>NeglectStability</code> shouldn't be used anyway!)</li>\n<li>Only with its final, hypothetical, scope-based form do we gain something immediately useful- generic code <em>in the type's scope</em> using <code>TransmuteFrom&lt;T, NeglectStability&gt;</code> bounds that are inaccessible to other scopes.</li>\n</ul>\n<p>So what I mean is, <code>NeglectStability</code> et al are quite a lot of surface area to add to an MVP, on the off chance that we can eventually within \"decades\" implement the final form.</p>",
        "id": 208765605,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599006043
    },
    {
        "content": "<p>(I'm sorry to keep prodding you on this, but you keep saying interesting things!)</p>",
        "id": 208766286,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599006620
    },
    {
        "content": "<p>So: I do <em>not</em> view <code>NeglectStability</code> as an option with a ton of associated machinery. Rather, I view the stability system as a bunch of machinery, with an associated <code>NeglectStability</code> option.</p>\n<p>The stability system lets users make very fine grained stability promises about their types, and have the implications of those promises automatically enforced by the trait system (and without any compiler magic!). It <em>also</em> happens to be sometimes convenient to turn off, so the RFC provides a mechanism for doing so.</p>\n<p>In terms of raw expressive power, yes, <code>NeglectStability</code> seems like it might not bring much to the table: you can always just vendor your dependencies  and add the stability promises to the necessary types. (Can crates with vendored dependencies be published to <a href=\"http://crates.io\">crates.io</a>?)</p>",
        "id": 208766609,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599006891
    },
    {
        "content": "<p>My opinion regarding the stability system overall is that Rust already has a stability system, in the form of item visibility and semver, and it would be preferable to me to design a safe transmute API so that it dovetails with these existing systems rather than effectively emulating them using traits and witnesses.</p>",
        "id": 208766926,
        "sender_full_name": "glowcoil",
        "timestamp": 1599007199
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208766609\">said</a>:</p>\n<blockquote>\n<p>So: I do <em>not</em> view <code>NeglectStability</code> as an option with a ton of associated machinery. Rather, I view the stability system as a bunch of machinery, with an associated <code>NeglectStability</code> option.</p>\n</blockquote>\n<p>This is a distinction a) without a difference and b) that I was not trying to make. (Thus \"<code>NeglectStability</code> <em>et al</em>.\") You should be able to accomplish essentially the same things, fine-grained layout descriptions and all, without <em>any</em> of that machinery, just using the existing idiom of \"a plain old trait impl is a promise about the type.\" Vendored deps shouldn't even come into this.</p>\n<p>If a type author wishes to export a fine-grained guarantee about their type's layout, they should be able to <code>impl TransmuteFrom&lt;ThatType&gt; for SomeArchetype</code>- all the <code>Promise..</code>/<code>NeglectStability</code> machinery folds away, and the archetype thing becomes nothing more than a useful design pattern. (Which, to be clear, I do quite like!)</p>\n<p>On the other hand, if a type author wishes <em>not</em> to export anything about their type's layout, that is not a reason to add a \"convenience\" hole in the visibility system! We don't have an equivalent way to bypass missing <code>Copy</code> impls- we just expect clients to file a bug and/or do the copy \"by hand\" (e.g. <code>let new_data = Data { old_data.field1, old_data.field2 }</code>).</p>",
        "id": 208767353,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599007654
    },
    {
        "content": "<blockquote>\n<p>You should be able to accomplish essentially the same things, fine-grained layout descriptions and all, without any of that machinery, just using the existing idiom of \"a plain old trait impl is a promise about the type.\"</p>\n</blockquote>\n<p>I'm having a hard time envisioning how this would work, since a key component of the current visibility system is specifying archetypes that exemplify the bounds of the stability promise. I'd like to see a proposal more fully fleshing this idea out.</p>\n<blockquote>\n<p>Vendored deps shouldn't even come into this.</p>\n</blockquote>\n<p>I only bring it up because that's only the solution to the \"the-impls-don't-exist\" case if dependencies are involved and you can't <code>NeglectStability</code>. <a href=\"https://github.com/rust-lang/libc/issues/471#issuecomment-266541262\">libc would be a prominent cause of this scenario</a>.</p>\n<blockquote>\n<p>On the other hand, if a type author wishes not to export anything about their type's layout, that is not a reason to add a \"convenience\" hole in the visibility system!</p>\n</blockquote>\n<p>I think we're really responding to a hole that <em>already exists</em>: the current bit-reinterpretation conversion mechanisms do not have any concept of stability. Let's say we drop <code>NeglectStability</code>: if you cannot vendor your dependency and add impls for the stability declaration traits, your <em>only</em> recourse will be to continue to use those wildly-unsafe transmutation mechanisms. In our RFC, the <code>NeglectStability</code> option provides a safer alternative.</p>",
        "id": 208768157,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599008419
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"284949\">glowcoil</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208766926\">said</a>:</p>\n<blockquote>\n<p>My opinion regarding the stability system overall is that Rust already has a stability system, in the form of item visibility and semver, and it would be preferable to me to design a safe transmute API so that it dovetails with these existing systems rather than effectively emulating them using traits and witnesses.</p>\n</blockquote>\n<p>I do not feel that we are emulating SemVer with traits and witnesses. The item visibility and semver rules, as laid out in prior RFCs, do not make substantial promises about a type's layout.</p>\n<p>So, rather than try to come up with entirely new semver rules relating to transmutation, we just reuse the existing mechanisms.  The current SemVer rules <em>do</em> talk about what is a breaking change when a trait is implemented. We reify the stability promise as two traits which end-users implement. Those traits follow all the normal rules of semver stability.</p>",
        "id": 208768423,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599008698
    },
    {
        "content": "<p>(I do intend to come back to this, this is just a really busy week for me at work. I would love to write up some examples to clarify how things might work with an opt-in <code>TransmuteFrom</code> -- <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> let me know if you have any specific cases that would be helpful to see.)</p>",
        "id": 208984243,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599146659
    },
    {
        "content": "<p>Will do! I've also just written a <em>Gentle Introduction to Transmutation Stability</em> which hopefully provides some more context of what the RFC is even talking about: <a href=\"https://jack.wrenn.fyi/blog/transmutation-stability/\">https://jack.wrenn.fyi/blog/transmutation-stability/</a></p>",
        "id": 208984423,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599146750
    },
    {
        "content": "<p>That's what prompted me to leave this message, actually -- I appreciate the clarification and wish I'd had it when first reading the RFC. (Though I think my response is still warranted :P)</p>",
        "id": 208984814,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599146921
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208984423\">said</a>:</p>\n<blockquote>\n<p>Will do! I've also just written a <em>Gentle Introduction to Transmutation Stability</em> which hopefully provides some more context of what the RFC is even talking about: <a href=\"https://jack.wrenn.fyi/blog/transmutation-stability/\">https://jack.wrenn.fyi/blog/transmutation-stability/</a></p>\n</blockquote>\n<p>FWIW something seems to be broken in the markup, one paragraph reads <code>Rust's auto traits (</code> and then ends.</p>",
        "id": 209172458,
        "sender_full_name": "RalfJ",
        "timestamp": 1599302926
    },
    {
        "content": "<p>regarding the general discussion here, <code>NeglectStability</code> indeed seems like a big can of worms and I wonder if it really has to be part of the MVP</p>",
        "id": 209172520,
        "sender_full_name": "RalfJ",
        "timestamp": 1599303040
    },
    {
        "content": "<blockquote>\n<p>FWIW something seems to be broken in the markup, one paragraph reads Rust's auto traits ( and then ends.</p>\n</blockquote>\n<p>gah, weird. I could have sworn I fixed that. it's DEFINITELY fixed now</p>",
        "id": 209177554,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599311775
    },
    {
        "content": "<blockquote>\n<p>I wonder if it really has to be part of the MVP</p>\n</blockquote>\n<p><a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#minimal-useful-stabilization-surface\"><code>NeglectStability</code> does not need to be part of the stable MVP for this RFC to be broadly useful.</a></p>",
        "id": 209177593,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599311872
    },
    {
        "content": "<p>We should be able to go even further than that, and make both <code>NeglectStability</code> and <code>Promise..</code> <em>forever</em> unnecessary without giving up on important use cases, and make the API smaller and more idiomatic in the process:</p>\n<p>The core idea is to move \"implicit constructability\" from the trait system into the visibility system. Syntactically it might look similar to <code>mem::transmute</code> or <code>as</code>. For <em>monomorphic</em> types <code>Dst</code> and <code>Src</code>, it would allow construction of a <code>Dst</code> value from a <code>Src</code> value iff <code>Dst</code> is implicitly constructable from <code>Src</code> at the current position. (I'm leaving cross-module implicit constructability intentionally vague for the moment- see \"layout visibility\" below.)</p>\n<p>Up front, doing this without a trait appears to lose two things: polymorphism over the presence or absence of <code>NeglectStability</code>, and polymorphism over un-annotated implicitly constructable types. However, the first seems extraneous, and the RFC only actually provides the second via a <em>very</em> hypothetical extension to the trait system (impls whose existence depends on source location). Further, if Rust does ever get that extension, this approach could use it just as readily as the RFC! (Again, see below for details.)</p>",
        "id": 209187959,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599327159
    },
    {
        "content": "<p>On the other hand, this notably does <em>not</em> lose fine-grained control over stability guarantees orthogonal to safety, polymorphism over <em>annotated</em> transmutable types, or future extensibility:</p>\n<ul>\n<li>To understand how this approach handles safety+stability, think in terms of the \"layout visibility\" I mentioned above. I see three design choices here: leave all layouts private and only make them public with impls, retroactively make public the layouts of <code>#[repr(..)]</code> types, or add new syntax to declare layout public (e.g. <code>#[repr(pub, C)]</code>). Either way, the goal is to give type authors control over whether the type is implicitly constructible <em>outside</em> its module.</li>\n<li>Building on this, we can recover fine-grained stability annotations <em>and</em> polymorphic safe transmutes by re-introducing a simpler, option-less <code>TransmuteFrom</code> trait! The RFC's excellent archetype pattern still works here- a type author can <code>impl Transmute{From,Into}&lt;MainType&gt; for ItsArchetype</code>, where <code>ItsArchetype</code> has public layout, enabling other modules+crates to work with <code>ItsArchetype</code> in their transmutes.<ul>\n<li>libcore could still provide a convenience wrapper for archetype&lt;-&gt;archetype transmutes, with an extra <code>trait PublicLayout { type Archetype: Transmute{From,Into}&lt;Self&gt;; }</code>. But this doesn't need to be in the MVP to provide the actual fine-grained control!</li>\n</ul>\n</li>\n<li>If Rust ever does gain location-dependent impls, this approach can take advantage of them by adding bounds to its core intrinsic. This would be similar to adding <code>where size_of::&lt;T&gt;() == size_of::&lt;U&gt;()</code> to <code>mem::transmute</code>- it simply becomes usable on polymorphic types. These bounds don't need to be related to <code>TransmuteFrom</code> <em>at all</em>- so this poses no risk of a \"whoops, time to replace the entire safe transmute API\" scenario.</li>\n</ul>",
        "id": 209187960,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599327162
    },
    {
        "content": "<p>Another thing I left vague above, because there are several possible approaches, is the <em>rest</em> of the <code>Neglect..</code> options. They're still possible, even without the options parameter to <code>Transmute..</code>!</p>\n<p>For the core intrinsic itself, we have a few options- split it up into multiple functions, give the intrinsic itself an RFC-like options parameter, etc.</p>\n<p>For polymorphic partially-safe transmutes, I will for now just note that the RFC's examples for <code>NeglectAlignment</code> and <code>NeglectValidity</code> should be able to use the core intrinsics directly- the validity example just goes between two monomorphic types (<code>u8</code> and <code>Bool</code>), and the alignment example only needs to know that <code>T</code> and <code>U</code> are transmutable <em>on their own</em> in order to transmute references to them.</p>\n<p>(This last one also has precedent with <code>mem::transmute</code>, which <em>can</em> handle polymorphic types like <code>&amp;T</code> -&gt; <code>&amp;U</code> because the \"top level\" which determines the size is known.)</p>",
        "id": 209188915,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599328845
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> </p>\n<blockquote>\n<p>NeglectStability indeed seems like a big can of worms</p>\n</blockquote>\n<p>Not sure I follow; what's the can of worms?</p>",
        "id": 209192590,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599334474
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132362\">Joshua Liebow-Feeser</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209192590\">said</a>:</p>\n<blockquote>\n<p>Not sure I follow; what's the can of worms?</p>\n</blockquote>\n<p>The worm under discussion so far is that it basically punches a hole through the usual privacy/stability rules- rather than the type author controlling whether their type is transmutable (a la the explicit opt in to implement the Copy trait), now crate <em>clients</em> can do that without their involvement.</p>\n<p>And while the RFC starts it out as unsafe, and provides a technically-sound way to make it safe, and at least makes it opt-in on the part of the type <em>user</em>, it still departs from the usual idioms around privacy+stability, which are \"the type author decides what is public and what is private.\"</p>",
        "id": 209192823,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599334778
    },
    {
        "content": "<p>See e.g. this reply <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208766926\">https://rust-lang.zulipchat.com/#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/208766926</a></p>",
        "id": 209192874,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599334811
    },
    {
        "content": "<blockquote>\n<p>The worm under discussion so far is that it basically punches a hole through the usual privacy/stability rules- rather than the type author controlling whether their type is transmutable (a la the explicit opt in to implement the Copy trait), now crate clients can do that without their involvement.</p>\n</blockquote>\n<p>Doesn't the fact that <code>NeglectStability</code> is unsafe just put this on the same footing as pointer casting or <code>mem::transmute</code>, both of which allow you to punch the hole you're describing so long as you use <code>unsafe</code>?</p>",
        "id": 209193181,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599335309
    },
    {
        "content": "<p>As described in the RFC, <code>NeglectStability</code> is _not_ unsafe to use. It implements <code>SafeTransmuteOptions</code>.<br>\n<a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#neglecting-static-checks\">https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#neglecting-static-checks</a></p>",
        "id": 209193197,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1599335353
    },
    {
        "content": "<p>It's technically <em>initially</em> unsafe to use. I say it should be eventually safe because, in principle, safety is orthogonal to stability.</p>\n<p>In this, I'm following the pattern of <code>mem::align_of</code> and <code>mem::size_of</code>. These functions are safe, callable with any type, but their output should not be considered stable across even minor crate versions.</p>\n<p>(However, whereas these functions don't really call attention to their instability, <code>TransmuteFrom</code> does: you need to actually type the words <code>NeglectStability</code> to make it behave unlike a \"normal\" trait with respect to stability.)</p>",
        "id": 209193207,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599335387
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229913\">HeroicKatora</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209193197\">said</a>:</p>\n<blockquote>\n<p>As described in the RFC, <code>NeglectStability</code> is _not_ unsafe to use. It implements <code>SafeTransmuteOptions</code>.<br>\n<a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#neglecting-static-checks\">https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#neglecting-static-checks</a></p>\n</blockquote>\n<p>It starts out unsafe in the MVP, is what I'm referring to.</p>",
        "id": 209193209,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599335391
    },
    {
        "content": "<p>Right, so referring to the MVP, can you clarify how this is different than unions, pointer casting, or <code>mem::transmute</code>, which allow this sort of breaking-the-visibility-wall today? I'm not sure I see the difference.</p>",
        "id": 209193580,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599335890
    },
    {
        "content": "<p>Well, it may be unsafe in the MVP but it still has a different (smaller) proof obligation- \"the type author documented this type's layout as stable\" instead of the full obligation of <code>mem::transmute</code> et al. And if you aren't supposed to use <code>NeglectStability</code> without the type author's opt-in, then why does it even exist to begin with? Why not just have the type author add the right impls?</p>",
        "id": 209193878,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599336315
    },
    {
        "content": "<p>(Copy works the same way- we don't have a \"please let me copy this even though the author didn't impl Copy\" tool, we just make a PR or use cargo's patch feature or whatever.)</p>",
        "id": 209193886,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599336347
    },
    {
        "content": "<blockquote>\n<p>(Copy works the same way- we don't have a \"please let me copy this even though the author didn't impl Copy\" tool, we just make a PR or use cargo's patch feature or whatever.)</p>\n</blockquote>\n<p><code>ptr::read</code> lets you do this.</p>",
        "id": 209194003,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599336484
    },
    {
        "content": "<p>(And, by extension, <code>transmute_copy</code>)</p>",
        "id": 209194017,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599336534
    },
    {
        "content": "<p>That's not what ptr::read or transmute_copy are <em>for</em>, though- they target different use cases and only provide that functionality incidentally and in a totally unchecked way.</p>",
        "id": 209194035,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599336581
    },
    {
        "content": "<p>They provide no justification to extend the equivalent escape hatch here, mem::transmute, into NeglectStability</p>",
        "id": 209194079,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599336607
    },
    {
        "content": "<p>That may be the case, but there are explicit reasons that you want to be able to neglect stability: namely, if you are operating in the same crate in which a type is defined. On Fuchsia (the project I work on, and the project for which I created the <code>zerocopy</code> crate), we do this all the time.</p>",
        "id": 209194206,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599336888
    },
    {
        "content": "<p>If it's only for use within the same crate, then that job belongs to the visibility system, not the trait system. And then you get to my big spiel above about just exposing safe transmutability directly as an intrinsic.</p>",
        "id": 209194222,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599336936
    },
    {
        "content": "<p>That lets you \"neglect stability\" (or rather handle it by existing in the same unit of versioning) <em>safely</em>, in an MVP instead of gated on a hypothetical trait system extension.</p>",
        "id": 209194276,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337013
    },
    {
        "content": "<p>Ah I see your point. I believe there are still scenarios in which visibility alone doesn't cut it. Imagine you have a type which is public, and all of its fields are public. You may want to not promise stability of its layout, while still relying on its layout internally in your crate. Since the type is publicly constructible (in other words, it's visible as are all of its fields), you can't use the visibility system to allow you to make this distinction.</p>",
        "id": 209194508,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599337478
    },
    {
        "content": "<p>My big spiel above addresses that issue.</p>",
        "id": 209194513,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337504
    },
    {
        "content": "<p>Type layout is a separate thing that should have its own visibility, and code that can see it would be able to rely on its layout while code that cannot would have to go through its API, which may or may not include a Transmute.. impl</p>",
        "id": 209194562,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337565
    },
    {
        "content": "<p><code>transmute_copy</code> and <code>ptr::read</code> already ignore visibility, but they're unsafe <em>because</em> they're so unchecked, so instead of allowing a partly or fully checked way to accomplish those tasks... we should just not improve the situation at all? That's an unacceptable position</p>",
        "id": 209194578,
        "sender_full_name": "Lokathor",
        "timestamp": 1599337625
    },
    {
        "content": "<p>That's not my position!</p>",
        "id": 209194584,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337647
    },
    {
        "content": "<p>then I have misunderstood you</p>",
        "id": 209194624,
        "sender_full_name": "Lokathor",
        "timestamp": 1599337692
    },
    {
        "content": "<p>My position is that type authors need to retain control over the visibility of their type's layout, using the same rules and patterns as anything else with a visibility.</p>",
        "id": 209194641,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337771
    },
    {
        "content": "<blockquote>\n<p>Type layout is a separate thing that should have its own visibility, and code that can see it would be able to rely on its layout while code that cannot would have to go through its API, which may or may not include a Transmute.. impl</p>\n</blockquote>\n<p>Ah I understand now. That could work, but it would be a significant language change. It strikes me that the MVP proposed by the RFC is much simpler. Not to suggest that we don't want something like that eventually; we definitely might! But it would require a lot of careful design, and I don't think including it in this RFC is the best way of going about that.</p>",
        "id": 209194684,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599337807
    },
    {
        "content": "<p>It may be a larger language change than the RFC's MVP, but it's overall a <em>much much</em> smaller language change than the RFC's \"selective impl visibility\" stuff.</p>",
        "id": 209194698,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337855
    },
    {
        "content": "<p>And it enables what I believe to be a much nicer API. :)</p>",
        "id": 209194708,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337875
    },
    {
        "content": "<blockquote>\n<p>My position is that type authors need to retain control over the visibility of their type's layout, using the same rules and patterns as anything else with a visibility.</p>\n</blockquote>\n<p>and NeglectVisibility doesn't oppose that position. It says \"i dont care if it breaks later, just do it now\".</p>",
        "id": 209194709,
        "sender_full_name": "Lokathor",
        "timestamp": 1599337878
    },
    {
        "content": "<p>If I thought NeglectStability were consistent with my position, why would I be saying otherwise? Please try not to make brick-wall claims like this.</p>",
        "id": 209194721,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337913
    },
    {
        "content": "<p>That ability to say \"I don't care if it breaks later\" is <em>new</em> and <em>not something we should encourage</em>. If you need to access a type's layout, either convince the crate's author to make it (partially) public, or patch the crate yourself. This is no different from any other trait- Copy, Clone, Send, Sync, etc.</p>",
        "id": 209194769,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599337980
    },
    {
        "content": "<p>it is <em>not new</em> it's just <code>transmute_copy</code> but safer</p>",
        "id": 209194782,
        "sender_full_name": "Lokathor",
        "timestamp": 1599338010
    },
    {
        "content": "<p>transmute_copy is not intended for use as a \"let me ignore stability\" tool- using it as one is unsound!</p>",
        "id": 209194787,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338033
    },
    {
        "content": "<p>^ I suspect that without <code>NeglectStability</code>, people will just <em>keep using</em> <code>transmute</code> and <code>transmute_copy</code>.</p>",
        "id": 209194791,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599338040
    },
    {
        "content": "<p>And I don't think using it as such is unsound.</p>",
        "id": 209194832,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599338062
    },
    {
        "content": "<p>A bad idea, yes.</p>",
        "id": 209194834,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599338067
    },
    {
        "content": "<p>It is unsound unless you can somehow enforce that you are always built using an exact version of your dependency.</p>",
        "id": 209194846,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338099
    },
    {
        "content": "<p>Otherwise you need to see your code as, in a sense, polymorphic over all the versions you might ever be built against.</p>",
        "id": 209194852,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338120
    },
    {
        "content": "<p>You say \"somehow\", but pinning deps is <em>really</em> easy.</p>",
        "id": 209194854,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599338124
    },
    {
        "content": "<p>It's easy in cargo, but it's impossible in rust proper.</p>",
        "id": 209194857,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338140
    },
    {
        "content": "<p>The important distinction is that, if you depend on a type's layout using <code>transmute</code> or <code>transmute_copy</code>, and then the layout changes, your code will continue to compile, but it will be unsound. With <code>NeglectStability</code>, it will stop compiling. That's a <em>very</em> important distinction.</p>",
        "id": 209194858,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1599338146
    },
    {
        "content": "<p>And I don't think that's strictly true, either. E.g., You can use <code>transmute</code> to newtype and un-newtype a foreign type, regardless of whether that foreign type has made any documented stability promises.</p>",
        "id": 209194859,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599338146
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132362\">Joshua Liebow-Feeser</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209194858\">said</a>:</p>\n<blockquote>\n<p>The important distinction is that, if you depend on a type's layout using <code>transmute</code> or <code>transmute_copy</code>, and then the layout changes, your code will continue to compile, but it will be unsound. With <code>NeglectStability</code>, it will stop compiling. That's a <em>very</em> important distinction.</p>\n</blockquote>\n<p>That is an important distinction, but it's not completely true! It may continue to compile and do something weird.</p>",
        "id": 209194913,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338230
    },
    {
        "content": "<p>if you want to talk about rust in the absence of cargo, there's no concept of version anyway.</p>",
        "id": 209194916,
        "sender_full_name": "Lokathor",
        "timestamp": 1599338250
    },
    {
        "content": "<p>rust without cargo gets weird fast</p>",
        "id": 209194921,
        "sender_full_name": "Lokathor",
        "timestamp": 1599338272
    },
    {
        "content": "<p>This is quickly getting into the weeds, but my overall point is, \"people who would just use <code>transmute_copy</code>\" should <em>not</em> be our target audience as language designers! We should not be holding a bucket in a rainstorm trying to maximize the number of poor decisions we can make accidentally-correct.</p>",
        "id": 209194991,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338370
    },
    {
        "content": "<p>If people <em>are</em> overusing <code>transmute_copy</code>, then we should look at their use cases and address them directly, not give them the exact same tool with <em>slightly</em> more static checks, which still let them break things.</p>",
        "id": 209195053,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338413
    },
    {
        "content": "<p>Vendoring a dependency to add an impl to it is a big undertaking. I think people faced with the prospect of doing that will probably just continue to use whatever old wildly unsafe mechanism they're using. It's far easier to <em>pin</em> a dependency, and use <code>NeglectStability</code>.</p>",
        "id": 209195055,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599338417
    },
    {
        "content": "<p>It is not a big undertaking <em>at all</em>! We just had this discussion over in this thread: <a href=\"#narrow/stream/122651-general/topic/querying.20type.20niche.20status\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/querying.20type.20niche.20status</a></p>",
        "id": 209195083,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338480
    },
    {
        "content": "<p>All you have to do is git clone, add the impl, and then add a [patch] section to your cargo.toml.</p>",
        "id": 209195093,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338498
    },
    {
        "content": "<blockquote>\n<p>Type layout is a separate thing that should have its own visibility</p>\n</blockquote>\n<p>The RFC, quite intentionally, does not attempt to define \"layout\" (rather, it focuses on the definition of _transmutability_). We don't talk about the layouts of types being visible or private, but instead of transmutations being stable, or unstable (or unsafe, or unsound).</p>\n<p>Some aspects of a type's layout are <em>already</em> observable in completely safe code (e.g., size and alignment), and even more are observable with unsafe code. Designing a notion of \"visible layout\" that's compatible with the current state of Rust, and useful for transmutations, is a non-trivial task. I'm not confident that attempting this would make the RFC smaller.</p>",
        "id": 209195105,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599338521
    },
    {
        "content": "<p>When I say \"layout visibility\" I'm not attempting to imply <em>any</em> new definition work. I'm using it to refer to, precisely, the RFC's definition of scope-dependent implicit constructibility.</p>",
        "id": 209195159,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338576
    },
    {
        "content": "<p>People <em>are</em> overusing <code>transmute_copy</code>. And we <em>did</em> look at their use cases. This project has been going on quite a while, it is not an RFC out of the blue.</p>",
        "id": 209195169,
        "sender_full_name": "Lokathor",
        "timestamp": 1599338596
    },
    {
        "content": "<p>The difference between what I call public and private visibility is exactly the same difference as the RFC's \"PromiseTransmutable..\" impls.</p>",
        "id": 209195171,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338602
    },
    {
        "content": "<p>I'm quite happy with the RFC's definition of transmutability- that aspect seems to be quite direct and useful. All I'm trying to discuss here is how it's exposed in the language, because what I see in the RFC seems deeply unidiomatic and overly complex.</p>",
        "id": 209195277,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338738
    },
    {
        "content": "<p>If I'm inadvertently breaking a use case <em>other</em> than \"I want to ignore a foreign type's lack of publicly-guaranteed transmutability,\" I'm happy to explore the design space there. But that particular use case simply is not something I'm willing to entertain- we <em>already have</em> multiple solutions to that problem, and we should apply them here as well.</p>",
        "id": 209195423,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599338888
    },
    {
        "content": "<p>Can you clarify what about the API you feel is \"deeply unidomatic\"?</p>",
        "id": 209195452,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339000
    },
    {
        "content": "<p>(At the absolute minimum, if those solutions seem insufficient, then any extensions to them ought to be in their <em>own</em> RFC, not riders on the safe transmute RFC.)</p>",
        "id": 209195494,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339004
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209195452\">said</a>:</p>\n<blockquote>\n<p>Can you clarify what about the API you feel is \"deeply unidomatic\"?</p>\n</blockquote>\n<p>Nothing that hasn't already been said- it's trying to do the visibility system's job in the trait system, and then adding an escape hatch to make up for the trait system's inability to fully do that job. If something should be private, <em>make it private</em>, don't just hide it behind <code>NeglectStability</code>.</p>",
        "id": 209195513,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339085
    },
    {
        "content": "<p><code>NeglectStability</code> isn't an escape hatch for the trait system. It's there because stability and safety are <em>fundamentally</em> orthogonal.</p>",
        "id": 209195568,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339193
    },
    {
        "content": "<p>I am running out of ways to say this: nothing I'm proposing conflates stability and safety.</p>",
        "id": 209195574,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339221
    },
    {
        "content": "<p>It merely aligns the way they are expressed with the rest of the language.</p>",
        "id": 209195581,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339234
    },
    {
        "content": "<p>Are you proposing any mechanism that allows safe transmutations that are not stable?</p>",
        "id": 209195622,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339246
    },
    {
        "content": "<p>Yes! Please read my giant response above! :(</p>",
        "id": 209195629,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339264
    },
    {
        "content": "<p>For example, a \"tell\" to me that NeglectStability <em>is</em> an escape hatch is that <span class=\"user-mention\" data-user-id=\"132362\">@Joshua Liebow-Feeser</span> mentioned the use case of \"use it in the same crate as the type definition.\" With my giant spiel above, that is a non-issue, because you can just use the core intrinsic and it will decide whether the transmutation is allowed <em>directly</em> based on visibility, the same way <code>TransmuteFrom&lt;T, NeglectStability&gt;</code> would in the full version of the RFC.</p>",
        "id": 209195693,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339395
    },
    {
        "content": "<p>In other words, instead of forcing the transmute-er to manually decide whether they want to use the type's public or private API, we should simply select the correct API based on source position, and close the escape hatch of the transmute-er deciding on the private API when they should not.</p>",
        "id": 209195786,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339542
    },
    {
        "content": "<p>If it helps simplify what I'm trying to suggest, you might (loosely) think of it as \"make <code>TransmuteFrom&lt;T, NeglectStability&gt;</code> into an intrinsic like <code>mem::transmute</code>, and build the rest on top of that.\"</p>",
        "id": 209195797,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339588
    },
    {
        "content": "<p>That's more or less how I already think of it.</p>\n<p>See line 132 here: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=1ff1700e6dba595f1e600d20da5d6387\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=1ff1700e6dba595f1e600d20da5d6387</a></p>",
        "id": 209195846,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339623
    },
    {
        "content": "<p>Er, no, I specifically mean \"an intrinsic which is not a trait impl\" because that is a very very important distinction.</p>",
        "id": 209195854,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339658
    },
    {
        "content": "<p>I imagine that that impl is swapped out with a compiler supported one. Everything else is built on top of that.</p>",
        "id": 209195855,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339661
    },
    {
        "content": "<p>And the reason I use the trait impl as the intrinsic, rather than some <code>can_transmute</code> predicate  is because traits can be abstracted over. A primary goal of this RFC is to create an API surface with abstractions can be built.</p>",
        "id": 209195873,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339715
    },
    {
        "content": "<p>I also address that in my giant spiel- abstraction is not really necessary at this level, and brings with it a major cost- it forces the operation to become universally available, opening the hole I keep complaining about.</p>",
        "id": 209195919,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339770
    },
    {
        "content": "<p>Can you sketch out the API surface you think would work?</p>",
        "id": 209195979,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339882
    },
    {
        "content": "<p>I tried to do so in my giant spiel.</p>",
        "id": 209195987,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339899
    },
    {
        "content": "<p>If your design can't be used to make abstractions that sounds poor</p>",
        "id": 209195995,
        "sender_full_name": "Lokathor",
        "timestamp": 1599339906
    },
    {
        "content": "<p>Yes, but with code.</p>",
        "id": 209195997,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339909
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> it can be used to make abstractions, that's my entire point...</p>",
        "id": 209196010,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339932
    },
    {
        "content": "<p>(You also mentioned ditching the <code>Neglect</code> parameter of <code>TransmuteFrom</code>, and I'm not sure how that all fits into this.)</p>",
        "id": 209196018,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599339949
    },
    {
        "content": "<p>Not so much ditching as moving out of the trait system.</p>",
        "id": 209196066,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599339971
    },
    {
        "content": "<p>...but traits are Rust's primary abstraction mechanism for working with types.</p>",
        "id": 209196095,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340034
    },
    {
        "content": "<p>Can't do generics without traits</p>",
        "id": 209196100,
        "sender_full_name": "Lokathor",
        "timestamp": 1599340065
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> I'm not sure what code you're asking for. I'm suggesting that the MVP only needs to be a single new intrinsice: <code>fn safe_transmute&lt;T, U&gt;(t: T) -&gt; U</code>, which is callable in precisely the same circumstances as <code>TransmuteFrom&lt;T, NeglectStability&gt; for U</code> would exist.</p>",
        "id": 209196101,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340069
    },
    {
        "content": "<p>If I want to use that function in a generic context, I'm going to need to repeat whatever <code>where</code> bound is on it.</p>",
        "id": 209196141,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340103
    },
    {
        "content": "<p>If there's no <code>where</code> bound that constrains its types, then it seems about as useful for abstractions as <code>mem::transmute</code>.</p>",
        "id": 209196151,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340154
    },
    {
        "content": "<p>It starts with no where bounds, like mem::transmute, just like the RFC starts with no way to use NeglectStability safely. If Rust ever gets position-dependent impls, then its where bounds can become something like <code>where U: MagicalTransmuteFrom&lt;T&gt;</code></p>",
        "id": 209196156,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340166
    },
    {
        "content": "<p>Are there any traits at all in your MVP?</p>",
        "id": 209196162,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340190
    },
    {
        "content": "<p>There don't need to be! :)</p>",
        "id": 209196164,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340199
    },
    {
        "content": "<p>How do I build abstractions like <a href=\"https://github.com/rust-lang/project-safe-transmute/blob/master/rfcs/0000-ext-container-casting.md\">Slice Casting</a> on top of it then?</p>",
        "id": 209196210,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340235
    },
    {
        "content": "<p>You can implement something like PromiseTransmutable.. purely in userspace on top of that intrinsic. You could include it in an initial implementation if it's more convenient, or leave it up to the ecosystem if there is still room for designing.</p>",
        "id": 209196211,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340240
    },
    {
        "content": "<p>how do you make it so that a library transmutes a user's type for them?</p>",
        "id": 209196218,
        "sender_full_name": "Lokathor",
        "timestamp": 1599340297
    },
    {
        "content": "<p><code>PromiseTransmutableInto</code> looks like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">PromiseTransmutableInto</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Archetype</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NeglectStability</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>It's only safe because I can bound the <code>Archetype</code> with a trait. What bound would I put there in your proposal?</p>",
        "id": 209196219,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340302
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209196218\">said</a>:</p>\n<blockquote>\n<p>how do you make it so that a library transmutes a user's type for them?</p>\n</blockquote>\n<p>Require them to implement a trait. The impl is non-polymorphic and can use the intrinsic; the library dispatches via the trait.</p>",
        "id": 209196265,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340354
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209196219\">said</a>:</p>\n<blockquote>\n<p><code>PromiseTransmutableInto</code> looks like this:<br>\n[...]<br>\nIt's only safe because I can bound the <code>Archetype</code> with a trait. What bound would I put there in your proposal?</p>\n</blockquote>\n<p>Replace the associated type with a call to the intrinsic. It provides the same sort of proof discharge.</p>",
        "id": 209196281,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340401
    },
    {
        "content": "<p>(I covered this in the middle bullet point of the spiel.)</p>",
        "id": 209196285,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340435
    },
    {
        "content": "<p><a href=\"https://docs.rs/generic-array/0.14.4/generic_array/\">generic-array</a> is probably going to want to write an impl like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">PromiseTransmutableFrom</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">PromiseTransmutableFrom</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">N</span>: <span class=\"nc\">ArrayLength</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"c1\">// for lack of implied bounds, we must repeat the bounds on `Archetype`:</span>\n<span class=\"w\">    </span><span class=\"n\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>::<span class=\"n\">Archetype</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span>: <span class=\"nc\">TransmuteInto</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NeglectStability</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">PromiseTransmutableFrom</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Archetype</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>::<span class=\"n\">Archetype</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 209196322,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340454
    },
    {
        "content": "<p>what's the intrinsic call?</p>",
        "id": 209196324,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340462
    },
    {
        "content": "<p>Something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TransmutableFrom</span><span class=\"o\">&lt;</span><span class=\"n\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">PublicLayout</span><span class=\"o\">&lt;</span><span class=\"n\">Archetype</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">N</span>: <span class=\"nc\">ArrayLength</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">transmute_from</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"nc\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">safe_transmute</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 209196452,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340721
    },
    {
        "content": "<p>You own GenericArray there, so you get access to whatever NeglectStability would.</p>",
        "id": 209196460,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340753
    },
    {
        "content": "<p>That is, the intrinsic can see GenericArray, and it can see into its fields, so the only \"tricky\" part here is when it hits the T-&gt;U transmute.</p>",
        "id": 209196518,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340856
    },
    {
        "content": "<p>Transmutation isn't just about transmutation, though. Calling <code>transmute</code> isn't always a meaningful thing to do.</p>\n<p>It's not sensible in the case of slice casting:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">cast</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;i</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"na\">&#39;o</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">src</span>: <span class=\"kp\">&amp;</span><span class=\"na\">&#39;i</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Src</span><span class=\"p\">])</span><span class=\"w\"> </span>-&gt; <span class=\"kp\">&amp;</span><span class=\"na\">&#39;o</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Dst</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">&amp;</span><span class=\"na\">&#39;o</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Dst</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">]</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;&amp;</span><span class=\"na\">&#39;i</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Src</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"kt\">usize</span>::<span class=\"n\">MAX</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">size_of_val</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">).</span><span class=\"n\">checked_div</span><span class=\"p\">(</span><span class=\"n\">size_of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Dst</span><span class=\"o\">&gt;</span><span class=\"p\">()).</span><span class=\"n\">unwrap_or</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">slice</span>::<span class=\"n\">from_raw_parts</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"p\">.</span><span class=\"n\">as_ptr</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">len</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>and it's DEFINITELY not sensible with an <code>AlignLtEq</code> trait:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"sd\">/// Implemented if `align_of::&lt;Self&gt;() &lt;= align_of::&lt;Rhs&gt;()`</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">AlignLtEq</span><span class=\"o\">&lt;</span><span class=\"n\">Rhs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"o\">=</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Neglect</span>: <span class=\"nc\">TransmuteOptions</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Lhs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Rhs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">AlignLtEq</span><span class=\"o\">&lt;</span><span class=\"n\">Rhs</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Lhs</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Neglect</span>: <span class=\"nc\">TransmuteOptions</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"o\">&lt;</span><span class=\"na\">&#39;a</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Lhs</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">]</span>: <span class=\"nc\">TransmuteFrom</span><span class=\"o\">&lt;&amp;</span><span class=\"na\">&#39;a</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">Rhs</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>In these examples, trait bound is used as a proof of some property for purposes other than transmutation.</p>",
        "id": 209196533,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599340914
    },
    {
        "content": "<p>To avoid punching holes in the visibility system, that T-&gt;U transmute should only be performable by this code if either a) T and U have visible layouts here, which requires the hypothetical trait system extension to write a bound for, or b) T and U have exposed their layouts via a TransmuteFrom impl.</p>",
        "id": 209196574,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599340945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209196452\">said</a>:</p>\n<blockquote>\n<p>Something like this:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TransmutableFrom</span><span class=\"o\">&lt;</span><span class=\"n\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">PublicLayout</span><span class=\"o\">&lt;</span><span class=\"n\">Archetype</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">N</span>: <span class=\"nc\">ArrayLength</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">transmute_from</span><span class=\"p\">(</span><span class=\"n\">t</span>: <span class=\"nc\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">GenericArray</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">safe_transmute</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n</blockquote>\n<p>Does <code>safe_transmute</code> have any static restrictions on its type parameters, or is it only callable in a monomorphic context like <code>mem_transmute</code>? If it either of these are true, this won't compile.</p>",
        "id": 209196626,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341048
    },
    {
        "content": "<p>(This does imply that some use cases will need the intrinsic to understand and use a <code>TransmuteFrom</code> trait.)</p>",
        "id": 209196629,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341057
    },
    {
        "content": "<p><code>mem::transmute</code> is not only callable in monomorphic contexts. You can, for example, transmute a &amp;T to a &amp;U.</p>",
        "id": 209196639,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341092
    },
    {
        "content": "<p>Only because it effectively erases those types away!</p>",
        "id": 209196645,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341117
    },
    {
        "content": "<p>Doesn't mean a new intrinsic couldn't pay attention to them. ;)</p>",
        "id": 209196648,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341134
    },
    {
        "content": "<p>...and thus be subject to the same monomorphization restriction?</p>",
        "id": 209196695,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341178
    },
    {
        "content": "<p>No, see my parenthetical- there's no reason it can't look for trait impls on them.</p>",
        "id": 209196701,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341208
    },
    {
        "content": "<p>At this point, let me propose a thought experiment: Imagine a hybrid of the RFC with this approach, where the lang-item is a trait like the RFC, but the trait has no options parameter. Instead, there are two traits- TransmuteFromPrivate and TransmuteFrom. Does <em>this</em> change on its own seem plausible to you, at least?</p>",
        "id": 209196761,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341300
    },
    {
        "content": "<p>I don't like it, but I can imagine it.</p>",
        "id": 209196770,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341347
    },
    {
        "content": "<p>That's the direction I'm aiming for with the non-trait version. Remove knobs and dials and hole-punches from the primary <code>TransmuteFrom</code> trait, and isolate them to impl bodies.</p>",
        "id": 209196822,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341411
    },
    {
        "content": "<p>The knobs and dials are kinda important.</p>",
        "id": 209196828,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341446
    },
    {
        "content": "<p>But not for every use case!</p>",
        "id": 209196831,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341458
    },
    {
        "content": "<p>That's why the <code>Neglect</code> parameter is defaulted.</p>",
        "id": 209196835,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341469
    },
    {
        "content": "<p>Mostly they are important in the \"glue\" that enables the actual end use cases.</p>",
        "id": 209196836,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341472
    },
    {
        "content": "<p>Defaulting is perhaps better than forcing everyone to write (), but it does not close the visibility hole.</p>",
        "id": 209196840,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341499
    },
    {
        "content": "<p>It may well be that my version is worse than the trait version when it comes to implementing the glue. But I'm not starting from the premise that we must use a function rather than a trait! I'm starting from the premise that we must re-use and integrate with Rust's existing mechanisms for stability.</p>",
        "id": 209196883,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341545
    },
    {
        "content": "<p>Which, before anyone contradicts that again, <code>NeglectStability</code> does <em>not</em> do.</p>",
        "id": 209196889,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341585
    },
    {
        "content": "<p>(I'm just about out of time for this discussion today; hopefully I conveyed at least a little of what I intended to. I can discuss this more another time.)</p>",
        "id": 209196939,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341675
    },
    {
        "content": "<p>I don't view this issue as at all novel. What's the distinction between the impl <code>Dst: TransmuteFrom&lt;Src, NeglectStability</code> not being stable, and the return value of  <code>align_of</code>/<code>size_of</code> not being stable?</p>",
        "id": 209196940,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341677
    },
    {
        "content": "<p>The whole point of this RFC is to lift aspects of layout into the trait system.</p>",
        "id": 209196942,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341698
    },
    {
        "content": "<p>It's not surprising that the same instabilities would apply.</p>",
        "id": 209196951,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341716
    },
    {
        "content": "<p>If anything, the \"idiomatic\" thing to do would be, like those <code>mem</code> intrinsics, to make no attempt to close the stability hole at all!</p>",
        "id": 209196957,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599341758
    },
    {
        "content": "<p>Alright I'll answer that one. <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span> I've said this before, but <code>align_of</code>/<code>size_of</code> are both super-early features that were not designed with our current understanding of stability. They are already causing problems (e.g. with <code>extern type</code>), and thus are not justification to create more APIs with the same pitfalls.</p>",
        "id": 209197000,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341788
    },
    {
        "content": "<p>I do agree(?) that giving generic code access to safe transmutation is quite a good goal. I just think that we shouldn't make the align_of/size_of problem any worse in doing so.</p>",
        "id": 209197005,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341865
    },
    {
        "content": "<p>To be fair, though, before I read the RFC I would not have been too upset by leaving the hole completely open, either! It's the in-between state that bothers me, where the API pays the complexity cost to avoid the hold but doesn't actually close it.</p>",
        "id": 209197056,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599341963
    },
    {
        "content": "<p>(i.e. I would personally be open to considering <code>#[repr(C)]</code> sufficient to mark a type's layout as public)</p>",
        "id": 209197099,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599342005
    },
    {
        "content": "<p>That's not back-compat. :(</p>",
        "id": 209197100,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599342026
    },
    {
        "content": "<p>nobody ever actually officially articulated that's the case, so we can't apply that rule to old rust code.</p>",
        "id": 209197107,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599342088
    },
    {
        "content": "<p>Ohh right in the sense that new, safe-transmute-using code could break by switching between two <em>already existing</em> old versions of a dep.</p>",
        "id": 209197109,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599342094
    },
    {
        "content": "<p>Well that's sad but it doesn't really change the overall design space at this point I guess.</p>",
        "id": 209197114,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599342119
    },
    {
        "content": "<p>that only affects people who #YOLO, <code>NeglectStability</code>, and transmute anyways</p>",
        "id": 209197160,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599342129
    },
    {
        "content": "<p>retroactively changing the meaning of <code>repr(C)</code> would foist new stability requirements on everyone, including those who aren't transmuting</p>",
        "id": 209197164,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599342152
    },
    {
        "content": "<p>It also occurs to me that a hypothetical <code>#[repr(pub)]</code> would, at a wishy-washy intuitive level, mirror what Swift does at API boundaries to let library authors choose between layout optimization and caller optimization.</p>",
        "id": 209197224,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599342260
    },
    {
        "content": "<p>Sorry if I misrepresent your proposal, <span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> , but what I understand is that you would like to flip who is in charge of allowing NeglectStability, from the destination type to the source type, by adding an intrinsic (transmute_safe), used to request that visibility breaking behavior (if allowed by the source type and requested by the user). That way the source type keeps visibility control and, possibly, only trait impls would be needed on it (probably mostly derived). Also, visibility breakage is contained at the language level (the intrinsic), with consent from the source type implementor.</p>\n<p>Sorry you both of this is nonsense, I'm a total noobie, but find this conversation fascinating.</p>",
        "id": 209203007,
        "sender_full_name": "pachi",
        "timestamp": 1599354784
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132362\">Joshua Liebow-Feeser</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209192590\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> </p>\n<blockquote>\n<p>NeglectStability indeed seems like a big can of worms</p>\n</blockquote>\n<p>Not sure I follow; what's the can of worms?</p>\n</blockquote>\n<p>I might be missing something, but doesn't this break semver? Any crate using <code>NeglectStability</code> risks failing to build/run after a semver-compatible update -- right? This is dangerously close to abstraction-breaking mechanisms such as reflection, an in the Rust ecosystem where our entire safety story relies on good non-leaky abstractions, that is playing with fire.</p>",
        "id": 209215105,
        "sender_full_name": "RalfJ",
        "timestamp": 1599380244
    },
    {
        "content": "<blockquote>\n<p>because, in principle, safety is orthogonal to stability.</p>\n</blockquote>\n<p>That is... maybe technically true but IMO not true in any useful way. There is a deep connection between good solid abstractions and the kind of safe encapsulation that Rust relies on. <a href=\"https://www.youtube.com/watch?v=8Xyk_dGcAwk\">This talk</a> explains the connection:<br>\nThe gist is that if Rust had reflection, there would be no encapsulation of unsafe code behind a safe interface -- at least, not in any precise formal sense. Needless to say, Rust without safe encapsulation is basically a useless language. Reflection here is of course just a stand-in for any abstraction-breaking mechanism.</p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"8Xyk_dGcAwk\" href=\"https://www.youtube.com/watch?v=8Xyk_dGcAwk\"><img src=\"https://i.ytimg.com/vi/8Xyk_dGcAwk/default.jpg\"></a></div>",
        "id": 209215169,
        "sender_full_name": "RalfJ",
        "timestamp": 1599380401
    },
    {
        "content": "<p>I only skimmed the rest of the lively discussion, but the claim that stability and safety are orthogonal was repeated again and I just don't think that's a good view of things. Stability is closely tied to \"abstraction\" in the sense of \"implementation details of a crate are not observable\", and abstraction is <em>crucial</em> for Rust's safety story.</p>",
        "id": 209215310,
        "sender_full_name": "RalfJ",
        "timestamp": 1599380667
    },
    {
        "content": "<p>Enough people have said that they need to \"break\" semver, and thereby basically break abstraction, for one reason or another that I cannot outright dismiss that usecase -- but I think the discussion of whether and how we want to explicitly support something like this should be separated from the rest of the RFC. Its concerns are way different, and it is much more likely to be controversial. It's not helpful to block the rest of the RFC on disagreements about how important stability is. That's why I called it a can of worms.</p>",
        "id": 209215376,
        "sender_full_name": "RalfJ",
        "timestamp": 1599380854
    },
    {
        "content": "<p>Hm okay I guess the point of <code>NeglectStability</code> is that compilation is still guaranteed to fail if the assumptions the downstream crate is making are wrong? I'll have to think about how that changes things.</p>",
        "id": 209215482,
        "sender_full_name": "RalfJ",
        "timestamp": 1599381083
    },
    {
        "content": "<p>After reading the RFC properly, I think I understand <code>NeglectStability</code> better now -- the point is that if this is used to break through an abstraction, and then later the \"invaded\" crate changes, we get a static compilation failure, not UB or so. That is still a big problem, but <em>on its own</em> does not impede safety.<br>\nHowever, I remain worried about the larger ecosystem consequences -- will people start using <code>=1.2.3</code> dependencies to make block even semver-compatible updates? will that mean that soundness and other fixes have a harder time propagating through the ecosystem?</p>",
        "id": 209220648,
        "sender_full_name": "RalfJ",
        "timestamp": 1599390738
    },
    {
        "content": "<p>Like an earlier comment in this discussion,I'm also wondering why NeglectStability is something the caller can specify, rather than some annotation on the source type.</p>",
        "id": 209235132,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1599415425
    },
    {
        "content": "<p>In a sense, it does require an annotation <code>#[repr(C)]</code> on the involved types.</p>\n<p>The intuition is sorta like we're taking <code>core::mem</code> intrinsics and lifting them to a type-level. Just as whether <code>size_of::&lt;T&gt;() == 0</code> is satisfied isn't part of <code>T</code>'s stability guarantee, neither does whether the bound <code>T: TransmuteFrom&lt;(), NeglectStability&gt;</code> is satisfied. (We do try to make this instability a little more obvious in our RFC than it is with <code>size_of</code>, though.)</p>\n<p>Unfortunately, I don't think any of us anticipated the argument that Rust perhaps <em>shouldn't</em> have had a general <code>size_of</code> function.</p>",
        "id": 209235807,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599416555
    },
    {
        "content": "<p>It is <strong>not</strong> okay to use <code>NeglectStability</code> to break abstraction. Even with <code>NeglectStability</code>, you can only transmute into a type which is fully-implicitly constructable.</p>\n<p>(Under the simplified formulation of constructability, this isn't <em>totally</em> enforced due to the pub-in-priv trick. We recommend that while the simplified formulation of constructability is used, the documentation for <code>PromiseTransmutable*</code> make <em>very</em> clear that these traits <em>must not</em> be implemented on any type using the pub-in-priv trick to restrict constructability! To do so anyways would be to violate the contract of <code>PromiseTransmutable*</code>.)</p>\n<p>The RFC <em>does</em> pose a potential future <a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#design-of-neglectconstructability\"><code>NeglectConstructability</code></a> option that <em>would</em> break abstraction. It's listed as out-of-scope precisely <em>because</em> it's an utter can-of-worms.</p>",
        "id": 209235991,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599416873
    },
    {
        "content": "<p>I suppose the most-robust thing to do would be to mark the <code>PromiseTransmutable*</code> traits as unsafe for as long as the simplified version of constructability is used.</p>\n<p>However, currently, making an <code>unsafe</code> trait safe is forbidden by rust—I'm not really sure why. E.g.:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<div class=\"codehilite\"><pre><span></span><code>error[E0199]: implementing the trait `Foo` is not unsafe\n --&gt; src/lib.rs:4:1\n  |\n4 | unsafe impl Foo for Bar {}\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n</code></pre></div>\n\n\n<p>Is there a fundamental reason for this?</p>",
        "id": 209236145,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599417116
    },
    {
        "content": "<p>What would be the point of that? You might be conflating the 2 meanings of unsafe here (ughh) - an unsafe on the implementation requires you to discharge a proof obligation specified by the trait, but if there is no such proof obligation, there is nothing to discharge.</p>",
        "id": 209240631,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599424525
    },
    {
        "content": "<p>There <em>is</em>, arguably, a proof obligation with the simplified formulation of constructibility: that you are not bypassing the requirement of implicit constructibility with the pub in priv trick.</p>",
        "id": 209240767,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599424773
    },
    {
        "content": "<p>So you'd need to mark the trait unsafe (and declare a proof obligation).</p>",
        "id": 209240886,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599424954
    },
    {
        "content": "<p>That seems reasonable.</p>",
        "id": 209241136,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599425466
    },
    {
        "content": "<p>If I'm reading this right, the proof obligation would be that all values allowed solely by a recursive field-check can be allowed, ie, no bitpatterns that rustc allows for a given field must be invalid due to library invariants?</p>\n<p>Which in practice basically just rules out pub-in-priv?</p>",
        "id": 209241248,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599425687
    },
    {
        "content": "<p>Under the simplified formulation of constructability, your proof obligation is that you don't implement <code>PromiseTransmutableFrom/Into</code> on your type if you are using the pub-in-priv trick to constrain its implicit constructability. This isn't asking a lot of end-users. If they're implementing <code>PromiseTransmutableFrom</code>, they're explicitly signaling that they promise their type should be instantiatable via transmutation—that's functionally equivalent to making the type itself fully implicitly constructable.</p>\n<p>Under the full formulation of constructability, you don't have a manual proof obligation: the trait <code>bound</code> on <code>Archetype</code> enforces all safety properties.</p>",
        "id": 209241662,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599426414
    },
    {
        "content": "<p>I apologize if this was discussed, I read the entire discussion but I may have been lost in the weeds. Is it difficult to enforce a full definition of constructability compiler wise? Ie, by treating any non fully constructible field as private.</p>",
        "id": 209241718,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599426514
    },
    {
        "content": "<blockquote>\n<p>Is it difficult to enforce a full definition of constructability compiler wise?</p>\n</blockquote>\n<p>In the general case, yeah. The problem is that to figure out whether a field type is implicitly constructable, you have to determine whether that type is visible from the perspective of whether the transmutation is occuring.</p>\n<p>Because Rust permits the pub-in-priv trick, just because a field is <code>pub</code>, and its type is <code>pub</code> doesn't mean that field is <em>actually</em> visible: it could be inside a private module.</p>\n<p>To resolve these sorts of situations, you need to actually take scope into account—it's not sufficient to just look for <code>pub</code> keywords on fields (which is exactly what the simplified formulation does).</p>",
        "id": 209241851,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599426728
    },
    {
        "content": "<p>It's not inconceivable that Rust could do this <em>someday</em> (and there are some aspects of <code>TransmutableFrom</code> that probably make it slightly easier than a full-blown scoped-impls feature), and so the RFC is careful to be forwards-compatible with this possibility.</p>",
        "id": 209241916,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599426904
    },
    {
        "content": "<p>It'd be a big undertaking, though, and I don't think it's practical to block safe transmutation efforts on implementing a complete formulation of constructability.</p>\n<p>The pub-in-priv trick is rather niche, and if you're using it on a struct field, you're definitely doing so to restrict the struct's implicit constructability. If that's your intent, implementing <code>PromiseTransmutableFrom</code> is nonsensical, anyways.</p>",
        "id": 209242019,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599427096
    },
    {
        "content": "<p>Got it. The only downside though is that you can't make an unsafe trait safe to implement without breakage (as you've discovered, so it'll probably be a blocker to stabilization either way.</p>",
        "id": 209246289,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599434686
    },
    {
        "content": "<p>Not really. There's no fundamental issue with the trait remaining <code>unsafe</code> even after the full formulation of constructability is implemented, other than it being scarier-than-necessary to <code>impl</code>.</p>\n<p>The limitation that you can't <code>unsafe</code> impl a safe trait seems totally artificial, too. That restriction could probably be lifted entirely, or special-cased for <code>PromiseTransmutable*</code> so it can be someday made safe without breaking old <code>unsafe</code> impls.</p>\n<p>Regardless, this is probably <em>waaaaaay</em> off in the future.</p>",
        "id": 209246535,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599435184
    },
    {
        "content": "<p>I also just realized that being fully implictly constructibke Repr-C structs limits any potential breakage with NeglectStability dramatically. I'm not sure what semver wrt to these types of structs says, but I doubt this will make any impact. There is not a lot you could/want to do with these restrictions in place.</p>",
        "id": 209247369,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599436714
    },
    {
        "content": "<p>That's true, and a little frustrating. The <code>Archetype</code> system is expressive enough to let you pull tricks like adding new fields where there was padding, but the other side-effects of <code>pub</code> are <em>really</em> constricting: if all your fields are <code>pub</code>, you <em>can't</em> add a new field, because that breaks anybody pattern matching who isn't using <code>..</code>.</p>",
        "id": 209249194,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599440071
    },
    {
        "content": "<p>So, you might very well add a private dummy field to a type, just to prevent people from fully-destructuring it—not to restrict its constructability. (heh, it's destructibility <em>vs</em> constructability...)</p>",
        "id": 209249836,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599441466
    },
    {
        "content": "<p>I'm going to need to sleep on this. I think some of these use cases are covered by <a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#stability-of-unsafe-transmutations\">forward-compat extension</a> to the RFC, which would allow type authors to make stable transmutations that neglect, e.g., constructability.</p>",
        "id": 209249881,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599441539
    },
    {
        "content": "<p>I'm curious as to why the PromiseTransmutable traits themselves do not discharge the proof obligation of implicit constructability. I remember (though this may have been my imagination), that an early draft of the RFC stated that an archetype containing private fields would require NeglectValidity in order to transmute.</p>\n<p>Sorry if this was asked already, but I scrolled through roughly 200 messages and didn't find a mention, and my zulip-fu isn't too good.</p>",
        "id": 209250711,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599443157
    },
    {
        "content": "<blockquote>\n<p>I remember (though this may have been my imagination), that an early draft of the RFC stated that an archetype containing private fields would require NeglectValidity in order to transmute.</p>\n</blockquote>\n<p>In an earlier draft, it required <code>NeglectVisibility</code>. Yeah, that got taken out. There's some prose on an equivalent \"<code>NeglectConstructability</code>\" though!</p>",
        "id": 209250772,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599443274
    },
    {
        "content": "<p>The type bound of <code>Archetype</code> <em>does</em>, in theory, enforce implicit constructability.</p>",
        "id": 209250814,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599443299
    },
    {
        "content": "<p>However, the simplified formulation of constructability has a soundness hole, so as long as the simplified formulation is used, the obligation not to abuse that soundness hole falls on <code>impl</code>s of <code>PromiseTransmutable*</code></p>",
        "id": 209250827,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599443351
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209247369\">said</a>:</p>\n<blockquote>\n<p>I also just realized that being fully implictly constructibke Repr-C structs limits any potential breakage with NeglectStability dramatically. I'm not sure what semver wrt to these types of structs says, but I doubt this will make any impact. There is not a lot you could/want to do with these restrictions in place.</p>\n</blockquote>\n<p>This observation makes me think there's a <em>really</em> good chance I'm going to be revisiting the stability traits.</p>\n<p>If a type is implicitly constructible, it's <em>already</em> effectively stably transmutable (if its constituent parts are transmutable), since <em>all</em> of the details of the type are public. You can't do much, or <em>anything</em> to change it.</p>\n<p>It's only when a type <em>isn't</em> implicitly constructible (i.e., it has private fields) that <code>PromiseTransmutable*::Archetype</code> gets interesting. If there's a private field, that means you <em>can</em>, for instance, add fields without breaking destructurings.</p>",
        "id": 209250989,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599443667
    },
    {
        "content": "<p>(Gah. The range of things in Rust which can be breaking changes is staggeringly complex!)</p>",
        "id": 209251042,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599443797
    },
    {
        "content": "<blockquote>\n<p>If a type is implicitly constructible, it's already effectively stably transmutable (if its constituent parts are transmutable), since all of the details of the type are public. You can't do much, or anything to change it.</p>\n</blockquote>\n<p>You can reorder fields... and that's about it I think.^^ I guess one could argue that <code>repr(C)</code> promises field order stability but I am not sure if that is widely accepted.</p>",
        "id": 209296881,
        "sender_full_name": "RalfJ",
        "timestamp": 1599486122
    },
    {
        "content": "<p>I can tell you that it's at least accepted among the various Discord communities for Rust.</p>",
        "id": 209316389,
        "sender_full_name": "Lokathor",
        "timestamp": 1599500094
    },
    {
        "content": "<p>Hmm, just going to throw out some musings here.</p>\n<p>The main thing to note here is that safe transmutation (with a layout guarantee) is logically identical to a recursive field-by-field transmute and calling implicit constructors. We get the observation that <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> made that for a transmutation to be safe - the struct must be fully implicitly constructible. </p>\n<p>An MVP for safe transmutation then, could completely <strong>ignore</strong> weak-stability guarantees - the only guarantee possible would be the one the derive makes. We could keep the RFC and NeglectStability exactly the same - the only break NeglectStabiliy could manifest would be field reorderings of a fully implicitly constructible <code>repr(C)</code> struct, which imo is in all honesty a very small issue.</p>\n<p>Basically this is just a wall of text way of saying I think the only change we could make to NeglectStability would be to remove it - if it turns out field reordering is already a semver breaking change in this context.</p>",
        "id": 209319385,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599503513
    },
    {
        "content": "<p>An even more MVP approach would be to ignore references and NeglectValidity/Alignment entirely (and go fully safe), but that might be a little bit heavy handed.</p>",
        "id": 209320027,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599504006
    },
    {
        "content": "<p>MVP in the RFC doesn't necessarily include NeglectValidity/Alignment.</p>\n<p>Ignoring references altogether is too minimal. They're not at all difficult to include, though.</p>",
        "id": 209320143,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599504117
    },
    {
        "content": "<p>Oh wait, a reference transmutation could be made fully safe. Hmm, I think focusing on the safe API (+ the soundness hole) in the RFC, removing weak stability, and shunting the implementation over to a separate doc (modulo the soundness hole) would really help readability.</p>",
        "id": 209321022,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1599504946
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209250989\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Stability.20and.20visibility/near/209247369\">said</a>:</p>\n<blockquote>\n<p>I also just realized that being fully implictly constructibke Repr-C structs limits any potential breakage with NeglectStability dramatically. I'm not sure what semver wrt to these types of structs says, but I doubt this will make any impact. There is not a lot you could/want to do with these restrictions in place.</p>\n</blockquote>\n<p>This observation makes me think there's a <em>really</em> good chance I'm going to be revisiting the stability traits.</p>\n<p>If a type is implicitly constructible, it's <em>already</em> effectively stably transmutable (if its constituent parts are transmutable), since <em>all</em> of the details of the type are public. You can't do much, or <em>anything</em> to change it.</p>\n<p>It's only when a type <em>isn't</em> implicitly constructible (i.e., it has private fields) that <code>PromiseTransmutable*::Archetype</code> gets interesting. If there's a private field, that means you <em>can</em>, for instance, add fields without breaking destructurings.</p>\n</blockquote>\n<p>These observations made me think that the bounds on <code>PromiseTransmutable*</code>'s <code>Archetype</code> should be relaxed such that <code>Self</code> <em>could</em> have private fields; e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">PromiseTransmutableFrom</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">Self</span>::<span class=\"n\">Archetype</span>: <span class=\"nc\">PromiseTransmutableFrom</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Archetype</span>: <span class=\"nc\">TransmuteInto</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">NeglectConstructability</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NeglectStability</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>Then I realized this use-case is <em>already</em> supported with the current definitions under the full formulation of constructability. Your <code>Archetype</code> and <code>Self</code> <strong>are</strong> (usually) going to be fully implicitly constructible from the perspective of your <code>PromiseTransmutable*</code> impl, because they (usually) live right next to each other.</p>\n<p>The full formulation of constructability really opens a lot of doors without further complicating the model or sacrificing the ability build type-level abstractions. <span aria-label=\"slight frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"slight frown\">:slight_frown:</span></p>",
        "id": 209552173,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599677503
    },
    {
        "content": "<p>Rather than continuing to attack this problem from the angle of carefully compromising on safety, I'm curious if we can formulate full implicit constructability in a way that wouldn't actually be too impractical implement in the near-term.</p>\n<p>Here's an idea:</p>\n<ul>\n<li>The compiler implements <code>T: Constructible&lt;S&gt;</code> if <code>T</code> is fully implicitly constructible in the scope <code>S</code>.</li>\n<li>The <code>here!()</code> macro produces an opaque <code>Scope</code> type/value which uniquely represents the invocation scope of the macro.</li>\n</ul>\n<p>e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">mod</span> <span class=\"nn\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"n\">private</span>::<span class=\"n\">Bar</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"k\">mod</span> <span class=\"nn\">private</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"n\">assert_impl</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Foo</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">here</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\">  </span><span class=\"c1\">// Foo is fully implicitly constructible here</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">mod</span> <span class=\"nn\">b</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">super</span>::<span class=\"n\">a</span>::<span class=\"n\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">  </span><span class=\"n\">assert_not_impl</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">Foo</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">here</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"p\">);</span><span class=\"w\">  </span><span class=\"c1\">// Foo isn&#39;t fully implicitly constructible here</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>This has an ergonomic cost; you end up scope-passing e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"c1\">// need to repeat bar&#39;s bound to call it</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">bar</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">bar</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>...but I don't <em>think</em> it requires fundamentally reorganizing the type system in the way which a more implicit approach would.</p>",
        "id": 209566004,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599683985
    },
    {
        "content": "<p>The scope-passing chore implies a slightly different API. Since we can't write:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"sd\">/// error[E0207]: the type parameter `Scope` is not constrained by the impl trait, self type, or predicates</span>\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">TransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"bp\">Self</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* ... */</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>...we'd probably need to frame the RFC as three traits, instead:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\">// is the transmutation well-defined?</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">SoundTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"cm\">/* ^implemented purely with compiler magic */</span><span class=\"w\"></span>\n\n\n<span class=\"c1\">// is the transmutation well-defined and safe?</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">SafeTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">SafeTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Src</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">Constructible</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">SoundTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n\n\n<span class=\"c1\">// Is the transmutation well-defined and stable?</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">StableTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">StableTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Src</span>: <span class=\"nc\">PromiseTransmutableInto</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>: <span class=\"nc\">PromiseTransmutableFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Dst</span>::<span class=\"n\">Archetype</span>: <span class=\"nc\">SafeTransmuteFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span>::<span class=\"n\">Archetype</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 209568353,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599685377
    },
    {
        "content": "<p>The idea of scope-passing makes explicit a question that already exists in the non-scope-passing version: which location is used to determine whether a bound is satisfied? Today, when generic code tries to determine whether a bound is satisfied, it can look at both its own bounds and impls defined in its crate and dependencies. The difference between these two becomes the difference between forwarding a <code>Scope</code> parameter and using <code>here!()</code>.</p>\n<p>This choice is quite fuzzy today - the compiler gives no indication which it chooses or why when both are available - because it currently makes no difference which one is used. Thus, it's plausible (and IMO quite likely) that the non-scope-passing version would need an equivalent mechanism anyway, because making impls depend on privacy makes this difference semantically meaningful.</p>",
        "id": 209573531,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599688527
    },
    {
        "content": "<p>This seems promising. It totally gets rid of the hand-waving about implementing full formulation of implicit constructability and seems very feasible to implement.</p>\n<p>The modifications to the API surface aren't too deep, either: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=e758c5b17ce74108edc758c27497305a\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=e758c5b17ce74108edc758c27497305a</a></p>",
        "id": 209671764,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599754944
    },
    {
        "content": "<p>Should the <code>Promise..</code> traits perhaps <em>not</em> take a <code>Scope</code> parameter? As-is it seems like impls won't be able to \"share\" their <code>Here!()</code> type with clients, to let the primary type have private fields but still be transmutable via an archetype. (Or is that not supposed to work anyway?)</p>\n<p>(I also see no impl for <code>TransmuteFrom&lt;Src, Scope, (NeglectConstructability,)&gt;</code>, despite it being used as a bound on line 48, is that maybe a typo?)</p>\n<p>(Also, veering into bikeshed territory: the \"tower\" of trait impls on lines 27-49, each one removing one option from the one before it, kinda calls out to be turned into a chain of separate traits, similar to <code>trait Fn: FnMut</code>/<code>trait FnMut: FnOnce</code>/<code>trait FnOnce</code>.)</p>",
        "id": 209679036,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599757979
    },
    {
        "content": "<blockquote>\n<p>Should the <code>Promise..</code> traits perhaps not take a <code>Scope</code> parameter? </p>\n</blockquote>\n<p>I <em>think</em> we do, to accomodate generic containers; e.g.:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">N</span>: <span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">PromiseTransmutableFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"c1\">// we definitely need a scope parameter for this, because `T` probably isn&#39;t in scope in libcore</span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nc\">PromiseTransmutableFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"p\">[</span><span class=\"n\">T</span>::<span class=\"n\">Archetype</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">]</span><span class=\"w\"></span>\n<span class=\"w\">        </span>: <span class=\"nc\">TransmuteInto</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">NeglectStability</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">PromiseTransmutableFrom</span><span class=\"o\">&lt;</span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span> <span class=\"nc\">Archetype</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">T</span>::<span class=\"n\">Archetype</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">N</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 209681633,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599759302
    },
    {
        "content": "<p>I'm not completely sure how well this works for types with multiple type parameters.</p>\n<p>I think it might work fine.</p>",
        "id": 209681990,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599759488
    },
    {
        "content": "<p>I'm imagining that impl would just write <code>T: PromiseTransmutableFrom</code> without a <code>Scope</code>, and rely on <code>T</code>'s own <code>PromiseTransmutableFrom</code> impl to use <em>its</em> own <code>Here!()</code> in its <code>TransmuteInto</code> bound.</p>",
        "id": 209684300,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599760544
    },
    {
        "content": "<p>I think that would work, if it weren't for having to repeat <code>Archetype</code>'s bounds:</p>\n<div class=\"codehilite\"><pre><span></span><code>    [T::Archetype; N]\n        : TransmuteInto&lt;Self, Scope, NeglectStability&gt;\n</code></pre></div>\n\n\n<p>The bound <code>[T::Archetype; N]: TransmuteInto&lt;Self, Here!(), NeglectStability&gt;</code> almost certainly wouldn't hold at the <code>impl</code> site, because <code>T</code> probably isn't reachable from the scope of the <code>impl</code>.</p>",
        "id": 209684873,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599760767
    },
    {
        "content": "<p>But its Archetype should be, right?</p>",
        "id": 209685548,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599761024
    },
    {
        "content": "<p>err, nevermind, of course not.</p>",
        "id": 209685598,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599761042
    },
    {
        "content": "<p>Its Archetype should be reachable by the <em>client</em> of this impl, though- so maybe the impl needs a Scope param to forward to the TransmuteInto bound, but we don't really want to use that same Scope param in T: PromiseTransmutableFrom&lt;Scope&gt;, IIUC?</p>",
        "id": 209685707,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599761098
    },
    {
        "content": "<p>That prooobably hits the unused param error though? (Can't try it out just now.)</p>",
        "id": 209685832,
        "sender_full_name": "rpjohnst",
        "timestamp": 1599761156
    },
    {
        "content": "<p>Haha, yep, it totally does.</p>",
        "id": 209685922,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599761191
    },
    {
        "content": "<p>From an end-user perspective, we'd probably want to provide something like:</p>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"cp\">$expr</span>: <span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">TransmuteFrom</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Here</span><span class=\"o\">!</span><span class=\"p\">()</span><span class=\"o\">&gt;</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"cp\">$expr</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n\n\n<p>So that you didn't have to think about any of this unless you were building a generic abstraction over <code>TransmuteFrom</code>.</p>",
        "id": 209686892,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599761568
    },
    {
        "content": "<p>I've summarized some of this idea as a comment on the RFC: <a href=\"https://github.com/rust-lang/rfcs/pull/2981#discussion_r487319138\">https://github.com/rust-lang/rfcs/pull/2981#discussion_r487319138</a></p>",
        "id": 209843460,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599863801
    },
    {
        "content": "<p>I’m a big fan of the <code>transmute</code> macro! It’s looking like we can’t really do safe transmute abstractions you can build off without inventing new tools, and new tools need time to bake. A combination of <code>#[derive]</code> and <code>transmute!</code> seems like it would offer a useful starting point to get rubber on the road without painting ourselves into any corners or compromising any APIs we do want to offer. I’d be interested to see what other uses people would cook up for <code>Here!()</code></p>",
        "id": 209877661,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599910894
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"204346\">@Ashley Mannix</span> With today's updates, the RFC's suggested initial stabilization surface consists just of the derives and <code>transmute!</code>: <a href=\"https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#minimal-useful-stabilization-surface\">https://github.com/jswrenn/rfcs/blob/safer-transmute/text/0000-safer-transmute.md#minimal-useful-stabilization-surface</a></p>",
        "id": 209909716,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1599963272
    },
    {
        "content": "<p>Having a stability roadmap is a great idea <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 209909979,
        "sender_full_name": "Ashley Mannix",
        "timestamp": 1599963940
    }
]