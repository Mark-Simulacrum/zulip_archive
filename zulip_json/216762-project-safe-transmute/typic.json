[
    {
        "content": "<p>Worth reviewing: <a href=\"https://github.com/jswrenn/typic\" target=\"_blank\" title=\"https://github.com/jswrenn/typic\">https://github.com/jswrenn/typic</a></p>",
        "id": 184458872,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1577695129
    },
    {
        "content": "<p>I'm happy to answer questions about it!</p>",
        "id": 184492266,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577732027
    },
    {
        "content": "<p>Based on <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span>'s amazing work on <code>typic</code>, I created <code>chtrans</code> (checked transmute)</p>\n<p><a href=\"https://github.com/KrishnaSannasi/chtrans\" target=\"_blank\" title=\"https://github.com/KrishnaSannasi/chtrans\">https://github.com/KrishnaSannasi/chtrans</a></p>",
        "id": 184558390,
        "sender_full_name": "Yato",
        "timestamp": 1577816725
    },
    {
        "content": "<p>A few notable differences, I fully support non-zero types, bool, but I have less support for references right now. (Although I could support references in the same way as <code>typic</code> with minor changes).<br>\nThere are numerous implementation differences, such as removing references as slots, a custom backwards linked list (which made some other parts easier/cheaper to implement).</p>",
        "id": 184558391,
        "sender_full_name": "Yato",
        "timestamp": 1577816728
    },
    {
        "content": "<p>All this without a huge amount of special casing (such as in <code>typic::transmutation</code>), this is due to a new idea I'm calling <code>Marker</code>. <code>Marker</code>s are properties that can be searched for and must be validated. For example, <code>NonZero&lt;N&gt;</code> is the property that the next <code>N</code> bytes when interpreted as an integer is non-zero</p>",
        "id": 184558482,
        "sender_full_name": "Yato",
        "timestamp": 1577816833
    },
    {
        "content": "<p>My hope was to spur experimentation in this area, so I'm thrilled to have been a source of inspiration. :D I can't wait to dig into your approach!</p>",
        "id": 184558662,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577817032
    },
    {
        "content": "<p>It was really eye opening to see your implementation, I loved digging through it!</p>",
        "id": 184558685,
        "sender_full_name": "Yato",
        "timestamp": 1577817056
    },
    {
        "content": "<p>It reminded me of when I first  began to understand typenum.</p>",
        "id": 184558707,
        "sender_full_name": "Yato",
        "timestamp": 1577817079
    },
    {
        "content": "<p>One limitation that I am now realizing is the handling of privacy, right now if you apply <code>chtrans::repr</code>, you are implicitly making your type transparent. I need to find a way around this. I also don't support fallible transmute just yet. I suspect these two are related.</p>",
        "id": 184558823,
        "sender_full_name": "Yato",
        "timestamp": 1577817205
    },
    {
        "content": "<p>Re privacy, did you see this: <a href=\"https://github.com/jswrenn/typic/blob/master/typic/tests/invariants_opaque.rs\" target=\"_blank\" title=\"https://github.com/jswrenn/typic/blob/master/typic/tests/invariants_opaque.rs\">https://github.com/jswrenn/typic/blob/master/typic/tests/invariants_opaque.rs</a><br>\nIn my approach, a type is only transparent if all fields are marked <code>pub</code>.</p>",
        "id": 184559026,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577817440
    },
    {
        "content": "<p>Yes, I was just getting to that. That's what reminded me of this problem.</p>",
        "id": 184559096,
        "sender_full_name": "Yato",
        "timestamp": 1577817510
    },
    {
        "content": "<p>For checking invariants, would it be fine if we just created the type then passed it to <code>Invariants::check</code>, and leaking it if the check fails? That way we don't need to generate at <code>Candidate</code> type (which looks like it is semantically doing the same thing). I'm not sure if the is sound, but it might be simpler to implement.</p>",
        "id": 184559356,
        "sender_full_name": "Yato",
        "timestamp": 1577817766
    },
    {
        "content": "<p>Maybe? The <code>Candidate</code> is a doppelganger of the type but without any methods, since methods on the original type might rely on inter-field invariants. My first approach at this did what you describe, but the soundness issue lead me to move away from it.</p>",
        "id": 184559588,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577818057
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 184559680,
        "sender_full_name": "Yato",
        "timestamp": 1577818152
    },
    {
        "content": "<p>Following up on my assertion that supporting <code>union</code> was 'just' a matter of adding the layout algorithm for them, the <code>unions</code> branch of Typic now provides a proof-of-concept implementation. Example here: <a href=\"https://github.com/jswrenn/typic/blob/unions/typic/tests/unions.rs\" target=\"_blank\" title=\"https://github.com/jswrenn/typic/blob/unions/typic/tests/unions.rs\">https://github.com/jswrenn/typic/blob/unions/typic/tests/unions.rs</a></p>\n<p>To encode which unions are layout compatible, I needed my first nightly feature: <code>marker_trait_attr</code>. (Namely, to state that  a<code>UA</code> can be transmuted into a <code>UB</code> if every variant of <code>UA</code> can be transmuted into  _any_ variant of <code>UB</code>.) So, that's an unfortunate barrier for making this functionality available as a library.</p>",
        "id": 184612696,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577911289
    },
    {
        "content": "<p>I added <code>MaybeUninit</code>, but I need to add full union support. (This shouldn't be too hard, similarly to you it is just extending the macro, and adding the layout algorithm)</p>\n<p>On the note of <code>Candidate</code>, I found this in the UCG</p>\n<p><a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/glossary.md#validity-and-safety-invariant\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/glossary.md#validity-and-safety-invariant\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/reference/src/glossary.md#validity-and-safety-invariant</a></p>\n<blockquote>\n<p>The safety invariant is an invariant that safe code may assume all data to uphold. This invariant is used to justify which operations safe code can perform. The safety invariant can be temporarily violated by unsafe code, but must always be upheld when interfacing with unknown safe code. It is not relevant when arguing whether some program has UB, but it is relevant when arguing whether some code safely encapsulates its unsafety -- in other words, it is relevant when arguing whether some library is sound.</p>\n</blockquote>\n<p>So I think it is fine to forge an possibly invalid type as long as it doesn't break any validity invariants, like references must always be aligned.  Library invariants don't matter (like <code>Foo.x</code> can never be odd, or <code>Vec.len</code> must not cover uninitialized data. So long as you don't expose this to safe code. Which we don't, only exposed to the <code>Invariants</code> trait, which is <code>unsafe</code> to implement.</p>",
        "id": 184613537,
        "sender_full_name": "Yato",
        "timestamp": 1577912694
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"202379\">@Yato</span> I just pushed to the <code>enums</code> branch with proof-of-concept support of <code>enum</code>.</p>\n<p>I desugar enums to equivalent unions according to <a href=\"https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html\" target=\"_blank\" title=\"https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html\">RFC#2195</a> and use my existing <code>union</code> layout machinery.  Discriminants are represented using const generics. See: <a href=\"https://github.com/jswrenn/typic/blob/enums/typic/tests/enums.rs\" target=\"_blank\" title=\"https://github.com/jswrenn/typic/blob/enums/typic/tests/enums.rs\">https://github.com/jswrenn/typic/blob/enums/typic/tests/enums.rs</a></p>",
        "id": 184614723,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577914956
    },
    {
        "content": "<p>And with that, I'm thrilled to have confirmed my suspicion that Rust's type system is already expressive enough to reasonably enforce every statically-checkable transmutation I can think of! ^_^</p>",
        "id": 184614801,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577915160
    },
    {
        "content": "<p>Caveat for onlookers: this is totally Research Quality™. I haven't yet closely reviewed my low-level layout compatibility checks to make sure I haven't accidentally permitted something I meant to forbid (which is as easy as leaving off a trait bound) or omitted an impl for a transition I meant to allow (in fact, I've definitely omitted impls).</p>",
        "id": 184614988,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577915516
    },
    {
        "content": "<p>Same caveat applies to <code>chtrans</code></p>",
        "id": 184616983,
        "sender_full_name": "Yato",
        "timestamp": 1577919358
    },
    {
        "content": "<p>One thing I was thinking about wrt unions, are unions allowed to contain uninitialized bytes anywhere in their layout</p>\n<p>i.e. is this allowed to be uninitialized</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">union</span> <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">value</span>: <span class=\"kt\">i32</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184617036,
        "sender_full_name": "Yato",
        "timestamp": 1577919428
    },
    {
        "content": "<p>Unless those bytes are introduced by a variant: no. <code>MaybeUninit&lt;i32&gt;</code> cannot be transmuted to <code>Foo</code>, because <code>Foo</code>'s valid bit pattern is identical to <code>i32</code> (i.e., four arbitrarily initialized bytes).</p>",
        "id": 184617099,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577919595
    },
    {
        "content": "<p>This seems to be related to<br>\n<a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">https://github.com/rust-lang/unsafe-code-guidelines/issues/73</a><br>\n<a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/156\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/156\">https://github.com/rust-lang/unsafe-code-guidelines/issues/156</a></p>",
        "id": 184617245,
        "sender_full_name": "Yato",
        "timestamp": 1577919785
    },
    {
        "content": "<p>Huh. Regarding <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">#73</a>, I find it very surprising that there could be a valid bit pattern for a union <code>T</code> that wasn't a valid bit pattern for any of <code>T</code>'s variants.</p>",
        "id": 184617539,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577920254
    },
    {
        "content": "<p>Off the top of my head, it seems like that would pose a significant barrier to providing a mechanism for safe variant access. E.g., it's completely impossible to provide a safe accessor for <code>value</code> in your example, because a valid instance of<code>Foo</code> could have been constructed from uninitialized bits.</p>",
        "id": 184617609,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577920377
    },
    {
        "content": "<p>Yes, that's why I asked. As I was going through the UCG's guidelines I came across <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">#73</a> and that surprised me. For now, I will implement unions as a sequence of uninitialized bytes, just to be safe.</p>\n<p>Here is the motivating example for unions having byte patterns that fit non of the variants from another thread<br>\n<a href=\"https://github.com/rust-lang/rust/issues/32836#issuecomment-408766424\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/issues/32836#issuecomment-408766424\">https://github.com/rust-lang/rust/issues/32836#issuecomment-408766424</a></p>",
        "id": 184617694,
        "sender_full_name": "Yato",
        "timestamp": 1577920520
    },
    {
        "content": "<p>The current rule I have basically this: <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73#issuecomment-504060109\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73#issuecomment-504060109\">https://github.com/rust-lang/unsafe-code-guidelines/issues/73#issuecomment-504060109</a></p>",
        "id": 184617950,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577921019
    },
    {
        "content": "<p>There's some discussion of niche-finding optimizations in that issue. AFAIK, those considerations don't affect us because niche finding can't reach into <code>#[repr(C)]</code> types to find niches.</p>\n<p>(At least, that's my understanding from <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/174\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/174\">#174</a>.)</p>",
        "id": 184618061,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577921188
    },
    {
        "content": "<p>Ok, I'm going to ask there just to make sure, I don't really want to speculate on this.</p>",
        "id": 184618169,
        "sender_full_name": "Yato",
        "timestamp": 1577921424
    },
    {
        "content": "<p>Layout optimizations does matter for your implementation of enums, wrt <code>Option</code>-like enums, but not wrt unions</p>",
        "id": 184618225,
        "sender_full_name": "Yato",
        "timestamp": 1577921538
    },
    {
        "content": "<p>I haven't tried to implement any layout computations for <code>#[repr(Rust)]</code> enums (and probably won't attempt it). There aren't any tricky layout optimizations on <code>#[repr(C)]</code> enums.</p>",
        "id": 184618279,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577921664
    },
    {
        "content": "<p>It looks like this doesn't work?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[typic::repr(C, _)]</span><span class=\"w\"></span>\n<span class=\"k\">enum</span> <span class=\"nc\">OptionLike</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Bool</span><span class=\"p\">(</span><span class=\"kt\">bool</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Empty</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>So just <code>C</code>-like enums then?</p>",
        "id": 184618349,
        "sender_full_name": "Yato",
        "timestamp": 1577921816
    },
    {
        "content": "<p>What do you mean by \"work\"? <code>OptionLike</code> is <code>repr(C)</code>, so we can compute the layout of it without doing any niche finding optimizations. It should be eight bytes. If it weren't <code>repr(C)</code>, then it'd only be one byte.</p>",
        "id": 184618464,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577922036
    },
    {
        "content": "<p>Right now that doesn't compile with <code>typic</code> (regardless of what integer type I put in the <code>_</code>)</p>",
        "id": 184618607,
        "sender_full_name": "Yato",
        "timestamp": 1577922318
    },
    {
        "content": "<p>Oops. It \"works\" in \"theory\". ;) Tbh, I committed after getting discriminants to work and didn't write any test cases for variants with fields. Let me see what I forgot...</p>",
        "id": 184618676,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577922430
    },
    {
        "content": "<p>I get these errors,</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"n\">error</span>: <span class=\"nc\">reaching</span><span class=\"w\"> </span><span class=\"n\">this</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"n\">at</span><span class=\"w\"> </span><span class=\"n\">runtime</span><span class=\"w\"> </span><span class=\"n\">will</span><span class=\"w\"> </span><span class=\"n\">panic</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"n\">abort</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">typic</span><span class=\"err\">\\</span><span class=\"n\">tests</span><span class=\"err\">\\</span><span class=\"n\">enums</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">24</span>:<span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"cp\">#[typic::repr(C)]</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">^^^^^^^^^^^^^^^^^</span><span class=\"w\"> </span><span class=\"s\">&quot;pointer-to-integer cast&quot;</span><span class=\"w\"> </span><span class=\"n\">needs</span><span class=\"w\"> </span><span class=\"n\">an</span><span class=\"w\"> </span><span class=\"n\">rfc</span><span class=\"w\"> </span><span class=\"n\">before</span><span class=\"w\"> </span><span class=\"n\">being</span><span class=\"w\"> </span><span class=\"n\">allowed</span><span class=\"w\"> </span><span class=\"n\">inside</span><span class=\"w\"> </span><span class=\"n\">constants</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"err\">`</span><span class=\"cp\">#[deny(const_err)]</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">on</span><span class=\"w\"> </span><span class=\"n\">by</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"></span>\n\n<span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">E0080</span><span class=\"p\">]</span>: <span class=\"nc\">evaluation</span><span class=\"w\"> </span><span class=\"n\">of</span><span class=\"w\"> </span><span class=\"n\">constant</span><span class=\"w\"> </span><span class=\"n\">value</span><span class=\"w\"> </span><span class=\"n\">failed</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">typic</span><span class=\"err\">\\</span><span class=\"n\">tests</span><span class=\"err\">\\</span><span class=\"n\">enums</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">24</span>:<span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"cp\">#[typic::repr(C)]</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">^^^^^^^^^^^^^^^^^</span><span class=\"w\"> </span><span class=\"n\">referenced</span><span class=\"w\"> </span><span class=\"n\">constant</span><span class=\"w\"> </span><span class=\"n\">has</span><span class=\"w\"> </span><span class=\"n\">errors</span><span class=\"w\"></span>\n\n<span class=\"n\">error</span><span class=\"p\">[</span><span class=\"n\">E0605</span><span class=\"p\">]</span>: <span class=\"nc\">non</span><span class=\"o\">-</span><span class=\"n\">primitive</span><span class=\"w\"> </span><span class=\"n\">cast</span>: <span class=\"err\">`</span><span class=\"n\">OptionLike</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"kt\">isize</span><span class=\"err\">`</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">-</span>-&gt; <span class=\"nc\">typic</span><span class=\"err\">\\</span><span class=\"n\">tests</span><span class=\"err\">\\</span><span class=\"n\">enums</span><span class=\"p\">.</span><span class=\"n\">rs</span>:<span class=\"mi\">24</span>:<span class=\"mi\">1</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"mi\">24</span><span class=\"w\"> </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"cp\">#[typic::repr(C)]</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"> </span><span class=\"o\">^^^^^^^^^^^^^^^^^</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">|</span><span class=\"w\"></span>\n<span class=\"w\">   </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">note</span>: <span class=\"nc\">an</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"k\">as</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"n\">expression</span><span class=\"w\"> </span><span class=\"n\">can</span><span class=\"w\"> </span><span class=\"n\">only</span><span class=\"w\"> </span><span class=\"n\">be</span><span class=\"w\"> </span><span class=\"n\">used</span><span class=\"w\"> </span><span class=\"n\">to</span><span class=\"w\"> </span><span class=\"n\">convert</span><span class=\"w\"> </span><span class=\"n\">between</span><span class=\"w\"> </span><span class=\"n\">primitive</span><span class=\"w\"> </span><span class=\"n\">types</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"n\">Consider</span><span class=\"w\"> </span><span class=\"n\">using</span><span class=\"w\"> </span><span class=\"n\">the</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"nb\">From</span><span class=\"err\">`</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"></span>\n</pre></div>",
        "id": 184618727,
        "sender_full_name": "Yato",
        "timestamp": 1577922494
    },
    {
        "content": "<p>HUH. Ohhhhh. D'oh.</p>",
        "id": 184618735,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577922535
    },
    {
        "content": "<p>I forgot you can't use <code>as</code> on non-fieldless variants.<br>\nThis is the problematic line: <a href=\"https://github.com/jswrenn/typic/blob/644d264e9cc22ad63b011532ffff07ee6e6fe7fe/typic-derive/src/lib.rs#L173\" target=\"_blank\" title=\"https://github.com/jswrenn/typic/blob/644d264e9cc22ad63b011532ffff07ee6e6fe7fe/typic-derive/src/lib.rs#L173\">https://github.com/jswrenn/typic/blob/644d264e9cc22ad63b011532ffff07ee6e6fe7fe/typic-derive/src/lib.rs#L173</a></p>",
        "id": 184618744,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577922570
    },
    {
        "content": "<p><del>Yeah, that's going to be slightly inconvenient to work around, but nothing major.</del> (I'd love to see an RFC for safely accessing the discriminants of non-fieldless variants!)</p>\n<p>EDIT: That's going to be a pain to work around. It's not a theoretical limitation or anything, there's just no easy way to get the discriminant out of a variant without constructing an instance of the variant. I have an idea of how to do it, but it's a bunch of dreadful extra work on the automatic derive that I'm not eager to do tonight. :(</p>",
        "id": 184618868,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577922790
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"202379\">@Yato</span>: Give things a shot, now. I found a workaround that wasn't as painful as I was expecting. :)</p>",
        "id": 184620789,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1577926571
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> I think <span class=\"user-mention\" data-user-id=\"215333\">@Florian Gilcher</span> had an RFC for this (a [const] function that gets you the ID of the variant)</p>",
        "id": 184660528,
        "sender_full_name": "James Munns",
        "timestamp": 1577980117
    },
    {
        "content": "<p>Ah, wrong on two counts. It was only to get the <em>size</em> of the discriminant in bits, and it was closed without merging: <a href=\"https://github.com/rust-lang/rfcs/pull/2684\" target=\"_blank\" title=\"https://github.com/rust-lang/rfcs/pull/2684\">https://github.com/rust-lang/rfcs/pull/2684</a></p>",
        "id": 184660655,
        "sender_full_name": "James Munns",
        "timestamp": 1577980207
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"202379\">@Yato</span> </p>\n<blockquote>\n<p>I think it is fine to forge an possibly invalid type as long as it doesn't break any validity invariants</p>\n</blockquote>\n<p>That sounds a bit funny? \"It can be invalid as long as it's valid\"?^^<br>\nbut it is fine to forge a value violating the <em>safety</em> invariant as long as it does not violate the <em>validity</em> invariant</p>",
        "id": 184665071,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983738
    },
    {
        "content": "<p>@RalfJ Sorry, got my terms mixed up, but that's what I meant</p>",
        "id": 184665095,
        "sender_full_name": "Yato",
        "timestamp": 1577983765
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> </p>\n<blockquote>\n<p>Huh. Regarding <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">#73</a>, I find it very surprising that there could be a valid bit pattern for a union <code>T</code> that wasn't a valid bit pattern for any of <code>T</code>'s variants.</p>\n</blockquote>\n<p>That is explicitly desired and by design; the OP of <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73\">https://github.com/rust-lang/unsafe-code-guidelines/issues/73</a> has a motivating use-case for allowing bit patterns in a union that none of the variants allow.</p>",
        "id": 184665102,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983776
    },
    {
        "content": "<p>As per <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73#issuecomment-570259312\" target=\"_blank\" title=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/73#issuecomment-570259312\">this comment</a> by <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>, unions do not inherently have any validity constraints. This means that we will have to require the users to opt-in to allow safe union transmute (when transmuting from a union to a non-union type)</p>",
        "id": 184665174,
        "sender_full_name": "Yato",
        "timestamp": 1577983811
    },
    {
        "content": "<blockquote>\n<p><del>Yeah, that's going to be slightly inconvenient to work around, but nothing major.</del> (I'd love to see an RFC for safely accessing the discriminants of non-fieldless variants!)</p>\n<p>EDIT: That's going to be a pain to work around. It's not a theoretical limitation or anything, there's just no easy way to get the discriminant out of a variant without constructing an instance of the variant. I have an idea of how to do it, but it's a bunch of dreadful extra work on the automatic derive that I'm not eager to do tonight. :(</p>\n</blockquote>\n<p>also AFAIK the discriminant of dataful variants is entirely unspecified in both value and representation, so code relying on it or messing with it in any way is probably incorrect. I am not an export on representation details though, so maybe more things are fixed than I know. but please be extremely conservative around enums and only assume things that are explicitly RFC'd! Notice that the unsafe-code-guidelines repo is <em>not</em> RFC'd.</p>",
        "id": 184665386,
        "sender_full_name": "RalfJ",
        "timestamp": 1577983991
    },
    {
        "content": "<p>ah and while we are speaking about unions, one of the things that is not specified for them is the start offset of the fields. for non-<code>repr(C)</code> unions, fields <em>are</em> allowed to be at non-0 offset.</p>",
        "id": 184665530,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  We are only dealing with <code>repr(C)</code> types, not even attempting anything on <code>repr(Rust)</code> types. Right now <code>enum</code>'s <code>repr(C)</code> representation is guaranteed by <a href=\"https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html\" target=\"_blank\" title=\"https://rust-lang.github.io/rfcs/2195-really-tagged-unions.html\">RFC#2195</a></p>",
        "id": 184665911,
        "sender_full_name": "Yato",
        "timestamp": 1577984404
    },
    {
        "content": "<p>oh I see. yes that guarantees many things.</p>",
        "id": 184666166,
        "sender_full_name": "RalfJ",
        "timestamp": 1577984608
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> <span class=\"user-mention\" data-user-id=\"202379\">@Yato</span> Just catching up now. Very, very cool! I think this type of approach has a lot of promise. I'm guessing one of the biggest issues would be error messages. One extra downside one considering this as a possibility for inclusion in the std lib is that such an approach doesn't really have any precedence in the std lib. Would it be considerable to magical?</p>",
        "id": 184731951,
        "sender_full_name": "rylev",
        "timestamp": 1578057189
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> <span class=\"user-mention\" data-user-id=\"202379\">@Yato</span> <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> I know I've asked this before, but I'd like to collect use cases for the motivation for this feature. My main motivating use case is viewing bytes in a structured way for parsing network protocols in an extremely efficient way. As such a feature that allowed <code>[u8; size_of::&lt;T&gt;]</code> to <code>T</code> transmutes (when the array is well aligned) would probably be sufficient for me. I personally don't really need arbitrary casting between byte compatible types. </p>\n<p>The other motivation I've seen is from <span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> around packing and unpacking of simd types to and from arrays (of floating points). I don't know enough about simd to fully understand this use case but if you're using simd instructions I can understand why performance is a concern. </p>\n<p>What are some other use cases?</p>",
        "id": 184733511,
        "sender_full_name": "rylev",
        "timestamp": 1578058447
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224872\">@Ryan Levick</span> I think my RFC had a collection of examples at the beginning.</p>",
        "id": 184733771,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578058659
    },
    {
        "content": "<p>Feel free to extract those and put them wherever they might be more easily accessible.</p>",
        "id": 184733792,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578058680
    },
    {
        "content": "<p>Compiling a collection of examples of things that we do want to support (and why) would be useful to check whether any design satisfies the constraints.</p>",
        "id": 184733861,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578058710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"132920\">@gnzlbg</span> The examples feel a bit abstract to me. I'm looking for more higher level descriptions of use cases.</p>",
        "id": 184734057,
        "sender_full_name": "rylev",
        "timestamp": 1578058919
    },
    {
        "content": "<p>Ah ok.</p>",
        "id": 184734158,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059012
    },
    {
        "content": "<p>The SIMD example is just a sub-case of doing type-punning.</p>",
        "id": 184734172,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059032
    },
    {
        "content": "<p>That's pretty much what you are doing with network data, file data, or any other example as well.</p>",
        "id": 184734235,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059069
    },
    {
        "content": "<p>So I suppose you are looking more for examples of useful type punning ?</p>",
        "id": 184734251,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059084
    },
    {
        "content": "<p>Yes to prove that we need general type punning capabilities and not specialized ones.</p>",
        "id": 184734314,
        "sender_full_name": "rylev",
        "timestamp": 1578059158
    },
    {
        "content": "<p>The <code>union</code> RFC might also be a good place to search for those. Another example is, e.g., comparing floating-point numbers for equality based on ULPs, using e.g. a pointer address as an <code>usize</code> hash, etc.</p>",
        "id": 184734356,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059165
    },
    {
        "content": "<p>Some of these are already supported in safe Rust via <code>as</code>, e.g., in the language reference, <code>thin_ptr as usize</code> is guaranteed to not \"modify\" the bits of the pointer in any way.</p>",
        "id": 184734413,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059253
    },
    {
        "content": "<p>or <code>0_isize as usize</code></p>",
        "id": 184734485,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059284
    },
    {
        "content": "<p>So there is a certain degree of \"safe transmutes\" (bit preserving type conversions) in the language already.</p>",
        "id": 184734502,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059320
    },
    {
        "content": "<p>I see the safe transmute RFC goal as generalizing those for user-defined types.</p>",
        "id": 184734536,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059350
    },
    {
        "content": "<p>One reason I'm asking for use cases is whether we can justify things like transmuting for types that require validation (e.g, bool). Is the complexity of supporting such transmutes worth it?</p>",
        "id": 184734657,
        "sender_full_name": "rylev",
        "timestamp": 1578059416
    },
    {
        "content": "<p>e.g. why is <code>0_isize as usize</code> safe, but <code>(0_isize, 0_isize) as (usize, usize)</code> require an <code>unsafe transmute</code> ?</p>",
        "id": 184734664,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059420
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224872\">@Ryan Levick</span> good question, my RFC supports that through a different API (a different trait), which does not necessarily need to be part of the first version of the RFC</p>",
        "id": 184734739,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059500
    },
    {
        "content": "<p>I don't recall what the safe-transmute v2 RFC did</p>",
        "id": 184734753,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059518
    },
    {
        "content": "<p>but that RFC allowed transmuting types of different sizes, so if you want that, you need some kind of validation</p>",
        "id": 184734829,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059573
    },
    {
        "content": "<p>e.g. to transmute a fat <code>&amp;[T]</code> into a thin <code>&amp;[T; N]</code></p>",
        "id": 184734843,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059587
    },
    {
        "content": "<p>the type of validation you need for that isn't that different of the one required for <code>bool</code> IIRC</p>",
        "id": 184734874,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059618
    },
    {
        "content": "<p>So I guess my opinion is that I don't know if it is worth it to allow transmutes that require validation, but if we do, then it probably isn't worth it to support some validations but not others.</p>",
        "id": 184735000,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059688
    },
    {
        "content": "<p>Yea I agree that any mechanism that supports validation would allow for arbitrary validation</p>",
        "id": 184735049,
        "sender_full_name": "rylev",
        "timestamp": 1578059727
    },
    {
        "content": "<p>The SIMD case could benefit from validation support, e.g., we have SIMD vectors of bools, that people want to transmute from/to byte vectors</p>",
        "id": 184735126,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059767
    },
    {
        "content": "<p><code>bool -&gt; u8</code> is ok, but <code>u8 -&gt; bool</code> requires validation, and so does transmuting a <code>u8xN -&gt; boolxN</code></p>",
        "id": 184735146,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059792
    },
    {
        "content": "<p>IIRC <code>packed_simd</code> currently uses <code>TryFrom</code> for those where <code>TryFrom</code> makes sense</p>",
        "id": 184735162,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578059820
    },
    {
        "content": "<p>FYI: here's a WIP version of v3 of the safe-transmute proposal. It's largely unfinished but the reference guide section is mostly complete: <a href=\"https://gist.github.com/rylev/f0c103340d81f3ce9237184ed8e7abe6\" target=\"_blank\" title=\"https://gist.github.com/rylev/f0c103340d81f3ce9237184ed8e7abe6\">https://gist.github.com/rylev/f0c103340d81f3ce9237184ed8e7abe6</a></p>",
        "id": 184735282,
        "sender_full_name": "rylev",
        "timestamp": 1578059926
    },
    {
        "content": "<p>It would be nice to collect at this into a document of what the current state is. I'd like for <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span>'s proposal to settle a bit and for us to see how that fits into this.</p>",
        "id": 184735347,
        "sender_full_name": "rylev",
        "timestamp": 1578059983
    },
    {
        "content": "<p>Glad to have inspired some thought! I wouldn't call typic a proposal per se, but a demonstration that when Rust's can reason about layouts at inference time, really powerful static guarantees are possible. Implementing this as a library has downsides (like error messages), so there might be a case for having rustc reason 'natively' about layouts.</p>\n<p>My motivation is that I view <code>transmute</code> as a soundness footgun. If Rust can improve it's safety guarantees without incurring a runtime cost, it should—and we now know that it can! We can also improve the expressivity of <code>transmute</code>, removing it's unique limitation of not being usable in generic contexts.</p>\n<p>My approach (or actually extending the type system to reason about layout natively) also creates an executable semantics of Rust's layout guarantees, which is valuable to have.</p>",
        "id": 184735650,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578060225
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> thanks for providing some background on your motivation. I think it's fair to say that while we should consider type level reasoning about type layout, but that we shouldn't necessarily expect a _full_ proposal on a safe transmute feature from you (though of course we're happy to have your input and help with that!).</p>",
        "id": 184735983,
        "sender_full_name": "rylev",
        "timestamp": 1578060503
    },
    {
        "content": "<p>I wonder who the right person is to talk to about the viability of type level constraints as a solution that is likely to be accepted into the std lib. Perhaps <span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> has some ideas?<br>\nNiko, the tl;dr is that <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> has written a proof of concept that allows encoding of a type's layout in the type system (as a trait) such that at the type level we can tell whether two types have compatible layouts. Besides talking with <span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> about this from the lang team's perspective, is there a person from the compiler team who would be good to talk to about the viability of such an approach to ensure safe transmute?</p>",
        "id": 184736295,
        "sender_full_name": "rylev",
        "timestamp": 1578060792
    },
    {
        "content": "<p>Another issue is performance, as types scale up, the performance of this method dies (but only for really large types). For example, converting between 2 4-kilobyte types took about a minute to compile. If there are any errors you get a full screenful of a type.<br>\nI think that Rust can do better, especially wrt error messages and performance. Now a 4-kilobyte type is huge, so this may not be a problem, but doing lots of these checked transmutes could add up in the same way.</p>",
        "id": 184736869,
        "sender_full_name": "Yato",
        "timestamp": 1578061332
    },
    {
        "content": "<p>I personally would not want the type based checked transmutes in std, because it is really complex and subtle. It be far more reliable and maintainable if these computations were baked into the compiler.</p>",
        "id": 184737141,
        "sender_full_name": "Yato",
        "timestamp": 1578061591
    },
    {
        "content": "<blockquote>\n<p>I wonder who the right person is to talk to about the viability of type level constraints as a solution that is likely to be accepted into the std lib. Perhaps @nikomatsakis has some ideas?</p>\n</blockquote>\n<p>I can imagine how to do this reliably using traits, but haven't looked at typic. I can't imagine a way of doing this reliably and efficiently as a library.</p>",
        "id": 184737870,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578062205
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> do you have any compile-time benchmarks for <code>typic</code> ?</p>",
        "id": 184737890,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578062223
    },
    {
        "content": "<p>e.g. we used to have benchmarks for meta-programming like this in C++, for example, in <a href=\"http://metaben.ch/\" target=\"_blank\" title=\"http://metaben.ch/\">http://metaben.ch/</a></p>",
        "id": 184737919,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578062257
    },
    {
        "content": "<p>In a nutshell one just needs to automatically generate a file containing two types, and performing a typic conversions, and measure the compile-time.</p>",
        "id": 184737993,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578062294
    },
    {
        "content": "<p>You then increase the size of these types, e.g., by adding more fields, and plot the compile-time as a function of, e.g., the type fields.</p>",
        "id": 184738028,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578062324
    },
    {
        "content": "<p>You can then also add more types, and plot the compile-times as a functions of the types using <code>typic</code></p>",
        "id": 184738043,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578062343
    },
    {
        "content": "<p>Not yet. If you don't transmute between two types, you shouldn't pay any penalty for computing the layout of those types.</p>\n<p>My implementation aims for simplicity in the low level representation, not efficiency. <span class=\"user-mention\" data-user-id=\"202379\">@Yato</span> followed up with a more efficient representation without too much increased complexity.</p>\n<p>I like your benchmarking idea!</p>",
        "id": 184738212,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578062452
    },
    {
        "content": "<p>I've thought about writing a tool to \"hammer\" the rust compiler, by allowing to easily specify production rules for tests like these, but never got the time to do it. There are many language features for which compile-times currently explode once you add more cases (e.g. a <code>match 0_i32 { 0 =&gt; ..., 1 =&gt; ..., ... i32::MAX =&gt; ... }</code> where compile-times grow as a function of the match arms in a non-linear way).</p>",
        "id": 184738235,
        "sender_full_name": "gnzlbg",
        "timestamp": 1578062483
    },
    {
        "content": "<p>I'm not sure if my way is more efficient, just that it has less special casing.</p>",
        "id": 184750492,
        "sender_full_name": "Yato",
        "timestamp": 1578071804
    },
    {
        "content": "<p>(What happened to your last list of needs? keep this one in a safe place this time :P )</p>\n<p>I've had the following general needs:</p>\n<ul>\n<li><strong>owned casting (T -&gt; U):</strong> Generally used with \"math stuff\" like f32/u32/i32 mixing, or SIMD versions of the same, or arrays, etc.</li>\n<li><strong>slice casting (&amp;[T] -&gt; &amp;[U], with appropriate length change if T and U aren't the same size, and with the &amp;mut variant as well):</strong> Often needed for things like data format stuff as you move it between places. <code>include_bytes!</code> (gives <code>&amp;[u8]</code>) to SPIRV (needs to be <code>&amp;[u32]</code>), or uploading a texture (in <code>&amp;[RGBA8]</code>) to the graphics card (takes <code>&amp;[u8]</code>), or string stuff (in <code>&amp;[u8]</code>) as you send it out to FFI (<code>&amp;[c_char]</code>).</li>\n<li><strong>Lone reference to and from slices (<code>&amp;T</code> -&gt; <code>&amp;[U]</code> and <code>&amp;[U]</code> -&gt; <code>&amp;T</code>)</strong> This is the use case you needed, which I didn't need until very recently but have bumped into myself.</li>\n</ul>",
        "id": 184757094,
        "sender_full_name": "Lokathor",
        "timestamp": 1578077070
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>I wonder who the right person is to talk to about the viability of type level constraints as a solution that is likely to be accepted into the std lib. Perhaps @nikomatsakis has some ideas?</p>\n</blockquote>\n<p>I can imagine how to do this reliably using traits, but haven't looked at typic. I can't imagine a way of doing this reliably and efficiently as a library.</p>\n</blockquote>\n<p>Incidentally, I think I've encountered an obstacle in my implementation of enums. In short, there's one case where I need to encode a type-level <code>Filter</code> operation. However, I don't know how to that without overlapping implementations. Overlapping implementations are supported with <code>#[marker]</code>, but _not_ on traits with associated types. A <code>Filter</code>-like trait needs an associated type to encode its output.</p>\n<p>A brief experiment suggests that chalk is already capable of expressing this.</p>",
        "id": 185336572,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578680642
    },
    {
        "content": "<p>Actually, disregard the above! I think I found a workaround.</p>",
        "id": 185356120,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578693787
    },
    {
        "content": "<p>For the curious, I've started modeling the type-level compatibility checking rules with Prolog. Prolog is really a fantastic way to experiment with typelevel programming in Rust. Rust's type system is very similar to Prolog, and Prolog predicates can be written in a way that admits straight-forward translation to Rust code. The repo is here: <a href=\"https://github.com/jswrenn/typic-pl\" target=\"_blank\" title=\"https://github.com/jswrenn/typic-pl\">https://github.com/jswrenn/typic-pl</a></p>",
        "id": 185396879,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578761654
    },
    {
        "content": "<p>I'm nervous about this being computed at compile time every build.</p>\n<p>How have the build times been with this approach?</p>",
        "id": 185403468,
        "sender_full_name": "Lokathor",
        "timestamp": 1578773362
    },
    {
        "content": "<p>I haven't benchmarked anything, but in the process of developing and testing typic, compilation has been basically instantaneous. There's a few costs to consider:</p>\n<p>The library itself:</p>\n<ol>\n<li><code>typic</code> itself builds nearly instantly, but relies on <code>typic-derive</code></li>\n<li><code>typic-derive</code> requires <code>syn</code>, which has significant one-off build time.</li>\n</ol>\n<p>Clients using the library:</p>\n<ol>\n<li>For types marked with <code>#[typic::repr(C)]</code>, a trait implementation is generated with an associated type that corresponds to the high-level structure of that type. It's akin to <a href=\"https://docs.rs/frunk/0.3.1/frunk/generic/trait.Generic.html\" target=\"_blank\" title=\"https://docs.rs/frunk/0.3.1/frunk/generic/trait.Generic.html\"><code>frunk::Generic</code></a>. This is just a syntactic transformation of the type. There is no type-level computation happening yet.</li>\n<li>The low-level representations of types are only computed if the user tries to transmute between them. How expensive this is depends on the complexity of the types. For small types, it's basically instantaneous.</li>\n</ol>",
        "id": 185404781,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578775921
    },
    {
        "content": "<p>That last item is really the only expensive operation. The good news is that it's paid on-demand, <em>only</em> for the types you try to transmute between.</p>\n<p>I'm unsure to what extent this cost is paid on <em>every</em> build. It might be the case that incremental compilation caches most of the computation. I'll have to look into it.</p>",
        "id": 185404933,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578776164
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> </p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[typic::repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">T6</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">e</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T6</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T6</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">typic</span>::<span class=\"n\">transmute</span>::<span class=\"n\">TransmuteFrom</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T8</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>took 7.72 s to build on my computer (just this, nothing else). So performance is definitely a concern.</p>",
        "id": 185458719,
        "sender_full_name": "Yato",
        "timestamp": 1578878485
    },
    {
        "content": "<p>Incremental compilation helps, but Rust need to redo all the work <em>for every call to <code>transmute_from</code></em></p>",
        "id": 185458829,
        "sender_full_name": "Yato",
        "timestamp": 1578878679
    },
    {
        "content": "<p>That said, I just tested my version, and a the equivalent code (shown below) built in under a second</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[chtrans::repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">T6</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">e</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T6</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T6</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">chtrans</span>::<span class=\"n\">Reinterpret</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">reinterp_into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 185459345,
        "sender_full_name": "Yato",
        "timestamp": 1578879810
    },
    {
        "content": "<p>(although I did find out that I didn't support generic types till now, so there's that)</p>",
        "id": 185459406,
        "sender_full_name": "Yato",
        "timestamp": 1578879948
    },
    {
        "content": "<p>Just tried to push it a bit, and I broke the default recursion limit :)</p>\n<p>This took ~9 s</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#![recursion_limit=</span><span class=\"s\">&quot;10000&quot;</span><span class=\"cp\">]</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[chtrans::repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">T4</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">e</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">g</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">h</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"cp\">#[chtrans::repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">T8</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">e</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">g</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">h</span>: <span class=\"nc\">T</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">T8</span><span class=\"o\">&lt;</span><span class=\"n\">T4</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"p\">()</span>: <span class=\"p\">())</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">T4</span><span class=\"o\">&lt;</span><span class=\"n\">T8</span><span class=\"o\">&lt;</span><span class=\"kt\">u64</span><span class=\"o\">&gt;&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">chtrans</span>::<span class=\"n\">Reinterpret</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">reinterp_into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 185459500,
        "sender_full_name": "Yato",
        "timestamp": 1578880103
    },
    {
        "content": "<p>the largest I'm willing to try took ~27s</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[chtrans::repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Big</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_a</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_b</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_c</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">3</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_d</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">4</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_e</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_f</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">6</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_g</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">7</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">_h</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">8</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">a</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">b</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">c</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">11</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">d</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">12</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">e</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">13</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">f</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">14</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">g</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">15</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">h</span>: <span class=\"p\">[</span><span class=\"kt\">u64</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">],</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"nc\">Big</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Big</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">chtrans</span>::<span class=\"n\">Reinterpret</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">.</span><span class=\"n\">reinterp_into</span><span class=\"p\">()</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Rust seems to be good at caching results sometimes, so having a lot of different types helps kill build times.</p>",
        "id": 185459723,
        "sender_full_name": "Yato",
        "timestamp": 1578880608
    },
    {
        "content": "<p>Yikes! Are there any mechanisms for tracing trait resolution? I'd be very interested to know how the time is being spent.</p>",
        "id": 185554754,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1578963036
    },
    {
        "content": "<p>I am not aware of any</p>",
        "id": 185562729,
        "sender_full_name": "Yato",
        "timestamp": 1578973476
    },
    {
        "content": "<p>Trait resolution is just very poorly suited for this</p>",
        "id": 185932308,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579278801
    },
    {
        "content": "<p>This problem is common enough that it deserves a good solution</p>",
        "id": 185932356,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579278837
    },
    {
        "content": "<p>Is there a specific proposal to go with that?</p>",
        "id": 185973074,
        "sender_full_name": "Lokathor",
        "timestamp": 1579310044
    },
    {
        "content": "<p>There is the <code>Compatible&lt;T&gt;</code> rfc</p>",
        "id": 186098849,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579524708
    },
    {
        "content": "<p>and the safe-transmute v2/v3 rfcs</p>",
        "id": 186098931,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579524751
    },
    {
        "content": "<p>but the transitive closure in the <code>Compatible&lt;T&gt;</code> RFC only works for transmuting types that have the same size</p>",
        "id": 186099087,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579524862
    },
    {
        "content": "<p>I don't think there is a good solution with transitive closure for transmuting types of different sizes into each other</p>",
        "id": 186099158,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579524913
    },
    {
        "content": "<p>although there are some</p>",
        "id": 186099176,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579524933
    },
    {
        "content": "<p>e.g. one could make the <code>TryCompatible&lt;T&gt;</code> trait in the compatible-RFC have transitive closure, by eliminating the associated error type</p>",
        "id": 186099302,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579525034
    },
    {
        "content": "<p>at the cost of loosing the ability to specify custom error conditions</p>",
        "id": 186099393,
        "sender_full_name": "gnzlbg",
        "timestamp": 1579525109
    },
    {
        "content": "<p>I was curious how far a Safer Transmute RFC could get in which every example was explorable with Typic, and the answer is pretty far: <a href=\"https://github.com/jswrenn/typic/blob/master/0000-safer_transmute.md\" target=\"_blank\" title=\"https://github.com/jswrenn/typic/blob/master/0000-safer_transmute.md\">https://github.com/jswrenn/typic/blob/master/0000-safer_transmute.md</a></p>\n<p>All of the guidance in that document is implemented in Typic. The examples that ought to work <em>actually</em> compile and run. The examples that ought to fail <em>actually</em> produce compile errors.</p>\n<p>(Well, except that the automatic <code>Transparent</code> impl currently happens a little more conservatively than I've described in that document: the implementation requires that all fields are <code>pub</code>, not <em>merely</em> that they have visibility greater than or equal to their parent type, as specified. I'll fix that tomorrowish.)</p>",
        "id": 187496621,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1580937938
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"202379\">@Yato</span> The new implementation is also <em>much</em> faster. Your <code>Big</code> testcase now takes under a second on my laptop. With incremental builds thereafter, I don't notice any slowdown at all.</p>",
        "id": 187497257,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1580938365
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span>  Cool! What was the big slowdown?</p>",
        "id": 187655479,
        "sender_full_name": "Yato",
        "timestamp": 1581093629
    },
    {
        "content": "<p>Looks like you went through a big rewrite recently, can I get a brief summary of what changed? It looks like you moved away from frunk into some custom type encodings like I did, but it's a big change and I'm not sure how it all fits together in my brief look at it.</p>",
        "id": 187656308,
        "sender_full_name": "Yato",
        "timestamp": 1581094262
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"202379\">@Yato</span> The major representational change is that rather than representing type layouts as an <code>HList</code> of one-byte slots, the leaves of the new low-level representation have both a <code>Kind</code> and a <code>Size</code>.</p>\n<p>So, eight adjacent padding bytes is no longer an <code>HList</code> of eight <code>Uninitialized</code> slots. It's now one slot with <code>Kind=Uninitialized</code> and <code>Size=U8</code>. </p>\n<p>I'm guessing this change is responsible for the speedup, but I never actually traced trait resolution on the initial version, so I can't be absolutely sure.</p>",
        "id": 187660733,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1581096892
    },
    {
        "content": "<p>As far as the public API goes, I refocused typic on strictly on <em>infallible</em> conversions. The public API of the crate exactly models what I think the public API of an initial, general, safe transmute RFC should be:</p>\n<ul>\n<li>The function <a href=\"https://docs.rs/typic/latest/typic/fn.transmute_safe.html\" target=\"_blank\" title=\"https://docs.rs/typic/latest/typic/fn.transmute_safe.html\"><code>transmute_safe</code></a> and traits <a href=\"https://docs.rs/typic/latest/typic/trait.TransmuteInto.html\" target=\"_blank\" title=\"https://docs.rs/typic/latest/typic/trait.TransmuteInto.html\"><code>TransmuteInto</code></a> and <a href=\"https://docs.rs/typic/latest/typic/trait.TransmuteFrom.html\" target=\"_blank\" title=\"https://docs.rs/typic/latest/typic/trait.TransmuteFrom.html\"><code>TransmuteFrom</code></a>, providing completely safe transmutation.</li>\n<li>The function <a href=\"https://docs.rs/typic/latest/typic/fn.transmute_sound.html\" target=\"_blank\" title=\"https://docs.rs/typic/latest/typic/fn.transmute_sound.html\"><code>transmute_sound</code></a>, which is a soundness-enforcing (but still unsafe) successor to <code>mem::transmute</code>.</li>\n</ul>\n<p>A <em>general</em> solution for <em>fallible</em> conversions is much trickier, because error reporting is hard to get right.</p>",
        "id": 187664845,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1581099439
    },
    {
        "content": "<p>What's so hard to get right?</p>",
        "id": 187686578,
        "sender_full_name": "Lokathor",
        "timestamp": 1581114816
    },
    {
        "content": "<p>Let's say we want to transmute from <code>u16</code> to <code>Constrained</code>:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"cp\">#[repr(C)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Constrained</span><span class=\"p\">(</span><span class=\"n\">NonZeroU8</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">bool</span><span class=\"p\">);</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>On a little-endian system, this is only a valid transmutation if our <code>u16</code> is greater than 0 and less than 512. In all other cases, a general-purpose, fallible, sound transmuter should be able to report which bytes of our source type violated the layout of the destination type.</p>\n<p>A general-purpose, fallible, <em>safe</em> transmuter should be able to communicate why user-defined invariants are violated, too. (E.g., if <code>Constrained</code> also required that it's first field was an odd number.)</p>",
        "id": 187688317,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1581116439
    },
    {
        "content": "<p>Is the granularity of \"alignment\", \"size\" and \"type invariants\" not enough?</p>",
        "id": 187727677,
        "sender_full_name": "Shnatsel",
        "timestamp": 1581188474
    },
    {
        "content": "<p>I don't think you can reasonably report what type invariant exactly was broken in code that's this generic.</p>",
        "id": 187727803,
        "sender_full_name": "Shnatsel",
        "timestamp": 1581188751
    },
    {
        "content": "<p>I've just been looking into this in the context of <a href=\"https://gitlab.freedesktop.org/zeenix/zbus/\" target=\"_blank\" title=\"https://gitlab.freedesktop.org/zeenix/zbus/\">https://gitlab.freedesktop.org/zeenix/zbus/</a> and that's the only errors that any code I can imagine really cares to distinguish between. If it's an alignment problem, the fix is just copy the thing and make the alignment correct; if it's a size or broken type invariant problem, then we reject the input as invalid. That's it.</p>",
        "id": 187727845,
        "sender_full_name": "Shnatsel",
        "timestamp": 1581188785
    },
    {
        "content": "<p>OTOH I like the idea of keeping the scope contained and getting infallible conversions right first, then experimenting with fallible ones</p>",
        "id": 187727852,
        "sender_full_name": "Shnatsel",
        "timestamp": 1581188811
    },
    {
        "content": "<p>Yes, encoding the size would speed things up, especially because typenum has O(log n) operations as opposed to mine at O(n).</p>\n<p>I agree that we should only focus on infallible conversions as a start.</p>",
        "id": 187746743,
        "sender_full_name": "Yato",
        "timestamp": 1581228521
    },
    {
        "content": "<p>So, I'm thinking about how bit validity interacts with mutation.</p>\n<p>Consider these two type definitions:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">NonZeroU8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Given these types,</p>\n<ul>\n<li><code>Foo</code> → <code>Bar</code> is safe.</li>\n<li><code>&amp;Foo</code> → <code>&amp;Bar</code> is safe.</li>\n<li><code>&amp;mut Foo</code> → <code>&amp;mut Bar</code> is unsafe:</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span>: <span class=\"nc\">Foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bar</span><span class=\"w\"> </span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"mi\">0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">get</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// ack!!!</span>\n</pre></div>\n\n\n<p>This suggests a rule: bit validity can be widened with a value-to-value transmute, but is totally invariant for a mutable-reference-to-mutable-reference transmute.</p>",
        "id": 190096666,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583775638
    },
    {
        "content": "<p>Except, now let's consider:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">struct</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">NonZeroU8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Bar</span><span class=\"p\">(</span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">AtomicU8</span><span class=\"p\">);</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>Given those types,</p>\n<ul>\n<li><code>Foo</code> → <code>Bar</code> is safe.</li>\n<li><code>&amp;Foo</code> → <code>&amp;Bar</code> is <strong>unsafe</strong>:</li>\n</ul>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"p\">(</span><span class=\"n\">NonZeroU8</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"n\">unwrap</span><span class=\"p\">());</span><span class=\"w\"></span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bar</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">Bar</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">core</span>::<span class=\"n\">mem</span>::<span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">foo</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">bar</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">store</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Ordering</span>::<span class=\"n\">Relaxed</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"n\">assert_eq</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"mf\">0.</span><span class=\"n\">get</span><span class=\"p\">(),</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// ack!!!</span>\n</pre></div>\n\n\n<p>I'm not really sure what rule is suggested by this.</p>",
        "id": 190096708,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583775669
    },
    {
        "content": "<p>A very coarse rule is that validity is invariant whenever references (shared or unique) are involved.</p>\n<p>I think the <strong>actual</strong> rule is something like: <code>&amp;T</code> → <code>&amp;U</code> is safe only if <code>U</code> does not directly or transitively contain any <code>UnsafeCell</code>s.</p>",
        "id": 190098005,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583776481
    },
    {
        "content": "<p>As for the first point, the rule I use in <code>zerocopy</code> is that <code>&amp;mut Foo -&gt; &amp;mut Bar</code> requires that <code>Foo -&gt; Bar</code> and <code>Bar -&gt; Foo</code> since the reference allows you to both view a <code>Foo</code> as a <code>Bar</code> and also store a <code>Bar</code> in the location that may be later viewed as a <code>Foo</code>. There are more constraints besides (as you've pointed out with your atomic example), but those requirements exist at a minimum.</p>",
        "id": 190098360,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1583776670
    },
    {
        "content": "<p>Typic used a similar rule for a while, but ultimately abandoned it, because it forbids safe transmutations between types of different sizes. Given:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">type</span> <span class=\"nc\">A0</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"k\">type</span> <span class=\"nc\">A9</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">9</span><span class=\"p\">];</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>...we have the following transmutations:</p>\n<ol>\n<li><code>A9</code> → <code>A0</code></li>\n<li><code>A0</code> ↛ <code>A9</code></li>\n<li><code>&amp;A9</code> → <code>&amp;A0</code></li>\n<li><code>&amp;A0</code> ↛ <code>&amp;A9</code></li>\n</ol>\n<p>That rule eliminates transmute №3, since <code>A0</code> ↛ <code>A9</code>.</p>",
        "id": 190099857,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583777523
    },
    {
        "content": "<p>I wouldn't say that A9 -&gt; A0 is valid in the first place</p>",
        "id": 190112520,
        "sender_full_name": "Lokathor",
        "timestamp": 1583784731
    },
    {
        "content": "<p>Why not?</p>",
        "id": 190124641,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583792798
    },
    {
        "content": "<p>I would not allow different sized owned casting</p>",
        "id": 190137406,
        "sender_full_name": "Lokathor",
        "timestamp": 1583807386
    },
    {
        "content": "<p>it's relatively poorly defined and you can generally have the user reference manipulate things to get the cast they want if they really do want to truncate things</p>",
        "id": 190137457,
        "sender_full_name": "Lokathor",
        "timestamp": 1583807452
    },
    {
        "content": "<p>It's maybe a bit weird, but not at all unsound. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 190137461,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583807461
    },
    {
        "content": "<p>On the scale of good APIs there's a small margin just above \"strictly speaking sound\" where the API is still a footgun</p>",
        "id": 190137575,
        "sender_full_name": "Lokathor",
        "timestamp": 1583807653
    },
    {
        "content": "<p>Sure. Right now, Typic is scoped to just telling you when you're doing something unstable, unsafe, or unsound—but not unsensible.</p>",
        "id": 190137757,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583807912
    },
    {
        "content": "<p>Although I've actually legitimately used shrinking transmutes of arrays!</p>",
        "id": 190137769,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583807952
    },
    {
        "content": "<p>Sure, there are correct uses, but usually you should sub-slice it down to a desired size and use the sub-slice</p>",
        "id": 190138309,
        "sender_full_name": "Lokathor",
        "timestamp": 1583808725
    },
    {
        "content": "<p>The cast <code>A9</code> -&gt; <code>A0</code>, in that case, seems as if it should be implemented as a conversion by reference followed by deref+Copy to me.<br>\nBut it makes a point, that this is not always possible and requires <code>A0: Copy</code>.</p>",
        "id": 190156324,
        "sender_full_name": "HeroicKatora",
        "timestamp": 1583834024
    },
    {
        "content": "<p>You also probably really shouldn't be transmuting non-Copy data in the first place ;P</p>",
        "id": 190195094,
        "sender_full_name": "Lokathor",
        "timestamp": 1583858447
    },
    {
        "content": "<p>I've compiled a condensed introduction to what typic provides, that might be helpful: <a href=\"https://hackmd.io/@jswrenn/HydSGVHS8\" target=\"_blank\" title=\"https://hackmd.io/@jswrenn/HydSGVHS8\">https://hackmd.io/@jswrenn/HydSGVHS8</a></p>",
        "id": 190200068,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1583860953
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"224872\">@Ryan Levick</span> you <a href=\"https://github.com/rust-lang/lang-team/issues/26\">wrote</a>:</p>\n<blockquote>\n<p>While it might be possible to expose friendly traits for most use cases, there will be some use cases that require complex type level programming to be understood by the user.</p>\n</blockquote>\n<p>What use cases are you thinking of?</p>",
        "id": 201160326,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592408634
    },
    {
        "content": "<p>I actually was thinking of one where we could expose a simple trait. I’ll rephrase that</p>",
        "id": 201161415,
        "sender_full_name": "rylev",
        "timestamp": 1592409143
    },
    {
        "content": "<p>I still think the sentiment stands. Typic’s approach is complicated. I’m of the personal opinion that this is necessary complexity if we want a solution that covers the largest percentage of use cases, but complexity is still a con even if it’s warranted</p>",
        "id": 201161712,
        "sender_full_name": "rylev",
        "timestamp": 1592409275
    },
    {
        "content": "<p>I don't think it's necessary complexity to cover the widest percentage of use cases</p>",
        "id": 201162283,
        "sender_full_name": "Lokathor",
        "timestamp": 1592409580
    },
    {
        "content": "<p>It's maybe necessary to get 100% of cases though</p>",
        "id": 201162368,
        "sender_full_name": "Lokathor",
        "timestamp": 1592409605
    },
    {
        "content": "<p>Typic's definitely internally complicated, but I don't think the public interface is. There's just two basic traits for transmuting: <code>TransmuteFrom&lt;SrcType&gt;</code> and <code>UnsafeTransmuteFrom&lt;SrcType&gt;</code>.</p>\n<p>Likewise, the method used to declare ABI guarantees will also be just two traits: <code>TransmutableFrom</code> and <code>TransmutableInto</code>.</p>\n<p>One of my motivations for typic's approach was exploring whether it was possible to avoid a zoo of marker traits.</p>",
        "id": 201162452,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592409653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> I agree for straight transmute this is true, but I'm hoping to also discuss other things that are related tangentially like a Zeroable marker trait</p>",
        "id": 201162960,
        "sender_full_name": "rylev",
        "timestamp": 1592409851
    },
    {
        "content": "<p>I'm also not sure about what complexity would be needed to ensure good error messages</p>",
        "id": 201163056,
        "sender_full_name": "rylev",
        "timestamp": 1592409897
    },
    {
        "content": "<p>I don't know if <a href=\"#narrow/stream/216762-project-safe-transmute/topic/mem-markers.20v0.2E1/near/198681841\">this</a> is really what's conjured by the phrase \"complex type level programming\".</p>\n<p>It's a common enough pattern that having a facade <code>Zeroable</code> trait is probably nice to have, but it's nowhere near the complexity of using frunk or nalgebra (which I think is what comes to mind when people hear \"complex type level programming\").</p>",
        "id": 201163815,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592410245
    },
    {
        "content": "<p>That's fair. Does the phrase \"non-trivial API\" sound like a more accurate statement?</p>",
        "id": 201164071,
        "sender_full_name": "rylev",
        "timestamp": 1592410391
    },
    {
        "content": "<p>Er, I think the public API _is_ trivial, though. Just one trait (<code>TransmuteFrom</code>) covers 90% of use cases. And you mostly don't need to think about what marker traits you need to implement, because typic does it for you.</p>\n<p>Whether that's simpler is just my (rather uninformed) personal opinion. I feel like juggling many manually-implemented marker traits is more complex, but maybe it isn't. I'd be curious to here <span class=\"user-mention\" data-user-id=\"132362\">@Joshua Liebow-Feeser</span>'s thoughts on using zerocopy in practice.</p>",
        "id": 201164770,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592410714
    },
    {
        "content": "<p>Manually implemented marker traits are so extremely simple</p>",
        "id": 201165116,
        "sender_full_name": "Lokathor",
        "timestamp": 1592410868
    },
    {
        "content": "<p>The implementation details of Typic are definitely \"much more complex\" right now, but the public API isn't. </p>\n<p>The type-level programming aspect of typic is an internal implementation detail. Probably a temporary one, too: if our recent const-generics experimentation is any indicator the implementation details of typic will probably get much simpler in the future by just relying solely on rustc's own layout computation.</p>",
        "id": 201165172,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592410899
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> one thing is that we'd need a slightly alternative interface for opting in to transmutation than is currently used</p>",
        "id": 201165505,
        "sender_full_name": "Lokathor",
        "timestamp": 1592411056
    },
    {
        "content": "<p>though this is a small issue</p>",
        "id": 201165520,
        "sender_full_name": "Lokathor",
        "timestamp": 1592411061
    },
    {
        "content": "<p>For the record, I think that the best path is <em>both options</em>, implement typic style computation in the compiler that's user visible, then also make marker traits based on the typic computation</p>",
        "id": 201165600,
        "sender_full_name": "Lokathor",
        "timestamp": 1592411110
    },
    {
        "content": "<p>That's close to what I'm thinking too.</p>",
        "id": 201165658,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592411147
    },
    {
        "content": "<blockquote>\n<p>one thing is that we'd need a slightly alternative interface for opting in to transmutation than is currently used</p>\n</blockquote>\n<p>can you clarify?</p>",
        "id": 201165664,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592411149
    },
    {
        "content": "<p>currently (as i understand it) people put [typic::repr(C)] on a type to make it go through the typic calculation, but if this were official then having the normal repr(C) shouldn't necessarily be all it takes to be transmutable</p>",
        "id": 201165897,
        "sender_full_name": "Lokathor",
        "timestamp": 1592411274
    },
    {
        "content": "<p>because that's a stability hazard, which wr have enough of already</p>",
        "id": 201165967,
        "sender_full_name": "Lokathor",
        "timestamp": 1592411287
    },
    {
        "content": "<p>Oh, it's not. You also have to make all of your fields public, and declare lower and/or upper ABI bounds (via <code>TransmutableFrom</code> and <code>TransmutableInto</code>).</p>",
        "id": 201166045,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592411329
    },
    {
        "content": "<p>(Ooof, I really need to release more...)</p>",
        "id": 201166740,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1592411653
    },
    {
        "content": "<p>release every 6 weeks no matter what. that's the rust way!</p>",
        "id": 201169146,
        "sender_full_name": "Lokathor",
        "timestamp": 1592412808
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/typic/near/201165600\">said</a>:</p>\n<blockquote>\n<p>For the record, I think that the best path is <em>both options</em>, implement typic style computation in the compiler that's user visible, then also make marker traits based on the typic computation</p>\n</blockquote>\n<p>I agree with this fwiw</p>",
        "id": 201173287,
        "sender_full_name": "rylev",
        "timestamp": 1592414700
    },
    {
        "content": "<p>With regards to the complexity of the API, I agree that for the normal transmute case, the public API is as simple as it can be, but the Zeroable example is more complex IMO than it would be with marker traits since the zeroable marker trait would already be provided to the user. That being said, as I said above, I think the right answer is a combination of both - marker traits provided by typic style compile time information about the type's layout</p>",
        "id": 201173821,
        "sender_full_name": "rylev",
        "timestamp": 1592414896
    }
]