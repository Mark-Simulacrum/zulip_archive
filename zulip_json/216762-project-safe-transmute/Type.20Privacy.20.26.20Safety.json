[
    {
        "content": "<p>@Ralf, you <a href=\"https://github.com/rust-lang/rfcs/pull/2981#issuecomment-714672477\">asked</a>:</p>\n<blockquote>\n<p>But for these \"publicly unnameable type\", what does the reasoning look like? I am not asking for a PhD thesis working this out in full detail, but even explaining on an intuitive level how extra invariants arise here, what they are attached to and where unsafe (?) code needs to ensure they are upheld would help.</p>\n</blockquote>\n<p>I <a href=\"https://github.com/rust-lang/rfcs/pull/2981#issuecomment-715402660\">responded</a>:</p>\n<blockquote>\n<p>I'll try to sketch this out sometime in the next week. Briefly: The safety invariant on <code>Here!()</code> that is that the resulting type should not appear (<a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md#how-to-determine-visibility-of-a-type\">per the type privacy rules</a>) in the public API of the module it's invoked in.</p>\n</blockquote>\n<p>Before I try to elaborate, though, I want to make sure that I do so in a direction that's <em>actually</em> helpful.</p>",
        "id": 214338523,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603472319
    },
    {
        "content": "<p>(If you meant to ping them, you have to include the J at the end.)</p>",
        "id": 214410262,
        "sender_full_name": "Lokathor",
        "timestamp": 1603516594
    },
    {
        "content": "<p>(yeah that ping didn't work, just noticed this by accident^^)</p>",
        "id": 214426713,
        "sender_full_name": "RalfJ",
        "timestamp": 1603544562
    },
    {
        "content": "<blockquote>\n<p>I'll try to sketch this out sometime in the next week. Briefly: The safety invariant on Here!() that is that the resulting type should not appear (per the type privacy rules) in the public API of the module it's invoked in.</p>\n</blockquote>\n<p>Is that enough? Don't you also need to ensure that nothing inside this module calls generic functions outside the module with the \"private type\" as a parameter? That seems really hard to ensure.</p>",
        "id": 214426747,
        "sender_full_name": "RalfJ",
        "timestamp": 1603544626
    },
    {
        "content": "<p>No, that sort of delegation is the whole point of making <code>Scope</code> an explicit type parameter.</p>",
        "id": 214426853,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603544734
    },
    {
        "content": "<p>oh... that seems extremely subtle then. how do you protect against accidentally leaking the type?</p>",
        "id": 214427186,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545163
    },
    {
        "content": "<p>also doesn't this mean you assume that the called code does not somehow \"store\" the type through mechanisms such as <code>dyn Trait</code> or <code>type_id</code>?</p>",
        "id": 214427202,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545195
    },
    {
        "content": "<p>The type privacy rules seem to do a REALLY good of job if making it impossible to leak <code>Here!()</code>.</p>\n<p>You assume the called code upholds its contract. I'm not sure about storing mechanisms. There is no <code>Scope</code> trait. I'm not sure how <code>type_id</code> would be used to store a type in a recoverable way.</p>",
        "id": 214427446,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603545505
    },
    {
        "content": "<blockquote>\n<p>The type privacy rules seem to do a REALLY good of job if making it impossible to leak Here!().</p>\n</blockquote>\n<p>Ugh... so we're relying on those rules accidentally being entirely airtight? My impression was that these are mostly a lint</p>",
        "id": 214427486,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545595
    },
    {
        "content": "<p>They seem to be errors.</p>",
        "id": 214427530,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603545618
    },
    {
        "content": "<p>(All of this is a somewhat moot point since this mechanism needs to be removed from the RFC.)</p>",
        "id": 214427533,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603545629
    },
    {
        "content": "<p>sure, I didnt mean on the technical level</p>",
        "id": 214427536,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545635
    },
    {
        "content": "<p>more like how <code>mut</code> is a lint</p>",
        "id": 214427540,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545641
    },
    {
        "content": "<p>Gotcha.</p>",
        "id": 214427550,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603545654
    },
    {
        "content": "<p>as in, it's good to have the compiler prevent is from mutating all locals, but it's not critical for the safety story or so</p>",
        "id": 214427560,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545673
    },
    {
        "content": "<blockquote>\n<p>There is no Scope trait. </p>\n</blockquote>\n<p>Sure... but you could use <code>dyn Any</code> or so I assume? Or do you rely on <code>Scope</code> not implementing <em>any</em> trait whatsoever?</p>",
        "id": 214427576,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545714
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214427533\">said</a>:</p>\n<blockquote>\n<p>(All of this is a somewhat moot point since this mechanism needs to be removed from the RFC.)</p>\n</blockquote>\n<p>I find it independently intellectually interesting to figure out what this mechanism relies on and what it can be used for -- but I can understand if you want to focus on more productive discussions.^^</p>",
        "id": 214427627,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545760
    },
    {
        "content": "<blockquote>\n<p>The type privacy rules seem to do a REALLY good of job if making it impossible to leak Here!().</p>\n</blockquote>\n<p>I seem to recall proposals to relax those rules... but I do not remember what the status of that is</p>",
        "id": 214427691,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545851
    },
    {
        "content": "<p>No, I find it interesting too. There is a fundamental safety discussion here: whether the type privacy rules can be used for safety guarantees.</p>",
        "id": 214427693,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603545860
    },
    {
        "content": "<p>I'm currently on mobile, but try playing around with this example: <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=c711d84abd5187cdb52d90d603601da6\">https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=c711d84abd5187cdb52d90d603601da6</a></p>",
        "id": 214427710,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603545896
    },
    {
        "content": "<p>OTOH <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0136-no-privates-in-public.md\">https://github.com/rust-lang/rfcs/blob/master/text/0136-no-privates-in-public.md</a> seems to support your statement that this is something one should be able to rely on</p>",
        "id": 214427723,
        "sender_full_name": "RalfJ",
        "timestamp": 1603545915
    },
    {
        "content": "<p>Using impl Any also produces hard errors.</p>",
        "id": 214427726,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603545923
    },
    {
        "content": "<p>ah I mean this one I think: <a href=\"https://github.com/rust-lang/rfcs/pull/2145\">https://github.com/rust-lang/rfcs/pull/2145</a></p>",
        "id": 214427831,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546040
    },
    {
        "content": "<p>latest text: <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md\">https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md</a></p>",
        "id": 214427836,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546058
    },
    {
        "content": "<p>Yeah, that's the RFC I've been referencing. :)</p>",
        "id": 214427838,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603546065
    },
    {
        "content": "<p>right, that still builds on type privacy. seems like I misremembered.</p>",
        "id": 214427937,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546191
    },
    {
        "content": "<p>okay so <code>dyn Trait</code> smuggling cannot work if the type is uninhabited</p>",
        "id": 214427996,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546254
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214426853\">said</a>:</p>\n<blockquote>\n<p>No, that sort of delegation is the whole point of making <code>Scope</code> an explicit type parameter.</p>\n</blockquote>\n<p>That however feels like quite the departure from the line of arguments you follow in the RFC -- that this is about relying on the tried-and-proven concept of visibility. Rust's visibility system does not have a notion of delegation after all. My private fields can be accessed only inside the module, not inside this module <em>and all other modules I delegate my scope handle to</em> (deliberately or accidentally). So this does introduce an entirely new kind of visibility system that requires different reasoning principles to support delegation.</p>",
        "id": 214428160,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546448
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214427996\">said</a>:</p>\n<blockquote>\n<p>okay so <code>dyn Trait</code> smuggling cannot work if the type is uninhabited</p>\n</blockquote>\n<p>(but IIRC your blogpost does not say that making the type uninhabited is crucial, so I wonder what this means for type-privacy-based reasoning in general... probably that you must never leak a value of this type outside the module)</p>",
        "id": 214428265,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546593
    },
    {
        "content": "<p>I can see that argument.</p>",
        "id": 214428275,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603546615
    },
    {
        "content": "<blockquote>\n<p>So this does introduce an entirely new kind of visibility system that requires different reasoning principles to support delegation.</p>\n</blockquote>\n<p>Or, well, maybe I should say it introduces a significant extension of the visibility system.</p>",
        "id": 214428362,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546695
    },
    {
        "content": "<p>The <em>goal</em> is to express the constructability analysis in-language in a way that reflects the visibility of fields.</p>",
        "id": 214428366,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603546707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214428366\">said</a>:</p>\n<blockquote>\n<p>The <em>goal</em> is to express the constructability analysis in-language in a way that reflects the visibility of fields.</p>\n</blockquote>\n<p>Yeah I understood that. In the RFC thread I am arguing that this might not be a goal we want to pursue; but for the purpose of this discussion I am willing to take that as a given and explore how we might reach it.</p>",
        "id": 214428404,
        "sender_full_name": "RalfJ",
        "timestamp": 1603546773
    },
    {
        "content": "<p>FWIW I cannot think of any way to do weird things with <code>type_id</code> either... it's not like you can synthesize the type name <code>T</code> at compile time even if you have its ID at runtime.</p>",
        "id": 214428710,
        "sender_full_name": "RalfJ",
        "timestamp": 1603547133
    },
    {
        "content": "<p>So the qualm, as I understand it, is that access to <code>Scope</code> gives you the ability to fiddle with fields via transmutation.</p>\n<p>Rust has a few mechanisms for letting outsiders fiddle with a type's innards. The primary mechanism is field visibility. <code>DerefMut</code> also comes to mind. In both cases,  if you do not want outsiders to have access to your type's innards, you don't make your fields pub for unwelcome parties, or impl DerefMut.</p>\n<p>Analogously: don't delegate <code>Here!()</code> if your type has internal invariants it needs to maintain.</p>",
        "id": 214428711,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1603547135
    },
    {
        "content": "<p>however, that RFC explicitly mentions <code>impl Trait</code> as a way to \"leak\" private types, I wonder if there is anything there</p>",
        "id": 214428721,
        "sender_full_name": "RalfJ",
        "timestamp": 1603547152
    },
    {
        "content": "<blockquote>\n<p>Analogously: don't delegate Here!() if your type has internal invariants it needs to maintain.</p>\n</blockquote>\n<p>That's a completely new kind of thing to be wary of though. Now I need to, what, carefully audit every call to other crates' functions to see if the (entirely implicit!) type parameters leak my scope, or so?</p>",
        "id": 214428801,
        "sender_full_name": "RalfJ",
        "timestamp": 1603547227
    },
    {
        "content": "<p>so far it's all about visibility, and then about code I write that works on private fields -- <code>impl DerefMut</code> alone is not enough, it needs actual code in there that works with my private field.</p>",
        "id": 214428828,
        "sender_full_name": "RalfJ",
        "timestamp": 1603547271
    },
    {
        "content": "<p>unsafe code authors in rust are used to auditing what happens with their private fields, and this is not even Rust-specific, many languages work this way</p>",
        "id": 214428880,
        "sender_full_name": "RalfJ",
        "timestamp": 1603547301
    },
    {
        "content": "<blockquote>\n<p>Now I need to, what, carefully audit every call to other crates' functions to see if the (entirely implicit!) type parameters leak my scope, or so?</p>\n</blockquote>\n<p>Also this makes type inference failing on ambiguity safety-critical... at least I think this is the only barrier protecting us from these implicit parameters changing in the future to actually leak the thing we do not want to leak.<br>\nMaybe I am overestimating how hard this would be in practice, but it seems at least potentially problematic.</p>",
        "id": 214429921,
        "sender_full_name": "RalfJ",
        "timestamp": 1603548657
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214428160\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"219211\">Jack Wrenn</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214426853\">said</a>:</p>\n<blockquote>\n<p>No, that sort of delegation is the whole point of making <code>Scope</code> an explicit type parameter.</p>\n</blockquote>\n<p>That however feels like quite the departure from the line of arguments you follow in the RFC -- that this is about relying on the tried-and-proven concept of visibility. Rust's visibility system does not have a notion of delegation after all. My private fields can be accessed only inside the module, not inside this module <em>and all other modules I delegate my scope handle to</em> (deliberately or accidentally). So this does introduce an entirely new kind of visibility system that requires different reasoning principles to support delegation.</p>\n</blockquote>\n<p>I think this is a fair point, so what I'd suggest is to have a special syntax to signify this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">//! Modulo exact syntax bikeshed, of course</span>\n\n<span class=\"k\">mod</span> <span class=\"nn\">boundary</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Here</span><span class=\"o\">!</span><span class=\"p\">();</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"cp\">#[safe_transmute_attrs]</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">MyNonZeroU8</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">pub</span><span class=\"p\">(</span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">Here</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"c1\">// expresses that the `Here` token grants visibility and thus access to `.value`</span>\n<span class=\"w\">        </span><span class=\"n\">value</span>: <span class=\"kt\">u8</span><span class=\"p\">,</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">MyNonZeroU8</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">new</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">value</span>: <span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Option</span><span class=\"o\">&lt;</span><span class=\"bp\">Self</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n\n<span class=\"w\">        </span><span class=\"k\">pub</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">get_value</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">NonZeroU8</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">                </span><span class=\"c1\">// Safety: within the `boundary`, the `Here` token has been given to:</span>\n<span class=\"w\">                </span><span class=\"c1\">//  1. neither an API that would then alter `.value`,</span>\n<span class=\"w\">                </span><span class=\"c1\">//  2. nor an unknown generic API (since it could, transitively, lead to `1.`)</span>\n<span class=\"w\">                </span><span class=\"n\">NonZeroU8</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 214432006,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1603551575
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214428265\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214427996\">said</a>:</p>\n<blockquote>\n<p>okay so <code>dyn Trait</code> smuggling cannot work if the type is uninhabited</p>\n</blockquote>\n<p>(but IIRC your blogpost does not say that making the type uninhabited is crucial, so I wonder what this means for type-privacy-based reasoning in general... probably that you must never leak a value of this type outside the module)</p>\n</blockquote>\n<p>What's the routine for calling <code>ctf()</code> using <code>dyn Trait</code> if <code>Here</code> <em>is</em> inhabited?</p>",
        "id": 215396999,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1604362687
    },
    {
        "content": "<p>I think I was imagining <a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=628723dd4f7cd94625d61ccc45f16328\">something like this</a>... this does not quite work but maybe with specialization it does?</p>",
        "id": 216002557,
        "sender_full_name": "RalfJ",
        "timestamp": 1604834704
    },
    {
        "content": "<p>AFAIK specialization is intended to \"see through\" <code>impl Trait</code></p>",
        "id": 216002569,
        "sender_full_name": "RalfJ",
        "timestamp": 1604834724
    },
    {
        "content": "<p>(not sure what I had in mind with <code>dyn Trait</code> TBH)</p>",
        "id": 216002577,
        "sender_full_name": "RalfJ",
        "timestamp": 1604834738
    },
    {
        "content": "<p>Some archeology: The type privacy rules <a href=\"https://github.com/rust-lang/rfcs/pull/2145#issuecomment-329023808\">sprung</a> from <a href=\"https://internals.rust-lang.org/t/lang-team-minutes-private-in-public-rules/4504\">this internals discussion</a>, which sheds some light on the motivation behind it:</p>\n<blockquote>\n<p>Their intention is to ensure that if you have a private struct, then nobody outside of the module can get their hands on an instance of that struct, and nor can they name the type. This implies that <strong>methods defined on that private struct (<em>including methods from public traits like <code>Clone</code> which don’t have privacy protections</em>) cannot be invoked except for within the module that defined it</strong>. <strong>This is a useful guarantee for unsafe code.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>\"Local\" trait implementations weren't a hacky accident of type privacy—they were a key motivation!</p>",
        "id": 216525675,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605213864
    },
    {
        "content": "<p>but note that that comment is about \"methods on that struct\", i.e., methods that <em>actually take some value of the struct as a parameter</em> (possibly by reference)</p>",
        "id": 216588075,
        "sender_full_name": "RalfJ",
        "timestamp": 1605260720
    },
    {
        "content": "<p>that is a very different approach from what you have been doing, where there is no value, just a type parameter</p>",
        "id": 216588086,
        "sender_full_name": "RalfJ",
        "timestamp": 1605260728
    },
    {
        "content": "<p>The Type Privacy RFC makes no such distinction—it doesn't treat type privacy differently based on whether a value is involved or not.</p>",
        "id": 216609923,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605274265
    },
    {
        "content": "<p>Actually, it's <a href=\"https://github.com/petrochenkov/rfcs/blob/9901089b2467b0813456479ba03642e9f0ac0912/text/0000-type-privacy.md#additional-restrictions-for-associated-items\">explicit about this point</a>:</p>\n<blockquote>\n<p>When associated function is defined in a private impl (i.e. the impl type or trait is private) it's guaranteed that the function can't be used outside of the impl's area of visibility. [...] As a result, type privacy additionally prohibits use of any associated items from private impls.</p>\n</blockquote>",
        "id": 216627236,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605281668
    },
    {
        "content": "<blockquote>\n<p>type privacy additionally prohibits use of any associated items from private impls.</p>\n</blockquote>\n<p>Interesting.<br>\nHowever, IIRC, in your proposal, it the \"protected\" item wasn't even an associated item of the \"private impl\", right? IIRC <code>Scope</code> was a marker trait, so it has no associated items. It was more like the private impl enabling other (public) impls to be used and then <em>those</em> have associated items that are useful?</p>",
        "id": 216725894,
        "sender_full_name": "RalfJ",
        "timestamp": 1605356229
    },
    {
        "content": "<p>Scope isn't a trait at all. It's a type parameter on <code>TransmuteFrom</code> that, when instantiated with a private type (<code>Here!()</code>), makes an implementation of <code>TransmuteFrom</code> a \"private impl\".</p>\n<p>Since <code>TransmuteFrom</code> is a private impl, you can't call its <code>transmute_from</code> associated function.</p>",
        "id": 216726397,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605357061
    },
    {
        "content": "<p>sorry, yeah, I am mixing things up again.<br>\nI think you are still slightly extending what is described there though: \"the impl type or trait is private\" is extended to also include \"a type parameter of the impl type is private\".</p>",
        "id": 216728859,
        "sender_full_name": "RalfJ",
        "timestamp": 1605360135
    },
    {
        "content": "<p>which maybe doesn't make such a big difference, I dont have good enough intuition for this to tell</p>",
        "id": 216728873,
        "sender_full_name": "RalfJ",
        "timestamp": 1605360182
    },
    {
        "content": "<p>I think that behavior is described here:</p>\n<blockquote>\n<ul>\n<li>Traits or trait types are as visible as their least visible type argument or trait constructor.<br>\n<code>vis(Tr&lt;A, B&gt;) = min(vis(Tr), vis(A), vis(B))</code>.</li>\n</ul>\n</blockquote>\n<p>The RFC could be phrased a little more clearly here. I believe this is referring to trait <em>implementations</em>, since it's only in the context of implementations that trait type arguments have any privacy at all (per the second bullet point on that list).</p>\n<p>There's also this next bullet point:</p>\n<blockquote>\n<ul>\n<li>Trait objects and impl Trait types are as visible as their least visible component.<br>\n<code>vis(TrA + TrB) = vis(impl TrA + TrB) = min(vis(TrA), vis(TrB)).</code></li>\n</ul>\n</blockquote>",
        "id": 216736210,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605369891
    },
    {
        "content": "<p>Another relevant bullet point:</p>\n<blockquote>\n<p>For trait methods components include signature, trait, <strong>type parameters</strong> (including impl type Self) and the method item's nominal visibility (inherited from the trait, included automatically).<br>\n<code>vis(fn(A, B) -&gt; R { &lt;Type as Trait&gt;::foo&lt;C&gt; })) = min(vis(fn(A, B) -&gt; R), vis(C), vis(Type), vis(Trait)).</code></p>\n</blockquote>\n<p>(emphasis mine)</p>",
        "id": 216736799,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605370659
    },
    {
        "content": "<p>Anyways, perhaps <a href=\"https://github.com/rust-lang/rfcs/pull/2145#issuecomment-727232373\">best to go to the source</a>!</p>",
        "id": 216737775,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605371919
    },
    {
        "content": "<p>And a <a href=\"https://github.com/rust-lang/rfcs/pull/2145#issuecomment-727233646\">response</a>!</p>\n<blockquote>\n<p>There is this line</p>\n<blockquote>\n<p>When associated function is defined in a <strong>private impl (i.e. the impl type or trait is private)</strong> it's guaranteed that the function can't be used outside of the impl's area of visibility.</p>\n</blockquote>\n<p>where \"impl type or trait\" include their generic parameters as well.</p>\n</blockquote>",
        "id": 216738718,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605372883
    },
    {
        "content": "<p>I see, thanks!</p>",
        "id": 216786661,
        "sender_full_name": "RalfJ",
        "timestamp": 1605439526
    },
    {
        "content": "<p>so do we have \"private impls\" in Rust unbeknownst do the lang team? that doesn't seem right either^^</p>",
        "id": 216786711,
        "sender_full_name": "RalfJ",
        "timestamp": 1605439603
    },
    {
        "content": "<p>personally, I really hope someone can model this formally some day. I won't trust it until I know how to prove it. but I also know my standards are absurdly high.</p>",
        "id": 216786726,
        "sender_full_name": "RalfJ",
        "timestamp": 1605439623
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/214427486\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>The type privacy rules seem to do a REALLY good of job if making it impossible to leak Here!().</p>\n</blockquote>\n<p>Ugh... so we're relying on those rules accidentally being entirely airtight? My impression was that these are mostly a lint</p>\n</blockquote>\n<p>They are very intentionally airtight.<br>\nIf they were not we could get link-time errors on use of private entities because our link-time symbol exporting strategy is based on type privacy.</p>",
        "id": 216805918,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1605464075
    },
    {
        "content": "<p>(The alternative would be exporting <em>everything</em> at link time, but that's certainly not good.)</p>",
        "id": 216805944,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1605464140
    },
    {
        "content": "<p>well, it is possible to explicitly \"leak\" these types to enable delegation though, or at leats I thought we had that established?</p>",
        "id": 216809786,
        "sender_full_name": "RalfJ",
        "timestamp": 1605469111
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> can answer better than I, but I'm pretty those apparent \"leaks\" disappear after monomorphization.</p>",
        "id": 216810103,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605469420
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216809786\">said</a>:</p>\n<blockquote>\n<p>well, it is possible to explicitly \"leak\" these types to enable delegation though, or at leats I thought we had that established?</p>\n</blockquote>\n<p>I'm not sure what delegation you are talking about.</p>",
        "id": 216810415,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1605469694
    },
    {
        "content": "<p>I <em>think</em> <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> is referring to this sort of situation in \"crate_c\": <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5f224f0fac59f412d9c71435d576a524\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5f224f0fac59f412d9c71435d576a524</a></p>\n<p>(I edited this example a few times, <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span>, so if you already clicked the link, click again!)</p>",
        "id": 216811229,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605470456
    },
    {
        "content": "<p>A similar case of this in the standard library is <code>From</code> and <code>Into</code>.</p>\n<p>If you define a private implementation of <code>From</code>; i.e., either:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">struct</span> <span class=\"nc\">Private</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Public</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">Private</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Public</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"nb\">From</span><span class=\"o\">&lt;</span><span class=\"n\">Public</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Private</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>...then <em>you</em> can still take advantage of the blanket impl on <code>Into</code> provided by libcore. For instance, if a third-party crate defines a function:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">is_convertible</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"k\">where</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">T</span>: <span class=\"nb\">Into</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"o\">&gt;</span><span class=\"w\"></span>\n<span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><em>you</em> can call that function with <code>Public</code> and <code>Private</code> <em>even though the implementations of <code>From</code> for those types is private</em>.</p>",
        "id": 216822070,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605485400
    },
    {
        "content": "<p>how would you call that with <code>Public</code> and <code>Private</code> if <code>Private</code> is not accessible?</p>",
        "id": 216822262,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485671
    },
    {
        "content": "<p>It's only <em>within</em> the module defining <code>Public</code> and <code>Private</code> can you make that call.</p>",
        "id": 216822272,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605485711
    },
    {
        "content": "<p>but then the impls are visible too?</p>",
        "id": 216822346,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485879
    },
    {
        "content": "<p>Yes, within the module defining those types. Sorry, I used \"private impls\" as a shorthand to mean \"private outside this module.\"</p>",
        "id": 216822385,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605485916
    },
    {
        "content": "<p>or is this some situation where the impls are <em>even more</em> private than the <code>Private</code></p>",
        "id": 216822393,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605485947
    },
    {
        "content": "<p>It's not that sort of situation.</p>",
        "id": 216822478,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605486086
    },
    {
        "content": "<p>Have you <a href=\"https://jack.wrenn.fyi/blog/private-trait-impls/\">read this</a> by any chance? It might clarify what we mean by impl privacy.</p>",
        "id": 216822527,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605486157
    },
    {
        "content": "<p>I <em>think</em> <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> is asking about whether you can make use of private impls across generic abstractions. <code>From</code> and its generic abstraction <code>Into</code> are prime examples of this. Check out this playground snippet for a full example: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ba50ce384e29dbe2a36c4d7a0af1307c\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=ba50ce384e29dbe2a36c4d7a0af1307c</a></p>",
        "id": 216822610,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605486316
    },
    {
        "content": "<p>You couldn't, however \"see\" <code>&lt;Private as Into&lt;Public&gt;</code> or <code>&lt;Public as Into&lt;Private&gt;</code> <em>outside</em> of <code>crate_b</code> in that snippet, though.</p>",
        "id": 216822659,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605486376
    },
    {
        "content": "<p>So it's obvious to me that <code>is_convertible::&lt;Public, Private&gt;()</code> can't textually be written outside the module, but perhaps your point is that type privacy is ensuring that there is no way to get a call to the function by other means either?</p>",
        "id": 216822670,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605486420
    },
    {
        "content": "<p>In order to get some formal proof content out of this guarantee you would need the latter, which I guess is hard because of type inference. At least that's my understanding of Ralf's worry</p>",
        "id": 216822730,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605486529
    },
    {
        "content": "<p>Actually, there <em>is</em> a deliberate hole in type privacy that <em>does</em> let us write <code>is_convertible::&lt;Public, Private&gt;()</code>outside of <code>crate_b</code> and therefore lets us observe that the <em>rest</em> of type privacy can be depended on to produce an error in that case.</p>\n<p>You can see that at work here: <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=35c0405857cb3b0548cc2a838fff5d48\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=35c0405857cb3b0548cc2a838fff5d48</a></p>",
        "id": 216822844,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605486743
    },
    {
        "content": "<p>I think your understanding of <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>'s worry is correct. <span class=\"user-mention\" data-user-id=\"123856\">@Vadim Petrochenkov</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216805918\">observes that Rust *already* depends on these rules being airtight</a>.</p>",
        "id": 216822906,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605486851
    },
    {
        "content": "<p>Impls don't have an explicit privacy setting, but it seems like you can say that they have the minimum visibility of the trait, and values for parameter types (but not associated types). Then a given function application involves chaining some impls together to prove the where clauses, and the minimum visibility of all those impls, the parameter types, and the function itself should be at least at the visibility level of the module containing the function call.</p>\n<p>I think that can be formalized, over the \"visibility lattice\" consisting of <code>pub</code> and the modules ordered by nesting, with a bottom element for failure. Then the various public in private errors become the necessary conditions to establish well nesting of visibilities: for example, the general theorem that the associated types of an impl must be more visible than the impl itself, is enforced by a privacy check.</p>\n<p>I think my model might still be off, because in <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=8921ede3d294d9c6438a050704c4c034\">this example</a></p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">super</span>::<span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">super</span>::<span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">Private</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">type</span> <span class=\"nc\">A</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Private</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">mk</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Private</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Private</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>the definition of \"impl visibility\" I gave would say that this impl is private, because it uses the private type <code>Private</code> in its where clause, but the error says that this is a public impl and errors on <code>type A = Private</code> as a private-in-public error.</p>",
        "id": 216824317,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605489102
    },
    {
        "content": "<p>Oh, it seems that where clauses don't count toward impl visibility, and must in turn be at least as visible as the impl itself, which I guess makes sense</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">mod</span> <span class=\"nn\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Private</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">super</span>::<span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"k\">where</span><span class=\"w\"> </span><span class=\"n\">T</span>: <span class=\"nc\">super</span>::<span class=\"n\">Bar</span><span class=\"o\">&lt;</span><span class=\"n\">Private</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"> </span><span class=\"c1\">// ERROR: private type `Private` in public impl</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 216824439,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605489301
    },
    {
        "content": "<p>Yep! Have you see the <a href=\"https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md\">Type Privacy RFC</a>, yet? Its rules are what's underpinning our current discussion. When we say \"private impl\", we mean it in the sense of that RFC.</p>",
        "id": 216824450,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605489320
    },
    {
        "content": "<p>yes, I've read it. I'm trying to see what it would take to formalize</p>",
        "id": 216824510,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605489369
    },
    {
        "content": "<p>So in the RFC, it's a \"double check\"? I.e. we have the local rules on impls already, but there is also a check at actual point of use (that in principle should have been stopped by the lints)?</p>",
        "id": 216824585,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605489506
    },
    {
        "content": "<p>Is this only because of the leaky public-in-private warning, or is it because we don't trust that the rest of it is actually airtight</p>",
        "id": 216824606,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605489567
    },
    {
        "content": "<p>If there is a check at point of use, it's not hard to make it airtight: If you check that X holds then it does. The system of local checks don't matter in that case</p>",
        "id": 216824680,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605489674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216824585\">said</a>:</p>\n<blockquote>\n<p>So in the RFC, it's a \"double check\"? I.e. we have the local rules on impls already, but there is also a check at actual point of use (that in principle should have been stopped by the lints)?</p>\n</blockquote>\n<p>Type privacy check at the point of use is the <em>main</em> check, it's fully implemented and works correctly (to extent of my knowledge).<br>\nThe local check (private-in-public lint) is badly working, leaky and the intention is to remove it and replace with a couple of lints that work slightly differently, using reachability heuristics (the RFC writes about this).</p>",
        "id": 216848847,
        "sender_full_name": "Vadim Petrochenkov",
        "timestamp": 1605519165
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216824510\">said</a>:</p>\n<blockquote>\n<p>yes, I've read it. I'm trying to see what it would take to formalize</p>\n</blockquote>\n<p>awesome. :)<br>\nto be clear, what I meant by \"formalize\" is having formal reasoning principles for unsafe code that exploit this. something like what <a href=\"https://plv.mpi-sws.org/rustbelt/popl18/\">this paper</a> did for the way more common pattern of unsafe code relying on field privacy (which enables unsafe code to attach invariants to all inhabitants of a type, which is really the foundation of everything in that paper). of course I do not expect something fully worked out and formalized in Coq^^ but so far I couldn't even <em>sketch</em> a soundness proof of a module relying on type privacy. To be fair, I also did not spend much time trying to come up with such a sketch.<br>\nit'd be great to have a small self-contained example of code needing type privacy (<span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> has posted such examples in the past), adjusting it so that type privacy is truly needed <em>for soundness</em> (i.e., adding a <code>pub</code> somewhere lets safe code actually cause UB), and then start sketching out a solid argument for soundness of this code.</p>",
        "id": 216849384,
        "sender_full_name": "RalfJ",
        "timestamp": 1605519513
    },
    {
        "content": "<p>I think the basic mechanism behind turning type privacy into a logical invariant is that the \"soundness\" property of a safe private function (one that does not use <code>unsafe fn</code>) quantifies not over all possible safe code that pokes at the function, but instead comes with its own invariant, where the invariant only has to hold over all callers inside the module, which by type privacy are all possible callers. In other words, it is a license to treat a <code>fn</code> as if it was <code>unsafe fn</code>, with possible nontrivial preconditions.</p>",
        "id": 216854018,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605522585
    },
    {
        "content": "<p>For example, both functions <code>f</code> and <code>foo</code> are sound in the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">42</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>foo</code> is safe because it just returns <code>42</code>, and <code>f</code> is safe because it can only be called on <code>&amp;42</code></p>",
        "id": 216854354,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605522787
    },
    {
        "content": "<p>Now that uses a private function instead of a private type, but the idea is the same. A type permits access to various trait impl functions, which in turn can have narrow contracts. Here is an example with a private type:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">mod</span> <span class=\"nn\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"k\">super</span>::<span class=\"n\">Foo</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">struct</span> <span class=\"nc\">Private</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Foo</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Private</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Private</span>::<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">42</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">evil</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">a</span>::<span class=\"n\">Private</span>::<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">std</span>::<span class=\"n\">ptr</span>::<span class=\"n\">null</span><span class=\"p\">())</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The function <code>evil()</code> doesn't compile due to type privacy, but if <code>Private</code> were public it would cause UB. Here we can argue that the implementation of <code>Private::f</code> is sound even though it doesn't match the contract of the global <code>Foo</code> trait (which necessarily has a broad contract since it is a safe function) because we can enumerate all possible callers of <code>Private::f</code> and they only ever call it in a safe way.</p>",
        "id": 216855918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1605523839
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> interestingly enough, not even type inference can bypass this kind of privacy <span aria-label=\"dizzy\" class=\"emoji emoji-1f635\" role=\"img\" title=\"dizzy\">:dizzy:</span> <span aria-label=\"muscle\" class=\"emoji emoji-1f4aa\" role=\"img\" title=\"muscle\">:muscle:</span> : <a href=\"https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=69d243b468bfbafc4f44da1dce615b0a\">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=69d243b468bfbafc4f44da1dce615b0a</a></p>",
        "id": 217119994,
        "sender_full_name": "Daniel Henry-Mantilla",
        "timestamp": 1605697053
    },
    {
        "content": "<p>Yeah, that's by design! It's awesome.</p>",
        "id": 217139763,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1605709228
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Type.20Privacy.20.26.20Safety/near/216854354\">said</a>:</p>\n<blockquote>\n<p>For example, both functions <code>f</code> and <code>foo</code> are sound in the following code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">mod</span> <span class=\"nn\">a</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u8</span> <span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"mi\">42</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p><code>foo</code> is safe because it just returns <code>42</code>, and <code>f</code> is safe because it can only be called on <code>&amp;42</code></p>\n</blockquote>\n<p>to me that sounds like just saying, private functions do not have to be sound. there's nothing useful to show about <code>f</code> (except private internal lemmas), which means every caller needs to carefully justify its call, which could be considered okay because <code>f</code> is private.<br>\nbut I do not see how that helps to talk about public functions, where we need a proof that they abide by the contract determined by their type.</p>",
        "id": 217500176,
        "sender_full_name": "RalfJ",
        "timestamp": 1605962309
    },
    {
        "content": "<p>I think that's more or less correct. Private functions are effectively <code>unsafe</code> by default: they can have additional preconditions for soundness beyond what their type says, and as long as all callers in the module abide by these added preconditions then everything is a-ok because outside the module they aren't just unsafe, they are not callable at all. (Of course, a private function can also choose to not have preconditions, and just be sound in the usual sense. But this isn't a requirement.) For public functions, they need to abide by the contract determined by their type, that is as it always has been.</p>",
        "id": 217524854,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606002173
    },
    {
        "content": "<blockquote>\n<p>Private functions are effectively unsafe by default: they can have additional preconditions for soundness beyond what their type says, and as long as all callers in the module abide by these added preconditions then everything is a-ok because outside the module they aren't just unsafe, they are not callable at all. </p>\n</blockquote>\n<p>That's a matter of convention. I'd call even a private function unsound if safe code can cause UB by calling it. We can of course make private functions sound <em>by fiat</em> but I don't think that actually provides any <em>insight</em>, and I do not see how it helps explain private types.</p>",
        "id": 217544205,
        "sender_full_name": "RalfJ",
        "timestamp": 1606039594
    }
]