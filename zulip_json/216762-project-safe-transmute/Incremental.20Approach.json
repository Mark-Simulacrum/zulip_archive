[
    {
        "content": "<p>As I was falling asleep last night, I was thinking about whether a much more incremental approach might help cut down the RFC significantly.</p>\n<p>Concretely, we reduce the <em>initial</em> proposal to <em>just</em> this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[derive(PartialEq, Eq)]</span><span class=\"w\"></span>\n<span class=\"cp\">#[non_exhaustive]</span><span class=\"w\"></span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">alignment</span><span class=\"w\">   </span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">lifetimes</span><span class=\"w\">   </span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">validity</span><span class=\"w\">    </span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"n\">visibility</span><span class=\"w\">  </span>: <span class=\"kt\">bool</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">NOTHING</span>: <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">Neglect</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">alignment</span><span class=\"w\">   </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">lifetimes</span><span class=\"w\">   </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">validity</span><span class=\"w\">    </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">visibility</span><span class=\"w\">  </span>: <span class=\"nc\">false</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">};</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">is_transmutable_from</span><span class=\"o\">&lt;</span><span class=\"n\">Src</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Dst</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Scope</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">_</span>: <span class=\"nc\">Neglect</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">bool</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"cm\">/* compiler intrinsic */</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 218232202,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606686286
    },
    {
        "content": "<p><a href=\"https://play.rust-lang.org/?version=nightly&amp;mode=debug&amp;edition=2018&amp;gist=9b5551f37af7c4dbda51502e9f99ea26\">*Everything* else we've discussed can be built on that foundation.</a></p>",
        "id": 218232302,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606686426
    },
    {
        "content": "<p>i wonder if Neglect being a parameter makes sense? when would you dynamically determine those things? and how would that work</p>",
        "id": 218234776,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606690372
    },
    {
        "content": "<p>It feels like it works more as a const parameter, i mean.</p>",
        "id": 218234783,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606690399
    },
    {
        "content": "<p>But perhaps thats too far off.</p>",
        "id": 218234784,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606690406
    },
    {
        "content": "<p>No, that's a really good observation. It <em>should</em> be a const param, I think.</p>",
        "id": 218234840,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606690498
    },
    {
        "content": "<p>Besides that, I really like this. It's very simple and is relatively clear how to build stuff on top of it. I've struggled to understand some of the earlier proposals despite being the author of a few of <code>bytemuck</code>'s traits (So if nothing else I'm somewhat aware of the design space), but find this a lot simpler and more clear.</p>",
        "id": 218235031,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606690806
    },
    {
        "content": "<p>This would mandate const generics for some use cases that wouldn't need them with the more complex approach, right?</p>",
        "id": 218239575,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1606697851
    },
    {
        "content": "<p>Also, I feel like Neglect isn't the complex part of the RFC. <code>Here!</code> is.</p>",
        "id": 218239579,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1606697879
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218239579\">said</a>:</p>\n<blockquote>\n<p>Also, I feel like Neglect isn't the complex part of the RFC. <code>Here!</code> is.</p>\n</blockquote>\n<p>That's fair, although this is simpler in that it boils the complex thing down to just that, as opposed to that + a family of traits.</p>",
        "id": 218239644,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606697971
    },
    {
        "content": "<p>I'm not trying to simplify <code>Neglect</code> with this incremental suggestionâ€”we need to wrestle with how that's encoded regardless.</p>",
        "id": 218239649,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606697990
    },
    {
        "content": "<p>Er, <code>Here!()</code> isn't part of this suggestion.</p>",
        "id": 218239722,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606698066
    },
    {
        "content": "<p>Scope is tho, which is what <code>Here!()</code> is for, no?</p>",
        "id": 218239796,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606698193
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span>  <code>Here!()</code> is just an ergonomic device. It's totally not central and it'd perhaps be best if we forgot I suggested it. ;)</p>\n<p><code>Scope</code> works like so:</p>\n<ul>\n<li>If validity is being neglected, set <code>Scope</code> to anything. It's totally ignored.</li>\n<li>If validity <em>isn't</em> being neglected, <code>Scope</code> should be instantiated with some private type. The compiler then pretends it's at the definition site of that private type, and checks to see whether the necessary fields of <code>Src</code> and <code>Dst</code> are visible at that location.</li>\n</ul>\n<p>It's what lets us answer the question of transmutation safety <em>without</em> wrestling with the design of manually implemented traits that <em>also</em> carry stability connotations.</p>",
        "id": 218239871,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606698265
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> For me, the complex part of safe transmutation is devising a satisfactory way to communicate layout semver stability. I think we're approaching a solution for one class of transmutations and stability guarantees, but there's a lot of work yet to do to work out the details, and there are <em>lots</em> of others situations we haven't yet addressed. All of these have <em>super</em> subtle tradeoffs.</p>",
        "id": 218240181,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606698735
    },
    {
        "content": "<p>Yeah, I figured it was something like that. That's a bit odd since nothing like that exists in rust currently, but hm, okay.</p>",
        "id": 218240464,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606699273
    },
    {
        "content": "<p>Heh, it's a bit unusual, but so is an intrinsic that reasons about the safety of transmutations. <span aria-label=\"smile\" class=\"emoji emoji-1f642\" role=\"img\" title=\"smile\">:smile:</span></p>",
        "id": 218240542,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606699387
    },
    {
        "content": "<p>I don't see how removing <code>Here!()</code> but not <code>Scope</code> is any less fundamentally complex. And <code>Here!()</code> being \"just an ergonomic device\" only backs that up...</p>",
        "id": 218251429,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606715917
    },
    {
        "content": "<p>I think it only working for public types would be unfortunate. That's an issue I always had with the bytemuck design (<code>ref_cast</code> has the same issue). <code>Scope</code> solves that problem in a way that seems explainable relatively simply, I wasn't really aware of what it did before <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218239871\">this</a>, and that doesn't seem that bad for a low level building-block that a higher level api can be built on top of.</p>",
        "id": 218253083,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606718434
    },
    {
        "content": "<p>The point is, again, private impls are a whole other problem space. It's really out of scope for the safe transmute RFC to try to solve that problem too- it should be addressed head-on, not as a side issue for something else.</p>",
        "id": 218311690,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606754560
    },
    {
        "content": "<p>And it's not like there aren't workarounds! Leaving the private impl question for future work doesn't block safe transmute, it just means some use cases will have some boilerplate. And that boilerplate already happens elsewhere, it's not new or unique.</p>",
        "id": 218311780,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606754608
    },
    {
        "content": "<p>Look, we could also solve safe transmute by first providing a general mechanism that reflects the structure or layouts of types, or by first providing a stable compiler plugin mechanism. Instead, we're providing a somewhat magical transmutability intrinsicâ€”we <em>don't</em> need to wait to first solve these big problems in-the-large.</p>",
        "id": 218312206,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606754789
    },
    {
        "content": "<p>Anyways, the <code>Muckable*</code> approach is unsuitable for a lot of use-cases I'm interested in exploring.  <span aria-label=\"sad\" class=\"emoji emoji-2639\" role=\"img\" title=\"sad\">:sad:</span>  It's not just a matter of boilerplate!</p>",
        "id": 218312262,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606754826
    },
    {
        "content": "<p>And the existence of a more foundational API <em>doesn't</em> preclude the existence of a scope-unaware <code>Muckable*</code> abstraction!</p>",
        "id": 218312956,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606755090
    },
    {
        "content": "<p>The difference is that we would presumably want to keep the Muckable stuff around forever, as an easier/simpler API on top of whatever the full version is. But we definitely <em>don't</em> want to keep <code>Scope</code> around forever, we want it not to exist at all.</p>",
        "id": 218313143,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606755153
    },
    {
        "content": "<p>This is getting into the same problem that the initial RFC did- targeting a big set of use cases at any cost, without really clarifying whether those use cases are worth it or whether the cost is even on the table.</p>",
        "id": 218313290,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606755220
    },
    {
        "content": "<p>I suspect the discussion would benefit from more presentation of motivating use cases, so that more brains can consider solutions for them.</p>",
        "id": 218313609,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606755342
    },
    {
        "content": "<p>I've been trying to follow all of this pretty closely but I still feel like every discussion ends with \"but &lt;this other use case&gt;\" that I wasn't aware of. :/</p>",
        "id": 218313728,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606755381
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218313143\">said</a>:</p>\n<blockquote>\n<p>But we definitely <em>don't</em> want to keep <code>Scope</code> around forever, we want it not to exist at all.</p>\n</blockquote>\n<p><strong>I categorically disagree.</strong> There's a <em>lot</em> of discussion in the <a href=\"#narrow/stream/216762-project-safe-transmute/topic/UnstableTransmuteFrom\">UnstableTransmuteFrom topic</a> about:</p>\n<ul>\n<li>why an explicit <code>Scope</code> parameter might be fundamentally necessary</li>\n<li>how it fits into rust's existing impl privacy rules</li>\n<li>how we can elide the parameter in the future if someone, someday figures out the deep issues with an implicit impl privacy system</li>\n</ul>",
        "id": 218313738,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606755386
    },
    {
        "content": "<p>Nothing in that topic convinced me that <code>Scope</code> is fundamentally necessary. <code>FromZeros</code> would work perfectly fine without it, using the newtype pattern to export a type without exporting its <code>FromZeros</code> impl.</p>",
        "id": 218314407,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606755684
    },
    {
        "content": "<p>I'd like to avoid derailing every topic with this discussion, so I'm going to create a distinct topic for every scenario.</p>",
        "id": 218320190,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606758255
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 218342116,
        "sender_full_name": "Nick12",
        "timestamp": 1606768494
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> did you catch that this proposal <em>isn't</em> suggesting a trait?</p>",
        "id": 218508517,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606876033
    },
    {
        "content": "<p>Yes. ???</p>",
        "id": 218508537,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876074
    },
    {
        "content": "<p>Sorry, you were referencing the <code>UnstableTransmuteFrom</code> trait in some of your recent messages. I just wanted to be clear that's not what's being proposed here.</p>",
        "id": 218508588,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606876111
    },
    {
        "content": "<p>Well those messages don't really change if you replace <code>UnstableTransmutableFrom</code> with <code>const fn is_trasnmutable_from</code> do they.</p>",
        "id": 218508605,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876154
    },
    {
        "content": "<p>Some of them do, I think. People <em>do</em> have an expectation that trait implementations have stability connotations. They don't have this expectation for the <code>mem</code> intrinsics.</p>",
        "id": 218508630,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606876196
    },
    {
        "content": "<p>Perhaps that's fair, but in that case why include <code>Scope</code> at all? Why not just have the <code>const fn</code> ignore visibility entirely like the other <code>mem</code> intrinsics?</p>",
        "id": 218508710,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876288
    },
    {
        "content": "<p>Does the size or alignment of a type depend on scope?</p>",
        "id": 218508775,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606876331
    },
    {
        "content": "<p>No, but neither does a type's layout.</p>",
        "id": 218508779,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876342
    },
    {
        "content": "<p>In contrast, the visibility of a field <em>does</em> matter as to whether you can safely fiddle with it.</p>",
        "id": 218508783,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606876349
    },
    {
        "content": "<p>But the scope is totally insufficient to determine whether a transmute is actually safe/visible.</p>",
        "id": 218508792,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876368
    },
    {
        "content": "<p>We'd be right back in the same place as <code>trait UnstableTransmuteFrom</code>.</p>",
        "id": 218508817,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876389
    },
    {
        "content": "<p>Whereby \"actual safe/visible\", you mean: \"The type author has declared it to be semver stable.\"</p>",
        "id": 218508823,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606876402
    },
    {
        "content": "<p>Exactly.</p>",
        "id": 218508826,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876407
    },
    {
        "content": "<p>That's just <em>not</em> what \"safe\" typically means, though. I'm using \"safety\" it in the typical sense of <em>cannot cause memory unsoundness or compiler UB</em>. (cc <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>, since I'm probably mis-paraphrasing him here.)</p>",
        "id": 218508977,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606876598
    },
    {
        "content": "<p>But it is- these things are connected! Consumer code (including unsafe consumer code) ought to be able to rely not only on the continued validity of a transmutation (it would at least stop compiling if that were the only problem) but on its meaning. Take the <code>Packet</code>/<code>Header</code> example- what if <code>Header</code>s fields are reordered (or <code>Packet</code> replaces its <code>Header</code> with <code>HeaderWithReorderedFields</code>) but it's still a <em>valid</em> transmute on its own? Now if I actually use the <code>Header</code> for something that would be sound with the original version, it may no longer be sound.</p>",
        "id": 218509089,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876742
    },
    {
        "content": "<p>This is why safety and visibility and semver are connected, and not totally separable. Something can only be sound if unsafe code's assumptions aren't violated, but those assumptions can be violated by seemingly-innocuous changes if suddenly external code can rely on those changes not happening.</p>",
        "id": 218509295,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606876964
    },
    {
        "content": "<p>And now that Rust has been around a while, we have to further keep in mind that some of those changes <em>already happen across versions.</em> There are already crates out there that change field order in minor releases, so providing a tool like <code>UnstableTransmutableFrom</code> or <code>is_transmutable_from</code> that makes field order visible is just asking for trouble.</p>",
        "id": 218509454,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606877152
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218509295\">said</a>:</p>\n<blockquote>\n<p>This is why safety and visibility and semver are connected, and not totally separable.</p>\n</blockquote>\n<p>That is not fully the case. For example, iirc the UGC opinion on unsafely creating a DST or a slice via transmute is that if you guess the field order right, there's no UB. It's unspecified behavior, not undefined. This is different from say, guessing the stack position of a local variable or the address of a call to malloc, which is UB no matter what.</p>",
        "id": 218510487,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606878462
    },
    {
        "content": "<p>They are connected in the sense that you <em>must not rely on unspecified behavior for the soundness of safe code</em>. But this is just  the reality we live in. It's not <em>just</em> <code>size_of</code>, or <code>align_of</code>, or <code>as</code> casting, it's with <code>sort_unstable</code> and <code>Range</code> edge-cases â€” with <em>anything</em> that introduces unspecified behavior. If you are writing unsafe code, the burden is on <em>you</em> to not rely on unspecified behavior.</p>\n<p>Unspecified behavior <em>isn't</em> evil. It's a fundamentally useful programming tool. Their existence isn't \"asking for trouble\". The fact that someone <em>might</em> incorrectly rely on <code>align_of</code> or <code>sort_unstable</code> isn't a convincing argument against the existence of those constructs.</p>",
        "id": 218510495,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606878481
    },
    {
        "content": "<p>What is it you plan to keep unspecified? While I agree the burden is on the unsafe code to not make assumptions not guaranteed by its dependencies, I'd also say that a transmute which just produces an unspecified value of the target type is not very useful.</p>",
        "id": 218532666,
        "sender_full_name": "RalfJ",
        "timestamp": 1606901532
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> <code>UnstableTransmuteFrom</code>/<code>is_transmutable</code> would be by-default SemVer unspecified, similar to the other <code>mem</code> intrinsics.</p>",
        "id": 218553346,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606914785
    },
    {
        "content": "<p>I don't know what this means or how it relates to other <code>mem</code> intrinsics</p>",
        "id": 218554165,
        "sender_full_name": "RalfJ",
        "timestamp": 1606915188
    },
    {
        "content": "<p>Sorry. <code>mem::align_of</code> tells you the minimum alignment of a type, but there's no connotation that that output value will remain static across SemVer minor changes to that type.</p>\n<p>Similarly, UnstableTransmuteFrom/is_transmutable would tell you whether a bit-reinterpretation cast is well defined and safeâ€”but not whether that will remain true across SemVer minor changes.</p>\n<p>(I'm not arguing against layout stability systems, to be clear. Just that this API would be a broadly useful initial foundation for layout stability abstractions.)</p>",
        "id": 218557214,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606916674
    },
    {
        "content": "<p>right... I feel there is still confusion here about the two very different usecases where the compiler can help with transmutations:</p>\n<ul>\n<li><em>inside</em> a library, with full control over both types</li>\n<li><em>across</em> library boundaries, where at least one involved type is in a different crate (or more generally a \"different semver domain\", if that makes any sense)</li>\n</ul>\n<p>I gather from <span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> 's response to the message where you pinged me that they are thinking of the 2nd case, where your last messages here are clearly about the first case.</p>",
        "id": 218569845,
        "sender_full_name": "RalfJ",
        "timestamp": 1606921963
    },
    {
        "content": "<p>(or maybe I am misunderstanding things here... I got pinged so I am trying to understand what the question is about but I didnt have time to read the entire pretty long backlog, sorry)</p>",
        "id": 218570248,
        "sender_full_name": "RalfJ",
        "timestamp": 1606922126
    },
    {
        "content": "<p>Yes, I believe you're understanding things. I think <span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span>'s position is that items with semver unspecified behavior (e.g., <code>size_of</code>, <code>align_of</code>) are historical mistakes that shouldn't be repeated because they can lead to unsafety. Rust therefore must not provide a compiler-implemented intrinsic for assessing transmutability that doesn't require SemVer opt-in.</p>",
        "id": 218576980,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606924791
    },
    {
        "content": "<p>No, you've read me <em>way</em> too broadly. I have no problem with <code>sort_unstable</code>, or typical <em>uses</em> of <code>align_of</code>, or even with an <code>is_transmutable</code> intrinsic per se! I have a problem with APIs that forcibly export new aspects of types that were previously non-breaking to change.</p>\n<p>Going back a step in our discussion, I said this:</p>\n<blockquote>\n<p>in that case why include <code>Scope</code> at all? Why not just have the <code>const fn</code> ignore visibility entirely like the other <code>mem</code> intrinsics?</p>\n</blockquote>\n<p>Ralf's division suggests a better way to frame this. A version of the intrinsic that I would be totally okay with is one that is only usable inside a library, with <em>no way whatsoever</em> to use it across libraries without an opt-in. This is why I don't like <code>Scope</code>- it essentially <em>is</em> a layout stability system, but a very blunt and un-idiomatic one that is declared by fiat not to provide any actual visibility.</p>",
        "id": 218580991,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606926252
    },
    {
        "content": "<p>Going back to the <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20Partial.20Visibility/near/218507058\">\"golden standard\"</a> of visibility- given a primitive like <code>is_transmutable</code> that works <em>only</em> on validity and not visibility/safety, it is the job of the type author to call that intrinsic. If other libraries need that functionality, they should only be able to use it via some well-defined semver-stable interface.</p>",
        "id": 218581317,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606926375
    },
    {
        "content": "<p>And frankly, I would characterize the <code>Scope</code> approach as the one conflating things here- it tries to tie visibility into the intrinsic, but that conflates validity (what the type author is allowed to do) with visibility (which is neither necessary nor sufficient to determine safety).</p>",
        "id": 218581649,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606926505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218510487\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218509295\">said</a>:</p>\n<blockquote>\n<p>This is why safety and visibility and semver are connected, and not totally separable.</p>\n</blockquote>\n<p>That is not fully the case. For example, iirc the UGC opinion on unsafely creating a DST or a slice via transmute is that if you guess the field order right, there's no UB. It's unspecified behavior, not undefined. This is different from say, guessing the stack position of a local variable or the address of a call to malloc, which is UB no matter what.</p>\n</blockquote>\n<p>This is also a great illustrative example- guessing the field order means there's no UB in that compilation, because everything stays <em>valid.</em> But guessing the field order is certainly a violation of visibility and semver- if the field order changes it suddenly <em>is</em> UB. The unspecified behavior includes \"UB in the future.\"</p>",
        "id": 218582244,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606926745
    },
    {
        "content": "<p>Now, I fully understand the reason for <em>wanting</em> the <code>Scope</code> system- to let libraries extend the <code>is_transmutable</code> intrinsic with richer APIs that are still, themselves, unstable. These APIs would then be usable by type authors to \"close the loop\" and hide the instability <em>almost</em> entirely inside their library. But that doesn't mean I think that's a good approach.</p>",
        "id": 218582671,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606926935
    },
    {
        "content": "<p>I apologize, though I'm not sure I'm clear. Isn't the typical use of <code>align_of</code> writing <code>unsafe</code> that depends on alignment?</p>",
        "id": 218582984,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606927052
    },
    {
        "content": "<p>Well by \"typical\" I mean things like allocators, which can handle any value for <code>align_of</code> and will simply adjust if it changes.</p>",
        "id": 218583283,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606927180
    },
    {
        "content": "<p>I don't think pointer bitpacking is an <em>atypical</em> use of <code>align_of</code>.</p>",
        "id": 218583514,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606927277
    },
    {
        "content": "<p>It's certainly less common than allocators ;)</p>",
        "id": 218583537,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606927290
    },
    {
        "content": "<p>But I don't mind picking a different word, my point was about the use cases and not how common they are.</p>",
        "id": 218583573,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606927312
    },
    {
        "content": "<p>And things that involve <code>size_of</code> are quite often either <em>they work or they don't</em> (e.g., does a type fit into a buffer or not).</p>",
        "id": 218583586,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606927317
    },
    {
        "content": "<p>Wellllll the \"good\" use of <code>size_of</code> is to <em>determine</em> the size of that buffer to begin with.</p>",
        "id": 218583720,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606927351
    },
    {
        "content": "<p>Using it to \"guess\" that a type will stay a particular size across versions when that's not part of the type's API is questionable.</p>",
        "id": 218583792,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606927383
    },
    {
        "content": "<p>I don't see that it's used to guess any such thing. Rather, it's used to enforce a safety invariant.</p>",
        "id": 218583981,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606927454
    },
    {
        "content": "<p>If it matters that the size is stable <em>across</em> versions, you either need to look towards documentation, marker traits or other indicators (like that the type is fully implicitly constructible).</p>",
        "id": 218584107,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606927518
    },
    {
        "content": "<p>Perhaps \"guess\" was also an imprecise word. My point is, I don't mind people using <code>size_of</code> or <code>align_of</code> in ways that adapt to changes in their values- that's basically no different than e.g. field access syntax. I grit my teeth and accept people using them to enforce <em>documented</em> assumptions, because unfortunately we don't have a better alternative. But I don't like people using them to enforce <em>undocumented</em> assumptions, because that means they are liable to stop compiling in the face of changes that should have been non-breaking.</p>",
        "id": 218584465,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606927669
    },
    {
        "content": "<p>And thus I also object to adding new APIs that can be used the same error-prone way.</p>",
        "id": 218584548,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606927687
    },
    {
        "content": "<p>Okay, so this objection isn't specific to scope awareness. A scope-<em>unaware</em> <code>is_transmutable</code> would pose the same hazard, too. (E.g., the <code>NeglectSafety</code>-like option discussed in the RFC comments.)</p>",
        "id": 218584972,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606927870
    },
    {
        "content": "<p>Right, I don't want a scope-<em>unaware</em> intrinsic but a <em>current-scope-only</em> intrinsic.</p>",
        "id": 218585392,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928042
    },
    {
        "content": "<p>(And that excludes other scopes that can see some or all fields.)</p>",
        "id": 218585501,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928075
    },
    {
        "content": "<p>(So perhaps I should say \"make layout fully private rather than tying it to field or type visibility.\"</p>",
        "id": 218585551,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928111
    },
    {
        "content": "<p>When you say \"current scope only\", then what visibility matters? That the fields must be visible in the scope of the transmutation? That the types must be visible in the scope of the transmutation?</p>",
        "id": 218585767,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606928208
    },
    {
        "content": "<p>The visibility of the type's layout. :P</p>",
        "id": 218585915,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928276
    },
    {
        "content": "<p>This was the most appealing aspect of <code>Muckable</code>- it provided an actual source-level entity representing \"the type's layout\" that could be exposed or not-exposed.</p>",
        "id": 218585934,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928283
    },
    {
        "content": "<p>Like, without that then the sort of intrinsic I'm talking about would only be usable if all fields were primitives.</p>",
        "id": 218586020,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928306
    },
    {
        "content": "<p>(Or other structs in the same module where it bottoms out at primitives.)</p>",
        "id": 218586056,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928325
    },
    {
        "content": "<p>This doesn't sound like anything you can abstract over, even slightly. <span aria-label=\"slight frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"slight frown\">:slight_frown:</span></p>",
        "id": 218586299,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606928416
    },
    {
        "content": "<p>Yeah see <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218582671\">my acknowledgement of that detail</a> :/</p>",
        "id": 218586434,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928465
    },
    {
        "content": "<p>The point is, I think the abstraction needs to be separated out a bit more than it is with <code>Scope</code>, so it can match idioms with the rest of the language and not have weird pitfalls and holes.</p>",
        "id": 218586541,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928517
    },
    {
        "content": "<p>E.g. Muckable + a sound archetype system might meet that goal.</p>",
        "id": 218586619,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928533
    },
    {
        "content": "<p>IOW I want to separate the visibility of a field from the visibility of its offset and size, because today the first does not imply the second.</p>",
        "id": 218586950,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928652
    },
    {
        "content": "<p>Currently, if I can see a field, I can tell you its offset, size, and padding in <em>completely</em> safe code.</p>",
        "id": 218587343,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606928793
    },
    {
        "content": "<p>Yeah but you're ignoring what we just discussed about <code>size_of</code>/<code>align_of</code>! You can of course find that information, but the \"right\" way to use that information is in a generic way that only assumes that it <em>exists</em> and nothing about its actual content. Once we start talking about transmutes, we shift focus from \"does this field exist and have <em>some</em> offset/size/padding\" to \"does this field exist <em>at this particular</em> offset/size/padding.\"</p>",
        "id": 218587881,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606928979
    },
    {
        "content": "<p>It's the difference between a bound like <code>T: Iterator</code> (this thing has a <code>next</code> method that returns <code>Option&lt;T::Item&gt;</code>) and <code>T: Iterator&lt;Item = i32&gt;</code> (this thing specifically gives me <code>i32</code>s).</p>",
        "id": 218588169,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606929074
    },
    {
        "content": "<p>That's just not accurate. These intrinsics are used to assert that properties are upheld. For pointer bitpacking, I use <code>align_of</code> to enforce that I have sufficient unused bits in my pointer. Or that a struct is a <em>particular</em> size. These aren't considered misuses, as far as I'm aware.</p>\n<p>Just because you <em>can</em> use a transmutability intrinsic in a way that depends on field offsets (just as you <em>can</em> use <code>as</code> casting to rely on field offsets) doesn't mean <em>all</em> uses of such an intrinsic must care about field offsets. <code>mem::zeroed()</code> is a prime example of this.</p>",
        "id": 218588859,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606929389
    },
    {
        "content": "<p>I think your line-in-the-sand is this: \"We must not provide an automatic, abstractable intrinsic for transmutation Safetyâ„¢.\"</p>",
        "id": 218589031,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606929470
    },
    {
        "content": "<p>Please, that's absurd.</p>",
        "id": 218589092,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606929484
    },
    {
        "content": "<p>What is?</p>",
        "id": 218589127,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606929504
    },
    {
        "content": "<p>Do you genuinely not understand what I'm trying to say? Or do you understand and just disagree?</p>",
        "id": 218589130,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606929505
    },
    {
        "content": "<p>That's what I'm trying to figure out by stating what I <em>think</em> your line is. I <em>think</em> you're okay with an automatic intrinsic that <em>isn't</em> abstractable. And I think you're okay with something that's abstractable, but not fully automatic. </p>\n<p>But you object to an intrinsic that's both automatic <em>and</em> abstractable.</p>",
        "id": 218589361,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606929605
    },
    {
        "content": "<p>I have no opinion on abstractability or automatability per se, I don't understand why you would even bring those up. They're consequences of the combination of my <em>actual</em> objection and the particular design you've proposed.</p>",
        "id": 218589496,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606929670
    },
    {
        "content": "<p>IOW if we can come up with a design that is both abstractable and automatic and <em>also</em> does not expose type layouts without an opt-in, I'd be absolutely thrilled.</p>",
        "id": 218589656,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606929736
    },
    {
        "content": "<p>Type size, type alignment, field offset, field size, and field alignment are all <em>already</em> exposed in the sense that they're all safely observable. The only thing that <em>isn't</em> currently observable is bit validity.</p>",
        "id": 218590255,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606929993
    },
    {
        "content": "<p>I bring up abstractibility and automatability because you've repeatedly suggested to remove either one of those aspects.</p>",
        "id": 218590606,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606930136
    },
    {
        "content": "<ul>\n<li>An intrinsic that requires the involved types to be fully instantiated simply cannot be abstracted over. This is the great limitation of <code>mem::transmute</code>. </li>\n<li>A mechanism that requires special opt-in for making bit validity observable is, definitionally, not automatic.</li>\n</ul>",
        "id": 218591287,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606930420
    },
    {
        "content": "<p>Observability is too low a bar. I've tried to explain my position on that several times, do you at least understand the point I'm trying to make there?</p>",
        "id": 218591410,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606930466
    },
    {
        "content": "<p>I do understand your point. I believe your conclusion is that \"APIs that provide observability without stability shouldn't exist\".</p>",
        "id": 218591987,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606930712
    },
    {
        "content": "<p>Then why is it that you keep trying to use the existence of mem::size_of to convince me that such APIs are okay?</p>",
        "id": 218592401,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606930888
    },
    {
        "content": "<p>I suggested those removals (in a thread about an \"incremental approach!\") not because I see them as an end goal, but because without them we can still do <em>some</em> transmutes without the problem of instability.</p>",
        "id": 218592688,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931002
    },
    {
        "content": "<p>I fully anticipate a more comprehensive solution that does allow abstracting over these properties, so long as the required properties are properly expressed in the type system.</p>",
        "id": 218592874,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931080
    },
    {
        "content": "<p>Like, my conclusion is still <em>way</em> more nuanced than \"apis that provide observability without stability shouldn't exist.\"</p>",
        "id": 218592958,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931115
    },
    {
        "content": "<p>It's that we shouldn't <em>exploit</em> observability in unstable ways. <code>mem::size_of</code> gets a pass because it's been there since long before 1.0 without any alternative, but uses of it that rely on unstable aspects of a type do not get such a pass.</p>",
        "id": 218593159,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931194
    },
    {
        "content": "<p>You're proposing to 1) expand observability without stability 2) in a foundational API.</p>",
        "id": 218593216,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931221
    },
    {
        "content": "<p>(And that doesn't even touch on the fact that <code>Scope</code> is still deeply un-idiomatic. Type privacy is there to enforce that private types stay private, not as a building block for first-class visibility tokens. We already have first-class visibility tokens, they're called trait impls.)</p>",
        "id": 218593531,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931347
    },
    {
        "content": "<p>Yeah, I don't think I can convince you that such APIs are okay. However, I think the vast majority of Rust programmers find <code>align_of</code> and <code>size_of</code> to be totally unobjectionable. I think someone dropping into this chat would be alarmed by a lot of your messages. For instance, that the foundational API \"punches a hole in safety and visibility\". This is SUPER alarming â€” but you're using \"safety\" in an idiosyncratic way. Or, that the foundational API provides a slew of new, dangerous observational powers that don't exist today. It doesn't. </p>\n<p>I agree with you that layout stability is a worthy challenge. I <em>disagree</em> that we need to solve it completely before providing a foundational API for arbitrary transmutations.</p>",
        "id": 218593598,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606931381
    },
    {
        "content": "<p>Well I'm not saying we need to solve it completely up front either. I'm saying we need to stop undermining our ability to solve it well in the future.</p>",
        "id": 218593760,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931433
    },
    {
        "content": "<p>I think solving stability is going to be a <em>long</em> process. I think we stand a better chance of getting it right if we first provide a foundational API, and then watch how the community builds stable abstractions over it.</p>",
        "id": 218593873,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606931475
    },
    {
        "content": "<p>Let's pick a foundational API that doesn't punch a hole in visibility, then.</p>",
        "id": 218593897,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931492
    },
    {
        "content": "<p>Sigh. Stability. It punches a hole in <em>stability</em>. Not visibility.</p>",
        "id": 218593932,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606931510
    },
    {
        "content": "<p>Visibility is how you control stability.</p>",
        "id": 218594030,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931547
    },
    {
        "content": "<p>I really don't appreciate being called \"SUPER alarming\" for pointing out that your proposal makes some aspects of types newly visible with no control over that visibility.</p>",
        "id": 218594249,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931660
    },
    {
        "content": "<p>I'll quit calling it a safety hole because that's kind of a weird fuzzy nuanced argument, but it is <em>absolutely</em> a visibility hole.</p>",
        "id": 218594299,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931691
    },
    {
        "content": "<p>It's not even totally \"newly visible\". <code>mem::zeroed</code> panics these days!</p>",
        "id": 218594328,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606931705
    },
    {
        "content": "<p>Not based on any sort of trait bound, though.</p>",
        "id": 218594390,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931735
    },
    {
        "content": "<p>Panics in mem::zeroed are a last-ditch effort to make that API less error-prone by making the worst cases fail at runtime. That's not exactly something to aspire to.</p>",
        "id": 218594490,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931767
    },
    {
        "content": "<p>You have the relationship backwards, too. Stability dictates the set of changes you can make to an item. Visibility is one class of changes constrained by stability, but there are <em>tons</em>. And not all are in-language either. If you want the alignment of your type to be stable, you document it. If you want <code>#[repr(C)]</code> to be stable, you document it.</p>",
        "id": 218594623,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606931830
    },
    {
        "content": "<p>I thought the point of safe transmute was to bring those aspects into the language.....?</p>",
        "id": 218594688,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606931866
    },
    {
        "content": "<p>No, not really. It's in the name: to make transmutations safe (in the usual understanding of the term). Yes, I want to solve layout stability too, but that's complimentary, not core, to our charter.</p>",
        "id": 218595066,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932026
    },
    {
        "content": "<p>Well, if you can chop stability out of the charter then I can chop abstraction out of the charter. Stability and abstraction go hand-in-hand, separating them is, again, asking for trouble.</p>",
        "id": 218595472,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932182
    },
    {
        "content": "<p>A safe transmute that only works on fully-visible types is still safe, and you can still build some abstractions on it.</p>",
        "id": 218595556,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932218
    },
    {
        "content": "<p>Why not start there and then expand its capabilities as we solve layout stability?</p>",
        "id": 218595602,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932238
    },
    {
        "content": "<p>Can determine fully-visible types? The original purpose of <code>Scope</code> was to solve the pub-in-priv hole.</p>",
        "id": 218595677,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606932257
    },
    {
        "content": "<p>^Yes, but only by nixing abstraction.</p>",
        "id": 218595713,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932273
    },
    {
        "content": "<p>Fully-visible as in, defined in the same module where visibility is irrelevant.</p>",
        "id": 218595715,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932274
    },
    {
        "content": "<p>e.g., as in how <code>mem::transmute</code> can't be called on generic types</p>",
        "id": 218595733,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932283
    },
    {
        "content": "<p>Well, like I described in the \"golden standard\" thread, you certainly <em>can</em> still abstract over mem::transmute. That's how trait impls work- they bottom out at non-generic types, where you <em>can</em> do things that require full visibility.</p>",
        "id": 218595874,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932360
    },
    {
        "content": "<p>You just can't use mem::transmute-alikes directly on generic types- you have to go through a trait.</p>",
        "id": 218595959,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932390
    },
    {
        "content": "<p>Another useful term here is parametricity.</p>",
        "id": 218596040,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932433
    },
    {
        "content": "<p>I don't think that's true. If you try to use <code>mem::transmute</code>, you can't do so on generic types no matter where they occur. If you use it in a trait, it needs to occur in <em>individual</em> trait impls.</p>",
        "id": 218596157,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932489
    },
    {
        "content": "<p>Yes, that's exactly what I said...</p>",
        "id": 218596178,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932500
    },
    {
        "content": "<p>...so you're not really abstracting over anything.</p>",
        "id": 218596202,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932512
    },
    {
        "content": "<p>Of course you are. You're abstracting over all the individual impls that call mem::transmute.</p>",
        "id": 218596237,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932527
    },
    {
        "content": "<p>You've got the idea of \"mem::transmute but it works on generic types\" so deeply embedded in your idea of how this should work that you're dismissing alternatives.</p>",
        "id": 218596318,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932564
    },
    {
        "content": "<p>So this would in practice be a <code>mem::transmute</code> that is safe because it tests for visibility at the use site?</p>",
        "id": 218596376,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606932593
    },
    {
        "content": "<p>Well that's one possibility.</p>",
        "id": 218596495,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932627
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218595472\">said</a>:</p>\n<blockquote>\n<p>Well, if you can chop stability out of the charter then I can chop abstraction out of the charter. Stability and abstraction go hand-in-hand, separating them is, again, asking for trouble.</p>\n</blockquote>\n<p>I'm not chopping anything of our charter. We're here to make transmutations safe. We have a design that makes transmutations safe. We even have a complementary design that makes <em>some</em> transmutations stable, too!</p>\n<p>Nixing abstraction is artificially pruning the set of transmutations we will make safe.</p>",
        "id": 218596541,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932651
    },
    {
        "content": "<p>Generally our disagreement seems to be over where safety is checked. You propose to check it at any use site, by tying layout visibility to field visibility. I would rather keep layout private by default, and then use established idioms to (partially) expose it.</p>",
        "id": 218596797,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932768
    },
    {
        "content": "<p>Layout isn't private.</p>",
        "id": 218596834,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932788
    },
    {
        "content": "<p>(I.e., I propose for safety to be checked at the site that makes (an aspect of) layout visible.)</p>",
        "id": 218596868,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932807
    },
    {
        "content": "<p>Well that's what we've been discussing all morning! Layout is partially <em>observable</em> today but only in limited ways, and even those ways are arguably incorrect for some use cases.</p>",
        "id": 218596913,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932835
    },
    {
        "content": "<p>It's not limited at all! <em>Every</em> aspect of layout <em>except</em> bit validity is safely observable.</p>",
        "id": 218596982,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932856
    },
    {
        "content": "<p>Some aspects of layout still <em>are</em> private in the sense that changing them is considered non-breaking, despite those changes breaking some ill-advised constructs.</p>",
        "id": 218597019,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932880
    },
    {
        "content": "<p>You keep conflating observability and visibility and I would rather you not. ;)</p>",
        "id": 218597045,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932895
    },
    {
        "content": "<p>You keep conflating visibility with stability! We have an accepted term for the kind of thing you are describing. It's stability. Not visibility.</p>",
        "id": 218597108,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606932921
    },
    {
        "content": "<p>Ugh, whatever, forget the terminology, it's irrelevant to my point!</p>",
        "id": 218597137,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932939
    },
    {
        "content": "<p>My point is, I don't want people writing generic code that will stop compiling when I make changes that used to be non-breaking!</p>",
        "id": 218597170,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606932960
    },
    {
        "content": "<p>(And simply declaring by fiat that those changes are still non-breaking doesn't really solve anything.)</p>",
        "id": 218597349,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933032
    },
    {
        "content": "<p>Just to prod this a bit, would you be ok with something like a <code>SizeEq</code> or <code>AlignEq</code> trait (something there's been interest in)? You can already assert on the size of an object, and this would just fail with a compile time error (the same why <code>mem::transmute</code> errors if size changes even thought that breaks code)?</p>",
        "id": 218597417,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606933073
    },
    {
        "content": "<p>Yes, that would be wonderful (as long as it's opt-in on the part of the type author).</p>",
        "id": 218597592,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933156
    },
    {
        "content": "<p>That's exactly the sort of thing I'm pushing for.</p>",
        "id": 218597601,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933161
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span> do you mean an automatic <code>AlignEq</code> trait?</p>",
        "id": 218597678,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933194
    },
    {
        "content": "<p>I'd love to be able to declare in the trait system that my type is always going to be pointer-sized, for example.</p>",
        "id": 218597685,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933197
    },
    {
        "content": "<p>Yes, I had bad wording :( An automatic AlignEq trait.</p>",
        "id": 218597803,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606933237
    },
    {
        "content": "<p>I'd even consider being okay with it being an auto trait, if there were some way to opt <em>out</em> of it through <code>PhantomData</code> or similar. It would certainly be a pain to have to declare <code>Send</code> and <code>Sync</code> all the time, even though changing whether they're impled is considered breaking.</p>",
        "id": 218597933,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933306
    },
    {
        "content": "<p>...so would you be okay with an <code>UnstableTransmuteFrom</code> trait you can opt out of?</p>",
        "id": 218598169,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933401
    },
    {
        "content": "<p>That one's much more comprehensive so I'd have to think about it. And I'd still object to the <code>Scope</code> mechanism out of sheer weirdness and complexity.</p>",
        "id": 218598231,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933434
    },
    {
        "content": "<p>I do wonder we couldn't just start with a sound archetype system, where the type author impls TransmutableFrom/Into (through a derive if they want full layout stability), the compiler checks that the impl is valid (like Copy), and then mem::safe_transmute uses those traits.</p>",
        "id": 218598527,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933540
    },
    {
        "content": "<p>I encourage you to take a stab at making archetypes sound.</p>",
        "id": 218598655,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933586
    },
    {
        "content": "<p>Though that system got a <em>lot</em> of pushback just for its complexity. (Which is partly why I'm of the mind that there <em>isn't</em> a one-size fits all stability system, but rather different systems tuned to different use-cases.)</p>",
        "id": 218598756,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933637
    },
    {
        "content": "<p>Well, there <em>was</em> a lot of complexity there that I am imagining doing away with.</p>",
        "id": 218598795,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933654
    },
    {
        "content": "<p>For instance I would probably just leave out <em>all</em> the Neglect options. :P</p>",
        "id": 218598956,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933717
    },
    {
        "content": "<p>And of course there would be no need for <code>Scope</code>.</p>",
        "id": 218598985,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933725
    },
    {
        "content": "<p>Well. No, Scope is pretty essential for the use-cases I'm interested in. Namely: purely local analysis of transmutation safety.</p>",
        "id": 218599058,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933757
    },
    {
        "content": "<blockquote>\n<p>I'd love to be able to declare in the trait system that my type is always going to be pointer-sized, for example.</p>\n</blockquote>\n<p>Honestly I prefer a direct static assert on size to whatever it would probably look like in the trait system. It's awkward to have to do stuff like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">assert_send</span><span class=\"o\">&lt;</span><span class=\"n\">T</span>: <span class=\"nb\">Send</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span>: <span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">assert_send</span>::<span class=\"o\">&lt;</span><span class=\"n\">MyType</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n</code></pre></div>\n<hr>\n<p>This is no longer really what you're talking about, but as a data point on alignment stability, I've seen code that had <code>type PhantomAligned&lt;T&gt; = [T; 0];</code> before.</p>",
        "id": 218599095,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606933772
    },
    {
        "content": "<p>^This is moreso how I'm envisioning \"general\" stability too.</p>",
        "id": 218599217,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933811
    },
    {
        "content": "<p>I'm not sure \"purely local\" is really compatible with stability.</p>",
        "id": 218599279,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933842
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"209168\">@Thom Chiovoloni</span> have you played with the static assertions crate? It's phenomenal.</p>",
        "id": 218599286,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933844
    },
    {
        "content": "<p>If it means what I think it means.</p>",
        "id": 218599292,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933847
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> It's not compatible.</p>",
        "id": 218599304,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933854
    },
    {
        "content": "<p>Yes, I have. I'm good friends with the author too.</p>",
        "id": 218599335,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606933867
    },
    {
        "content": "<p>Perhaps we ought to dig more into that use case, then.</p>",
        "id": 218599359,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933877
    },
    {
        "content": "<p>I'm hoping we can arrive at something that's sufficiently signposted that you'd be satisfied. E.g., <code>UnstableTransmuteFrom</code> or <code>ExtraScaryUnstableTransmuteFrom</code>.</p>",
        "id": 218599392,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933894
    },
    {
        "content": "<p>No amount of signposting will satisfy me. Signposting is exactly my complaint.</p>",
        "id": 218599485,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933924
    },
    {
        "content": "<p>A type's author ought to have control over whether their type is transmutable, independent of field visibility.</p>",
        "id": 218599577,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933973
    },
    {
        "content": "<p>Then I think we're simply at an impasse.</p>",
        "id": 218599580,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606933974
    },
    {
        "content": "<p>Thus:</p>\n<blockquote>\n<p>Perhaps we ought to dig more into that use case, then.</p>\n</blockquote>",
        "id": 218599635,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606933996
    },
    {
        "content": "<p>What, exactly, would type author control take away from you?</p>",
        "id": 218599679,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606934022
    },
    {
        "content": "<p>I cannot generate layout stability impls on the fly.</p>",
        "id": 218599778,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606934061
    },
    {
        "content": "<p>That's up to the authors of those types.</p>",
        "id": 218599809,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606934081
    },
    {
        "content": "<p>And even if I could, that wouldn't respect field visibility, which is essential to safety.</p>",
        "id": 218600002,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606934166
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> if you can convert to the type that's basically equivalent to having public writable fields. if you can convert from it, it's equivalent to having public readable fields. No?</p>",
        "id": 218600056,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606934192
    },
    {
        "content": "<p>ehh maybe i'm covering well-explored ground. i don't really want to wade into this if I'm just going to cause repetition of earlier discussion that's already happened.</p>",
        "id": 218600246,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1606934282
    },
    {
        "content": "<p>What I'm asking is, what sort of use cases are blocked by type author control? We need to consider whether those use cases are actually worth addressing, before we toss stability out the window.</p>",
        "id": 218600264,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606934284
    },
    {
        "content": "<p>Addressing my use-cases is pretty much my motivation for working on solving safe transmute. <span aria-label=\"slight frown\" class=\"emoji emoji-1f641\" role=\"img\" title=\"slight frown\">:slight_frown:</span></p>",
        "id": 218600441,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606934354
    },
    {
        "content": "<p>A type author opt-in (or opt-out, I suppose) to (perhaps partial) transmutability is how they would mark those aspect(s) of their type's layout as <del>public</del> stable, rather than merely observable.</p>",
        "id": 218600449,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606934358
    },
    {
        "content": "<p>I should also say, we need to consider whether they're addressable in other ways!</p>",
        "id": 218600480,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606934370
    },
    {
        "content": "<p>Like, if your use cases are \"let me transmute types I don't own in ways they haven't opted into (or would like to have opted out of), which may break when their authors make formerly-non-breaking changes\" then that's really not something we should be addressing. But if that's just an XY-problem and you would be able to accomplish what you want with the type author's participation in some way, there's probably a better solution.</p>",
        "id": 218600862,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606934532
    },
    {
        "content": "<p>There's a <em>ton</em> of existing unsafe code out there that relies only on documented layout guarantees for its safety. The participation of the type's author <em>is</em> the documented stability guarantees. Or, often, the person doing the transmutation because it's within the same SemVer universe (though not necessarily the same module or even crate).</p>\n<p>I'm interested in making this code safer <em>without</em> necessitating non-local changes (e.g., rewriting type internals, redesigning existing abstractions, etc).</p>",
        "id": 218601425,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606934816
    },
    {
        "content": "<p>I think we need to consider \"the type author converts from a doc comment to some kind of trait impl\" as an acceptable change to require.</p>",
        "id": 218601582,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606934883
    },
    {
        "content": "<p>Otherwise we're basically just saying \"hey I know a bunch of types don't implement Copy, but they could implement it, and I don't want to wait around for new crate versions, so let's just add a new UnstableCopy trait for people to use instead.\"</p>",
        "id": 218601713,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606934938
    },
    {
        "content": "<p>I also think it would be totally acceptable for the initial version of safe transmute not to address every use case! If some crates have to stick to unsafe transmute until we come up with a way for type authors to stablize the properties they depend on, that's okay.</p>",
        "id": 218601842,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606935000
    },
    {
        "content": "<p>If a type could implement Copy but you have visibility into its fields, you <em>can</em>, practically speaking, copy it.</p>",
        "id": 218601951,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606935042
    },
    {
        "content": "<p>Yes, but that still doesn't mean we should add UnstableCopy for types like that. It means those type authors should consider implementing Copy.</p>",
        "id": 218602014,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606935074
    },
    {
        "content": "<p>Which they might not want to do, because they don't want to make Copy part of their semver guarantee.</p>",
        "id": 218602066,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606935099
    },
    {
        "content": "<p>If they dont' want to make Copy part of their semver guarantee then that's a pretty strong argument <em>against</em> UnstableCopy, no?</p>",
        "id": 218602218,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606935157
    },
    {
        "content": "<p>I think that's a private impl question though.</p>",
        "id": 218602229,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606935161
    },
    {
        "content": "<p>That is to say, does any of this (type author converts doc comments to trait impls, not all use cases can use safe transmute on day 1) actually <em>block</em> your use cases? Or are we just arguing over the UnstableCopy thing?</p>",
        "id": 218602478,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606935266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218602229\">said</a>:</p>\n<blockquote>\n<p>I think that's a private impl question though.</p>\n</blockquote>\n<p>^Kinda, yeah. And that's why <code>UnstableTransmuteFrom</code> is scope-aware.</p>",
        "id": 218602505,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606935279
    },
    {
        "content": "<p>If we had private impls, would <code>InvariantFree</code> + derives work for your use cases?</p>",
        "id": 218602748,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606935369
    },
    {
        "content": "<p>No, because a local transformation at the point of transmutation can't just generate impls for non-local types. Not in any safe sense, at least.</p>",
        "id": 218602870,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606935438
    },
    {
        "content": "<p>Can you explain?</p>",
        "id": 218603127,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606935559
    },
    {
        "content": "<p>Sure. <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20Encapsulation.20Redundancy.20Risks/near/218330313\">Check out this topic</a>, but the gist is: field visibility is what matters when determining whether its safe to fiddle with a field.</p>\n<p>In contrast, type visibility is what matters when determining the visibility of an impl. So, a trait that denotes \"treat all my fields as recursively pub\" will have the same visibility of the type its implemented on.</p>",
        "id": 218609859,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606938801
    },
    {
        "content": "<p>Let's say I have a safe <code>transmute!</code> macro with which I can replace occurences of <code>mem::transmute</code> and <code>transmute_copy</code>, and union accesses, etc. In the foundational approach, this boils down to:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"cp\">$expr</span>: <span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Here</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"n\">UnstableTransmuteFrom</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">Here</span><span class=\"o\">&gt;</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"cp\">$expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This doesn't let me muck with any fields I didn't already have visibility on at the invocation site.</p>\n<p>In a scope-unaware approach where a trait (e.g., <code>Muckable</code>) is used, it'd look like this:</p>",
        "id": 218610338,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606939047
    },
    {
        "content": "<p>uh, well actually, I don't even know how to write it.</p>",
        "id": 218610362,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606939055
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"kr\">macro</span><span class=\"w\"> </span><span class=\"n\">transmute</span><span class=\"p\">(</span><span class=\"cp\">$expr</span>: <span class=\"nc\">expr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Muckable</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">SRC_TYPE</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Muckable</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">DST_TYPE</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">TransmuteFrom</span>::<span class=\"o\">&lt;</span><span class=\"n\">_</span><span class=\"o\">&gt;</span>::<span class=\"n\">transmute_from</span><span class=\"p\">(</span><span class=\"cp\">$expr</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>(I can't use the <code>_</code> trick to infer the source and destination types for the purposes of implementing <code>Muckable</code>. Not sure what the workaround here is....)</p>",
        "id": 218610527,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606939131
    },
    {
        "content": "<p>Even if I could name the src and dst types for the purposes of impl'ing <code>Muckable</code>, other issues arise.</p>\n<p>First, I can't necessarily implement traits for these types. If I've broken up my network stack code into lots of sub-crates that are all part of the same semver universe, I can't implement <code>Muckable</code> for any type that aren't defined in the same sub-crate, and thus this macro is unworkable.</p>",
        "id": 218611131,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606939388
    },
    {
        "content": "<p>Second, even when I can, it's a <em>terrible</em> idea for me to do so for types outside the same module. Just because I have visibility on a type, <em>doesn't</em> mean I have visibility onto its fields. A macro that clobbers the visibility of fields is a safety hazard.</p>",
        "id": 218611289,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606939448
    },
    {
        "content": "<p>Ultimately, the decision of whether fields are visible is one made at the definition site of a type. I can't judge whether fiddling with a field is safe without first confirming that I <em>can</em> fiddle with the field.</p>",
        "id": 218611532,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606939560
    },
    {
        "content": "<p>Muckable would be derived or implemented at the definition site right?</p>",
        "id": 218613745,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606940572
    },
    {
        "content": "<p>So, that all still feels like you're just trying to avoid having type authors participate. Like, providing <em>just</em> a safe transmute that lets you do anything that's valid value-wise doesn't capture stability, obviously, but I still don't see any sort of justification for that beyond \"it's too hard to design a full layout stability system up front\" or \"it's too annoying/invasive to wait for type authors to opt in.\"</p>",
        "id": 218614025,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606940607
    },
    {
        "content": "<p>It would have to be. If the field visibility is anything less than all-pub, then the type would need to be refactored.</p>",
        "id": 218614049,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606940620
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> All of this can happen within the same semver universe, e.g., as in subcrates, or even within the same crate but across different modules.</p>",
        "id": 218614135,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606940660
    },
    {
        "content": "<p>But you aren't <em>enforcing</em> that it happens within the same semver universe- it can also happen outside it.</p>",
        "id": 218614160,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606940676
    },
    {
        "content": "<p>Yes, you understand correctly. I'm not convinced that we must absolutely <strong>not</strong> provide bit validity observability without stability.</p>",
        "id": 218614295,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606940749
    },
    {
        "content": "<p>I think we're at an impasse, here.</p>",
        "id": 218614384,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606940777
    },
    {
        "content": "<p>With private impls, you could make it <code>pub(crate)</code> or <code>pub(super)</code> or whatever you need.</p>",
        "id": 218614407,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606940788
    },
    {
        "content": "<p>Well I'm not trying to convince you of anything just yet, I'm trying to understand your use cases, as I asked here: <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218602478\">https://rust-lang.zulipchat.com/#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218602478</a></p>",
        "id": 218614416,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606940794
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"303115\">Quy Nguyen</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218614407\">said</a>:</p>\n<blockquote>\n<p>With private impls, you could make it <code>pub(crate)</code> or <code>pub(super)</code> or whatever you need.</p>\n</blockquote>\n<p>Those impls <em>still</em> need to be written at type definition sites. You can't soundly generate those impls at transmutation sites.</p>",
        "id": 218614545,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606940865
    },
    {
        "content": "<p>Anyways, we still end up with two competing indicators of whether you can fiddle with a field. <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20Encapsulation.20Redundancy.20Risks/near/218330313\">I think this is asking for trouble.</a></p>",
        "id": 218614684,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606940916
    },
    {
        "content": "<p>That sounds like something that should be addressed by having the compiler check that you're allowed to impl Muckable.</p>",
        "id": 218614881,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606941005
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span> Rust doesn't have a <code>pub(crate) impl</code> syntax, and will not have it in the foreseeable future. It <em>does</em> have a notion of impl privacy those, and that's what <code>UnstableTransmuteFrom</code> takes advantage of with its <code>Scope</code> parameter. It automatically respects the visibility of your fields.</p>",
        "id": 218614908,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606941014
    },
    {
        "content": "<p>Forget what I said about private impls for now, I didn't have the axioms right in my head. If <code>Muckable</code> was exactly like <code>Copy</code> (usage-wise) and had no field stability gurantees, would your only compliant be that type authors have to manually derive it?</p>",
        "id": 218617681,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1606942258
    },
    {
        "content": "<p>That would resolve the issue of <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20Language-Level.20Layout.20Instability/near/218336402\">language-level layout (in)stability</a> (i.e., <code>Muckable</code> is currently really just tuned for <code>repr(C)</code> types). But:</p>\n<ul>\n<li><a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20Encapsulation.20Redundancy.20Risks/near/218330313\">you still end up with two competing indicators of whether a field can be fiddled with</a></li>\n<li><a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20Partial.20Visibility/near/218478354\">partial visibility is awkward, at best</a> (but an archetype-based stability system might do somewhat better here, if someone can figure out how to make it sound)</li>\n<li><a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20No.20Quick.20Answers/near/218332628\">you still can't purely-locally analyze the safety of transmutations</a></li>\n<li><a href=\"#narrow/stream/216762-project-safe-transmute/topic/Muckable.20Pitfall.20-.20Newtype.20Workaround.20Ergonomics/near/218320527\">the partial-workaround of newtyping has steep ergonomic drawbacks, and it might not be worth trying to update unsafe code that already just works</a></li>\n<li>we'd then need an additional stability system <em>besides</em> <code>Muckable</code> to opt-in to field ordering semver stability. the existence of a system that let one observe transmutability <em>without</em> providing adequate semver opt-ins is precisely what rpjohnst's is worried about</li>\n</ul>",
        "id": 218618860,
        "sender_full_name": "Jack Wrenn",
        "timestamp": 1606942809
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> FWIW I have definitely written the kind of code you wish didn't exist. A lot of my use cases for safe-transmute are when I want to <em>opt out</em> of visibility/stability promises made by an upstream crate, by taking their struct, transmuting it to one of mine, and then mucking with fields. Is this unsafe? Yes. The definition of satefy in rust includes invariants at module boundaries, so visibility override is unsafe. However rust can still assist in checking that the layout hasn't changed since I wrote the code. Currently I have to opt out of <em>memory safety</em> in this operation as well, which I would like to avoid. <span class=\"user-mention\" data-user-id=\"219211\">@Jack Wrenn</span> 's proposal allows for this use case with the <code>NeglectStability</code> / <code>NeglectVisibility</code> options but you seem to want to block this.</p>\n<p>You can reasonably ask why I need to do this. It mostly came up while trying to determine how much memory I have allocated, because that involves the internal details of a lot of crates I don't control, and I have no intention to modify them to support my use case.</p>",
        "id": 218645185,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606960276
    },
    {
        "content": "<p>(Actually, this is arguably a misuse of transmute in the first place, in the sense that what is needed, visibility override, need not even involve memory unsafe operations but this is brought into the game because there is no way to override visibility on a field directly. So taking a hard stance on visibility protection actually makes UB-in-practice easier, which seems like a bad situation.)</p>",
        "id": 218645732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606960853
    },
    {
        "content": "<p>Yeah transmute is not a great solution here. Can you clarify whether this memory allocation measurement is a one-off debugging technique, or a permanent part of your program? If it's the former you may be able to use cargo patching without much trouble; if the latter you probably want allocator instrumentation.</p>",
        "id": 218651569,
        "sender_full_name": "rpjohnst",
        "timestamp": 1606968150
    },
    {
        "content": "<p>I can't patch std, that sounds like a nightmare</p>",
        "id": 218653806,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606971209
    },
    {
        "content": "<p>it's mostly the former, although I want to test memory usage in some reasonably realistic scenarios so it can't differ too much from the production version</p>",
        "id": 218653863,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1606971266
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218253083\">said</a>:</p>\n<blockquote>\n<p>I think it only working for public types would be unfortunate. That's an issue I always had with the bytemuck design (<code>ref_cast</code> has the same issue). <code>Scope</code> solves that problem in a way that seems explainable relatively simply, I wasn't really aware of what it did before <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218239871\">this</a>, and that doesn't seem that bad for a low level building-block that a higher level api can be built on top of.</p>\n</blockquote>\n<p>Seconding this! The <code>Scope</code> parameter seems pretty explainable, particularly compared to all the <em>other</em> transmutation rules.</p>\n<p>I spend a lot of time building abstractions over transmutations, and the foundational API seems like a <em>really</em> useful building block.</p>",
        "id": 218755094,
        "sender_full_name": "Joshua Liebow-Feeser",
        "timestamp": 1607029909
    },
    {
        "content": "<p>I do think the central issue here is whether an privacy-scoped impl for a trait is the general idea for what you're arguing against, or whether you're against the Scope parameter specifically.</p>\n<p>I actually don't remember what your main points are anymore, but I'll address some I've thought about.</p>\n<p>Usability in a generic context:<br>\n<code>mem::transmute</code> is not usable generically yes, but with improvements in const-eval/generics, I've seen a prototype that is.</p>\n<p>Stability:<br>\nThe ability to introspect private fields is prohibited. Unsafe code can already cause breakage with <code>mem::transmute</code>, as well as <code>size_of</code> (but that is arguably special), and I'd argue that breaking something at compile time is miles better than causing hidden UB by merely updating.</p>\n<p>Complexity:<br>\nI do think this API is a lot less complex than many other solutions, simply because the concepts are expressed in the same Rust constructs people already use to express those concepts!</p>\n<p>I think the final thing to just note here is that everything here <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218618860\">https://rust-lang.zulipchat.com/#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218618860</a> is a use case for <code>Scope</code>- all organized into a single post</p>",
        "id": 218799710,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1607065637
    },
    {
        "content": "<p>I would summarize my my point as: we ought to preserve <em>modularity</em> (in the ML sense) as much as possible. This means type authors must be able to hide implementation details like the order of fields and other things that are currently non-breaking to change.</p>\n<p>This means (applying the above to your points):</p>\n<ul>\n<li>I have no problem with generic safe transmute per se, only with the impls it would use being controlled entirely by existing field visibility. I.e. I disagree with Jack's assertion about \"two competing indicators\"- I <em>want</em> those things to be indicated separately, and I <em>don't</em> want purely-local analysis.</li>\n<li>I have no problem with turning UB into compile errors either, I just want <em>even more</em> compile errors. Jack seems to think this will just lead people back to UB because the alternative of type authors opting in would be too onerous, though tbf he hasn't given me a straight answer here so I could be misinterpreting him. (And of course I see that opt-in, or at least opt-out, as crucial.)</li>\n<li>My complaints about complexity are secondary, though I disagree that anyone is already using a <code>Scope</code>-like mechanism anywhere. I would also note that we have a large example of a language that avoids adding new language features when things can be done in a library - C++ - and it often just makes a big mess (e.g. <code>std::variant</code>/<code>std::visit</code>).</li>\n</ul>\n<p>(The linked post is more about the downsides of Muckable, which I also don't disagree with, than it is about the upsides of Scope. Personally I would rather we went with neither and instead came up with a system where external transmute call sites could <em>just</em> rely on a normal trait impl without Scope, as that solves the semver problem <em>and</em> happens to mean that we don't even need to decide whether Scope or any other form of private impls is explainable enough.)</p>",
        "id": 218860315,
        "sender_full_name": "rpjohnst",
        "timestamp": 1607101170
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"117495\">rpjohnst</span> <a href=\"#narrow/stream/216762-project-safe-transmute/topic/Incremental.20Approach/near/218860315\">said</a>:</p>\n<blockquote>\n<p>The linked post is more about the downsides of Muckable, which I also don't disagree with, than it is about the upsides of Scope. Personally I would rather we went with neither and instead came up with a system where external transmute call sites could just rely on a normal trait impl without Scope,</p>\n</blockquote>\n<p>Can you elaborate? The <code>Muckable</code> I asked about there would be just a normal trait impl that asserts that the type contains no further invariants beyond type-level ones.</p>",
        "id": 218887956,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1607114050
    },
    {
        "content": "<p>Right- Muckable on its own does satisfy \"just rely on a normal trait impl without Scope,\" what I'm getting at is that Muckable is too limiting to be a general solution. One possibility to resolve that problem is some kind of semver-ignoring foundational API that we can build things on, but I would rather we skip that and come up with something that shares Muckable's \"just a normal trait impl\" property but also supports things like partial visibility.</p>",
        "id": 218893871,
        "sender_full_name": "rpjohnst",
        "timestamp": 1607117607
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> </p>\n<blockquote>\n<p>Actually, this is arguably a misuse of transmute in the first place, in the sense that what is needed, visibility override, need not even involve memory unsafe operations</p>\n</blockquote>\n<p>visibility override is effectively memory-unsafe. e.g. if you override visibility of <code>Vec</code> and mutate its <code>capacity</code> field, that leads to memory unafety. I don't think you can entirely separate these concerns.</p>",
        "id": 218935674,
        "sender_full_name": "RalfJ",
        "timestamp": 1607175663
    },
    {
        "content": "<p>That's true; this is what I meant by visibility override is unsafe</p>",
        "id": 218935689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607175699
    },
    {
        "content": "<p>I mean that rust can defend against the most immediate kind of UB</p>",
        "id": 218935733,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607175736
    },
    {
        "content": "<p>it's still unsafe but it's not insta-UB</p>",
        "id": 218935737,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607175751
    },
    {
        "content": "<p>put another way, it takes it down a notch from double-plus-unsafe that you see in the docs on <code>transmute</code> to regular unsafe</p>",
        "id": 218935815,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1607175923
    },
    {
        "content": "<p>I see. I guess I don't entirely agree that these \"two kinds of unsafe\" are as different as you make them sound here.</p>",
        "id": 218936039,
        "sender_full_name": "RalfJ",
        "timestamp": 1607176298
    },
    {
        "content": "<p>Right, so the thing is that <code>Muckable</code> can be seen as just <code>Pod</code> where as much as possible is checked by the compiler.</p>\n<p>The following is (imo) what a maximally useful \"normal trait\" would look like. </p>\n<p><code>Muckable</code> states that a struct does not have any extra invariants beyond those required by it's fields, and it's fields all implement <code>Muckable</code>. A field is considered suitable for transmutation iff it is <code>pub</code> and <code>Muckable</code>. (For usability, an <em>exported</em> struct with all pub fields can derive <code>Muckable</code> automatically)</p>\n<p>This resolves the concerns of competing indicators (partially) and partial visibility, but it wouldn't help with the others. Those are <strong>intrinsic</strong> limitations of the trait system (and some of them, such as newtyping, have been a complaint since forever). If we want a solely trait based solution without visbility, we (quite obviously) will be limited by the trait system.</p>",
        "id": 218953352,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1607202057
    }
]