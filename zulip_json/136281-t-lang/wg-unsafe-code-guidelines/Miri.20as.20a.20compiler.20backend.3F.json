[
    {
        "content": "<p>How feasible do you think it would be to make a rustc backend that essentially does the same checks as MIRI, but is compiled instead of interpreted? Perhaps it could even be a compiler middleware, so it transforms the MIR into new MIR which emulates the rust abstract machine, and then that MIR can be passed through to a real backend like LLVM.</p>",
        "id": 278059402,
        "sender_full_name": "Diggsey",
        "timestamp": 1649266606
    },
    {
        "content": "<p>That sounds like what <a href=\"https://github.com/viperproject/prusti-dev\">Prusti</a>, <a href=\"https://github.com/xldenis/creusot\">Cruseot</a> and <a href=\"https://github.com/secure-foundations/verus\">Verus</a> do.</p>",
        "id": 278069817,
        "sender_full_name": "Pointerbender",
        "timestamp": 1649271326
    },
    {
        "content": "<p>I think that it may be possible, but I'm not sure you'd see particularly significant optimizations. At least in SB with raw pointer tagging, the majority of the runtime of Miri is in the Stacked Borrows implementation, not interpreting of Rust. The situation is significantly less dire without raw pointer tagging.</p>",
        "id": 278070382,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649271588
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"400735\">Pointerbender</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Miri.20as.20a.20compiler.20backend.3F/near/278069817\">said</a>:</p>\n<blockquote>\n<p>That sounds like what <a href=\"https://github.com/viperproject/prusti-dev\">Prusti</a>, <a href=\"https://github.com/xldenis/creusot\">Cruseot</a> and <a href=\"https://github.com/secure-foundations/verus\">Verus</a> do.</p>\n</blockquote>\n<p>no, those tools (at least the first 2) do verification. that's a very different problem statement. they want to show that <em>all</em> executions of a program are correct; Miri (like sanitizers) wants to show that <em>the one execution currently happenig</em> is fine (not causing UB).</p>",
        "id": 278073528,
        "sender_full_name": "RalfJ",
        "timestamp": 1649273080
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"295632\">@Diggsey</span> that's basically the ubsan approach. no idea how hard that is for the kinds of checks Miri does...</p>",
        "id": 278073621,
        "sender_full_name": "RalfJ",
        "timestamp": 1649273133
    },
    {
        "content": "<p>This is always possible because we can just embed in the machine code everything Miri does, but Miri does a lot and it may cause even slower execution (because of instruction cache). I'm also not sure what optimizations we'll be able to do without breaking the checks. So we can't rely on LLVM for optimized codegen.</p>",
        "id": 278089404,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649280908
    },
    {
        "content": "<p>well we can still assume LLVM is bug-free and only optimizes away checks that are actually redundant</p>",
        "id": 278089534,
        "sender_full_name": "RalfJ",
        "timestamp": 1649280970
    },
    {
        "content": "<p>sure, there is a higher risk of false results than with plain Miri, but it's also faster, so -- it's a tradeoff</p>",
        "id": 278089555,
        "sender_full_name": "RalfJ",
        "timestamp": 1649280985
    },
    {
        "content": "<blockquote>\n<p>well we can still assume LLVM is bug-free and only optimizes away checks that are actually redundant</p>\n</blockquote>\n<p>I don't think LLVM is buggy but Miri may do things that if compiled into LLVM IR are UB (I have to admit I'm don't know much about Miri's code, though).</p>",
        "id": 278090482,
        "sender_full_name": "Chayim Refael Friedman",
        "timestamp": 1649281443
    },
    {
        "content": "<p>I suspect an LLVM IR Miri would just look like ASan from a great distance</p>",
        "id": 278090755,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649281612
    },
    {
        "content": "<p>Just doing an extra function call here there and everywhere which may crash</p>",
        "id": 278090778,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649281627
    },
    {
        "content": "<p>My biggest concern is that the fact that function calls and returns have meaning to SB will wreck inlining... And there go all the optimizations</p>",
        "id": 278090911,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649281687
    },
    {
        "content": "<p>I don't want to tell people not to do this, I just think that between the sheer number of checks that Miri does compared to ASan and the amount of time in the SB runtime (which is compiled Rust) we have better opportunities for improvement elsewhere.</p>",
        "id": 278091146,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649281812
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"340138\">Chayim Refael Friedman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Miri.20as.20a.20compiler.20backend.3F/near/278090482\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>well we can still assume LLVM is bug-free and only optimizes away checks that are actually redundant</p>\n</blockquote>\n<p>I don't think LLVM is buggy but Miri may do things that if compiled into LLVM IR are UB (I have to admit I'm don't know much about Miri's code, though).</p>\n</blockquote>\n<p>well that would be a bug in the instrumentation pass...</p>",
        "id": 278094426,
        "sender_full_name": "RalfJ",
        "timestamp": 1649283882
    },
    {
        "content": "<p>Yeah I imagine the main benefits would come from inlining the MIRI checks into the source code itself</p>",
        "id": 278102937,
        "sender_full_name": "Diggsey",
        "timestamp": 1649290047
    },
    {
        "content": "<p>since there may be cases where the check is not necessary given knowledge of values at that point in the code</p>",
        "id": 278102956,
        "sender_full_name": "Diggsey",
        "timestamp": 1649290078
    },
    {
        "content": "<p>it's also possible there's a lot of redundant checking of constraints, which can't actually be violated given knowledge of the code being executed</p>",
        "id": 278103066,
        "sender_full_name": "Diggsey",
        "timestamp": 1649290179
    },
    {
        "content": "<p>and llvm could take advantage of that</p>",
        "id": 278103076,
        "sender_full_name": "Diggsey",
        "timestamp": 1649290189
    },
    {
        "content": "<p>I do not think that any of the stacked borrows checks will inline</p>",
        "id": 278103352,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649290442
    },
    {
        "content": "<p>Alignment checks will probably clean up a bit</p>",
        "id": 278103379,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649290460
    }
]