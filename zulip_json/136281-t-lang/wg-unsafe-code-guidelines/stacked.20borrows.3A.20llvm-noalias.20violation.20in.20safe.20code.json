[
    {
        "content": "<p>example:</p>\n<div class=\"codehilite\"><pre><span></span>let x: &amp;mut u32 = a;\nlet raw_ptr: *const u32 = x;\nfoo(x, raw_ptr);\n\nfn foo(x: &amp;mut u32, raw_ptr: *const u32) -&gt; u32 {\n    let x = &amp;mut *x; // stack is now [..., Uniq(N)]\n    *x = 5;\n    let y = &amp;*x; // stack is now [..., Uniq(N), Shr]\n\n    // this is OK according to stacked borrows because of the Shr tag, but is UB\n    // according to LLVM noalias and would be hard to make non-UB.\n    unsafe { *raw_ptr }\n}\n</pre></div>",
        "id": 148370161,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543242559
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"116009\">@nikomatsakis</span> This is an example of code that is UB according to LLVM but not according to Stacked Borrows. I designed Stacked Borrows coming more from the Rust side than from the LLVM side, so I am not too surprised these exist, but it means Stacked Borrows cannot be the end of the story for justifying <code>noalias</code>.</p>",
        "id": 148698750,
        "sender_full_name": "RalfJ",
        "timestamp": 1543396358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126804\">@Ariel Ben-Yehuda</span> you had another interesting example, involving <code>mem::replace</code> or so, didn't you?</p>",
        "id": 148698757,
        "sender_full_name": "RalfJ",
        "timestamp": 1543396382
    },
    {
        "content": "<p>My general plan for this is that I hope to work with some other people on better understanding LLVM noalias, and once we got that we can see how much of that we have to incorporate into Rust, and how it interacts with Stacked Borrows.</p>",
        "id": 148698772,
        "sender_full_name": "RalfJ",
        "timestamp": 1543396429
    },
    {
        "content": "<p>but that's a multi-year plan ;)</p>",
        "id": 148698775,
        "sender_full_name": "RalfJ",
        "timestamp": 1543396439
    },
    {
        "content": "<p>I would really hope that's ub in any system we come up with</p>",
        "id": 148723271,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543421801
    },
    {
        "content": "<p>we should be able to assume <code>&amp;mut</code> pointers don't alias anything</p>",
        "id": 148723307,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543421845
    },
    {
        "content": "<p>especially other function parameters</p>",
        "id": 148723533,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422061
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> that doesn't hold though, here is a counterexample:</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">use</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">cell</span>::<span class=\"n\">RefCell</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">fn</span> <span class=\"nf\">inner</span><span class=\"p\">(</span><span class=\"n\">rc</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">RefCell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">aliasing</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"c1\">// the two pointers alias (they are not equal, but they overlap)</span>\n<span class=\"w\">        </span><span class=\"n\">println</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s\">&quot;{:?} + {} = {:?}&quot;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">rc</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"p\">(</span><span class=\"n\">aliasing</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">rc</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">aliasing</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">rc</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">RefCell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">23</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">bmut</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">rc</span><span class=\"p\">.</span><span class=\"n\">borrow_mut</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">inner</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">rc</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">bmut</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 148723852,
        "sender_full_name": "RalfJ",
        "timestamp": 1543422344
    },
    {
        "content": "<p>that's not aliasing?</p>",
        "id": 148723955,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422411
    },
    {
        "content": "<p>that's pointers being equal</p>",
        "id": 148723974,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422430
    },
    {
        "content": "<p>so you are not actually talking about the property of pointers then, but about the property of accesses \"done through\" them</p>",
        "id": 148724097,
        "sender_full_name": "RalfJ",
        "timestamp": 1543422537
    },
    {
        "content": "<p>yes</p>",
        "id": 148724125,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422564
    },
    {
        "content": "<p>I think I know what you mean, I am not sure I agree though. I don't think raw pointers should have an identity. That's just an unnecessary complication in usually-already-complicated raw ptr code.</p>",
        "id": 148724137,
        "sender_full_name": "RalfJ",
        "timestamp": 1543422585
    },
    {
        "content": "<p>the type system must guarantee that those accesses do not alias</p>",
        "id": 148724140,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422589
    },
    {
        "content": "<p>but raw pointers probably must have an identity for purposes of alias analysis</p>",
        "id": 148724229,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422623
    },
    {
        "content": "<p>since they do have an identity in LLVM</p>",
        "id": 148724240,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422631
    },
    {
        "content": "<blockquote>\n<p>since they do have an identity in LLVM</p>\n</blockquote>\n<p>at this point I am still trying to separate \"the model we want\" from constraints like \"how LLVM works\". that may be just naive or idealistic, but well, I'm dreaming a bit ;)</p>",
        "id": 148724438,
        "sender_full_name": "RalfJ",
        "timestamp": 1543422813
    },
    {
        "content": "<p>I mean that's fair, but we should keep in mind LLVM</p>",
        "id": 148724458,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422834
    },
    {
        "content": "<p>it's been designed in a reasonably useful way for optimization</p>",
        "id": 148724507,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422847
    },
    {
        "content": "<p>fair enough</p>",
        "id": 148724514,
        "sender_full_name": "RalfJ",
        "timestamp": 1543422854
    },
    {
        "content": "<p>I'm not gonna say raw pointers must have identity, I don't know, but that example must be UB</p>",
        "id": 148724527,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543422876
    },
    {
        "content": "<p>hence my long-term plan: 1. understand LLVM noalias (for me this means have a precise formal model, one that one could use to prove things in), and then 2. see if from that we can glean how to make Stacked Borrows compatible, or maybe small tweaks to LLVM that might be acceptable upstream to make it more compatible with an idea of \"untracked pointers\"</p>",
        "id": 148724540,
        "sender_full_name": "RalfJ",
        "timestamp": 1543422905
    },
    {
        "content": "<blockquote>\n<p>but that example must be UB</p>\n</blockquote>\n<p>that is because LLVM treats it as such and you consider LLVM immutable, or because there are good reasons for this from a pure Rust perspective?</p>",
        "id": 148724634,
        "sender_full_name": "RalfJ",
        "timestamp": 1543422966
    },
    {
        "content": "<p>I <em>think</em> the current model is sound wrt LLVM if no raw pointers are involved, which is a good start IMO.</p>",
        "id": 148724732,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423073
    },
    {
        "content": "<p>because there are good reasons for this from a pure rust perspective</p>",
        "id": 148724824,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423140
    },
    {
        "content": "<p>basically, I don't think introducing raw pointers should do anything to optimization</p>",
        "id": 148724865,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423186
    },
    {
        "content": "<p><code>*const T</code> should be treated as a nullable, maybe-unaligned <code>&amp;T</code>, while <code>*mut T</code> should be treated as a nullable, maybe-unaligned <code>&amp;UnsafeCell&lt;T&gt;</code></p>",
        "id": 148725022,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423296
    },
    {
        "content": "<p>(that was weird UX things)</p>",
        "id": 148725032,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423309
    },
    {
        "content": "<p>also to be clear, I really like stacked borrows, I think it's a fantastic model which just requires a bit of working out the kinks</p>",
        "id": 148725107,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423365
    },
    {
        "content": "<blockquote>\n<p>also to be clear, I really like stacked borrows, I think it's a fantastic model which just requires a bit of working out the kinks</p>\n</blockquote>\n<p>good to hear. :) I am sure it's not ready yet</p>",
        "id": 148725297,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423520
    },
    {
        "content": "<blockquote>\n<p>*const T should be treated as a nullable, maybe-unaligned &amp;T</p>\n</blockquote>\n<p>that can't be entirely right, <code>&amp;i32</code> e.g. asserts immutability while <code>*const i32</code> is fine with writes through other pointers to the same location</p>",
        "id": 148725383,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423579
    },
    {
        "content": "<p>mmh, good point</p>",
        "id": 148725438,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423638
    },
    {
        "content": "<p>about the example: the reason it is considered okay by stacked borrows is that the mutable ref <em>did</em> get shared. so reads can happen through shared references</p>",
        "id": 148725461,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423658
    },
    {
        "content": "<p>also allowing reads through raw pointers at that point didn't seem too harmful</p>",
        "id": 148725527,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423684
    },
    {
        "content": "<p>so <code>*const T</code> should also be treated as <code>&amp;UnsafeCell&lt;T&gt;</code> probably</p>",
        "id": 148725537,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423692
    },
    {
        "content": "<p>fixing this particular example is easy though (just disallow raw ptr reads when the location was never cast to a raw ptr). variants of it are harder.</p>",
        "id": 148725573,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423729
    },
    {
        "content": "<p>even then, it seems untenable to support</p>",
        "id": 148725603,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423764
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">raw_ptr</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">u32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// stack is now [..., Uniq(N)]</span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">5</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">mem</span>::<span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// internally uses raw pointers</span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// stack is now [..., Uniq(N), Shr]</span>\n\n<span class=\"w\">    </span><span class=\"c1\">// this is OK according to stacked borrows because of the Shr tag, but is UB</span>\n<span class=\"w\">    </span><span class=\"c1\">// according to LLVM noalias and would be hard to make non-UB.</span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">raw_ptr</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 148725621,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423781
    },
    {
        "content": "<p>here the location actually <em>does</em> get \"leaked\" to raw ptrs by <code>mem::swap</code>, hence justifying the raw ptr access later</p>",
        "id": 148725712,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423817
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>let x : *mut i32;\nlet y : &amp;mut i32;\n\n*y = 0;\ny as *mut i32;\n*x\n</pre></div>",
        "id": 148725729,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423829
    },
    {
        "content": "<p>I don't see a way to rule this out without tracking raw ptr identity</p>",
        "id": 148725743,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423844
    },
    {
        "content": "<p>right</p>",
        "id": 148725749,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423850
    },
    {
        "content": "<p>I'd argue that that's the solution</p>",
        "id": 148725755,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423857
    },
    {
        "content": "<p>I'd argue that cure is worse than the disease ;)</p>",
        "id": 148725778,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423877
    },
    {
        "content": "<p>basically I am not convinced that the additional power this gives to the optimizer is worth the additional complexity this imposes on every unsafe code author</p>",
        "id": 148725804,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423907
    },
    {
        "content": "<p>I mean... the complexity is imposed already</p>",
        "id": 148725861,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423940
    },
    {
        "content": "<p>I also don't think it's really any extra complexity for unsafe authors</p>",
        "id": 148725873,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423959
    },
    {
        "content": "<p>raw pointers not being tracked seems like a very useful complexity reduction to me</p>",
        "id": 148725879,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423967
    },
    {
        "content": "<p>but I might also be overestimating that extra complexity</p>",
        "id": 148725884,
        "sender_full_name": "RalfJ",
        "timestamp": 1543423973
    },
    {
        "content": "<p>for the model, I think</p>",
        "id": 148725887,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423977
    },
    {
        "content": "<p>but not for people writing code</p>",
        "id": 148725897,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543423984
    },
    {
        "content": "<p>and it might reduce complexity around other questions, like the difference between transmute-to-raw and cast-to-raw, or the funny effects when you transmute a raw ptr to a reference</p>",
        "id": 148725923,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424010
    },
    {
        "content": "<p>exactly</p>",
        "id": 148725934,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424021
    },
    {
        "content": "<p>hm now that is curious, people writing the code will have to understand the model, so I'd think any complexity increase in the model is also a complexity increase for programmers?</p>",
        "id": 148725949,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424035
    },
    {
        "content": "<p>very few programmers will ever understand the model on a mathematical level</p>",
        "id": 148726011,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424063
    },
    {
        "content": "<p>they will get told \"this is UB\"</p>",
        "id": 148726022,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424074
    },
    {
        "content": "<p>oh sure, I meant on a more intuitive, descriptive level</p>",
        "id": 148726032,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424085
    },
    {
        "content": "<p>by people like me</p>",
        "id": 148726037,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424088
    },
    {
        "content": "<p>something with pictures of a stack ;)</p>",
        "id": 148726041,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424090
    },
    {
        "content": "<p>on an intuitive level, they probably won't get close to enough mathematical rigor that the extra complexity matters</p>",
        "id": 148726076,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424124
    },
    {
        "content": "<p>this is my experience in the C++ community, anyways</p>",
        "id": 148726108,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424153
    },
    {
        "content": "<p>having a checker is far more important than having a simple system</p>",
        "id": 148726208,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424217
    },
    {
        "content": "<p>because the vast, vast majority of people will never read this part of the specification :P</p>",
        "id": 148726254,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424275
    },
    {
        "content": "<p>judging from the feedback I got, experienced programmers without a CS degree can think in terms of sth on the complexity of Stacked Borrows. so I hope we can keep the model simple enough. but well, only time will tell^^</p>",
        "id": 148726318,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424298
    },
    {
        "content": "<p>(or most of the other parts of the specification, let's be honest)</p>",
        "id": 148726320,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424300
    },
    {
        "content": "<p>the vast majority will hopefully never write unsafe code :P</p>",
        "id": 148726323,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424308
    },
    {
        "content": "<p>that's a key advantage we have over C++</p>",
        "id": 148726340,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424320
    },
    {
        "content": "<p>I don't mean they can't understand it, I mean they just don't care enough to read it</p>",
        "id": 148726347,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424328
    },
    {
        "content": "<p>because we should design our model in a way which means you don't end up having to read it :)</p>",
        "id": 148726377,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424354
    },
    {
        "content": "<p>(and I think stacked borrowd follow that rule)</p>",
        "id": 148726458,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424407
    },
    {
        "content": "<p>I feel in the Rust community there is a strong desire for safe abstractions, and there is a sizeable group of people valuing that enough to very carefully evaluate their crates accordingly. I have no experience with the C++ community so I cannot compare, but as an outsider, safe abstractions seem to be less of a core thing there (also because the type system doesn't really let you do that to the extend Rust does)</p>",
        "id": 148726467,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424413
    },
    {
        "content": "<p>my main problem with \"lets track raw ptrs\" is explaining int-to-ptr casts. we need some kind of \"wildcard\", some kind of fallback. and if that works like raw ptrs work in Stacked Borrows, nothing is won. (all the examples above would still be fine, then, if you just cast ptrs to integers and back a bit.) that's why I'd first like to understand LLVM noalias in isolation, and then maybe that teaches us how to solve this kind of problem.</p>",
        "id": 148726472,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424416
    },
    {
        "content": "<p>I think to understand noalias, one must understand provenance</p>",
        "id": 148726518,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424472
    },
    {
        "content": "<p>provenance travels through values of any type</p>",
        "id": 148726539,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424501
    },
    {
        "content": "<p>true. I feel at least I understand it much better now than I did a year ago.</p>",
        "id": 148726543,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424505
    },
    {
        "content": "<blockquote>\n<p>provenance travels through values of any type</p>\n</blockquote>\n<p>I strongly disagree with that</p>",
        "id": 148726550,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424512
    },
    {
        "content": "<p>how?</p>",
        "id": 148726592,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424524
    },
    {
        "content": "<p>integers shouldnt have provenance, and I think any model making them have provenance is untenable</p>",
        "id": 148726600,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424540
    },
    {
        "content": "<p>there are common compiler optimizations that are incompatible with integers having provenance</p>",
        "id": 148726637,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424583
    },
    {
        "content": "<p>like, GVN putting <code>i</code> and <code>j</code> into the same \"bucket\" inside an <code>if i == j</code></p>",
        "id": 148726651,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424600
    },
    {
        "content": "<p>and also from a modelling perspective, integers corresponding to mathematical integers (modulo 2^N) is <em>extremely useful</em></p>",
        "id": 148726676,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424629
    },
    {
        "content": "<p>and breaking that... ugh. no please no.^^</p>",
        "id": 148726721,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424646
    },
    {
        "content": "<p>for the next C/C++ standards, AFAIK the game still seems to be open wrt. integers do or do not have provenance. I very strongly hope they decide against making them have provenance</p>",
        "id": 148726760,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424695
    },
    {
        "content": "<p>(I'll be back later, afk for now)</p>",
        "id": 148726776,
        "sender_full_name": "RalfJ",
        "timestamp": 1543424714
    },
    {
        "content": "<p>I would argue that provenance lists are the way to solve that</p>",
        "id": 148726803,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424748
    },
    {
        "content": "<p>but this is the way LLVM does noalias:</p>",
        "id": 148726809,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424758
    },
    {
        "content": "<blockquote>\n<p>This indicates that objects accessed via pointer values based on the argument or return value are not also accessed, during the execution of the function, via pointer values not based on the argument or return value.</p>\n</blockquote>",
        "id": 148726817,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424762
    },
    {
        "content": "<p>(on a noalias argument)</p>",
        "id": 148726864,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543424773
    },
    {
        "content": "<p>I agree understanding provenance is key to understanding noalias</p>",
        "id": 148729638,
        "sender_full_name": "RalfJ",
        "timestamp": 1543427274
    },
    {
        "content": "<p>it means that stuff like:</p>",
        "id": 148730574,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543428240
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span>fn foo(x: &amp;mut i32, y: *const i32) -&gt; i32 {\n  *(x as *mut _ as usize as *mut i32) = 1;\n  *y\n}\n</pre></div>",
        "id": 148730643,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543428291
    },
    {
        "content": "<p>is still UB, if x and y alias</p>",
        "id": 148730654,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543428303
    },
    {
        "content": "<blockquote>\n<p>is still UB, if x and y alias</p>\n</blockquote>\n<p>what about this?</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">y</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">i32</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xi</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">yi</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">if</span><span class=\"w\"> </span><span class=\"n\">xi</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">yi</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">yi</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"o\">*</span><span class=\"n\">y</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>\n\n\n<p>And what if I now replace <code>yi</code> by <code>xi</code> inside the conditional (which GVN will do if it deems it profitable)?</p>",
        "id": 148740691,
        "sender_full_name": "RalfJ",
        "timestamp": 1543436844
    },
    {
        "content": "<p>LLVM can introduce that kind of UB in its passes, as long as it makes it not UB by some other transformation.</p>",
        "id": 148745440,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543440789
    },
    {
        "content": "<p>That doesn't mean you can.</p>",
        "id": 148745445,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543440795
    },
    {
        "content": "<p>Sure, but LLVM wants to run alias analysis before and after GVN, so there is a tension here that can't just be explained away that way</p>",
        "id": 148745527,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543440867
    },
    {
        "content": "<p>for example, LLVM can transform <code>struct { unsigned x; unsigned y; } foo; do_smth(&amp;foo); return foo.x | (static_cast&lt;uint64_t&gt;(foo.y) &lt;&lt; 32);</code> with <code>return *(uint64_t*)&amp;foo;</code>, but you sure can't.</p>",
        "id": 148745529,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543440869
    },
    {
        "content": "<p>(in C++ (because of alignment _and_ TBAA), nor Rust (because of alignment))</p>",
        "id": 148745537,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543440879
    },
    {
        "content": "<p>if LLVM wants to make that transformation, it has to make the transformed code not UB via some method</p>",
        "id": 148745638,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543440968
    },
    {
        "content": "<p>Yes, the issue is how to do that in a model where integers have provenance.</p>",
        "id": 148745802,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543441112
    },
    {
        "content": "<p>huh?</p>",
        "id": 148745836,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441145
    },
    {
        "content": "<p>integers have provenance in LLVM</p>",
        "id": 148745847,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441154
    },
    {
        "content": "<p>if GVN wants to make that optimization, that's LLVM's problem</p>",
        "id": 148745934,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441212
    },
    {
        "content": "<p>we have to guarantee that Rust code which does not have UB transforms into LLVM IR that doesn't have undefined behavior, though</p>",
        "id": 148745986,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441268
    },
    {
        "content": "<p>LLVM also has to make sure its transformations follow this property</p>",
        "id": 148745997,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441293
    },
    {
        "content": "<p>one easy way to do this would be to remove the <code>noalias</code> on the parameter</p>",
        "id": 148746011,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441311
    },
    {
        "content": "<p>I am well aware of the roles of rustc and LLVM passes. I think we're coming from different perspectives? Like, yes, ultimately justifying transformations is the problem of the one doing them, but Ralf's point was more generally that models in which integers have provenance suck, in part because it's so difficult to justify perfectly sensible optimizations on pure integer operations (such as GVN in that example).</p>",
        "id": 148746138,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543441429
    },
    {
        "content": "<p>I mean, okay, but we have to deal with LLVM as it exists, and LLVM as it exists gives integers provenance. I don't see a way of keeping the optimizations without giving integers provenance in any model we use.</p>",
        "id": 148746266,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441506
    },
    {
        "content": "<p>(also, we can give integers provenance in the Rust model, and then helpfully ignore integer provenance if it's helpful for optimization)</p>",
        "id": 148746393,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441619
    },
    {
        "content": "<p>(which is what I assume LLVM does)</p>",
        "id": 148746402,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543441628
    },
    {
        "content": "<p>Well, it's not like LLVM is immutable and infallible. Its integer optimizations and aliasing model have in the past contradicted itself.</p>",
        "id": 148746548,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543441742
    },
    {
        "content": "<p>As detailed in <a href=\"https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf\" target=\"_blank\" title=\"https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf\">https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf</a> which also lays out a memory model that justifies many existing optimizations LLVM does without provenance for integers (though IIRC it don't say anything about <code>noalias</code> specifically)</p>",
        "id": 148746750,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543441888
    },
    {
        "content": "<p>None of this means we're in the clear wrt how LLVM works today but to me it illustrates that maybe noalias in its current form isn't the be-all-end-all and we either have to conform to it or lose all hope of improving AA. I can definitely see a future where either LLVM changes its aliasing/memory model or gains more fine-grained alternatives to <code>noalias</code> that we have a better shot at using (there's plenty of non-Rust-incentives for this, e.g. noalias is known to be pretty inadequate for <code>restrict</code> too)</p>",
        "id": 148747081,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543442168
    },
    {
        "content": "<blockquote>\n<p>LLVM as it exists gives integers provenance.</p>\n</blockquote>\n<p>I doubt that. I think it does not. And they have a GVN transformation which witnesses that it does not.</p>",
        "id": 148747096,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442186
    },
    {
        "content": "<p>LLVM IR has the same semantics before and after GVN</p>",
        "id": 148747110,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442205
    },
    {
        "content": "<p>so, while it is true that LLVM can have semantics different from Rust, it must have <em>some</em> consistent semantics</p>",
        "id": 148747130,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442224
    },
    {
        "content": "<p>and I am saying \"naive noalias with int-ptr-casts\" + \"GVN based on int equality\" cannot coexist as transformations on the same IR</p>",
        "id": 148747142,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442255
    },
    {
        "content": "<p>it seems likely that LLVM currently does both, and hence is buggy. would be interesting to construct a miscompilation from this actually.</p>",
        "id": 148747190,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442297
    },
    {
        "content": "<blockquote>\n<p>noalias is known to be pretty inadequate for restrict too</p>\n</blockquote>\n<p>it is?</p>",
        "id": 148747207,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442329
    },
    {
        "content": "<p>I believe it's fine for arguments but not expressive enough for locals with restrict</p>",
        "id": 148747229,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543442362
    },
    {
        "content": "<p>ah yeah that seems plausible</p>",
        "id": 148747237,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442378
    },
    {
        "content": "<blockquote>\n<p>As detailed in <a href=\"https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf\" target=\"_blank\" title=\"https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf\">https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf</a> which also lays out a memory model that justifies many existing optimizations LLVM does without provenance</p>\n</blockquote>\n<p>oh but we have provenance :) just not on integers</p>",
        "id": 148747463,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442570
    },
    {
        "content": "<p>but pointers carry around extra information, reflecting their provenance</p>",
        "id": 148747466,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442580
    },
    {
        "content": "<p>a bit like the tags which pointers carry in Stacked Borrows, which also are a form of provenance</p>",
        "id": 148747476,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442598
    },
    {
        "content": "<p>er, yeah, I meant provenance on integers</p>",
        "id": 148747480,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543442600
    },
    {
        "content": "<p>sorry for the confusion</p>",
        "id": 148747483,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543442605
    },
    {
        "content": "<p>okay, then I agree :)</p>",
        "id": 148747488,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442612
    },
    {
        "content": "<p>but yes, <code>noalias</code> is future work</p>",
        "id": 148747496,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442621
    },
    {
        "content": "<p>I am meeting with some other authors of that paper in Jan to start thinking about noalias</p>",
        "id": 148747503,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442633
    },
    {
        "content": "<p><span class=\"emoji emoji-1f38a\" title=\"confetti\">:confetti:</span></p>",
        "id": 148747576,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543442675
    },
    {
        "content": "<p>and the example above will be an interesting litmus test</p>",
        "id": 148747613,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442715
    },
    {
        "content": "<p>one of my coauthors is really good at turning such problems into miscompilations, I'll ask them if they can't exploit this one^^</p>",
        "id": 148747630,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442737
    },
    {
        "content": "<p>but anyway it's getting late... good night!</p>",
        "id": 148747696,
        "sender_full_name": "RalfJ",
        "timestamp": 1543442780
    },
    {
        "content": "<blockquote>\n<p>and I am saying \"naive noalias with int-ptr-casts\" + \"GVN based on int equality\" cannot coexist as transformations on the same IR</p>\n</blockquote>\n<p>My original solution what I called \"broadcast semantics\" - doing the \"unfreeze and push an Shr\" on the ptr-&gt;int cast or pointer comparison (of course, this makes them side-effectful, which has its own disadvantages. Did anyone measure the perf impact of that?)</p>\n<blockquote>\n<p>@Ariel Ben-Yehuda you had another interesting example, involving <code>mem::replace</code> or so, didn't you?</p>\n</blockquote>\n<p>That was just about <code>mem::replace</code> using raw pointers internally, and us not wanting to treat it as a \"leak\".</p>",
        "id": 148750889,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543446176
    },
    {
        "content": "<p>good night in any casez.</p>",
        "id": 148750903,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543446191
    },
    {
        "content": "<blockquote>\n<p>My original solution what I called \"broadcast semantics\" - doing the \"unfreeze and push an Shr\" on the ptr-&gt;int cast or pointer comparison (of course, this makes them side-effectful, which has its own disadvantages. Did anyone measure the perf impact of that?)</p>\n</blockquote>\n<p>Yes and that's what Stacked Borrows does, but this breaks your <code>mem::replace</code> example because <code>replace</code> performs a broadcast</p>",
        "id": 148773548,
        "sender_full_name": "RalfJ",
        "timestamp": 1543481757
    },
    {
        "content": "<p>the issue is somehow \"scoping\" the broadcast, I think</p>",
        "id": 148773591,
        "sender_full_name": "RalfJ",
        "timestamp": 1543481766
    },
    {
        "content": "<p>The idea was limiting the broadcast to ptr-&gt;int casts (and maybe pointer comparisons), rather than to raw pointer ops.</p>",
        "id": 148773644,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543481881
    },
    {
        "content": "<p>with the idea being that ptr-&gt;int casts on pointers that are not \"very much escaped\" should be rare</p>",
        "id": 148773688,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543481912
    },
    {
        "content": "<p>hm. but then calling an unknown function could still do that.</p>",
        "id": 148773721,
        "sender_full_name": "RalfJ",
        "timestamp": 1543481954
    },
    {
        "content": "<p>Stacked Borrows, for me, is all about the guarantees you get around unknown function calls</p>",
        "id": 148773731,
        "sender_full_name": "RalfJ",
        "timestamp": 1543481985
    },
    {
        "content": "<p>yea, and it  can be because the unknown function could be <code>as_ptr</code></p>",
        "id": 148773735,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543481990
    },
    {
        "content": "<p>so one idea I had was to have some kind of references following lifetimes in safe code, that's all the deal about the \"tootsie pop model\"</p>",
        "id": 148773796,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482021
    },
    {
        "content": "<p>I mean Stacked Borrows gives you some of that</p>",
        "id": 148773809,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482045
    },
    {
        "content": "<p>but only after you do a write</p>",
        "id": 148773814,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482055
    },
    {
        "content": "<p>it currently makes even ref-to-raw \"broadcast\" and still you get some guarantees around unknown code</p>",
        "id": 148773822,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482067
    },
    {
        "content": "<p>no, any <code>Retag</code> will do it</p>",
        "id": 148773824,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482073
    },
    {
        "content": "<p>and also there are these \"function call barriers\" that give you even more information (and have <a href=\"https://github.com/rust-lang/rust/pull/56319\" target=\"_blank\" title=\"https://github.com/rust-lang/rust/pull/56319\">found a bug already</a>)</p>",
        "id": 148773826,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482087
    },
    {
        "content": "<p>which go in the other direction, don't they?</p>",
        "id": 148773830,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482107
    },
    {
        "content": "<p>Wouldn't that bug have been caught even without function call barriers?</p>",
        "id": 148773888,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482167
    },
    {
        "content": "<p>no</p>",
        "id": 148773893,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482172
    },
    {
        "content": "<p>because there was a <code>Shr</code> somewhere on the stack</p>",
        "id": 148773896,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482178
    },
    {
        "content": "<p>so turning the raw ptr into an <code>&amp;mut</code> popped to make that <code>Shr</code> active</p>",
        "id": 148773925,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482219
    },
    {
        "content": "<p>so that's the \"raw pointer escape\" rule?</p>",
        "id": 148773984,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482278
    },
    {
        "content": "<p>the equivalent of</p>\n<p>let x: &amp;mut A = ...;<br>\nlet y: *mut A = &amp;mut *x;<br>\nlet z: &amp;A = (&amp;mut *x); // \"WRONG\"<br>\nuse(z, x); // ok, because we have an Shr ?</p>",
        "id": 148774017,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482338
    },
    {
        "content": "<p>ah no there were only 2 shared references there, AND a raw pointer</p>",
        "id": 148774067,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482364
    },
    {
        "content": "<p>so</p>\n<div class=\"codehilite\"><pre><span></span>let x: &amp;A = ...;\nlet y: *const A = &amp;*x;\nlet wrong_z: &amp;A =(&amp;mut *(x as *const A as *mut A);\nuse(x, wrong_z);\n</pre></div>",
        "id": 148774082,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482412
    },
    {
        "content": "<p>I am not sure exactly where the <code>Shr</code> is coming from in this case</p>",
        "id": 148774097,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482446
    },
    {
        "content": "<p>it might have been more like</p>\n<div class=\"codehilite\"><pre><span></span>let x: &amp;mut T = ...;\nlet xraw = x as *mut _;\nlet y = &amp;mut *xraw;\nlet z = &amp;*y;\nlet bad = &amp;mut *(z as *const _); // okay because this raw ptr can match the item pushed for xraw\n</pre></div>",
        "id": 148774168,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482529
    },
    {
        "content": "<p>adding a barrier anywhere between xraw and bad then detects this because you cannot use xraw any more when creating bad</p>",
        "id": 148774186,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482566
    },
    {
        "content": "<p>that seems wrong (not being able to use <code>xraw</code> after using <code>bad</code>).</p>",
        "id": 148774262,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482669
    },
    {
        "content": "<p>you mean <code>y</code>?</p>",
        "id": 148774271,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482682
    },
    {
        "content": "<p>I thought that broadcastness remained until you used an \"old\" raw pointer</p>",
        "id": 148774280,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482714
    },
    {
        "content": "<p>or reference</p>",
        "id": 148774328,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482733
    },
    {
        "content": "<p>aka <code>x</code></p>",
        "id": 148774329,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543482735
    },
    {
        "content": "<blockquote>\n<p>that seems wrong (not being able to use <code>xraw</code> after using <code>bad</code>).</p>\n</blockquote>\n<p>I said no such thing?</p>",
        "id": 148774477,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482971
    },
    {
        "content": "<p>Creating <code>bad</code> will make the <code>Shr</code> item pushed for <code>xraw</code> top-of-stack</p>",
        "id": 148774482,
        "sender_full_name": "RalfJ",
        "timestamp": 1543482988
    },
    {
        "content": "<p>so now you can use both <code>bad</code> and <code>xraw</code> interchangably: two raw pointers with the same tag, pointing to a location whose top-of-stack is <code>Shr</code></p>",
        "id": 148774488,
        "sender_full_name": "RalfJ",
        "timestamp": 1543483014
    },
    {
        "content": "<p>the barrier makes it so that <code>bad</code> cannot be <em>created</em>, because the item it needs (<code>Shr</code>) is behind a barrier</p>",
        "id": 148774506,
        "sender_full_name": "RalfJ",
        "timestamp": 1543483059
    },
    {
        "content": "<p>that would be code like</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">...;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">xraw</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">xraw</span><span class=\"p\">);</span><span class=\"w\"></span>\n\n<span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">y</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">mut</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"c1\">// here we add a barrier to the stack, making sure y cannot be popped off</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">bad</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">z</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"c1\">// NOT okay because this would pop y off the stack,</span>\n<span class=\"c1\">// which is prevent by a barrier</span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre></div>",
        "id": 148774583,
        "sender_full_name": "RalfJ",
        "timestamp": 1543483158
    },
    {
        "content": "<p>ok I just misread you</p>",
        "id": 148774966,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543483710
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> is this the result of asking your coauthor who's good at creating miscompiles? :D <a href=\"https://bugs.llvm.org/show_bug.cgi?id=39846\" target=\"_blank\" title=\"https://bugs.llvm.org/show_bug.cgi?id=39846\">https://bugs.llvm.org/show_bug.cgi?id=39846</a></p>",
        "id": 148852995,
        "sender_full_name": "Hanna Kruppe",
        "timestamp": 1543573138
    },
    {
        "content": "<p>it is^^ (not the coauthor I expected, but I sent this to all of them)</p>",
        "id": 148853378,
        "sender_full_name": "RalfJ",
        "timestamp": 1543573632
    },
    {
        "content": "<p>I'm actually rather surprised by this particular miscompile, I expected them to be different, but I won't be picky^^. Anything that demonstrates that LLVM's noalias handling is inconsistent is helpful towards figuring out a consistent story.</p>",
        "id": 148853467,
        "sender_full_name": "RalfJ",
        "timestamp": 1543573772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126804\">@Ariel Ben-Yehuda</span> <span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span>  you might also be interested in this example, see the link a few messages up</p>",
        "id": 148853522,
        "sender_full_name": "RalfJ",
        "timestamp": 1543573824
    },
    {
        "content": "<p>One another solution would be to track derivation \"precisely\" in the spec, but to have LLVM treat inttoptr as a broadcast.</p>",
        "id": 148864043,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543587878
    },
    {
        "content": "<p>which would make GVN not a legal endo-optimization on Rust code, but maintain it as an endo-optimization on LLVM IR</p>",
        "id": 148864066,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543587908
    },
    {
        "content": "<p>*ptrtoint is broadcast, not inttoptr</p>",
        "id": 148864077,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543587941
    },
    {
        "content": "<p>so this would keep the spec clean, but (I think) enable all the optimizations we want in practice</p>",
        "id": 148864172,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543588051
    },
    {
        "content": "<p>other than pointers being passed to foreign functions being treated as escaping. But that's a must given <code>as_ptr</code> I think</p>",
        "id": 148864188,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543588076
    },
    {
        "content": "<p>we need to make sure that <code>*(ptr as *const usize) = *(ptr as *const usize);</code> \"breaks derived\" while having memcpy work</p>",
        "id": 148865032,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543588804
    },
    {
        "content": "<p>as in, keep derived, preferably without broadcast</p>",
        "id": 148865058,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543588818
    },
    {
        "content": "<p>moving memcpy to use a \"databyte\" type that is GVN-less instead of u8 would work</p>",
        "id": 148865068,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543588832
    },
    {
        "content": "<p>so in the MIR you can't even optimize <code>x*0</code> [if we really wanted, we could add <code>broadcast</code> to MIR and optimize <code>x*0</code> to <code>{ broadcast(x); 0 }</code>]</p>",
        "id": 148865449,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543589243
    },
    {
        "content": "<p>and we can even lower the likes if <code>inttoptr(ptrtoint(x) | 1)</code> in a way that doesn't broadcast anything</p>",
        "id": 148865463,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543589262
    },
    {
        "content": "<p>we'll need a <code>set_tag</code> intrinsic that doesn't allow intermediate GVN, but that will work</p>",
        "id": 148865520,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543589304
    },
    {
        "content": "<p>and add \"Torvalds' delight\" where in the MIR, <code>(x &amp; 0xff)</code> is not derived from <code>x</code> but <code>x &amp; 0xffffff00</code> is</p>",
        "id": 148865748,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543589552
    },
    {
        "content": "<p>integer optimizations on MIR require adding broadcasts to random places, let LIR handle them</p>",
        "id": 148865857,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543589662
    },
    {
        "content": "<p>I really dislike provenance on integers. I think <code>u32</code> should exactly model <code>Z_[2^32]</code>, i.e., integers modulo 2^32, not the product of that and some magic metadata. We shouldn't make people's reasoning about code harder than it already is.</p>",
        "id": 148866513,
        "sender_full_name": "RalfJ",
        "timestamp": 1543590314
    },
    {
        "content": "<p>that's basically externalizing the cost and letting our users pay the price</p>",
        "id": 148866607,
        "sender_full_name": "RalfJ",
        "timestamp": 1543590391
    },
    {
        "content": "<p>our integers don't model the modulo field tho</p>",
        "id": 148868471,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543592049
    },
    {
        "content": "<p>also, why is that making code harder to reason about?</p>",
        "id": 148868496,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543592080
    },
    {
        "content": "<p>because it is extra state that has to be considered during verification? it means all sorts of equations that hold trivially for integers need to be carefully verified for these \"strange integers\". likely, they are not even associative and/or commutative. it might even make the set of possible values infinite depending on what exactly provenance looks like.</p>",
        "id": 148868632,
        "sender_full_name": "RalfJ",
        "timestamp": 1543592170
    },
    {
        "content": "<p>it means that just because I know that some integer is 0, I <em>still</em> cannot fully describe its behavior. How is that not a huge burden for verification?</p>",
        "id": 148868656,
        "sender_full_name": "RalfJ",
        "timestamp": 1543592196
    },
    {
        "content": "<p>you said users</p>",
        "id": 148868719,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543592265
    },
    {
        "content": "<p>I don't think it's a burden for users</p>",
        "id": 148868785,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543592290
    },
    {
        "content": "<p>also, remember that these are simply checks on functions - if someone has a complex enough function that it's impossible to model the provenance of integer values (noting that the provenance of integer values is usually nil), I don't really mind that they don't get UB checking</p>",
        "id": 148868926,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543592431
    },
    {
        "content": "<p>if you have an integer value that has provenance for more than 20 objects, what are you doing with your life</p>",
        "id": 148869139,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543592647
    },
    {
        "content": "<p>probably hashing a vector of raw pointers</p>",
        "id": 148869836,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543593298
    },
    {
        "content": "<p>I mean, here provenance can \"leak\" through booleans</p>",
        "id": 148876529,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543599936
    },
    {
        "content": "<p>and other small integers</p>",
        "id": 148876535,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543599946
    },
    {
        "content": "<p>I mean yeah.</p>",
        "id": 148876543,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543599962
    },
    {
        "content": "<p>so you could mix a \"real\" raw pointer with a lots of \"booleans\"</p>",
        "id": 148876589,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543599975
    },
    {
        "content": "<p>and have a value with 30 provenances, only one of them matters</p>",
        "id": 148876596,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543599986
    },
    {
        "content": "<p>yeah</p>",
        "id": 148876609,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543599995
    },
    {
        "content": "<p>if the problem is automated verifications, maybe have annotations for that?</p>",
        "id": 148876624,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600019
    },
    {
        "content": "<p>intrinsics::fix_provenance(ptr, orig)</p>",
        "id": 148876636,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600030
    },
    {
        "content": "<p>which prevents <code>ptr</code> from gaining provenances beyond <code>orig</code>?</p>",
        "id": 148876644,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600043
    },
    {
        "content": "<p>(and checks that <code>ptr</code> has <code>orig</code> as a provenance)</p>",
        "id": 148876656,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600057
    },
    {
        "content": "<p>and have the verifier otherwise complain if you dereference a raw pointer with too many provenances</p>",
        "id": 148876723,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600086
    },
    {
        "content": "<p>the intrinsic doesn't even need to have language semantics, just verifier semantics</p>",
        "id": 148876826,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600216
    },
    {
        "content": "<p>otoh, this has the problem of preventing a \"mindless\" verification</p>",
        "id": 148876952,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600371
    },
    {
        "content": "<p>you couldn't run MIRI on an unmodified program that makes a mess with ints &amp; ptrs</p>",
        "id": 148876968,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600390
    },
    {
        "content": "<p>otoh, twin allocation is SO MUCH worse when it comes to soundness</p>",
        "id": 148877055,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600479
    },
    {
        "content": "<p>*when it comes to having a easy-to-compute, mindless way of determining whether a program execution is defined</p>",
        "id": 148877273,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600696
    },
    {
        "content": "<p>I mean, even if we define it so that disassembling a pointer into bits and reassembling it doesn't give you a usable pointer</p>",
        "id": 148877428,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600859
    },
    {
        "content": "<p>I don't think anyone would care</p>",
        "id": 148877430,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600863
    },
    {
        "content": "<p>actually, I'm not that sure about ^</p>",
        "id": 148877460,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600906
    },
    {
        "content": "<p>So I think the problem that would result here is that SOMEONE will deflate and inflate their RAM, and then complain that that breaks the verifier</p>",
        "id": 148877531,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543600959
    },
    {
        "content": "<p>to which I'll answer \"if you do these crazy things, please do <code>broadcast</code> on the RAM that you deflate and inflate and then everyone will be happy\"</p>",
        "id": 148877567,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601018
    },
    {
        "content": "<p>OTOH, \"deflating an inflating RAM\" is a good way provenance can be really \"lost\", if you don't broadcast</p>",
        "id": 148877834,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601300
    },
    {
        "content": "<p>(because it might all use array indexes in the middle, which destroy provenance)</p>",
        "id": 148877850,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601317
    },
    {
        "content": "<p>and the compiler might even theoretically notice <em>that</em></p>",
        "id": 148877915,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601399
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> how bad do you think is forcing anyone who does these kinds of mixing-up to do a broadcast on all the bytes?</p>",
        "id": 148877997,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601461
    },
    {
        "content": "<p>OTOH, I believe that the \"deflating RAM\" might do their sins with <em>references</em>, and not <em>raw pointers</em></p>",
        "id": 148878078,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601529
    },
    {
        "content": "<p>in which case that'll be UB even with Stacked Borrows</p>",
        "id": 148878085,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601543
    },
    {
        "content": "<p>take a bunch of RAM, deflate it, write that over a socket, read on the other end, unpack it</p>",
        "id": 148878137,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601619
    },
    {
        "content": "<p>inflate it back, use it</p>",
        "id": 148878142,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543601624
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126804\">@Ariel Ben-Yehuda</span> I doubt it's that big of a deal, for most things.</p>",
        "id": 148884893,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543607790
    },
    {
        "content": "<p>although on the other hand, broadcast semantics also make sense</p>",
        "id": 148885357,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543608235
    },
    {
        "content": "<p>we'd just need to make sure LLVM wasn't miscompiling us</p>",
        "id": 148885403,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543608245
    },
    {
        "content": "<p>users also want to at least informally reason about their code</p>",
        "id": 148885427,
        "sender_full_name": "RalfJ",
        "timestamp": 1543608276
    },
    {
        "content": "<p>the closer we can make the real model to what they are going to assume anyway, the better</p>",
        "id": 148885438,
        "sender_full_name": "RalfJ",
        "timestamp": 1543608287
    },
    {
        "content": "<p>every diversion from that should be very well-justified. I dont think integer provenance is even remotely justified enough, <em>in particular</em> if not even LLVM has it.</p>",
        "id": 148885465,
        "sender_full_name": "RalfJ",
        "timestamp": 1543608335
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"kr\">restrict</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"kr\">restrict</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n  <span class=\"kt\">intptr_t</span> <span class=\"n\">x_addr</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">intptr_t</span><span class=\"p\">)</span><span class=\"n\">x</span><span class=\"p\">;</span>\n  <span class=\"kt\">intptr_t</span> <span class=\"n\">y_addr</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">intptr_t</span><span class=\"p\">)</span><span class=\"n\">y</span><span class=\"p\">;</span>\n\n  <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">x_addr</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">y_addr</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>converting this to</p>\n<div class=\"codehilite\"><pre><span></span><span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"kr\">restrict</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"kr\">restrict</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"o\">*</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre></div>\n\n\n<p>I believe requires integer provenance.</p>",
        "id": 148885692,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543608581
    },
    {
        "content": "<p>it does. which is why I think this transformation should not be allowed.</p>",
        "id": 148885918,
        "sender_full_name": "RalfJ",
        "timestamp": 1543608789
    },
    {
        "content": "<blockquote>\n<p>users also want to at least informally reason about their code</p>\n</blockquote>\n<p>I think that users informally reason about integer provenance</p>",
        "id": 148886001,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543608847
    },
    {
        "content": "<p>pretty well</p>",
        "id": 148886016,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543608868
    },
    {
        "content": "<p>and the main problem with it is that it annoys optimizer &amp; verification tool writers</p>",
        "id": 148886047,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543608901
    },
    {
        "content": "<p>(or at least, I don't expect users to distinguish much between integer provenance, raw pointer provenance, and reference provenance)</p>",
        "id": 148886098,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543608952
    },
    {
        "content": "<p>I agree</p>",
        "id": 148886166,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543608981
    },
    {
        "content": "<p>the only case where there might be confusion is the \"deflating &amp; inflating RAM\" case</p>",
        "id": 148886176,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543608990
    },
    {
        "content": "<p>Also, if you want these semantics to be true for Rust, you'll need to fix LLVM <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span></p>",
        "id": 148886192,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609011
    },
    {
        "content": "<p>see <a href=\"https://gcc.godbolt.org/z/2rwaFe\" target=\"_blank\" title=\"https://gcc.godbolt.org/z/2rwaFe\">https://gcc.godbolt.org/z/2rwaFe</a></p>",
        "id": 148886212,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609025
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> we'll need to fix LLVM anyway: <a href=\"https://bugs.llvm.org/show_bug.cgi?id=39846\" target=\"_blank\" title=\"https://bugs.llvm.org/show_bug.cgi?id=39846\">https://bugs.llvm.org/show_bug.cgi?id=39846</a></p>",
        "id": 148886222,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609038
    },
    {
        "content": "<p>sure</p>",
        "id": 148886249,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609059
    },
    {
        "content": "<p>right now, given that LLVM is not self-consistent, I do not think it is a useful basis for discussion</p>",
        "id": 148886251,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609059
    },
    {
        "content": "<p>but there are different levels of \"fixing\"</p>",
        "id": 148886267,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609074
    },
    {
        "content": "<p>and I think that adding annotations to RAM inflate/deflate is not such a high cost</p>",
        "id": 148886314,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609085
    },
    {
        "content": "<p>and I very much doubt that LLVM would be willing to give up optimizations like this</p>",
        "id": 148886325,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609097
    },
    {
        "content": "<p>well, LLVM does GVN on integer equality. and it is my understanding that they strongly desire to keep it.</p>",
        "id": 148886326,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609098
    },
    {
        "content": "<p>so when LLVM is self-consistent, I assume it'll still do this GVN and we have a model that can do noalias without integer provenance. or maybe it will have integer provenance and give up on GVN, and that may persuade me to do the same.<br>\nEDIT: or maybe we'll have found a way to have both, that'd be even better!</p>",
        "id": 148886372,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609163
    },
    {
        "content": "<blockquote>\n<blockquote>\n<p>users also want to at least informally reason about their code</p>\n</blockquote>\n<p>I think that users informally reason about integer provenance</p>\n</blockquote>\n<p>my experience is that users are already surprised by pointers not being \"just integers\" and having some kind of provenance. if not even integers are \"just (mathematical) integers\", I think this will get worse.</p>",
        "id": 148886459,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609226
    },
    {
        "content": "<p>it is very unnatural to write code that can observe that integers are not \"just (mathematical) integers\"</p>",
        "id": 148886503,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609291
    },
    {
        "content": "<p>pretty much any code casting between ints and ptrs would be such code</p>",
        "id": 148886560,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609323
    },
    {
        "content": "<p>I was originally worried that e.g. crypto code would be affected, but likely provenance would not affect integer arithmetic so one can work on equivalence classes of values quotiented by \"the integer part is the same\"</p>",
        "id": 148886603,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609381
    },
    {
        "content": "<p>that would require one thing though: integer comparison is deterministic and ignores provenance</p>",
        "id": 148886627,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609409
    },
    {
        "content": "<p>(this is not the case for ptr comparison)</p>",
        "id": 148886639,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609415
    },
    {
        "content": "<blockquote>\n<p>that would require one thing though: integer comparison is deterministic and ignores provenance</p>\n</blockquote>\n<p>Sounds like a good idea. I personally prefer to also define ptr comparison as integer comparison.</p>",
        "id": 148886706,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609456
    },
    {
        "content": "<p>have fun convincing LLVM of that :P</p>",
        "id": 148886713,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609472
    },
    {
        "content": "<p>we can do it in Rust :-)</p>",
        "id": 148886720,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609483
    },
    {
        "content": "<p>by emitting ptrtoint</p>",
        "id": 148886723,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609487
    },
    {
        "content": "<p>C actually says that in the standard, and LLVM still doesn't care</p>",
        "id": 148886731,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609490
    },
    {
        "content": "<p>true, we can. it'd make me sleep better. but I think some people wouldn't like it as it'll likely cost some perf...</p>",
        "id": 148886747,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609508
    },
    {
        "content": "<p>we wouldn't want to do it if ptrtoint has broadcast semantics</p>",
        "id": 148886753,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609514
    },
    {
        "content": "<p>yeah and that</p>",
        "id": 148886828,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609565
    },
    {
        "content": "<p>one thing to note: the C standard gives integers provenance</p>",
        "id": 148886829,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609566
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> source? I've not seen that</p>",
        "id": 148886839,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609584
    },
    {
        "content": "<p>the C17 standard, page 89, 6.7.3.1.3</p>",
        "id": 148886852,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609611
    },
    {
        "content": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf\" target=\"_blank\" title=\"http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf\">http://www.open-std.org/jtc1/sc22/wg14/www/abq/c17_updated_proposed_fdis.pdf</a></p>",
        "id": 148886855,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609617
    },
    {
        "content": "<p>(technically it's the draft standard but <span class=\"emoji emoji-1f937\" title=\"shrug\">:shrug:</span>)</p>",
        "id": 148886869,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609628
    },
    {
        "content": "<p>I keep looking for a good HTML version of the standard...</p>",
        "id": 148886872,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609634
    },
    {
        "content": "<p>actually, for iterators to work, pointer comparison between pointers with the same provenance must not be a broadcast</p>",
        "id": 148886944,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609684
    },
    {
        "content": "<p>In what follows, a pointer expression <code>E</code> is said to be based on object <code>P</code> if (at some sequence point in the execution of <code>B</code> [the block which <code>P</code> is declared to be for] prior to the evaluation of <code>E</code>) modifying <code>P</code> to point to a copy of the array object into which it formerly pointed would change the value of <code>E</code>. Note that “based” is defined only for expressions with pointer types.</p>",
        "id": 148886982,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609734
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> oh, that sentence. yeah it's also in older standards. it's about pointers though, and their definition is basically information flow control which is... not even a trace-based property.</p>",
        "id": 148886984,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609737
    },
    {
        "content": "<p>like, that mandates that <code>x - x</code> kills all provenance</p>",
        "id": 148887002,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609764
    },
    {
        "content": "<p>true</p>",
        "id": 148887013,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609780
    },
    {
        "content": "<p>It is not in general even <em>defined</em> when looking only at a single trace</p>",
        "id": 148887014,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609781
    },
    {
        "content": "<p>(aka, it's a hyperproperty)</p>",
        "id": 148887020,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609787
    },
    {
        "content": "<p>I think broadcast semantics are likely the only reasonable semantics, looking at it</p>",
        "id": 148887079,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609814
    },
    {
        "content": "<p>although we'd need a way to tell LLVM \"broadcast this pointer value\"</p>",
        "id": 148887085,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609826
    },
    {
        "content": "<p>so, that's not just giving integers provenance. that's killing trace-based reasoning. I don't intend to abandon trace-based reasoning for Rust^^</p>",
        "id": 148887090,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609834
    },
    {
        "content": "<p>broadcast @ ptr-&gt;int cast?</p>",
        "id": 148887100,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609847
    },
    {
        "content": "<p>because we don't in general want ptrtoint to broadcast</p>",
        "id": 148887102,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609854
    },
    {
        "content": "<p>@ Rust ptr-&gt;int cast ?</p>",
        "id": 148887113,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609870
    },
    {
        "content": "<p>yeah its very useful to keep ptrtoint side-effect free. reorderdable, can be DCO'd, and so on</p>",
        "id": 148887129,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609893
    },
    {
        "content": "<p>the issue I see is with function calls</p>",
        "id": 148887132,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609894
    },
    {
        "content": "<blockquote>\n<p>yeah its very useful to keep ptrtoint side-effect free. reorderdable, can be DCO'd, and so on</p>\n</blockquote>\n<p>is it?</p>",
        "id": 148887142,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609911
    },
    {
        "content": "<p>did you measure/know why?</p>",
        "id": 148887190,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609926
    },
    {
        "content": "<p>I dont think I have numbers, no</p>",
        "id": 148887192,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609935
    },
    {
        "content": "<p>but if ptrtoint broadcasts, LLVM has to stop reordering it freely and treat it specially</p>",
        "id": 148887202,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609948
    },
    {
        "content": "<p>that seems hard</p>",
        "id": 148887205,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609949
    },
    {
        "content": "<p>i.e., <code>&lt;&amp;T as Pointer&gt;::fmt(&amp;p)</code> should broadcast, but <code>&lt;i32 as Display&gt;::fmt(p)</code> should not</p>",
        "id": 148887211,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609959
    },
    {
        "content": "<p>or we could emit an intrinsic instead</p>",
        "id": 148887212,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609959
    },
    {
        "content": "<p>and there is no good reason to marry the type-conversion and the side-effecting broadcast into one operation</p>",
        "id": 148887217,
        "sender_full_name": "RalfJ",
        "timestamp": 1543609965
    },
    {
        "content": "<p>I suspect that even emitting a call to an external function won't kill performance</p>",
        "id": 148887220,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543609973
    },
    {
        "content": "<p>but it does mean that every unknown call that accepts an <code>&amp;T</code> now broadcasts</p>",
        "id": 148887227,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543609982
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> yeah taht's exactly the <code>mem::replace</code> problem</p>",
        "id": 148887243,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610001
    },
    {
        "content": "<p>(it might be useful to have a <code>nobroadcast</code> type for parameters)</p>",
        "id": 148887246,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610004
    },
    {
        "content": "<p>\"it uses raw ptr internally so it broadcasted\"</p>",
        "id": 148887247,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610008
    },
    {
        "content": "<p>now we may avoid this with raw</p>",
        "id": 148887252,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610017
    },
    {
        "content": "<p>but with int...</p>",
        "id": 148887254,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610021
    },
    {
        "content": "<p>and then if a function casts a pointer to an int, it has broadcasted</p>",
        "id": 148887264,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610038
    },
    {
        "content": "<p>(we'll be able to eliminate most of these, I think, in MIR)</p>",
        "id": 148887308,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610050
    },
    {
        "content": "<p>shame that that's a safe operation</p>",
        "id": 148887309,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610052
    },
    {
        "content": "<p>casting a pointer to an int needs to be a safe op</p>",
        "id": 148887315,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610069
    },
    {
        "content": "<p>because <code>HashMap&lt;*const (), VAL&gt;</code></p>",
        "id": 148887318,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610078
    },
    {
        "content": "<p>must exist</p>",
        "id": 148887321,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610085
    },
    {
        "content": "<p>is that so common?</p>",
        "id": 148887323,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610093
    },
    {
        "content": "<p>yea</p>",
        "id": 148887335,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610104
    },
    {
        "content": "<p>that HashMap is probably not even correct in C++. at least not if you compare ptrs at ptr type</p>",
        "id": 148887351,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610134
    },
    {
        "content": "<p>because ptrs with the same address but different provenance may compare inequal</p>",
        "id": 148887354,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610144
    },
    {
        "content": "<p>hashing pointers converts them to integers IIRC</p>",
        "id": 148887356,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610157
    },
    {
        "content": "<p>that seems like it should be invalid?</p>",
        "id": 148887404,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610166
    },
    {
        "content": "<p>it does</p>",
        "id": 148887406,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610170
    },
    {
        "content": "<p>right but HashMaps also do <code>==</code> on the keys because collisions</p>",
        "id": 148887407,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610171
    },
    {
        "content": "<p>why would you be comparing == pointers with different provenances?</p>",
        "id": 148887431,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610195
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> there's no good HTML C standard; do you have the C++ standard?</p>",
        "id": 148887433,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610204
    },
    {
        "content": "<p>HashMap already deals with erratic PartialEq, from a safety perspective</p>",
        "id": 148887436,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610209
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> I got <a href=\"https://timsong-cpp.github.io/cppwp/n4140/\" target=\"_blank\" title=\"https://timsong-cpp.github.io/cppwp/n4140/\">https://timsong-cpp.github.io/cppwp/n4140/</a></p>",
        "id": 148887449,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610223
    },
    {
        "content": "<p>ah, that one also works, yeah</p>",
        "id": 148887460,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610239
    },
    {
        "content": "<blockquote>\n<p>HashMap already deals with erratic PartialEq, from a safety perspective</p>\n</blockquote>\n<p>true but then it violates its functional properties</p>",
        "id": 148887461,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610242
    },
    {
        "content": "<p>so the consequence is that you might get \"safe erratic\" behavior if you leave GCed keys in your hashmap</p>",
        "id": 148887467,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610249
    },
    {
        "content": "<p>the C standard people are more friendly to ISO rules about \"not publishing their work online\"</p>",
        "id": 148887471,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610258
    },
    {
        "content": "<p>I'm not sure that users intentionally do that</p>",
        "id": 148887472,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610259
    },
    {
        "content": "<blockquote>\n<p>ah, that one also works, yeah</p>\n</blockquote>\n<p>you know another (better?) HTML version?</p>",
        "id": 148887474,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610260
    },
    {
        "content": "<p>no, they run the same code; <a href=\"http://eel.is/c++draft\" target=\"_blank\" title=\"http://eel.is/c++draft\">eel.is/c++draft</a> is what we commonly use</p>",
        "id": 148887488,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610278
    },
    {
        "content": "<blockquote>\n<p>the C standard people are more friendly to ISO rules about \"not publishing their work online\"</p>\n</blockquote>\n<p>I'd frame that as \"less friendly to the public\"^^</p>",
        "id": 148887489,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610279
    },
    {
        "content": "<p>not inaccurate</p>",
        "id": 148887541,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610293
    },
    {
        "content": "<p>side note, if we do get to the point where we release a standard, we should go with ECMA</p>",
        "id": 148887558,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610312
    },
    {
        "content": "<blockquote>\n<p>no, they run the same code; <a href=\"http://eel.is/c++draft\" target=\"_blank\" title=\"http://eel.is/c++draft\">eel.is/c++draft</a> is what we commonly use</p>\n</blockquote>\n<p>who is  \"we\" here? (just curious)</p>",
        "id": 148887576,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610335
    },
    {
        "content": "<blockquote>\n<p>side note, if we do get to the point where we release a standard, we should go with ECMA</p>\n</blockquote>\n<p>my entirely uninformed opinion is to go with IETF. but whatever^^</p>",
        "id": 148887619,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610378
    },
    {
        "content": "<p>\"people who work on C++\"</p>",
        "id": 148887697,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610434
    },
    {
        "content": "<p>the IETF is not a standards organization, afaict</p>",
        "id": 148887712,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610450
    },
    {
        "content": "<p>well IETF does TCP/IP and similar. if these are not standards I dont know what is^^</p>",
        "id": 148887727,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610467
    },
    {
        "content": "<p>ECMA is a standards organization that encourages open standards, and has experience with languages</p>",
        "id": 148887739,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610487
    },
    {
        "content": "<p>I don't care about whether governments consider these standards. practically speaking, IETF does standards. but yeah I dont think they do programming languages^^</p>",
        "id": 148887758,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610508
    },
    {
        "content": "<p>it's where C++ would move if the politics were to work out</p>",
        "id": 148887808,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610535
    },
    {
        "content": "<p>^^</p>",
        "id": 148887819,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610545
    },
    {
        "content": "<p>ECMA currently does Javascript, C#, Eiffel, and the CLI (C# backend)</p>",
        "id": 148887939,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610669
    },
    {
        "content": "<p>wow I had no idea they do C#</p>",
        "id": 148887955,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610685
    },
    {
        "content": "<p>also apparently Dart</p>",
        "id": 148887960,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543610691
    },
    {
        "content": "<p><code>HashMap&lt;*const (), T&gt;</code> at least has the semantics where<br>\n1. If you don't leave invalid elements in it, it acts as desired<br>\n2. If you <em>do</em> leave invalid elements in it, it doesn't UB but can have erratic semantics</p>",
        "id": 148887968,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610701
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"126804\">@Ariel Ben-Yehuda</span> that is the intention, yes. unfortunately I dont know how to give a proper account to ptr equality that is deterministic, and LLVM assumes it to be deterministic.</p>",
        "id": 148888008,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610753
    },
    {
        "content": "<p>(non-determinism would break <code>HashMap</code> but breaks some LLVM optimizations)</p>",
        "id": 148888051,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610764
    },
    {
        "content": "<blockquote>\n<p>(non-determinism would break <code>HashMap</code> but breaks some LLVM optimizations)</p>\n</blockquote>\n<p>If it is not \"undef\" non-determinism, then it is no worse than any other erratic PartialEq impl</p>",
        "id": 148888078,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610799
    },
    {
        "content": "<p><code>BTreeMap&lt;*const (), T&gt;</code> is a totally different story... I am pretty sure that's UB in C/C++ and have no idea how to make it work in LLVM^^</p>",
        "id": 148888083,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610805
    },
    {
        "content": "<p>you might get random panics, or not find your elements, but you won't get UB</p>",
        "id": 148888088,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610815
    },
    {
        "content": "<blockquote>\n<p>If it is not \"undef\" non-determinism, then it is no worse than any other erratic PartialEq impl</p>\n</blockquote>\n<p>agreed.</p>",
        "id": 148888096,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610825
    },
    {
        "content": "<p>and if LLVM just returns undef, then that's <em>prima facia</em> unsafety.</p>",
        "id": 148888104,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610843
    },
    {
        "content": "<p>yeah if LLVM can make ptr comparison undef then we are in trouble^^</p>",
        "id": 148888120,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610859
    },
    {
        "content": "<p>I dont think they want to, though</p>",
        "id": 148888127,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610874
    },
    {
        "content": "<p>And doesn't <code>BTreeMap&lt;*const (), T&gt;</code> have the same semantics in Rust?</p>",
        "id": 148888209,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610922
    },
    {
        "content": "<p>it uses <code>&lt;</code> in pointers</p>",
        "id": 148888218,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610930
    },
    {
        "content": "<p>yea</p>",
        "id": 148888222,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610934
    },
    {
        "content": "<p>which should <em>work</em> when they are valid</p>",
        "id": 148888227,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610939
    },
    {
        "content": "<p>that's... uh. we make it UB/undef in our paper because we dont know how else to make the optimizations work^^</p>",
        "id": 148888240,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610951
    },
    {
        "content": "<p>and return an nondeterministic-but-not-<em>poison</em> value when they are not</p>",
        "id": 148888245,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610955
    },
    {
        "content": "<p>but TBH I dont think we spent much time on inequalities</p>",
        "id": 148888265,
        "sender_full_name": "RalfJ",
        "timestamp": 1543610970
    },
    {
        "content": "<p>same comment about returning UB/undef being <em>prima facia</em> unsafety</p>",
        "id": 148888271,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543610976
    },
    {
        "content": "<p>yes if it returns undef then it would be wrong to make it safe in Rust</p>",
        "id": 148888354,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611019
    },
    {
        "content": "<p>I <em>think</em> replacing all undef by \"non-deterministic but valid boolean\" wouldn't break anything in our model but I might well be wrong. I should probably ask.</p>",
        "id": 148888422,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611093
    },
    {
        "content": "<p>oh actually I misremembered. it is non-deterministic in our model, not undef or even UB</p>",
        "id": 148888511,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611169
    },
    {
        "content": "<p>so, good enough for erratic but safe <code>BTreeMap</code></p>",
        "id": 148888515,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611175
    },
    {
        "content": "<p>but not very satisfying</p>",
        "id": 148888518,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611179
    },
    {
        "content": "<p>so I think we concluded that the MIR translation to LLVM should use broadcast, probably on ptr-&gt;int casts</p>",
        "id": 148888529,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611188
    },
    {
        "content": "<p>and we are not sure whether MIR itself should be defined as broadcast or provenance-based tracking</p>",
        "id": 148888541,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611208
    },
    {
        "content": "<p>and that calling an <em>unknown</em> function is a broadcast because <code>as_ptr</code> exists</p>",
        "id": 148888554,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611233
    },
    {
        "content": "<p>that seems to be the rough idea currently</p>",
        "id": 148888558,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611238
    },
    {
        "content": "<p>I still dont know exactly what broadcast means for noalias</p>",
        "id": 148888596,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611245
    },
    {
        "content": "<p>it seems that unknown functions broadcasting might be a big problem for noalias? (on the LLVM side)</p>",
        "id": 148888609,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611268
    },
    {
        "content": "<p>depends on how much unknown functions you have</p>",
        "id": 148888628,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611288
    },
    {
        "content": "<p>and on how well LLVM can infer <code>nocapture</code></p>",
        "id": 148888642,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611305
    },
    {
        "content": "<p>and <code>nobroadcast</code> I guess^^</p>",
        "id": 148888650,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611316
    },
    {
        "content": "<p>it might also be useful to have a way to \"scope\" broadcast</p>",
        "id": 148888653,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611325
    },
    {
        "content": "<p><code>nocapture</code> implies <code>nobroadcast</code></p>",
        "id": 148888663,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611334
    },
    {
        "content": "<p>no idea what that means though^^</p>",
        "id": 148888664,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611335
    },
    {
        "content": "<p>sort of</p>",
        "id": 148888678,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611350
    },
    {
        "content": "<p><code>broadcast</code> is already scoped</p>",
        "id": 148888686,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611361
    },
    {
        "content": "<p>once you pop it off the stack, it is gone</p>",
        "id": 148888726,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611369
    },
    {
        "content": "<p>oh I wasn't aware there's still a stack. LLVM doesn't have the stacks, or do you think it does?</p>",
        "id": 148888740,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611390
    },
    {
        "content": "<p>I mean, from a Rust POV there's still the stack thing</p>",
        "id": 148888768,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611422
    },
    {
        "content": "<p>or the \"cactus stack\"</p>",
        "id": 148888777,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611427
    },
    {
        "content": "<p>true</p>",
        "id": 148888780,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611429
    },
    {
        "content": "<p>lol^^</p>",
        "id": 148888785,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611430
    },
    {
        "content": "<p>which still has the same pop-when-you-write</p>",
        "id": 148888787,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611432
    },
    {
        "content": "<p>(even reads may pop)</p>",
        "id": 148888789,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611441
    },
    {
        "content": "<p>yea, pop-when-you-access</p>",
        "id": 148888797,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611454
    },
    {
        "content": "<p>ack</p>",
        "id": 148888799,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611457
    },
    {
        "content": "<p>I'm not sure whether LLVM has pop-when-you-access ATM</p>",
        "id": 148888813,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611475
    },
    {
        "content": "<p>that could be something worth adding</p>",
        "id": 148888836,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611482
    },
    {
        "content": "<p>true, braodcast is scoped in MIR by popping currently. but there is no way for a function to say \"I am not like as_ptr\", as in, \"I may broadcast internally but not beyond this call\"</p>",
        "id": 148888869,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611500
    },
    {
        "content": "<p>something like \"auto-pop the stack <em>after</em> this function to be like it was right before\"</p>",
        "id": 148888881,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611513
    },
    {
        "content": "<p>so one idea I had was to do auto-pops when you are in a function that doesn't contain an unsafe block</p>",
        "id": 148888892,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611534
    },
    {
        "content": "<p><code>mem::replace</code> would want that</p>",
        "id": 148888896,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611540
    },
    {
        "content": "<p>*to do them at the callee</p>",
        "id": 148888903,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611545
    },
    {
        "content": "<p>uuhh</p>",
        "id": 148888905,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611548
    },
    {
        "content": "<p>I... dont think I like that</p>",
        "id": 148888907,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611554
    },
    {
        "content": "<p><code>mem::replace</code> is <em>not</em> an unknown function</p>",
        "id": 148888909,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611559
    },
    {
        "content": "<p>LLVM will very quickly discover that it is <code>nocapture nobroadcast</code></p>",
        "id": 148888919,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611571
    },
    {
        "content": "<p>unless it does a broadcast by accident</p>",
        "id": 148888935,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611598
    },
    {
        "content": "<p>that's not enough on the MIR side though. it pushes a <code>Shr</code> and doesnt pop it</p>",
        "id": 148888938,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611602
    },
    {
        "content": "<p>so after calling it you are allowed to use raw ptrs to access</p>",
        "id": 148888999,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611614
    },
    {
        "content": "<p>well okay we said only for ints, but that's easily adapted</p>",
        "id": 148889014,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611632
    },
    {
        "content": "<blockquote>\n<p>that's not enough on the MIR side though. it pushes a <code>Shr</code> and doesnt pop it</p>\n</blockquote>\n<p>umm that's why I wanted provenance for raw pointers</p>",
        "id": 148889020,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611635
    },
    {
        "content": "<p>imagine <code>mem::replace</code> would go through <code>usize</code></p>",
        "id": 148889026,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611642
    },
    {
        "content": "<p>yea, in that case it would be bad</p>",
        "id": 148889037,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611654
    },
    {
        "content": "<p>or something with tagged pointers</p>",
        "id": 148889040,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611657
    },
    {
        "content": "<p>or so</p>",
        "id": 148889042,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611658
    },
    {
        "content": "<p>I feel that's a bogeyman</p>",
        "id": 148889060,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611674
    },
    {
        "content": "<p>(the problems are the same no matter whether you make raw ptrs broadcast or just integers broadcast, so for now I made raw ptrs broadcast in Stacked Borrows for easier experimentation)</p>",
        "id": 148889063,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611685
    },
    {
        "content": "<p>we could add intrinsics for tags that don't broadcast</p>",
        "id": 148889128,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611740
    },
    {
        "content": "<p>if tags are improtant</p>",
        "id": 148889130,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611745
    },
    {
        "content": "<p>true</p>",
        "id": 148889132,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611749
    },
    {
        "content": "<p>and I expect more complicated uses to only occur in cases that are \"definitely broadcast\"</p>",
        "id": 148889141,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611766
    },
    {
        "content": "<p>*when the pointer is already \"definitely broadcast\"</p>",
        "id": 148889147,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611773
    },
    {
        "content": "<p>same as having an intrinsic for cast-to-int-then-icmp that doesnt broadcast. which we'd likely want for rust's ptr comparisons to make them definitely deterministic.</p>",
        "id": 148889148,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611774
    },
    {
        "content": "<p>@RalfJ I prefer the latter intrinsic to be PartialOrd::le</p>",
        "id": 148889163,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543611803
    },
    {
        "content": "<p>seems we just have to convince LLVM to have such broadcasts then. should be easy. :P</p>",
        "id": 148889355,
        "sender_full_name": "RalfJ",
        "timestamp": 1543611997
    },
    {
        "content": "<p>And work items:<br>\n1. investigate &amp; measure the perf impact of making ptrtoint side-effectful<br>\n2. investigate &amp; measure the perf impact of using deterministic pointer comparisons<br>\n3. figure out how to add broadcast to LLVM</p>",
        "id": 148889358,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543612002
    },
    {
        "content": "<p>some of this measuring will be hard because LLVM doesn't currently implement a consistent semantics</p>",
        "id": 148889380,
        "sender_full_name": "RalfJ",
        "timestamp": 1543612047
    },
    {
        "content": "<p><em>in particular</em> around ptrtoint/inttoptr</p>",
        "id": 148889385,
        "sender_full_name": "RalfJ",
        "timestamp": 1543612059
    },
    {
        "content": "<p>\"4\". figure out whether we want provenance-based or broadcast-based semantics for MIR, but that feels like too much of a bikeshed right now (keywords: deflate-and-inflate RAM, easiness for checking)</p>",
        "id": 148889389,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543612063
    },
    {
        "content": "<p>@RalfJ that's why it's \"investigate &amp; measure\"</p>",
        "id": 148889444,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543612085
    },
    {
        "content": "<p>;)</p>",
        "id": 148889450,
        "sender_full_name": "RalfJ",
        "timestamp": 1543612090
    },
    {
        "content": "<p>also 3a. or so, \"investigate how to integrate raw ptr provenance with Stacked Borrows\"</p>",
        "id": 148889467,
        "sender_full_name": "RalfJ",
        "timestamp": 1543612118
    },
    {
        "content": "<p>sure, cool</p>",
        "id": 148889510,
        "sender_full_name": "Ariel Ben-Yehuda",
        "timestamp": 1543612187
    },
    {
        "content": "<p>it's not entirely trivial, the naive thing doesnt work... I forgot why though. I should find out and describe it to y'all^^</p>",
        "id": 148889743,
        "sender_full_name": "RalfJ",
        "timestamp": 1543612358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> C++ has those same semantics for &lt; (unspecified, nondeterministic, but not UB)</p>",
        "id": 148892036,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543614643
    },
    {
        "content": "<p>and it uses <code>std::less</code> to compare pointers for <code>std::map</code>, which creates a total ordering</p>",
        "id": 148892053,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543614680
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125253\">@Nicole Mazzuca</span> IIRC C++ allows an \"indeterminate\" result at least for <code>==</code>, which would be undef in LLVM? Or has that changed on more recent versions?</p>",
        "id": 148892899,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615591
    },
    {
        "content": "<p>yeah, I believe it changed in C++14?</p>",
        "id": 148892924,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615618
    },
    {
        "content": "<p>it's now \"unspecified\"</p>",
        "id": 148892960,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615682
    },
    {
        "content": "<p>hm... <a href=\"http://eel.is/c++draft/expr.eq#3.1\" target=\"_blank\" title=\"http://eel.is/c++draft/expr.eq#3.1\">http://eel.is/c++draft/expr.eq#3.1</a> says the result may be \"unspecified\"</p>",
        "id": 148892998,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615684
    },
    {
        "content": "<p>I have no idea what that means</p>",
        "id": 148893002,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615689
    },
    {
        "content": "<p>lemme look and check for sure what that means</p>",
        "id": 148893006,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615692
    },
    {
        "content": "<p><a href=\"http://eel.is/c++draft/defns.unspecified#:behavior,unspecified\" target=\"_blank\" title=\"http://eel.is/c++draft/defns.unspecified#:behavior,unspecified\">http://eel.is/c++draft/defns.unspecified#:behavior,unspecified</a></p>\n<blockquote>\n<p>behavior, for a well-formed program construct and correct data, that depends on the implementation<br>\n[ Note: The implementation is not required to document which behavior occurs.</p>\n</blockquote>",
        "id": 148893029,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615741
    },
    {
        "content": "<p>now I am left wondering if the compiler may choose to make the result \"indeterminate\"</p>",
        "id": 148893056,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615776
    },
    {
        "content": "<p>I don't believe so</p>",
        "id": 148893061,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615783
    },
    {
        "content": "<p>but it also doesnt say the result may be non-deterministic</p>",
        "id": 148893070,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615794
    },
    {
        "content": "<p>as in, does comparing the same two pointers twice have to produce the same result?</p>",
        "id": 148893125,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615809
    },
    {
        "content": "<blockquote>\n<p>The range of possible behaviors is usually delineated by this document.</p>\n</blockquote>\n<p>well, not in this case :/</p>",
        "id": 148893132,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615824
    },
    {
        "content": "<p>I believe it's something like \"<code>a &lt; b</code>\" must produce either true or false for any specific expression</p>",
        "id": 148893156,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615872
    },
    {
        "content": "<p>but does <code>(a &lt; b) == (a &lt; b)</code> always have to produce true?</p>",
        "id": 148893172,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615894
    },
    {
        "content": "<p>it doesnt <em>allow</em> non-determinism</p>",
        "id": 148893175,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615901
    },
    {
        "content": "<p>i.e., it's definitely gonna be one or the other, but it doesn't have to be consistent</p>",
        "id": 148893184,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615906
    },
    {
        "content": "<p>it also doesnt <em>forbid</em> an indeterminate value</p>",
        "id": 148893188,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615908
    },
    {
        "content": "<p>so this seems fairly vague to me</p>",
        "id": 148893194,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615912
    },
    {
        "content": "<p>the forbidding of an indeterminate value is implied</p>",
        "id": 148893236,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615925
    },
    {
        "content": "<p>so the comparison is nondeterministic, but each comparison produces exactly one value</p>",
        "id": 148893251,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615952
    },
    {
        "content": "<p>hm that would make sense (that it can't be indeterminate or plain UB), though I'd prefer if it said that in the def.n of \"unspecified\"</p>",
        "id": 148893259,
        "sender_full_name": "RalfJ",
        "timestamp": 1543615970
    },
    {
        "content": "<p>I agree</p>",
        "id": 148893282,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543615996
    },
    {
        "content": "<blockquote>\n<p>so the comparison is nondeterministic, but each comparison produces exactly one value</p>\n</blockquote>\n<p>that seems to be the most liberal interpretation</p>",
        "id": 148893294,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616009
    },
    {
        "content": "<p>and it is in line with what we model for LLVM</p>",
        "id": 148893302,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616015
    },
    {
        "content": "<p>however, LLVM will (AFAIK) duplicate <code>icmp</code>, so it actually expects its own operation to be deterministic</p>",
        "id": 148893320,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616035
    },
    {
        "content": "<p>and I don't know how to model <em>that</em>^^</p>",
        "id": 148893352,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616043
    },
    {
        "content": "<p>yeah</p>",
        "id": 148893362,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616043
    },
    {
        "content": "<p>I doubt it's necessary, tbh</p>",
        "id": 148893378,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616059
    },
    {
        "content": "<p>duplicating?</p>",
        "id": 148893382,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616067
    },
    {
        "content": "<p>no, modeling anything more than nondeterminism</p>",
        "id": 148893399,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616092
    },
    {
        "content": "<p>on the surface language level, maybe</p>",
        "id": 148893412,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616103
    },
    {
        "content": "<p>I'd like to understand LLVM as well though</p>",
        "id": 148893421,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616109
    },
    {
        "content": "<p>faut</p>",
        "id": 148893428,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616114
    },
    {
        "content": "<p>*fair</p>",
        "id": 148893434,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616117
    },
    {
        "content": "<p>well, this has been interesting but it's getting late. see you later everyone!</p>",
        "id": 148893669,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616392
    },
    {
        "content": "<p>o7</p>",
        "id": 148893713,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616403
    },
    {
        "content": "<p>I already wanted to ask yesterday... what does \"o7\" mean?</p>",
        "id": 148893725,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616418
    },
    {
        "content": "<p>or is that \"o/\" plus \"too lazy for shift\"?^^</p>",
        "id": 148893735,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616431
    },
    {
        "content": "<p>(at least on the German keyboard, / is Shift-7)</p>",
        "id": 148893749,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616450
    },
    {
        "content": "<p>nah, it's just a different wave</p>",
        "id": 148893754,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616463
    },
    {
        "content": "<p>okay :D <span class=\"emoji emoji-1f44b\" title=\"wave\">:wave:</span></p>",
        "id": 148893774,
        "sender_full_name": "RalfJ",
        "timestamp": 1543616484
    },
    {
        "content": "<p>also, I think, from the documentation,  icmp on pointers should be exactly a ptrtoint comparison</p>",
        "id": 148893788,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616507
    },
    {
        "content": "<p>If the operands are pointer typed, the pointer values are compared as if they were integers.</p>",
        "id": 148893841,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616527
    },
    {
        "content": "<p>if a pass actually doesn't treat pointers like that, I feel like it should probably be seen as a bug</p>",
        "id": 148893853,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543616556
    },
    {
        "content": "<blockquote>\n<p>also, I think, from the documentation,  icmp on pointers should be exactly a ptrtoint comparison</p>\n</blockquote>\n<p>you mean in LLVM? we certainly have counterexamples for that and I think they are deliberate: LLVM will optimize <code>x == y</code> to <code>false</code> if they come from different <code>malloc</code>, even if (using <code>getelementptr</code>) they might be equal</p>",
        "id": 150675051,
        "sender_full_name": "RalfJ",
        "timestamp": 1543652081
    },
    {
        "content": "<p>even if that's true, that feels like it should be treated as a miscompilation :&lt;</p>",
        "id": 150675313,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543652718
    },
    {
        "content": "<p>at least according to the documentation on <code>icmp</code></p>",
        "id": 150675314,
        "sender_full_name": "Nicole Mazzuca",
        "timestamp": 1543652729
    },
    {
        "content": "<p>You are right, it is pretty explicit about that:</p>\n<blockquote>\n<p>If the operands are pointer typed, the pointer values are compared as if they were integers.</p>\n</blockquote>",
        "id": 150675615,
        "sender_full_name": "RalfJ",
        "timestamp": 1543653426
    },
    {
        "content": "<p>LLVM also works really hard to make sure that icmp is observably deterministic</p>",
        "id": 150675804,
        "sender_full_name": "RalfJ",
        "timestamp": 1543653926
    },
    {
        "content": "<p>but I dont know how to turn that into a formal operational spec, because that would basically require knowing how an allocation is used already when it is created. and a syntactic analysis does not work because LLVM may optimize away uses.</p>",
        "id": 150675844,
        "sender_full_name": "RalfJ",
        "timestamp": 1543653967
    }
]