[
    {
        "content": "<p>from <a href=\"https://github.com/rust-lang/rust/pull/95241#issuecomment-1076769919\">bjorn3</a>:</p>\n<blockquote>\n<blockquote>\n<p>wasm is less weird in that its function pointers are just usize indices (in a table of function pointers), so raw pointers can represent all function addresses even if the resulting pointer isn't itself valid for any memory access.</p>\n</blockquote>\n<p>Actually it seems they are always 32bit indices, even if you use a 64bit memory:</p>\n<p><a href=\"https://github.com/WebAssembly/memory64/blob/main/proposals/memory64/Overview.md\">https://github.com/WebAssembly/memory64/blob/main/proposals/memory64/Overview.md</a></p>\n<blockquote>\n<p>The <a href=\"https://webassembly.github.io/spec/core/syntax/types.html#table-types\">table type</a> continues to use i32 indices</p>\n</blockquote>\n</blockquote>\n<p>re: wasm's table type, it makes sense that its \"function pointers\" continue to be u32 no matter what, because uhh who the f needs more than 4294967296 symbols?</p>",
        "id": 276411301,
        "sender_full_name": "Jubilee",
        "timestamp": 1648075239
    },
    {
        "content": "<p>this really illustrates the need for something for function pointers/Harvard architectures tho'<br>\nhowever wasm kind of is a true \"language model without provenance\", as I understand it.</p>",
        "id": 276411691,
        "sender_full_name": "Jubilee",
        "timestamp": 1648075390
    },
    {
        "content": "<p>wasm itself is a genuine case of my \"a language that is little more than an assembler\"</p>",
        "id": 276411842,
        "sender_full_name": "Gankra",
        "timestamp": 1648075490
    },
    {
        "content": "<p>right.</p>",
        "id": 276411880,
        "sender_full_name": "Jubilee",
        "timestamp": 1648075516
    },
    {
        "content": "<p>at least fn pointer <em>addresses</em> fit in data pointers (even if invalid for data usage) heh</p>",
        "id": 276420819,
        "sender_full_name": "eddyb",
        "timestamp": 1648082257
    },
    {
        "content": "<p>most of the interesting (hardware) Harvard stuff I keep coming across has larger code pointers, because you may need a large program but it always operate with constrained RAM</p>",
        "id": 276420877,
        "sender_full_name": "eddyb",
        "timestamp": 1648082337
    },
    {
        "content": "<p>8051 is really cute with its 16-bit code pointers and 8-bit data pointers :3</p>",
        "id": 276420888,
        "sender_full_name": "eddyb",
        "timestamp": 1648082358
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> you worked with amdgpu a lot a little while ago? I know it is also a harvard (has distinct address spaces for code and data.) but is it doing anything special otherwise?</p>",
        "id": 277538801,
        "sender_full_name": "nagisa",
        "timestamp": 1648917020
    },
    {
        "content": "<p>I haven't done anything that low-level (yet), sorry</p>",
        "id": 277538813,
        "sender_full_name": "eddyb",
        "timestamp": 1648917045
    },
    {
        "content": "<p>the ISA docs are public, so I suppose I could go look</p>",
        "id": 277538823,
        "sender_full_name": "eddyb",
        "timestamp": 1648917059
    },
    {
        "content": "<p>No worries, I'll do it myself if anything really forces the evaluation of that question thunk ^^</p>",
        "id": 277538840,
        "sender_full_name": "nagisa",
        "timestamp": 1648917100
    },
    {
        "content": "<p>(OTOH I wouldn't expect GPUs to be doing any von Neumann shenanigans any time soon, so I would assume they're all Harvard)</p>",
        "id": 277538841,
        "sender_full_name": "eddyb",
        "timestamp": 1648917103
    },
    {
        "content": "<p>amdgpu just popped in my mind as an example of harvard one of these days I was walking my dog <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 277538894,
        "sender_full_name": "nagisa",
        "timestamp": 1648917139
    },
    {
        "content": "<p>(god just imagine the massive stalls a GPU core would go through if it had to account for self-modifying code)</p>",
        "id": 277538900,
        "sender_full_name": "eddyb",
        "timestamp": 1648917154
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/wasm.20and.20.22function.20pointers.22/near/276411301\">said</a>:</p>\n<blockquote>\n<p>re: wasm's table type, it makes sense that its \"function pointers\" continue to be u32 no matter what, because uhh who the f needs more than 4294967296 symbols?</p>\n</blockquote>\n<p>WebAssembly is also interesting in that most VMs and parsers introduce limits stricter than the spec on the number of instances. In practice you won't really get more than a million distinct functions in a core module. Tables, though are somewhat different in that nobody prevents a producer from putting a function in the table more than once.</p>",
        "id": 277539027,
        "sender_full_name": "nagisa",
        "timestamp": 1648917380
    },
    {
        "content": "<p>Something folks here may find interesting: There is work underway on wasm64, where linear-memory indices are 64-bit, however function tables will remain 32-bit. So there's a question: in the C ABI, should function pointers be 32-bit or 64-bit?</p>",
        "id": 277542709,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648922339
    },
    {
        "content": "<p>Right now, it looks like they're going to be 64-bit, because that's the default behavior of LLVM for 64-bit targets, and it avoids potential compatibility problems.</p>",
        "id": 277542935,
        "sender_full_name": "Dan Gohman",
        "timestamp": 1648922547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/wasm.20and.20.22function.20pointers.22/near/276411842\">said</a>:</p>\n<blockquote>\n<p>wasm itself is a genuine case of my \"a language that is little more than an assembler\"</p>\n</blockquote>\n<p>That reminds me of this comment <a href=\"https://github.com/rust-lang/rust/pull/95583#issuecomment-1086613300\">https://github.com/rust-lang/rust/pull/95583#issuecomment-1086613300</a></p>\n<p>They're trying to pass serialized pointers from WASM to the browser and back to WASM again where they deserialize them.  Is there any provenance-preserving API between a browser and WASM?</p>",
        "id": 277543564,
        "sender_full_name": "scottmcm",
        "timestamp": 1648923332
    },
    {
        "content": "<p>The wasm module could have a function taking <code>*mut ...</code> and thus having provenance. On wasm level this lowers to i32/i64 so the browser can pass an integer address.</p>",
        "id": 277543817,
        "sender_full_name": "bjorn3",
        "timestamp": 1648923688
    },
    {
        "content": "<p>generally if you give <code>[MaybeUninit&lt;u8&gt;; N]</code> to an FFI and get it back later you can assume provenance was preserved</p>",
        "id": 277629709,
        "sender_full_name": "RalfJ",
        "timestamp": 1648993055
    },
    {
        "content": "<p>if you give it to the FFI as integers then you already stripped provenance on the Rust side before handing it out so you don't get it back</p>",
        "id": 277629791,
        "sender_full_name": "RalfJ",
        "timestamp": 1648993085
    },
    {
        "content": "<p>but if you use <em>casts</em> from ptr 2 int and back, you are still fine under permissive provenance (but you are leaving the strict provenance fragment of the language)</p>",
        "id": 277629813,
        "sender_full_name": "RalfJ",
        "timestamp": 1648993100
    }
]