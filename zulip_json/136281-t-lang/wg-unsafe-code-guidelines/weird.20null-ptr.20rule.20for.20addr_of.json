[
    {
        "content": "<p>Extra language was added to addr_of by <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span>  in this commit: <a href=\"https://github.com/rust-lang/rust/pull/83815/commits/b93137a24e0de539293a99f6bfce9855cf13679d\">https://github.com/rust-lang/rust/pull/83815/commits/b93137a24e0de539293a99f6bfce9855cf13679d</a></p>\n<blockquote>\n<p>Note, however, that the expr in <code>addr_of!(expr)</code> is still subject to all the usual rules. In particular, <code>addr_of!(*ptr::null())</code> is Undefined Behavior because it dereferences a null pointer.</p>\n</blockquote>\n<p>My <em>intuition</em> is that this is specifically trying to capture the notion that you aren't allowed to use addr_of to compute the \"pure offset\" of a field by doing <code>addr_of!((*null).field.subfield)</code>, because addr_of lowers to <code>GEP [inbounds]</code> which requires the pointer to be in an allocation to start with. Or to stay in Rust semantics, it lowers to <code>ptr::offset</code> (which is just <code>GEP [inbounds]</code> with a sheet draped over it).</p>\n<p>The <em>precise</em> case of <code>addr_of!(*ptr::null())</code> is weird because this is a no-op, and there's no reason to lower to <code>ptr.offset(0)</code>. Even if it <em>did</em>, <code>offset(0)</code> is a longstanding \"uhh???\" where it's like, it's <em>probably</em> fine but also hey don't do that? There <em>is</em> established precedent for the language having the notion of \"things that are seemingly UB but they're fine because it's a noop\" because of ZSTs.</p>\n<p>We freely out-of-thin-air pointers to ZSTs and \"\"read\"\" and \"\"write\"\" to them on the grounds that it's all statically and transparently a noop the compiler can discard. To my knowledge, this claim extends to ZSTs with fields: <code>((), ())</code> is a ZST with fields. This code should work:</p>\n<div class=\"codehilite\"><pre><span></span><code>let mut x = ((), ());\nlet ptr = (&amp;mut x) as *mut _;\n*(addr_of!((*x).1) = ();\n</code></pre></div>\n<p>Now I understand that <code>null</code> is special because we aren't allowed to out-out-thin-air ZSTs there, but like, it seems weird for us to not just allow this weird static noop. If you want to express that you can't do the \"pure offset\" trick, I suggest explicitly calling <em>that</em> out. And specifically calling out dangling pointers in general.</p>",
        "id": 269942814,
        "sender_full_name": "Gankra",
        "timestamp": 1643561357
    },
    {
        "content": "<p>\"subject to all the usual rules\" is also a weird thing to say because what's \"usual\" wrt <code>addr_of_mut!(place)</code>? clearly not <code>&amp;mut place</code>, so is it just computing the address of <code>place</code>?</p>\n<p>I'm not sure where we even define anything like <code>.field</code> having the restrictions of <code>ptr::offset</code>, but we should link that to these docs, instead of a vague reference</p>",
        "id": 269943081,
        "sender_full_name": "eddyb",
        "timestamp": 1643561668
    },
    {
        "content": "<blockquote>\n<p>I'm not sure where we even define anything like <code>.field</code> having the restrictions of <code>ptr::offset</code></p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> the standard library docs of <code>std::ptr</code> relates the two: <a href=\"https://doc.rust-lang.org/nightly/std/ptr/index.html#allocated-object\">https://doc.rust-lang.org/nightly/std/ptr/index.html#allocated-object</a></p>\n<blockquote>\n<h2><a href=\"https://doc.rust-lang.org/nightly/std/ptr/index.html#allocated-object\">Allocated object</a></h2>\n<p>For several operations, such as <a href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.offset\"><code>offset</code></a> or field projections (<code>expr.field</code>), the notion of an “allocated object” becomes relevant. An allocated object is a contiguous region of memory. Common examples of allocated objects include stack-allocated variables (each variable is a separate allocated object), heap allocations (each allocation created by the global allocator is a separate allocated object), and <code>static</code> variables.</p>\n</blockquote>",
        "id": 269944123,
        "sender_full_name": "Frank Steffahn",
        "timestamp": 1643562830
    },
    {
        "content": "<p>great, it's even in the same module :D</p>",
        "id": 269944178,
        "sender_full_name": "eddyb",
        "timestamp": 1643562871
    },
    {
        "content": "<p>so yeah the <code>addr_of</code> macros should link to that</p>",
        "id": 269944191,
        "sender_full_name": "eddyb",
        "timestamp": 1643562886
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> </p>\n<blockquote>\n<p>The precise case of addr_of!(*ptr::null()) is weird because this is a no-op, and there's no reason to lower to ptr.offset(0). Even if it did, offset(0) is a longstanding \"uhh???\" where it's like, it's probably fine but also hey don't do that? There is established precedent for the language having the notion of \"things that are seemingly UB but they're fine because it's a noop\" because of ZSTs.</p>\n</blockquote>\n<p>I think the confusion arises because you are thinking in terms of \"what this lowers to\" (e.g. in LLVM), but these docs are written in a way that encourages to think on the level of surface Rust or maybe MIR -- I think that is the level on which we want to write the spec.<br>\nOn that level, <code>addr_of!(*ptr::null())</code> is definitely not a NOP. It constructs a value of ptr type (a NULL ptr), and then does a value-to-place conversion (<code>*</code>, also often called \"dereferencing a pointer\", but sadly \"dereferencing\" is rather ambiguous), and then it does a place-to-value coercion (addr_of). In my mental model, and according to what the Reference and Miri currently require, the key step here is the value-to-place coercion: the requirement is that all places always point to valid memory, so value-to-place conversion is UB if the (ptr) value is dangling or null.<br>\nAs <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> put it in private conversion, one can think of this as an extra \"validity invariant\" that is imposed on all places ever constructed during program execution.</p>",
        "id": 270999136,
        "sender_full_name": "RalfJ",
        "timestamp": 1644249459
    },
    {
        "content": "<p>As a side not as far as I understand references to ZST are required to not be <code>ptr::null()</code> for various reasons, but instead point to some \"arbitrary assumed to hold an allocated object  place with an non-zero address\". Or is that an misunderstanding on my side?</p>",
        "id": 271558609,
        "sender_full_name": "Philipp Korber",
        "timestamp": 1644576450
    },
    {
        "content": "<p>They also need to be properly aligned</p>",
        "id": 271588639,
        "sender_full_name": "Nick12",
        "timestamp": 1644591737
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209646\">Philipp Korber</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/weird.20null-ptr.20rule.20for.20addr_of/near/271558609\">said</a>:</p>\n<blockquote>\n<p>As a side not as far as I understand references to ZST are required to not be <code>ptr::null()</code> for various reasons, but instead point to some \"arbitrary assumed to hold an allocated object  place with an non-zero address\". Or is that an misunderstanding on my side?</p>\n</blockquote>\n<p>yes. an <code>&amp;()</code> must be non-null and either obtained by casting an integer to a reference, or point to an actually allocated blob of memory.<br>\nan <code>&amp;[i32;0]</code> must additionally be 4-aligned (on platforms where <code>i32</code> has alignment 4).</p>",
        "id": 271683054,
        "sender_full_name": "RalfJ",
        "timestamp": 1644663398
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> also see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/319\">https://github.com/rust-lang/unsafe-code-guidelines/issues/319</a> which I just opened</p>",
        "id": 272998168,
        "sender_full_name": "RalfJ",
        "timestamp": 1645643909
    }
]