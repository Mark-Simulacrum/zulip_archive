[
    {
        "content": "<p>I was reminded of this by the conversation about monotonicity and Ralf's blog post, and would like to ask some specific questions here:</p>\n<p>PNVI-like models make use of angelic non-determinism; however, this is only possible if we have a theorem that states that the observable behavior of the program may not depend on which non-deterministic choice we make (restricting ourselves to those that do not cause UB). Is this correct?</p>\n<p>Is this any weaker than the following theorem:<br>\nLet P be an arbitrary program. Let <code>f</code> be a function with the property that it's only effect is to change the provenance of some bytes in memory. Let Q be a program obtained by inserting <code>f</code> at some arbitrary point in P. If P and Q both have defined behavior, that behavior must be the same.</p>\n<p>Essentially, I am trying to ask whether there is something special about int2ptr casts that make the choice of non-determinism irrelevant, or this is a property universal to provenance. Hopefully this motivation makes sense.</p>\n<p>If this theorem is true, I believe it would be formalizing the notion that provenance must be shadow state - it can only add UB, and cannot influence the execution of the program. If that is the case, I think it's interesting because (much like monotonicity) it represents an obligation for the remainder of the memory model - I recently even <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/206#issuecomment-1081256838\">made a suggestion</a> that would no longer be an option because of this</p>",
        "id": 278586827,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649697395
    },
    {
        "content": "<p>(sidenote: What is the proper set to quantify P over? I have enough background in theory to know that \"programs\" is obviously under-specified, but no background in PLT that would tell me what the correct alternative is)</p>",
        "id": 278587616,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649697779
    },
    {
        "content": "<blockquote>\n<p>Let P be an arbitrary program. Let f be a function with the property that it's only effect is to change the provenance of some bytes in memory. Let Q be a program obtained by inserting f at some arbitrary point in P. If P and Q both have defined behavior, that behavior must be the same.</p>\n</blockquote>\n<p>Yes, this theorem should be true. It is generally enforced to hold because it is impossible to codegen anything that accesses provenance directly. That's not a proof, but it is an incentive structure to keep the property true which is probably even better than a proof</p>",
        "id": 278592116,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649699605
    },
    {
        "content": "<p>P would probably be something like a \"conforming execution trace\" rather than a program</p>",
        "id": 278592448,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649699753
    },
    {
        "content": "<p>Here's a way to formalize it: Say that <code>S</code> is the collection of all AM states and <code>-&gt;</code> is the (nondeterministic) step relation on S. A trace is a sequence of states <code>T := s0 -&gt; s1 -&gt; ... -&gt; sn</code> and it is associated to some sequence of IO calls that make up the \"observable behavior\" of that trace, call it <code>obs(T) = obs(s0 -&gt; s1) ++ ... ++ obs(s(n-1) -&gt; sn)</code>. Let <code>s ~ t</code> mean that <code>s</code> and <code>t</code> are states which differ only in the assignment of provenance to bytes in memory. Then:</p>\n<ul>\n<li>The step relation is nondeterministic only in provenance: <code>s -&gt; s1</code> and <code>s -&gt; s2</code> implies <code>s1 ~ s2</code>. This is probably not literally true, but we need it to state the other parts. We can add an additional input to the step relation to accommodate nondeterministic transitions that occur on real machines; here we are only handling provenance nondeterminism.</li>\n<li>The step relation preserves provenance-relation: If <code>s ~ t</code> and <code>s -&gt; s'</code> and <code>t -&gt; t'</code> then <code>s' ~ t'</code></li>\n<li>The observable behavior of a trace does not depend on provenance: if <code>s ~ t</code> and <code>s -&gt; s'</code> and <code>t -&gt; t'</code> then <code>obs(s -&gt; s') = obs(t -&gt; t')</code></li>\n</ul>\n<p>This in particular implies your theorem: if we insert <code>f</code> in the middle of the trace <code>P</code> to make <code>Q</code>, we get something like:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">P</span><span class=\"w\"> </span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">pi</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">pi</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">pn</span><span class=\"w\"></span>\n<span class=\"n\">Q</span><span class=\"w\"> </span>:<span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">p1</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">pi</span><span class=\"w\"> </span><span class=\"o\">~</span><span class=\"w\"> </span><span class=\"n\">qi</span><span class=\"w\"> </span>-&gt; <span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">qn</span><span class=\"w\"></span>\n</code></pre></div>\n<p>where we inserted <code>f</code> at step <code>i</code> to turn <code>pi</code> into <code>qi := f(pi)</code>, and then did a bunch more steps, which are all in lock step with the corresponding <code>P</code> steps. As a result, each pair of transitions results in the same <code>obs</code> because <code>pj ~ qj</code> for all j.</p>",
        "id": 278594607,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649700670
    },
    {
        "content": "<p>I think you need to include differing borrow stacks in <code>~</code> in addition to differing provenance in memory for your second bullet to be true, but I understand your point of course</p>",
        "id": 278597747,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649701930
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278592116\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>Let P be an arbitrary program. Let f be a function with the property that it's only effect is to change the provenance of some bytes in memory. Let Q be a program obtained by inserting f at some arbitrary point in P. If P and Q both have defined behavior, that behavior must be the same.</p>\n</blockquote>\n<p>Yes, this theorem should be true. It is generally enforced to hold because it is impossible to codegen anything that accesses provenance directly. That's not a proof, but it is an incentive structure to keep the property true which is probably even better than a proof</p>\n</blockquote>\n<p>On the one hand, yes this seems true - on the other hand, the example I gave of using provenance to disambiguate allocations with a shared address is sort of a counterexample here. I'm not sure if this is the only example though, or if there are others</p>",
        "id": 278597937,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649702033
    },
    {
        "content": "<blockquote>\n<p>I recently even made a suggestion that would no longer be an option because of this</p>\n</blockquote>\n<p>how does that suggestion violate this property? if it can be implemented on regular (non-CHERI) hardware, I expect it cannot possibly violate the property you are postulating</p>",
        "id": 278604962,
        "sender_full_name": "RalfJ",
        "timestamp": 1649705453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278604962\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I recently even made a suggestion that would no longer be an option because of this</p>\n</blockquote>\n<p>how does that suggestion violate this property? if it can be implemented on regular (non-CHERI) hardware, I expect it cannot possibly violate the property you are postulating</p>\n</blockquote>\n<p>I'm suggesting that we use provenance to disambiguate which allocation a pointer writes to. This trivially means that changing provenance can cause a change in observable behavior; at the same time though, it is easy to implement this correctly on non-CHERI hardware by just giving each allocation unique addresses. This is indeed sort of cheating because it hides behind the implementation defined choice of base address for the allocation, but still</p>",
        "id": 278605321,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649705634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278597747\">said</a>:</p>\n<blockquote>\n<p>I think you need to include differing borrow stacks in <code>~</code> in addition to differing provenance in memory for your second bullet to be true, but I understand your point of course</p>\n</blockquote>\n<p>Yes, that was my intent. Basically all the shadow state in Miri is part of <code>~</code>: the borrow stacks on each byte of memory and the tags associated to any values, as well as the inheritance structure between tags and whether tags are exposed or not</p>",
        "id": 278608781,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649707439
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278605321\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278604962\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I recently even made a suggestion that would no longer be an option because of this</p>\n</blockquote>\n<p>how does that suggestion violate this property? if it can be implemented on regular (non-CHERI) hardware, I expect it cannot possibly violate the property you are postulating</p>\n</blockquote>\n<p>I'm suggesting that we use provenance to disambiguate which allocation a pointer writes to. This trivially means that changing provenance can cause a change in observable behavior; at the same time though, it is easy to implement this correctly on non-CHERI hardware by just giving each allocation unique addresses. This is indeed sort of cheating because it hides behind the implementation defined choice of base address for the allocation, but still</p>\n</blockquote>\n<p>Reading your proposal again, it sounds like you are suggesting that there can be multiple bytes that have the same address, at the same time, in the AM. That is a significant complication, since it means that now you don't just have borrow stacks, you have a whole stack of bytes (possibly with different values) at a given address, each of which has its own stack. Miri certainly can't handle anything like this</p>",
        "id": 278609444,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649707769
    },
    {
        "content": "<p>it also makes the mapping from AM state to hardware much less clear, since you can't just forget all the shadow state anymore</p>",
        "id": 278609621,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649707857
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278609444\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278605321\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Provenance.20must.20be.20shadow.20state/near/278604962\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I recently even made a suggestion that would no longer be an option because of this</p>\n</blockquote>\n<p>how does that suggestion violate this property? if it can be implemented on regular (non-CHERI) hardware, I expect it cannot possibly violate the property you are postulating</p>\n</blockquote>\n<p>I'm suggesting that we use provenance to disambiguate which allocation a pointer writes to. This trivially means that changing provenance can cause a change in observable behavior; at the same time though, it is easy to implement this correctly on non-CHERI hardware by just giving each allocation unique addresses. This is indeed sort of cheating because it hides behind the implementation defined choice of base address for the allocation, but still</p>\n</blockquote>\n<p>Reading your proposal again, it sounds like you are suggesting that there can be multiple bytes that have the same address, at the same time, in the AM. That is a significant complication, since it means that now you don't just have borrow stacks, you have a whole stack of bytes (possibly with different values) at a given address, each of which has its own stack. Miri certainly can't handle anything like this</p>\n</blockquote>\n<p>Yes. This is another way of saying that you cannot identify the byte in memory from the address alone. </p>\n<p>This is indeed a complication for users; it's less of a concern for the compiler. To be clear though, I'm not particularly hung up on that proposal. I'm mostly just mentioning it because a theorem as strong as the one I posted was a non-obvious requirement to me before</p>",
        "id": 278610088,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649708068
    },
    {
        "content": "<p>It's an interesting idea, not as impossible as I thought at first; but I think it will run aground on anything using asm or FFI to spec out what it means to read an address with multiple byte values in it. There are always going to be those debugger-like use cases and I think these fundamentally can't handle the \"two-dimensional\" view of memory</p>",
        "id": 278611250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649708508
    },
    {
        "content": "<p>I have reading that proposal on my todo list, but yeah I am rather skeptical of having overlapping live allocations that are somehow disambiguated via provenance</p>",
        "id": 278624810,
        "sender_full_name": "RalfJ",
        "timestamp": 1649715659
    }
]