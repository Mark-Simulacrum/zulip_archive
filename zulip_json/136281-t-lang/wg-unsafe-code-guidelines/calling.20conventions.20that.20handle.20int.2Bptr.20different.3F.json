[
    {
        "content": "<p>FFI is a struggle for strict-provenance whenever system APIs freely pun ints and pointers. </p>\n<p>The \"obvious\" solution to this is to just fix the signature on the Rust side so Rust understands Pointers Are Happening. On all the ABIs and Calling Conventions <em>I</em> know, a pointer-sized-integer and an actual pointer have identical ABIs in the standard calling conventions, making this fixup perfectly fine.</p>\n<p>It would be good to know on what platforms/conventions this trick does/doesn't work, as that determines how viable it is. CHERI is exempt from this discussion because if it has wrong signatures then the OS is busted and not our problem.</p>",
        "id": 276797780,
        "sender_full_name": "Gankra",
        "timestamp": 1648400968
    },
    {
        "content": "<p>WASM has <code>funcref</code> type IIRC.</p>",
        "id": 276798125,
        "sender_full_name": "nagisa",
        "timestamp": 1648401475
    },
    {
        "content": "<p>The SNES-Dev abi for w65 currently treats the pointer-sized integer (u32) and pointers as having different alignment requirements, which impacts the abi when parameters spill to the stack. This may or may not be changed, though (except on lccc, which has been designed with this in mind, it seems that making that work may be more trouble than its worth).</p>",
        "id": 276798242,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648401605
    },
    {
        "content": "<p>Yeah, never mind. WASM arguments are <code>I32 | i64 | f32 | f64</code> and function pointers are passed through as i32.</p>",
        "id": 276798361,
        "sender_full_name": "nagisa",
        "timestamp": 1648401827
    },
    {
        "content": "<p>Though the draft expands the set to include reftypes too: <a href=\"https://webassembly.github.io/spec/core/bikeshed/#syntax-valtype\">https://webassembly.github.io/spec/core/bikeshed/#syntax-valtype</a></p>",
        "id": 276798437,
        "sender_full_name": "nagisa",
        "timestamp": 1648401941
    },
    {
        "content": "<p>I believe it may also be tautologically true that this works for all conventions Rust supports, because I vaguely recall the code we use for actually computing the way to pass args explicitly just says a pointer has Integer Type Kind</p>",
        "id": 276798560,
        "sender_full_name": "Gankra",
        "timestamp": 1648402099
    },
    {
        "content": "<p>So if you do end up with a module which says that a function signature is a funcref and another that specifies <code>i32</code>, module validation/linking/etc will fail.</p>",
        "id": 276798563,
        "sender_full_name": "nagisa",
        "timestamp": 1648402104
    },
    {
        "content": "<p>cc <span class=\"user-mention\" data-user-id=\"119009\">@eddyb</span> who wrote a lot of this code, iirc</p>",
        "id": 276798649,
        "sender_full_name": "Gankra",
        "timestamp": 1648402224
    },
    {
        "content": "<p>yeah there is some conflation in e.g. RegKind only having Int|Float|Vector: <a href=\"https://github.com/rust-lang/rust/blob/master/compiler/rustc_target/src/abi/call/mod.rs#L136\">https://github.com/rust-lang/rust/blob/master/compiler/rustc_target/src/abi/call/mod.rs#L136</a></p>",
        "id": 276799931,
        "sender_full_name": "Gankra",
        "timestamp": 1648404177
    },
    {
        "content": "<p>but it's possible an ABI could e.g. always pass pointers on the stack</p>",
        "id": 276799942,
        "sender_full_name": "Gankra",
        "timestamp": 1648404203
    },
    {
        "content": "<p>(eddyb is explaining this is more complex to me... ABIs are messes who would have guessed)</p>",
        "id": 276800017,
        "sender_full_name": "Gankra",
        "timestamp": 1648404313
    },
    {
        "content": "<p>(eddyb agrees they have never seen an ABI where just Fixing The Extern would actually mess up the FFI)</p>",
        "id": 276800438,
        "sender_full_name": "Gankra",
        "timestamp": 1648404849
    },
    {
        "content": "<p>for struct layout you'd need to switch some ints to union { int; pointer } after bindgen, but that's doable of course</p>",
        "id": 276800847,
        "sender_full_name": "Talchas",
        "timestamp": 1648405484
    },
    {
        "content": "<p>I think you can/should just make them only \"pointer\", making non-aggregates into aggregates is... sketchier (not 100% sure how unions get classified)</p>",
        "id": 276801951,
        "sender_full_name": "Gankra",
        "timestamp": 1648406954
    },
    {
        "content": "<p>that would /actually/ break the layout for the \"use u64 for pointers so that the syscall can be the same on 32bit\" kernel ones</p>",
        "id": 276802867,
        "sender_full_name": "Talchas",
        "timestamp": 1648408217
    },
    {
        "content": "<p>Oh! yes sorry very good point</p>",
        "id": 276803056,
        "sender_full_name": "Gankra",
        "timestamp": 1648408528
    },
    {
        "content": "<p>yeah, in general going to union is potentially sketchy for ABI</p>",
        "id": 276803301,
        "sender_full_name": "Talchas",
        "timestamp": 1648408870
    },
    {
        "content": "<p>but for these uses is almost certainly more correct</p>",
        "id": 276803306,
        "sender_full_name": "Talchas",
        "timestamp": 1648408892
    },
    {
        "content": "<p>It might still be worth providing a Blessed/Magic Ptr64, Ptr128, etc type to express this in a way that doesn't mess with ABI ever</p>",
        "id": 276803384,
        "sender_full_name": "Gankra",
        "timestamp": 1648408984
    },
    {
        "content": "<p>I asked some of my C friends and also found that there were APIs that did the whole use an integer for ABI, but made it 32bit. And you need to get a properly low pointer to pass it. Sigh. Luckily I think it's just a library API and not a platform one.</p>",
        "id": 276804635,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648410845
    },
    {
        "content": "<p>Actually, if they get the proper low pointer from elsewhere they might just be fine, since that pointer can carry the provenance</p>",
        "id": 276804714,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648410972
    },
    {
        "content": "<p>I mean, you have a valid pointer already whether it's low-required or not; the question is about getting it to C (and for io_uring or similar things, getting it back from C)</p>",
        "id": 276805292,
        "sender_full_name": "Talchas",
        "timestamp": 1648411748
    },
    {
        "content": "<p>(and in the latter case \"you can store the pointer elsewhere\" is not a solution; PtrN types are)</p>",
        "id": 276805306,
        "sender_full_name": "Talchas",
        "timestamp": 1648411785
    },
    {
        "content": "<p>(the PtrN types of course being equivalent to bN byte types or other sorts of limited PVI, though limiting it to FFI might let you cheat)</p>",
        "id": 276805393,
        "sender_full_name": "Talchas",
        "timestamp": 1648411903
    },
    {
        "content": "<p>I just really hope no one is a smartass and wants the pointer part in the high bits</p>",
        "id": 276805396,
        "sender_full_name": "Gankra",
        "timestamp": 1648411912
    },
    {
        "content": "<p>Wait till you see somebody shifting pointersâ€¦</p>",
        "id": 276811470,
        "sender_full_name": "nagisa",
        "timestamp": 1648420300
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"123586\">@nagisa</span> oh you mean rustc? <a href=\"https://github.com/rust-lang/rust/blob/ab0c2e18dceb7140626a158affb983ae81039bd0/compiler/rustc_data_structures/src/tagged_ptr/copy.rs#L67\">https://github.com/rust-lang/rust/blob/ab0c2e18dceb7140626a158affb983ae81039bd0/compiler/rustc_data_structures/src/tagged_ptr/copy.rs#L67</a></p>",
        "id": 276811804,
        "sender_full_name": "Gankra",
        "timestamp": 1648420881
    },
    {
        "content": "<p>This is shifting in the wrong direction <span aria-label=\"grinning\" class=\"emoji emoji-1f600\" role=\"img\" title=\"grinning\">:grinning:</span></p>",
        "id": 276811860,
        "sender_full_name": "nagisa",
        "timestamp": 1648420958
    },
    {
        "content": "<p>i mean either way seems equally fucked up lol</p>",
        "id": 276811876,
        "sender_full_name": "Gankra",
        "timestamp": 1648421014
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/276805396\">said</a>:</p>\n<blockquote>\n<p>I just really hope no one is a smartass and wants the pointer part in the high bits</p>\n</blockquote>\n<p>i do this sometimes but just via #[rep(align(N))], it might not be what you mean though</p>",
        "id": 276811942,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421117
    },
    {
        "content": "<p>yeah i mean like, they have a 32-bit pointer and store it in 64-bit int by doing <code>ptr as u64</code> &lt;&lt; 32</p>",
        "id": 276811953,
        "sender_full_name": "Gankra",
        "timestamp": 1648421158
    },
    {
        "content": "<p>which like, is a decision you can make</p>",
        "id": 276811993,
        "sender_full_name": "Gankra",
        "timestamp": 1648421167
    },
    {
        "content": "<p>i have done it with #[repr(align(256))] to stick a whole byte in there and then read that byte separately, but that code was UB (for more reasons than just this)</p>",
        "id": 276811995,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421170
    },
    {
        "content": "<p>oh, yeah, i see</p>",
        "id": 276811998,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421175
    },
    {
        "content": "<p>i suppose that byte trick wouldn't work anymore, since its morally a ptr/int transmute. the only case i can think of where you \"need\" to do this is a mixed-size atomic access though</p>",
        "id": 276812011,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421229
    },
    {
        "content": "<p>which is forbidden on x86 (... where it works perfectly and the linux kernel's spinlocks use it so it probably cant break)</p>",
        "id": 276812016,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421272
    },
    {
        "content": "<p>mixed-size atomic? 0.o</p>",
        "id": 276812055,
        "sender_full_name": "Gankra",
        "timestamp": 1648421288
    },
    {
        "content": "<p>yeah basically where you turn a AtomicFoo into an [AtomicU8; size_of::&lt;AtomicFoo&gt;()]</p>",
        "id": 276812064,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421346
    },
    {
        "content": "<p>and read one of the bytes</p>",
        "id": 276812065,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421352
    },
    {
        "content": "<p>...huh</p>",
        "id": 276812071,
        "sender_full_name": "Gankra",
        "timestamp": 1648421368
    },
    {
        "content": "<p>in this case AtomicFoo is AtomicPtr&lt;T&gt; where T is #[repr(align(256))]</p>",
        "id": 276812072,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421369
    },
    {
        "content": "<p>and then the bottom byte is read as a AtomicU8</p>",
        "id": 276812073,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421383
    },
    {
        "content": "<p>anyway i dont expect this to be allowed</p>",
        "id": 276812076,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421391
    },
    {
        "content": "<p>it literally is forbidden by the x86 arch manual</p>",
        "id": 276812079,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421400
    },
    {
        "content": "<p>lmao</p>",
        "id": 276812123,
        "sender_full_name": "Gankra",
        "timestamp": 1648421408
    },
    {
        "content": "<p>(even though it works and is used everywhere)</p>",
        "id": 276812129,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421418
    },
    {
        "content": "<p>\"I am the kernel i win arguments with even the cpu vendor\"</p>",
        "id": 276812130,
        "sender_full_name": "Gankra",
        "timestamp": 1648421421
    },
    {
        "content": "<p>libstdc++ merged a patch that used it recently to optimize shared pointers</p>",
        "id": 276812141,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421443
    },
    {
        "content": "<p>according to <a href=\"https://twitter.com/davidtgoldblatt/status/1501725130765975553\">https://twitter.com/davidtgoldblatt/status/1501725130765975553</a> the fact that it's disallowed even came up in review</p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/davidtgoldblatt/status/1501725130765975553\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/10505c6822ea679ab52748ead753f0100140a004/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f3837393536393934323638343734353732382f39757553387934565f6e6f726d616c2e6a7067\"></a><p><a href=\"https://twitter.com/at_tcsc\">@at_tcsc</a> Yeah, I think you're right that it's officially disallowed (we talked about it in review too IIRC). I always end up being OK with this sort of thing because:\n- It's too widely used for Intel to break without breaking the world\n- I think the real intent of that section is to (1/2)</p><span>- David Goldblatt (@davidtgoldblatt)</span></div></div>",
        "id": 276812148,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421463
    },
    {
        "content": "<p>hmm interesting, I'm surprised this is compelling in Rust given ownership lets you avoid the kind of pointless traffic that Swift is constantly weeping over</p>",
        "id": 276812246,
        "sender_full_name": "Gankra",
        "timestamp": 1648421627
    },
    {
        "content": "<p>i'm not sure it actually is that compelling in rust</p>",
        "id": 276812291,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421646
    },
    {
        "content": "<p>that said for async code you often need Arc&lt;T&gt; even if the synch version of the api would be &amp;T</p>",
        "id": 276812329,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421745
    },
    {
        "content": "<p>just to avoid the pain of lifetime shenanigans with futures</p>",
        "id": 276812347,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421762
    },
    {
        "content": "<p>sounds believable, yeah</p>",
        "id": 276812379,
        "sender_full_name": "Gankra",
        "timestamp": 1648421778
    },
    {
        "content": "<p>and more generally Arc is heavily used in async code</p>",
        "id": 276812380,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421780
    },
    {
        "content": "<p>i just expect \"just kinda getting my job done\"-quality rust code to have an order of magnitude less ARC traffic than equivalent C++ (and maybe Swift) for the same reason I've come to expect that for String vs std::string copies</p>",
        "id": 276812396,
        "sender_full_name": "Gankra",
        "timestamp": 1648421853
    },
    {
        "content": "<p>hm, depends on the codebase. some places refcounting is more heavily used than others</p>",
        "id": 276812453,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648421924
    },
    {
        "content": "<p>specifically here I mean that C++/Swift will Do What I Mean lots of \"needless\" refcount traffic because it's genuinely pretty hard to notice all that places where implicit copy/assign ctors show up and properly insert the std::moves -- and even if you can you might decide not to for the sake of defense in depth against complicated pointer bugs. whereas in rust you are doing trivial moves by default and can pretty confidently just mess with references wherever and know the compiler has your back (and the clone being explicit makes you \"feel bad\" for using it)</p>",
        "id": 276812603,
        "sender_full_name": "Gankra",
        "timestamp": 1648422070
    },
    {
        "content": "<p>maybe this effect is more dramatic with Strings because string_view stuff is relatively new and messy tho (and cstrings don't like being subsliced), while rust slices are very first-class</p>",
        "id": 276812669,
        "sender_full_name": "Gankra",
        "timestamp": 1648422142
    },
    {
        "content": "<p>anyway i mostly said that offhand</p>",
        "id": 276812833,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648422393
    },
    {
        "content": "<p>in the tweet</p>",
        "id": 276812835,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648422396
    },
    {
        "content": "<p>it's possible it's not as compelling for us. i think its certainly not compelling enouhg to go against something the cpu vendor says, even if it Works In Practice</p>",
        "id": 276812844,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648422428
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/276812079\">said</a>:</p>\n<blockquote>\n<p>it literally is forbidden by the x86 arch manual</p>\n</blockquote>\n<p>wait really? that seems like a cheap cap-out^^</p>",
        "id": 276813709,
        "sender_full_name": "RalfJ",
        "timestamp": 1648423808
    },
    {
        "content": "<p>I cite (and screenshot) the specific part here: <a href=\"https://twitter.com/at_tcsc/status/1501712444451741696\">https://twitter.com/at_tcsc/status/1501712444451741696</a></p>\n<div class=\"inline-preview-twitter\"><div class=\"twitter-tweet\"><a href=\"https://twitter.com/at_tcsc/status/1501712444451741696\"><img class=\"twitter-avatar\" src=\"https://uploads.zulipusercontent.net/9492b1a49a185414e8d7f67b9ac7f5b5324fd2ce/68747470733a2f2f7062732e7477696d672e636f6d2f70726f66696c655f696d616765732f313337323036383434393439373734373435362f306f524c7a4b394f5f6e6f726d616c2e6a7067\"></a><p>it'd be great to get this opt in Rust, since \"Arc&lt;T&gt; but in practice a Box&lt;T&gt;\" is common (it can be needed to make an API safe, even if the issue requires deliberate misuse).\n\nSadly, IDK how the algo isn't violating this rule from x86 architecture manual (from 3A/I 8.1.2.2): <a href=\"https://t.co/WX5uI92dDW\">https://twitter.com/davidtgoldblatt/status/1477728140600307714</a> <a href=\"https://t.co/JTXAUNVof2\">https://twitter.com/at_tcsc/status/1501712444451741696/photo/1</a></p><span>- thom, supposedly (@at_tcsc)</span><div class=\"twitter-image\"><a href=\"https://t.co/JTXAUNVof2\"><img src=\"https://uploads.zulipusercontent.net/db4439f895e81f5e9f23da69c20cf588d32f3886/68747470733a2f2f7062732e7477696d672e636f6d2f6d656469612f464e636d5752415655414531434b672e706e673a6c61726765\"></a></div></div></div>",
        "id": 276815461,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648426693
    },
    {
        "content": "<p>anyway this has gotten off topic</p>",
        "id": 276815474,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648426717
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/276797780\">said</a>:</p>\n<blockquote>\n<p>The \"obvious\" solution to this is to just fix the signature on the Rust side so Rust understands Pointers Are Happening.</p>\n</blockquote>\n<p>At least one such system function, <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getwindowlongptrw\">GetWindowLongPtrW</a>, happily mixes function pointers, data pointers, and integers, all as a single \"accessor\" function. They're all returned through an <code>isize</code> value, and the caller is expected to convert to the correct form.</p>\n<p>So, some sort of union for that too?</p>",
        "id": 276832032,
        "sender_full_name": "Lokathor",
        "timestamp": 1648449017
    },
    {
        "content": "<p>as long as it's ptr-sized, we can use a ptr type as that union type</p>",
        "id": 276873328,
        "sender_full_name": "RalfJ",
        "timestamp": 1648474366
    },
    {
        "content": "<p>I really dislike the usability impact of having to declare things with different signatures than they have in C.  Especially if you're using bindgen to automatically bind to C headersâ€¦</p>",
        "id": 277004403,
        "sender_full_name": "comex",
        "timestamp": 1648560586
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> i've already added CHERI-style uptr/iptr to the stable Polyfill (sptr) and you can use that in the worst-case</p>",
        "id": 277006362,
        "sender_full_name": "Gankra",
        "timestamp": 1648561450
    },
    {
        "content": "<p>Would it work to use an <code>isize</code> value that is actually a transmuted pointer or fn pointer, in a world where int2ptr doesn't exist? I'm not sure if calling the FFI function causes a read at the wrong type</p>",
        "id": 277006420,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648561481
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> that is the exact thing i just described</p>",
        "id": 277006669,
        "sender_full_name": "Gankra",
        "timestamp": 1648561567
    },
    {
        "content": "<p><a href=\"https://docs.rs/sptr/0.2.1/sptr/int/struct.uptr.html\">https://docs.rs/sptr/0.2.1/sptr/int/struct.uptr.html</a></p>",
        "id": 277006680,
        "sender_full_name": "Gankra",
        "timestamp": 1648561574
    },
    {
        "content": "<p><code>uptr</code> is just a wrapper around <code>*mut ()</code> though, right?</p>",
        "id": 277006704,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648561587
    },
    {
        "content": "<p>it's not actually a <code>usize</code></p>",
        "id": 277006729,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648561602
    },
    {
        "content": "<p>they have identical ABIs, the only difference is the compiler knows to track provenance</p>",
        "id": 277006766,
        "sender_full_name": "Gankra",
        "timestamp": 1648561626
    },
    {
        "content": "<p>all known supported ABIs (outside CHERI where this issue should be irrelevant) pass pointers and pointer-sized-integers identically</p>",
        "id": 277006942,
        "sender_full_name": "Gankra",
        "timestamp": 1648561700
    },
    {
        "content": "<p>I read <span class=\"user-mention\" data-user-id=\"198590\">@comex</span> 's point as saying that we want to be able to mechanically turn the C definition into a rust extern spec and there wouldn't be a way to make <code>uptr</code> come out unless there was an annotation on the C side</p>",
        "id": 277006946,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648561703
    },
    {
        "content": "<p>if this hack is deemed necessary, it can be a built-in type with built-in magic</p>",
        "id": 277007064,
        "sender_full_name": "Gankra",
        "timestamp": 1648561764
    },
    {
        "content": "<p>Could rust/rustc simply mark every single pointer-sized integer in extern's as actually a pointer?</p>",
        "id": 277007116,
        "sender_full_name": "Nick12",
        "timestamp": 1648561792
    },
    {
        "content": "<p>it could, but this would be a Very Sad Outcome</p>",
        "id": 277007196,
        "sender_full_name": "Gankra",
        "timestamp": 1648561809
    },
    {
        "content": "<p>certainly you could imagine having it as a -C option, in the same vein of people compiling their code with strict-aliasing disabled in C++ because it's \"too hard\"</p>",
        "id": 277007286,
        "sender_full_name": "Gankra",
        "timestamp": 1648561853
    },
    {
        "content": "<p>Having the implicit transmute happening across the FFI boundary is pretty sketch though</p>",
        "id": 277007336,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648561875
    },
    {
        "content": "<p>actually, no</p>",
        "id": 277007344,
        "sender_full_name": "Gankra",
        "timestamp": 1648561877
    },
    {
        "content": "<p>rustc just marking the API isn't really helpful</p>",
        "id": 277007366,
        "sender_full_name": "Gankra",
        "timestamp": 1648561889
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> all FFI is implict transmutes lol</p>",
        "id": 277007407,
        "sender_full_name": "Gankra",
        "timestamp": 1648561910
    },
    {
        "content": "<p>it's just \"hope the ABI matches\"</p>",
        "id": 277007477,
        "sender_full_name": "Gankra",
        "timestamp": 1648561928
    },
    {
        "content": "<p>Auditing FFI is hard when you are doing magical things at the same time</p>",
        "id": 277007532,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648561957
    },
    {
        "content": "<p>so bindgen is very useful and I hope we can find a solution that is compatible with it</p>",
        "id": 277007625,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562003
    },
    {
        "content": "<p>Auditing FFI would be even harder if instead of translating a C declaration you <em>also</em> had to account for \"this is an integer but <em>actually</em> its a pointer so I need to use another type\"</p>",
        "id": 277007637,
        "sender_full_name": "Nick12",
        "timestamp": 1648562010
    },
    {
        "content": "<p>tbc, if the pointer <em>comes from</em> FFI and <em>goes back to</em> FFI and Rust never thought about it as a pointer (like most cases of HANDLE) then that's totally fine, since provenance is only within rust's abstract machine. The abstract machine doesn't care if someone on the other side is roundtripping lying pointers through us.</p>",
        "id": 277007901,
        "sender_full_name": "Gankra",
        "timestamp": 1648562127
    },
    {
        "content": "<p>that's what I meant about transmuted pointers</p>",
        "id": 277008030,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562168
    },
    {
        "content": "<p>If it's <em>not</em> roundtripping then attempting to use the API will inevitably result in \"oh fuck I need to do a ptr&lt;-&gt;int cast\" and boom there's your audit</p>",
        "id": 277008045,
        "sender_full_name": "Gankra",
        "timestamp": 1648562174
    },
    {
        "content": "<p>like literally you <em>already</em> have to cast to deal with these kinds of APIs</p>",
        "id": 277008153,
        "sender_full_name": "Gankra",
        "timestamp": 1648562220
    },
    {
        "content": "<p>we can just use <code>isize</code> even though it stores <code>*mut ()</code> data, even if performing any operation on that data is considered UB (either immediately or later when someone on the other end of the FFI derefs it) as long as it is only ever handled opaquely</p>",
        "id": 277008231,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562254
    },
    {
        "content": "<p>I'm not sure we can just call that provenance \"someone else's problem\" though, the AM execution includes that FFI stuff too</p>",
        "id": 277008332,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562286
    },
    {
        "content": "<p>You cannot have stuff outside of Rust in the abstract machine. It does not make sense to discuss. Provenance modeling must end at the FFI boundary.</p>",
        "id": 277008510,
        "sender_full_name": "Gankra",
        "timestamp": 1648562387
    },
    {
        "content": "<p>What if you pass a pointer to C and it passes the pointer back? We don't want to consider that as a ptr2int2ptr, I think</p>",
        "id": 277008742,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562451
    },
    {
        "content": "<p>if you erase all provenance at the door then that's what you get</p>",
        "id": 277008799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562479
    },
    {
        "content": "<p>please explicitly write out what you're describing as code so that we can have a coherent discussion</p>",
        "id": 277008891,
        "sender_full_name": "Gankra",
        "timestamp": 1648562522
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"kt\">int</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">return</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This should not be UB</p>",
        "id": 277009113,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562631
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277008742\">said</a>:</p>\n<blockquote>\n<p>What if you pass a pointer to C and it passes the pointer back? We don't want to consider that as a ptr2int2ptr, I think</p>\n</blockquote>\n<p>No, but if it can't analyze the function it has to assume it returns either any parameter or any escaped pointer.</p>",
        "id": 277009229,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648562669
    },
    {
        "content": "<p>I'm not talking about what the compiler can optimize with, I'm talking about the AM semantics</p>",
        "id": 277009305,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562698
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> agreed, this code works perfectly under strict provenance</p>",
        "id": 277009330,
        "sender_full_name": "Gankra",
        "timestamp": 1648562707
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277009305\">said</a>:</p>\n<blockquote>\n<p>I'm not talking about what the compiler can optimize with, I'm talking about the AM semantics</p>\n</blockquote>\n<p>AM Semantics arround FFI are hard to specify.</p>",
        "id": 277009411,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648562752
    },
    {
        "content": "<p>I know, I've been wondering about this issue for a long time since it seems to be the elephant in the room</p>",
        "id": 277009496,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562778
    },
    {
        "content": "<p>but I don't see how we are supposed to avoid every other language spec being a part of the Rust AM if it has FFI</p>",
        "id": 277009533,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562801
    },
    {
        "content": "<p>...or, you know, we could just keep ignoring it</p>",
        "id": 277009755,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562888
    },
    {
        "content": "<p>AM semantics for FFI seem very clear unless you expect the compiler to Have To reason globally. This is no different than a native Rust API that goes (*const) -&gt; *const</p>",
        "id": 277009773,
        "sender_full_name": "Gankra",
        "timestamp": 1648562897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277009533\">said</a>:</p>\n<blockquote>\n<p>but I don't see how we are supposed to avoid every other language spec being a part of the Rust AM if it has FFI</p>\n</blockquote>\n<p>The issue is that every other language spec can't be part of the Rust AM.</p>",
        "id": 277009838,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648562930
    },
    {
        "content": "<p>in a rust API, there is someone to pick up the phone on the other end, and AFAIK the AM semantics go right on through that barrier</p>",
        "id": 277009899,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562961
    },
    {
        "content": "<p>even if the compiler can't see / optimize through that barrier</p>",
        "id": 277009935,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648562983
    },
    {
        "content": "<p>Some of them do.</p>",
        "id": 277009939,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648562986
    },
    {
        "content": "<p>for C and C++ I think we want at least some sharing of execution semantics since there is language about panicking vs C++ exception handling, repr(C) and all that</p>",
        "id": 277010140,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648563063
    },
    {
        "content": "<p>I think it might be possible to formally define a nondeterministic transition to \"any state you could possibly get to by non-UB unsafe rust code\" (not defined literally like that but closer to setting all accessible memory to nondeterministic values) which would be the AM equivalent of \"run an opaque function\", which could be used for modeling FFI calls and possibly also external rust calls in a shared library</p>",
        "id": 277012689,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564078
    },
    {
        "content": "<p>it would be pretty impossible for miri to execute that though</p>",
        "id": 277012784,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564099
    },
    {
        "content": "<p>Well, I mean, miri can't execute unknown FFI anyways, so...</p>",
        "id": 277013071,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564218
    },
    {
        "content": "<p>what about known FFI?</p>",
        "id": 277013148,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564248
    },
    {
        "content": "<p>Nondeterminstic=Unspecified.<br>\nIf MIRI knows about the FFI, it can make the appropriate choice for the unspecified behaviour.</p>",
        "id": 277013349,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564320
    },
    {
        "content": "<p>I'm suggesting to use that kind of semantics for all FFI, even if it is to a \"known\" function (whatever that means). In particular that means that compilers are not permitted to optimize or inline across FFI even if they git gud</p>",
        "id": 277013415,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564334
    },
    {
        "content": "<p>the alternative would be throwing the C / C++ specs into the rust spec which is... undesirable</p>",
        "id": 277013528,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564388
    },
    {
        "content": "<p>I'd define it as some ellaboration on:</p>\n<blockquote>\n<p>Places the abstract machine in some unspecified state, or the behaviour is undefined.</p>\n</blockquote>\n<p>Which means compilers can most certainly optimize/inline accross FFI.</p>",
        "id": 277013581,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564410
    },
    {
        "content": "<p>no see that's not the nondeterminism I mean. \"Unspecified\" has the wrong behavior since the compiler can just make up a function and do that instead of the real one</p>",
        "id": 277013795,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564485
    },
    {
        "content": "<p>I mean, how do you specify what \"the real one\" is.</p>",
        "id": 277013851,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564504
    },
    {
        "content": "<p>You log a call to the function and the current state of (accessible) memory to the Observable Behavior trace</p>",
        "id": 277013953,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564540
    },
    {
        "content": "<p>like IO</p>",
        "id": 277013994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564556
    },
    {
        "content": "<p>You can limit it's choices somewhat, for example</p>\n<blockquote>\n<p>If some crate defines a function with an export-name that matches the link_name of an external declaration, then the result of calling the declaration is the same as the result of calling that definition as-if the definition was accessible to the current crate. The behaviour is undefined if the definitions is not compatible with the declaration.</p>\n</blockquote>",
        "id": 277014173,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564613
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277013953\">said</a>:</p>\n<blockquote>\n<p>You log a call to the function and the current state of (accessible) memory to the Observable Behavior trace</p>\n</blockquote>\n<p>Realistically, this will never fly.</p>",
        "id": 277014238,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564640
    },
    {
        "content": "<p>And as an implementor... No, definately not.</p>",
        "id": 277014272,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564656
    },
    {
        "content": "<p>how so? It's entirely a theoretical concept</p>",
        "id": 277014287,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564659
    },
    {
        "content": "<p>FFI-inlining happens with LTO.</p>",
        "id": 277014332,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564676
    },
    {
        "content": "<p>Good luck convincing llvm not to inline function definitions in LTO mode.</p>",
        "id": 277014405,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564695
    },
    {
        "content": "<p>Good luck convincing any optimizing compiler that supports LTO to not inline definitions with LTO.</p>",
        "id": 277014484,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564726
    },
    {
        "content": "<p>hm... does LLVM have LLVM IR for both sides of the FFI in this scenario?</p>",
        "id": 277014504,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564733
    },
    {
        "content": "<p>It might.</p>",
        "id": 277014539,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564744
    },
    {
        "content": "<p>that concern is 5-10 years away from being reality given LLVM <em>already</em> doesn't have a coherent notion of aliasing and PNVI and strict-aliasing are both just proposed concepts</p>",
        "id": 277014551,
        "sender_full_name": "Gankra",
        "timestamp": 1648564747
    },
    {
        "content": "<p>the \"virtue\" of strict-aliasing is that basically any coherent model must be a weakening of it, afaict</p>",
        "id": 277014647,
        "sender_full_name": "Gankra",
        "timestamp": 1648564789
    },
    {
        "content": "<p>so if we make all <em>our</em> code conform to it, it will \"always\" be right</p>",
        "id": 277014681,
        "sender_full_name": "Gankra",
        "timestamp": 1648564802
    },
    {
        "content": "<p>(well specifically stacked-borrows-with-strict-aliasing)</p>",
        "id": 277014794,
        "sender_full_name": "Gankra",
        "timestamp": 1648564833
    },
    {
        "content": "<p>I actually have plans to build all of lccc's libraries (including the rust libraries) in mixed-LTO mode, which means that the static archives will contain both machine code and xir bytecode, so turning on LTO gets LTO to all of the rt and standard libraries.</p>",
        "id": 277014841,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564851
    },
    {
        "content": "<p>sure, but \"compiling any code on LLVM\" is already conceptually unsound because it simply does not have a coherent model</p>",
        "id": 277014905,
        "sender_full_name": "Gankra",
        "timestamp": 1648564885
    },
    {
        "content": "<p>I think I will return to my original position of \"this seems impossible to specify unless you make every spec be part of rust\"</p>",
        "id": 277014941,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648564897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277014941\">said</a>:</p>\n<blockquote>\n<p>I think I will return to my original position of \"this seems impossible to specify unless you make every spec be part of rust\"</p>\n</blockquote>\n<p>Just make it unspecified and place some limitations on it.</p>",
        "id": 277014994,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564917
    },
    {
        "content": "<p>You're never going to get anything better than that.</p>",
        "id": 277015116,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648564955
    },
    {
        "content": "<p>basically I am suggesting a tower of weakenings:</p>\n<ul>\n<li>strictest: the model people write code against</li>\n<li>stricter: whatever weakening of this model we think we can make coherent</li>\n<li>shrug-emoji: whatever annotations and transforms compilers actually define and provide</li>\n</ul>",
        "id": 277015435,
        "sender_full_name": "Gankra",
        "timestamp": 1648565065
    },
    {
        "content": "<p>i cannot imagine there ever being a coherent system that would miscompile code conforming to strict-provenance</p>",
        "id": 277015818,
        "sender_full_name": "Gankra",
        "timestamp": 1648565201
    },
    {
        "content": "<p>what the <em>compiler</em> actually emits in the face of FFI and Evil is its business</p>",
        "id": 277015902,
        "sender_full_name": "Gankra",
        "timestamp": 1648565238
    },
    {
        "content": "<p>right?</p>",
        "id": 277015971,
        "sender_full_name": "Gankra",
        "timestamp": 1648565264
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277015818\">said</a>:</p>\n<blockquote>\n<p>i cannot imagine there ever being a coherent system that would miscompile code conforming to strict-provenance</p>\n</blockquote>\n<p><code>ptr.wrapping_offset(HUGE).wrapping_offset(-HUGE)</code> <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 277016511,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648565507
    },
    {
        "content": "<p>that code is safe under strict-provenance rules and CHERI has coherent arguments for breaking it</p>",
        "id": 277016752,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648565616
    },
    {
        "content": "<p>that's a hardware/system limitation, not a compiler \"bug\"</p>",
        "id": 277016861,
        "sender_full_name": "Gankra",
        "timestamp": 1648565648
    },
    {
        "content": "<p>if an OS had 128-byte stacks a bunch of Rust code would explode on it but it's not being \"miscompiled\"</p>",
        "id": 277016921,
        "sender_full_name": "Gankra",
        "timestamp": 1648565674
    },
    {
        "content": "<p>like we don't hand-wring about someone targetting rust to some low-end embedded hardware having to be careful to not exhaust the thing's resources, or having to be nostd. some code isn't as portable as you'd like. it happens.</p>",
        "id": 277017502,
        "sender_full_name": "Gankra",
        "timestamp": 1648565890
    },
    {
        "content": "<p>the current docs i have do say wrapping_offset is still chill, but just mentions that some platforms may fall over if you push it too hard. just like rust lets you say <code>let x: [u8; 100000000] = [0; 100000000]</code> and we will faithfully try to do that and then your program falls over immediately.</p>",
        "id": 277017755,
        "sender_full_name": "Gankra",
        "timestamp": 1648565993
    },
    {
        "content": "<p>hell we #[cfg] out random parts of std for WASM, it's fine.</p>",
        "id": 277018079,
        "sender_full_name": "Gankra",
        "timestamp": 1648566087
    },
    {
        "content": "<p>(by the way, small stacks isn't just an embedded problem, it can happen on userspace linux too. A while back I investigated whether it is possible to compile code without faulting on stack overflow if you precalculate the total required stack space, and I was gobsmacked to discover that you can set the stack limit such that you get a stack overflow before running the first line of <code>_start</code>)</p>",
        "id": 277018269,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648566150
    },
    {
        "content": "<p>(and also the user can be a jerk and put a ton of stuff in the environment variables and use up your stack)</p>",
        "id": 277018460,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648566235
    },
    {
        "content": "<p>The \"tower of weakenings\" concept makes sense to me.  But it comes at the cost of usability, since it implies imposing stricter requirements than the compiler actually takes advantage of or, most likely IMO, will ever take advantage of.  (There's no possible future where LLVM starts imposing strict provenance on C.  There's a possible future where we have important Rust-specific optimizations that rely on strict provenance, but it seems pretty distant to me, given that the amount of contribution from the Rust project to LLVM is still relatively limited.  Besides, it's not clear to me that optimizing based on strict provenance will actually be necessary to avoid losing significant performance compared to today's unsound behavior.)</p>",
        "id": 277019918,
        "sender_full_name": "comex",
        "timestamp": 1648566802
    },
    {
        "content": "<p>That said, there's definitely a possible future where CHERI is everywhere and Rust can have a better story than C does for avoiding accidental provenance loss.  I'm a fan of strict provenance to that extent.</p>",
        "id": 277020072,
        "sender_full_name": "comex",
        "timestamp": 1648566864
    },
    {
        "content": "<p>Still, <em>today</em>, from my perspective, the most important problem with Rust pointers is usability issues caused by Stacked Borrows being too strict.  Trying to improve the situation by making some closely-related semantics <em>stricter</em> just seems completely backwards to meâ€¦</p>",
        "id": 277020475,
        "sender_full_name": "comex",
        "timestamp": 1648567042
    },
    {
        "content": "<p>I think it's entirely possible a rust-specific compiler and optimization framework could take advantage of strict provenance.</p>",
        "id": 277020636,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648567098
    },
    {
        "content": "<p>I agree it's unlikely to appear on any general compilation frameworks any time soon.</p>",
        "id": 277020712,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648567133
    },
    {
        "content": "<p>I think imposing strict semantics that can be adopted by the community to help them express what they mean better than the multi-purpose <code>as usize</code> is a good thing even if the functions have definitions in terms of <code>as usize</code> and such</p>",
        "id": 277020924,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648567212
    },
    {
        "content": "<p>This is my example for the issues we have with FFI. What would the actual limits on what FFI would be capable of? It's easy to say FFI is undefined in the AM (and probably necessary to actually have a coherent spec), but not very useful for actually reasoning about code.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">extern</span><span class=\"w\"> </span><span class=\"s\">\"C\"</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">ptrtoint</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"kt\">usize</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">fn</span> <span class=\"nf\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">p</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">fn</span> <span class=\"nf\">example</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">inttoptr</span><span class=\"p\">(</span><span class=\"n\">ptrtoint</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)));</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277020989,
        "sender_full_name": "Quy Nguyen",
        "timestamp": 1648567241
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> True.  In some ways stricter semantics could actually improve usability by being easier to understand, easier to explicitly reason about, and easier for miri to reason about.  But you could say the same about Stacked Borrows; that doesn't stop it from being a source of a lot of frustration.  In its case, noalias is very nice to have, and so would be the additional optimizations that are allowed under Stacked Borrows even if rustc doesn't perform them today.  In strict provenance's caseâ€¦ well, it might be necessary to avoid a significant performance loss in the name of soundness, or it might not be; there's still a lack of data.</p>",
        "id": 277022428,
        "sender_full_name": "comex",
        "timestamp": 1648567854
    },
    {
        "content": "<p>With the \"tower of weakenings\" approach, it is possible to get <em>most</em> code to meet the high standard, and thereby tolerate more performance degredation in the few places that absolutely need to commit Pointer Crimes</p>",
        "id": 277022750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648568002
    },
    {
        "content": "<p>it doesn't have to be all or nothing, although I am dubious about the only function in strict-provenance for int2ptr being called <code>invalid()</code></p>",
        "id": 277023007,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648568103
    },
    {
        "content": "<p>because people keep bringing it up I have added an entry to the FAQ for wrapping_offset: <a href=\"https://github.com/rust-lang/rust/issues/95228#issuecomment-1075881238\">https://github.com/rust-lang/rust/issues/95228#issuecomment-1075881238</a></p>",
        "id": 277023701,
        "sender_full_name": "Gankra",
        "timestamp": 1648568380
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277020475\">said</a>:</p>\n<blockquote>\n<p>Still, <em>today</em>, from my perspective, the most important problem with Rust pointers is usability issues caused by Stacked Borrows being too strict.  Trying to improve the situation by making some closely-related semantics <em>stricter</em> just seems completely backwards to meâ€¦</p>\n</blockquote>\n<p>I agree, which is why my work and article are entirely focused on introducing new APIs that make using raw pointers in a \"strictly right\" way easier / the default. I am not pushing for the ~ ergonomics stuff because that's syntax/compiler stuff and I cannot \"do\" that stuff and it will bikeshedded into oblivion.</p>",
        "id": 277024062,
        "sender_full_name": "Gankra",
        "timestamp": 1648568503
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span>  That is true.  As I was going to say to <span class=\"user-mention\" data-user-id=\"303115\">@Quy Nguyen</span>, in theory, rustc could allow such FFI calls to have the expected 'provenance broadcast' semantics but be more conservative with optimizations in their presence.  There could be similar functions in the standard library too.  At least then, if you know you're committing Crimes, you have some kind of escape clause (that doesn't work on CHERI).  But a major component of the usability issues with SB is not knowing which things are Crimes in the first place.  Perhaps that's less of an issue with integer&lt;-&gt;pointer casts.</p>",
        "id": 277024066,
        "sender_full_name": "comex",
        "timestamp": 1648568506
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"137587\">@Gankra</span> Fair enough.  I definitely agree that these new APIs are helpful (pretty much regardless of what provenance semantics we end up imposing!).</p>",
        "id": 277024325,
        "sender_full_name": "comex",
        "timestamp": 1648568592
    },
    {
        "content": "<p>But yes part of the motivation of strict provenance is that it is an absolute nightmare to \"teach\" a less strict model</p>",
        "id": 277024400,
        "sender_full_name": "Gankra",
        "timestamp": 1648568617
    },
    {
        "content": "<p>like, \"ok so if you do these 5 things then it triggers a special rule that lets you do a Special Crime\" is a lot harder than \"just do this. if you always do this then you win\"</p>",
        "id": 277024985,
        "sender_full_name": "Gankra",
        "timestamp": 1648568817
    },
    {
        "content": "<p>(I <em>really</em> would strongly encourage folks with ties to lang/compiler to push for something like ~ because it has the exact same \"every question has an easy answer\" effect as strict provenance, but I am not touching that project with a ten-foot pole)</p>",
        "id": 277025652,
        "sender_full_name": "Gankra",
        "timestamp": 1648569070
    },
    {
        "content": "<p>I like ~ but i worry it has a bit of an uphil battle in terms of the syntax. But probably not as much of one as <code>.await</code> had (presumably fewer people will have Opinions)</p>",
        "id": 277025958,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648569179
    },
    {
        "content": "<p>yeah the syntax is whatever, it was just funny to me to \"resurrect\" the friend i never got to have</p>",
        "id": 277026248,
        "sender_full_name": "Gankra",
        "timestamp": 1648569268
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277004403\">said</a>:</p>\n<blockquote>\n<p>I really dislike the usability impact of having to declare things with different signatures than they have in C.  Especially if you're using bindgen to automatically bind to C headersâ€¦</p>\n</blockquote>\n<p>yeah it's not great. but also C is just wrong... like even C itself is moving to PNVI, as in \"provenance <em>not</em> via integers\", which means an integer type is <em>not</em> a universal type that holds all kinds of data. sadly this realization comes a bit too late for some existing APIs, so there will be some amount of friction.</p>",
        "id": 277026569,
        "sender_full_name": "RalfJ",
        "timestamp": 1648569385
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277015818\">said</a>:</p>\n<blockquote>\n<p>i cannot imagine there ever being a coherent system that would miscompile code conforming to strict-provenance</p>\n</blockquote>\n<p>FWIW I agree, all the wild miscompilation examples I know involve int2ptr casts and expecting the ptr to somehow obtain \"useful\" provenance through magic or so</p>",
        "id": 277026870,
        "sender_full_name": "RalfJ",
        "timestamp": 1648569496
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277026569\">said</a>:</p>\n<blockquote>\n<p>yeah it's not great. but also C is just wrong... like even C itself is moving to PNVI, as in \"provenance <em>not</em> via integers\", which means an integer type is <em>not</em> a universal type that holds all kinds of data. sadly this realization comes a bit too late for some existing APIs, so there will be some amount of friction.</p>\n</blockquote>\n<p>Eh, under PNVI it's still a universal type in every practical sense, just one that might block optimizations you probably don't care about.  (CHERI is a different matterâ€¦)</p>",
        "id": 277027053,
        "sender_full_name": "comex",
        "timestamp": 1648569566
    },
    {
        "content": "<p>well it is not universal in the sense that converting a ptr to int and back is lossy</p>",
        "id": 277027209,
        "sender_full_name": "RalfJ",
        "timestamp": 1648569604
    },
    {
        "content": "<p>though I guess you are right that on the surface level that loss only means fewer optimizations (and a more complicated memory model)</p>",
        "id": 277027347,
        "sender_full_name": "RalfJ",
        "timestamp": 1648569631
    },
    {
        "content": "<p>in the optimizer this is super relevant though, LLVM regularly assumes that <code>iN</code> is universal in a non-lossy way</p>",
        "id": 277027420,
        "sender_full_name": "RalfJ",
        "timestamp": 1648569654
    },
    {
        "content": "<p>and being able to do things that are \"obviously\" UB like smuggled UAFs</p>",
        "id": 277027474,
        "sender_full_name": "Gankra",
        "timestamp": 1648569669
    },
    {
        "content": "<p>I should actually mention this \"tower of weakenings\" concept in the FAQ</p>",
        "id": 277027768,
        "sender_full_name": "Gankra",
        "timestamp": 1648569751
    },
    {
        "content": "<p>Sidenote: When it comes to C API design, I used to think that <code>uintptr_t</code> was <em>better</em> than <code>void *</code> for opaque values and should be preferred for new APIs, because the C standard says that converting arbitrary integers to pointers is implementation-defined and (depending on the implementation) might produce trap representations.  It's also UB to cast pointers to another type if they're misaligned, which is easier to do by accident if you start with <code>void *</code>.  On the other hand, if <code>uintptr_t</code> exists, round tripping <code>void *</code> to <code>uintptr_t</code> and back is at least guaranteed to produce a pointer that compares equal to the original, so it seems like it would be preferable.  But then I learned CHERI was a thing and realized that 'compares equal' isn't necessarily the same thing as 'is equivalent', if the round trip strips runtime provenance. (Though in practice CHERI uses 128-bit <code>uintptr_t</code> and tries not to strip runtime provenance, I think?)  Oh well.  I guess it's a good thing that <code>void *</code> is more common in existing usage.</p>",
        "id": 277028469,
        "sender_full_name": "comex",
        "timestamp": 1648570026
    },
    {
        "content": "<p>ok added under \"Isn't This Model WAY Too Strict?\"</p>",
        "id": 277029617,
        "sender_full_name": "Gankra",
        "timestamp": 1648570504
    },
    {
        "content": "<p>Yeah the CHERI interpretation is basically \"the only really valid use of intptr_t is pointer crimes, so let's assume it is in fact just a pointer\"</p>",
        "id": 277029804,
        "sender_full_name": "Gankra",
        "timestamp": 1648570571
    },
    {
        "content": "<p>with magic analysis to try to propagate the \"correct\" provenance when you have operations like lhs + rhs</p>",
        "id": 277030030,
        "sender_full_name": "Gankra",
        "timestamp": 1648570675
    },
    {
        "content": "<p>(fallback is just \"lhs wins\" aiui)</p>",
        "id": 277030082,
        "sender_full_name": "Gankra",
        "timestamp": 1648570688
    },
    {
        "content": "<p>one nice detail of that approach is that because all of intptr_t's \"typical aliases\" (uint64_t, size_t, ptrdiff_t, ...) are <em>genuinely</em> different sizes from intptr_t so like, anywhere that is using the wrong one can be \"found\" and fixed in porting something to it</p>",
        "id": 277030392,
        "sender_full_name": "Gankra",
        "timestamp": 1648570815
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277026569\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277004403\">said</a>:</p>\n<blockquote>\n<p>I really dislike the usability impact of having to declare things with different signatures than they have in C.  Especially if you're using bindgen to automatically bind to C headersâ€¦</p>\n</blockquote>\n<p>yeah it's not great. but also C is just wrong... like even C itself is moving to PNVI, as in \"provenance <em>not</em> via integers\", which means an integer type is <em>not</em> a universal type that holds all kinds of data. sadly this realization comes a bit too late for some existing APIs, so there will be some amount of friction.</p>\n</blockquote>\n<p>It's also impossible for some apis to update, as stated previously, since sometimes you need a consistent ABI for both 32-bit and 64-bit pointer ABIs.</p>",
        "id": 277030959,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648571079
    },
    {
        "content": "<p>yes indeed we are lacking in expressivity here -- we dont have arbitrarily-sized data with provenance, only ptr-sized data with provenance</p>",
        "id": 277031317,
        "sender_full_name": "RalfJ",
        "timestamp": 1648571226
    },
    {
        "content": "<p>that's where the seams of this are showing. a lot.</p>",
        "id": 277031343,
        "sender_full_name": "RalfJ",
        "timestamp": 1648571234
    },
    {
        "content": "<p>in Rust we have <code>MaybeUninit&lt;u64&gt;</code> as something that can also hold provenance but it's super clunky</p>",
        "id": 277031483,
        "sender_full_name": "RalfJ",
        "timestamp": 1648571289
    },
    {
        "content": "<p><code>union { u64, *const () }</code> is probably our best bet. plus hacks to ensure it has the right ABI.</p>",
        "id": 277031510,
        "sender_full_name": "RalfJ",
        "timestamp": 1648571306
    },
    {
        "content": "<p>Hm, why can MaybeUninit&lt;u64&gt; hold provenance?</p>",
        "id": 277031642,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648571384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277031642\">said</a>:</p>\n<blockquote>\n<p>Hm, why can MaybeUninit&lt;u64&gt; hold provenance?</p>\n</blockquote>\n<p><code>MaybeUninit&lt;T&gt;</code> can hold any bytes at all.</p>",
        "id": 277031801,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648571440
    },
    {
        "content": "<p>Hmm... What happens if you <code>transmute_copy</code> from a pointer over <code>MaybeUninit&lt;u8&gt;</code>?</p>",
        "id": 277031991,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648571525
    },
    {
        "content": "<p>That's useful to know. Is that something that can be relied on though?</p>\n<p>Like, it feels like the kind of thing where if I wrote code to rely on this, then in 3 years we'd be talking about how we need to break that code because it's Always Been Broken <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> anyway.</p>",
        "id": 277032805,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1648571883
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277031991\">said</a>:</p>\n<blockquote>\n<p>Hmm... What happens if you <code>transmute_copy</code> from a pointer over <code>MaybeUninit&lt;u8&gt;</code>?</p>\n</blockquote>\n<p>there generally needs to be a \"memcopy exception\" in any provenance model, and how well that can be defined formally partially depends on things like llvm's \"byte\" type proposal.</p>",
        "id": 277033876,
        "sender_full_name": "Gankra",
        "timestamp": 1648572476
    },
    {
        "content": "<p>just assume your AM has Arm's memcpy instructions</p>",
        "id": 277036201,
        "sender_full_name": "Jubilee",
        "timestamp": 1648573502
    },
    {
        "content": "<p>oh? does ARM do something special?</p>",
        "id": 277036302,
        "sender_full_name": "Gankra",
        "timestamp": 1648573545
    },
    {
        "content": "<p>I am joking but only somewhat. They literally added memcpy instructions that have like exactly the signature of memcpy so that the processor can turn it into a DMA.</p>",
        "id": 277036420,
        "sender_full_name": "Jubilee",
        "timestamp": 1648573590
    },
    {
        "content": "<p>oh lol ok</p>",
        "id": 277036460,
        "sender_full_name": "Gankra",
        "timestamp": 1648573612
    },
    {
        "content": "<p>i thought you meant it did some cute stuff with the v8.3 ptr auth stuff</p>",
        "id": 277036489,
        "sender_full_name": "Gankra",
        "timestamp": 1648573629
    },
    {
        "content": "<p><a href=\"https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-a-profile-architecture-developments-2021\">https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/arm-a-profile-architecture-developments-2021</a></p>",
        "id": 277036890,
        "sender_full_name": "Jubilee",
        "timestamp": 1648573790
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"209168\">Thom Chiovoloni</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277032805\">said</a>:</p>\n<blockquote>\n<p>Like, it feels like the kind of thing where if I wrote code to rely on this, then in 3 years we'd be talking about how we need to break that code because it's Always Been Broken <span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> anyway.</p>\n</blockquote>\n<p>that's why I want a normative formal model, so there are no more excuses like that :D</p>",
        "id": 277041660,
        "sender_full_name": "RalfJ",
        "timestamp": 1648575924
    },
    {
        "content": "<p>yeah.</p>",
        "id": 277047365,
        "sender_full_name": "Jubilee",
        "timestamp": 1648578745
    },
    {
        "content": "<blockquote>\n<p>On all the ABIs and Calling Conventions I know, a pointer-sized-integer and an actual pointer have identical ABIs in the standard calling conventions, making this fixup perfectly fine.</p>\n</blockquote>\n<p>m68k is the thorn in your side here; pointers are returned in %a0, integers are returned in %d0. Arguments are at least the same though, all passed on the stack (yay old hardware...). <a href=\"https://trofi.github.io/posts/191-ghc-on-m68k.html\">https://trofi.github.io/posts/191-ghc-on-m68k.html</a> is an example of this becoming a problem in the real world. Specifically, to quote the psABI (page 3-16, <a href=\"https://m680x0.github.io/ref/sysv-m68k-abi-part2.pdf\">https://m680x0.github.io/ref/sysv-m68k-abi-part2.pdf</a>):</p>\n<blockquote>\n<p>A function that returns an integral value places its result in %d0. A function that returns a pointer value places its result in %a0.</p>\n</blockquote>\n<p>FFI is the one place where I believe you truly do need a uintptr_t-like thing to exist in Rust, even if you can get away without one in the land of pure untainted Rust.</p>\n<p>The m68k psABI is a whole bunch of fun, not least because the official SysV psABI spec is not _quite_ what's implemented in GCC...</p>",
        "id": 277209731,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648677928
    },
    {
        "content": "<p>oooh nice nice ty</p>",
        "id": 277209816,
        "sender_full_name": "Gankra",
        "timestamp": 1648677975
    },
    {
        "content": "<p>well,  actually \"fuck god damnit\" but, y'know,</p>",
        "id": 277209944,
        "sender_full_name": "Gankra",
        "timestamp": 1648678056
    },
    {
        "content": "<p>(the de-facto ABI also being the one that brings you fun like <code>alignof(int, long, void *) == 2</code> but <code>sizeof(int, long, void *) == 4</code>; ponder how that goes down with (a) low-bit pointer tagging (b) Linux's \"On all platforms, futexes are four-byte integers that must be aligned on a four-byte boundary.\"...)</p>",
        "id": 277209958,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648678063
    },
    {
        "content": "<p><code>m68k-unknown-linux-gnu</code> is tier3, I should <code>cfg</code> sptr::uptr off on the platform</p>",
        "id": 277210311,
        "sender_full_name": "Gankra",
        "timestamp": 1648678317
    },
    {
        "content": "<p>lmao</p>",
        "id": 277212772,
        "sender_full_name": "Jubilee",
        "timestamp": 1648680482
    },
    {
        "content": "<p>I think a more flexible approach for FFI specifically would be something like <code>fn f(#[abi(usize)] x: *const ())</code> which would allow some type punning at the ABI level for a small whitelist of type pairs, perhaps replaced by safe-transmute at some point</p>",
        "id": 277234210,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1648703647
    },
    {
        "content": "<p>Yeah, I would be happier to have the raw ABI represented somehow.</p>",
        "id": 277237224,
        "sender_full_name": "cuviper",
        "timestamp": 1648707121
    },
    {
        "content": "<p>I've actually wanted to write some functions even without FFI that transmute their arguments implicitly on the boundaries -- though it's for some <code>ManuallyDrop</code> things where ideally optimizations will fix it eventually</p>",
        "id": 277240602,
        "sender_full_name": "scottmcm",
        "timestamp": 1648710106
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"439664\">Jessica Clarke</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277209958\">said</a>:</p>\n<blockquote>\n<p>(the de-facto ABI also being the one that brings you fun like <code>alignof(int, long, void *) == 2</code> but <code>sizeof(int, long, void *) == 4</code>; ponder how that goes down with (a) low-bit pointer tagging (b) Linux's \"On all platforms, futexes are four-byte integers that must be aligned on a four-byte boundary.\"...)</p>\n</blockquote>\n<p>FWIW, I looked into this a little -- the kernel will simply fail <code>EINVAL</code> if your futex is not 4-byte aligned. And it looks like glibc, musl, and uClibc all get this wrong in their <code>pthread_mutex_t</code>. There is a gcc flag <code>-malign-int</code> for 32-bit alignment, but it's not the default, and it changes your whole ABI.</p>",
        "id": 277317792,
        "sender_full_name": "cuviper",
        "timestamp": 1648749369
    },
    {
        "content": "<p>Yes, on m68k you need <code>__attribute__((aligned(4)))</code> for any futexes. In languages without such a thing it gets more awkward (Go has such issues).</p>",
        "id": 277336599,
        "sender_full_name": "Jessica Clarke",
        "timestamp": 1648758963
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"138448\">cuviper</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/calling.20conventions.20that.20handle.20int.2Bptr.20different.3F/near/277317792\">said</a>:</p>\n<blockquote>\n<p>FWIW, I looked into this a little -- the kernel will simply fail <code>EINVAL</code> if your futex is not 4-byte aligned. And it looks like glibc, musl, and uClibc all get this wrong in their <code>pthread_mutex_t</code>. There is a gcc flag <code>-malign-int</code> for 32-bit alignment, but it's not the default, and it changes your whole ABI.</p>\n</blockquote>\n<p>this is hilarious to me.</p>",
        "id": 277351226,
        "sender_full_name": "Jubilee",
        "timestamp": 1648767580
    },
    {
        "content": "<p>Looks like glibc gets it right actually: <a href=\"https://github.com/bminor/glibc/blob/master/sysdeps/nptl/bits/pthreadtypes.h#L67-L72\">pthread_mutex_t is a union</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">typedef</span><span class=\"w\"> </span><span class=\"k\">union</span>\n<span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"k\">struct</span> <span class=\"nc\">__pthread_mutex_s</span><span class=\"w\"> </span><span class=\"n\">__data</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"kt\">char</span><span class=\"w\"> </span><span class=\"n\">__size</span><span class=\"p\">[</span><span class=\"n\">__SIZEOF_PTHREAD_MUTEX_T</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">  </span><span class=\"n\">long</span><span class=\"w\"> </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">__align</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">pthread_mutex_t</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And <a href=\"https://github.com/bminor/glibc/blob/master/sysdeps/nptl/bits/struct_mutex.h#L29\">__pthread_mutex_s</a> has this field:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">  </span><span class=\"n\">int</span><span class=\"w\"> </span><span class=\"n\">__lock</span><span class=\"w\"> </span><span class=\"n\">__LOCK_ALIGNMENT</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>And <a href=\"https://github.com/bminor/glibc/blob/master/sysdeps/m68k/nptl/bits/pthreadtypes-arch.h#L33\">__LOCK_ALIGNMENT forces 4-byte alignment on m68k</a>:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code>#<span class=\"n\">define</span><span class=\"w\"> </span><span class=\"n\">__LOCK_ALIGNMENT</span><span class=\"w\"> </span><span class=\"n\">__attribute__</span><span class=\"w\"> </span><span class=\"p\">((</span><span class=\"n\">__aligned__</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)))</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277433965,
        "sender_full_name": "Tavian Barnes",
        "timestamp": 1648826352
    },
    {
        "content": "<p>aha! I was distracted by the insufficient <code>long int __align</code></p>",
        "id": 277439456,
        "sender_full_name": "cuviper",
        "timestamp": 1648828662
    }
]