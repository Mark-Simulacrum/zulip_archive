[
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> points out that we break <code>x - x</code> to <code>0</code>, but we could still have <code>with_addr(0, x)</code>. We also break some forms of GVN, although not all of them and it vaguely seems reasonable to recover things here by being smart about inserting <code>with_addr()</code> in the right places. What else do we break?</p>",
        "id": 277473057,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844534
    },
    {
        "content": "<p>(<a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277471945\">context</a>)</p>",
        "id": 277473085,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648844549
    },
    {
        "content": "<p>If <code>x == y</code>, then we can no longer replace <code>x</code> by <code>y</code> or vice versa — not in general</p>",
        "id": 277476134,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648846321
    },
    {
        "content": "<p>Yes, but such a replacement on it's own is not that useful. It's only useful in the context of enabling other optimizations (such as CSE), and I think some examples of particular optimizations that actually benefit runtime on their own are necessary</p>",
        "id": 277478455,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648847677
    },
    {
        "content": "<p>Also, if <code>x == y</code>, you can replace <code>x</code> with <code>y</code> if you can prove any of the following:</p>\n<ul>\n<li><code>x</code> does not come from a pointer</li>\n<li><code>y</code> will not be used as a pointer</li>\n<li><code>y</code> can't equal a valid pointer - say, if it is a small integer constant (depending on the target)</li>\n</ul>",
        "id": 277480360,
        "sender_full_name": "comex",
        "timestamp": 1648848739
    },
    {
        "content": "<p>Also, you can always replace <code>x</code> with <code>x.with_addr(y)</code>.</p>",
        "id": 277480437,
        "sender_full_name": "comex",
        "timestamp": 1648848789
    },
    {
        "content": "<p>Moving the vaguely related question here, to not disrupt:<br>\n<span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277473854\">said</a>:</p>\n<blockquote>\n<p>Sure, explain it.</p>\n</blockquote>\n<p>So, the issue that all of this boils down to is that moves are not elidable. In other words, consider code like this, post inlining:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">;</span><span class=\"w\"></span>\n</code></pre></div>\n<p>As someone who has a semi-decent amount of experience with MIR from the optimization side, I can tell you that this sort of pattern is potentially <em>extremely</em> common. So, first, removing the second and third statement entirely is unsound (as we have established). Replacing them with <code>broadcast_provenance(x);</code> is probably sound. It requires a theorem that says \"replacing integer bytes with pointer bytes as an optimization is sound\" - Ralf and I talked about this a little, and this theorem is probably true, but it is not immediately clear. In any case, even if sound, this optimization is at the very least lossy - that's because it leaves pointer bytes where there were previously integer bytes. This means that future optimizations (such as GVN, CSE, etc.) might not be able to run on this. The best lossless thing that I think we can turn the last two statements into is <code>x = x;</code>. That preserves all information, however it makes things complicated. This is a <em>mutation</em> of the place, which... has a tendency to interfere with other optimizations. We now have to make everything aware of the \"halfway\" nature of this mutation so that it doesn't block on it completely. That seems error prone at the very least, and really something I would want to avoid if at all possible</p>",
        "id": 277480704,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648848942
    },
    {
        "content": "<p>Hold on, that is PNVI, let's not get these mixed up :p</p>",
        "id": 277481007,
        "sender_full_name": "comex",
        "timestamp": 1648849077
    },
    {
        "content": "<p>Yes, maybe we need a different thread for that too <span aria-label=\"laughing\" class=\"emoji emoji-1f606\" role=\"img\" title=\"laughing\">:laughing:</span></p>",
        "id": 277481356,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648849219
    },
    {
        "content": "<p>PVI also means we have to make provenance more complicated -- <code>x+y</code> needs to be able to carry the provenance of <code>x</code> and <code>y</code>. I dont know what this would even mean for Stacked Borrows. you do an operation using a pointer that has two tags... what do you actually do with the borrow stacks? literally no idea.</p>",
        "id": 277530000,
        "sender_full_name": "RalfJ",
        "timestamp": 1648906483
    },
    {
        "content": "<p>in contrast, with PNVI there exists no operation that takes 2 pointers as input and produces a result with provenance. so there always is at most one provenance in a pointer -- at most one stacked borrows tag.</p>",
        "id": 277530028,
        "sender_full_name": "RalfJ",
        "timestamp": 1648906548
    },
    {
        "content": "<p>well, you could do it like union-provenance PNVI - when you cast back to a pointer you can only use it like it was <em>one</em> of the provenances making it up, and just have the uniony bit to make it so that integer addition is still commutative. Alternatively you can say \"xor lists gtfo\" and say that <code>x+y</code> only gives you provenance only if exactly one of them had provenance, which iirc is what the C PVI proposal does. (Which is basically the same reasoning as the \"every operation should be <code>ptr op usize = ptr</code>\")</p>",
        "id": 277542842,
        "sender_full_name": "Talchas",
        "timestamp": 1648922448
    },
    {
        "content": "<p>I dont think that union approach works for more complicated models of provenance, like SB</p>",
        "id": 277627917,
        "sender_full_name": "RalfJ",
        "timestamp": 1648992022
    },
    {
        "content": "<p>How about modeling union provenance like this, very vaguely speaking: a pointer doesn't just have one borrow stack but can be 'entangled' with multiple different borrow stacks.  They don't interact with each other; operations that modify the stacks do so to each of them in parallel.  Accessing the pointer is allowed if it would be allowed under any of the stacks.</p>",
        "id": 277802028,
        "sender_full_name": "comex",
        "timestamp": 1649111016
    },
    {
        "content": "<p>(Though I'm open to saying \"xor lists gtfo\", at least to some extent.  I have yet to encounter a single xor list being used in real code.)</p>",
        "id": 277802248,
        "sender_full_name": "comex",
        "timestamp": 1649111158
    },
    {
        "content": "<p>I'm not entirely sure what you're getting at. In Stacked Borrows, a borrow stack belongs to a byte of memory, not a pointer.</p>",
        "id": 277802734,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649111487
    },
    {
        "content": "<p>What you're suggesting sounds vaguely like union provenance, which I personally object to because it's essentially uncheckable due to state space explosion, though I know not everyone shares that concern</p>",
        "id": 277802845,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649111543
    },
    {
        "content": "<p>I would be interested to see an extension of Miri that actually does the state space explosion though. Especially if exposed pointers are usually unique it might not be that bad in practice. Loom seems to manage pretty well</p>",
        "id": 277804556,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649112668
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"198590\">@comex</span> I don't think that implementation is precise: you can get literal \"entanglement\" of multiple borrow stacks by copying pointers around or reborrowing from a one multi-stack pointer and saving the reference somewhere else</p>",
        "id": 277804732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649112805
    },
    {
        "content": "<p>by interacting with the borrow you can end up \"collapsing\" one of the entangled states so you have to find all the places that state appears in memory to clear it</p>",
        "id": 277804871,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649112898
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F/near/277802734\">said</a>:</p>\n<blockquote>\n<p>I'm not entirely sure what you're getting at. In Stacked Borrows, a borrow stack belongs to a byte of memory, not a pointer.</p>\n</blockquote>\n<p>I was misremembering how Stacked Borrows works :)</p>",
        "id": 277813582,
        "sender_full_name": "comex",
        "timestamp": 1649119208
    },
    {
        "content": "<p>And yes, as I said, I was trying to specify union provenance.</p>",
        "id": 277813731,
        "sender_full_name": "comex",
        "timestamp": 1649119262
    },
    {
        "content": "<p>After refreshing myself on how Stacked Borrows really works… It never copies a tag from a pointer to a byte, does it?  So why isn't it even easier than I thought before?  A pointer just has a list of tags, and the granting item is the topmost one that matches any of the tags.</p>",
        "id": 277815126,
        "sender_full_name": "comex",
        "timestamp": 1649120192
    },
    {
        "content": "<p>Quite possibly I'm missing something (again).</p>",
        "id": 277815136,
        "sender_full_name": "comex",
        "timestamp": 1649120202
    },
    {
        "content": "<p>There's no state space explosion there.</p>",
        "id": 277815150,
        "sender_full_name": "comex",
        "timestamp": 1649120215
    },
    {
        "content": "<p>What about ZSTs?</p>",
        "id": 277815422,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649120431
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F/near/277815126\">said</a>:</p>\n<blockquote>\n<p>After refreshing myself on how Stacked Borrows really works… It never copies a tag from a pointer to a byte, does it?  So why isn't it even easier than I thought before?  A pointer just has a list of tags, and the granting item is the topmost one that matches any of the tags.</p>\n</blockquote>\n<p>This might not be what the user wants though. Imagine that we're talking about <code>UnsafeCell&lt;T&gt;</code> memory here - that makes this easiest to demonstrate, but I think you can actually create the same problem just using disabling and no <code>UnsafeCell</code>. Lets say the stack contains  <code>[a SRW, b Unique, c SRW]</code> and on int to pointer cast creating pointer <code>p</code>, I pick up tags <code>a</code> and <code>c</code>. Now I do <code>q = &amp;*p</code>, I get granted access from <code>c</code>, and so <code>q</code> has tag <code>d</code> and the stack gets a <code>d SRW</code> on top. Now I use some pointer that has tag <code>b</code> to write to the memory, and so <code>c</code> and <code>d</code> get popped off. This means that <code>q</code> is invalid and UB to use.</p>\n<p>In the fully non-deterministic model, this would be a non-issue, because the non-deterministic choice of tag <code>a</code> for <code>p</code> would give us DB. Essentially, this smells a lot like the problem with untagged raw pointers - its possible to accidentally reborrow too high up the stack, against the users intentions</p>",
        "id": 277816278,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649121257
    },
    {
        "content": "<p>I'm much more deep into the implementation as opposed to the theory, unlike most people here, so I'm trying to participate based on what I know.</p>\n<p>With respect to state explosion, we <em>already</em> have a memory explosion problem in Stacked Borrows. My favorite example is the <code>regex</code> crate. Normally, its tests require 155 MB of memory. In Miri with raw pointer tagging I don't know how much memory its requires, because it OOMs on my desktop which has 128 GB. It's uncommon to see this degree of explosion, but 1,000x is pretty bad, so I'm very wary of things that would make the situation worse. We have some ideas that might make the situation better but the complexity cost is pretty massive.</p>",
        "id": 277816446,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649121395
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> Hmm, but in the alternate universe where you reborrowed from <code>a</code>, doesn't that disable <code>b</code> and make the write through <code>b</code> UB?</p>",
        "id": 277816569,
        "sender_full_name": "comex",
        "timestamp": 1649121561
    },
    {
        "content": "<p>No, not for <code>UnsafeCell</code></p>",
        "id": 277816578,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649121580
    },
    {
        "content": "<p>Are you sure?  A <code>Unique</code> above an <code>SRW</code> should be what you'd get if you called <code>get_mut()</code> on the <code>UnsafeCell</code> to get an <code>&amp;mut T</code>… You definitely can't mutate the original UnsafeCell interchangeably with the mutable reference.</p>",
        "id": 277816760,
        "sender_full_name": "comex",
        "timestamp": 1649121806
    },
    {
        "content": "<p>(… and then to get another SharedReadWrite on top, I guess the type would have to be <code>UnsafeCell&lt;UnsafeCell&lt;T&gt;&gt;</code>, so first you call <code>get_mut()</code> to get <code>&amp;mut UnsafeCell&lt;T&gt;</code>, and then you reborrow as immutable to get <code>&amp;UnsafeCell&lt;T&gt;</code>...)</p>",
        "id": 277816879,
        "sender_full_name": "comex",
        "timestamp": 1649121917
    },
    {
        "content": "<p>No, the code that should give this behavior is this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">UnsafeCell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a_prev</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a_prev</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">broadcast</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b_prev</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">b_prev</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">c</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">broadcast</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// [a_prev SRW, a SRW, b_prev SRW, b Unique, c SRW]</span>\n\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">p</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">addr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">UnsafeCell</span><span class=\"o\">&lt;</span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// either `a` or `c`</span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">q</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;*</span><span class=\"n\">p</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"c1\">// Since this gets `c` perms, stack is now `[a_prev SRW, a SRW, b_prev SRW, b Unique, c SRW, d SRW]`</span>\n<span class=\"c1\">// However, if this had `a` perms, the stack would be `[a_prev SRW, a SRW, d SRW, b_prev SRW, b Unique, c SRW]`</span>\n<span class=\"o\">*</span><span class=\"n\">b</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"fm\">dbg!</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">q</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">());</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277817443,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649122504
    },
    {
        "content": "<p>This is the special handling of shared references for <code>UnsafeCell</code></p>",
        "id": 277817460,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649122530
    },
    {
        "content": "<p>Oh, because retagging by itself doesn't pop...</p>",
        "id": 277817773,
        "sender_full_name": "comex",
        "timestamp": 1649122918
    },
    {
        "content": "<p>I'd like to understand better why it's that way, but not now.</p>",
        "id": 277818131,
        "sender_full_name": "comex",
        "timestamp": 1649123352
    },
    {
        "content": "<p>Of course, if integers <em>don't</em> have provenance, then you can get the same problem with any form of unrestricted ptr2int2ptr (even a limited one that only works through FFI or whatever - and even on CHERI!), so we can't realistically avoid running into this problem somewhere in the model.</p>",
        "id": 277818769,
        "sender_full_name": "comex",
        "timestamp": 1649124047
    },
    {
        "content": "<p>Realistically, I suppose, the biggest problem with PVI is simply that the C committee as well as, according to <span class=\"user-mention\" data-user-id=\"218745\">@Wanja Hentze</span>, LLVM and GCC have, for some time, had buy-in on PNVI-ae for C.  So while neither compiler seems to have started making the sacrifices needed to be sound under PNVI-ae, it's plausible that they will at some point.  And if they do, they are not going to be interested in also making the sacrifices needed to be sound under PVI.</p>",
        "id": 277819908,
        "sender_full_name": "comex",
        "timestamp": 1649125288
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"198590\">comex</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F/near/277817773\">said</a>:</p>\n<blockquote>\n<p>Oh, because retagging by itself doesn't pop...</p>\n</blockquote>\n<p>Well, it does, but not for <code>UnsafeCell</code>. <code>UnsafeCell</code> comes with its own set of rules because I need to be able to reborrow/move references to <code>UnsafeCell</code> on one thread while writing on another thread</p>",
        "id": 277828899,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1649136183
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F/near/277816446\">said</a>:</p>\n<blockquote>\n<p>With respect to state explosion, we <em>already</em> have a memory explosion problem in Stacked Borrows. My favorite example is the <code>regex</code> crate. Normally, its tests require 155 MB of memory. In Miri with raw pointer tagging I don't know how much memory its requires, because it OOMs on my desktop which has 128 GB. It's uncommon to see this degree of explosion, but 1,000x is pretty bad, so I'm very wary of things that would make the situation worse. We have some ideas that might make the situation better but the complexity cost is pretty massive.</p>\n</blockquote>\n<p>Sure, state explosion hurts and it probably can't be used on real world tests, but it could be useful for small tricky examples at least. Even if there is exponential state explosion, if it is not undecidable then I think there is a lot of value in having something that can actually answer the question \"is this UB\" without false negatives or false positives</p>",
        "id": 277840736,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649145788
    },
    {
        "content": "<p>I was thinking of not making it the default option at all, just an optional command line argument or a separate tool entirely</p>",
        "id": 277840768,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649145823
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"310518\">@Jak{e,ob} Degen</span> Okay, <em>now</em> I see how what you're saying matches up with the spec.</p>",
        "id": 277895429,
        "sender_full_name": "comex",
        "timestamp": 1649172162
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20PVI.20-.20What.20optimizations.20does.20it.20break.3F/near/277804556\">said</a>:</p>\n<blockquote>\n<p>I would be interested to see an extension of Miri that actually does the state space explosion though. Especially if exposed pointers are usually unique it might not be that bad in practice. Loom seems to manage pretty well</p>\n</blockquote>\n<p>I dont disagree, but uff the pain of implementing this^^</p>",
        "id": 277922923,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183116
    },
    {
        "content": "<p>I'm sure it could be done with a SAT solver <span aria-label=\"sob\" class=\"emoji emoji-1f62d\" role=\"img\" title=\"sob\">:sob:</span></p>",
        "id": 277923724,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649183396
    },
    {
        "content": "<p>I dont see how that would help at all^^</p>",
        "id": 277924560,
        "sender_full_name": "RalfJ",
        "timestamp": 1649183660
    },
    {
        "content": "<p>In practice, or how to implement it?</p>",
        "id": 277941267,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649191729
    },
    {
        "content": "<p>I can sketch it</p>",
        "id": 277941286,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649191744
    },
    {
        "content": "<p>-&gt; <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Checking.20permissive.20provenance.20with.20SMT\">#t-lang/wg-unsafe-code-guidelines &gt; Checking permissive provenance with SMT</a></p>",
        "id": 277944980,
        "sender_full_name": "Bram Geron",
        "timestamp": 1649193616
    }
]