[
    {
        "content": "<p>For an example, <a href=\"https://github.com/rust-lang/miri/issues/1526\">see this issue</a>. Essentially, the problem with raw pointer tagging is that the borrow stack may have many untagged items, and it's very hard to know which of those untagged items your use of a raw pointer will match. cc <span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> who I think had some cool examples of this</p>",
        "id": 277336578,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648758953
    },
    {
        "content": "<p>Sure, here's one of my favorites</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"fm\">vec!</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>This <code>Vec</code> is not mutable, and yet under SB without raw pointer tagging, you can convert a shared reference to one of its elements to a mutable reference and mutate through it.</p>",
        "id": 277337107,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648759247
    },
    {
        "content": "<p>yeah so... what's the question here? ;)<br>\nthis is what happens when one tries to support ptr2int2ptr roundtrips without an exploding state space^^</p>",
        "id": 277338227,
        "sender_full_name": "RalfJ",
        "timestamp": 1648759879
    },
    {
        "content": "<p>Ah, sorry, should have linked: <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277335957\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance/near/277335957</a></p>",
        "id": 277338312,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648759919
    },
    {
        "content": "<p>I've noticed in conversations that people are mostly not familiar with how strange and chaotic SB without raw pointer tagging is. There's a good example on the UCG repo of the fragility of code that it accepts, but what I'm pointing out with this example is just that I find a lot of code that it accepts defies intuition that we teach in safe Rust.</p>",
        "id": 277338600,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648760073
    },
    {
        "content": "<p>yes</p>",
        "id": 277341698,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761630
    },
    {
        "content": "<p>the evaluation criteria for original SB (without raw ptr tagging) is \"are these optimizations correct\". and they are.</p>",
        "id": 277341743,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761665
    },
    {
        "content": "<p>IOW, the extra UB introduced by raw ptr tagging doesn't help a lot for optimizations</p>",
        "id": 277341758,
        "sender_full_name": "RalfJ",
        "timestamp": 1648761679
    },
    {
        "content": "<p>What optimizations? Are they in the paper?</p>",
        "id": 277341967,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648761795
    },
    {
        "content": "<p>Okay, this is important then. My proposal in <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance\">#t-lang/wg-unsafe-code-guidelines &gt; Strict provenance</a> isn't very good if untagged pointers don't work well</p>",
        "id": 277342946,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648762252
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277336578\">said</a>:</p>\n<blockquote>\n<p>For an example, <a href=\"https://github.com/rust-lang/miri/issues/1526\">see this issue</a>. Essentially, the problem with raw pointer tagging is that the borrow stack may have many untagged items, and it's very hard to know which of those untagged items your use of a raw pointer will match. cc <span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> who I think had some cool examples of this</p>\n</blockquote>\n<p>I think it could be argued (from a CHERI point of view) that you need to \"enable/broadcast\" <code>a</code> first with <code>&amp;a as *const _</code></p>",
        "id": 277343274,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648762502
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277337107\">said</a>:</p>\n<blockquote>\n<p>This <code>Vec</code> is not mutable, and yet under SB without raw pointer tagging, you can convert a shared reference to one of its elements to a mutable reference and mutate through it.</p>\n</blockquote>\n<p>This matches my intuition that really, <code>*const</code> = <code>*mut</code>, it's just decoration</p>",
        "id": 277343305,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648762527
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277341967\">said</a>:</p>\n<blockquote>\n<p>What optimizations? Are they in the paper?</p>\n</blockquote>\n<p>yes</p>",
        "id": 277343333,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762543
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277342946\">said</a>:</p>\n<blockquote>\n<p>Okay, this is important then. My proposal in <a class=\"stream-topic\" data-stream-id=\"136281\" href=\"/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Strict.20provenance\">#t-lang/wg-unsafe-code-guidelines &gt; Strict provenance</a> isn't very good if untagged pointers don't work well</p>\n</blockquote>\n<p>well, okay so I may have to relativize</p>",
        "id": 277343400,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762573
    },
    {
        "content": "<p>default SB is very aggressive with untagging</p>",
        "id": 277343409,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762580
    },
    {
        "content": "<p>like, all raw ptrs are untagged</p>",
        "id": 277343418,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762585
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277343274\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"310518\">Jak{e,ob} Degen</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277336578\">said</a>:</p>\n<blockquote>\n<p>For an example, <a href=\"https://github.com/rust-lang/miri/issues/1526\">see this issue</a>. Essentially, the problem with raw pointer tagging is that the borrow stack may have many untagged items, and it's very hard to know which of those untagged items your use of a raw pointer will match. cc <span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> who I think had some cool examples of this</p>\n</blockquote>\n<p>I think it could be argued (from a CHERI point of view) that you need to \"enable/broadcast\" <code>a</code> first with <code>&amp;a as *const _</code></p>\n</blockquote>\n<p>The problem isn't the ptr to int stuff, it's SB without raw pointer tagging in general. The \"int to ptr gives an untagged raw pointer\" only makes sense if untagged raw pointers exist at all</p>",
        "id": 277343424,
        "sender_full_name": "Jak{e,ob} Degen",
        "timestamp": 1648762592
    },
    {
        "content": "<p><code>Vec</code> uses tons of raw ptrs so there is untagged everywhere</p>",
        "id": 277343427,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762595
    },
    {
        "content": "<p>but I think it should be possible, at least with future generations of aliasing models, to only do the 'untagged' thing when doing <code>ptr as usize</code>. which <code>Vec</code> doesn't do so there is no problem there.<br>\nalso the only pointers that would be untagged are those produced by int2ptr. so code not using int2ptr would still be effectively using full tagging.</p>",
        "id": 277343513,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762677
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"465167\">@Bram Geron</span> So can you explain why in this code, converting to a raw pointer does not give you the ability to do writes?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277343606,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648762720
    },
    {
        "content": "<p>Same deal with this code</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 277343659,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648762772
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> why would it give you the ability to do writes?</p>",
        "id": 277343813,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762853
    },
    {
        "content": "<p>it does in current SB because current SB basically treats all ref-to-raw conversions like ptr2int, and all raw-to-ref as int2ptr</p>",
        "id": 277343835,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762870
    },
    {
        "content": "<p>Sure. Your <code>&amp;[T]</code> may come from a function argument. And rustc will optimize the caller assuming that the array doesn't change. So SB must prevent your code must changing the array.</p>",
        "id": 277343843,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648762873
    },
    {
        "content": "<p>like, raw pointers are basically integers for default SB</p>",
        "id": 277343849,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762883
    },
    {
        "content": "<p>This matches my view that <code>*mut</code> doesn't give you any extra abilities over <code>*const</code></p>",
        "id": 277343866,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648762907
    },
    {
        "content": "<p>that is <em>clearly</em> crazy. I did it because I wanted to be <em>sure</em> that integer roundtrips work well in SB. So I made sure they happen all the time.</p>",
        "id": 277343880,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762921
    },
    {
        "content": "<p>SB decides if you're allowed to write. The type system doesn't decide any more</p>",
        "id": 277343918,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648762924
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277343843\">said</a>:</p>\n<blockquote>\n<p>Sure. Your <code>&amp;[T]</code> may come from a function argument. And rustc will optimize the caller assuming that the array doesn't change. So SB must prevent your code must changing the array.</p>\n</blockquote>\n<p>Why doesn't this logic apply to an immutable <code>Vec&lt;u8&gt;</code>? <code>Vec</code> does not contain any interior mutability.</p>",
        "id": 277343932,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648762945
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277343866\">said</a>:</p>\n<blockquote>\n<p>This matches my view that <code>*mut</code> doesn't give you any extra abilities over <code>*const</code></p>\n</blockquote>\n<p>note that if <code>x: &amp;mut T</code>, then <code>x as *const T as *mut T</code> gives you a <em>read-only</em> pointer in SB</p>",
        "id": 277343941,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762954
    },
    {
        "content": "<p>Hm. That's weird.</p>",
        "id": 277343954,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648762971
    },
    {
        "content": "<p>it is and it isnt...</p>",
        "id": 277343958,
        "sender_full_name": "RalfJ",
        "timestamp": 1648762982
    },
    {
        "content": "<p>the borrow checker will let you write <code>x as *const T</code> in some sitatiuons where you are not allowed to write <code>x as *mut T</code></p>",
        "id": 277343981,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763000
    },
    {
        "content": "<p>so in ref-to-raw casts, the type you cast to clearly matters</p>",
        "id": 277343994,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763014
    },
    {
        "content": "<p>SB reflects that</p>",
        "id": 277343995,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763016
    },
    {
        "content": "<p>feel free to read <a href=\"https://github.com/rust-lang/rust/issues/56604\">https://github.com/rust-lang/rust/issues/56604</a> for all the glory details :D</p>",
        "id": 277344050,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763043
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277343981\">said</a>:</p>\n<blockquote>\n<p>the borrow checker will let you write <code>x as *const T</code> in some sitatiuons where you are not allowed to write <code>x as *mut T</code></p>\n</blockquote>\n<p>Remind me why it's helpful to forbid <code>x as *mut T</code> sometimes <span aria-label=\"thinking\" class=\"emoji emoji-1f914\" role=\"img\" title=\"thinking\">:thinking:</span></p>",
        "id": 277344348,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648763277
    },
    {
        "content": "<p>helpful? no idea. borrowck does it.^^</p>",
        "id": 277344542,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763380
    },
    {
        "content": "<p>it lets you do <code>x as *mut T</code> only when you can also do <code>&amp;mut *x</code></p>",
        "id": 277344553,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763391
    },
    {
        "content": "<p>i.e., it doesnt let you do it when there are outstanding shared loans</p>",
        "id": 277344570,
        "sender_full_name": "RalfJ",
        "timestamp": 1648763400
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277343606\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"465167\">Bram Geron</span> So can you explain why in this code, converting to a raw pointer does not give you the ability to do writes?</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">v</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">v</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"mi\">1</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>Here I can see an argument: <code>&amp;[0u8]</code> may have type <code>&amp;'static [u8]</code>.</p>\n<p>I think we could stack-allocate the array at runtime, and then the miri encoding could create a <code>Unique</code>, making your program legal.</p>\n<blockquote>\n<p>same version but with <code>&amp;mut [0u8]</code></p>\n</blockquote>\n<p>I don't understand why miri should reject this. <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> ?</p>",
        "id": 277344826,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648763555
    },
    {
        "content": "<p>The question here isn't <em>why</em> Miri should reject this code. That's not what my complaint about SB with raw pointer tagging is.</p>",
        "id": 277345364,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648763865
    },
    {
        "content": "<p>My concern about SB without raw pointer tagging is that teaching it to people is a can of worms and the examples defy common intuition.</p>\n<p>In the majority of cases when I see code that Miri rejects without raw pointer tagging, I turn on raw pointer tagging and hope that no other code in the project is rejected, in order to debug the code.</p>",
        "id": 277345534,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648763977
    },
    {
        "content": "<p>Or if you like, understand what code pattern the model doesn't accept, if you don't consider code which is rejected by Miri to be buggy ;)</p>",
        "id": 277345610,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648764007
    },
    {
        "content": "<p>If your argument is that SB is needlessly restrictive in the context of CHERI, then I can see that point</p>",
        "id": 277346042,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764221
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> yes so that is fixed by the hypothetical stacked-borrows-untagged-integers</p>",
        "id": 277346044,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764222
    },
    {
        "content": "<p>which might not be coherent but I hope some future variant of stacked borrows will make it coherent</p>",
        "id": 277346070,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764242
    },
    {
        "content": "<p>But as Rust lacks <code>volatile</code>, I think it might have to be so restrictive</p>",
        "id": 277346120,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764254
    },
    {
        "content": "<p>eh... Rust has volatile and what does that have to do with anything??^^</p>",
        "id": 277346158,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764272
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> Can you think of a model that's easier to explain that still allows for \"Rusty\" optimizations?</p>",
        "id": 277346172,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764282
    },
    {
        "content": "<p>SB with raw pointer tagging ;)</p>",
        "id": 277346200,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648764303
    },
    {
        "content": "<p>:D</p>",
        "id": 277346206,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764308
    },
    {
        "content": "<p>right so stacked-borrows-untagged-integers behaves exactly like SB with raw pointer tagging on programs that are strict aliasing conformant</p>",
        "id": 277346236,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764330
    },
    {
        "content": "<p>so I dont think you have to be worried here <span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span></p>",
        "id": 277346259,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764352
    },
    {
        "content": "<p>assuming I can make stacked-borrows-untagged-integers actually work, that is ;)</p>",
        "id": 277346267,
        "sender_full_name": "RalfJ",
        "timestamp": 1648764358
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/SB.20Without.20Raw.20Pointer.20Tagging/near/277346158\">said</a>:</p>\n<blockquote>\n<p>eh... Rust has volatile and what does that have to do with anything??^^</p>\n</blockquote>\n<p>Never mind, poor choice of words</p>",
        "id": 277346335,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764381
    },
    {
        "content": "<p>What is SB with raw pointer tagging?</p>",
        "id": 277346493,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764483
    },
    {
        "content": "<p>(and how is it easier to explain)</p>",
        "id": 277346535,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764510
    },
    {
        "content": "<p>Raw pointers inherit properties strictly based on what they were created from. If your raw pointer comes from a <code>&amp;T</code>, it cannot be used for writes. If it comes from a <code>&amp;mut T</code>, it can.</p>\n<p>There's no spooky action at a distance, like there is without raw pointer tagging. All of the examples I pasted above are rejected by SB with raw pointer tagging, because they all attempt to mutate through a pointer which descends from a <code>&amp;T</code>.</p>",
        "id": 277346809,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648764649
    },
    {
        "content": "<p>There is of course a lot more to it. And it rejects a lot more code because <code>const</code> vs <code>mut</code> is just a lint, so people have been sort of trained that all raw pointers are equivalent. But they aren't, and they're not the same in SB without raw pointer tagging for action-at-a-distance reasons, but in SB with raw pointer tagging, it's all much more local.</p>",
        "id": 277346995,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648764743
    },
    {
        "content": "<p>Also, I can write good Miri diagnostics for SB with raw pointer tagging. Without it, diagnostics involve literal guesswork and luck.</p>",
        "id": 277347051,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648764788
    },
    {
        "content": "<p>So, the tag is just a boolean?</p>",
        "id": 277347082,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764815
    },
    {
        "content": "<p>(quite something else than <code>untagged</code> in the context of the SB paper)</p>",
        "id": 277347167,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648764855
    },
    {
        "content": "<p>I cannot speak to the paper. I'm doing my best to exit academia, but <em>certain people</em> seem to be pulling me back in. I can speak to the implementation in Miri.</p>",
        "id": 277347226,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648764903
    },
    {
        "content": "<p>\"Tag\" is somewhat of a misnomer. Borrow stacks contain Items, and each Item is a Tag, a Permission, and a Protector. This is always the case, but in SB without raw pointer tagging there is a special tag Untagged which may appear many times in a borrow stack. All other tags may only appear once in a borrow stack.</p>",
        "id": 277347267,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648764943
    },
    {
        "content": "<p>What information does a tag contain?</p>",
        "id": 277347419,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648765032
    },
    {
        "content": "<p>A tag is just a unique identifier for a pointer.</p>",
        "id": 277347529,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648765090
    },
    {
        "content": "<p>You may want to read this <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md\">https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md</a> or this <a href=\"https://github.com/rust-lang/miri/blob/master/src/stacked_borrows.rs\">https://github.com/rust-lang/miri/blob/master/src/stacked_borrows.rs</a></p>",
        "id": 277347556,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1648765116
    },
    {
        "content": "<p>Thanks</p>",
        "id": 277347703,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648765236
    },
    {
        "content": "<p>So: enabling \"tagging\" in miri will reject more programs. I don't think we should necessarily go there for a specification of Rust (make more programs UB) but good to know.</p>",
        "id": 277347923,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648765366
    },
    {
        "content": "<p>Then again, maybe we'll want to mark memory read-only for CHERI. Could be very very desirable.</p>",
        "id": 277348073,
        "sender_full_name": "Bram Geron",
        "timestamp": 1648765464
    }
]