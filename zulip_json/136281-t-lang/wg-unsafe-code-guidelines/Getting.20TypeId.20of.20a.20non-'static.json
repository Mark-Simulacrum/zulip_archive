[
    {
        "content": "<p>Heya. I'm working with a datastructure in the same class of <code>GhostCell</code> where a token is given out and all accesses to the data structure have the same lifetime. I'm under the impression that it would be okay to get a TypeId of a non-'static lifetime internal to the structure, as all references will have the exact same <code>'id</code> (the invariant + closured lifetime). I assume TypeId only works on <code>'static</code> to ensure that you don't compare types of different lifetimes? But in my case all the lifetimes inside the structure will always be identical at compile time.</p>\n<p>Although, I'm not even sure if it's possible to do <code>T: 'id</code> -&gt; <code>T: 'static</code> in any way in Rust?</p>",
        "id": 277797718,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649108512
    },
    {
        "content": "<p>Not for a generic <code>T</code>.</p>",
        "id": 277798893,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649109166
    },
    {
        "content": "<p>If you know the specific <code>T</code>, you can just instantiate it with <code>'static</code> instead.</p>",
        "id": 277798935,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649109188
    },
    {
        "content": "<p>I wonder if there should be a library way to get a <code>TypeId</code> for a non-<code>'static</code> type by erasing lifetimes. Something like <code>TypeId::of_erased::&lt;T&gt;()</code>.</p>",
        "id": 277798998,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649109231
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Getting.20TypeId.20of.20a.20non-'static/near/277798935\">said</a>:</p>\n<blockquote>\n<p>If you know the specific <code>T</code>, you can just instantiate it with <code>'static</code> instead.</p>\n</blockquote>\n<p>Hmm, sadly I don't think I can do that here. I'll have to think about my design a bit</p>",
        "id": 277799089,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649109266
    },
    {
        "content": "<p>Yeah, with the influx of new code doing the invariant lifetimes, being able to compare types at compile time, when you know all types _only_ contain references using that invariant lifetime I think there's some crazy stuff that could be done</p>",
        "id": 277799149,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649109313
    },
    {
        "content": "<p>I think that's sound? Assuming you only ever compare types of the same invariant lifetime, I think TypeId is always okay there?</p>",
        "id": 277799190,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649109335
    },
    {
        "content": "<p>depending on what exactly you're doing you might accidentally allow turning <code>Foo&lt;Tag&lt;'a&gt;, &amp;'x i32&gt;</code> into <code>Foo&lt;Tag&lt;'a&gt;, &amp;'y i32&gt;</code>, but that might be impossible in your use case</p>",
        "id": 277800221,
        "sender_full_name": "Talchas",
        "timestamp": 1649109855
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Getting.20TypeId.20of.20a.20non-'static/near/277800221\">said</a>:</p>\n<blockquote>\n<p>depending on what exactly you're doing you might accidentally allow turning <code>Foo&lt;Tag&lt;'a&gt;, &amp;'x i32&gt;</code> into <code>Foo&lt;Tag&lt;'a&gt;, &amp;'y i32&gt;</code>, but that might be impossible in your use case</p>\n</blockquote>\n<p>I think it should be in my case. It's a shared pool allocator where multiple threads can allocate from, initialize (once), and then share the references <code>usize</code>s with different cores (if the <code>T</code> is <code>Sync</code>). All types are a <code>NumaRef&lt;'id, T&gt;</code> where <code>T: ?Sized + 'id</code> and <code>'id</code> is the invariant reference itself. It's a complex design, still kinda working on it in my head but I think it all checks out.</p>",
        "id": 277800453,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649110002
    },
    {
        "content": "<p>Since all the references are <code>usize</code>, and only ever in the <code>NumaPool</code>, it allows the pool to be moved, and for threads to use their thread-local copy by simply a different pointer. All data structures thus only can reference other <code>NumaRef</code>s with the same <code>'id</code>, everything is kept \"internal\" to the pool and immutable<br>\nMy specific goal with the <code>TypeId</code> stuff here, is that I can maintain a map of <code>TypeId, Vec&lt;NumaRef&lt;'id&gt;&gt;</code> which allows me to get any <code>T: 'id</code> in the database.</p>",
        "id": 277800600,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649110085
    },
    {
        "content": "<p>Here's the current \"implementation\" I think it's fairly solid, but I'm sure there are still some edge cases <a href=\"https://gist.github.com/gamozolabs/364312aaf6db32c57c31a0abad1e6da2\">https://gist.github.com/gamozolabs/364312aaf6db32c57c31a0abad1e6da2</a></p>",
        "id": 277802741,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649111490
    },
    {
        "content": "<p>If you're talking about <a href=\"https://gist.github.com/gamozolabs/364312aaf6db32c57c31a0abad1e6da2#file-numapool-rs-L429-L461\">https://gist.github.com/gamozolabs/364312aaf6db32c57c31a0abad1e6da2#file-numapool-rs-L429-L461</a> then you need <code>T: 'static</code> for it to be sound. if you don't do that then you could register a <code>NumaRef&lt;'id, &amp;'id Something&gt;</code> and then get an <code>&amp;'static Something</code> out of it later. Remember that <code>T: 'id</code> doesn't mean \"the only lifetime that appears in <code>T</code> is <code>'id</code>, but rather that any lifetime that appears in <code>T</code> lives longer than <code>'id</code>.</p>",
        "id": 277866829,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1649160417
    },
    {
        "content": "<p>Not if <code>NumaRef</code> is invariant in both <code>'id</code> and <code>T</code>.</p>",
        "id": 277867003,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649160485
    },
    {
        "content": "<p>(And same with the <code>Pool</code>)</p>",
        "id": 277867048,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649160506
    },
    {
        "content": "<p>I don't see how that costrains the signature of <code>values</code>. There I can freely choose <code>T</code> without variance requirements.</p>",
        "id": 277883745,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1649167507
    },
    {
        "content": "<p>Yeah. This is kinda tough. I've decided to do an unsafe trait:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Poolable</span>: <span class=\"nb\">Sync</span> <span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">POOL_TYPE</span>: <span class=\"nc\">TypeId</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"cp\">#[derive(Clone, Copy, Debug)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Fleen</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">val</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">other</span>: <span class=\"nc\">NumaRef</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Poolable</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Fleen</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">POOL_TYPE</span>: <span class=\"nc\">TypeId</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TypeId</span>::<span class=\"n\">of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Fleen</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Where it is unsafe, and you have to define a globally unique type ID for that value. All the functions that operate on <code>NumaRef</code>s expect <code>'id</code> to match the invariant lifetime of the pool itself, thus I think it's \"fine\" to use the typeid of <code>'static</code> for <code>'id</code>, as to the pool, it's a unique type ID, and impossible to put a non-<code>'id</code> reference into it where typeids could collide based on differing lifetimes</p>",
        "id": 277944907,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649193594
    },
    {
        "content": "<p>With this it looks like you can't insert types with non-<code>id</code> lifetimes, but you can still retrieve them with different lifetimes.</p>",
        "id": 277946732,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1649194531
    },
    {
        "content": "<p>I think you should take a look at how the <code>better_any</code> crate does this.</p>",
        "id": 277947209,
        "sender_full_name": "Giacomo Stevanato",
        "timestamp": 1649194782
    },
    {
        "content": "<p>Hmm. I'm not using <code>Any</code> though, if it's impossible to insert a non-<code>'id</code> type, then it's also impossible to get a non-<code>'id</code> type as none exist in the database with a differing lifetime. I'm also using a procedural macro where you can only make structures with PoD types and <code>NumaRef&lt;'id&gt;</code> it's impossible to ever have a non-<code>'id</code> numa ref at any point</p>",
        "id": 277947431,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649194900
    },
    {
        "content": "<p>All interactions with the pool require an <code>'id</code> from the pool</p>",
        "id": 277947460,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649194916
    },
    {
        "content": "<p>I can further restrict this by doing:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">trait</span><span class=\"w\"> </span><span class=\"n\">Poolable</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span>: <span class=\"o\">'</span><span class=\"na\">id</span> <span class=\"o\">+</span><span class=\"w\"> </span><span class=\"nb\">Sync</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">POOL_TYPE</span>: <span class=\"nc\">TypeId</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"cp\">#[derive(Clone, Copy, Debug)]</span><span class=\"w\"></span>\n<span class=\"k\">struct</span> <span class=\"nc\">Fleen</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">val</span>: <span class=\"kt\">i32</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">other</span>: <span class=\"nc\">NumaRef</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"kt\">i32</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Poolable</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">Fleen</span><span class=\"o\">&lt;'</span><span class=\"na\">id</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"n\">POOL_TYPE</span>: <span class=\"nc\">TypeId</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">TypeId</span>::<span class=\"n\">of</span>::<span class=\"o\">&lt;</span><span class=\"n\">Fleen</span><span class=\"o\">&lt;'</span><span class=\"nb\">static</span><span class=\"o\">&gt;&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>Thus any place where I get values by type it requires that <code>: 'id</code> bound on <code>Poolable</code></p>",
        "id": 277949732,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649196274
    },
    {
        "content": "<p>Updated the code quite a bit to a new API and added really strict <code>'id</code> bounds on everything <a href=\"https://gist.github.com/gamozolabs/82c50abe8cfeb17c36921cd7e0f58f4a\">https://gist.github.com/gamozolabs/82c50abe8cfeb17c36921cd7e0f58f4a</a></p>",
        "id": 277967673,
        "sender_full_name": "Brandon Falk",
        "timestamp": 1649211214
    }
]