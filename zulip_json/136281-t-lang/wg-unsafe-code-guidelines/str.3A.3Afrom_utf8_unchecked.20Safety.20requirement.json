[
    {
        "content": "<p><code>str::from_utf8_unchecked</code> documents this:</p>\n<blockquote>\n<p>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that &amp;strs are valid UTF-8.</p>\n</blockquote>\n<p>This makes me super uncomfortable, because it suggests that the UB is elsewhere, if the requirements of this <code>unsafe fn</code> are violated.</p>\n<p><span class=\"user-mention\" data-user-id=\"326176\">@Boxy [she/her]</span> asked if I'm okay with <code>NonZeroU32</code>. The answer is yes, absolutely. It documents</p>\n<blockquote>\n<p>Creates a non-zero without checking whether the value is non-zero. This results in undefined behaviour if the value is zero.<br>\nSafety<br>\nThe value must not be zero.</p>\n</blockquote>\n<p>Interpreted literally, or per <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span>'s reading here: <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278421409\">https://rust-lang.zulipchat.com/#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Problems.20with.20integer.20provenance/near/278421409</a> it would be incorrect for an implementation of <code>str::from_utf8_unchecked</code> to abort if it were passed a slice of bytes which is not UTF-8. By contrast, if you attempt to run this program:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">_</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">std</span>::<span class=\"n\">num</span>::<span class=\"n\">NonZeroU32</span>::<span class=\"n\">new_unchecked</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>in debug mode with <code>-Zbuild-std</code>, you will see this:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"w\">   </span><span class=\"n\">Compiling</span><span class=\"w\"> </span><span class=\"n\">scratch</span><span class=\"w\"> </span><span class=\"n\">v0</span><span class=\"p\">.</span><span class=\"mf\">1.0</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"o\">/</span><span class=\"n\">tmp</span><span class=\"o\">/</span><span class=\"n\">scratch</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Finished</span><span class=\"w\"> </span><span class=\"n\">dev</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"n\">unoptimized</span><span class=\"w\"> </span><span class=\"o\">+</span><span class=\"w\"> </span><span class=\"n\">debuginfo</span><span class=\"p\">]</span><span class=\"w\"> </span><span class=\"n\">target</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"mf\">0.36</span><span class=\"n\">s</span><span class=\"w\"></span>\n<span class=\"w\">     </span><span class=\"n\">Running</span><span class=\"w\"> </span><span class=\"err\">`</span><span class=\"n\">target</span><span class=\"o\">/</span><span class=\"n\">x86_64</span><span class=\"o\">-</span><span class=\"n\">unknown</span><span class=\"o\">-</span><span class=\"n\">linux</span><span class=\"o\">-</span><span class=\"n\">gnu</span><span class=\"o\">/</span><span class=\"n\">debug</span><span class=\"o\">/</span><span class=\"n\">scratch</span><span class=\"err\">`</span><span class=\"w\"></span>\n<span class=\"n\">Illegal</span><span class=\"w\"> </span><span class=\"n\">instruction</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"n\">core</span><span class=\"w\"> </span><span class=\"n\">dumped</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278422824,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527615
    },
    {
        "content": "<p>So the only problem is that <code>str</code> doesnt actually have niches for invalid utf8?</p>",
        "id": 278422839,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527653
    },
    {
        "content": "<p>and that you'd be uncomfortable with <code>NonZeroU32</code> having <code>new_unchecked</code> be unsafe if it didnt have a niche?</p>",
        "id": 278422861,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527679
    },
    {
        "content": "<p>No, my concern is that <code>&amp;str</code> has a wobbly sort of unsafe postcondition</p>",
        "id": 278422908,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527699
    },
    {
        "content": "<p>i dont see how its any different than <code>NonZeroU32</code></p>",
        "id": 278422916,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527710
    },
    {
        "content": "<p><code>NonZeroU32::new_unchecked</code> has a precondition</p>",
        "id": 278422932,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527724
    },
    {
        "content": "<p>it doesnt really have a postcondition- just make sure that the bytes are valid utf8</p>",
        "id": 278422939,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527733
    },
    {
        "content": "<p>by not being lang level UB yes i suppose its not _immediately_ UB and the real UB might happen later</p>",
        "id": 278422955,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527758
    },
    {
        "content": "<p>but that seems _better_ to me</p>",
        "id": 278422963,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527773
    },
    {
        "content": "<p>Yes it does, a literal reading of that says it is not UB to pass invalid bytes to <code>str::from_utf8_unchecked</code>, so long as you don't do anything with it. That means it would be incorrect for the standard library to check that the bytes passed are UTF-8 in debug mode.</p>",
        "id": 278422966,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527777
    },
    {
        "content": "<p>The utf8 condition applies any time you pass a <code>&amp;str</code> value to any function at all, <em>ever</em>, unless you specifically know that the function can cope with malformed data (eg: because you wrote that function).</p>",
        "id": 278422972,
        "sender_full_name": "Lokathor",
        "timestamp": 1649527782
    },
    {
        "content": "<blockquote>\n<p>If this constraint is violated, undefined behavior results</p>\n</blockquote>",
        "id": 278422979,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527800
    },
    {
        "content": "<p>this sounds pretty clear cut to me that it is UB to pass it  bytes that arent utf8</p>",
        "id": 278423024,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527811
    },
    {
        "content": "<p>the docs are quite fuzzy on when, as they should be</p>",
        "id": 278423030,
        "sender_full_name": "Lokathor",
        "timestamp": 1649527822
    },
    {
        "content": "<p>the safety docs could probably be clearer though about exactly what is going on, but I definitely dont read it as \"its fine to pass in non utf8 bytes\"</p>",
        "id": 278423040,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649527846
    },
    {
        "content": "<p>because the only UB is if some code assumes utf8 as part of a safety contract (eg: pointer offsetting) and the data doesn't hold</p>",
        "id": 278423043,
        "sender_full_name": "Lokathor",
        "timestamp": 1649527863
    },
    {
        "content": "<p>anyway, that's not the only way to make a malformed str</p>",
        "id": 278423054,
        "sender_full_name": "Lokathor",
        "timestamp": 1649527890
    },
    {
        "content": "<p>there's also as_bytes_mut</p>",
        "id": 278423058,
        "sender_full_name": "Lokathor",
        "timestamp": 1649527900
    },
    {
        "content": "<p>That may be when the program actually explodes, but my concern is about where the author's mistake is</p>",
        "id": 278423064,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527910
    },
    {
        "content": "<p>If it's okay to pass invalid bytes to <code>from_utf8_unchecked</code>, we basically have no ability to write a helpful checker</p>",
        "id": 278423119,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527947
    },
    {
        "content": "<p>That is, a checker without false positives or a bajillion flags</p>",
        "id": 278423136,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649527982
    },
    {
        "content": "<p>I mean the safety contract of that function is clear</p>",
        "id": 278423206,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528084
    },
    {
        "content": "<p>by \"checker\" do you mean miri? because tbh I wouldnt expect miri to detect library UB like invalid utf8 strings</p>",
        "id": 278423208,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649528086
    },
    {
        "content": "<p>but again that's not the only way to do what we're talking about, so whatever</p>",
        "id": 278423216,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528098
    },
    {
        "content": "<p>its okay language UB wise to pass invalid bytes, but its incorrect library UB wise so its \"obviously\" the fault of the <code>from_utf8_unchecked</code> call having not valid bytes if safe code then causes lang UB from relying on it being valid utf8</p>",
        "id": 278423235,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649528133
    },
    {
        "content": "<p>safe code would not cause lang UB</p>",
        "id": 278423282,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528164
    },
    {
        "content": "<p>it would still be library UB</p>",
        "id": 278423289,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528172
    },
    {
        "content": "<p>Side note: lang ub / lib ub is an absolutely terrible pair of names</p>",
        "id": 278423306,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528196
    },
    {
        "content": "<p>what i mean is that calling a safe fn could cause lang ub</p>",
        "id": 278423405,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649528318
    },
    {
        "content": "<p>no that's still lib ub</p>",
        "id": 278423411,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528331
    },
    {
        "content": "<p>i.e. safe code could call a safe fn which uses unsafe internally relying on the library UB</p>",
        "id": 278423415,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649528339
    },
    {
        "content": "<p>which then escalates to lang UB</p>",
        "id": 278423420,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649528347
    },
    {
        "content": "<p>I like lang/library UB distinction</p>",
        "id": 278423441,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649528396
    },
    {
        "content": "<p>I'm very unclear on how library ub would \"escalate\" to lang ub. Once you've done any ub the whole program is nonsense and it doesn't go any farther</p>",
        "id": 278423498,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528432
    },
    {
        "content": "<blockquote>\n<p>I like lang/library UB distinction</p>\n</blockquote>\n<p>I like the distinction but they initial to the same thing which is utterly terrible</p>",
        "id": 278423512,
        "sender_full_name": "Lokathor",
        "timestamp": 1649528465
    },
    {
        "content": "<p>By \"checker\" I mean any principled automatic insertion of checks. It could be Miri, or it could be the standard library debug assertions, or it could be some third-party analysis tool or interpreter.</p>",
        "id": 278423692,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649528759
    },
    {
        "content": "<p>I think it would be perfectly fine to insert a check that the bytes are valid utf8 inside of that function</p>",
        "id": 278423775,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649528859
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278423498\">said</a>:</p>\n<blockquote>\n<p>I'm very unclear on how library ub would \"escalate\" to lang ub. Once you've done any ub the whole program is nonsense and it doesn't go any farther</p>\n</blockquote>\n<p>take this example:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"sd\">/// Safety: n must be &gt; 0</span>\n<span class=\"n\">unsaf</span><span class=\"w\"> </span><span class=\"n\">efn</span><span class=\"w\"> </span><span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>violating the safety invariant doesnt ever turn into lang UB its \"just\" library UB- still UB and wrong and dont do it but its not violating any of the built in rust lang rules that can result in your code getting mangled up by optimizations and miri cant check this either. </p>\n<p>but if we then add <code>NonZeroU32::new_unchecked(n)</code> now we've \"escalated\" the library UB into lang UB because we've got a <code>NonZeroU32</code> with a niche of <code>0</code> and its value set to <code>0</code></p>",
        "id": 278423932,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529077
    },
    {
        "content": "<p>What if I wrote this though?</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"cp\">#[requires = </span><span class=\"s\">\"n &gt; 0\"</span><span class=\"cp\">]</span><span class=\"w\"></span>\n<span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"n\">n</span>: <span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 278424031,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649529226
    },
    {
        "content": "<p>hard to say given <code>#[requires</code> is not a rust attribute that i know exists lol</p>",
        "id": 278424080,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529282
    },
    {
        "content": "<p>is the string \"n &gt; 0\" something that rust itself now understands and will optimize around?</p>",
        "id": 278424101,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529320
    },
    {
        "content": "<p>What if it's just a thing that the frontend parses, and Miri recognizes, and will check for you?</p>",
        "id": 278424111,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649529339
    },
    {
        "content": "<p>seems reasonable to me</p>",
        "id": 278424118,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529360
    },
    {
        "content": "<p>that would be pretty cool to have :D</p>",
        "id": 278424161,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529373
    },
    {
        "content": "<p>So is it library UB or language UB now that Miri can check it but it's not optimized on?</p>",
        "id": 278424163,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649529376
    },
    {
        "content": "<p>still library UB imo</p>",
        "id": 278424167,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529384
    },
    {
        "content": "<p>So what about all the properties of Stacked Borrows which Miri checks but rustc does not optimize on?</p>",
        "id": 278424177,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649529418
    },
    {
        "content": "<p>its also still _ub_ so it seems perfectly fine to me to yell at the user about them having violated the safety invariants here</p>",
        "id": 278424179,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529421
    },
    {
        "content": "<p>my wording has probably been pretty crap so this is on me but whether rustc _currently_ optimizes soemthing doesnt determine if its lang ub or not</p>",
        "id": 278424256,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529501
    },
    {
        "content": "<p>im not really sure if you expect a real answer to your question im not on lang team and even if i was I couldnt unanimously say that stacked borrows was now the Official<span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span> aliasing rules for rust :P</p>",
        "id": 278424271,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529540
    },
    {
        "content": "<p>i dont quite understand what you're asking here</p>",
        "id": 278424280,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529560
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> a checker can <em>absolutely</em> insert a check in <code>str::from_utf8_unchecked</code> if it wants to.</p>",
        "id": 278424292,
        "sender_full_name": "Lokathor",
        "timestamp": 1649529578
    },
    {
        "content": "<p><del>I guess in some ways you could consider lang UB to be library UB on the <code>compile_my_code</code> function rofl</del></p>",
        "id": 278424297,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529589
    },
    {
        "content": "<p>I'm trying to point out how incredibly wobbly the difference between \"library UB\" and \"language UB\" is. I'm yet to see a solid definition for either, and I'm <em>extremely</em> wary of Miri's ability to check things or rustc's optimizations bleeding into any such conversation.</p>",
        "id": 278424365,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649529648
    },
    {
        "content": "<p>well.. its hard to say exactly waht is lang ub and what isnt seeing as how rust has conveniently not decided on this yet which amkes it a huge pain to write unsafe code</p>",
        "id": 278424393,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529710
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"326176\">Boxy [she/her]</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278424297\">said</a>:</p>\n<blockquote>\n<p><del>I guess in some ways you could consider lang UB to be library UB on the <code>compile_my_code</code> function rofl</del></p>\n</blockquote>\n<p>tbh i was joking with this remark but i do sort of like it :P</p>",
        "id": 278424435,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529736
    },
    {
        "content": "<p>if <code>cargo run/build/check/test</code> could be unsafe and had a big <code>/// Safety:</code> section...</p>",
        "id": 278424438,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529751
    },
    {
        "content": "<blockquote>\n<p>but if we then add <code>NonZeroU32::new_unchecked(n)</code> now we've \"escalated\" the library UB into lang UB because we've got a <code>NonZeroU32</code> with a niche of <code>0</code> and its value set to <code>0</code></p>\n</blockquote>\n<p>So, my position is that it doesn't matter what the body of <code>foo</code> is. If the unsafe function documents &gt;0 then it's UB the instant you call it with 0 <em>regardless</em> of the actual code body of <code>foo</code>.</p>",
        "id": 278424439,
        "sender_full_name": "Lokathor",
        "timestamp": 1649529752
    },
    {
        "content": "<p>to be clear im not saying that calling it wouldnt conceptually be UB</p>",
        "id": 278424458,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529810
    },
    {
        "content": "<p>im just saying that its library UB not language UB</p>",
        "id": 278424459,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529816
    },
    {
        "content": "<p>both of which are UB and Bad</p>",
        "id": 278424464,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529819
    },
    {
        "content": "<p>For example, this program is UB under stacked borrows with raw pointer tagging, it's documented to be not allowed by the standard library documentation, and it is checked for by debug assertions. But I am not sure we will ever have a world where it is optimized against.</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">main</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">arr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"k\">u8</span><span class=\"p\">;</span><span class=\"w\"> </span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">sli</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"n\">arr</span><span class=\"p\">[</span><span class=\"o\">..</span><span class=\"mi\">1</span><span class=\"p\">];</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"fm\">println!</span><span class=\"p\">(</span><span class=\"s\">\"{}\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">sli</span><span class=\"p\">.</span><span class=\"n\">get_unchecked</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>So I don't know how you'd draw a distinction between whether this is library UB or language UB, so I'm uncomfortable with drawing any distinction in the first place between those.</p>\n<p>(*) we could turn the above program into definite LLVM UB for fun, but it would probably just be slower</p>",
        "id": 278424513,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649529865
    },
    {
        "content": "<p>sure, but I'm saying that once the lib UB has happened the program is nonsense and there's no escalation because nothing at all happens.</p>\n<p>Which is a purely philosophical point perhaps.</p>",
        "id": 278424517,
        "sender_full_name": "Lokathor",
        "timestamp": 1649529881
    },
    {
        "content": "<p>I would say its lang UB in a world where we officially endorse stacked borrows as the rules<span aria-label=\"tm\" class=\"emoji emoji-2122\" role=\"img\" title=\"tm\">:tm:</span></p>",
        "id": 278424523,
        "sender_full_name": "Boxy [she/her]",
        "timestamp": 1649529895
    },
    {
        "content": "<p>But anyway that took my cold fingers a long time to type out and I see we mostly agree, so yeah now I feel like I'm more venting :p</p>",
        "id": 278424525,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649529897
    },
    {
        "content": "<p>Ben i would say your example is a lib UB, get_unchecked to an oob location violates the function contract</p>",
        "id": 278424586,
        "sender_full_name": "Lokathor",
        "timestamp": 1649529977
    },
    {
        "content": "<p>lang ub is actually, i would say, very rare because most of what we do in rust goes through functions (many of which wrap intrinsics)</p>",
        "id": 278424593,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530024
    },
    {
        "content": "<p>But it's only documented to be UB because it is language UB under Stacked Borrows <span aria-label=\"wink\" class=\"emoji emoji-1f609\" role=\"img\" title=\"wink\">:wink:</span></p>",
        "id": 278424605,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649530058
    },
    {
        "content": "<p>I'm 99% sure that reading out of bounds has been UB since before stacked borrows ;P</p>",
        "id": 278424669,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530113
    },
    {
        "content": "<p>it's in bounds of the original allocation, so there's a reasonable world in which it's ok</p>",
        "id": 278424690,
        "sender_full_name": "Talchas",
        "timestamp": 1649530154
    },
    {
        "content": "<p>Exactly</p>",
        "id": 278424692,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649530161
    },
    {
        "content": "<p>just hard to define what exactly the boundaries of &amp;mut+unsafe are in that world</p>",
        "id": 278424696,
        "sender_full_name": "Talchas",
        "timestamp": 1649530170
    },
    {
        "content": "<p>i don't think it is. I think the bounds of the intermediate reference are narrowed, and we've (probably) treated things like that since before stacked borrows. Slice::split_at_mut is so old it doesn't have a stabilized version listed, and it's only sound if references narrow provenance</p>",
        "id": 278424826,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530326
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278424439\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>but if we then add <code>NonZeroU32::new_unchecked(n)</code> now we've \"escalated\" the library UB into lang UB because we've got a <code>NonZeroU32</code> with a niche of <code>0</code> and its value set to <code>0</code></p>\n</blockquote>\n<p>So, my position is that it doesn't matter what the body of <code>foo</code> is. If the unsafe function documents &gt;0 then it's UB the instant you call it with 0 <em>regardless</em> of the actual code body of <code>foo</code>.</p>\n</blockquote>\n<p>this doesn't work because it doesn't violate any rules of the abstract machine. we still have a fully defined operational semantics that completely ignores the function documentation. \"library ub\" is just a way to say \"if you do this it may or may not be actual abstract-machine ub today, i as the library author simply reserve the right to have it result in abstract-machine ub without any further <code>unsafe</code> apis\"</p>",
        "id": 278424830,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649530354
    },
    {
        "content": "<p>sure, and everything you just said applies to str methods and safety invariants in general.</p>",
        "id": 278424866,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530409
    },
    {
        "content": "<blockquote>\n<p>we've (probably) treated things like that since before stacked borrows</p>\n</blockquote>\n<p>Well, that would be before my involvement in unsafe Rust, but this out-of-bounds access was only documented to be UB on its own in August 2019: <a href=\"https://github.com/rust-lang/rust/commit/f44abba4ec19ee8b7ae4dfbe557fa4846eec8ad6\">https://github.com/rust-lang/rust/commit/f44abba4ec19ee8b7ae4dfbe557fa4846eec8ad6</a></p>",
        "id": 278424877,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649530432
    },
    {
        "content": "<p>in other words \"library ub\" is only a useful concept \"one level up\" when you're talking about <code>unsafe</code> and api design</p>",
        "id": 278424878,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649530436
    },
    {
        "content": "<p>correct johnst</p>",
        "id": 278424915,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530450
    },
    {
        "content": "<p>calling <code>from_utf8_unchecked</code> with invalid utf-8 may or may not invoke any language/abstract machine UB, but because we're talking about its api contract, that is not relevant- it is an implementation detail.</p>",
        "id": 278424935,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649530515
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span> sadly our docs are often insufficient. Again, <code>slice::split_at_mut</code> is only sound if references have their provenance narrowed. That's just a fact, even if no one documented it</p>",
        "id": 278424936,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530518
    },
    {
        "content": "<p>and as an implementation detail, it is already perfectly fine to add debug asserts to it, have miri check it, etc</p>",
        "id": 278424948,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649530561
    },
    {
        "content": "<p>rpjohnst i think you and i are in complete agreement, or at least nearly so</p>",
        "id": 278425016,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530665
    },
    {
        "content": "<p>yeah i'm not trying to disagree with your general position just the justification you gave</p>",
        "id": 278425065,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649530706
    },
    {
        "content": "<p>because i think saying \"it's UB the instant you call wrong\" doesn't really help answer ben's concern about the docs</p>",
        "id": 278425089,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649530764
    },
    {
        "content": "<p>fair point, I've been eating lunch this whole time so I've probably been less than fully articulate</p>",
        "id": 278425202,
        "sender_full_name": "Lokathor",
        "timestamp": 1649530830
    },
    {
        "content": "<p>No, it does. The docs need some clarification</p>",
        "id": 278425211,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649530834
    },
    {
        "content": "<p>They suggest a particular causality, which I think is unnecessary vague. The slice unchecked indexing docs clarified this some time ago, we should do the same for <code>from_utf8_unchecked</code></p>",
        "id": 278425230,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649530873
    },
    {
        "content": "<p>I prefer using something simpler than UTF-8 to have these conversations.</p>\n<p>I find it much easier to talk about</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// This one has a *safety* invariant that it must be even</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Even</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>vs</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"c1\">// This one has a *correctness* invariant that it must be even</span>\n<span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span> <span class=\"nc\">Even</span><span class=\"p\">(</span><span class=\"kt\">u32</span><span class=\"p\">);</span><span class=\"w\"> </span><span class=\"k\">impl</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span> <span class=\"nf\">new_unchecked</span><span class=\"p\">(</span><span class=\"n\">x</span>: <span class=\"kt\">u32</span><span class=\"p\">)</span><span class=\"w\"> </span>-&gt; <span class=\"nc\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"> </span><span class=\"n\">Even</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>\n<p>The code is <em>exactly</em> the same, other than <code>unsafe</code>.</p>\n<p>But the former type carries a \"proof\" that it's even, upon which <code>unsafe</code> code can rely, while the latter doesn't.</p>",
        "id": 278425241,
        "sender_full_name": "scottmcm",
        "timestamp": 1649530892
    },
    {
        "content": "<p>my point is that it is not, in fact, inherently UB to call an unsafe function without upholding its preconditions- this is not a question of immediate (language) UB, it is a question \"one level up\" about API design</p>",
        "id": 278425294,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649530941
    },
    {
        "content": "<p>And my response to this has been that if it is not immediately UB, it cannot be checked</p>",
        "id": 278425318,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649530986
    },
    {
        "content": "<p>no, that is wrong- it can be checked, the justification is just different</p>",
        "id": 278425329,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531004
    },
    {
        "content": "<p>you could even check it if the function were safe</p>",
        "id": 278425335,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531015
    },
    {
        "content": "<p>It can be checked <em>with false positives</em> and <em>with a wobbly error message</em> which I don't find compelling</p>",
        "id": 278425346,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649531034
    },
    {
        "content": "<p>it may be a false positive for <em>language UB</em> but it is certainly not a false positive for <em>library correctness</em></p>",
        "id": 278425395,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531059
    },
    {
        "content": "<p>bringing UB into this at all is a bit of a red herring</p>",
        "id": 278425400,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531070
    },
    {
        "content": "<p>even a safe API is fully within its rights to panic on precondition violations</p>",
        "id": 278425412,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531096
    },
    {
        "content": "<p>in other words, <code>unsafe</code> has no bearing on the abstract machine. it's part of a different layer, whose job is to assign blame for potential abstract machine UB, not to actually determine what is or is not UB</p>",
        "id": 278425490,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531208
    },
    {
        "content": "<p>in terms of scott's example, how would you document <code>unsafe fn new_unchecked(x: u32) -&gt; Even</code> when the only abstract machine UB is off in some other function <code>fn use_even(Even(x): Even) { if x % 2 == 1 { unsafe { unreachable_unchecked() } }</code></p>",
        "id": 278425649,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531416
    },
    {
        "content": "<p>I don't think that <code>from_utf8_unchecked</code> needs a docs change.</p>\n<p>If you call the function with invalid bytes it's UB. End. That's it.</p>\n<p>Checkers can put as many guards inside the function, because the caller did a UB, so go wild with checks.</p>",
        "id": 278425842,
        "sender_full_name": "Lokathor",
        "timestamp": 1649531710
    },
    {
        "content": "<p>I would really like to emphasize that the function is <em>just one way</em> to get invalid data inside a <code>&amp;str</code></p>",
        "id": 278425924,
        "sender_full_name": "Lokathor",
        "timestamp": 1649531827
    },
    {
        "content": "<p>that's why the utf8 rule exists on the type as well as the function</p>",
        "id": 278425946,
        "sender_full_name": "Lokathor",
        "timestamp": 1649531861
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278425842\">said</a>:</p>\n<blockquote>\n<p>If you call the function with invalid bytes it's UB. End. That's it.</p>\n</blockquote>\n<p>but it's not abstract machine UB, that's the part that makes this tricky- we certainly don't ever want anyone call it with invalid bytes, and the API/docs are certainly not trying to allow tricks like \"construct an invalid &amp;str but never pass it anywhere,\" but the justification needs to be a bit more precise than \"it's UB\" because it simply isn't.</p>",
        "id": 278426009,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649531925
    },
    {
        "content": "<p>the justification is rather, the fact that it isn't immediately UB is not part of the API surface, it is an implementation detail of the API that you are not supposed to rely on</p>",
        "id": 278426042,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649532001
    },
    {
        "content": "<p>for example, it would actually be sound for from_utf8_unchecked to start invoking UB immediately if passed invalid bytes</p>",
        "id": 278426135,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649532104
    },
    {
        "content": "<p>and if <em>that's</em> fine then surely putting in a check is fine</p>",
        "id": 278426181,
        "sender_full_name": "rpjohnst",
        "timestamp": 1649532128
    },
    {
        "content": "<p>An action that's UB might work anyway. It really might. It could behave as you thought it would. That does not make it not UB.</p>\n<p>We certainly <em>should</em> justify why an unsafe function is unsafe, but I would say that's separate.</p>",
        "id": 278426284,
        "sender_full_name": "Lokathor",
        "timestamp": 1649532291
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278423498\">said</a>:</p>\n<blockquote>\n<p>I'm very unclear on how library ub would \"escalate\" to lang ub. Once you've done any ub the whole program is nonsense and it doesn't go any farther</p>\n</blockquote>\n<p>that's only true for lang ub.<br>\nthe AM doesn't even know what lib UB is, so lib UB has absolutely no bearing on how the program behaves.</p>",
        "id": 278467957,
        "sender_full_name": "RalfJ",
        "timestamp": 1649596988
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278424936\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> sadly our docs are often insufficient. Again, <code>slice::split_at_mut</code> is only sound if references have their provenance narrowed. That's just a fact, even if no one documented it</p>\n</blockquote>\n<p>no that's not true. for <code>split_at_mut</code> to be sound, it is enough for a reference's <em>safety contract</em> to ensure it is limited to stay within its bounds. provenance, language UB, all that stuff -- is not needed.</p>",
        "id": 278468024,
        "sender_full_name": "RalfJ",
        "timestamp": 1649597093
    },
    {
        "content": "<p>so I agree with <span class=\"user-mention\" data-user-id=\"117495\">@rpjohnst</span> and disagree with <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> here. all of this \"when you cause UB that's The End\" is only true for lang UB.</p>",
        "id": 278468105,
        "sender_full_name": "RalfJ",
        "timestamp": 1649597213
    },
    {
        "content": "<p>lang UB is the contract between the programmer(s) -- all the source code -- and the compiler.<br>\nlibrary UB is the contract <em>between the library author and the library user</em>. the compiler doesn't care to the slightest, and program behavior is not affected by this contract. library UB <em>does</em> give the library author license to cause language UB, and if that happens then the usual lang UB things apply. but library UB on its own doesn't have any world-ending powers -- if you are willing to break the abstraction and look into the library code, things might go on even if you cause library UB. you still should never do that because breaking abstractions is bad, other versions of the library might be different, etc., but this is a fundamental difference between lang UB and lib UB.</p>",
        "id": 278468203,
        "sender_full_name": "RalfJ",
        "timestamp": 1649597373
    },
    {
        "content": "<p>(and yes all these terms are bad, including UB itself)</p>",
        "id": 278468205,
        "sender_full_name": "RalfJ",
        "timestamp": 1649597382
    },
    {
        "content": "<p>I agree with <span class=\"user-mention\" data-user-id=\"120791\">@RalfJ</span> here, but I also think <span class=\"user-mention\" data-user-id=\"224471\">@Lokathor</span> has a point that the situation with lang UB is actually somewhat parallel in that you can also open the hood of the compiler and write code that is lang UB and still know that the show will go on. (In fact, <code>std</code> does exactly this in some places, not with lang UB AFAIK but with <code>repr(Rust)</code>.) The AM in this setting is revealed to be a lie that is used to define and describe the contract between the compiler and the code author; if you are willing to break that abstraction barrier then the AM ceases to matter</p>",
        "id": 278468799,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649598181
    },
    {
        "content": "<p>yeah, I agree. however, \"opening up\" the compiler is a much bigger step -- you now have to consider all interactions of all optimizations, everything becomes very non-local.</p>",
        "id": 278470860,
        "sender_full_name": "RalfJ",
        "timestamp": 1649600593
    },
    {
        "content": "<p>you can inspect the assembly, but even changing unrelated parts of the program can change the assembly of your function.</p>",
        "id": 278470866,
        "sender_full_name": "RalfJ",
        "timestamp": 1649600608
    },
    {
        "content": "<p>in contrast, \"going below\" lib UB still gives you local reasoning etc</p>",
        "id": 278470871,
        "sender_full_name": "RalfJ",
        "timestamp": 1649600634
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278467957\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278423498\">said</a>:</p>\n<blockquote>\n<p>I'm very unclear on how library ub would \"escalate\" to lang ub. Once you've done any ub the whole program is nonsense and it doesn't go any farther</p>\n</blockquote>\n<p>that's only true for lang ub.<br>\nthe AM doesn't even know what lib UB is, so lib UB has absolutely no bearing on how the program behaves.</p>\n</blockquote>\n<p>I dispute the distinction here - after all, the standard library is free to \"promote\" lib UB to lang UB, or interact with other parts of the libraries in ways that render the program equally nonsensical. There isn't a functional difference - it's just UB.<br>\nAnd in both cases, you have implementation privilege - the stdlib can rely on the compiler doing \"the right thing\" (for some definiton thereof) for some case of lang UB, just as much as it can rely on the rest of the stdlib doing the right thing for some case of lib UB.<br>\nYes, you have to ensure that it interacts properly, but it's the same with lib UB. If you violate a stdlib precondition within the stdlib, you have to ensure that you don't exploit that precondition in a way that affects the observable behaviour, and it's the same for lang preconditions.</p>",
        "id": 278474196,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649604886
    },
    {
        "content": "<p>A valid implementation of <code>core::str::from_utf8_unchecked</code> is <code>core::ptr::from_utf8(buf).unwrap_unchecked()</code>.</p>",
        "id": 278474318,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605044
    },
    {
        "content": "<p>As is \"transmute and check later\".</p>",
        "id": 278474327,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605062
    },
    {
        "content": "<p>(check meaning assume here)</p>",
        "id": 278474342,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605080
    },
    {
        "content": "<blockquote>\n<p>I dispute the distinction here - after all, the standard library is free to \"promote\" lib UB to lang UB, or interact with other parts of the libraries in ways that render the program equally nonsensical. There isn't a functional difference - it's just UB.</p>\n</blockquote>\n<p>It's a very big difference when you are debugging your code.<br>\nso this is just what I said above -- \"library UB does give the library author license to cause language UB\"</p>",
        "id": 278474402,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605144
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 278474414,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605175
    },
    {
        "content": "<p>Non-standard library is the same case as the stdlib, but you don't get implementation privilege over language UB, just like you don't get implementation privilege over the standard library, or for that matter any library you call to not under your contrl.</p>",
        "id": 278474475,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605239
    },
    {
        "content": "<blockquote>\n<p>[the stdlib] can rely on the rest of the stdlib doing the right thing for some case of lib UB.</p>\n</blockquote>\n<p><em>any</em> library can rely on <em>other parts of itself</em> doing the right thing for some cases of lib UB. as I said, lib UB is a contract between the lib author and its users. the lib author can break its own contract as much as they please.</p>",
        "id": 278474479,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605255
    },
    {
        "content": "<p>IOW, nothing you say is even in arguing against anything I said above...</p>",
        "id": 278474491,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605279
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474318\">said</a>:</p>\n<blockquote>\n<p>A valid implementation of <code>core::str::from_utf8_unchecked</code> is <code>core::ptr::from_utf8(buf).unwrap_unchecked()</code>.</p>\n</blockquote>\n<p>agreed</p>",
        "id": 278474492,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605286
    },
    {
        "content": "<p>Yes. The exception is that the standard library also has the same privilege wrt. it's contract with the abstract machine, because, strictly speaking, the Standard Library is part of the whole implementation of the Rust Programming Language, and thus under it's control.</p>",
        "id": 278474552,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605353
    },
    {
        "content": "<p>yes</p>",
        "id": 278474557,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605366
    },
    {
        "content": "<p>but that still doesnt eradicate the clear distincion between lib UB and lang UB</p>",
        "id": 278474567,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605379
    },
    {
        "content": "<p>But I wouldn't call that any different from just another \"library\" that the stdlib calls to, but that's under the standard libraries control.</p>",
        "id": 278474573,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605388
    },
    {
        "content": "<p>so?</p>",
        "id": 278474580,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605399
    },
    {
        "content": "<p>So there really isn't a difference here.<br>\nAnd one of the reasons I don't like the distinction is that it seems to give people the impression that it's not as bad. It's all UB. The program is entirely nonsensical unless you control the result of that UB.</p>",
        "id": 278474648,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605475
    },
    {
        "content": "<blockquote>\n<p>So there really isn't a difference here.</p>\n</blockquote>\n<p>There's the differences I explained above, none of which you even gave arguments against...</p>",
        "id": 278474665,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605506
    },
    {
        "content": "<p>I certainly dont want to give anyone the impression that violating lib UB is okay. and I don't think I ever did. so for this discussion that's a strawman argument.</p>",
        "id": 278474679,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605547
    },
    {
        "content": "<blockquote>\n<p>The program is entirely nonsensical unless you control the result of that UB.</p>\n</blockquote>\n<p>Your definition of \"nonsensical\" must be very different from mine.</p>",
        "id": 278474732,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605593
    },
    {
        "content": "<p>using my Abstract Machine, I can very easily make a lot of sense of programs that violate lib UB but not lang UB. I can even prove formal statements about them.</p>",
        "id": 278474739,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605616
    },
    {
        "content": "<p>Sure - <em>if</em> you know and control the result.</p>",
        "id": 278474749,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605646
    },
    {
        "content": "<p>my proof might break when the lib is updated, yeah</p>",
        "id": 278474861,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605794
    },
    {
        "content": "<p>but if I keep everything pinned, it'll keep working</p>",
        "id": 278474865,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605802
    },
    {
        "content": "<p>Or replaced with a different version.</p>",
        "id": 278474909,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605813
    },
    {
        "content": "<p>which is a <em>lot</em> easier than what happens when lang UB is violated</p>",
        "id": 278474912,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605819
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474909\">said</a>:</p>\n<blockquote>\n<p>Or replaced with a different version.</p>\n</blockquote>\n<p>how's that different from \"updated\"?^^</p>",
        "id": 278474915,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605825
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474865\">said</a>:</p>\n<blockquote>\n<p>but if I keep everything pinned, it'll keep working</p>\n</blockquote>\n<p>That is also true if you pin the compiler to a version that \"defines\" the UB.</p>",
        "id": 278474917,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605830
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474917\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474865\">said</a>:</p>\n<blockquote>\n<p>but if I keep everything pinned, it'll keep working</p>\n</blockquote>\n<p>That is also true if you pin the compiler to a version that \"defines\" the UB.</p>\n</blockquote>\n<p>no. changing any code anywhere in your program can have arbitrary effects with lang UB, even if you keep the rustc version the same.</p>",
        "id": 278474921,
        "sender_full_name": "RalfJ",
        "timestamp": 1649605847
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474915\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474909\">said</a>:</p>\n<blockquote>\n<p>Or replaced with a different version.</p>\n</blockquote>\n<p>how's that different from \"updated\"?^^</p>\n</blockquote>\n<p>Mostly isn't for user libraries. The standard library, however, is supplied with the implementation.</p>",
        "id": 278474923,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605854
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474921\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474917\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474865\">said</a>:</p>\n<blockquote>\n<p>but if I keep everything pinned, it'll keep working</p>\n</blockquote>\n<p>That is also true if you pin the compiler to a version that \"defines\" the UB.</p>\n</blockquote>\n<p>no. changing any code anywhere in your program can have arbitrary effects with lang UB.</p>\n</blockquote>\n<p>Only if the compiler didn't define the behaviour.</p>\n<p>I can use C++ unions to type pun all I want so long as I know that I'm using a compiler in the (nonexistautive) set {gcc. clang, msvc, lccc, nvcc (I think)}, and I can reason about what it's behaviour is.<br>\nThe fact it's strictly UB in C++ is moot, because all of those implementations have said what happens. And if I know that, I can proof the behaviour of the AM in those cases. It's the same with library UB. If you know what the implementation specifically does, you can proof it's behaviour.</p>",
        "id": 278475024,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649605995
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474923\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474915\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278474909\">said</a>:</p>\n<blockquote>\n<p>Or replaced with a different version.</p>\n</blockquote>\n<p>how's that different from \"updated\"?^^</p>\n</blockquote>\n<p>Mostly isn't for user libraries. The standard library, however, is supplied with the implementation.</p>\n</blockquote>\n<p>If you pin, say, bytemuck 1.7.0, then you can be reasonably sure that it's the same every time.<br>\nBut if you pin rust 1.60, and use it's standard library, you  can get multiple different versions in different compilations (as the compilations may come with different implementations of the rust 1.60 standard library, particularily if it's using different implemenations of rust 1.60). Pinning rustc itself returns to the former case, though (most likely).</p>",
        "id": 278475101,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649606084
    },
    {
        "content": "<p>So you could say that the difference between language UB and library UB is how easy it is to \"know\" the behaviour (if it's not just \"do literally anything\") - but this still doesn't hold for the stdlib.</p>",
        "id": 278475211,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649606228
    },
    {
        "content": "<blockquote>\n<p>Only if the compiler didn't define the behaviour.</p>\n</blockquote>\n<p>oh sure, if you have some idea of what the effective AM actually implemented by the compiler is you could exploit that</p>",
        "id": 278475231,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606267
    },
    {
        "content": "<p>generally that's super hard though because not even the authors of the compiler know what the effective AM induced by their optimizations is ;)</p>",
        "id": 278475277,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606288
    },
    {
        "content": "<p>that's the argument <span class=\"user-mention\" data-user-id=\"271719\">@Mario Carneiro</span> made above that I already agreed to, not sure why you had to repeat it...</p>",
        "id": 278475280,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606305
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278475277\">said</a>:</p>\n<blockquote>\n<p>generally that's super hard though because not even the authors of the compiler know what the effective AM induced by their optimizations is ;)</p>\n</blockquote>\n<p>Well, they do if they control how correct optimizations are applied to a program.</p>",
        "id": 278475692,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649606811
    },
    {
        "content": "<p>for most of the compilers in your list, as far as I can tell, nobody has a clue</p>",
        "id": 278475716,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606870
    },
    {
        "content": "<p>lccc might be doing better, and that's great. :-)</p>",
        "id": 278475757,
        "sender_full_name": "RalfJ",
        "timestamp": 1649606886
    },
    {
        "content": "<p>Well, since all of those compilers specifically permit (as an extension) bit_cast through inactive member of union, I'm fairly confident that a decent number of people do for that operation.</p>",
        "id": 278475787,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649606959
    },
    {
        "content": "<p>(So an optimization that exploited active member rule in a way that violates that extension would be unsound - thus it's fairly trivial to reason about programs that contain such an operation)</p>",
        "id": 278475879,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649607075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120791\">RalfJ</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278475757\">said</a>:</p>\n<blockquote>\n<p>lccc might be doing better, and that's great. :-)</p>\n</blockquote>\n<p>I'd hope that in the case of the entire set, lccc will do as good at most. In this case, I'm meaning \"control the information given to the optimizer in ways that would make certain transformations valid and others invalid\" (for example, by not indicating that the optimizer is free to exploit active variant rule).</p>",
        "id": 278476060,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649607335
    },
    {
        "content": "<p>There was an explicit decision to make \"str is UTF-8\" a safety invariant rather than a validity invariant (though I can't find the issue where it was discussed rn)</p>",
        "id": 278483971,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649617194
    },
    {
        "content": "<p>So it isn't UB to create a str that isn't UTF-8?</p>",
        "id": 278484151,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649617327
    },
    {
        "content": "<p>I think the key point is this: \"library UB\" versus \"language UB\" only matters for a <em>specific execution</em> (just like UB in general refers to a specific execution).<br>\n\"Language UB\" is specifically \"did this execution violate requirements of the Abstract Machine\" — if so, there is <em>no</em> guarantee on the behavior of the execution.<br>\n\"Library UB\" is specifically \"did this execution violate safety invariants of the used functions, but not violate the Abstract Machine\" — if so, there is a guaranteed execution, but no guarantee <em>under changing the implementation/provider of the functions</em></p>",
        "id": 278484247,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649617458
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"120827\">@Ben Kimock (Saethlin)</span><br>\n<a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/78\">unsafe-code-guidelines#78</a> <a href=\"https://github.com/rust-lang/reference/issues/792\">reference#792</a> <a href=\"https://github.com/rust-lang/rust/issues/71033\">rust#71033</a><br>\nFound them</p>",
        "id": 278484355,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649617583
    },
    {
        "content": "<p>The fact that this is a safety and not validity invariant is also important for <code>as_bytes_mut</code>; if it were a validity invariant that UTF-8 were well-formed, then you wouldn't be able to write in UTF-8 bytewise, as it temporarily puts ill-formed UTF-8 into the string</p>",
        "id": 278484612,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649617912
    },
    {
        "content": "<p>(well, modulo <em>when</em> exactly validity at type str is actually enforced...)</p>",
        "id": 278484661,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649617943
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/84184#issuecomment-981800385\">https://github.com/rust-lang/rust/issues/84184#issuecomment-981800385</a></p>",
        "id": 278484860,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649618163
    },
    {
        "content": "<p>So I'm not sure why we need to demote str to a safety invariant to support <code>as_bytes_mut</code> if this example is valid. It's in the docs, which seems to me the most normative thing we have.</p>",
        "id": 278484969,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1649618319
    },
    {
        "content": "<p>I believe as the <code>from_utf8_unchecked</code> docs are currently written, they do imply that it is <em>not</em> a violation of the Abstract Machine to call with ill-formed UTF-8. However, no other method on <code>&amp;str</code> says it works on ill-formed UTF-8, so strictly the only valid thing to do would be to drop the reference or coerce it to a pointer.</p>",
        "id": 278484979,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649618330
    },
    {
        "content": "<p>But yeah also see <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/84\">unsafe-code-guidelines#84</a> and related discussion</p>",
        "id": 278485008,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649618390
    },
    {
        "content": "<p>\"validity on typed copy\" seems to be the way we're going... but <code>str</code> is an unsized type, and can't have a typed copy IIUC, at least not until unsized locals</p>",
        "id": 278485062,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649618436
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278484151\">said</a>:</p>\n<blockquote>\n<p>So it isn't UB to create a str that isn't UTF-8?</p>\n</blockquote>\n<p>It's UB to pass such a <code>&amp;str</code> to any function that expects a normal well-formed <code>&amp;str</code> (which is any function that accepts <code>&amp;str</code>, unless you specifically know otherwise about a specific function).</p>\n<p>and that requirement is arguably <em>separate</em> from the <code>from_utf8_unchecked</code> safety requirements, which are in fact allowed to be \"immediate UB on passing in malformed bytes\", which is what's currently documented.</p>",
        "id": 278486387,
        "sender_full_name": "Lokathor",
        "timestamp": 1649620115
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278486387\">said</a>:</p>\n<blockquote>\n<p>which is what's currently documented.</p>\n</blockquote>\n<p>This is what's debatable, though. The actual text is</p>\n<blockquote>\n<p>This function is unsafe because it does not check that the bytes passed to it are valid UTF-8. If this constraint is violated, undefined behavior results, as the rest of Rust assumes that <code>&amp;strs</code> are valid UTF-8.</p>\n</blockquote>\n<p>which can reasonably be read as the UB results <em>as a result of</em> the rest of Rust assuming that <code>&amp;str</code> is valid UTF-8, or that the UB happens <em>when</em> the rest of Rust exploits that assumption, <em>not</em> as a result of calling this function.</p>",
        "id": 278486490,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620272
    },
    {
        "content": "<p>Ah, so we're quibbling about precisely when it's saying the UB happens.</p>",
        "id": 278486511,
        "sender_full_name": "Lokathor",
        "timestamp": 1649620316
    },
    {
        "content": "<p>I agree it <em>should</em> be considered immediate UB, and you have to use a transmute to go from non-UTF-8 <code>&amp;[u8]</code> to non-UTF-8 <code>&amp;str</code>, but the docs don't make this clear at the moment</p>",
        "id": 278486512,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620317
    },
    {
        "content": "<p>But yes, the debate here is over the exact wording and when the (library) UB happens</p>",
        "id": 278486560,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620346
    },
    {
        "content": "<p>(and thus when the library would be allowed to insert a violation of the Abstract Machine)</p>",
        "id": 278486569,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620365
    },
    {
        "content": "<p>(or, equivalently, a UB sanitizer failure)</p>",
        "id": 278486608,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620423
    },
    {
        "content": "<p>Well I suppose I don't super care on where that falls out, <strong> Saethlin</strong> wants to put a debugger check for valid UTF-8 on that function then I say it's legitimate to have such a debug check. Even if it's not immediate UB it should be fine to have such a check! I genuinely don't care about debug code hitting a panic because it definitely broke safety invariants that it planned to fix up later before anyone noticed. It's honestly fine, really.</p>",
        "id": 278486674,
        "sender_full_name": "Lokathor",
        "timestamp": 1649620476
    },
    {
        "content": "<p>...interesting tangentially related note: <code>from_utf8_unchecked</code> uses <code>mem::transmute</code> but <code>from_utf8_unchecked_mut</code> uses pointer casts... for some reason</p>",
        "id": 278486676,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620481
    },
    {
        "content": "<p>This doc note is from 2015, so I think it's reasonable to say it is loosely worded and tighten the wording for current conventions <a href=\"https://github.com/rust-lang/rust/commit/4d73da92f0e6d00025609e42b1e7f59f00b73be9\">https://github.com/rust-lang/rust/commit/4d73da92f0e6d00025609e42b1e7f59f00b73be9</a></p>",
        "id": 278486825,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649620734
    },
    {
        "content": "<p>I opened a PR: <a href=\"https://github.com/rust-lang/rust/issues/95895\">rust#95895</a></p>",
        "id": 278487137,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649621143
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"224471\">Lokathor</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278486387\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"120827\">Ben Kimock (Saethlin)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278484151\">said</a>:</p>\n<blockquote>\n<p>So it isn't UB to create a str that isn't UTF-8?</p>\n</blockquote>\n<p>It's UB to pass such a <code>&amp;str</code> to any function that expects a normal well-formed <code>&amp;str</code> (which is any function that accepts <code>&amp;str</code>, unless you specifically know otherwise about a specific function).</p>\n<p>and that requirement is arguably <em>separate</em> from the <code>from_utf8_unchecked</code> safety requirements, which are in fact allowed to be \"immediate UB on passing in malformed bytes\", which is what's currently documented.</p>\n</blockquote>\n<p>(library UB)</p>",
        "id": 278489849,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624863
    },
    {
        "content": "<p>but we all agree that adding such checks in <code>from_utf8_unchecked</code> is fine, yes. the part where the docs say \"this is not checked\" should be interpreted as \"the implementation does not <em>guarantee</em> to check this\".</p>",
        "id": 278489914,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624930
    },
    {
        "content": "<p>Are there <em>any</em> std methods that have lang UB on invalid utf-8? I recall looking into this a while ago and I think I couldn't find any</p>",
        "id": 278489918,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649624941
    },
    {
        "content": "<p>I am pretty sure an example was brought up during the safety/validity invariant discussion</p>",
        "id": 278489940,
        "sender_full_name": "RalfJ",
        "timestamp": 1649624991
    },
    {
        "content": "<p>I dont recall if the example was confirmed or refuted though...^^</p>",
        "id": 278489943,
        "sender_full_name": "RalfJ",
        "timestamp": 1649625000
    },
    {
        "content": "<p>there are of course plenty of hypothetical implementations you can make with lang UB on invalid UTF-8</p>",
        "id": 278489994,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649625049
    },
    {
        "content": "<p>ah, here's the thread -&gt; <a href=\"#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings\">https://rust-lang.zulipchat.com/#narrow/stream/122651-general/topic/Memory.20safety.20exploits.20involving.20non-UTF-8.20strings</a></p>",
        "id": 278490017,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649625110
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278489918\">said</a>:</p>\n<blockquote>\n<p>Are there <em>any</em> std methods that have lang UB on invalid utf-8? I recall looking into this a while ago and I think I couldn't find any</p>\n</blockquote>\n<p>I haven't gotten to UTF-8 in lccc libcore yet, but my own UTF-8 hander in a basic-string library uses <code>get_unchecked</code> in <code>decode_char_unchecked</code> and <code>debug_range_unchecked</code> (called by <code>BasicStr&lt;Char,Traits&gt;::unicode_iter()</code> and <code>BasicStr&lt;Char,Traits&gt;::debug()</code> respectively)</p>",
        "id": 278490253,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649625457
    },
    {
        "content": "<p>(So malformed UTF-8 - specifically an unepxected EOS - could lead to OOB accesses in theory).</p>",
        "id": 278490318,
        "sender_full_name": "Connor Horman",
        "timestamp": 1649625521
    },
    {
        "content": "<p>Malformed UTF-8 will lead to out of bounds reads with the rustc std str as well, for any function that does UTF-8 decoding</p>",
        "id": 278491392,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627075
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"132829\">Christopher Durham (CAD97)</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/str.3A.3Afrom_utf8_unchecked.20Safety.20requirement/near/278491392\">said</a>:</p>\n<blockquote>\n<p>Malformed UTF-8 will lead to out of bounds reads with the rustc std str as well, for any function that does UTF-8 decoding</p>\n</blockquote>\n<p>I tried to find that code but couldn't^^</p>",
        "id": 278491464,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627195
    },
    {
        "content": "<p>I know at one point I verified that the chars iterator does</p>",
        "id": 278491481,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627266
    },
    {
        "content": "<p>yeah I thought I had seen that</p>",
        "id": 278491533,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627332
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/blob/027a232755fa9728e9699337267f6675dfd0a8ba/library/core/src/str/validations.rs#L36-L70\">https://github.com/rust-lang/rust/blob/027a232755fa9728e9699337267f6675dfd0a8ba/library/core/src/str/validations.rs#L36-L70</a></p>",
        "id": 278491610,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627445
    },
    {
        "content": "<p>Uses <code>bytes.next().unwrap_unchecked()</code> to get the bytes of a code point encoding</p>",
        "id": 278491614,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627464
    },
    {
        "content": "<p>No longer an OOB read, it seems, \"just\" <code>std::hint::unreachable_unchecked</code></p>",
        "id": 278491620,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627489
    },
    {
        "content": "<p>(Which, of course, given that it's UB, likely compiles to an OOB read, but no guarantees etc)</p>",
        "id": 278491632,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649627510
    },
    {
        "content": "<p>I grepped for 'unreachable' in that folder and didnt' find it...</p>",
        "id": 278491679,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627533
    },
    {
        "content": "<p>I guess I had whole-word matching turned on or something silly like that :/</p>",
        "id": 278491684,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627542
    },
    {
        "content": "<p>ah no it's hidden behind <code>unwrap_unchecked</code>, I see</p>",
        "id": 278491692,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627569
    },
    {
        "content": "<p>I literally saw that code but didnt realize it makes the UTF8 assumption :( oh well</p>",
        "id": 278491700,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627594
    },
    {
        "content": "<p>yeah thats why my grep didnt find it</p>",
        "id": 278491782,
        "sender_full_name": "RalfJ",
        "timestamp": 1649627691
    },
    {
        "content": "<p>Oh, that's a recent change: <a href=\"https://github.com/rust-lang/rust/commit/23637e20cdf3f7b8e01b42dbaf25357e5d3c31ae\">https://github.com/rust-lang/rust/commit/23637e20cdf3f7b8e01b42dbaf25357e5d3c31ae</a></p>",
        "id": 278492450,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649628657
    },
    {
        "content": "<p>that code was safe when I audited it last year</p>",
        "id": 278492462,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649628696
    },
    {
        "content": "<p>A <em>long</em> time ago it used an unchecked slice: <a href=\"https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src/libcore/str.rs#L111\">https://github.com/rust-lang/rust/blob/9bae6ec828fdc7f87838ee008cccef90e31b9f84/src/libcore/str.rs#L111</a></p>",
        "id": 278493229,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649629922
    },
    {
        "content": "<p>But that was before I started using Rust so I have no idea where I saw UTF-8 being trusted</p>",
        "id": 278493260,
        "sender_full_name": "Christopher Durham (CAD97)",
        "timestamp": 1649629940
    },
    {
        "content": "<p>Actually that code is safe because <code>char_range_at</code> is written in such a way that it would panic on earlier byte accesses if the slice was out of bounds</p>",
        "id": 278494027,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1649631237
    },
    {
        "content": "<p>I'm surprised there's not at least a <code>255 =&gt; unreachable_unchecked()</code> somewhere in decoding, since there might as well be, to not have to handle that impossible case.</p>",
        "id": 278639514,
        "sender_full_name": "scottmcm",
        "timestamp": 1649729011
    }
]