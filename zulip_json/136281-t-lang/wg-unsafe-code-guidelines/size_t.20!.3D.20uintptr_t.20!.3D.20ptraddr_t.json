[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274022959\">said</a>:</p>\n<blockquote>\n<p>there are already stabilized things that imply that usize = uintptr, one more isn't going to hurt</p>\n</blockquote>\n<p>I'm vaguely curious, which such things do we have in stable? (Leaving aside the extensive code in the ecosystem making such an assumption.)</p>",
        "id": 274031585,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646337984
    },
    {
        "content": "<p>Because while I have serious doubts that we could fix this, I also think <em>if</em> we decided to separate the two, for didactic reasons the path we'd want to take is <code>usize == size_t</code>, <code>uptr == uintptr_t</code>, rather than making <code>usize</code> not <code>size_t</code>.</p>",
        "id": 274031704,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646338053
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/Int.20to.20pointer.20casts.20-.20union.20provenance.3F/near/274031704\">said</a>:</p>\n<blockquote>\n<p>Because while I have serious doubts that we could fix this, I also think <em>if</em> we decided to separate the two, for didactic reasons the path we'd want to take is <code>usize == size_t</code>, <code>uptr == uintptr_t</code>, rather than making <code>usize</code> not <code>size_t</code>.</p>\n</blockquote>\n<p>Okay so I have done some thought on this and the answer is <code>usize</code> is not necessarily <code>size_t</code> but it isn't necessarily <code>uintptr_t</code> either.<br>\nIt is a type that was not named before CHERI gave it one:<br>\n<code>ptraddr_t</code></p>",
        "id": 274033670,
        "sender_full_name": "Jubilee",
        "timestamp": 1646338864
    },
    {
        "content": "<p>It is <strong>almost</strong> always the case that <code>type_shape_eq(ptraddr_t, size_t)</code>.</p>",
        "id": 274033835,
        "sender_full_name": "Jubilee",
        "timestamp": 1646338940
    },
    {
        "content": "<p>But it is also <strong>almost</strong> always the case that <code>type_shape_eq(ptraddr_t, uintptr_t)</code>.</p>",
        "id": 274033900,
        "sender_full_name": "Jubilee",
        "timestamp": 1646338980
    },
    {
        "content": "<p>(should this be moved to a different topic/stream?)</p>",
        "id": 274034288,
        "sender_full_name": "Jake",
        "timestamp": 1646339153
    },
    {
        "content": "<p>probably. :P I don't have authority to move it to another stream.</p>",
        "id": 274034401,
        "sender_full_name": "Jubilee",
        "timestamp": 1646339185
    },
    {
        "content": "<p>There, another topic.</p>",
        "id": 274034641,
        "sender_full_name": "Jubilee",
        "timestamp": 1646339262
    },
    {
        "content": "<p>CHERI is not actually the first architecture to say that a pointer is not just its memory address... but the last time that was a more <strong>typical</strong> attitude to take even on the <strong>hardware</strong> level was before, frankly, a wave of hackers who insisted that C is just a macro assembler arrived.</p>",
        "id": 274035418,
        "sender_full_name": "Jubilee",
        "timestamp": 1646339547
    },
    {
        "content": "<p>If you can't turn a <code>ptraddr_t</code> back into a valid pointer, then it doesn't seem obvious that what people are doing with <code>usize</code> is equivalent to <code>ptraddr_t</code>. People often treat <code>usize</code> as a numeric type you can <em>round-trip</em> a pointer through losslessly. Assuming I'm understanding CHERI's distinction correctly, that would be <code>uintptr_t</code>, not <code>ptraddr_t</code>, right?</p>",
        "id": 274036598,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340072
    },
    {
        "content": "<p>You can find a ton of older systems where a pointer and an address are different, depending on the model, and what an \"address\" is defined as.<br>\nA near pointer in 8086 isn't the same as a linear address.</p>",
        "id": 274036756,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646340153
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274036598\">said</a>:</p>\n<blockquote>\n<p>If you can't turn a <code>ptraddr_t</code> back into a valid pointer, then it doesn't seem obvious that what people are doing with <code>usize</code> is equivalent to <code>ptraddr_t</code>. People often treat <code>usize</code> as a numeric type you can <em>round-trip</em> a pointer through losslessly. Assuming I'm understanding CHERI's distinction correctly, that would be <code>uintptr_t</code>, not <code>ptraddr_t</code>, right?</p>\n</blockquote>\n<p>correct.<br>\nthe subtle distinction is that on a hypothetical combination of CHERI + segmented memory:<br>\nsize_t &lt; ptr_addr_t &lt; uintptr_t</p>",
        "id": 274036944,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340246
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> While I can <em>imagine</em> such a system, I sincerely hope nobody ever builds one.</p>",
        "id": 274036972,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340266
    },
    {
        "content": "<p>w65 technically is that, because you could call <code>ptr_addr_t</code> there as <code>uint24_t</code>.</p>",
        "id": 274037006,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646340287
    },
    {
        "content": "<p>I agree fully that we can treat the difference as largely academic.</p>",
        "id": 274037007,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340287
    },
    {
        "content": "<p>Also, likewise for 8086, if pointers are far pointers - <code>size_t</code> would be <code>uint16_t</code>, <code>ptr_addr_t</code> would be <code>uint20_t</code>, and <code>uintptr_t</code> would be <code>uint32_t</code>.</p>",
        "id": 274037069,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646340327
    },
    {
        "content": "<p>And while I am aware of and programmed for x86 segmented memory systems, I also think it's reasonable to write off segmented memory systems as something we simply don't support, or at least don't support using our standard types. I think it'd be fine if making Rust run on such a system required very careful code that avoided such assumptions, even while the Rust ecosystem <em>did</em> assume no segmentation.</p>",
        "id": 274037105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340353
    },
    {
        "content": "<p>(in a variant different form from the case of w65, where <code>uintptr_t</code> is just a zero-extended <code>ptr_addr_t</code>.</p>",
        "id": 274037119,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646340360
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274037069\">said</a>:</p>\n<blockquote>\n<p>Also, likewise for 8086, if pointers are far pointers - <code>size_t</code> would be <code>uint16_t</code>, <code>ptr_addr_t</code> would be <code>uint20_t</code>, and <code>uintptr_t</code> would be <code>uint32_t</code>.</p>\n</blockquote>\n<p>I think both <code>ptraddr_t</code> and <code>uintptr_t</code> would be technically 20-bits, and I don't see why zero extension to 32-bits would be applied to one and not the other. Zero-extension in both cases would be a convenience, and zero-extension in neither case would make sense if trying to pack things as small as possible.</p>",
        "id": 274037261,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340429
    },
    {
        "content": "<p>Yeah, the way I think of it as,<br>\nusize != uintptr_t<br>\nusize ≈ size_t</p>",
        "id": 274037345,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340468
    },
    {
        "content": "<p>I think the only thing we should do is be careful of embedding \"usize exactly equals size_t\" into core.<br>\nFor the typical Rust programmer, usize <strong>is</strong> size_t.</p>",
        "id": 274037533,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340542
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274037345\">said</a>:</p>\n<blockquote>\n<p>Yeah, the way I think of it as,<br>\nusize != uintptr_t<br>\nusize ≈ size_t</p>\n</blockquote>\n<p>Right. I think that's the path we'd take forward iff we decide to make the tradeoff of supporting systems where size_t and uintptr_t aren't the same at the expense of breaking a lot of existing code.</p>",
        "id": 274037547,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340547
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274037261\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274037069\">said</a>:</p>\n<blockquote>\n<p>Also, likewise for 8086, if pointers are far pointers - <code>size_t</code> would be <code>uint16_t</code>, <code>ptr_addr_t</code> would be <code>uint20_t</code>, and <code>uintptr_t</code> would be <code>uint32_t</code>.</p>\n</blockquote>\n<p>I think both <code>ptraddr_t</code> and <code>uintptr_t</code> would be technically 20-bits, and I don't see why zero extension to 32-bits would be applied to one and not the other. Zero-extension in both cases would be a convenience, and zero-extension in neither case would make sense if trying to pack things as small as possible.</p>\n</blockquote>\n<p>Not zero extension here. If pointers are being treated as far pointers, then they'd be a (segment,offset) tuple, both <code>u16</code>s, so <code>uintptr_t</code> would be the <code>segment&lt;&lt;16|offset</code>, whereas <code>ptr_addr_t</code> would (in my mind) be a linear address from <code>segment+offset</code> or (in the case of protected mode, <code>GDT[segment].base+offset</code> (the latter makes it a uint36_t on 386+)</p>",
        "id": 274037649,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646340596
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274037533\">said</a>:</p>\n<blockquote>\n<p>I think the only thing we should do is be careful of embedding \"usize exactly equals size_t\" into core.<br>\nFor the typical Rust programmer, usize <strong>is</strong> size_t.</p>\n</blockquote>\n<p>I agree with \"be careful\", but personally I think we <em>should</em> embed that assumption into core, precisely because it's what people widely assume, including from the name.</p>",
        "id": 274037653,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340597
    },
    {
        "content": "<p>oh to be clear</p>",
        "id": 274037807,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340650
    },
    {
        "content": "<p>what I mean is that I think libcore should compile for such a hypothetical Extremely Wonky system, not that its functions are useful</p>",
        "id": 274037855,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340675
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> Ah, I see; you're treating uintptr_t as the <code>(u16, u16)</code> version, where you <em>might</em> have meaningful differences between two different segment/address pairs that map to the same linear address?</p>",
        "id": 274037875,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340689
    },
    {
        "content": "<p>Yes.</p>",
        "id": 274037900,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646340702
    },
    {
        "content": "<p>(And in that case, a roundtrip through <code>ptraddr_t</code> would be lossy at runtime, as it is for CHERI, notably \"canonicalizing\" the address)</p>",
        "id": 274038044,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646340761
    },
    {
        "content": "<p>importantly, usize == ptraddr_t means that usize can still contain the answer to<br>\n\"do these two pointers point at the same place in memory or not?\"</p>",
        "id": 274038060,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274038044\">said</a>:</p>\n<blockquote>\n<p>(And in that case, a roundtrip through <code>ptraddr_t</code> would be lossy at runtime, as it is for CHERI, notably \"canonicalizing\" the address)</p>\n</blockquote>\n<p>(Assuming that canonicalizing is actually semantically lossy.)</p>",
        "id": 274038075,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340776
    },
    {
        "content": "<p>if the answer is 0, then yes.</p>",
        "id": 274038104,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340793
    },
    {
        "content": "<p>it doesn't say they're the <strong>same</strong> pointer</p>",
        "id": 274038133,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340806
    },
    {
        "content": "<p>it just says they are looking at the same spot.</p>",
        "id": 274038159,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340822
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> That's true, but at the same time, in a hypothetical world in which we're distinguishing between size_t and uintptr_t, it's not obvious if we gain much in the way of reduced breakage by allowing people to assume size_t and ptraddr_t are the same.</p>",
        "id": 274038294,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340880
    },
    {
        "content": "<p>We do, actually.</p>",
        "id": 274038388,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340933
    },
    {
        "content": "<p>/me is interested to hear what breakage that avoids.</p>",
        "id": 274038434,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646340959
    },
    {
        "content": "<p>Almost all the currently existing methods on <code>*const T</code> and <code>*mut T</code>.</p>",
        "id": 274038515,
        "sender_full_name": "Jubilee",
        "timestamp": 1646340983
    },
    {
        "content": "<p><em>oh</em>.</p>",
        "id": 274038662,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341058
    },
    {
        "content": "<p>yes, now do you see. :D</p>",
        "id": 274038677,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341065
    },
    {
        "content": "<p>I see. Because <code>ptraddr_t</code> and <code>ptrdiff_t</code> are the same?</p>",
        "id": 274038694,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341076
    },
    {
        "content": "<p>The CHERI people say no but uh<br>\nonly in a lunatic world, yes. ptrdiff_t is isize</p>",
        "id": 274038810,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341119
    },
    {
        "content": "<p>Yeah, that's the confusion I was experiencing.</p>",
        "id": 274038831,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341135
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274038810\">said</a>:</p>\n<blockquote>\n<p>The CHERI people say no but uh<br>\nonly in a lunatic world, yes. ptrdiff_t is isize</p>\n</blockquote>\n<p>I say no, as well, in general.</p>",
        "id": 274038892,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341176
    },
    {
        "content": "<p>(Aside: I <em>can</em> imagine a world in which they're different, but it'd be something like \"all addresses are linear 128-bit addresses, processes get a 64-bit address space to themselves, all addresses are unique even between processes\". And it's not obvious to me that we need to cater to that. In particular, we <em>could</em> support that, if suboptimally, by just making usize 128-bit.)</p>",
        "id": 274038915,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341191
    },
    {
        "content": "<p>I do agree that it's a minority of systems, with a minority of users, that the answer is \"no\" on, though.</p>",
        "id": 274039231,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341229
    },
    {
        "content": "<p>Like they added <code>sptraddr_t</code> and say <code>ptrdiff_t</code> is different than that but my attitude towards the silicon it is untrue on is basically uh</p>",
        "id": 274039280,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341251
    },
    {
        "content": "<p>What actual silicon and systems <em>is</em> it untrue for?</p>",
        "id": 274039323,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341272
    },
    {
        "content": "<p>Hypotheticals aside.</p>",
        "id": 274039333,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341277
    },
    {
        "content": "<p><a href=\"/user_uploads/4715/P7VCuj7PUX5wvS4y5KouIRXx/these_are_not_made.jpg\">these_are_not_made.jpg</a></p>\n<div class=\"message_inline_image\"><a href=\"/user_uploads/4715/P7VCuj7PUX5wvS4y5KouIRXx/these_are_not_made.jpg\" title=\"these_are_not_made.jpg\"><img src=\"/user_uploads/4715/P7VCuj7PUX5wvS4y5KouIRXx/these_are_not_made.jpg\"></a></div>",
        "id": 274039348,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341283
    },
    {
        "content": "<p>( Also I am assuming the C23 definition of <code>ptrdiff_t</code> where they caved and admitted it's fine to have <code>ptrdiff_t</code> be 16 bits. )</p>",
        "id": 274039530,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341349
    },
    {
        "content": "<p>(Huh, I'm surprised that wasn't true before.)</p>",
        "id": 274039570,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341371
    },
    {
        "content": "<p>It had a minimum width of 17 up until 23.</p>",
        "id": 274039618,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341389
    },
    {
        "content": "<p>which everyone ignored.</p>",
        "id": 274039644,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341404
    },
    {
        "content": "<p>Yep. Even I did (and I've been very careful to design my w65 abi arround complying with the C/++ standards)</p>",
        "id": 274039710,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341436
    },
    {
        "content": "<p>This doesn't really solve the \"I want a type for C interop\", but for Rust itself, <code>usize</code> isn't that great of a type for indexing anyway, so I kinda would like a different type for indexing and size_of and such anyway.  <code>x[usize::MAX]</code> only ever works for ZSTs, for example, so just not being able to represent that would be totally ok.</p>\n<p>So something like a <code>uindex</code> type that's <code>u31</code> on a 32-bit platform would actually be rather nice to have.  But I have no idea how to actually add that nicely (because of all the APIs) without a time machine, though.</p>",
        "id": 274039849,
        "sender_full_name": "scottmcm",
        "timestamp": 1646341487
    },
    {
        "content": "<p>Like in the case of Rust we have users who may disagree with our ivory tower perspective and may wish to deploy our most virulent memes against them, but the C Standard has been losing that battle for 24 years. At that time you pack it in.</p>",
        "id": 274039862,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341495
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> Can you clarify why <code>usize</code> <em>isn't</em> great for indexing? That seems like the one case it <em>is</em> great for under any possible change we might make about its interactions with pointers.</p>",
        "id": 274039957,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341551
    },
    {
        "content": "<p>people actually do use ptrdiff_t for indexing sometimes</p>",
        "id": 274040026,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341573
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"125270\">@scottmcm</span> And on at least <em>some</em> systems it may be possible to <code>x[usize::MAX-1]</code>; there's no fundamental reason you can't have a full 64-bit (virtual) address space.</p>",
        "id": 274040056,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341595
    },
    {
        "content": "<p>in general our allocations break if they exceed isize::MAX</p>",
        "id": 274040122,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341633
    },
    {
        "content": "<p>Isn't there some text in the pointer docs saying that this is not allowed?</p>",
        "id": 274040127,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646341636
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274040056\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> And on at least <em>some</em> systems it may be possible to <code>x[usize::MAX-1]</code>; there's no fundamental reason you can't have a full 64-bit address space.</p>\n</blockquote>\n<p>Except llvm, lccc, probably gcc, and I think rust itself, says that indexing occurs in signed integers.</p>",
        "id": 274040173,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341662
    },
    {
        "content": "<p>^ what jubilee said, that's an LLVM limitation IIRC</p>",
        "id": 274040174,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646341662
    },
    {
        "content": "<p>Fair, and I'm not saying that's entirely viable with current toolchains or systems. I more meant, it's not obvious what we'd <em>gain</em> by doing indexing with a u31/u63.</p>",
        "id": 274040264,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341692
    },
    {
        "content": "<p>it does seem like a silly restriction though</p>",
        "id": 274040272,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646341696
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274040272\">said</a>:</p>\n<blockquote>\n<p>it does seem like a silly restriction though</p>\n</blockquote>\n<p>It's because you can do negative indexing on pointers.</p>",
        "id": 274040303,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341716
    },
    {
        "content": "<p>I don't see why that matters</p>",
        "id": 274040364,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646341740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274039231\">said</a>:</p>\n<blockquote>\n<p>I do agree that it's a minority of systems, with a minority of users, that the answer is \"no\" on, though.</p>\n</blockquote>\n<p>cough up their names and addresses, Connor.</p>",
        "id": 274040395,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341759
    },
    {
        "content": "<p>you can just use different operations to say what you want</p>",
        "id": 274040401,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646341762
    },
    {
        "content": "<p>I JUST WANT TO TALK.</p>",
        "id": 274040407,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341767
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274040395\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274039231\">said</a>:</p>\n<blockquote>\n<p>I do agree that it's a minority of systems, with a minority of users, that the answer is \"no\" on, though.</p>\n</blockquote>\n<p>cough up their names and addresses, Connor.</p>\n</blockquote>\n<p>w65 with the abi defined by SNES-Dev. 8086 in far pointer segmented model are the ones I can think of off the top of my head.</p>",
        "id": 274040514,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341811
    },
    {
        "content": "<p>With 8086 in far-pointer segmented, ptrdiff_t and ptraddr_t would still be the same (20 bits), as far as I can tell.</p>",
        "id": 274040572,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646341842
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274040401\">said</a>:</p>\n<blockquote>\n<p>you can just use different operations to say what you want</p>\n</blockquote>\n<p>I can't speak for llvm (though it doesn't have signed integers at the ir level), but I really like the consistency of <em>one</em> <code>add</code> instruction.</p>",
        "id": 274040626,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341876
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274040572\">said</a>:</p>\n<blockquote>\n<p>With 8086 in far-pointer segmented, ptrdiff_t and ptraddr_t would still be the same (20 bits), as far as I can tell.</p>\n</blockquote>\n<p>ptrdiff_t and size_t would be 16-bit, since objects wouldn't be able to cross segments (and you can't semantically index accross segments efficiently with a far pointer)</p>",
        "id": 274040683,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341912
    },
    {
        "content": "<p>At the hardware level, it <em>is</em> one <code>add</code> instruction</p>",
        "id": 274040684,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646341912
    },
    {
        "content": "<p><a href=\"https://github.com/SNES-Dev/abi\">https://github.com/SNES-Dev/abi</a><br>\nCONNOR</p>",
        "id": 274040694,
        "sender_full_name": "Jubilee",
        "timestamp": 1646341919
    },
    {
        "content": "<p>Hello.</p>",
        "id": 274040760,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341932
    },
    {
        "content": "<p>I chose ptrdiff_t and size_t to be 16-bit because<br>\na) Objects can't be more than 64k in size<br>\nb) I like the efficient codegen of memcpy when size_t is 16-bit</p>",
        "id": 274040823,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341970
    },
    {
        "content": "<p>32-bit size_t actually makes memcpy quite less than viable.</p>",
        "id": 274040849,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646341999
    },
    {
        "content": "<p>ptrdiff_t should still be 20 bits, though, so it can represent any location in memory.</p>",
        "id": 274040871,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342011
    },
    {
        "content": "<p>It's not <em>completely</em> invalid to make <code>size_t</code> different than <code>ptrdiff_t</code>/<code>ptraddr_t</code>, though that doesn't mean we should support such systems. But I think it <em>is</em> completely invalid to make <code>ptrdiff_t</code> not able to represent the difference between two arbitrary pointers.</p>",
        "id": 274040888,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646342024
    },
    {
        "content": "<p>I don't mind if you lower usize ops to 16 bits though.</p>",
        "id": 274040891,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342025
    },
    {
        "content": "<p>ptrdiff_t does not proport to represent any location in memory.<br>\nIt's defined as the difference between two indecies of an array.</p>",
        "id": 274040966,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342055
    },
    {
        "content": "<p>uuugh</p>",
        "id": 274041053,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342102
    },
    {
        "content": "<p>I am going to ask Jean-Heyd if you are right.</p>",
        "id": 274041066,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342109
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274040888\">said</a>:</p>\n<blockquote>\n<p>It's not <em>completely</em> invalid to make <code>size_t</code> different than <code>ptrdiff_t</code>/<code>ptraddr_t</code>, though that doesn't mean we should support such systems. But I think it <em>is</em> completely invalid to make <code>ptrdiff_t</code> not able to represent the difference between two arbitrary pointers.</p>\n</blockquote>\n<p>You can't get the difference between two arbitrary pointers, at least, not in C.<br>\nAlso, I really like the assumption that <code>ptrdiff_t</code>==<code>signed size_t</code></p>",
        "id": 274041071,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342111
    },
    {
        "content": "<p>c2x:</p>\n<blockquote>\n<p>The types are <code>ptrdiff_t</code> which is the signed integer type of the result of subtracting two pointers</p>\n</blockquote>",
        "id": 274041105,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646342132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274041105\">said</a>:</p>\n<blockquote>\n<p>c2x:</p>\n<blockquote>\n<p>The types are <code>ptrdiff_t</code> which is the signed integer type of the result of subtracting two pointers</p>\n</blockquote>\n</blockquote>\n<p>Yes, but you can't subtract <em>arbitrary</em> pointers.</p>",
        "id": 274041132,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342152
    },
    {
        "content": "<p>Chapter and verse of the C standard, please, to determine whether C is wrong or just your ABI? ;)</p>",
        "id": 274041196,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646342173
    },
    {
        "content": "<p>that's some classic C reasoning there</p>",
        "id": 274041197,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646342173
    },
    {
        "content": "<p>20 bits - 20 bits = 16 bits but it's not broken math, it's the magic of UB <span aria-label=\"rainbow\" class=\"emoji emoji-1f308\" role=\"img\" title=\"rainbow\">:rainbow:</span></p>",
        "id": 274041250,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646342198
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274041196\">said</a>:</p>\n<blockquote>\n<p>Chapter and verse of the C standard, please, to determine whether C is wrong or just your ABI? ;)</p>\n</blockquote>\n<p>Already searching.</p>",
        "id": 274041252,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342203
    },
    {
        "content": "<p>Ah, found it. J.2 on UB includes \"— Pointers that do not point into, or just beyond, the same array object are subtracted (6.5.6).\"</p>",
        "id": 274041278,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646342216
    },
    {
        "content": "<p>So C is wrong, and your ABI is technically compliant with C's incorrectness. ;)</p>",
        "id": 274041302,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646342226
    },
    {
        "content": "<p>It's under the definition of <code>-</code>.</p>",
        "id": 274041306,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342231
    },
    {
        "content": "<p>6.5.6#9</p>\n<blockquote>\n<p>When two pointers are subtracted, both shall point to elements of the same array object,<br>\nor one past the last element of the array object; the result is the difference of the<br>\nsubscripts of the two array elements.</p>\n</blockquote>",
        "id": 274041453,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342295
    },
    {
        "content": "<p>All pointer arithmetic in C is defined in terms of indecies of elements in an array.</p>",
        "id": 274041552,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342343
    },
    {
        "content": "<p>/shrug</p>",
        "id": 274041574,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342357
    },
    {
        "content": "<p>Hypothesis: most uses of pointer subtraction are when the sign of the result is known (probably nonnegative). I would love a version of offset_from that returns a usize</p>",
        "id": 274041611,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646342380
    },
    {
        "content": "<p>Same paragram also has</p>\n<blockquote>\n<p>The size of the result is implementation-defined, and its type (a signed integer type) is ptrdiff_t defined in the &lt;stddef.h&gt; header.<br>\nIf the result is not representable in an object of that type, the behavior is undefined</p>\n</blockquote>",
        "id": 274041614,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342381
    },
    {
        "content": "<p>Anyways: <code>isize</code> is <strong>morally</strong> our equivalent to <code>ptrdiff_t</code></p>",
        "id": 274041748,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342428
    },
    {
        "content": "<p>(Which means that you can allow arrays of <code>unsigned char</code> larger than <code>PTRDIFF_MAX</code> in size without breaking anything)</p>",
        "id": 274041759,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342433
    },
    {
        "content": "<p>And I must admit that in any well-behaved Rust code, Connor should never have to worry about this issue.</p>",
        "id": 274041783,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342453
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274040056\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"125270\">scottmcm</span> And on at least <em>some</em> systems it may be possible to <code>x[usize::MAX-1]</code>; there's no fundamental reason you can't have a full 64-bit (virtual) address space.</p>\n</blockquote>\n<p><code>ptr::offset</code> says you can't, though.  As do <code>slice::from_raw_parts</code> and such.</p>\n<p>And making that a niche would be great for <code>Option&lt;usize&gt;</code>.</p>",
        "id": 274041798,
        "sender_full_name": "scottmcm",
        "timestamp": 1646342460
    },
    {
        "content": "<p><code>Layout</code> constructors being safe does as well.</p>",
        "id": 274041865,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342490
    },
    {
        "content": "<p>Like,<br>\nI don't think, morally speaking, that we should care about the w65 as far as our overall Rust model goes.</p>",
        "id": 274041990,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342540
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274041865\">said</a>:</p>\n<blockquote>\n<p><code>Layout</code> constructors being safe does as well.</p>\n</blockquote>\n<p>How do you figure? Doesn't it return a result and check bounds?</p>",
        "id": 274042029,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646342559
    },
    {
        "content": "<p>It just should incidentally be the case that you can use Rust, if you are very careful with it, to emit correct code for an SNES.</p>",
        "id": 274042085,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342584
    },
    {
        "content": "<p><code>Layout::of::&lt;T&gt;()</code> is safe and returns a <code>Layout</code></p>",
        "id": 274042096,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342592
    },
    {
        "content": "<p>I'm not seeing the contradiction</p>",
        "id": 274042161,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646342625
    },
    {
        "content": "<p><code>Layout::of::&lt;[u8;usize::MAX]&gt;()</code> safely returns an illegal Layout</p>",
        "id": 274042265,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646342656
    },
    {
        "content": "<p>I would have assumed that would produce a post-mono error</p>",
        "id": 274042345,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646342687
    },
    {
        "content": "<p>and from a practical perspective, even if ptraddr_t != size_t on the SNES,<br>\nyou should be able to almost always use 16 bit types.<br>\nfunctionally, the detail though is that we should consider that an optimization, like how if you cast a u8 to usize to index then LLVM can ignore the cast.</p>",
        "id": 274042401,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342711
    },
    {
        "content": "<p>Layout::of for <code>[u8; usize::MAX]</code> gives a compile error.</p>",
        "id": 274042773,
        "sender_full_name": "bjorn3",
        "timestamp": 1646342904
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"239881\">@Josh Triplett</span> Also it's worth noting that subtracting pointers from outside the same segment causes UB in C.</p>",
        "id": 274042900,
        "sender_full_name": "Jubilee",
        "timestamp": 1646342996
    },
    {
        "content": "<p>There's also <code>Layout::from_val</code>, if you could produce a value of <code>[u8;usize::MAX]</code> anywhere.</p>",
        "id": 274042935,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343003
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>error: values of the type `[u8; 18446744073709551615]` are too big for the current architecture\n</code></pre></div>",
        "id": 274043149,
        "sender_full_name": "bjorn3",
        "timestamp": 1646343031
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274042900\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> Also it's worth noting that subtracting pointers from outside the same segment causes UB in C.</p>\n</blockquote>\n<p>Yep, since objects won't ever cross segments (in segmented 8086)</p>",
        "id": 274043211,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343065
    },
    {
        "content": "<p>No, you can't produce such a value.</p>",
        "id": 274043231,
        "sender_full_name": "bjorn3",
        "timestamp": 1646343079
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"133247\">bjorn3</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274043231\">said</a>:</p>\n<blockquote>\n<p>No, you can't produce such a value.</p>\n</blockquote>\n<p>Currently. Above was a discussion of the theoretical possibility of allowing it, and I'm offering a reason that wouldn't be possible.</p>",
        "id": 274043382,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343138
    },
    {
        "content": "<p>If this were to be a legal type, then I don't see why it couldn't be a legal <code>Layout</code> as well</p>",
        "id": 274043715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646343306
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274042900\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> Also it's worth noting that subtracting pointers from outside the same segment causes UB in C.</p>\n</blockquote>\n<p>As a general rule, I'm much <em>less</em> interested in spec-UB, and much more interested in what compilers actually break and have good reason to break.</p>",
        "id": 274043970,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646343456
    },
    {
        "content": "<p>indeed.</p>",
        "id": 274044002,
        "sender_full_name": "Jubilee",
        "timestamp": 1646343475
    },
    {
        "content": "<p>I don't know how existing C compilers address SNES.</p>",
        "id": 274044092,
        "sender_full_name": "Jubilee",
        "timestamp": 1646343505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274043970\">said</a>:</p>\n<blockquote>\n<p>As a general rule, I'm much <em>less</em> interested in spec-UB, and much more interested in what compilers actually break and have good reason to break.</p>\n</blockquote>\n<p>I like spec-ub because it means I can some back to things that are considered UB but not previously exploited.<br>\nThat being said, disallowing cross-segment subtraction means that subtraction on e.g. 8086 can be compiled to a sub+and.</p>",
        "id": 274044174,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343570
    },
    {
        "content": "<p>Any compiler developer talking about \"UB but not previously exploited\" is perpetuating the issue that UB is perceived (correctly in some cases) as a weapon compiler authors use against developers in that language.</p>",
        "id": 274044318,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646343628
    },
    {
        "content": "<p>lmao</p>",
        "id": 274044344,
        "sender_full_name": "Jubilee",
        "timestamp": 1646343648
    },
    {
        "content": "<p>w65 aside, I'm genuinely interested in how we <em>can</em> handle CHERI without breaking half the Rust ecosystem's uses of usize.</p>",
        "id": 274044403,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646343679
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274044092\">said</a>:</p>\n<blockquote>\n<p>I don't know how existing C compilers address SNES.</p>\n</blockquote>\n<p>They don't. I was working on gcc, but I'm probably going to focus on SNES-Dev support in lccc, mostly because gcc is highly confusing.</p>",
        "id": 274044415,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343686
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274044318\">said</a>:</p>\n<blockquote>\n<p>Any compiler developer talking about \"UB but not previously exploited\" is perpetuating the issue that UB is perceived (correctly in some cases) as a weapon compiler authors use against developers in that language.</p>\n</blockquote>\n<p>It really is. Although there are other parts of it, such as allowing significant implementation differences (more than would be expected for implementation-defined or unspecified), it really is. I've held this belief since long before I've worked on a compiler</p>",
        "id": 274044567,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343766
    },
    {
        "content": "<p>/me is not successfully parsing that statement. \"it really is\" used as a weapon? \"it really is\" UB?</p>",
        "id": 274044665,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646343819
    },
    {
        "content": "<p>\"It really is a weapon\".</p>",
        "id": 274044745,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343847
    },
    {
        "content": "<p>Or rather, a tool.</p>",
        "id": 274044759,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343856
    },
    {
        "content": "<p>A tool to produce fast code because people want their poorly written code to run fast even though it's poorly written.</p>",
        "id": 274044790,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646343878
    },
    {
        "content": "<p>To the extent it's used a weapon, that's an excellent argument for specs having <em>less</em> of it, and certainly a reason why I hope the term appears as little as it possibly can in any Rust spec that may or may not exist in the future. To the extent it's <em>not</em> used as a weapon, it might have value.</p>",
        "id": 274045130,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646344050
    },
    {
        "content": "<p>To the extent you successfully make the case that UB is a weapon, I'm going to take that as a case for disarmament. :)</p>",
        "id": 274045198,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646344082
    },
    {
        "content": "<p>I also think we're drifting <em>massively</em> off topic from the hope of future support for unusual targets.</p>",
        "id": 274045278,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646344129
    },
    {
        "content": "<p>Every weapon to one is a tool to another. Every tool to one is a weapon to another.</p>",
        "id": 274045332,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646344175
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274044403\">said</a>:</p>\n<blockquote>\n<p>w65 aside, I'm genuinely interested in how we <em>can</em> handle CHERI without breaking half the Rust ecosystem's uses of usize.</p>\n</blockquote>\n<p>So, as mentioned, all our existing pointer methods depend on usize being capable of addressing everything in memory. They <strong>do not</strong> depend on usize being capable of handling existing metadata tags, etc.<br>\nAnd for CHERI, I believe the correct approach is to introduce ways to make it easy to handle pointers directly.<br>\nI have already mentioned we might need a new type roughly equivalent to <code>void *</code>, but things like the <code>map</code> solution I proposed also help.</p>\n<p>I believe this is a minimal breakage path.<br>\nIf we wish to cleave apart <code>size_t</code> and <code>ptraddr_t</code>, fully, then I believe we <strong>could</strong> do that, but we would really need to deploy some aggressive code transformation tools to even think about it.</p>",
        "id": 274045345,
        "sender_full_name": "Jubilee",
        "timestamp": 1646344189
    },
    {
        "content": "<p>I think that seems reasonable.</p>",
        "id": 274046151,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646344653
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I definitely don't think we should separate <code>usize</code>/<code>size_t</code>/<code>ptrdiff_t</code>/<code>ptraddr_t</code>; that'd be too high a cost to the ecosystem.<br>\nI think we <em>could</em> manage to handle <code>usize</code> != <code>uintptr_t</code>.<br>\nOr, perhaps, at least make it <em>possible</em> to handle systems like that while also making it possible to say \"hey, my code wants to assume those are the same, let me declare that up front\", such as via the portability lint or similar.</p>",
        "id": 274046287,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646344711
    },
    {
        "content": "<p>Code that calls the methods on pointers would mostly still work. Code that uses <code>usize</code> in FFI would still work. Code that uses <code>usize</code> to handle arbitrary pointers as numbers wouldn't on CHERI, but we could potentially decide to say \"that works on most systems, we're not saying it works everywhere but you <em>could</em> assume that and just not work on systems where it's not true\".</p>",
        "id": 274046400,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646344792
    },
    {
        "content": "<p>And then, yeah, we could introduce the \"numeric pointer\" type (what's the leading candidate name for that, BTW?), and codebases that migrate to that <em>would</em> work on CHERI, while old code would continue to work everywhere else.</p>",
        "id": 274046739,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646344846
    },
    {
        "content": "<p>I've seen <code>uptr</code> before, at least.<br>\nIt's also not <strong>necessarily</strong> the case that we need it, we could just do things like exposing methods that allow tweaking or introspecting on the bits of the address directly on pointers.</p>",
        "id": 274046889,
        "sender_full_name": "Jubilee",
        "timestamp": 1646344920
    },
    {
        "content": "<p>But however that interface goes down, we should make it sufficiently ergonomic that we don't have to actually worry about anyone doing that in legacy code, IMO, and basically treat attempts to reduce a pointer to a usize as a mistake.</p>",
        "id": 274047013,
        "sender_full_name": "Jubilee",
        "timestamp": 1646344966
    },
    {
        "content": "<p>There should be a clippy restriction lint for that if there isn't already</p>",
        "id": 274047056,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646344997
    },
    {
        "content": "<p>the main issue being that there is no current alternative</p>",
        "id": 274047093,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345022
    },
    {
        "content": "<p>Yes. If we make it well-defined behavior and easy to use, people should feel most inclined to write the <strong>correct</strong> code.</p>",
        "id": 274047101,
        "sender_full_name": "Jubilee",
        "timestamp": 1646345027
    },
    {
        "content": "<p>It's a little funny to me that Rust is lagging behind C here in modeling reality, I'm used to the reverse situation</p>",
        "id": 274047220,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345092
    },
    {
        "content": "<p>I believe less code actually relies on the \"a pointer is definitely a usize, right?\" thing than the claims we are commonly sold, I just believe that it's definitely a case we straight-up made a mistake here, and there's no good alternative, and there should be.</p>",
        "id": 274047266,
        "sender_full_name": "Jubilee",
        "timestamp": 1646345128
    },
    {
        "content": "<p>I do agree though that if we are considering this level of breakage... even though I noted that it offers less breakage, I will admit: We <strong>can</strong> consider making it so <code>usize</code> really does just mean <code>size_t</code> always, and deploy the aggressive code transformation tools to author a new reality, and a new type.</p>",
        "id": 274047557,
        "sender_full_name": "Jubilee",
        "timestamp": 1646345292
    },
    {
        "content": "<p>For safe code that only uses <code>usize</code> as \"that thing that <code>len()</code> returns and <code>arr[_]</code> takes\", am I right in understanding that you would only ever interact with the <code>size_t</code> version and <code>uintptr_t</code> and <code>ptrdiff_t</code> would never appear?</p>",
        "id": 274047954,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345519
    },
    {
        "content": "<p>I know I have definitely assumed <code>usize</code> = <code>uintptr_t</code> before</p>",
        "id": 274048054,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646345559
    },
    {
        "content": "<p>I assume the main place <code>usize</code> meaning <code>uintptr_t</code> appears is in code that does <code>*const T as usize</code></p>",
        "id": 274048126,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345603
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274047557\">said</a>:</p>\n<blockquote>\n<p>I do agree though that if we are considering this level of breakage... even though I noted that it offers less breakage, I will admit: We <strong>can</strong> consider making it so <code>usize</code> really does just mean <code>size_t</code> always, and deploy the aggressive code transformation tools to author a new reality, and a new type.</p>\n</blockquote>\n<p>At the moment, what I'd love to do is incrementally ratchet one thing we guarantee: I'd like to ratify a consensus that <code>usize == size_t = ptrdiff_t</code>, <em>without</em> yet definitively settling the question of whether <code>usize == uintptr_t</code>.</p>",
        "id": 274048140,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646345614
    },
    {
        "content": "<blockquote>\n<p>I assume the main place <code>usize</code> meaning <code>uintptr_t</code> appears is in code that does <code>*const T as usize</code></p>\n</blockquote>\n<p>yes, or <code>usize as *mut T</code></p>",
        "id": 274048249,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646345654
    },
    {
        "content": "<p>which is bad for other reasons (see the thread this one split from)</p>",
        "id": 274048270,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274048249\">said</a>:</p>\n<blockquote>\n<blockquote>\n<p>I assume the main place <code>usize</code> meaning <code>uintptr_t</code> appears is in code that does <code>*const T as usize</code></p>\n</blockquote>\n<p>yes, or <code>usize as *mut T</code></p>\n</blockquote>\n<p>Or <code>math(*mut T as usize) as *mut T</code>, with a later <code>unmath(*mut T as usize) as *mut T</code>. (With the outer <code>as *mut T</code> casts appearing or not appearing depending on whether storage/serialization is as a pointer or a <code>usize</code>.)</p>",
        "id": 274048363,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646345740
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274047954\">said</a>:</p>\n<blockquote>\n<p>For safe code that only uses <code>usize</code> as \"that thing that <code>len()</code> returns and <code>arr[_]</code> takes\", am I right in understanding that you would only ever interact with the <code>size_t</code> version and <code>uintptr_t</code> and <code>ptrdiff_t</code> would never appear?</p>\n</blockquote>\n<p>correct.</p>",
        "id": 274048384,
        "sender_full_name": "Jubilee",
        "timestamp": 1646345754
    },
    {
        "content": "<p>If we somehow transition to a world where those math-casts are expressed as <code>(_: *mut T).map(|addr| math(addr))</code>, the type of <code>addr</code> can potentially be a smaller integer type than <code>uintptr_t</code> (<del>not sure what it would be called here</del> I guess this is <code>ptraddr_t</code>), which for CHERI pointers would mean just the address without the capability part</p>",
        "id": 274048609,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345869
    },
    {
        "content": "<p>in which case we might not need <code>uintptr_t</code> as a concept</p>",
        "id": 274048716,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345921
    },
    {
        "content": "<p>certainly for CHERI it is pretty suspicious, <code>u128</code> isn't doing what we want</p>",
        "id": 274048750,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646345944
    },
    {
        "content": "<p>My position is, essentially:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"n\">type_nonequal</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">uintptr_t</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">bitsize_of</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&lt;=</span><span class=\"w\"> </span><span class=\"n\">bitsize_of</span><span class=\"p\">(</span><span class=\"n\">ptraddr_t</span><span class=\"p\">)</span><span class=\"w\"></span>\n<span class=\"n\">bitsize_of</span><span class=\"p\">(</span><span class=\"kt\">usize</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">&gt;=</span><span class=\"w\"> </span><span class=\"n\">bitsize_of</span><span class=\"p\">(</span><span class=\"n\">size_t</span><span class=\"p\">)</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274048961,
        "sender_full_name": "Jubilee",
        "timestamp": 1646346040
    },
    {
        "content": "<p>yes, CHERI pointers are essentially a struct with an address inside them and then a bunch of fields specifying the allowed range, type, etc. of the pointer, collectively referred to as a \"capability\"</p>",
        "id": 274049223,
        "sender_full_name": "Jubilee",
        "timestamp": 1646346185
    },
    {
        "content": "<p>Other ABIs in the past have also encoded ideas like offsets, etc. directly into the pointer.</p>",
        "id": 274049461,
        "sender_full_name": "Jubilee",
        "timestamp": 1646346324
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274048140\">said</a>:</p>\n<blockquote>\n<p>At the moment, what I'd love to do is incrementally ratchet one thing we guarantee: I'd like to ratify a consensus that <code>usize == size_t = ptrdiff_t</code>, <em>without</em> yet definitively settling the question of whether <code>usize == uintptr_t</code>.</p>\n</blockquote>\n<p>unsure if that is what you were looking for re: this matter</p>",
        "id": 274050490,
        "sender_full_name": "Jubilee",
        "timestamp": 1646346853
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> I'd prefer to delete the <code>&gt;</code> and <code>&lt;</code> from your pseudocode above. And I don't actually want to ratify <code>type_nonequal(usize, uintptr_t)</code> yet, I'd like to settle that <em>separately</em> from incrementally saying a bit more about usize.</p>",
        "id": 274050695,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646346968
    },
    {
        "content": "<p>Well, my lingering question regarding the <code>ptraddr_t</code> vs <code>size_t</code> matter is if we ever <strong>do</strong> want to support segmented memory architectures and if so how.</p>",
        "id": 274052759,
        "sender_full_name": "Jubilee",
        "timestamp": 1646348167
    },
    {
        "content": "<p>Fair.</p>",
        "id": 274053686,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646348560
    },
    {
        "content": "<p>I think rust <em>should</em> support segmented memory architectures in <code>void*</code>=<code>void* _near</code> mode, and it should be a separate question whether it supports <code>void* _far</code>. <br>\nThe only thing that gives me pause with allowing the first as-is, is that you could have pointers to different segments (data vs. stack), but if that's not the case, I think rust can already (since it doesn't guarantee that converting between function and data pointers are meaningful).</p>",
        "id": 274053787,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646348620
    },
    {
        "content": "<p>cursed memory architecture secrets <a href=\"https://www.kernel.org/doc/html/latest/x86/x86_64/fsgs.html\">https://www.kernel.org/doc/html/latest/x86/x86_64/fsgs.html</a></p>",
        "id": 274054586,
        "sender_full_name": "Jubilee",
        "timestamp": 1646349054
    },
    {
        "content": "<p>I'm just glad that in 64-bit mode those are <em>just</em> an offset, nothing more.</p>",
        "id": 274054667,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646349099
    },
    {
        "content": "<p><em>runs program in compatibility mode</em></p>",
        "id": 274054760,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646349127
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274047266\">said</a>:</p>\n<blockquote>\n<p>I believe less code actually relies on the \"a pointer is definitely a usize, right?\" thing than the claims we are commonly sold, I just believe that it's definitely a case we straight-up made a mistake here, and there's no good alternative, and there should be.</p>\n</blockquote>\n<p>I don't know how many you expect. But currently, I can tell you that out of the top 4379 crates, 157 of them execute an int-to-pointer cast which is within the reach of Miri through their test suite. I think 76 of those 157 crates actually contain the cast, the rest do it via a dependency.</p>\n<p>I think the far more interesting question is whether all of those can get the functionality they need without doing this cast. I've only audited a few, but I have yet to see any that do something other than bit-packing into the alignment bits of a pointer, or just wanted to use <code>+</code> on <code>*mut u8</code>, so they converted them to <code>usize</code>.</p>",
        "id": 274056250,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646350112
    },
    {
        "content": "<p>The numbers are a bit muddied by the fact that <code>bytes</code> does this cast, and therefore basically all the web ecosystem does.</p>",
        "id": 274056347,
        "sender_full_name": "Ben Kimock (Saethlin)",
        "timestamp": 1646350188
    },
    {
        "content": "<p>there are also cases where I need <code>0x12345678 as *mut T</code>, mostly for embedded stuff</p>",
        "id": 274060768,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646353073
    },
    {
        "content": "<p>I think we should have a way to declare certain \"well-known addresses\" to the compiler, explicitly.</p>",
        "id": 274060835,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274060768\">said</a>:</p>\n<blockquote>\n<p>there are also cases where I need <code>0x12345678 as *mut T</code>, mostly for embedded stuff</p>\n</blockquote>\n<p>Embedded stuff is non-portable anyways.<br>\n<code>0x12345678 as *mut T</code> will have zero meaning on w65.</p>",
        "id": 274061019,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353254
    },
    {
        "content": "<p>yeah.</p>",
        "id": 274061028,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353262
    },
    {
        "content": "<p>(Also, TBH, using casts for this is <span aria-label=\"neutral\" class=\"emoji emoji-1f610\" role=\"img\" title=\"neutral\">:neutral:</span>, I prefer using magic linker symbols to magic numbers)</p>",
        "id": 274061198,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353371
    },
    {
        "content": "<p>yes.</p>",
        "id": 274061222,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353384
    },
    {
        "content": "<p>well...that doesn't cover stuff like (UB, but people need it anyway):</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">debugger_main</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">read_commands</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Command</span>::<span class=\"n\">ReadMem</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">.</span><span class=\"n\">parse</span>::<span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)})</span><span class=\"o\">?</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div>",
        "id": 274061366,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646353459
    },
    {
        "content": "<p>(I do understand the code that already does this and expects to be able to do it, though, so I will begrudingly support it)</p>",
        "id": 274061430,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353509
    },
    {
        "content": "<p>lol????</p>",
        "id": 274061467,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353541
    },
    {
        "content": "<p>Yeah, I've been told that I can't just make <code>addr as *mut u8</code> non-dereferenceable(n) for n&gt;0.</p>",
        "id": 274061602,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353624
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274061366\">said</a>:</p>\n<blockquote>\n<p>well...that doesn't cover stuff like (UB, but people need it anyway):</p>\n<p><div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"k\">fn</span> <span class=\"nf\">debugger_main</span><span class=\"p\">()</span><span class=\"w\"> </span>-&gt; <span class=\"nb\">Result</span><span class=\"o\">&lt;</span><span class=\"p\">()</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"w\"> </span><span class=\"k\">in</span><span class=\"w\"> </span><span class=\"n\">read_commands</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">match</span><span class=\"w\"> </span><span class=\"n\">cmd</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">Command</span>::<span class=\"n\">ReadMem</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">=&gt;</span><span class=\"w\"> </span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">.</span><span class=\"n\">parse</span>::<span class=\"o\">&lt;</span><span class=\"kt\">usize</span><span class=\"o\">&gt;</span><span class=\"p\">()</span><span class=\"o\">?</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">const</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">)})</span><span class=\"o\">?</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"o\">..</span><span class=\"p\">.</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><br>\n</p>\n</blockquote>\n<p>uhhh I can't tell what you're trying to do here</p>",
        "id": 274061778,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353753
    },
    {
        "content": "<p>It's reading an address out of a command, and using it to poke arbitrary memory.</p>",
        "id": 274061811,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353784
    },
    {
        "content": "<p>Which is horrible, horrible UB.</p>",
        "id": 274061825,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353797
    },
    {
        "content": "<p>isn't this PEEK not POKE</p>",
        "id": 274062052,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353825
    },
    {
        "content": "<p>Oh yeah PEEK.</p>",
        "id": 274062058,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353834
    },
    {
        "content": "<p>POKE is even worse.</p>",
        "id": 274062065,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353841
    },
    {
        "content": "<p>debuggers often need memory writing too</p>",
        "id": 274062082,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646353861
    },
    {
        "content": "<p>it would be sad if we had to resort to inline asm to get the compiler to behave how we want there</p>",
        "id": 274062161,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646353919
    },
    {
        "content": "<p>I was thrown by the write not matching <code>write!</code> syntax</p>",
        "id": 274062163,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353920
    },
    {
        "content": "<p>You're reading/writing to arbitrary memory within the context of that process.<br>\nIf you run into memory owned by the compiler, it will demolish you.</p>",
        "id": 274062217,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353939
    },
    {
        "content": "<p>anyways <span class=\"user-mention\" data-user-id=\"229517\">@Jacob Lifshay</span>, I don't see why addr can't simply be a pointer</p>",
        "id": 274062237,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353968
    },
    {
        "content": "<p>Not least of which if you have any <code>&amp;mut</code>/<code>&amp;</code> to said memory (but even without it).</p>",
        "id": 274062240,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646353974
    },
    {
        "content": "<p>a raw pointer yes</p>",
        "id": 274062242,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353976
    },
    {
        "content": "<p>but why not</p>",
        "id": 274062253,
        "sender_full_name": "Jubilee",
        "timestamp": 1646353988
    },
    {
        "content": "<p>(Also, debuggers of any kind are frankly cursed when surrounded by pointer optimizations of any kind. They're basically manifestly undefined behaviour just attaching)</p>",
        "id": 274062273,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354014
    },
    {
        "content": "<p>because we have to parse the address from text/some communication protocol at some point, might as well do it in the example code</p>",
        "id": 274062284,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354029
    },
    {
        "content": "<p>oh.</p>",
        "id": 274062296,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354039
    },
    {
        "content": "<p>yeah I am assuming you can still try to deserialize bytes into a pointer.</p>",
        "id": 274062352,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354063
    },
    {
        "content": "<p>Address from communciation protocol?</p>",
        "id": 274062356,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354068
    },
    {
        "content": "<p>And I am assuming you don't need to go through usize</p>",
        "id": 274062360,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354075
    },
    {
        "content": "<p>Sounds like a CVE waiting to happen.</p>",
        "id": 274062366,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354084
    },
    {
        "content": "<p>and yes</p>",
        "id": 274062372,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354090
    },
    {
        "content": "<p>like gdb's debugger protocol</p>",
        "id": 274062377,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354094
    },
    {
        "content": "<p>Free ACE/RCE.</p>",
        "id": 274062383,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354101
    },
    {
        "content": "<p>I am assuming that like</p>",
        "id": 274062391,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354106
    },
    {
        "content": "<p>\"try\"<br>\nmay be the active word here</p>",
        "id": 274062399,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354113
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274062377\">said</a>:</p>\n<blockquote>\n<p>like gdb's debugger protocol</p>\n</blockquote>\n<p>Debugger Protocol doesn't go into process memory.</p>",
        "id": 274062408,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354119
    },
    {
        "content": "<p>being able to access all the programs' internals and run arbitrary code is the whole point of a debugger...a CVE for that would be silly</p>",
        "id": 274062470,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354166
    },
    {
        "content": "<p>But this isn't happening inside the context of <em>the</em> process.</p>",
        "id": 274062486,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354191
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274062470\">said</a>:</p>\n<blockquote>\n<p>being able to access all the programs' internals and run arbitrary code is the whole point of a debugger...a CVE for that would be silly</p>\n</blockquote>\n<p>Meanwhile, the compiler is assuming nothing is looking at the internals or changing the code being run at all.</p>",
        "id": 274062522,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646354242
    },
    {
        "content": "<p>Can gdb debug itself?</p>",
        "id": 274062523,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646354244
    },
    {
        "content": "<p>well...in embedded, there may not be a way to do out-of-process debugging</p>",
        "id": 274062525,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646354244
    },
    {
        "content": "<p>well, as far as I am concerned, a debugger that isn't considering the merits of twiddling machine code directly is not cutting it as far as debugging goes. I don't think it should be UB to try to serialize or deserialize a pointer, though, oddly enough.</p>",
        "id": 274062527,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354247
    },
    {
        "content": "<p>And I don't think it necessarily needs to have anything to do with usize</p>",
        "id": 274062545,
        "sender_full_name": "Jubilee",
        "timestamp": 1646354277
    },
    {
        "content": "<p>I wonder if the solution is using some moral equivalent of <em>conditionally-support</em>, where by default this doesn't happen, and it's the implementation's (and users' thereof) problem to sort out if they do target a platform that this doesn't hold.</p>",
        "id": 274063739,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646355201
    },
    {
        "content": "<p>I also have used <code>size_of::&lt;usize&gt;() * 3</code> or something as an offset past a struct containing stuff like mixed <code>usize</code> and <code>*mut T</code>. I couldn't find it in published code, but I'm certain I've done it, rather than spell out <code>size_of::&lt;usize&gt;() * 2 + size_of::&lt;*mut T&gt;()</code> or similar, to offset past len/cap/ptr or something. Given that its guaranteed, I assumed it would be fine.</p>",
        "id": 274063813,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646355243
    },
    {
        "content": "<p>that's the kind of code that seems liable to break in a subtle and unfortunate way.</p>",
        "id": 274063827,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646355253
    },
    {
        "content": "<blockquote>\n<p>I wonder if the solution is using some moral equivalent of <em>conditionally-support</em>...</p>\n</blockquote>\n<p>that seems very likely to make a large amount of Rust code unusable on those platforms, like everyone assuming everything is little-endian, but worse (probably more UB)</p>",
        "id": 274063987,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646355379
    },
    {
        "content": "<p>Given the rarity and how niche they are, I don't think that's a huge issue.</p>",
        "id": 274064069,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646355447
    },
    {
        "content": "<p>Core language types and core language semantics is a bad place for \"conditionally support\" to be a phrase.</p>",
        "id": 274064187,
        "sender_full_name": "Jubilee",
        "timestamp": 1646355538
    },
    {
        "content": "<p>Although <code>core</code> itself would need to be mindful of this.</p>",
        "id": 274064517,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646355636
    },
    {
        "content": "<p>I do not necessarily mean in the libcore sense.</p>",
        "id": 274064539,
        "sender_full_name": "Jubilee",
        "timestamp": 1646355664
    },
    {
        "content": "<blockquote>\n<p>I wonder if the solution is using some moral equivalent of conditionally-support, where by default this doesn't happen, and it's the implementation's (and users' thereof) problem to sort out if they do target a platform that this doesn't hold.</p>\n</blockquote>\n<p>It will likely already be this way for those platforms for a lot of software (with rusts help or not), so to some extent I suspect this will happen anyway. We also sort of already have targets like these, in so far as people frequently hardcode lists of targets in <a href=\"http://build.rs\">build.rs</a>, ignoring the existence of target json files (admittedly unstable, although this may add to my point in a sense). I think this is something we want to avoid/reduce though, and it would be a bad precedent to start explicitly making decisions that way.</p>\n<p>That said, I also don't really want us to go back on our usize promises, since I don't like the pattern of \"well, only unsafe code depends on this so we can change it\". Which it feels like we do a lot, tbh.</p>\n<p>I do get that unsafe code can depend on literally any implementation detail of something -- stable and intentional or not -- but I don't think that means the things we make promises about should be considered any less binding than if it were a breaking change in any other API... honestly, I feel like it's <em>worse</em> -- in many cases the outcome for breaking <code>unsafe</code> guarantees is UB, rather than the compile error we'd get for most of the API breakage we try so hard to avoid (and if I were picking, I'd rather the compile error).</p>",
        "id": 274065066,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646356177
    },
    {
        "content": "<blockquote>\n<p>We also sort of already have targets like these, in so far as people frequently hardcode lists of targets in <a href=\"http://build.rs\">build.rs</a>, ignoring the existence of target json files (admittedly unstable, although this may add to my point in a sense).</p>\n</blockquote>\n<p>Or implementations that just have their own targets.</p>",
        "id": 274065254,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356322
    },
    {
        "content": "<p>I do get that its not always that cut and dry (in some cases there's no reasonable way to support the things we told unsafe it was okay to do, I suppose), but... part of my feeling is: yeah, it is indeed a consequence of making a stability guarantee that there are some changes you may want to make in the future, which you don't get to make.</p>",
        "id": 274065309,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646356342
    },
    {
        "content": "<p>I said it before and I will say it again:<br>\nChoosing the status quo is choosing an incoherent wasteland of UB which makes it harder, not easier, to write unsafe Rust.</p>",
        "id": 274065356,
        "sender_full_name": "Jubilee",
        "timestamp": 1646356393
    },
    {
        "content": "<p>And that is why I scrambled last month to fix asm.<br>\nThe issue here is that we're caught between a rock and a hard place.</p>\n<p>We either pick the thing that's <em>de jur</em> breaking or the thing that's <em>de facto</em> breaking.</p>",
        "id": 274065384,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356427
    },
    {
        "content": "<p>Or we make impossible legitimate, albeit niche, uses for rust.</p>",
        "id": 274065445,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356458
    },
    {
        "content": "<p>Well, actually, we don't actually get to pick.</p>",
        "id": 274065453,
        "sender_full_name": "Jubilee",
        "timestamp": 1646356467
    },
    {
        "content": "<p>People will take the Rust toolchain and LLVM and they will modify it until it compiles for their target and then complain to us when our language doesn't allow a coherent story for doing so.</p>",
        "id": 274065481,
        "sender_full_name": "Jubilee",
        "timestamp": 1646356503
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274065481\">said</a>:</p>\n<blockquote>\n<p>People will take the Rust toolchain and LLVM and they will modify it until it compiles for their target and then complain to us when our language doesn't allow a coherent story for doing so.</p>\n</blockquote>\n<p>Well, the choice I presented is for how to make this not a thing, at least in still-mostly-normal-target land.</p>",
        "id": 274065518,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356559
    },
    {
        "content": "<p>(If someone's trying to compile rust to  the PDP-11, they'd be 100% SOL)</p>",
        "id": 274065582,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356588
    },
    {
        "content": "<p>Sometimes we have a good answer for why we can tell them to, ah, accept they have done this to themselves, but other times we don't, and the answer is because a series of mistakes were made and every time someone tried to fix this everyone said \"buuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuut if we actually pick something that has a coherent result, then we break something...?????\"</p>",
        "id": 274065605,
        "sender_full_name": "Jubilee",
        "timestamp": 1646356614
    },
    {
        "content": "<p>If rust accepts <code>usize</code> as not simulateneously <code>size_t</code> and <code>uintptr_t</code>, then we either break the technically incorrect assumptions of a lot of code (including the interface of the standard library), or we break the actual guaranteed behaviour prescribed by the RFC.</p>",
        "id": 274065715,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356718
    },
    {
        "content": "<p>This is actually <a href=\"https://github.com/rust-lang/lang-team/issues/125\">lang-team#125</a>.</p>",
        "id": 274065780,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356801
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274065445\">said</a>:</p>\n<blockquote>\n<p>Or we make impossible legitimate, albeit niche, uses for rust.</p>\n</blockquote>\n<p>In various ways the decision to not support these was explicit. In the past I saw a modest amount of writing about the decision not to support targets without 8bit bytes -- yes, this does limit the situations where you can use rust, but it simplifies programming for everybody else enough to justify it.</p>\n<p>If it were just w65, I would be more inclined to lump it in the same category (...especially given that it's a custom ABI), but CHERI does seem like it may become a platform that is hard to ignore.</p>",
        "id": 274065822,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646356810
    },
    {
        "content": "<blockquote>\n<p>This is actually <a href=\"https://github.com/rust-lang/rust-lang/issues/125\">rust-lang#125</a>.</p>\n</blockquote>\n<p>http 404</p>",
        "id": 274065864,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646356882
    },
    {
        "content": "<p>I don't think it was an explicit decision to not support size_t!=uintptr_t. RFC 0544 actually explicitly says that usize is not the same as size_t.</p>",
        "id": 274065938,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646356939
    },
    {
        "content": "<blockquote>\n<p>especially given that it's a custom ABI</p>\n</blockquote>\n<p>To be fair, it's the only ABI for w65 that I've seen exist in any meaningful capacity. Any others probably existed in the 90s and ceased existing also in the 90s.</p>",
        "id": 274065993,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646357009
    },
    {
        "content": "<p>Right, I didn't mean to imply the platform couldn't be supported, just that rust won't be quite as efficient on them.</p>",
        "id": 274065994,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646357010
    },
    {
        "content": "<p>Arm is going to be designing a new extension for Arm hardware based on CHERI, after they are done with Morello.</p>",
        "id": 274066691,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357450
    },
    {
        "content": "<p>So yes, CHERI is going to become a lot harder to ignore.</p>",
        "id": 274066720,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357495
    },
    {
        "content": "<p>Yeah, that seems to follow given the direction many of their extensions have been going recently.</p>",
        "id": 274066727,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646357506
    },
    {
        "content": "<p>(MTE, TBI, ptrauth, etc)</p>",
        "id": 274066791,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646357551
    },
    {
        "content": "<p>Yes.</p>",
        "id": 274066797,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357556
    },
    {
        "content": "<p>And this has been an open request for Rust since, frankly, <del>2017</del> 2019.</p>",
        "id": 274066810,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357571
    },
    {
        "content": "<p>The problem with the declaration is that the assumptions under which the promise was made do not actually hold.</p>",
        "id": 274066857,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357624
    },
    {
        "content": "<p>I suppose, but it's not like CHERI can't be supported, just that it won't be as efficient.</p>",
        "id": 274066918,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646357654
    },
    {
        "content": "<p>Not really, it generates frankly UB because the datapath is still 64 bits.</p>",
        "id": 274066936,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357681
    },
    {
        "content": "<p>Well, it breaks the code that assumes that <code>usize</code> is <code>size_t</code>.</p>",
        "id": 274066938,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646357681
    },
    {
        "content": "<p>(Particularily FFI code)</p>",
        "id": 274066970,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646357719
    },
    {
        "content": "<p>It is not like CHERI simply has \"128 bit pointers\".</p>",
        "id": 274066974,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357721
    },
    {
        "content": "<p>It is not RV128.</p>",
        "id": 274066977,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357724
    },
    {
        "content": "<p>It actually has the memory address and the rest of the pointer as distinct concepts.</p>",
        "id": 274066992,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357739
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274066938\">said</a>:</p>\n<blockquote>\n<p>Well, it breaks the code that assumes that <code>usize</code> is <code>size_t</code>.</p>\n</blockquote>\n<p>There's a lot of rust code that assumes weird/wrong things about size_t already. Also, most of the code where that matters is calling into  C, and far more C code has issues here than Rust. (Even rather portable C codebases have trouble with CHERI)</p>",
        "id": 274067078,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646357801
    },
    {
        "content": "<p>So that does make manipulations that assume usize is the memory address... and there are many <strong>in std</strong>, some of them safe code... do undefined things if they try to use a u128 to interact with a 64-bit memory address.</p>",
        "id": 274067126,
        "sender_full_name": "Jubilee",
        "timestamp": 1646357849
    },
    {
        "content": "<p>Well, definitely if the platform has UB for safe code thats a huge problem. But the cases I'm most concerned about here is using size_of::&lt;usize&gt;() (or align_of::&lt;usize&gt;()) as a stand-in for pointer size/alignment in calculations, which I think wouldn't have a problem with what you describe.</p>",
        "id": 274067255,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646357956
    },
    {
        "content": "<p>Since those cases are the ones I don't really see a possible way to lint</p>",
        "id": 274067268,
        "sender_full_name": "Thom Chiovoloni",
        "timestamp": 1646357976
    },
    {
        "content": "<blockquote>\n<p>rustc tries to index into LLVM intrinsics such as memcpy with 128-bit integers. This isn't defined in the backend, and arguably shouldn't be defined.</p>\n</blockquote>\n<p>—Nicholas Wei Sheng Sim, author of \"Strengthening memory safety in Rust: exploring<br>\nCHERI capabilities for a safe language\"</p>",
        "id": 274067537,
        "sender_full_name": "Jubilee",
        "timestamp": 1646358139
    },
    {
        "content": "<p>To quote a Rust programmer who has nothing to do with any of this nonsense, but who does write unsafe code from time to time:</p>\n<blockquote>\n<p>I'm happy to write different code<br>\nI'm not happy to spend years living in a land of uncertainty where a shadowy cabal of undefined behavior knowers silently judge me for not writing the code they approve of but aren't documenting (because it's hard)</p>\n</blockquote>",
        "id": 274067672,
        "sender_full_name": "Jubilee",
        "timestamp": 1646358248
    },
    {
        "content": "<p>Or worse, silently judge them for not writing the code they approve of but that isn't supported in current / stable rust</p>",
        "id": 274067793,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646358343
    },
    {
        "content": "<p>So our options are:</p>\n<ul>\n<li>Go back and fix our mistake</li>\n<li>Demand LLVM support us indexing a 64-bit address space with 128-bit integers</li>\n<li>Somehow rework our entire backend interface to make it so we somehow magically don't break this</li>\n<li>Try to ignore CHERI, which has gotten harder every year and will continue growing harder</li>\n</ul>",
        "id": 274067876,
        "sender_full_name": "Jubilee",
        "timestamp": 1646358399
    },
    {
        "content": "<p>I believe it is our prerogative to say \"eh, whatever\" to non-flat address spaces.</p>",
        "id": 274067933,
        "sender_full_name": "Jubilee",
        "timestamp": 1646358467
    },
    {
        "content": "<p>But all the statements that <code>usize == uintptr_t</code> were premised on it also <strong>addressing the entire address space</strong>.</p>",
        "id": 274068029,
        "sender_full_name": "Jubilee",
        "timestamp": 1646358557
    },
    {
        "content": "<p>I don't think we should have <code>uintptr_t</code> at all. If we're thinking about CHERI, it doesn't make sense to do arithmetic on capabilities. Can someone give an example that requires specifically an <em>arithmetic type</em> which is <em>the size of a pointer</em>?</p>",
        "id": 274068232,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646358756
    },
    {
        "content": "<p>The CHERI C impl makes their uintptr_t a union of a pointer and integer for programmer convenience. I do not pretend there is any better reason. <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 274068337,
        "sender_full_name": "Jubilee",
        "timestamp": 1646358855
    },
    {
        "content": "<p>I'm imagining some C ABI that decides to use 128 bit integers to store rust slice pointers and just... no, you're doing it wrong</p>",
        "id": 274068341,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646358859
    },
    {
        "content": "<p>They have two reasons actually but I remember reading the first one and the second one (which explicitly states it's for convenience) and thinking \"ah, so, programmer convenience both times.\"</p>",
        "id": 274068440,
        "sender_full_name": "Jubilee",
        "timestamp": 1646358962
    },
    {
        "content": "<p>but those are C reasons. The only reason they would affect rust is if we want ABI compatibility in FFI, and there are other ways to accomodate that</p>",
        "id": 274068500,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646359023
    },
    {
        "content": "<p>yeah, NWWS said as much. We don't have to.</p>",
        "id": 274068789,
        "sender_full_name": "Jubilee",
        "timestamp": 1646359226
    },
    {
        "content": "<p>and we really do have to rework everything to make this happen, it's not really just a pessimization, because:</p>\n<blockquote>\n<p>The address space is 64 bits. ptr as int gives an LLVM i64, which can't be cast/isn't comparable to an i128; again there is no good reason to manipulate 128-bit integers here. Likewise when calling inttoptr, which is a valid instruction even if the result can't be dereferenced [5].</p>\n</blockquote>",
        "id": 274069052,
        "sender_full_name": "Jubilee",
        "timestamp": 1646359296
    },
    {
        "content": "<p>what are you quoting?</p>",
        "id": 274069111,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646359332
    },
    {
        "content": "<p><a href=\"https://github.com/rust-lang/rust/issues/65473\">https://github.com/rust-lang/rust/issues/65473</a></p>",
        "id": 274069117,
        "sender_full_name": "Jubilee",
        "timestamp": 1646359339
    },
    {
        "content": "<p>I have also read his paper and a fair number of the other CHERI papers.</p>",
        "id": 274069146,
        "sender_full_name": "Jubilee",
        "timestamp": 1646359371
    },
    {
        "content": "<p>but as far as pessimizations go, 3.5 times as many instructions to do a bounds check, in <strong>Rust</strong>, is pretty bad.</p>",
        "id": 274069394,
        "sender_full_name": "Jubilee",
        "timestamp": 1646359585
    },
    {
        "content": "<p>Rust code does a nontrivial number of bounds checks but is fast because branch predictors are pretty damn good in the 2020s.</p>",
        "id": 274069483,
        "sender_full_name": "Jubilee",
        "timestamp": 1646359681
    },
    {
        "content": "<p>As a first attempt at a solution or at least progress on this issue, what about introducing type aliases like <code>uintptr_t</code> and friends to std, so that they can be used as vocabulary types? This will at least let people be more explicit when they want to be, and maybe that massive automatic code refactor will be more effective if they exist</p>",
        "id": 274069715,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646359866
    },
    {
        "content": "<p>This would also be painful on w65, where a register by register transfer (3 cycles) followed by a usually-constant (6 cycles) or else memory (7 cycles) comparison is being replaced by two memory-memory or memory constant comparisons, which requires a register load (6 cycles), comparison (6 or 7 cycles), branch (2 or 3 cycles), register load (6 cycles), comparison (6 or 7 cycles). <br>\nSo, 9-10 cycles vs. 22-29 cycles.</p>",
        "id": 274069866,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646360027
    },
    {
        "content": "<p>eh, 64kb should be enough for anyone</p>",
        "id": 274069933,
        "sender_full_name": "Jubilee",
        "timestamp": 1646360080
    },
    {
        "content": "<p>13 cycles is the difference between missing an hblank and not. 19 cycles is enough to take a serious bite out of the VBLANK time.</p>",
        "id": 274069959,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646360121
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274069933\">said</a>:</p>\n<blockquote>\n<p>eh, 64kb should be enough for anyone</p>\n</blockquote>\n<p>Heh.</p>",
        "id": 274069970,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646360139
    },
    {
        "content": "<p>Object size or AS Size.</p>",
        "id": 274069988,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646360159
    },
    {
        "content": "<p>everything's an object &lt;/java&gt;</p>",
        "id": 274070272,
        "sender_full_name": "Jubilee",
        "timestamp": 1646360426
    },
    {
        "content": "<p>Or C++.</p>",
        "id": 274070314,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646360477
    },
    {
        "content": "<p>Even still, removing the second half of the comparison, there's still an extra 6 cycle load that didn't need  to exist for <code>usize</code>=6 <em>per bounds</em> check.</p>",
        "id": 274070441,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646360599
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"271719\">Mario Carneiro</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274069715\">said</a>:</p>\n<blockquote>\n<p>As a first attempt at a solution or at least progress on this issue, what about introducing type aliases like <code>uintptr_t</code> and friends to std, so that they can be used as vocabulary types? This will at least let people be more explicit when they want to be, and maybe that massive automatic code refactor will be more effective if they exist</p>\n</blockquote>\n<p>we do have <code>core::ffi</code> now</p>",
        "id": 274070876,
        "sender_full_name": "Jubilee",
        "timestamp": 1646360951
    },
    {
        "content": "<p>So, one of the objections to having those types (in either std or core) is precisely that if we have them that gives the implication that you're supposed to use them <em>instead</em> of <code>usize</code>.</p>",
        "id": 274071227,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646361102
    },
    {
        "content": "<p>I don't think we're going to be able to successfully stabilize those without consensus on at least the question of whether <code>usize</code> is <code>size_t</code>.</p>",
        "id": 274071284,
        "sender_full_name": "Josh Triplett",
        "timestamp": 1646361132
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274071227\">said</a>:</p>\n<blockquote>\n<p>So, one of the objections to having those types (in either std or core) is precisely that if we have them that gives the implication that you're supposed to use them <em>instead</em> of <code>usize</code>.</p>\n</blockquote>\n<p>Yes, I'd argue that's the intention.</p>",
        "id": 274071309,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646361167
    },
    {
        "content": "<p>I would agree this is squarely inside the <a href=\"https://github.com/rust-lang/lang-team/issues/125\">lang-team#125</a> proposal, though.</p>",
        "id": 274071380,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646361227
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"239881\">Josh Triplett</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274071284\">said</a>:</p>\n<blockquote>\n<p>I don't think we're going to be able to successfully stabilize those without consensus on at least the question of whether <code>usize</code> is <code>size_t</code>.</p>\n</blockquote>\n<p>I think it is not in question that <code>usize</code> is <code>size_t</code> on all currently supported platforms. So presumably we should start thinking about ways to incorporate compile time checks like <code>cfg(usize_is_size_t)</code> that are true today on all platforms but might become false on future platforms</p>",
        "id": 274072074,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646361774
    },
    {
        "content": "<p>Adding such mechanisms is not itself a breaking change</p>",
        "id": 274072112,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646361817
    },
    {
        "content": "<p>and we can't properly address the breaking part of the change until those mechanisms have had some time to stew in the ecosystem</p>",
        "id": 274072178,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646361847
    },
    {
        "content": "<p>This might be a good idea.</p>",
        "id": 274072358,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646362031
    },
    {
        "content": "<p>Although it leads to the bikeshedding of \"Is <code>usize</code> <code>size_t</code> or <code>uintptr_t</code>\" all over again.</p>",
        "id": 274072380,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646362063
    },
    {
        "content": "<p><code>cfg(usize_is_size_t_and_also_uintptr_t)</code></p>",
        "id": 274072659,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646362310
    },
    {
        "content": "<p><code>..._and_dont_forget_ptraddr_t_and_ptrdiff_t)</code></p>",
        "id": 274072732,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646362364
    },
    {
        "content": "<p>lmao</p>",
        "id": 274072756,
        "sender_full_name": "Jubilee",
        "timestamp": 1646362391
    },
    {
        "content": "<p>...</p>",
        "id": 274072757,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646362392
    },
    {
        "content": "<p><code>cfg(ptr_width_is_size_width)</code></p>",
        "id": 274072779,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646362426
    },
    {
        "content": "<p>Along with <code>cfg(target_size_width = \"*\")</code></p>",
        "id": 274072832,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646362443
    },
    {
        "content": "<p><code>if c_size_t::BITS == usize::BITS &amp;&amp; c_uintptr_t::BITS == usize::BITS {</code></p>",
        "id": 274072871,
        "sender_full_name": "Jubilee",
        "timestamp": 1646362482
    },
    {
        "content": "<p>I think you will need cfgs for some of this since you will get type errors if a type synonym isn't one anymore</p>",
        "id": 274072907,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646362529
    },
    {
        "content": "<p>that's comparing u32s</p>",
        "id": 274072999,
        "sender_full_name": "Jubilee",
        "timestamp": 1646362574
    },
    {
        "content": "<p>Yes that check itself is fine (and can even be done in a const fn) but it might be guarding some <code>foo(*const T as usize: uintptr_t)</code> stuff that would not compile even if it is on a compile time skipped branch</p>",
        "id": 274073095,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646362666
    },
    {
        "content": "<p>ohhh</p>",
        "id": 274073180,
        "sender_full_name": "Jubilee",
        "timestamp": 1646362713
    },
    {
        "content": "<p>I have managed to make Rust accept some surprising things gated by an <code>if</code>, but fair enough.</p>",
        "id": 274073231,
        "sender_full_name": "Jubilee",
        "timestamp": 1646362761
    },
    {
        "content": "<p>Yeah, reading the actual RFCs, the justification for \"usize == uintptr_t\" is continuously predicated on \"Rust assumes a flat address space.\"</p>",
        "id": 274076984,
        "sender_full_name": "Jubilee",
        "timestamp": 1646366132
    },
    {
        "content": "<p>So yes, we can resolve to say \"meh\" to segmented memory if we want, but we don't actually have the same argument against CHERI pointers.</p>",
        "id": 274077050,
        "sender_full_name": "Jubilee",
        "timestamp": 1646366204
    },
    {
        "content": "<p>...absolutely magnificent.</p>",
        "id": 274080611,
        "sender_full_name": "Jubilee",
        "timestamp": 1646369881
    },
    {
        "content": "<p>On CHERI, these are both true:</p>\n<div class=\"codehilite\" data-code-language=\"C\"><pre><span></span><code><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"mi\">16</span><span class=\"w\"></span>\n<span class=\"n\">UINTPTR_MAX</span><span class=\"w\"> </span><span class=\"o\">==</span><span class=\"w\"> </span><span class=\"n\">UINT64_MAX</span><span class=\"w\"></span>\n</code></pre></div>\n<p>beautiful</p>",
        "id": 274080679,
        "sender_full_name": "Jubilee",
        "timestamp": 1646369985
    },
    {
        "content": "<p>FWIW I fully agree with treating CHERI as \"its a 64bit address and then some other stuff so the entire pointer has size 128bits\", and interpreting ptr &lt;-&gt; usize casts as extracting the address from a pointer and synthesizing a pointer from an address. I said as much already back in <a href=\"https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369/52?u=ralfjung\">https://internals.rust-lang.org/t/pre-rfc-usize-is-not-size-t/15369/52?u=ralfjung</a>. :)<br>\nand indeed the API <code>ptr.map(|addr| addr | BITFLAG)</code> that already came up in the discussion around provenance would neatly handle the case of preserving CHERI permissions while manipulating the address.</p>",
        "id": 274254493,
        "sender_full_name": "RalfJ",
        "timestamp": 1646500520
    },
    {
        "content": "<p>(that is not too surprising because one way to view CHERI is as a machine where something like Rust's Abstract Machine provenance <em>exists even on the physical machine</em>)</p>",
        "id": 274254559,
        "sender_full_name": "RalfJ",
        "timestamp": 1646500584
    },
    {
        "content": "<p>One thing I'd note.<br>\nIf we do support this, I'd strongly recommend that ptraddr_t be exposition only (and not actually defined).<br>\nConsider the 8086 example: ptraddr_t is a u20, containing a 20-bit linear address, simple.<br>\nBut what if it's i386 16-bit protected mode (cr0.PE=1, css.Sz=0), which leaves linear addresses up to 32-bit, even after segmentation. Or Even i286 protected mode (msw.PE=1), which is 24-bit. Additionally, in these modes, it's generally impossible for unprivileged code to compute the segment base (it requires finding the global descriptor table, which may not exist in the available address space or segment space)</p>\n<p>In all cases, uintptr_t would still be 32-bit (seg,offset), and the difference is nearly transparent, and the codegen is largely the same: load the segment into ds, es, or (where available) gs, load the offset into bx, execute the instruction with the appropriate segment override prefix (if needed). However, computing the linear address in these modes is different (and, as mentioned, potentially impossible).</p>",
        "id": 274889516,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646943385
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I'm not very familiar with 8086 architecture, but I don't understand how it could be impossible to convert a pointer to an integer in principle (although I agree on the main point that we don't need this type to exist). Unless the memory is protected in some way, wouldn't you always be able to take a pointer, write it to memory and then read the 32-bits just written as an integer value? If some part of the address is hidden from user code, then presumably it is also hidden from writes to memory so the pointer type would end up just being the linear address part.</p>",
        "id": 274912023,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646955746
    },
    {
        "content": "<p>It's fine to convert to uintptr_t,  that's just segment&lt;&lt;16|offset.<br>\nThe issue is ptraddr_t, which would be the linear address (as noted above).</p>",
        "id": 274915742,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646958220
    },
    {
        "content": "<p>It's either <code>segment_base&lt;&lt;4+offset</code> or <code>segment_selector.base+offset</code>, and the latter may be impossible to get.</p>",
        "id": 274915834,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646958268
    },
    {
        "content": "<p><code>segment_base&lt;&lt;4+offset</code> -- don't forget the optional <code>% 0x100000</code>, A20 shenanigans!</p>",
        "id": 274916032,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646958384
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"229517\">Jacob Lifshay</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/274916032\">said</a>:</p>\n<blockquote>\n<p><code>segment_base&lt;&lt;4+offset</code> -- don't forget the optional <code>% 0x100000</code>, A20 shenanigans!</p>\n</blockquote>\n<p>Or on an actual 8086/80186.</p>",
        "id": 274916065,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646958414
    },
    {
        "content": "<p>so...on 80286+ in real mode, you get addresses from <code>0x0</code> to <code>0x10FFEF</code></p>",
        "id": 274916335,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646958585
    },
    {
        "content": "<p>so just <code>u20</code> isn't sufficient</p>",
        "id": 274916397,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646958605
    },
    {
        "content": "<p>Yep, if the A20 gate is enabled (or DNE).</p>",
        "id": 274916420,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646958623
    },
    {
        "content": "<p>And that's even more impossible to figure out.</p>",
        "id": 274916645,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646958776
    },
    {
        "content": "<p>it's like if <code>ptraddr_t</code> were Rust's <code>char</code>, but worse and more obscure</p>",
        "id": 274917049,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646959014
    },
    {
        "content": "<p>Welcome to old x86.<br>\nI don't know why I have a fixation on supporting it, but I mostly already do, so...</p>",
        "id": 274917211,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646959101
    },
    {
        "content": "<p>I believe we call that \"sunk cost fallacy\"</p>",
        "id": 274917255,
        "sender_full_name": "Mario Carneiro",
        "timestamp": 1646959136
    },
    {
        "content": "<p>Not even.</p>",
        "id": 274917272,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646959146
    },
    {
        "content": "<p>The \"mostly already do\" is 85% coincidence (and 15% I was bored and it's right there, so why not).</p>",
        "id": 274917289,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646959162
    },
    {
        "content": "<p>(I also like technology that's older than I am, so...)</p>",
        "id": 274917379,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646959205
    },
    {
        "content": "<p>maybe because a huge number of people have hardware that can natively run it (basically all x86 computers), and because both gcc and llvm don't really support it?</p>",
        "id": 274917462,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1646959288
    },
    {
        "content": "<p>Maybe. Beating llvm and gcc in something in version 1.0 of lccc would be very nice.</p>",
        "id": 274917574,
        "sender_full_name": "Connor Horman",
        "timestamp": 1646959395
    },
    {
        "content": "<p>I am reminded of the Data General Eclipse <a href=\"https://www.youtube.com/watch?v=ok1pTr2i5BE\">https://www.youtube.com/watch?v=ok1pTr2i5BE</a><br>\nfrom <a href=\"https://begriffs.com/posts/2018-11-15-c-portability.html\">https://begriffs.com/posts/2018-11-15-c-portability.html</a></p>\n<div class=\"youtube-video message_inline_image\"><a data-id=\"ok1pTr2i5BE\" href=\"https://www.youtube.com/watch?v=ok1pTr2i5BE\"><img src=\"https://uploads.zulipusercontent.net/76e373b3a76252f4c3c18b67594d5c1645ce9643/68747470733a2f2f692e7974696d672e636f6d2f76692f6f6b3170547232693542452f64656661756c742e6a7067\"></a></div><blockquote>\n<p>This machine uses a different numbering scheme for character- and integer-pointers. The same location in memory must be referred to by different addresses depending on the pointer type. A cast between char* and int* actually changes the address inside the pointer.</p>\n</blockquote>",
        "id": 274919929,
        "sender_full_name": "Jubilee",
        "timestamp": 1646961300
    },
    {
        "content": "<p>Anyways I agree that if we mention <code>ptraddr_t</code> we don't invest deeply into a rigid definition of it, it's mostly indicating the concept is Out There.</p>\n<p>Also, I dug around and found out that RV128's C data model will have both \"far\" pointers and \"near\" pointers, indicated by an <code>[[attribute]]</code>.</p>",
        "id": 275126463,
        "sender_full_name": "Jubilee",
        "timestamp": 1647135093
    },
    {
        "content": "<p>The way I'd define it is</p>\n<blockquote>\n<p><code>ptraddr_t</code>is an <em>exposition-only</em> integer type that can uniquely represent an address in memory, but might not exactly represent the entire value of a pointer.</p>\n</blockquote>",
        "id": 275126586,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647135308
    },
    {
        "content": "<p>that doesn't hold up to actual inspection unfortunately, the same way trying to have our cake and eat it too for \"<code>usize</code> is not <code>size_t</code>\" didn't work out. it would be fairly minor since it's just non-normative RFC verbiage but</p>",
        "id": 275128870,
        "sender_full_name": "Jubilee",
        "timestamp": 1647139287
    },
    {
        "content": "<p>I've been under the impression that the CHERI folks implementing intptr_t like that is less \"ah yes this is good and desirable\" and more \"god damnit there's so much bad code we need to get to work, ok fine we'll do this hack\".</p>\n<p>In that vein if we replaced intptr casts with cheri_address_set, it's unclear if we would at all need an intptr_t equivalent. usize==size_t/ptrdiff_t would be adequate for any application I can imagine (I can only really imagine Reasonable tagged pointer shenanigans and Dubious serialization schemes)</p>",
        "id": 275942957,
        "sender_full_name": "Gankra",
        "timestamp": 1647744154
    },
    {
        "content": "<p>I have updated my article to more clearly discuss this: <a href=\"https://gankra.github.io/blah/fix-rust-pointers/#redefining-usize\">https://gankra.github.io/blah/fix-rust-pointers/#redefining-usize</a></p>",
        "id": 275969685,
        "sender_full_name": "Gankra",
        "timestamp": 1647786265
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"137587\">Gankra</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275969685\">said</a>:</p>\n<blockquote>\n<p>I have updated my article to more clearly discuss this: <a href=\"https://gankra.github.io/blah/fix-rust-pointers/#redefining-usize\">https://gankra.github.io/blah/fix-rust-pointers/#redefining-usize</a></p>\n</blockquote>\n<p>In that section you state that <code>usize</code> can \"represent all addresses in all address spaces\". If I'm understanding correctly, that would be <code>ptraddr_t</code>? <br>\nAs mentioned above, on non-flat 8086, <code>ptraddr_t</code> would store a linear address which is not portable (and, as mentioned, may not be possible in all cases) to compute between 16-bit address modes of x86, so I'd prefer rust not expose a mechanism to obtain that.</p>",
        "id": 275972187,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647789847
    },
    {
        "content": "<p>Anything in reference to segmenting is definitely a big handwave, but I think it's fair to say there can still be some segmented architectures where we should be willing to say \"sorry no that's too cursed, do better\"</p>",
        "id": 275972230,
        "sender_full_name": "Gankra",
        "timestamp": 1647789958
    },
    {
        "content": "<p>Never thought I'd see the day when x86 is the architecture being called \"too cursed\" <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>.</p>",
        "id": 275972301,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647790029
    },
    {
        "content": "<p>from what i've heard of non-flat 8086 (the fact that segments actually <em>overlap</em> <span aria-label=\"scream cat\" class=\"emoji emoji-1f640\" role=\"img\" title=\"scream cat\">:scream_cat:</span>) it legit sounds kinda cursed lol</p>",
        "id": 275972308,
        "sender_full_name": "Gankra",
        "timestamp": 1647790045
    },
    {
        "content": "<p>Still, I wonder if this wouldn't be a more general problem.<br>\nReal/v8086 mode x86 is easy. Simply do u20/u21 arithmetic with segment&lt;&lt;4 and offset.<br>\n16-bit protected mode on both the 286 and 386+ are <em>fun</em> though.</p>",
        "id": 275972375,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647790126
    },
    {
        "content": "<p>(And in all other respects, 16-bit protected mode is basically transparent to real mode)</p>",
        "id": 275972390,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647790161
    },
    {
        "content": "<p>but like I said, this is outside my domain of expertese and I'm trying to just use the \"well we need to fuck with this anyway for CHERI\" situation as a chance to maybe open the door to segmentation getting better support. someone more in-the-know needs to figure out if that's possible.</p>",
        "id": 275972469,
        "sender_full_name": "Gankra",
        "timestamp": 1647790268
    },
    {
        "content": "<p>interesting context/feedback from actual CHERI person: <a href=\"https://lobste.rs/s/mptezc/rust_s_unsafe_pointer_types_need_overhaul#c_qbamrf\">https://lobste.rs/s/mptezc/rust_s_unsafe_pointer_types_need_overhaul#c_qbamrf</a></p>",
        "id": 275974672,
        "sender_full_name": "Gankra",
        "timestamp": 1647793340
    },
    {
        "content": "<p>CHERI is fundamentally incompatible with the existing C-based world by spec, and in practice for most anything doing anything seriously low level. Even segmented x86 targets are probably more compatible, and that's starting at \"by accident\" and \"without too much modification\". If rust still wants to claim to be a good replacement for low level code, \"need to support CHERI\" as an excuse for ripping out features is uhhh... a choice.</p>",
        "id": 275975385,
        "sender_full_name": "Talchas",
        "timestamp": 1647794346
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"257758\">Connor Horman</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275972301\">said</a>:</p>\n<blockquote>\n<p>Never thought I'd see the day when x86 is the architecture being called \"too cursed\" <span aria-label=\"rofl\" class=\"emoji emoji-1f923\" role=\"img\" title=\"rofl\">:rofl:</span>.</p>\n</blockquote>\n<p>x86 in real mode is absolutely the most cursed architecture we practically deal with.</p>",
        "id": 275976320,
        "sender_full_name": "Jubilee",
        "timestamp": 1647794941
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275975385\">said</a>:</p>\n<blockquote>\n<p>CHERI is fundamentally incompatible with the existing C-based world by spec, and in practice for most anything doing anything seriously low level. Even segmented x86 targets are probably more compatible, and that's starting at \"by accident\" and \"without too much modification\". If rust still wants to claim to be a good replacement for low level code, \"need to support CHERI\" as an excuse for ripping out features is uhhh... a choice.</p>\n</blockquote>\n<p>Precise compatibility with C, at the end of the day, is not actually a strict goal of Rust.</p>",
        "id": 275976417,
        "sender_full_name": "Jubilee",
        "timestamp": 1647795028
    },
    {
        "content": "<p>And C is incompatible in actual fact with many things, in spite of the advertisements otherwise. When we actually turn the lights on, we find that almost no compiler actually implements \"Standard C\" for all supported architectures, and that doing so in a strict sense often can and does make the compiler incompatible with many architectures.</p>",
        "id": 275976532,
        "sender_full_name": "Jubilee",
        "timestamp": 1647795164
    },
    {
        "content": "<p>Having less \"features\" <em>stricto sensu</em> but having more features you can actually <strong>rely on</strong> because they aren't something pulled directly out of a compiler writer's ass and subject to change upon the next compiler revision is, in fact, an actual selling point. Enormous amounts of embedded software programmers simply do not upgrade compilers because doing so often utterly and completely shatters their entire program's functionality. And all of the \"things C can do\" people are talking about when we discuss these are in fact within that domain.</p>",
        "id": 275976814,
        "sender_full_name": "Jubilee",
        "timestamp": 1647795504
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275976417\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"143798\">Talchas</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275975385\">said</a>:</p>\n<blockquote>\n<p>CHERI is fundamentally incompatible with the existing C-based world by spec, and in practice for most anything doing anything seriously low level. Even segmented x86 targets are probably more compatible, and that's starting at \"by accident\" and \"without too much modification\". If rust still wants to claim to be a good replacement for low level code, \"need to support CHERI\" as an excuse for ripping out features is uhhh... a choice.</p>\n</blockquote>\n<p>Precise compatibility with C, at the end of the day, is not actually a strict goal of Rust.</p>\n</blockquote>\n<p>Right, but rust should be useful for systems programming as it does at least somewhat claim (and people do use it for).</p>",
        "id": 275976826,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647795542
    },
    {
        "content": "<p>Yeah the C standard is in some sense irrelevant insofar as it is more <em>descriptive</em> than <em>prescriptive</em> since there are a billion jacked up compilers in production, most notably msvc</p>",
        "id": 275976952,
        "sender_full_name": "Gankra",
        "timestamp": 1647795643
    },
    {
        "content": "<p>Indeed.<br>\nI reserve my withering criticism simply for the \"but C does this!\" excuse.</p>",
        "id": 275976959,
        "sender_full_name": "Jubilee",
        "timestamp": 1647795661
    },
    {
        "content": "<p>what matters is compatibility with actual platform ABIs, which are expressed in C, but only given actual meaning by <em>the blessed C compiler of that platform</em></p>",
        "id": 275976977,
        "sender_full_name": "Gankra",
        "timestamp": 1647795693
    },
    {
        "content": "<p>\"Show me the money\", in other words. Or, well, actual use cases. Then we can talk.</p>",
        "id": 275976988,
        "sender_full_name": "Jubilee",
        "timestamp": 1647795713
    },
    {
        "content": "<p>My use cases for 8086 is largely the same as for w65, aka mountain climber reasoning.</p>",
        "id": 275977126,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647795857
    },
    {
        "content": "<p>That being said, it would be useful for writing pre-protected mode bootloaders in not pure assembly.</p>",
        "id": 275977143,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647795887
    },
    {
        "content": "<p>out of curiosity does much code <em>actually</em> run in that mode? i would have assumed you spend basically 0 time going \"fuck fuck fuck please by 32-bit\" and are good to go</p>",
        "id": 275977168,
        "sender_full_name": "Gankra",
        "timestamp": 1647795933
    },
    {
        "content": "<p>(assuming we're talking about the bootloader for a modern PC and not an actual 8086)</p>",
        "id": 275977229,
        "sender_full_name": "Gankra",
        "timestamp": 1647795974
    },
    {
        "content": "<p>There is some setup that needs to be done before you an go to 32-bit protected mode.<br>\nLegacy BIOS bootloaders also sometimes will revert to real mode to do disk I/O.</p>",
        "id": 275977302,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647796100
    },
    {
        "content": "<p>Yeah what would that bootloader actually look like?</p>",
        "id": 275977305,
        "sender_full_name": "Jubilee",
        "timestamp": 1647796106
    },
    {
        "content": "<p>At least some of the bootloader code I have actually read has been \"something that can only be expressed in pure assembly anyways\".</p>",
        "id": 275977318,
        "sender_full_name": "Jubilee",
        "timestamp": 1647796153
    },
    {
        "content": "<p>That being said, I don't see a huge amount of code doing this. 8086 is mostly mountain climber reasoning, aka. because it's there.</p>",
        "id": 275977385,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647796208
    },
    {
        "content": "<p>(Even moreso than w65, which could legitimately be used to write SNES homebrew)</p>",
        "id": 275977403,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647796250
    },
    {
        "content": "<p>With <em>that</em> being said, though, I still don't think rust should place unreasonable restrictions on targets, and that if it accepts CHERI and w65 it should reasonably accept <code>-mfar-ptr</code> 8086.</p>",
        "id": 275977562,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647796466
    },
    {
        "content": "<p>(Unless there's a fairly good reason not to)</p>",
        "id": 275977574,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647796484
    },
    {
        "content": "<p>Oh so we probably may have to think, unfortunately, about far pointers and near pointers, into the future as well. Did I mention that?</p>",
        "id": 275977679,
        "sender_full_name": "Jubilee",
        "timestamp": 1647796634
    },
    {
        "content": "<p>RV128's ABI, as it is currently being described, has <code>[[far]] void *</code> and <code>[[near]] void *</code>. The model still uses a flat address space, as I understand it? But they are differently sized because you almost never need to actually use the full address space.</p>",
        "id": 275977763,
        "sender_full_name": "Jubilee",
        "timestamp": 1647796766
    },
    {
        "content": "<p>Nice.</p>",
        "id": 275978470,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647797715
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"281757\">@Jubilee</span> the doc is very unclear but it sounds a lot like they're just describing the same thing that x32 is and that far pointers aren't something you would really use (but they decided to define because they can, or maybe they show up as like types for syscalls or something)</p>",
        "id": 275979473,
        "sender_full_name": "Gankra",
        "timestamp": 1647798978
    },
    {
        "content": "<p><em>nod.</em><br>\nYes, it basically is more like x32 than anything.</p>",
        "id": 275979723,
        "sender_full_name": "Jubilee",
        "timestamp": 1647799265
    },
    {
        "content": "<p>well i kind of specified that backwards: far pointers aren't a thing to use <em>because near pointers are the default and would span your process' memory anyway</em></p>",
        "id": 275979795,
        "sender_full_name": "Gankra",
        "timestamp": 1647799351
    },
    {
        "content": "<p>as in they are not near pointers in like, the 8086 \"completely unsound to handle\" sense</p>",
        "id": 275979810,
        "sender_full_name": "Gankra",
        "timestamp": 1647799382
    },
    {
        "content": "<p>Right.</p>",
        "id": 275982101,
        "sender_full_name": "Jubilee",
        "timestamp": 1647802476
    },
    {
        "content": "<p>well, i'm hoping rust will eventually be able to compile code for <a href=\"https://www.freedos.org/\">https://www.freedos.org/</a></p>",
        "id": 275985858,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647807826
    },
    {
        "content": "<p>...what's <code>size_t</code> on FreeDOS, pray tell</p>",
        "id": 275986320,
        "sender_full_name": "Jubilee",
        "timestamp": 1647808517
    },
    {
        "content": "<p>I assume u16</p>",
        "id": 275987175,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647809605
    },
    {
        "content": "<p>is it UB in C to have objects that straddle address spaces in cases where the segmentation allows that <strong>in theory</strong>?</p>",
        "id": 275989910,
        "sender_full_name": "Jubilee",
        "timestamp": 1647813417
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"257758\">@Connor Horman</span> I could go check the standard but I think asking you is a touch faster.</p>",
        "id": 275989941,
        "sender_full_name": "Jubilee",
        "timestamp": 1647813482
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275989910\">said</a>:</p>\n<blockquote>\n<p>is it UB in C to have objects that straddle address spaces in cases where the segmentation allows that <strong>in theory</strong>?</p>\n</blockquote>\n<p>I don't think it is <em>per se</em> but C compilers get a lot of freedom in where it puts objects, so it could just have that not happen and just assume it to not be possible.</p>",
        "id": 275990196,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647813746
    },
    {
        "content": "<p>ahkay.</p>",
        "id": 275990199,
        "sender_full_name": "Jubilee",
        "timestamp": 1647813761
    },
    {
        "content": "<p>Address spaces aren't even a concept in C.</p>",
        "id": 275990207,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647813780
    },
    {
        "content": "<p>Right, C doesn't ever look directly at a lot of things, just handwave a lot to allow enough freedom to implementers to cope with that stuff... and even then, people often can't encode it without breaking the standard and such (or at least a lot of compiler extensions... sometimes you drive past ISO C, sometimes you drive through it).</p>\n<p>Okay, so, tell me how your compiler intends to handle the entire memory segmentation dealio.</p>",
        "id": 275990297,
        "sender_full_name": "Jubilee",
        "timestamp": 1647813958
    },
    {
        "content": "<p>An object can only be allocated entirely within a segment, and cannot rely on intra-segment wrapping. <br>\nPointers are either near (simply offset) or far (segment:offset), near data pointers resolved using ds, near function pointers using cs, far pointers store the segment or segment selector in the upper word of the dword pointer, with offset in lower word. <br>\nThe model picks the default pointer kind (<code>-mnear-ptr</code>/<code>-mflat</code> vs. <code>-mfar-ptr</code>), and on everything other than flat, <code>_near</code> and <code>_far</code> override the default (in C, idk how this would be represented in rust).</p>",
        "id": 275990423,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814116
    },
    {
        "content": "<p><code>-mflat</code>?</p>",
        "id": 275990443,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814172
    },
    {
        "content": "<p><code>-mflat</code> is ss.base==cs.base==ds.base (or ss==cs==ds in actual real mode). IE. no segmentation (other than for TLS)</p>",
        "id": 275990498,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814227
    },
    {
        "content": "<p>Worth nothing that C of yore is very different from today's C. I don't think people back then had the time to worry about provenance and whatnot when they had to fit everything into kilobytes.</p>",
        "id": 275990508,
        "sender_full_name": "nagisa",
        "timestamp": 1647814259
    },
    {
        "content": "<p>Correct.</p>",
        "id": 275990512,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814269
    },
    {
        "content": "<p>So: How big do you think a <code>*const T</code> should be?</p>",
        "id": 275990568,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814337
    },
    {
        "content": "<p>(I myself only had an opportunity to write some assembly for x86_16, it was an interesting experience) I would say 16 bits. Carrying around segment information alongside pointers would be prohibitively expensive for that sort of architecture.</p>",
        "id": 275990602,
        "sender_full_name": "nagisa",
        "timestamp": 1647814431
    },
    {
        "content": "<p>On <code>-mfar-ptr</code>, 32, being 16:16.</p>",
        "id": 275990641,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814444
    },
    {
        "content": "<p>I could see a <code>target-feature</code> which enables -mfar-ptr equivalent, though, sure.</p>",
        "id": 275990651,
        "sender_full_name": "nagisa",
        "timestamp": 1647814472
    },
    {
        "content": "<p>On <code>-mnear-ptr</code>/<code>-mflat</code> it's 16 (just the offset).</p>",
        "id": 275990653,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814475
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275990651\">said</a>:</p>\n<blockquote>\n<p>I could see a <code>target-feature</code> which enables -mfar-ptr equivalent, though, sure.</p>\n</blockquote>\n<p>It wouldn't be a target-feature. I'd expect it to either be part of the sys component, or a separate (probably <code>-Z</code>) option.</p>",
        "id": 275990671,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814520
    },
    {
        "content": "<p>...actually a target feature might be a good idea.</p>",
        "id": 275990679,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814553
    },
    {
        "content": "<p>(Also technically <code>-mnear-ptr</code> and <code>-mfar-ptr</code> aren't the whole extend, since lccc will allow separate defaults for fn vs. data pointers, <code>-mnear-data-ptr</code>/<code>-mfar-fn-ptr</code>)</p>",
        "id": 275990716,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275990679\">said</a>:</p>\n<blockquote>\n<p>...actually a target feature might be a good idea.</p>\n</blockquote>\n<p>It's not really a binary choice, though.</p>",
        "id": 275990722,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814577
    },
    {
        "content": "<p>Well, it is, but it's not \"enable/disable\" it's pick one of two options.</p>",
        "id": 275990731,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814600
    },
    {
        "content": "<p><code>#[target_feature(enable)]</code></p>",
        "id": 275990732,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814601
    },
    {
        "content": "<p>(Also, it affects ABI, so the entire crate would need to be compiled with the same option)</p>",
        "id": 275990736,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814624
    },
    {
        "content": "<p>nah, you can have divergent ABI internally.</p>",
        "id": 275990744,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814656
    },
    {
        "content": "<p>Well, not if you want to be able to call functions</p>",
        "id": 275990751,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814676
    },
    {
        "content": "<p>you can call functions without function pointers in Rust.</p>",
        "id": 275990795,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814704
    },
    {
        "content": "<p>it'd be problematic if you implicitly lose the information about segment as a result of returning/passing in as an arugment a pointer.</p>",
        "id": 275990797,
        "sender_full_name": "nagisa",
        "timestamp": 1647814716
    },
    {
        "content": "<p>Fair (although xir needs a function pointer for it's <code>call</code> instruction). But function pointers need to be callable.</p>",
        "id": 275990805,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814756
    },
    {
        "content": "<p>Right, of course.<br>\nYou can choose to mix up <code>*const T</code> and <code>*mut T</code> repr based on <code>T</code>, though.</p>",
        "id": 275990816,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814796
    },
    {
        "content": "<p><em>shudders</em></p>",
        "id": 275990858,
        "sender_full_name": "Gankra",
        "timestamp": 1647814821
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275990797\">said</a>:</p>\n<blockquote>\n<p>it'd be problematic if you implicitly lose the information about segment as a result of returning/passing in as an arugment a pointer.</p>\n</blockquote>\n<p>Worse still, you don't lose the segment, but you pass two near pointers and a size_t into memcpy, and memcpy reads out two far ptrs and an size_t.</p>",
        "id": 275990860,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814824
    },
    {
        "content": "<p>:3</p>",
        "id": 275990861,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814825
    },
    {
        "content": "<p>heh.</p>",
        "id": 275990880,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814872
    },
    {
        "content": "<p>And then you realise that you passed 0x8730:0x8770. 0x3333:0x0010, 0x3333 to memcpy.</p>",
        "id": 275990899,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814915
    },
    {
        "content": "<p>hahahaha.</p>",
        "id": 275990935,
        "sender_full_name": "Jubilee",
        "timestamp": 1647814924
    },
    {
        "content": "<p>Where <code>0x3333</code> is just a stand in for an uninitialized register, or stack slot.</p>",
        "id": 275990938,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647814955
    },
    {
        "content": "<p>I am growing into the notion of some kind of <code>Far&lt;T&gt;</code> for the niche cases where we have to cope with it.</p>",
        "id": 275991023,
        "sender_full_name": "Jubilee",
        "timestamp": 1647815088
    },
    {
        "content": "<p>at that point two distinct targets make most sense to me, just like there are targets for <code>x86_64-...-gnu</code> and <code>x86_64-...-gnu32</code>.</p>",
        "id": 275991027,
        "sender_full_name": "nagisa",
        "timestamp": 1647815094
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 275991034,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815104
    },
    {
        "content": "<p>Although technically it's 5 distinct targets.</p>",
        "id": 275991039,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815124
    },
    {
        "content": "<p>And yes, from our perspective these are different target tuples.</p>",
        "id": 275991041,
        "sender_full_name": "Jubilee",
        "timestamp": 1647815136
    },
    {
        "content": "<p><code>flat</code>, <code>near-data-near-fn</code> (<code>near-ptr</code>), <code>near-data-far-fn</code>, <code>far-data-near-fn</code>, <code>far-data-far-fn</code> (<code>far-ptr</code>)</p>",
        "id": 275991047,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815161
    },
    {
        "content": "<p>To a certain degree, a target feature is already \"a different target tuple but one you can interact with in a sufficiently well-defined way\".</p>",
        "id": 275991087,
        "sender_full_name": "Jubilee",
        "timestamp": 1647815190
    },
    {
        "content": "<p>isn't flat a subset of <code>near-ptr</code> given that all segments are made the same anyway?</p>",
        "id": 275991096,
        "sender_full_name": "nagisa",
        "timestamp": 1647815208
    },
    {
        "content": "<p>that is “near-ptr” code should work equally well where flat is expected.</p>",
        "id": 275991107,
        "sender_full_name": "nagisa",
        "timestamp": 1647815235
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"123586\">nagisa</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275991096\">said</a>:</p>\n<blockquote>\n<p>isn't flat a subset of <code>near-ptr</code> given that all segments are made the same anyway?</p>\n</blockquote>\n<p>From lccc's perspective, it would be a separate target with separate properties (Since it sets <code>farptrbits</code>=<code>nearptrbits</code>=<code>ptrbits</code>=16)</p>",
        "id": 275991108,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815241
    },
    {
        "content": "<p>Whereas <code>near-ptr</code> is <code>farptrbits</code>=32, <code>nearptrbits</code>=<code>ptrbits</code>=16.</p>",
        "id": 275991111,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815265
    },
    {
        "content": "<p>okay.</p>",
        "id": 275991113,
        "sender_full_name": "nagisa",
        "timestamp": 1647815276
    },
    {
        "content": "<p>(<code>flat</code> is \"there is no segmentation it's all the same\", vs. <code>near-tr</code> with \"There is segmentation, but you don't see it by default\")</p>",
        "id": 275991165,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815331
    },
    {
        "content": "<p>And yeah, to handle this, rust would probably want a <code>NearPtr&lt;T&gt;</code> and <code>FarPtr&lt;T&gt;</code>, which would be pure compiler magic basically.</p>",
        "id": 275991296,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815529
    },
    {
        "content": "<p>But logically be a <code>#[repr(transparent)] struct NearPtr&lt;T: ?Sized&gt;(u16,/*as-near*/&lt;&lt;T as Pointee&gt;::Metadata&gt;);</code> and <code>#[repr(transparent)] struct FarPtr&lt;T: ?Sized&gt;(u16,u16,/*as-far*/&lt;&lt;T as Pointee&gt;::Metadata&gt;);</code> resp.</p>",
        "id": 275991362,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815654
    },
    {
        "content": "<p>(At least, on 8086 non-flat)</p>",
        "id": 275991371,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815677
    },
    {
        "content": "<p>I suspect we would want to say <code>*const T</code> and <code>*mut T</code> are either <code>Far&lt;P&gt;</code> or <code>Near&lt;P&gt;</code> by default.</p>",
        "id": 275991382,
        "sender_full_name": "Jubilee",
        "timestamp": 1647815709
    },
    {
        "content": "<p>Yeah.</p>",
        "id": 275991394,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815744
    },
    {
        "content": "<p>On lccc (in xir), the wrappers would be translated to be transparent over <code>*near [const] T</code>/<code>*far [const] T</code>.</p>",
        "id": 275991451,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815802
    },
    {
        "content": "<p>(Hense the <code>#[repr(transparent)]</code> that isn't even valid)</p>",
        "id": 275991455,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647815823
    },
    {
        "content": "<p>...memcpy is a good question.</p>",
        "id": 275991530,
        "sender_full_name": "Jubilee",
        "timestamp": 1647815947
    },
    {
        "content": "<p>do you just<br>\nhave four different memcpys?</p>",
        "id": 275991538,
        "sender_full_name": "Jubilee",
        "timestamp": 1647815980
    },
    {
        "content": "<p>memcpy would be defined as <code>void* memcpy(void* dest,const void* src,size_t  s);</code>, whatever <code>void*</code> and <code>const void*</code> happen to be</p>",
        "id": 275991589,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647816036
    },
    {
        "content": "<p>so the answer is that you do indeed have 4 different versions of memcpy.</p>",
        "id": 275991600,
        "sender_full_name": "Jubilee",
        "timestamp": 1647816076
    },
    {
        "content": "<p>Well, two, but only one at a time. There probably could be a <code>__memcpy_far</code> for near-ptr mode that takes two <code>void* _far</code>s, but meh.</p>",
        "id": 275991612,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647816109
    },
    {
        "content": "<p>nod.</p>",
        "id": 275991653,
        "sender_full_name": "Jubilee",
        "timestamp": 1647816128
    },
    {
        "content": "<p>(Note that most of this impl work isn't done yet - the state of lccc's x86 codegen is x86_64-linux, and I think it does need some tearing up for 8086 support, but I need to tear it up anyways lest I keep reading locals into parameters by <code>mov ecx, eax; mov edi, ecx</code>)</p>",
        "id": 275991813,
        "sender_full_name": "Connor Horman",
        "timestamp": 1647816406
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"281757\">Jubilee</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/size_t.20!.3D.20uintptr_t.20!.3D.20ptraddr_t/near/275986320\">said</a>:</p>\n<blockquote>\n<p>...what's <code>size_t</code> on FreeDOS, pray tell</p>\n</blockquote>\n<p>FreeDOS requires all C code to compile under OpenWatcom, <code>size_t</code> is <code>unsigned int</code> there, <code>unsigned int</code> is <code>u16</code> for 16-bit targets (most FreeDOS programs) and <code>u32</code> for 32-bit targets (some &gt;i386 FreeDOS programs).</p>",
        "id": 275994319,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647820626
    },
    {
        "content": "<p>OpenWatcom supports huge pointers, which allow you to have objects larger than 64kiB, which is larger than <code>size_t</code> supports</p>",
        "id": 275994395,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647820790
    },
    {
        "content": "<p>do we need <em>multiple</em> <code>size_t</code>s?!</p>",
        "id": 275994549,
        "sender_full_name": "Jacob Lifshay",
        "timestamp": 1647820907
    },
    {
        "content": "<p>It looks like, in huge pointer mode, it uses i32s as its <code>ptrdiff_t</code>.</p>",
        "id": 275998587,
        "sender_full_name": "Jubilee",
        "timestamp": 1647827052
    }
]