[
    {
        "content": "<p>As I understand it, <code>UnsafeCell</code> bends the rules of aliasing. Normally a <code>&amp;T</code> to the outside of a structure assumes no mutable references exist to the inside of it. However with an <code>UnsafeCell</code> you can have a <code>&amp;UnsafeCell&lt;T&gt;</code> and a <code>&amp;mut T</code> coexist. Does the reciprocal of this also apply? Can you have a <code>&amp;mut UnsafeCell&lt;T&gt;</code> coexist with a <code>&amp;T</code>? Normally you can't have a mutable reference to the outside of a struct and a reference to the inside the whole thing is guaranteed unique.</p>",
        "id": 276732862,
        "sender_full_name": "Troy",
        "timestamp": 1648310818
    },
    {
        "content": "<p>You can trivially  do this, in fact, in purely safe code:</p>\n<div class=\"codehilite\" data-code-language=\"Rust\"><pre><span></span><code><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">UnsafeCell</span>::<span class=\"n\">new</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">x</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">z</span>: <span class=\"kp\">&amp;</span><span class=\"nc\">T</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">y</span><span class=\"p\">.</span><span class=\"n\">get_mut</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"c1\">// `z` and `y` point to the same location</span>\n</code></pre></div>\n<p>Of course, if you mean unrelated references, no, the SRO from the <code>&amp;T</code> would either invalidate or be invalidated by the <code>Unique</code>of the <code>&amp;mut UnsafeCell&lt;T&gt;</code>.</p>\n<p><code>UnsafeCell&lt;T&gt;</code> is only special wrt. <code>&amp;UnsafeCell&lt;T&gt;</code> (Shared Read/Write instead of Shared Read-only). <code>&amp;mut UnsafeCell&lt;T&gt;</code> is functionally the same as any other <code>&amp;mut U</code>, and the inner <code>T</code> is just covered by the same borrow stack item.</p>",
        "id": 276733138,
        "sender_full_name": "Connor Horman",
        "timestamp": 1648311160
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"421643\">@Troy</span> <code>&amp;mut UnsafeCell&lt;T&gt;</code> is the same as <code>&amp;mut T</code>, basically (and the docs should say that)</p>",
        "id": 276733387,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311488
    },
    {
        "content": "<p>we might want to have <code>UnsafeAlias</code> that is special for <code>&amp;mut</code> (and not <code>&amp;</code>), that seems to nicely complement <code>UnsafeCell</code> and might be useful for self-referential types</p>",
        "id": 276733400,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311527
    },
    {
        "content": "<p>Has that been proposed before?</p>",
        "id": 276733405,
        "sender_full_name": "Troy",
        "timestamp": 1648311544
    },
    {
        "content": "<p>indeed the docs do say that:</p>\n<blockquote>\n<p>Note that whilst mutating the contents of an &amp;UnsafeCell&lt;T&gt; (even while other &amp;UnsafeCell&lt;T&gt; references alias the cell) is ok (provided you enforce the above invariants some other way), it is still undefined behavior to have multiple &amp;mut UnsafeCell&lt;T&gt; aliases. That is, UnsafeCell is a wrapper designed to have a special interaction with shared accesses (i.e., through an &amp;UnsafeCell&lt;_&gt; reference); there is no magic whatsoever when dealing with exclusive accesses (e.g., through an &amp;mut UnsafeCell&lt;_&gt;): neither the cell nor the wrapped value may be aliased for the duration of that &amp;mut borrow. This is showcased by the .get_mut() accessor, which is a safe getter that yields a &amp;mut T.</p>\n</blockquote>",
        "id": 276733412,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311563
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421643\">Troy</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/aliasing.20and.20unsafe.20cell/near/276733405\">said</a>:</p>\n<blockquote>\n<p>Has that been proposed before?</p>\n</blockquote>\n<p><code>UnsafeAlias</code> you mean? yes in some UCG discussions around self-referential types and generators</p>",
        "id": 276733417,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311579
    },
    {
        "content": "<p>not sure which name it was given</p>",
        "id": 276733430,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311594
    },
    {
        "content": "<p>the main issues to check would be <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/148\">https://github.com/rust-lang/unsafe-code-guidelines/issues/148</a> and <a href=\"https://github.com/rust-lang/unsafe-code-guidelines/issues/194\">https://github.com/rust-lang/unsafe-code-guidelines/issues/194</a></p>",
        "id": 276733474,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311613
    },
    {
        "content": "<p>thanks. It seems the only way to opt of out of <code>noalias</code> is implementing <code>!UnPin</code> which is a pretty terrible hack</p>",
        "id": 276733499,
        "sender_full_name": "Troy",
        "timestamp": 1648311673
    },
    {
        "content": "<p>that's also not a guarantee</p>",
        "id": 276733514,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311710
    },
    {
        "content": "<p>basically currently only rustc-generated generators (<code>async</code> blocks) get to do this kind of stuff since they are in the compiler and can exploit compiler-private features like the <code>Unpin</code> and <code>noalias</code> interaction</p>",
        "id": 276733565,
        "sender_full_name": "RalfJ",
        "timestamp": 1648311747
    },
    {
        "content": "<p>right, just a work around until something official is made</p>",
        "id": 276733587,
        "sender_full_name": "Troy",
        "timestamp": 1648311772
    },
    {
        "content": "<p>The issue I am looking at is that I am trying to port some garbage collectors to rust. When collection starts we need to trace through all the root structures, which are mutable. But doing so is a vilolation of mutable aliasing (we are reading data that rust thinks is unique). Wanted to see if there was a way to make it workable without the <code>!UnPin</code> hack to prevent miscompilations.</p>",
        "id": 276733682,
        "sender_full_name": "Troy",
        "timestamp": 1648311909
    },
    {
        "content": "<p>why would Rust ever think that data behind a <code>Gc&lt;T&gt;</code> is unique?</p>",
        "id": 276734049,
        "sender_full_name": "RalfJ",
        "timestamp": 1648312436
    },
    {
        "content": "<p>How would you mark it as not unique? <code>Gc</code> is not a Std lib type.</p>",
        "id": 276734393,
        "sender_full_name": "Troy",
        "timestamp": 1648312909
    },
    {
        "content": "<p>Raw pointers are allowed to alias other raw pointers (if you do things right), the default assumption is that Gc&lt;T&gt; accesss would be based around a raw pointer and not a reference, so the compiler would know to not get smart about aliasing</p>",
        "id": 276734666,
        "sender_full_name": "Gankra",
        "timestamp": 1648313312
    },
    {
        "content": "<p>you may be interested in <a href=\"https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/\">https://manishearth.github.io/blog/2015/09/01/designing-a-gc-in-rust/</a></p>",
        "id": 276734685,
        "sender_full_name": "Gankra",
        "timestamp": 1648313369
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"421643\">Troy</span> <a href=\"#narrow/stream/136281-t-lang.2Fwg-unsafe-code-guidelines/topic/aliasing.20and.20unsafe.20cell/near/276734393\">said</a>:</p>\n<blockquote>\n<p>How would you mark it as not unique? <code>Gc</code> is not a Std lib type.</p>\n</blockquote>\n<p>don't use <code>Box</code> or <code>&amp;mut</code></p>",
        "id": 276734902,
        "sender_full_name": "RalfJ",
        "timestamp": 1648313634
    }
]